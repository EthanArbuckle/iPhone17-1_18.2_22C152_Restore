void sub_2224B8178(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  NSObject *v5;

  v3 = *(std::__shared_weak_count **)(v1 - 192);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  v4 = *(std::__shared_weak_count **)(v1 - 176);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  if (*(char *)(v1 - 145) < 0) {
    operator delete(*(void **)(v1 - 168));
  }
  v5 = *(NSObject **)(v1 - 144);
  if (v5) {
    dispatch_release(v5);
  }
  if (*(char *)(v1 - 113) < 0) {
    operator delete(*(void **)(v1 - 136));
  }
  _Unwind_Resume(exception_object);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 24));
  *(unsigned char *)(v1 + 112) = 1;
  v2 = *(std::__shared_weak_count **)(v1 + 104);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(void (****)(void, uint64_t))(v1 + 96);
      if (v5) {
        (**v5)(v5, 1);
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
}

void sub_2224B8274(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_2(uint64_t a1)
{
}

void QMIStewieCommandDriver::notReady(dispatch_queue_t *this)
{
  dispatch_assert_queue_V2(this[3]);
  *((unsigned char *)this + 112) = 0;
  v2 = (std::__shared_weak_count *)this[13];
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = (void (***)(void, void))this[12];
      if (v5) {
        (**v5)(v5, 0);
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
}

void sub_2224B8320(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_3(uint64_t a1)
{
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 24));
  v2 = *(std::__shared_weak_count **)(v1 + 104);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      uint64_t v5 = *(void *)(v1 + 96);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
}

void sub_2224B83C4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_5(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  int v4 = *((_DWORD *)a2 + 1);
  uint64_t v5 = *(NSObject **)(v3 + 40);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v4;
      LOWORD(v47) = 2080;
      *(void *)((char *)&v47 + 2) = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Received ServiceInfo indication with error code:0x%x (%s)", buf, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Received ServiceInfo indication", buf, 2u);
    }
    *(void *)buf = 0;
    long long v47 = 0uLL;
    int v48 = 0;
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(a2);
    uint64_t v8 = TlvValue;
    if (TlvValue)
    {
      int v9 = v7;
      *(void *)v49 = TlvValue;
      char v10 = tlv::parseV<sft::tlv::ConnectionStatus>((unint64_t *)v49, v7);
      if (*(void *)v49)
      {
        unsigned int v11 = (v10 - 1);
        if (v11 < 3) {
          unsigned int v12 = v11 + 1;
        }
        else {
          unsigned int v12 = 0;
        }
        *(_DWORD *)buf = v12;
      }
      else
      {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 1, v8, v9);
      }
    }
    uint64_t v13 = qmi::MessageBase::findTlvValue(a2);
    uint64_t v15 = v13;
    if (v13)
    {
      int v16 = v14;
      *(void *)v49 = v13;
      char v17 = tlv::parseV<sft::tlv::RegistrationStatus>((unint64_t *)v49, v14);
      if (*(void *)v49)
      {
        int v18 = 2 * (v17 == 1);
        if (!v17) {
          int v18 = 1;
        }
        *(_DWORD *)&buf[4] = v18;
      }
      else
      {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 2, v15, v16);
      }
    }
    uint64_t v19 = qmi::MessageBase::findTlvValue(a2);
    uint64_t v21 = v19;
    if (v19)
    {
      int v22 = v20;
      *(void *)v49 = v19;
      int v23 = tlv::parseV<sft::tlv::RSSI>((unint64_t *)v49, v20);
      if (*(void *)v49)
      {
        LODWORD(v47) = v23;
        BYTE4(v47) = 1;
      }
      else
      {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 16, v21, v22);
      }
    }
    uint64_t v24 = qmi::MessageBase::findTlvValue(a2);
    uint64_t v26 = v24;
    if (v24)
    {
      int v27 = v25;
      *(void *)v49 = v24;
      unsigned __int8 v28 = tlv::parseV<sft::tlv::CongestionStatus>((unint64_t *)v49, v25);
      if (*(void *)v49)
      {
        if (v28 <= 3u)
        {
          DWORD2(v47) = v28 + 1;
          BYTE12(v47) = 1;
        }
      }
      else
      {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 17, v26, v27);
      }
    }
    uint64_t v29 = qmi::MessageBase::findTlvValue(a2);
    uint64_t v31 = v29;
    if (v29)
    {
      int v32 = v30;
      *(void *)v49 = v29;
      unsigned __int8 v33 = tlv::parseV<sft::tlv::CurrentFMNum>((unint64_t *)v49, v30);
      if (*(void *)v49) {
        LOWORD(v48) = v33 | 0x100;
      }
      else {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 18, v31, v32);
      }
    }
    uint64_t v34 = qmi::MessageBase::findTlvValue(a2);
    uint64_t v36 = v34;
    if (v34)
    {
      int v37 = v35;
      uint64_t v45 = v34;
      int v38 = tlv::parseV<sft::tlv::BBUID>((unint64_t *)&v45, v35);
      if (v45)
      {
        int v39 = v38;
        v40 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v49 = 67109120;
          *(_DWORD *)&v49[4] = v39;
          _os_log_impl(&dword_22231A000, v40, OS_LOG_TYPE_DEFAULT, "#I BBUID: %u", v49, 8u);
        }
        *(_DWORD *)(v3 + 116) = v39;
        *(unsigned char *)(v3 + 120) = 1;
      }
      else
      {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 20, v36, v37);
      }
    }
    v41 = *(std::__shared_weak_count **)(v3 + 104);
    if (v41)
    {
      v42 = std::__shared_weak_count::lock(v41);
      if (v42)
      {
        v43 = v42;
        uint64_t v44 = *(void *)(v3 + 96);
        if (v44) {
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v44 + 16))(v44, buf);
        }
        std::__shared_weak_count::__release_shared[abi:ne180100](v43);
      }
    }
  }
}

void sub_2224B87D8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_6(uint64_t a1, qmi::MessageBase *a2)
{
  *(void *)&v35[15] = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  int v4 = *((_DWORD *)a2 + 1);
  uint64_t v5 = *(NSObject **)(v3 + 40);
  if (!v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Received DeactivationComplete indication", buf, 2u);
    }
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(a2);
    uint64_t v8 = TlvValue;
    if (TlvValue)
    {
      int v9 = v7;
      *(void *)buf = TlvValue;
      unsigned __int8 v10 = tlv::parseV<sft::tlv::DeactivationReason>((unint64_t *)buf, v7);
      if (*(void *)buf)
      {
        if (v10 <= 5u)
        {
          uint64_t v8 = dword_222581B6C[(char)v10];
          goto LABEL_10;
        }
      }
      else
      {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 1, v8, v9);
      }
      uint64_t v8 = 0;
    }
LABEL_10:
    __int16 v28 = 0;
    memset(buf, 0, sizeof(buf));
    uint64_t v11 = qmi::MessageBase::findTlvValue(a2);
    uint64_t v13 = v11;
    if (v11)
    {
      int v14 = v12;
      uint64_t v29 = v11;
      uint64_t v15 = tlv::parseV<sft::tlv::SharedSecredUsage>((unint64_t *)&v29, v12);
      *(void *)unsigned __int8 v33 = v15;
      char v34 = v16;
      if (v29)
      {
        __int16 v28 = (v15 == 0) | 0x100;
        __n128 __p = 0uLL;
        uint64_t v31 = 0;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&__p, &v33[1], (uint64_t)v35, 8uLL);
        std::optional<std::vector<unsigned char>>::operator=[abi:ne180100]<std::vector<unsigned char>,void>((uint64_t)buf, &__p);
        if (__p.n128_u64[0])
        {
          __p.n128_u64[1] = __p.n128_u64[0];
          operator delete((void *)__p.n128_u64[0]);
        }
      }
      else
      {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 16, v13, v14);
      }
    }
    __n128 __p = 0uLL;
    uint64_t v17 = qmi::MessageBase::findTlvValue(a2);
    uint64_t v19 = v17;
    if (v17)
    {
      int v20 = v18;
      *(void *)unsigned __int8 v33 = v17;
      unsigned int v21 = tlv::parseV<sft::tlv::CellularTXDeferTime>((unint64_t *)v33, v18);
      if (*(void *)v33)
      {
        __p.n128_u8[8] = 1;
        unint64_t v22 = v21;
LABEL_22:
        __p.n128_u64[0] = v22;
        uint64_t v24 = *(std::__shared_weak_count **)(v3 + 104);
        if (v24)
        {
          int v25 = std::__shared_weak_count::lock(v24);
          if (v25)
          {
            uint64_t v26 = v25;
            uint64_t v27 = *(void *)(v3 + 96);
            if (v27) {
              (*(void (**)(uint64_t, uint64_t, __int16 *, uint8_t *, __n128 *))(*(void *)v27 + 24))(v27, v8, &v28, buf, &__p);
            }
            std::__shared_weak_count::__release_shared[abi:ne180100](v26);
          }
        }
        if (buf[24])
        {
          if (*(void *)buf)
          {
            *(void *)&uint8_t buf[8] = *(void *)buf;
            operator delete(*(void **)buf);
          }
        }
        return;
      }
      ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 2, v19, v20);
    }
    int v23 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unsigned __int8 v33 = 0;
      _os_log_error_impl(&dword_22231A000, v23, OS_LOG_TYPE_ERROR, "[CellularTx] BB did not populate defer time tlv, will unlock using max time", v33, 2u);
    }
    __p.n128_u8[8] = 1;
    unint64_t v22 = 10000;
    goto LABEL_22;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v4;
    *(_WORD *)&uint8_t buf[8] = 2080;
    *(void *)&buf[10] = qmi::asString();
    _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Received DeactivationComplete indication with error code:0x%x (%s)", buf, 0x12u);
  }
}

void sub_2224B8B40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, char a18)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  if (a18)
  {
    if (__p) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(a1);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_7(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  int v4 = *((_DWORD *)a2 + 1);
  uint64_t v5 = *(NSObject **)(v3 + 40);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v31) = 67109378;
      HIDWORD(v31) = v4;
      __int16 v32 = 2080;
      uint64_t v33 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Received RequestStateChange indication with error code:0x%x (%s)", (uint8_t *)&v31, 0x12u);
    }
    return;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v31) = 0;
    _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Received RequestStateChange indication", (uint8_t *)&v31, 2u);
  }
  uint64_t TlvValue = qmi::MessageBase::findTlvValue(a2);
  uint64_t v8 = TlvValue;
  if (!TlvValue) {
    goto LABEL_10;
  }
  int v9 = v7;
  uint64_t v31 = TlvValue;
  char v10 = tlv::parseV<sft::tlv::RequestedAction>((unint64_t *)&v31, v7);
  if (!v31)
  {
    ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 1, v8, v9);
LABEL_10:
    int v11 = 0;
    goto LABEL_11;
  }
  if (v10) {
    int v11 = 2 * (v10 == 1);
  }
  else {
    int v11 = 1;
  }
LABEL_11:
  int v12 = *(std::__shared_weak_count **)(v3 + 104);
  if (v12)
  {
    uint64_t v13 = std::__shared_weak_count::lock(v12);
    if (v13)
    {
      int v14 = v13;
      uint64_t v15 = *(void *)(v3 + 96);
      if (!v15)
      {
LABEL_37:
        std::__shared_weak_count::__release_shared[abi:ne180100](v14);
        return;
      }
      if (v11 != 2)
      {
        if (v11 != 1)
        {
          if (!v11)
          {
            char v16 = *(NSObject **)(v3 + 40);
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v31) = 0;
              _os_log_error_impl(&dword_22231A000, v16, OS_LOG_TYPE_ERROR, "Received RequestStateChange indication for unsupported action", (uint8_t *)&v31, 2u);
            }
          }
          goto LABEL_37;
        }
        uint64_t v24 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v31) = 0;
          _os_log_impl(&dword_22231A000, v24, OS_LOG_TYPE_DEFAULT, "#I Received RequestStateChange indication for suspension", (uint8_t *)&v31, 2u);
        }
        uint64_t v25 = qmi::MessageBase::findTlvValue(a2);
        uint64_t v27 = v25;
        if (v25)
        {
          int v28 = v26;
          uint64_t v31 = v25;
          unsigned __int8 v29 = tlv::parseV<sft::tlv::SuspendReason>((unint64_t *)&v31, v26);
          if (v31)
          {
            if (v29 <= 2u)
            {
              uint64_t v30 = dword_222581B60[(char)v29];
LABEL_36:
              (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 40))(v15, v30);
              goto LABEL_37;
            }
          }
          else
          {
            ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 2, v27, v28);
          }
        }
        uint64_t v30 = 0;
        goto LABEL_36;
      }
      uint64_t v17 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v31) = 0;
        _os_log_impl(&dword_22231A000, v17, OS_LOG_TYPE_DEFAULT, "#I Received RequestStateChange indication for deactivation", (uint8_t *)&v31, 2u);
      }
      uint64_t v18 = qmi::MessageBase::findTlvValue(a2);
      uint64_t v20 = v18;
      if (v18)
      {
        int v21 = v19;
        uint64_t v31 = v18;
        unsigned __int8 v22 = tlv::parseV<sft::tlv::DeactivationReason>((unint64_t *)&v31, v19);
        if (v31)
        {
          if (v22 <= 5u)
          {
            uint64_t v23 = dword_222581B6C[(char)v22];
LABEL_33:
            (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 32))(v15, v23);
            goto LABEL_37;
          }
        }
        else
        {
          ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 3, v20, v21);
        }
      }
      uint64_t v23 = 0;
      goto LABEL_33;
    }
  }
}

void sub_2224B8F1C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_8(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  int v4 = *(_DWORD *)(a2 + 4);
  uint64_t v5 = *(NSObject **)(v3 + 40);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v10[0] = 67109378;
      v10[1] = v4;
      __int16 v11 = 2080;
      uint64_t v12 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Received SecurityConfigUpdateNeeded indication with error code:0x%x (%s)", (uint8_t *)v10, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10[0]) = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Received SecurityConfigUpdateNeeded indication", (uint8_t *)v10, 2u);
    }
    v6 = *(std::__shared_weak_count **)(v3 + 104);
    if (v6)
    {
      int v7 = std::__shared_weak_count::lock(v6);
      if (v7)
      {
        uint64_t v8 = v7;
        uint64_t v9 = *(void *)(v3 + 96);
        if (v9) {
          (*(void (**)(uint64_t))(*(void *)v9 + 48))(v9);
        }
        std::__shared_weak_count::__release_shared[abi:ne180100](v8);
      }
    }
  }
}

void sub_2224B9090(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_9(uint64_t a1, qmi::MessageBase *a2)
{
  v33[1] = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  int v4 = *((_DWORD *)a2 + 1);
  uint64_t v5 = *(NSObject **)(v3 + 40);
  if (!v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Received SecurityConfigUsage indication", buf, 2u);
    }
    int v26 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(a2);
    uint64_t v8 = TlvValue;
    if (TlvValue)
    {
      int v9 = v7;
      v30.n128_u64[0] = TlvValue;
      uint64_t v10 = tlv::parseV<sft::tlv::SharedSecredUsage>(v30.n128_u64, v7);
      *(void *)buf = v10;
      uint8_t buf[8] = v11;
      if (v30.n128_u64[0])
      {
        uint64_t v12 = v10;
        __p[0] = &v26;
        for (uint64_t i = 1; i != 9; ++i)
          std::back_insert_iterator<std::vector<unsigned char>>::operator=[abi:ne180100]((unint64_t **)__p, &buf[i]);
        *(_OWORD *)__n128 __p = 0u;
        long long v25 = 0u;
        if (v12)
        {
          uint64_t v14 = 0;
        }
        else
        {
          uint64_t v19 = qmi::MessageBase::findTlvValue(a2);
          uint64_t v21 = v19;
          if (v19)
          {
            int v22 = v20;
            uint64_t v29 = v19;
            memset(buf, 0, sizeof(buf));
            __n128 v23 = tlv::parseV<sft::tlv::GeneratedAppKey>((unint64_t *)&v29, v20, buf);
            if (v29)
            {
              __n128 v30 = 0uLL;
              uint64_t v31 = 0;
              std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&v30, buf, (uint64_t)v33, 0x20uLL);
              std::optional<std::vector<unsigned char>>::operator=[abi:ne180100]<std::vector<unsigned char>,void>((uint64_t)__p, &v30);
              if (v30.n128_u64[0])
              {
                v30.n128_u64[1] = v30.n128_u64[0];
                operator delete((void *)v30.n128_u64[0]);
              }
            }
            else
            {
              ((void (*)(void, uint64_t, uint64_t, void, __n128))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 2, v21, v22, v23);
            }
          }
          uint64_t v14 = 1;
        }
        goto LABEL_12;
      }
      ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 1, v8, v9);
    }
    uint64_t v14 = 0;
    *(_OWORD *)__n128 __p = 0u;
    long long v25 = 0u;
LABEL_12:
    uint64_t v15 = *(std::__shared_weak_count **)(v3 + 104);
    if (v15)
    {
      char v16 = std::__shared_weak_count::lock(v15);
      if (v16)
      {
        uint64_t v17 = v16;
        uint64_t v18 = *(void *)(v3 + 96);
        if (v18) {
          (*(void (**)(uint64_t, uint64_t, void **, void **))(*(void *)v18 + 56))(v18, v14, &v26, __p);
        }
        std::__shared_weak_count::__release_shared[abi:ne180100](v17);
      }
    }
    if (BYTE8(v25) && __p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v26)
    {
      uint64_t v27 = v26;
      operator delete(v26);
    }
    return;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v4;
    *(_WORD *)&uint8_t buf[8] = 2080;
    *(void *)&buf[10] = qmi::asString();
    _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Received SecurityConfigUsage indication with error code:0x%x (%s)", buf, 0x12u);
  }
}

void sub_2224B9374(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (a12 && __p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_10(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  int v4 = *((_DWORD *)a2 + 1);
  uint64_t v5 = *(NSObject **)(v3 + 40);
  if (!v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Received MessageTXStatus indication", buf, 2u);
    }
    CFUUIDRef v25 = 0;
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(a2);
    uint64_t v8 = TlvValue;
    if (TlvValue)
    {
      int v9 = v7;
      uint64_t v26 = TlvValue;
      uint64_t byte7 = tlv::parseV<sft::tlv::GUID>((unint64_t *)&v26, v7);
      if (v26)
      {
        CFUUIDRef v12 = CFUUIDCreateWithBytes((CFAllocatorRef)*MEMORY[0x263EFFB08], byte7, BYTE1(byte7), BYTE2(byte7), BYTE3(byte7), BYTE4(byte7), BYTE5(byte7), BYTE6(byte7), HIBYTE(byte7), byte8, BYTE1(byte8), BYTE2(byte8), BYTE3(byte8), BYTE4(byte8), BYTE5(byte8), BYTE6(byte8), HIBYTE(byte8));
        uint64_t v27 = 0;
        *(void *)buf = v25;
        CFUUIDRef v25 = v12;
        ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)buf);
        ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v27);
      }
      else
      {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 1, v8, v9);
      }
    }
    if (v25) {
      uint64_t v13 = ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::get;
    }
    else {
      uint64_t v13 = 0;
    }
    if (!v13)
    {
      int v20 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_22231A000, v20, OS_LOG_TYPE_ERROR, "Received MessageTXStatus indication without valid messageId", buf, 2u);
      }
      goto LABEL_24;
    }
    uint64_t v14 = qmi::MessageBase::findTlvValue(a2);
    uint64_t v16 = v14;
    if (v14)
    {
      int v17 = v15;
      *(void *)buf = v14;
      char v18 = tlv::parseV<sft::tlv::MessageSendResult>((unint64_t *)buf, v15);
      if (*(void *)buf)
      {
        BOOL v19 = v18 == 0;
LABEL_19:
        uint64_t v21 = *(std::__shared_weak_count **)(v3 + 104);
        if (v21)
        {
          int v22 = std::__shared_weak_count::lock(v21);
          if (v22)
          {
            __n128 v23 = v22;
            uint64_t v24 = *(void *)(v3 + 96);
            if (v24) {
              (*(void (**)(uint64_t, CFUUIDRef *, BOOL))(*(void *)v24 + 64))(v24, &v25, v19);
            }
            std::__shared_weak_count::__release_shared[abi:ne180100](v23);
          }
        }
LABEL_24:
        ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)&v25);
        return;
      }
      ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 2, v16, v17);
    }
    BOOL v19 = 0;
    goto LABEL_19;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v4;
    __int16 v29 = 2080;
    uint64_t v30 = qmi::asString();
    _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Received MessageTXStatus indication with error code:0x%x (%s)", buf, 0x12u);
  }
}

void sub_2224B96C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_11(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  int v4 = *((_DWORD *)a2 + 1);
  uint64_t v5 = *(NSObject **)(v3 + 40);
  if (v4)
  {
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v4;
    LOWORD(v30) = 2080;
    *(void *)((char *)&v30 + 2) = qmi::asString();
    int v22 = "Received MessageRX indication with error code:0x%x (%s)";
    __n128 v23 = v5;
    uint32_t v24 = 18;
LABEL_24:
    _os_log_error_impl(&dword_22231A000, v23, OS_LOG_TYPE_ERROR, v22, buf, v24);
    return;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Received MessageRX indication", buf, 2u);
  }
  uint64_t TlvValue = qmi::MessageBase::findTlvValue(a2);
  uint64_t v8 = TlvValue;
  if (!TlvValue)
  {
LABEL_21:
    uint64_t v21 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)buf = 0;
    int v22 = "Received MessageRX indication without messageId";
    __n128 v23 = v21;
    uint32_t v24 = 2;
    goto LABEL_24;
  }
  int v9 = v7;
  *(void *)buf = TlvValue;
  unsigned __int16 v10 = tlv::parseV<sft::tlv::BBMessageID>((unint64_t *)buf, v7);
  if (!*(void *)buf)
  {
    ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 1, v8, v9);
    goto LABEL_21;
  }
  unsigned __int16 v11 = v10;
  __n128 __p = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  CFUUIDRef v12 = (char *)qmi::MessageBase::findTlvValue(a2);
  uint64_t v14 = v12;
  if (v12)
  {
    int v15 = v13;
    uint64_t v28 = v12;
    *(void *)buf = 0;
    long long v30 = 0uLL;
    tlv::parseV<sft::tlv::Message>(&v28, v13, buf);
    uint64_t v16 = v28;
    if (v28) {
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&__p, *(char **)buf, (char *)v30, v30 - *(void *)buf);
    }
    if (*(void *)buf)
    {
      *(void *)&long long v30 = *(void *)buf;
      operator delete(*(void **)buf);
    }
    if (!v16) {
      ((void (*)(void, uint64_t, char *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 2, v14, v15);
    }
  }
  int v17 = *(std::__shared_weak_count **)(v3 + 104);
  if (v17)
  {
    char v18 = std::__shared_weak_count::lock(v17);
    if (v18)
    {
      BOOL v19 = v18;
      uint64_t v20 = *(void *)(v3 + 96);
      if (v20) {
        (*(void (**)(uint64_t, void, void **))(*(void *)v20 + 72))(v20, v11, &__p);
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v19);
    }
  }
  if (__p)
  {
    uint64_t v26 = __p;
    operator delete(__p);
  }
}

void sub_2224B9968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_12(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  int v4 = *((_DWORD *)a2 + 1);
  uint64_t v5 = *(NSObject **)(v3 + 40);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v16) = 67109378;
      HIDWORD(v16) = v4;
      __int16 v17 = 2080;
      uint64_t v18 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Received FileTransferStatus indication with error code:0x%x (%s)", (uint8_t *)&v16, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v16) = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Received FileTransferStatus indication", (uint8_t *)&v16, 2u);
    }
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(a2);
    BOOL v8 = TlvValue;
    if (TlvValue)
    {
      int v9 = v7;
      uint64_t v16 = TlvValue;
      unsigned __int16 v10 = tlv::parseV<sft::tlv::TransferStatus>((unint64_t *)&v16, v7);
      if (v16)
      {
        if (v10 == 13) {
          uint64_t v11 = 2;
        }
        else {
          uint64_t v11 = v10 == 12;
        }
        BOOL v8 = v10 < 0x100u;
      }
      else
      {
        ((void (*)(void, uint64_t, BOOL, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 1, v8, v9);
        uint64_t v11 = 0;
        BOOL v8 = 0;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    CFUUIDRef v12 = *(std::__shared_weak_count **)(v3 + 104);
    if (v12)
    {
      int v13 = std::__shared_weak_count::lock(v12);
      if (v13)
      {
        uint64_t v14 = v13;
        uint64_t v15 = *(void *)(v3 + 96);
        if (v15) {
          (*(void (**)(uint64_t, uint64_t, BOOL))(*(void *)v15 + 80))(v15, v11, v8);
        }
        std::__shared_weak_count::__release_shared[abi:ne180100](v14);
      }
    }
  }
}

void sub_2224B9B8C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_13(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  int v4 = *((_DWORD *)a2 + 1);
  uint64_t v5 = *(NSObject **)(v3 + 40);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v4;
      *(_WORD *)&uint8_t buf[8] = 2080;
      *(void *)&buf[10] = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Received ServiceOutageInfo indication with error code:0x%x (%s)", buf, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Received ServiceOutageInfo indication", buf, 2u);
    }
    memset(buf, 0, 32);
    uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
    BOOL v8 = TlvValue;
    if (TlvValue)
    {
      int v9 = v7;
      __n128 __p = TlvValue;
      int v10 = tlv::parseV<sft::tlv::ServiceOutageInfoIdentifier>((unint64_t *)&__p, v7);
      if (__p) {
        *(_DWORD *)buf = v10;
      }
      else {
        ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 1, v8, v9);
      }
    }
    uint64_t v11 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
    int v13 = v11;
    if (v11)
    {
      int v14 = v12;
      uint64_t v43 = 0;
      uint64_t v44 = v11;
      __n128 __p = 0;
      v42 = 0;
      tlv::parseV<sft::tlv::SatelliteOutages>(&v44, v12, (uint64_t *)&__p);
      uint64_t v15 = v44;
      uint64_t v16 = __p;
      if (v44)
      {
        __int16 v17 = v42;
        if (__p != v42)
        {
          uint64_t v36 = v44;
          int v37 = v14;
          int v38 = v13;
          int v39 = a2;
          uint64_t v40 = v3;
          uint64_t v18 = 0;
          do
          {
            char v19 = *(unsigned char *)v16;
            uint64_t v20 = v16[1];
            uint64_t v21 = v16[2];
            if ((unint64_t)v18 >= *(void *)&buf[24])
            {
              __n128 v23 = *(void **)&buf[8];
              unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v18 - *(void *)&buf[8]) >> 3);
              unint64_t v25 = v24 + 1;
              if (v24 + 1 > 0xAAAAAAAAAAAAAAALL) {
                std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
              }
              if (0x5555555555555556 * ((uint64_t)(*(void *)&buf[24] - *(void *)&buf[8]) >> 3) > v25) {
                unint64_t v25 = 0x5555555555555556 * ((uint64_t)(*(void *)&buf[24] - *(void *)&buf[8]) >> 3);
              }
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[24] - *(void *)&buf[8]) >> 3) >= 0x555555555555555) {
                unint64_t v26 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v26 = v25;
              }
              if (v26)
              {
                if (v26 > 0xAAAAAAAAAAAAAAALL) {
                  std::__throw_bad_array_new_length[abi:ne180100]();
                }
                uint64_t v27 = (char *)operator new(24 * v26);
              }
              else
              {
                uint64_t v27 = 0;
              }
              uint64_t v28 = &v27[24 * v24];
              *uint64_t v28 = v19;
              *((void *)v28 + 1) = v20;
              *((void *)v28 + 2) = v21;
              __int16 v29 = v28;
              if (v18 != v23)
              {
                do
                {
                  long long v30 = *(_OWORD *)(v18 - 3);
                  *((void *)v29 - 1) = *(v18 - 1);
                  *(_OWORD *)(v29 - 24) = v30;
                  v29 -= 24;
                  v18 -= 3;
                }
                while (v18 != v23);
                uint64_t v18 = *(void **)&buf[8];
              }
              uint64_t v31 = &v27[24 * v26];
              int v22 = v28 + 24;
              *(void *)&uint8_t buf[8] = v29;
              *(void *)&buf[16] = v28 + 24;
              *(void *)&buf[24] = v31;
              if (v18) {
                operator delete(v18);
              }
            }
            else
            {
              *(unsigned char *)uint64_t v18 = v19;
              int v22 = v18 + 3;
              v18[1] = v20;
              v18[2] = v21;
            }
            *(void *)&buf[16] = v22;
            v16 += 3;
            uint64_t v18 = v22;
          }
          while (v16 != v17);
          uint64_t v3 = v40;
          uint64_t v16 = __p;
          int v13 = v38;
          a2 = v39;
          uint64_t v15 = v36;
          int v14 = v37;
        }
      }
      if (v16)
      {
        v42 = v16;
        operator delete(v16);
      }
      if (!v15) {
        ((void (*)(void, uint64_t, unsigned __int8 *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 2, v13, v14);
      }
    }
    __int16 v32 = *(std::__shared_weak_count **)(v3 + 104);
    if (v32)
    {
      uint64_t v33 = std::__shared_weak_count::lock(v32);
      if (v33)
      {
        uint64_t v34 = v33;
        uint64_t v35 = *(void *)(v3 + 96);
        if (v35) {
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v35 + 88))(v35, buf);
        }
        std::__shared_weak_count::__release_shared[abi:ne180100](v34);
      }
    }
    if (*(void *)&buf[8])
    {
      *(void *)&buf[16] = *(void *)&buf[8];
      operator delete(*(void **)&buf[8]);
    }
  }
}

void sub_2224B9F38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_14(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  int v4 = *((_DWORD *)a2 + 1);
  uint64_t v5 = *(NSObject **)(v3 + 40);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v4;
      LOWORD(v20) = 2080;
      *(void *)((char *)&v20 + 2) = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Received SaveBroadcastInfoBlob indication with error code:0x%x (%s)", buf, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Received SaveBroadcastInfoBlob indication", buf, 2u);
    }
    __n128 __p = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t TlvValue = (char *)qmi::MessageBase::findTlvValue(a2);
    BOOL v8 = TlvValue;
    if (TlvValue)
    {
      int v9 = v7;
      uint64_t v18 = TlvValue;
      *(void *)buf = 0;
      long long v20 = 0uLL;
      tlv::parseV<sft::tlv::BroadcastInfoBlob>(&v18, v7, buf);
      int v10 = v18;
      if (v18) {
        std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&__p, *(char **)buf, (char *)v20, v20 - *(void *)buf);
      }
      if (*(void *)buf)
      {
        *(void *)&long long v20 = *(void *)buf;
        operator delete(*(void **)buf);
      }
      if (!v10) {
        ((void (*)(void, uint64_t, char *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 1, v8, v9);
      }
    }
    uint64_t v11 = *(std::__shared_weak_count **)(v3 + 104);
    if (v11)
    {
      int v12 = std::__shared_weak_count::lock(v11);
      if (v12)
      {
        int v13 = v12;
        uint64_t v14 = *(void *)(v3 + 96);
        if (v14) {
          (*(void (**)(uint64_t, void **))(*(void *)v14 + 96))(v14, &__p);
        }
        std::__shared_weak_count::__release_shared[abi:ne180100](v13);
      }
    }
    if (__p)
    {
      uint64_t v16 = __p;
      operator delete(__p);
    }
  }
}

void sub_2224BA170(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t QMIStewieCommandDriver::start(dispatch_queue_t *this)
{
  dispatch_assert_queue_V2(this[3]);
  if (!this[10]) {
    __TUAssertTrigger();
  }
  v2 = this[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I Start", v4, 2u);
  }
  return qmi::Client::start((qmi::Client *)(this + 8));
}

void QMIStewieCommandDriver::stop(dispatch_queue_t *this)
{
  dispatch_assert_queue_V2(this[3]);
  if (!this[10]) {
    __TUAssertTrigger();
  }
  v2 = this[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I Stop", v4, 2u);
  }
  *((unsigned char *)this + 112) = 0;
  qmi::Client::stop((qmi::Client *)(this + 8));
  qmi::Client::release((qmi::Client *)(this + 8));
  uint64_t v3 = (std::__shared_weak_count *)this[13];
  this[12] = 0;
  this[13] = 0;
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void QMIStewieCommandDriver::getCapabilities(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v6 = a1 + 8;
    int v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v7, OS_LOG_TYPE_ERROR, "Failed to execute GetCapabilities. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL,StewieHWSupportType)>::__value_func[abi:ne180100]((uint64_t)buf, a2);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0>(v6);
  }
  memset(v8, 0, sizeof(v8));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v8);
  uint64_t v15 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL,StewieHWSupportType)>::__value_func[abi:ne180100]((uint64_t)v16, a2);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  int v4 = (std::__shared_weak_count *)operator new(0x40uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CEE98;
  v4[1].__vftable = v15;
  std::__function::__value_func<void ()(BOOL,StewieHWSupportType)>::__value_func[abi:ne180100]((uint64_t)&v4[1].__shared_owners_, (uint64_t)v16);
  uint64_t v9 = a1 + 64;
  uint64_t v10 = QMIServiceMsg::create();
  int v11 = 25000;
  uint64_t v12 = 0;
  int v13 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v18 = 1174405120;
  char v19 = ___ZN22QMIStewieCommandDriver4sendIN3sft15GetCapabilities7RequestEZNS_15getCapabilitiesEONSt3__18functionIFvb19StewieHWSupportTypeEEEE3__1EEvRKT_OT0__block_invoke;
  long long v20 = &__block_descriptor_tmp_72_8;
  uint64_t v21 = v4 + 1;
  int v22 = v4;
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft15GetCapabilities8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_2646103F0;
  aBlock[4] = buf;
  uint64_t v5 = _Block_copy(aBlock);
  int v13 = v5;
  if (v10)
  {
    qmi::Client::send();
    uint64_t v5 = v13;
  }
  if (v5) {
    _Block_release(v5);
  }
  if (v22) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  std::__function::__value_func<void ()(BOOL,StewieHWSupportType)>::~__value_func[abi:ne180100](v16);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v8);
}

void sub_2224BA550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 72);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  std::__function::__value_func<void ()(BOOL,StewieHWSupportType)>::~__value_func[abi:ne180100](v14);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::sendS4ConfigSegment(uint64_t a1, char *a2, unint64_t a3, unint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7)
{
  uint64_t v74 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (a5 >= a6)
  {
    __TUAssertTrigger();
    if (!a6) {
      __TUAssertTrigger();
    }
  }
  if (a3 >= a4) {
    __TUAssertTrigger();
  }
  if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a2 + 2) - *((void *)a2 + 1)) >> 3) < a4) {
    __TUAssertTrigger();
  }
  if (!*(unsigned char *)(a1 + 112))
  {
    v52 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__dst) = 0;
      _os_log_error_impl(&dword_22231A000, v52, OS_LOG_TYPE_ERROR, "Failed to execute SetS4Config. Client is not ready", (uint8_t *)&__dst, 2u);
    }
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&__dst, a7);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0>(a1 + 8);
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v56 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v14 = (const void **)__p[1];
  uint64_t v15 = (const void **)v56;
  if (__p[1] != (void *)v56)
  {
    while (*((unsigned char *)*v14 + 8) != 1)
    {
      if (++v14 == (const void **)v56) {
        goto LABEL_16;
      }
    }
  }
  if (v14 == (const void **)v56) {
LABEL_16:
  }
    operator new();
  if (!v16) {
    __cxa_bad_cast();
  }
  uint64_t v17 = v16 + 16;
  *uint64_t v17 = *a2;
  if (a3 >= a4) {
    goto LABEL_57;
  }
  __int16 v53 = a6;
  uint64_t v54 = a7;
  uint64_t v18 = (char **)(v16 + 24);
  do
  {
    uint64_t v19 = *((void *)a2 + 1);
    long long v20 = (char *)(v19 + 56 * a3);
    long long v72 = 0u;
    memset(v73, 0, 26);
    long long v70 = 0u;
    long long v71 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long __dst = 0u;
    long long v67 = 0u;
    uint64_t v21 = (unsigned __int8 *)(v20 + 8);
    if (v20[31] < 0) {
      uint64_t v22 = *((void *)v20 + 2);
    }
    else {
      uint64_t v22 = v20[31];
    }
    char v23 = *v20;
    if (v22 != 69) {
      __TUAssertTrigger();
    }
    uint64_t v25 = v19 + 56 * a3;
    unint64_t v24 = (void *)(v25 + 32);
    LODWORD(v25) = *(char *)(v25 + 55);
    if ((v25 & 0x80000000) != 0) {
      uint64_t v25 = v24[1];
    }
    else {
      uint64_t v25 = v25;
    }
    if (v25 != 69) {
      __TUAssertTrigger();
    }
    if (((char)v21[23] & 0x80000000) == 0)
    {
      size_t v26 = v21[23];
      if (!v21[23]) {
        goto LABEL_32;
      }
LABEL_31:
      memcpy(&__dst, v21, v26);
      goto LABEL_32;
    }
    uint64_t v36 = v21;
    uint64_t v21 = *(unsigned __int8 **)v21;
    size_t v26 = *((void *)v36 + 1);
    if (v26) {
      goto LABEL_31;
    }
LABEL_32:
    if ((*((char *)v24 + 23) & 0x80000000) == 0)
    {
      size_t v27 = *((unsigned __int8 *)v24 + 23);
      if (!*((unsigned char *)v24 + 23)) {
        goto LABEL_35;
      }
LABEL_34:
      memcpy((char *)&v70 + 5, v24, v27);
      goto LABEL_35;
    }
    int v37 = v24;
    unint64_t v24 = (void *)*v24;
    size_t v27 = v37[1];
    if (v27) {
      goto LABEL_34;
    }
LABEL_35:
    unint64_t v28 = *((void *)v17 + 2);
    unint64_t v29 = *((void *)v17 + 3);
    if (v28 >= v29)
    {
      uint64_t v31 = 0x3AEF6CA970586723 * (v28 - (void)*v18);
      unint64_t v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) > 0x1D77B654B82C339) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v33 = 0x3AEF6CA970586723 * (v29 - (void)*v18);
      if (2 * v33 > v32) {
        unint64_t v32 = 2 * v33;
      }
      if (v33 >= 0xEBBDB2A5C1619CLL) {
        unint64_t v34 = 0x1D77B654B82C339;
      }
      else {
        unint64_t v34 = v32;
      }
      if (v34) {
        uint64_t v35 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<sft::tlv::TargetLineSet>>((uint64_t)(v17 + 24), v34);
      }
      else {
        uint64_t v35 = 0;
      }
      int v38 = &v35[139 * v31];
      *int v38 = v23;
      *(_OWORD *)(v38 + 65) = v70;
      *(_OWORD *)(v38 + 49) = v69;
      *(_OWORD *)(v38 + 33) = v68;
      *(_OWORD *)(v38 + 17) = v67;
      *(_OWORD *)(v38 + 123) = *(_OWORD *)((char *)v73 + 10);
      *(_OWORD *)(v38 + 113) = v73[0];
      *(_OWORD *)(v38 + 97) = v72;
      *(_OWORD *)(v38 + 81) = v71;
      *(_OWORD *)(v38 + 1) = __dst;
      uint64_t v40 = (char *)*((void *)v17 + 1);
      int v39 = (char *)*((void *)v17 + 2);
      v41 = v38;
      if (v39 != v40)
      {
        do
        {
          *(_OWORD *)(v41 - 139) = *(_OWORD *)(v39 - 139);
          long long v42 = *(_OWORD *)(v39 - 123);
          long long v43 = *(_OWORD *)(v39 - 107);
          long long v44 = *(_OWORD *)(v39 - 91);
          *(_OWORD *)(v41 - 75) = *(_OWORD *)(v39 - 75);
          *(_OWORD *)(v41 - 91) = v44;
          *(_OWORD *)(v41 - 107) = v43;
          *(_OWORD *)(v41 - 123) = v42;
          long long v45 = *(_OWORD *)(v39 - 59);
          long long v46 = *(_OWORD *)(v39 - 43);
          long long v47 = *(_OWORD *)(v39 - 27);
          *((_OWORD *)v41 - 1) = *((_OWORD *)v39 - 1);
          *(_OWORD *)(v41 - 27) = v47;
          *(_OWORD *)(v41 - 43) = v46;
          *(_OWORD *)(v41 - 59) = v45;
          v41 -= 139;
          v39 -= 139;
        }
        while (v39 != v40);
        int v39 = *v18;
      }
      long long v30 = v38 + 139;
      *((void *)v17 + 1) = v41;
      *((void *)v17 + 2) = v38 + 139;
      *((void *)v17 + 3) = &v35[139 * v34];
      if (v39) {
        operator delete(v39);
      }
    }
    else
    {
      *(unsigned char *)unint64_t v28 = v23;
      *(_OWORD *)(v28 + 81) = v71;
      *(_OWORD *)(v28 + 97) = v72;
      *(_OWORD *)(v28 + 113) = v73[0];
      *(_OWORD *)(v28 + 123) = *(_OWORD *)((char *)v73 + 10);
      *(_OWORD *)(v28 + 17) = v67;
      *(_OWORD *)(v28 + 33) = v68;
      *(_OWORD *)(v28 + 49) = v69;
      *(_OWORD *)(v28 + 65) = v70;
      *(_OWORD *)(v28 + 1) = __dst;
      long long v30 = (char *)(v28 + 139);
    }
    *((void *)v17 + 2) = v30;
    ++a3;
  }
  while (a3 != a4);
  uint64_t v15 = (const void **)v56;
  a7 = v54;
  LOWORD(a6) = v53;
LABEL_57:
  for (uint64_t i = (const void **)__p[1]; ; ++i)
  {
    if (i == v15) {
      goto LABEL_64;
    }
    if (*((unsigned char *)*i + 8) == 17) {
      break;
    }
  }
  if (i == v15) {
LABEL_64:
  }
    operator new();
  if (!v49) {
    __cxa_bad_cast();
  }
  v49[5] = a5;
  v49[6] = a6;
  v63 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v64, a7);
  LOWORD(v65) = a5;
  HIWORD(v65) = a6;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v50 = (std::__shared_weak_count *)operator new(0x48uLL);
  v50->__shared_owners_ = 0;
  v50->__shared_weak_owners_ = 0;
  v50->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CEFB8;
  v50[1].__vftable = v63;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v50[1].__shared_owners_, (uint64_t)v64);
  LODWORD(v50[2].__shared_weak_owners_) = v65;
  uint64_t v57 = a1 + 64;
  uint64_t v58 = QMIServiceMsg::create();
  int v59 = 25000;
  uint64_t v60 = 0;
  v61 = 0;
  *(void *)&long long __dst = MEMORY[0x263EF8330];
  *((void *)&__dst + 1) = 1174405120;
  *(void *)&long long v67 = ___ZN22QMIStewieCommandDriver4sendIN3sft11SetS4Config7RequestEZNS_19sendS4ConfigSegmentERK20StewieTargetLineSetsmmttONSt3__18functionIFvbEEEE3__3EEvRKT_OT0__block_invoke;
  *((void *)&v67 + 1) = &__block_descriptor_tmp_81_6;
  *(void *)&long long v68 = v50 + 1;
  *((void *)&v68 + 1) = v50;
  atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
  aBlock[3] = &unk_264610418;
  aBlock[4] = &__dst;
  v51 = _Block_copy(aBlock);
  v61 = v51;
  if (v58)
  {
    qmi::Client::send();
    v51 = v61;
  }
  if (v51) {
    _Block_release(v51);
  }
  if (*((void *)&v68 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v68 + 1));
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v50);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v64);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224BAFAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,std::__shared_weak_count *a40)
{
  if (a40) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a40);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a19);
  std::__shared_weak_count::__release_shared[abi:ne180100](v41);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v40);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::activate(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, char a9, uint64_t a10)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v40 = a1 + 8;
    v41 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v41, OS_LOG_TYPE_ERROR, "Failed to execute Activation request. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100]((uint64_t)buf, a10);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0>(v40);
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v43 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v18 = (const void **)__p[1];
  uint64_t v17 = (const void **)v43;
  uint64_t v19 = (const void **)__p[1];
  if (__p[1] != (void *)v43)
  {
    uint64_t v19 = (const void **)__p[1];
    while (*((unsigned char *)*v19 + 8) != 1)
    {
      if (++v19 == (const void **)v43) {
        goto LABEL_10;
      }
    }
  }
  if (v19 == (const void **)v43) {
LABEL_10:
  }
    operator new();
  if (!v20) {
    __cxa_bad_cast();
  }
  v20[9] = (a2 - 5) < 0xFFFFFFFE;
  while (1)
  {
    if (v18 == v17) {
      goto LABEL_17;
    }
    if (*((unsigned char *)*v18 + 8) == 2) {
      break;
    }
    ++v18;
  }
  if (v18 == v17) {
LABEL_17:
  }
    operator new();
  if (!v21) {
    __cxa_bad_cast();
  }
  v21[9] = 2 * (a2 == 5);
  for (uint64_t i = (const void **)__p[1]; ; ++i)
  {
    if (i == v17) {
      goto LABEL_24;
    }
    if (*((unsigned char *)*i + 8) == 3) {
      break;
    }
  }
  if (i == v17) {
LABEL_24:
  }
    operator new();
  if (!v23) {
    __cxa_bad_cast();
  }
  v23[9] = 0;
  if (*(void *)(a7 + 8) - *(void *)a7 != 8) {
    __TUAssertTrigger();
  }
  if (*(void *)(a7 + 32) - *(void *)(a7 + 24) != 32) {
    __TUAssertTrigger();
  }
  unint64_t v24 = qmi::MutableMessageBase::getTLV<sft::tlv::SecurityCredentials>((uint64_t)__p, 4);
  uint64_t v25 = v24;
  uint64_t v26 = *(void *)(a7 + 8);
  if (v26 != *(void *)a7) {
    memmove(v24, *(const void **)a7, v26 - *(void *)a7);
  }
  size_t v27 = *(unsigned char **)(a7 + 24);
  unint64_t v28 = *(unsigned char **)(a7 + 32);
  if (v28 != v27) {
    memmove(v25 + 8, v27, v28 - v27);
  }
  unint64_t v29 = qmi::MutableMessageBase::getTLV<sft::tlv::EARFCN>((uint64_t)__p, 5);
  long long v30 = v29;
  if (v29 != (char *)a4) {
    std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>(v29, *(char **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 2);
  }
  if (v30 != (char *)a4) {
    std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>(v30 + 24, *(char **)(a4 + 24), *(void *)(a4 + 32), (uint64_t)(*(void *)(a4 + 32) - *(void *)(a4 + 24)) >> 2);
  }
  uint64_t v31 = qmi::MutableMessageBase::getTLV<sft::tlv::LocationData>((uint64_t)__p, 6);
  unint64_t v33 = (const void **)__p[1];
  unint64_t v32 = (const void **)v43;
  unint64_t v34 = (const void **)__p[1];
  if (__p[1] != (void *)v43)
  {
    unint64_t v34 = (const void **)__p[1];
    while (*((unsigned char *)*v34 + 8) != 7)
    {
      if (++v34 == (const void **)v43) {
        goto LABEL_45;
      }
    }
  }
  if (v34 == (const void **)v43) {
LABEL_45:
  }
    operator new();
  if (!v35) {
    __cxa_bad_cast();
  }
  v35[9] = 1;
  while (1)
  {
    if (v33 == v32) {
      goto LABEL_52;
    }
    if (*((unsigned char *)*v33 + 8) == 17) {
      break;
    }
    ++v33;
  }
  if (v33 == v32) {
LABEL_52:
  }
    operator new();
  if (!v36) {
    __cxa_bad_cast();
  }
  v36[9] = a9;
  if (*a8)
  {
    int v37 = qmi::MutableMessageBase::getTLV<sft::tlv::HeatMapData>((uint64_t)__p, 16);
  }
  uint64_t v50 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100]((uint64_t)v51, a10);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  int v38 = (std::__shared_weak_count *)operator new(0x40uLL);
  v38->__shared_owners_ = 0;
  v38->__shared_weak_owners_ = 0;
  v38->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF308;
  v38[1].__vftable = v50;
  std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100]((uint64_t)&v38[1].__shared_owners_, (uint64_t)v51);
  uint64_t v44 = a1 + 64;
  uint64_t v45 = QMIServiceMsg::create();
  int v46 = 25000;
  uint64_t v47 = 0;
  int v48 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v53 = 1174405120;
  uint64_t v54 = ___ZN22QMIStewieCommandDriver4sendIN3sft10Activation7RequestEZNS_8activateE19StewieRequestReason24StewieSPSEnvironmentTypeRK22StewieProvisioningDataRK18StewieTimeFreqDataRK18StewieLocationDataRK25StewieSecurityCredentialsRKNSt3__110shared_ptrIK13StewieHeatMapEEbONSI_8functionIFvbONSI_8optionalINSI_6chrono8durationIxNSI_5ratioILl1ELl1000EEEEEEEEEEE4__10EEvRKT_OT0__block_invoke;
  v55 = &__block_descriptor_tmp_84_7;
  long long v56 = v38 + 1;
  uint64_t v57 = v38;
  atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft10Activation8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_264610440;
  aBlock[4] = buf;
  int v39 = _Block_copy(aBlock);
  int v48 = v39;
  if (v45)
  {
    qmi::Client::send();
    int v39 = v48;
  }
  if (v39) {
    _Block_release(v39);
  }
  if (v57) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v57);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v38);
  std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::~__value_func[abi:ne180100](v51);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224BBC50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  int v7 = *(std::__shared_weak_count **)(v5 - 104);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va1);
  std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::~__value_func[abi:ne180100](v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::deactivate(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v11 = a1 + 8;
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v12, OS_LOG_TYPE_ERROR, "Failed to execute Deactivation request. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0>(v11);
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v14 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v6 = (const void **)__p[1];
  if (__p[1] != (void *)v14)
  {
    while (*((unsigned char *)*v6 + 8) != 1)
    {
      if (++v6 == (const void **)v14) {
        goto LABEL_9;
      }
    }
  }
  if (v6 == (const void **)v14) {
LABEL_9:
  }
    operator new();
  if (!v7) {
    __cxa_bad_cast();
  }
  if (a2 > 0x10) {
    char v8 = 3;
  }
  else {
    char v8 = byte_222581B84[a2];
  }
  v7[9] = v8;
  uint64_t v21 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v22, a3);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v9 = (std::__shared_weak_count *)operator new(0x40uLL);
  v9->__shared_owners_ = 0;
  v9->__shared_weak_owners_ = 0;
  v9->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF3D8;
  v9[1].__vftable = v21;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v9[1].__shared_owners_, (uint64_t)v22);
  uint64_t v15 = a1 + 64;
  uint64_t v16 = QMIServiceMsg::create();
  int v17 = 25000;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v24 = 1174405120;
  uint64_t v25 = ___ZN22QMIStewieCommandDriver4sendIN3sft12Deactivation7RequestEZNS_10deactivateE16StewieExitReasonONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke;
  uint64_t v26 = &__block_descriptor_tmp_87_5;
  size_t v27 = v9 + 1;
  unint64_t v28 = v9;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
  aBlock[3] = &unk_264610418;
  aBlock[4] = buf;
  uint64_t v10 = _Block_copy(aBlock);
  uint64_t v19 = v10;
  if (v16)
  {
    qmi::Client::send();
    uint64_t v10 = v19;
  }
  if (v10) {
    _Block_release(v10);
  }
  if (v28) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v28);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v22);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224BC1E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 88);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::setConcurrencyConfig(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v10 = a1 + 8;
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v11, OS_LOG_TYPE_ERROR, "Failed to execute SetConcurrencyConfig request. Client is not ready. Will retry later", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0>(v10);
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v13 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v6 = (const void **)__p[1];
  if (__p[1] != (void *)v13)
  {
    while (*((unsigned char *)*v6 + 8) != 1)
    {
      if (++v6 == (const void **)v13) {
        goto LABEL_9;
      }
    }
  }
  if (v6 == (const void **)v13) {
LABEL_9:
  }
    operator new();
  if (!v7) {
    __cxa_bad_cast();
  }
  v7[9] = a2;
  long long v20 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v21, a3);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  char v8 = (std::__shared_weak_count *)operator new(0x40uLL);
  v8->__shared_owners_ = 0;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF4A8;
  v8[1].__vftable = v20;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v8[1].__shared_owners_, (uint64_t)v21);
  uint64_t v14 = a1 + 64;
  uint64_t v15 = QMIServiceMsg::create();
  int v16 = 25000;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v23 = 1174405120;
  uint64_t v24 = ___ZN22QMIStewieCommandDriver4sendIN3sft20SetConcurrencyConfig7RequestEZNS_20setConcurrencyConfigEbONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke;
  uint64_t v25 = &__block_descriptor_tmp_89_3;
  uint64_t v26 = v8 + 1;
  size_t v27 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
  aBlock[3] = &unk_264610418;
  aBlock[4] = buf;
  uint64_t v9 = _Block_copy(aBlock);
  uint64_t v18 = v9;
  if (v15)
  {
    qmi::Client::send();
    uint64_t v9 = v18;
  }
  if (v9) {
    _Block_release(v9);
  }
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v21);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224BC738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 88);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::suspend(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v14 = a1 + 8;
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v15, OS_LOG_TYPE_ERROR, "Failed to execute Suspend. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0>(v14);
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v17 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v6 = (const void **)__p[1];
  int v7 = (const void **)v17;
  if (__p[1] != (void *)v17)
  {
    while (*((unsigned char *)*v6 + 8) != 1)
    {
      if (++v6 == (const void **)v17) {
        goto LABEL_9;
      }
    }
  }
  if (v6 == (const void **)v17) {
LABEL_9:
  }
    operator new();
  if (!v8) {
    __cxa_bad_cast();
  }
  unsigned int v9 = 0x10002u >> (8 * a2);
  if (a2 >= 4) {
    LOBYTE(v9) = 2;
  }
  v8[9] = v9;
  for (uint64_t i = (const void **)__p[1]; ; ++i)
  {
    if (i == v7) {
      goto LABEL_19;
    }
    if (*((unsigned char *)*i + 8) == 2) {
      break;
    }
  }
  if (i == v7) {
LABEL_19:
  }
    operator new();
  if (!v11) {
    __cxa_bad_cast();
  }
  v11[9] = 0;
  uint64_t v24 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v25, a3);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v12 = (std::__shared_weak_count *)operator new(0x40uLL);
  v12->__shared_owners_ = 0;
  v12->__shared_weak_owners_ = 0;
  v12->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF5C8;
  v12[1].__vftable = v24;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v12[1].__shared_owners_, (uint64_t)v25);
  uint64_t v18 = a1 + 64;
  uint64_t v19 = QMIServiceMsg::create();
  int v20 = 25000;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v27 = 1174405120;
  uint64_t v28 = ___ZN22QMIStewieCommandDriver4sendIN3sft7Suspend7RequestEZNS_7suspendE19StewieSuspendReasonONSt3__18functionIFvbEEEE3__3EEvRKT_OT0__block_invoke;
  uint64_t v29 = &__block_descriptor_tmp_91_4;
  long long v30 = v12 + 1;
  uint64_t v31 = v12;
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
  aBlock[3] = &unk_264610418;
  aBlock[4] = buf;
  long long v13 = _Block_copy(aBlock);
  uint64_t v22 = v13;
  if (v19)
  {
    qmi::Client::send();
    long long v13 = v22;
  }
  if (v13) {
    _Block_release(v13);
  }
  if (v31) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v31);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v25);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224BCE28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 88);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::resume(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char **a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v20 = a1 + 8;
    uint64_t v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v21, OS_LOG_TYPE_ERROR, "Failed to execute Resume. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a7);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>(v20);
  }
  memset(v22, 0, sizeof(v22));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v22);
  uint64_t v14 = qmi::MutableMessageBase::getTLV<sft::tlv::LocationData>((uint64_t)v22, 1);
  uint64_t v15 = qmi::MutableMessageBase::getTLV<sft::tlv::EARFCN>((uint64_t)v22, 2);
  uint64_t v16 = v15;
  if (v15 != (char *)a4) {
    std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>(v15, *(char **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 2);
  }
  if (v16 != (char *)a4) {
    std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>(v16 + 24, *(char **)(a4 + 24), *(void *)(a4 + 32), (uint64_t)(*(void *)(a4 + 32) - *(void *)(a4 + 24)) >> 2);
  }
  if (*a6)
  {
    long long v17 = qmi::MutableMessageBase::getTLV<sft::tlv::HeatMapData>((uint64_t)v22, 16);
  }
  uint64_t v29 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v30, a7);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v18 = (std::__shared_weak_count *)operator new(0x40uLL);
  v18->__shared_owners_ = 0;
  v18->__shared_weak_owners_ = 0;
  v18->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF648;
  v18[1].__vftable = v29;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v18[1].__shared_owners_, (uint64_t)v30);
  uint64_t v23 = a1 + 64;
  uint64_t v24 = QMIServiceMsg::create();
  int v25 = 25000;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v32 = 1174405120;
  unint64_t v33 = ___ZN22QMIStewieCommandDriver4sendIN3sft6Resume7RequestEZNS_6resumeERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNSt3__16vectorIhNSD_9allocatorIhEEEERKNSD_10shared_ptrIK13StewieHeatMapEEONSD_8functionIFvbEEEE3__4EEvRKT_OT0__block_invoke;
  unint64_t v34 = &__block_descriptor_tmp_93_4;
  uint64_t v35 = v18 + 1;
  uint64_t v36 = v18;
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
  aBlock[3] = &unk_264610418;
  aBlock[4] = buf;
  uint64_t v19 = _Block_copy(aBlock);
  uint64_t v27 = v19;
  if (v24)
  {
    qmi::Client::send();
    uint64_t v19 = v27;
  }
  if (v19) {
    _Block_release(v19);
  }
  if (v36) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v36);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v30);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v22);
}

void sub_2224BD28C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 88);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v14);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::initiateRegistration(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v6, OS_LOG_TYPE_ERROR, "Failed to execute InitiateRegistration. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a2);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0>(a1 + 8);
  }
  memset(v7, 0, sizeof(v7));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v7);
  uint64_t v14 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v15, a2);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  int v4 = (std::__shared_weak_count *)operator new(0x40uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF6C8;
  v4[1].__vftable = v14;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v4[1].__shared_owners_, (uint64_t)v15);
  uint64_t v8 = a1 + 64;
  uint64_t v9 = QMIServiceMsg::create();
  int v10 = 25000;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v17 = 1174405120;
  uint64_t v18 = ___ZN22QMIStewieCommandDriver4sendIN3sft20InitiateRegistration7RequestEZNS_20initiateRegistrationEONSt3__18functionIFvbEEEE3__1EEvRKT_OT0__block_invoke;
  uint64_t v19 = &__block_descriptor_tmp_95_3;
  uint64_t v20 = v4 + 1;
  uint64_t v21 = v4;
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
  aBlock[3] = &unk_264610418;
  aBlock[4] = buf;
  uint64_t v5 = _Block_copy(aBlock);
  uint64_t v12 = v5;
  if (v9)
  {
    qmi::Client::send();
    uint64_t v5 = v12;
  }
  if (v5) {
    _Block_release(v5);
  }
  if (v21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v7);
}

void sub_2224BD648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 72);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v14);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::requestServiceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v6 = a1 + 8;
    int v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v7, OS_LOG_TYPE_ERROR, "Failed to execute GetServiceInfo. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a2);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0>(v6);
  }
  memset(v8, 0, sizeof(v8));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v8);
  uint64_t v15 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v16, a2);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  int v4 = (std::__shared_weak_count *)operator new(0x40uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF748;
  v4[1].__vftable = v15;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v4[1].__shared_owners_, (uint64_t)v16);
  uint64_t v9 = a1 + 64;
  uint64_t v10 = QMIServiceMsg::create();
  int v11 = 25000;
  uint64_t v12 = 0;
  long long v13 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v18 = 1174405120;
  uint64_t v19 = ___ZN22QMIStewieCommandDriver4sendIN3sft14GetServiceInfo7RequestEZNS_18requestServiceInfoEONSt3__18functionIFvbEEEE3__1EEvRKT_OT0__block_invoke;
  uint64_t v20 = &__block_descriptor_tmp_97_3;
  uint64_t v21 = v4 + 1;
  uint64_t v22 = v4;
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
  aBlock[3] = &unk_264610418;
  aBlock[4] = buf;
  uint64_t v5 = _Block_copy(aBlock);
  long long v13 = v5;
  if (v10)
  {
    qmi::Client::send();
    uint64_t v5 = v13;
  }
  if (v5) {
    _Block_release(v5);
  }
  if (v22) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v16);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v8);
}

void sub_2224BD9FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 72);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v14);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::setSecurityConfig(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v13 = a1 + 8;
    uint64_t v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v14, OS_LOG_TYPE_ERROR, "Failed to execute SetSecurityConfig. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0>(v13);
  }
  if (*(void *)(a2 + 8) - *(void *)a2 != 8) {
    __TUAssertTrigger();
  }
  if (*(void *)(a2 + 32) - *(void *)(a2 + 24) != 32) {
    __TUAssertTrigger();
  }
  memset(v15, 0, sizeof(v15));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v15);
  uint64_t v6 = qmi::MutableMessageBase::getTLV<sft::tlv::SecurityCredentials>((uint64_t)v15, 1);
  int v7 = v6;
  uint64_t v8 = *(void *)(a2 + 8);
  if (v8 != *(void *)a2) {
    memmove(v6, *(const void **)a2, v8 - *(void *)a2);
  }
  uint64_t v9 = *(unsigned char **)(a2 + 24);
  uint64_t v10 = *(unsigned char **)(a2 + 32);
  if (v10 != v9) {
    memmove(v7 + 8, v9, v10 - v9);
  }
  uint64_t v22 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v23, a3);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  int v11 = (std::__shared_weak_count *)operator new(0x40uLL);
  v11->__shared_owners_ = 0;
  v11->__shared_weak_owners_ = 0;
  v11->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF7C8;
  v11[1].__vftable = v22;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v11[1].__shared_owners_, (uint64_t)v23);
  uint64_t v16 = a1 + 64;
  uint64_t v17 = QMIServiceMsg::create();
  int v18 = 25000;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v25 = 1174405120;
  uint64_t v26 = ___ZN22QMIStewieCommandDriver4sendIN3sft17SetSecurityConfig7RequestEZNS_17setSecurityConfigERK25StewieSecurityCredentialsONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke;
  uint64_t v27 = &__block_descriptor_tmp_99_6;
  uint64_t v28 = v11 + 1;
  uint64_t v29 = v11;
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
  aBlock[3] = &unk_264610418;
  aBlock[4] = buf;
  uint64_t v12 = _Block_copy(aBlock);
  uint64_t v20 = v12;
  if (v17)
  {
    qmi::Client::send();
    uint64_t v12 = v20;
  }
  if (v12) {
    _Block_release(v12);
  }
  if (v29) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v29);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v23);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v15);
}

void sub_2224BDE24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  int v18 = *(std::__shared_weak_count **)(v16 - 72);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v14);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::updateOrientation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v15 = a1 + 8;
    uint64_t v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v16, OS_LOG_TYPE_ERROR, "Failed to execute UpdateDeviceOrientation. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0>(v15);
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v18 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v6 = (const void **)__p[1];
  int v7 = (const void **)v18;
  uint64_t v8 = (const void **)__p[1];
  if (__p[1] != (void *)v18)
  {
    uint64_t v8 = (const void **)__p[1];
    while (*((unsigned char *)*v8 + 8) != 1)
    {
      if (++v8 == (const void **)v18) {
        goto LABEL_10;
      }
    }
  }
  if (v8 == (const void **)v18) {
LABEL_10:
  }
    operator new();
  if (!v9) {
    __cxa_bad_cast();
  }
  v9[9] = *(unsigned char *)(a2 + 8);
  while (1)
  {
    if (v6 == v7) {
      goto LABEL_17;
    }
    if (*((unsigned char *)*v6 + 8) == 2) {
      break;
    }
    ++v6;
  }
  if (v6 == v7) {
LABEL_17:
  }
    operator new();
  if (!v10) {
    __cxa_bad_cast();
  }
  v10[9] = *(unsigned char *)(a2 + 9);
  for (uint64_t i = (const void **)__p[1]; ; ++i)
  {
    if (i == v7) {
      goto LABEL_24;
    }
    if (*((unsigned char *)*i + 8) == 3) {
      break;
    }
  }
  if (i == v7) {
LABEL_24:
  }
    operator new();
  if (!v12) {
    __cxa_bad_cast();
  }
  v12[3] = (float)*(int *)(a2 + 12);
  uint64_t v25 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v26, a3);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v13 = (std::__shared_weak_count *)operator new(0x40uLL);
  v13->__shared_owners_ = 0;
  v13->__shared_weak_owners_ = 0;
  v13->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF938;
  v13[1].__vftable = v25;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v13[1].__shared_owners_, (uint64_t)v26);
  uint64_t v19 = a1 + 64;
  uint64_t v20 = QMIServiceMsg::create();
  int v21 = 25000;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v28 = 1174405120;
  uint64_t v29 = ___ZN22QMIStewieCommandDriver4sendIN3sft23UpdateDeviceOrientation7RequestEZNS_17updateOrientationERK27StewieDeviceOrientationDataONSt3__18functionIFvbEEEE3__4EEvRKT_OT0__block_invoke;
  uint64_t v30 = &__block_descriptor_tmp_101_6;
  uint64_t v31 = v13 + 1;
  uint64_t v32 = v13;
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
  aBlock[3] = &unk_264610418;
  aBlock[4] = buf;
  uint64_t v14 = _Block_copy(aBlock);
  uint64_t v23 = v14;
  if (v20)
  {
    qmi::Client::send();
    uint64_t v14 = v23;
  }
  if (v14) {
    _Block_release(v14);
  }
  if (v32) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v32);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v26);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224BE690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  long long v18 = *(std::__shared_weak_count **)(v16 - 88);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::sendMessage(uint64_t a1, CFUUIDRef *a2, char **a3, int a4, uint64_t a5)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v20 = a1 + 8;
    int v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v21, OS_LOG_TYPE_ERROR, "Failed to execute MessageTX. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a5);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0>(v20);
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v23 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v10 = (CFUUIDBytes *)qmi::MutableMessageBase::getTLV<sft::tlv::GUID>((uint64_t)__p, 1);
  *uint64_t v10 = CFUUIDGetUUIDBytes(*a2);
  int v11 = (const void **)__p[1];
  uint64_t v12 = (const void **)v23;
  if (__p[1] != (void *)v23)
  {
    while (*((unsigned char *)*v11 + 8) != 2)
    {
      if (++v11 == (const void **)v23) {
        goto LABEL_9;
      }
    }
  }
  if (v11 == (const void **)v23) {
LABEL_9:
  }
    operator new();
  if (!v13) {
    __cxa_bad_cast();
  }
  uint64_t v14 = (char **)(v13 + 16);
  if (v14 != a3)
  {
    std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v14, *a3, a3[1], a3[1] - *a3);
    uint64_t v12 = (const void **)v23;
  }
  for (uint64_t i = (const void **)__p[1]; ; ++i)
  {
    if (i == v12) {
      goto LABEL_19;
    }
    if (*((unsigned char *)*i + 8) == 16) {
      break;
    }
  }
  if (i == v12) {
LABEL_19:
  }
    operator new();
  if (!v16) {
    __cxa_bad_cast();
  }
  if (a4 == 1) {
    int v17 = 1;
  }
  else {
    int v17 = 2;
  }
  if (a4 == 2) {
    int v17 = 0;
  }
  v16[3] = v17;
  uint64_t v30 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v31, a5);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  long long v18 = (std::__shared_weak_count *)operator new(0x40uLL);
  v18->__shared_owners_ = 0;
  v18->__shared_weak_owners_ = 0;
  v18->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFAA8;
  v18[1].__vftable = v30;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v18[1].__shared_owners_, (uint64_t)v31);
  uint64_t v24 = a1 + 64;
  uint64_t v25 = QMIServiceMsg::create();
  int v26 = 25000;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v33 = 1174405120;
  unint64_t v34 = ___ZN22QMIStewieCommandDriver4sendIN3sft9MessageTX7RequestEZNS_11sendMessageERKN3ctu2cf11CFSharedRefIK8__CFUUIDEERKNSt3__16vectorIhNSC_9allocatorIhEEEE24StewieTrafficQosPriorityONSC_8functionIFvbEEEE3__4EEvRKT_OT0__block_invoke;
  uint64_t v35 = &__block_descriptor_tmp_103_5;
  uint64_t v36 = v18 + 1;
  uint64_t v37 = v18;
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
  aBlock[3] = &unk_264610418;
  aBlock[4] = buf;
  uint64_t v19 = _Block_copy(aBlock);
  uint64_t v28 = v19;
  if (v25)
  {
    qmi::Client::send();
    uint64_t v19 = v28;
  }
  if (v19) {
    _Block_release(v19);
  }
  if (v37) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v37);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v31);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224BEE44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  long long v18 = *(std::__shared_weak_count **)(v16 - 104);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::cancelMessageTx(uint64_t a1, CFUUIDRef *a2, uint64_t a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v11 = a1 + 8;
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v12, OS_LOG_TYPE_ERROR, "Failed to execute CancelMessageTX. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0>(v11);
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v14 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v6 = (const void **)__p[1];
  if (__p[1] != (void *)v14)
  {
    while (*((unsigned char *)*v6 + 8) != 1)
    {
      if (++v6 == (const void **)v14) {
        goto LABEL_9;
      }
    }
  }
  if (v6 == (const void **)v14) {
LABEL_9:
  }
    operator new();
  if (!v7) {
    __cxa_bad_cast();
  }
  v7[9] = 0;
  uint64_t v8 = (CFUUIDBytes *)qmi::MutableMessageBase::getTLV<sft::tlv::GUID>((uint64_t)__p, 16);
  *uint64_t v8 = CFUUIDGetUUIDBytes(*a2);
  int v21 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v22, a3);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v9 = (std::__shared_weak_count *)operator new(0x40uLL);
  v9->__shared_owners_ = 0;
  v9->__shared_weak_owners_ = 0;
  v9->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFB78;
  v9[1].__vftable = v21;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v9[1].__shared_owners_, (uint64_t)v22);
  uint64_t v15 = a1 + 64;
  uint64_t v16 = QMIServiceMsg::create();
  int v17 = 25000;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v24 = 1174405120;
  uint64_t v25 = ___ZN22QMIStewieCommandDriver4sendIN3sft15CancelMessageTX7RequestEZNS_15cancelMessageTxERKN3ctu2cf11CFSharedRefIK8__CFUUIDEEONSt3__18functionIFvbEEEE3__3EEvRKT_OT0__block_invoke;
  int v26 = &__block_descriptor_tmp_105_8;
  uint64_t v27 = v9 + 1;
  uint64_t v28 = v9;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
  aBlock[3] = &unk_264610418;
  aBlock[4] = buf;
  uint64_t v10 = _Block_copy(aBlock);
  uint64_t v19 = v10;
  if (v16)
  {
    qmi::Client::send();
    uint64_t v10 = v19;
  }
  if (v10) {
    _Block_release(v10);
  }
  if (v28) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v28);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v22);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224BF430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 88);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::ackReceivedMessage(uint64_t a1, __int16 a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v10 = a1 + 8;
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v11, OS_LOG_TYPE_ERROR, "Failed to execute MessageRXAck. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0>(v10);
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v13 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v6 = (const void **)__p[1];
  if (__p[1] != (void *)v13)
  {
    while (*((unsigned char *)*v6 + 8) != 1)
    {
      if (++v6 == (const void **)v13) {
        goto LABEL_9;
      }
    }
  }
  if (v6 == (const void **)v13) {
LABEL_9:
  }
    operator new();
  if (!v7) {
    __cxa_bad_cast();
  }
  v7[5] = a2;
  uint64_t v20 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v21, a3);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v8 = (std::__shared_weak_count *)operator new(0x40uLL);
  v8->__shared_owners_ = 0;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFC48;
  v8[1].__vftable = v20;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v8[1].__shared_owners_, (uint64_t)v21);
  uint64_t v14 = a1 + 64;
  uint64_t v15 = QMIServiceMsg::create();
  int v16 = 25000;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v23 = 1174405120;
  uint64_t v24 = ___ZN22QMIStewieCommandDriver4sendIN3sft12MessageRXAck7RequestEZNS_18ackReceivedMessageEtONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke;
  uint64_t v25 = &__block_descriptor_tmp_107_2;
  int v26 = v8 + 1;
  uint64_t v27 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
  aBlock[3] = &unk_264610418;
  aBlock[4] = buf;
  uint64_t v9 = _Block_copy(aBlock);
  uint64_t v18 = v9;
  if (v15)
  {
    qmi::Client::send();
    uint64_t v9 = v18;
  }
  if (v9) {
    _Block_release(v9);
  }
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v21);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224BF98C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 88);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::sendFileSegment(uint64_t a1, int a2, unsigned int a3, unsigned int a4, char **a5, uint64_t a6)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*a5 == a5[1]) {
    __TUAssertTrigger();
  }
  if (a3 < a4 || (__TUAssertTrigger(), a4))
  {
    if (a2) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  __TUAssertTrigger();
  if (!a2) {
LABEL_6:
  }
    __TUAssertTrigger();
LABEL_7:
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v19 = a1 + 8;
    uint64_t v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = a3;
      LOWORD(v33) = 1024;
      *(_DWORD *)((char *)&v33 + 2) = a4 - 1;
      _os_log_error_impl(&dword_22231A000, v20, OS_LOG_TYPE_ERROR, "Failed to execute SendFile (%d/%d). Client is not ready", buf, 0xEu);
    }
    std::__function::__value_func<void ()(BOOL,unsigned short)>::__value_func[abi:ne180100]((uint64_t)buf, a6);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_0>(v19);
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v22 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v12 = *a5;
  long long v13 = a5[1];
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  uint64_t v14 = (const void **)__p[1];
  if (__p[1] != (void *)v22)
  {
    while (*((unsigned char *)*v14 + 8) != 1)
    {
      if (++v14 == (const void **)v22) {
        goto LABEL_15;
      }
    }
  }
  if (v14 == (const void **)v22) {
LABEL_15:
  }
    operator new();
  if (!v15) {
    __cxa_bad_cast();
  }
  if (a2 == 1) {
    char v16 = 12;
  }
  else {
    char v16 = -1;
  }
  if (a2 == 2) {
    char v16 = 13;
  }
  v15[16] = v16;
  v15[17] = 0;
  *((_WORD *)v15 + 9) = a3;
  *((_WORD *)v15 + 10) = a4;
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((void *)v15 + 3, v12, v13, v13 - v12);
  if (v12) {
    operator delete(v12);
  }
  uint64_t v29 = (std::__shared_weak_count_vtbl *)a1;
  LOWORD(v30) = a3;
  HIWORD(v30) = a4;
  std::__function::__value_func<void ()(BOOL,unsigned short)>::__value_func[abi:ne180100]((uint64_t)v31, a6);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v17 = (std::__shared_weak_count *)operator new(0x48uLL);
  v17->__shared_owners_ = 0;
  v17->__shared_weak_owners_ = 0;
  v17->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFD18;
  v17[1].__vftable = v29;
  LODWORD(v17[1].__shared_owners_) = v30;
  std::__function::__value_func<void ()(BOOL,unsigned short)>::__value_func[abi:ne180100]((uint64_t)&v17[1].__shared_weak_owners_, (uint64_t)v31);
  uint64_t v23 = a1 + 64;
  uint64_t v24 = QMIServiceMsg::create();
  int v25 = 25000;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v33 = 1174405120;
  unint64_t v34 = ___ZN22QMIStewieCommandDriver4sendIN3sft8SendFile7RequestEZNS_15sendFileSegmentE14StewieFileTypettONSt3__16vectorIhNS5_9allocatorIhEEEEONS5_8functionIFvbtEEEE3__2EEvRKT_OT0__block_invoke;
  uint64_t v35 = &__block_descriptor_tmp_109_2;
  uint64_t v36 = v17 + 1;
  uint64_t v37 = v17;
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft8SendFile8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_264610468;
  aBlock[4] = buf;
  uint64_t v18 = _Block_copy(aBlock);
  uint64_t v27 = v18;
  if (v24)
  {
    qmi::Client::send();
    uint64_t v18 = v27;
  }
  if (v18) {
    _Block_release(v18);
  }
  if (v37) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v37);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  std::__function::__value_func<void ()(BOOL,unsigned short)>::~__value_func[abi:ne180100](v31);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224BFFD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v17 = *(std::__shared_weak_count **)(v15 - 104);
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a13);
  std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  std::__function::__value_func<void ()(BOOL,unsigned short)>::~__value_func[abi:ne180100](v14);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::sendGPSDataUpdate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char **a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v20 = a1 + 8;
    int v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v21, OS_LOG_TYPE_ERROR, "Failed to execute GPSDataUpdate. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a7);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>(v20);
  }
  memset(v22, 0, sizeof(v22));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v22);
  uint64_t v14 = qmi::MutableMessageBase::getTLV<sft::tlv::LocationData>((uint64_t)v22, 1);
  uint64_t v15 = qmi::MutableMessageBase::getTLV<sft::tlv::EARFCN>((uint64_t)v22, 16);
  char v16 = v15;
  if (v15 != (char *)a4) {
    std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>(v15, *(char **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 2);
  }
  if (v16 != (char *)a4) {
    std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>(v16 + 24, *(char **)(a4 + 24), *(void *)(a4 + 32), (uint64_t)(*(void *)(a4 + 32) - *(void *)(a4 + 24)) >> 2);
  }
  if (*a6)
  {
    uint64_t v17 = qmi::MutableMessageBase::getTLV<sft::tlv::HeatMapData>((uint64_t)v22, 17);
  }
  uint64_t v29 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v30, a7);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v18 = (std::__shared_weak_count *)operator new(0x40uLL);
  v18->__shared_owners_ = 0;
  v18->__shared_weak_owners_ = 0;
  v18->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFD98;
  v18[1].__vftable = v29;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v18[1].__shared_owners_, (uint64_t)v30);
  uint64_t v23 = a1 + 64;
  uint64_t v24 = QMIServiceMsg::create();
  int v25 = 25000;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v32 = 1174405120;
  uint64_t v33 = ___ZN22QMIStewieCommandDriver4sendIN3sft13GPSDataUpdate7RequestEZNS_17sendGPSDataUpdateERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNSt3__16vectorIhNSD_9allocatorIhEEEERKNSD_10shared_ptrIK13StewieHeatMapEEONSD_8functionIFvbEEEE3__4EEvRKT_OT0__block_invoke;
  unint64_t v34 = &__block_descriptor_tmp_112_2;
  uint64_t v35 = v18 + 1;
  uint64_t v36 = v18;
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
  aBlock[3] = &unk_264610418;
  aBlock[4] = buf;
  uint64_t v19 = _Block_copy(aBlock);
  uint64_t v27 = v19;
  if (v24)
  {
    qmi::Client::send();
    uint64_t v19 = v27;
  }
  if (v19) {
    _Block_release(v19);
  }
  if (v36) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v36);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v30);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v22);
}

void sub_2224C0440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 88);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v14);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::getCellularTxDeferTime(uint64_t a1, char **a2, uint64_t a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v11 = a1 + 8;
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v12, OS_LOG_TYPE_ERROR, "Failed to execute GetCellularTxDeferTime. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0>(v11);
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v14 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v6 = (const void **)__p[1];
  if (__p[1] != (void *)v14)
  {
    while (*((unsigned char *)*v6 + 8) != 1)
    {
      if (++v6 == (const void **)v14) {
        goto LABEL_9;
      }
    }
  }
  if (v6 == (const void **)v14) {
LABEL_9:
  }
    operator new();
  if (!v7) {
    __cxa_bad_cast();
  }
  uint64_t v8 = (char **)(v7 + 16);
  if (v8 != a2) {
    std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v8, *a2, a2[1], a2[1] - *a2);
  }
  int v21 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100]((uint64_t)v22, a3);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v9 = (std::__shared_weak_count *)operator new(0x40uLL);
  v9->__shared_owners_ = 0;
  v9->__shared_weak_owners_ = 0;
  v9->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFE68;
  v9[1].__vftable = v21;
  std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100]((uint64_t)&v9[1].__shared_owners_, (uint64_t)v22);
  uint64_t v15 = a1 + 64;
  uint64_t v16 = QMIServiceMsg::create();
  int v17 = 25000;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v24 = 1174405120;
  int v25 = ___ZN22QMIStewieCommandDriver4sendIN3sft22GetCellularTxDeferTime7RequestEZNS_22getCellularTxDeferTimeERKNSt3__16vectorIhNS4_9allocatorIhEEEEONS4_8functionIFvbONS4_8optionalINS4_6chrono8durationIxNS4_5ratioILl1ELl1000EEEEEEEEEEE3__2EEvRKT_OT0__block_invoke;
  uint64_t v26 = &__block_descriptor_tmp_114_4;
  uint64_t v27 = v9 + 1;
  uint64_t v28 = v9;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft22GetCellularTxDeferTime8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_264610490;
  aBlock[4] = buf;
  uint64_t v10 = _Block_copy(aBlock);
  uint64_t v19 = v10;
  if (v16)
  {
    qmi::Client::send();
    uint64_t v10 = v19;
  }
  if (v10) {
    _Block_release(v10);
  }
  if (v28) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v28);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::~__value_func[abi:ne180100](v22);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224C09B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 88);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::~__value_func[abi:ne180100](v15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::~QMIStewieCommandDriver(QMIStewieCommandDriver *this)
{
  *(void *)this = &unk_26D4CEC90;
  v2 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  qmi::Client::~Client((QMIStewieCommandDriver *)((char *)this + 64));
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  MEMORY[0x223C99A30]((char *)this + 40);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable((void *)this + 1);

  StewieCommandDriver::~StewieCommandDriver(this);
}

{
  uint64_t vars8;

  QMIStewieCommandDriver::~QMIStewieCommandDriver(this);

  JUMPOUT(0x223C9A950);
}

void QMIStewieCommandDriver::setBroadcastInfoBlob(uint64_t a1, char **a2, uint64_t a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 112))
  {
    uint64_t v11 = a1 + 8;
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_22231A000, v12, OS_LOG_TYPE_ERROR, "Failed to execute SetBroadcastInfoBlob. Client is not ready", buf, 2u);
    }
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
    ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0>(v11);
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v14 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v6 = (const void **)__p[1];
  if (__p[1] != (void *)v14)
  {
    while (*((unsigned char *)*v6 + 8) != 1)
    {
      if (++v6 == (const void **)v14) {
        goto LABEL_9;
      }
    }
  }
  if (v6 == (const void **)v14) {
LABEL_9:
  }
    operator new();
  if (!v7) {
    __cxa_bad_cast();
  }
  uint64_t v8 = (char **)(v7 + 16);
  if (v8 != a2) {
    std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v8, *a2, a2[1], a2[1] - *a2);
  }
  int v21 = (std::__shared_weak_count_vtbl *)a1;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v22, a3);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v9 = (std::__shared_weak_count *)operator new(0x40uLL);
  v9->__shared_owners_ = 0;
  v9->__shared_weak_owners_ = 0;
  v9->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFF38;
  v9[1].__vftable = v21;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v9[1].__shared_owners_, (uint64_t)v22);
  uint64_t v15 = a1 + 64;
  uint64_t v16 = QMIServiceMsg::create();
  int v17 = 25000;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  *(void *)buf = MEMORY[0x263EF8330];
  uint64_t v24 = 1174405120;
  int v25 = ___ZN22QMIStewieCommandDriver4sendIN3sft20SetBroadcastInfoBlob7RequestEZNS_20setBroadcastInfoBlobERKNSt3__16vectorIhNS4_9allocatorIhEEEEONS4_8functionIFvbEEEE3__2EEvRKT_OT0__block_invoke;
  uint64_t v26 = &__block_descriptor_tmp_117_4;
  uint64_t v27 = v9 + 1;
  uint64_t v28 = v9;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
  aBlock[3] = &unk_264610418;
  aBlock[4] = buf;
  uint64_t v10 = _Block_copy(aBlock);
  uint64_t v19 = v10;
  if (v16)
  {
    qmi::Client::send();
    uint64_t v10 = v19;
  }
  if (v10) {
    _Block_release(v10);
  }
  if (v28) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v28);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v22);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224C0FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 88);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0>(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIStewieCommandDriver::handleDumpState(dispatch_queue_t *this)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(this[3]);
  v2 = this[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6) = 0;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ********************************", (uint8_t *)&v6, 2u);
    v2 = this[5];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6) = 0;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I [d] * QMIStewieCommandDriver state *", (uint8_t *)&v6, 2u);
    v2 = this[5];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6) = 0;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ********************************", (uint8_t *)&v6, 2u);
    v2 = this[5];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)this + 112)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    int v6 = 136315138;
    int v7 = v3;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Ready: %s", (uint8_t *)&v6, 0xCu);
  }
  if (*((unsigned char *)this + 120))
  {
    int v4 = this[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *((_DWORD *)this + 29);
      int v6 = 67240192;
      LODWORD(v7) = v5;
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I [d] fLastKnownBBUID: %{public}u", (uint8_t *)&v6, 8u);
    }
  }
}

void *std::__function::__value_func<void ()(BOOL,StewieHWSupportType)>::~__value_func[abi:ne180100](void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::~__value_func[abi:ne180100](void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<void ()(BOOL,unsigned short)>::~__value_func[abi:ne180100](void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::shared_ptr<QMIStewieCommandDriver>::shared_ptr[abi:ne180100]<QMIStewieCommandDriver,std::shared_ptr<QMIStewieCommandDriver> ctu::SharedSynchronizable<QMIStewieCommandDriver>::make_shared_ptr<QMIStewieCommandDriver>(QMIStewieCommandDriver*)::{lambda(QMIStewieCommandDriver*)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2224C1560(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMIStewieCommandDriver> ctu::SharedSynchronizable<QMIStewieCommandDriver>::make_shared_ptr<QMIStewieCommandDriver>(QMIStewieCommandDriver*)::{lambda(QMIStewieCommandDriver*)#1}::operator() const(QMIStewieCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_2224C1588(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<QMIStewieCommandDriver *,std::shared_ptr<QMIStewieCommandDriver> ctu::SharedSynchronizable<QMIStewieCommandDriver>::make_shared_ptr<QMIStewieCommandDriver>(QMIStewieCommandDriver*)::{lambda(QMIStewieCommandDriver *)#1},std::allocator<QMIStewieCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<QMIStewieCommandDriver *,std::shared_ptr<QMIStewieCommandDriver> ctu::SharedSynchronizable<QMIStewieCommandDriver>::make_shared_ptr<QMIStewieCommandDriver>(QMIStewieCommandDriver*)::{lambda(QMIStewieCommandDriver *)#1},std::allocator<QMIStewieCommandDriver>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<QMIStewieCommandDriver *,std::shared_ptr<QMIStewieCommandDriver> ctu::SharedSynchronizable<QMIStewieCommandDriver>::make_shared_ptr<QMIStewieCommandDriver>(QMIStewieCommandDriver*)::{lambda(QMIStewieCommandDriver *)#1},std::allocator<QMIStewieCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIStewieCommandDriver> ctu::SharedSynchronizable<QMIStewieCommandDriver>::make_shared_ptr<QMIStewieCommandDriver>(QMIStewieCommandDriver*)::{lambda(QMIStewieCommandDriver*)#1}::operator() const(QMIStewieCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 184))();
  }
  return result;
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft11ServiceInfo10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224C1728(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft20DeactivationComplete10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224C182C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft18RequestStateChange10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224C1930(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft26SecurityConfigUpdateNeeded10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224C1A34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft19SecurityConfigUsage10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224C1B38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft15MessageTXStatus10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224C1C3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft9MessageRX10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224C1D40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft18FileTransferStatus10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224C1E44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft17ServiceOutageInfo10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224C1F48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft21SaveBroadcastInfoBlob10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224C204C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t std::__function::__value_func<void ()(BOOL,StewieHWSupportType)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0>(QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  std::function<void ()(BOOL,StewieHWSupportType)>::operator()(v1[3], 0, 2);
  std::unique_ptr<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0,std::default_delete<std::function<void ()(BOOL,StewieHWSupportType)> &&>>::~unique_ptr[abi:ne180100](&v4);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v3);
}

void sub_2224C2158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void **std::unique_ptr<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0,std::default_delete<std::function<void ()(BOOL,StewieHWSupportType)> &&>>::~unique_ptr[abi:ne180100](void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = std::__function::__value_func<void ()(BOOL,StewieHWSupportType)>::~__value_func[abi:ne180100](v2);
    MEMORY[0x223C9A950](v3, 0x1020C40A5B76CDFLL);
  }
  return a1;
}

uint64_t std::function<void ()(BOOL,StewieHWSupportType)>::operator()(uint64_t a1, char a2, int a3)
{
  char v5 = a2;
  int v4 = a3;
  if (!a1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, char *, int *))(*(void *)a1 + 48))(a1, &v5, &v4);
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft15GetCapabilities7RequestEZNS_15getCapabilitiesEONSt3__18functionIFvb19StewieHWSupportTypeEEEE3__1EEvRKT_OT0__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void **)(a1 + 32);
  int v3 = *((_DWORD *)a2 + 1);
  int v4 = *(NSObject **)(*v2 + 40);
  if (!v3)
  {
    if (os_log_type_enabled(*(os_log_t *)(*v2 + 40), OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15) = 0;
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I GetCapabilities succeeded", (uint8_t *)&v15, 2u);
    }
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(a2);
    if (TlvValue)
    {
      uint64_t v8 = TlvValue;
      int v9 = v7;
      uint64_t v15 = TlvValue;
      BOOL v10 = tlv::parseV<sft::tlv::HWSupport>((unint64_t *)&v15, v7);
      if (v15)
      {
        int v11 = v10;
LABEL_9:
        uint64_t v12 = v2[4];
        char v13 = 1;
        return std::function<void ()(BOOL,StewieHWSupportType)>::operator()(v12, v13, v11);
      }
      ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 3, v8, v9);
    }
    int v11 = 2;
    goto LABEL_9;
  }
  if (os_log_type_enabled(*(os_log_t *)(*v2 + 40), OS_LOG_TYPE_ERROR))
  {
    LODWORD(v15) = 67109378;
    HIDWORD(v15) = v3;
    __int16 v16 = 2080;
    uint64_t v17 = qmi::asString();
    _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute GetCapabilities. Error code:0x%x (%s)", (uint8_t *)&v15, 0x12u);
  }
  uint64_t v12 = v2[4];
  char v13 = 0;
  int v11 = 2;
  return std::function<void ()(BOOL,StewieHWSupportType)>::operator()(v12, v13, v11);
}

uint64_t __copy_helper_block_e8_32c116_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver15getCapabilitiesEONS_8functionIFvb19StewieHWSupportTypeEEEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c116_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver15getCapabilitiesEONS_8functionIFvb19StewieHWSupportTypeEEEE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_1,std::allocator<std::function<void ()(BOOL,StewieHWSupportType)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CEE98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_1,std::allocator<std::function<void ()(BOOL,StewieHWSupportType)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CEE98;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_1,std::allocator<std::function<void ()(BOOL,StewieHWSupportType)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL,StewieHWSupportType)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft15GetCapabilities8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224C24FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  std::function<void ()(BOOL)>::operator()((uint64_t)v3, 0);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v3);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2224C2584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLineSets>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CEF00;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLineSets>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CEF00;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x223C9A950);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLineSets>::getSize(uint64_t a1)
{
  return tlv::size<sft::tlv::TargetLineSets>(a1 + 16);
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLineSets>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<sft::tlv::TargetLineSets>((unsigned char **)a2, a1 + 16);
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLineSets>::clone()
{
}

void sub_2224C27C4(_Unwind_Exception *a1)
{
  int v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }
  MEMORY[0x223C9A950](v1, 0x10A1C40FDE69906);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::S4ConfigSegmentInfo>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::S4ConfigSegmentInfo>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<sft::tlv::S4ConfigSegmentInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::TdFragmentInfo>((_WORD **)a2, (_WORD *)(a1 + 10));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::S4ConfigSegmentInfo>::clone()
{
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft11SetS4Config7RequestEZNS_19sendS4ConfigSegmentERK20StewieTargetLineSetsmmttONSt3__18functionIFvbEEEE3__3EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(unsigned __int16 **)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  int v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v8 = v2[20];
      int v9 = v2[21] - 1;
      int v10 = 67109890;
      int v11 = v8;
      __int16 v12 = 1024;
      int v13 = v9;
      __int16 v14 = 1024;
      int v15 = v3;
      __int16 v16 = 2080;
      uint64_t v17 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute SetS4Config (%d/%d). Error code:0x%x (%s)", (uint8_t *)&v10, 0x1Eu);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = v2[20];
    int v6 = v2[21] - 1;
    int v10 = 67109376;
    int v11 = v5;
    __int16 v12 = 1024;
    int v13 = v6;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I SetS4Config (%d/%d) succeeded", (uint8_t *)&v10, 0xEu);
  }
  return std::function<void ()(BOOL)>::operator()((uint64_t)(v2 + 4), v3 == 0);
}

uint64_t __copy_helper_block_e8_32c127_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver19sendS4ConfigSegmentERK20StewieTargetLineSetsmmttONS_8functionIFvbEEEE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c127_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver19sendS4ConfigSegmentERK20StewieTargetLineSetsmmttONS_8functionIFvbEEEE3__3EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CEFB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CEFB8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  int v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    int v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0>(QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&,std::default_delete<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v1 = *a1;
  int v3 = a1;
  uint64_t v4 = v1;
  char v5 = 0;
  char v6 = 0;
  std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::operator()(v1[3], 0);
  std::unique_ptr<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0,std::default_delete<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::~unique_ptr[abi:ne180100](&v4);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v3);
}

void sub_2224C2BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void **std::unique_ptr<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0,std::default_delete<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::~unique_ptr[abi:ne180100](void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int v3 = std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::~__value_func[abi:ne180100](v2);
    MEMORY[0x223C9A950](v3, 0x1020C40A5B76CDFLL);
  }
  return a1;
}

uint64_t std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::operator()(uint64_t a1, char a2)
{
  char v3 = a2;
  if (!a1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 48))(a1, &v3);
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceType>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceType>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceType>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceType>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProtocolMode>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProtocolMode>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProtocolMode>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProtocolMode>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::SPSEnvironmentType>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::SPSEnvironmentType>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<sft::tlv::SPSEnvironmentType>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::SPSEnvironmentType>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<sft::tlv::SecurityCredentials>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3) {
LABEL_8:
  }
    operator new();
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::SecurityCredentials>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::SecurityCredentials>::getSize()
{
  return tlv::size<wds::tlv::Ipv6AddressExtended>();
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::SecurityCredentials>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = *a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  tlv::writeV<sft::tlv::SecurityCredentials>(a2, a1 + 9);
  uint64_t v6 = *a2 - v5;
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)(v4 + 1) = v6;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::SecurityCredentials>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<sft::tlv::EARFCN>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3) {
LABEL_8:
  }
    operator new();
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 16;
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::EARFCN>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CF160;
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  char v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::EARFCN>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CF160;
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  char v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }

  JUMPOUT(0x223C9A950);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::EARFCN>::getSize(uint64_t a1)
{
  return tlv::size<sft::tlv::EARFCN>((void *)(a1 + 16));
}

_DWORD *qmi::MutableMessageBase::TlvWrapper<sft::tlv::EARFCN>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<sft::tlv::EARFCN>((unsigned char **)a2, (_DWORD *)(a1 + 16));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::EARFCN>::clone()
{
}

void sub_2224C354C(_Unwind_Exception *a1)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 24) = v4;
    operator delete(v4);
  }
  MEMORY[0x223C9A950](v1, 0x1091C4035291CF6);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<sft::tlv::LocationData>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3) {
LABEL_8:
  }
    operator new();
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 16;
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::LocationData>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CF1B0;
  uint64_t v2 = (void *)a1[14];
  if (v2)
  {
    a1[15] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::LocationData>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CF1B0;
  uint64_t v2 = (void *)a1[14];
  if (v2)
  {
    a1[15] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x223C9A950);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::LocationData>::getSize(uint64_t a1)
{
  return tlv::size<sft::tlv::LocationData>(a1 + 16);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::LocationData>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = *a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<sft::tlv::LocationData>(a2, a1 + 16);
  uint64_t v7 = *a2 - v5;
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::LocationData>::clone()
{
}

void sub_2224C3940(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x1091C40F7E97885);
  _Unwind_Resume(a1);
}

void *anonymous namespace'::sToSftTlvLocationData(uint64_t a1, uint64_t a2, char **a3, uint64_t a4)
{
  *(_OWORD *)a4 = *(_OWORD *)(a2 + 8);
  *(void *)(a4 + 16) = *(void *)(a2 + 24);
  *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 40);
  *(void *)(a4 + 40) = *(void *)(a1 + 16);
  *(void *)(a4 + 48) = *(void *)(a1 + 24);
  *(void *)(a4 + 56) = *(void *)(a1 + 32);
  *(_DWORD *)(a4 + 64) = *(_DWORD *)(a1 + 40);
  *(void *)(a4 + 72) = *(void *)(a1 + 48);
  *(_DWORD *)(a4 + 80) = *(_DWORD *)(a1 + 56);
  *(void *)(a4 + 88) = *(void *)(a1 + 64);
  uint64_t result = (void *)(a4 + 96);
  if ((char **)(a4 + 96) != a3) {
    uint64_t result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(result, *a3, a3[1], a3[1] - *a3);
  }
  *(_DWORD *)(a4 + 120) = *(_DWORD *)(a1 + 72);
  *(unsigned char *)(a4 + 124) = *(unsigned char *)(a1 + 76);
  *(_DWORD *)(a4 + 128) = *(_DWORD *)(a1 + 80);
  *(void *)(a4 + 136) = *(void *)(a1 + 88);
  *(unsigned char *)(a4 + 144) = *(unsigned char *)(a1 + 96);
  *(void *)(a4 + 152) = *(void *)(a1 + 104);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::CellSearch>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::CellSearch>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<sft::tlv::CellSearch>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::CellSearch>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::AutoInitiateRegistration>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::AutoInitiateRegistration>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<sft::tlv::AutoInitiateRegistration>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::AutoInitiateRegistration>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<sft::tlv::HeatMapData>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3) {
LABEL_8:
  }
    operator new();
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 16;
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::HeatMapData>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CF2A0;
  uint64_t v2 = (void *)a1[6];
  if (v2)
  {
    a1[7] = v2;
    operator delete(v2);
  }
  char v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::HeatMapData>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CF2A0;
  uint64_t v2 = (void *)a1[6];
  if (v2)
  {
    a1[7] = v2;
    operator delete(v2);
  }
  char v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }

  JUMPOUT(0x223C9A950);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::HeatMapData>::getSize(uint64_t a1)
{
  return tlv::size<sft::tlv::HeatMapData>((void *)(a1 + 16));
}

unsigned char *qmi::MutableMessageBase::TlvWrapper<sft::tlv::HeatMapData>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<sft::tlv::HeatMapData>((unsigned char **)a2, (_DWORD *)(a1 + 16));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::HeatMapData>::clone()
{
}

void sub_2224C3FFC(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x10B1C4082A65931);
  _Unwind_Resume(a1);
}

void anonymous namespace'::sToSftTlvHeatMapData(uint64_t a1, uint64_t a2)
{
  if (a1 + 8 != a2) {
    std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>((char *)a2, *(char **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2);
  }
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 32);
  uint64_t v4 = *(void **)(a1 + 40);
  int v30 = (void *)(a1 + 48);
  if (v4 != (void *)(a1 + 48))
  {
    uint64_t v5 = (void *)(a2 + 32);
    do
    {
      uint64_t v6 = (void *)v4[5];
      if (v6 != v4 + 6)
      {
        do
        {
          int v7 = *((_DWORD *)v4 + 8);
          int v8 = *((_DWORD *)v6 + 7);
          unsigned int v9 = *((unsigned __int8 *)v6 + 32);
          if (v9 >= 5) {
            char v10 = 0;
          }
          else {
            char v10 = v9 - 1;
          }
          unint64_t v11 = *(void *)(a2 + 40);
          unint64_t v12 = *(void *)(a2 + 48);
          if (v11 >= v12)
          {
            unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - *v5) >> 2);
            unint64_t v15 = v14 + 1;
            if (v14 + 1 > 0x1555555555555555) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - *v5) >> 2);
            if (2 * v16 > v15) {
              unint64_t v15 = 2 * v16;
            }
            if (v16 >= 0xAAAAAAAAAAAAAAALL) {
              unint64_t v17 = 0x1555555555555555;
            }
            else {
              unint64_t v17 = v15;
            }
            if (v17) {
              uint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::CurrentDataSystem>>(a2 + 48, v17);
            }
            else {
              uint64_t v18 = 0;
            }
            uint64_t v19 = &v18[12 * v14];
            *(_DWORD *)uint64_t v19 = v7;
            *((_DWORD *)v19 + 1) = v8;
            v19[8] = v10;
            *(_WORD *)(v19 + 9) = 0;
            v19[11] = 0;
            int v21 = *(unsigned char **)(a2 + 32);
            uint64_t v20 = *(unsigned char **)(a2 + 40);
            long long v22 = v19;
            if (v20 != v21)
            {
              do
              {
                uint64_t v23 = *(void *)(v20 - 12);
                v20 -= 12;
                char v24 = v20[8];
                *(void *)(v22 - 12) = v23;
                v22 -= 12;
                v22[8] = v24;
              }
              while (v20 != v21);
              uint64_t v20 = (unsigned char *)*v5;
            }
            int v13 = v19 + 12;
            *(void *)(a2 + 32) = v22;
            *(void *)(a2 + 40) = v19 + 12;
            *(void *)(a2 + 48) = &v18[12 * v17];
            if (v20) {
              operator delete(v20);
            }
          }
          else
          {
            *(_DWORD *)unint64_t v11 = v7;
            *(_DWORD *)(v11 + 4) = v8;
            *(unsigned char *)(v11 + 8) = v10;
            *(_WORD *)(v11 + 9) = 0;
            int v13 = (char *)(v11 + 12);
            *(unsigned char *)(v11 + 11) = 0;
          }
          *(void *)(a2 + 40) = v13;
          int v25 = (void *)v6[1];
          if (v25)
          {
            do
            {
              uint64_t v26 = v25;
              int v25 = (void *)*v25;
            }
            while (v25);
          }
          else
          {
            do
            {
              uint64_t v26 = (void *)v6[2];
              BOOL v27 = *v26 == (void)v6;
              uint64_t v6 = v26;
            }
            while (!v27);
          }
          uint64_t v6 = v26;
        }
        while (v26 != v4 + 6);
      }
      uint64_t v28 = (void *)v4[1];
      if (v28)
      {
        do
        {
          uint64_t v29 = v28;
          uint64_t v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          uint64_t v29 = (void *)v4[2];
          BOOL v27 = *v29 == (void)v4;
          uint64_t v4 = v29;
        }
        while (!v27);
      }
      uint64_t v4 = v29;
    }
    while (v29 != v30);
  }
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft10Activation7RequestEZNS_8activateE19StewieRequestReason24StewieSPSEnvironmentTypeRK22StewieProvisioningDataRK18StewieTimeFreqDataRK18StewieLocationDataRK25StewieSecurityCredentialsRKNSt3__110shared_ptrIK13StewieHeatMapEEbONSI_8functionIFvbONSI_8optionalINSI_6chrono8durationIxNSI_5ratioILl1ELl1000EEEEEEEEEEE4__10EEvRKT_OT0__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  v18[2] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  int v4 = *((_DWORD *)this + 1);
  if (v4)
  {
    unint64_t v15 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v4;
      LOWORD(v18[0]) = 2080;
      *(void *)((char *)v18 + 2) = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v15, OS_LOG_TYPE_ERROR, "Failed to execute Activation request. Error code:0x%x (%s)", buf, 0x12u);
    }
    buf[0] = 0;
    LOBYTE(v18[0]) = 0;
    uint64_t v12 = v2[4];
    char v13 = 0;
  }
  else
  {
    *(void *)buf = 0;
    v18[0] = 0;
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(this);
    if (TlvValue)
    {
      uint64_t v8 = TlvValue;
      int v9 = v7;
      v16[0] = TlvValue;
      uint64_t v10 = tlv::parseV<sft::tlv::SftTxDeferTime>(v16, v7);
      if (v16[0])
      {
        LOBYTE(v18[0]) = 1;
        *(void *)buf = v10;
      }
      else
      {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)this, 16, v8, v9);
      }
    }
    unint64_t v11 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v16[0]) = 0;
      _os_log_impl(&dword_22231A000, v11, OS_LOG_TYPE_DEFAULT, "#I Activation request succeeded. Waiting for indication", (uint8_t *)v16, 2u);
    }
    uint64_t v12 = v2[4];
    char v13 = 1;
  }
  return std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::operator()(v12, v13);
}

uint64_t __copy_helper_block_e8_32c322_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver8activateE19StewieRequestReason24StewieSPSEnvironmentTypeRK22StewieProvisioningDataRK18StewieTimeFreqDataRK18StewieLocationDataRK25StewieSecurityCredentialsRKNS0_IK13StewieHeatMapEEbONS_8functionIFvbONS_8optionalINS_6chrono8durationIxNS_5ratioILl1ELl1000EEEEEEEEEEE4__10EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c322_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver8activateE19StewieRequestReason24StewieSPSEnvironmentTypeRK22StewieProvisioningDataRK18StewieTimeFreqDataRK18StewieLocationDataRK25StewieSecurityCredentialsRKNS0_IK13StewieHeatMapEEbONS_8functionIFvbONS_8optionalINS_6chrono8durationIxNS_5ratioILl1ELl1000EEEEEEEEEEE4__10EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_10,std::allocator<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF308;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_10,std::allocator<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF308;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_10,std::allocator<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft10Activation8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224C4588(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v2 = a1;
  uint64_t v3 = *a1;
  std::function<void ()(BOOL)>::operator()((uint64_t)v3, 0);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v3);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2224C4610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeactivationReason>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeactivationReason>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeactivationReason>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeactivationReason>::clone()
{
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft12Deactivation7RequestEZNS_10deactivateE16StewieExitReasonONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  int v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute Deactivation request. Error code:0x%x (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Deactivation request succeeded. Waiting for indication", (uint8_t *)v6, 2u);
  }
  return std::function<void ()(BOOL)>::operator()(v2 + 8, v3 == 0);
}

uint64_t __copy_helper_block_e8_32c108_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver10deactivateE16StewieExitReasonONS_8functionIFvbEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c108_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver10deactivateE16StewieExitReasonONS_8functionIFvbEEEE3__2EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF3D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF3D8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  std::function<void ()(BOOL)>::operator()((uint64_t)v3, 0);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v3);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2224C4904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProvisioningStatus>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProvisioningStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProvisioningStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  __int16 v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProvisioningStatus>::clone()
{
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft20SetConcurrencyConfig7RequestEZNS_20setConcurrencyConfigEbONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  int v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute SetConcurrencyConfig. Error code:0x%x (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I SetConcurrencyConfig succeeded", (uint8_t *)v6, 2u);
  }
  return std::function<void ()(BOOL)>::operator()(v2 + 8, v3 == 0);
}

uint64_t __copy_helper_block_e8_32c101_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver20setConcurrencyConfigEbONS_8functionIFvbEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c101_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver20setConcurrencyConfigEbONS_8functionIFvbEEEE3__2EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF4A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF4A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  std::function<void ()(BOOL)>::operator()((uint64_t)v3, 0);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v3);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2224C4BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::SuspendReason>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::SuspendReason>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<sft::tlv::SuspendReason>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  __int16 v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::SuspendReason>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceDomainPref>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceDomainPref>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceDomainPref>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  __int16 v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceDomainPref>::clone()
{
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft7Suspend7RequestEZNS_7suspendE19StewieSuspendReasonONSt3__18functionIFvbEEEE3__3EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  int v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute Suspend. Error code:0x%x (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Suspend succeeded", (uint8_t *)v6, 2u);
  }
  return std::function<void ()(BOOL)>::operator()(v2 + 8, v3 == 0);
}

uint64_t __copy_helper_block_e8_32c107_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver7suspendE19StewieSuspendReasonONS_8functionIFvbEEEE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c107_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver7suspendE19StewieSuspendReasonONS_8functionIFvbEEEE3__3EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF5C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF5C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  std::function<void ()(BOOL)>::operator()((uint64_t)v3, 0);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v3);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2224C4FC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft6Resume7RequestEZNS_6resumeERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNSt3__16vectorIhNSD_9allocatorIhEEEERKNSD_10shared_ptrIK13StewieHeatMapEEONSD_8functionIFvbEEEE3__4EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  int v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute Resume. Error code:0x%x (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Resume succeeded", (uint8_t *)v6, 2u);
  }
  return std::function<void ()(BOOL)>::operator()(v2 + 8, v3 == 0);
}

uint64_t __copy_helper_block_e8_32c203_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver6resumeERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNS_6vectorIhNS_9allocatorIhEEEERKNS0_IK13StewieHeatMapEEONS_8functionIFvbEEEE3__4EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c203_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver6resumeERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNS_6vectorIhNS_9allocatorIhEEEERKNS0_IK13StewieHeatMapEEONS_8functionIFvbEEEE3__4EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF648;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF648;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  std::function<void ()(BOOL)>::operator()((uint64_t)v3, 0);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v3);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2224C51E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft20InitiateRegistration7RequestEZNS_20initiateRegistrationEONSt3__18functionIFvbEEEE3__1EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  int v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute InitiateRegistration. Error code:0x%x (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I InitiateRegistration succeeded", (uint8_t *)v6, 2u);
  }
  return std::function<void ()(BOOL)>::operator()(v2 + 8, v3 == 0);
}

uint64_t __copy_helper_block_e8_32c100_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver20initiateRegistrationEONS_8functionIFvbEEEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c100_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver20initiateRegistrationEONS_8functionIFvbEEEE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_1,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF6C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_1,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF6C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_1,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  std::function<void ()(BOOL)>::operator()((uint64_t)v3, 0);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v3);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2224C53FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft14GetServiceInfo7RequestEZNS_18requestServiceInfoEONSt3__18functionIFvbEEEE3__1EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  int v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute GetServiceInfo. Error code:0x%x (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I GetServiceInfo succeeded", (uint8_t *)v6, 2u);
  }
  return std::function<void ()(BOOL)>::operator()(v2 + 8, v3 == 0);
}

uint64_t __copy_helper_block_e8_32c98_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver18requestServiceInfoEONS_8functionIFvbEEEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c98_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver18requestServiceInfoEONS_8functionIFvbEEEE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_1,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF748;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_1,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF748;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_1,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  std::function<void ()(BOOL)>::operator()((uint64_t)v3, 0);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v3);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2224C5618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft17SetSecurityConfig7RequestEZNS_17setSecurityConfigERK25StewieSecurityCredentialsONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  int v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute SetSecurityConfig. Error code:0x%x (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I SetSecurityConfig succeeded", (uint8_t *)v6, 2u);
  }
  return std::function<void ()(BOOL)>::operator()(v2 + 8, v3 == 0);
}

uint64_t __copy_helper_block_e8_32c126_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver17setSecurityConfigERK25StewieSecurityCredentialsONS_8functionIFvbEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c126_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver17setSecurityConfigERK25StewieSecurityCredentialsONS_8functionIFvbEEEE3__2EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF7C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF7C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  std::function<void ()(BOOL)>::operator()((uint64_t)v3, 0);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v3);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2224C5834(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLocked>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLocked>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLocked>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  __int16 v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLocked>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeviceStationary>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeviceStationary>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeviceStationary>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  __int16 v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeviceStationary>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::Orientation>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::Orientation>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::Orientation>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  tlv::writeV<sft::tlv::Orientation>((_DWORD **)a2, (float *)(a1 + 12));
  uint64_t v6 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v6;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::Orientation>::clone()
{
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft23UpdateDeviceOrientation7RequestEZNS_17updateOrientationERK27StewieDeviceOrientationDataONSt3__18functionIFvbEEEE3__4EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  int v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute UpdateDeviceOrientation. Error code:0x%x (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I UpdateDeviceOrientation succeeded", (uint8_t *)v6, 2u);
  }
  return std::function<void ()(BOOL)>::operator()(v2 + 8, v3 == 0);
}

uint64_t __copy_helper_block_e8_32c128_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver17updateOrientationERK27StewieDeviceOrientationDataONS_8functionIFvbEEEE3__4EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c128_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver17updateOrientationERK27StewieDeviceOrientationDataONS_8functionIFvbEEEE3__4EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF938;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CF938;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  std::function<void ()(BOOL)>::operator()((uint64_t)v3, 0);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v3);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2224C5CE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

char *qmi::MutableMessageBase::getTLV<sft::tlv::GUID>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  int v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3) {
LABEL_8:
  }
    operator new();
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::GUID>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::GUID>::getSize()
{
  return tlv::size<wds::tlv::Ipv4AddressExtended>();
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::GUID>::write(uint64_t a1, __n128 **a2)
{
  unsigned __int8 v3 = *(unsigned char *)(a1 + 8);
  int v4 = *a2;
  uint64_t v5 = (uint64_t)(*a2)->n128_i64 + 3;
  *a2 = (__n128 *)v5;
  tlv::writeV<vinyl::tlv::ReqProfileId>(a2, (__n128 *)(a1 + 9));
  uint64_t v6 = (char *)*a2 - v5;
  v4->n128_u8[0] = v3;
  *(unsigned __int16 *)((char *)v4->n128_u16 + 1) = (unsigned __int16)v6;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::GUID>::clone()
{
}

uint64_t ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::get(uint64_t a1)
{
  return *(void *)a1;
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::Message>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CF9F0;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::Message>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CF9F0;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x223C9A950);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::Message>::getSize(uint64_t a1)
{
  return tlv::size<vs::tlv::CallingNumber>((void *)(a1 + 16));
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::Message>::write(uint64_t a1, void **a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (char *)*a2;
  uint64_t v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  uint64_t result = tlv::writeV<vs::tlv::CallingNumber>(a2, a1 + 16);
  __int16 v7 = (char *)*a2 - v5;
  char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::Message>::clone()
{
}

void sub_2224C613C(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::TrafficQosPriority>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::TrafficQosPriority>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<sft::tlv::TrafficQosPriority>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::IPPref>((unsigned char **)a2, (_DWORD *)(a1 + 12));
  __int16 v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::TrafficQosPriority>::clone()
{
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft9MessageTX7RequestEZNS_11sendMessageERKN3ctu2cf11CFSharedRefIK8__CFUUIDEERKNSt3__16vectorIhNSC_9allocatorIhEEEE24StewieTrafficQosPriorityONSC_8functionIFvbEEEE3__4EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  int v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute MessageTX. Error code:0x%x (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I MessageTX request succeeded. Waiting for indication", (uint8_t *)v6, 2u);
  }
  return std::function<void ()(BOOL)>::operator()(v2 + 8, v3 == 0);
}

uint64_t __copy_helper_block_e8_32c186_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver11sendMessageERKN3ctu2cf11CFSharedRefIK8__CFUUIDEERKNS_6vectorIhNS_9allocatorIhEEEE24StewieTrafficQosPriorityONS_8functionIFvbEEEE3__4EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c186_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver11sendMessageERKN3ctu2cf11CFSharedRefIK8__CFUUIDEERKNS_6vectorIhNS_9allocatorIhEEEE24StewieTrafficQosPriorityONS_8functionIFvbEEEE3__4EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFAA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFAA8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  std::function<void ()(BOOL)>::operator()((uint64_t)v3, 0);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v3);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2224C6440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::CancelAllQueuedTXMessages>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::CancelAllQueuedTXMessages>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<sft::tlv::CancelAllQueuedTXMessages>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  __int16 v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::CancelAllQueuedTXMessages>::clone()
{
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft15CancelMessageTX7RequestEZNS_15cancelMessageTxERKN3ctu2cf11CFSharedRefIK8__CFUUIDEEONSt3__18functionIFvbEEEE3__3EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  int v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute CancelMessageTX. Error code:0x%x (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I CancelMessageTX request succeeded. Waiting for indication", (uint8_t *)v6, 2u);
  }
  return std::function<void ()(BOOL)>::operator()(v2 + 8, v3 == 0);
}

uint64_t __copy_helper_block_e8_32c131_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver15cancelMessageTxERKN3ctu2cf11CFSharedRefIK8__CFUUIDEEONS_8functionIFvbEEEE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c131_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver15cancelMessageTxERKN3ctu2cf11CFSharedRefIK8__CFUUIDEEONS_8functionIFvbEEEE3__3EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFB78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFB78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  std::function<void ()(BOOL)>::operator()((uint64_t)v3, 0);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v3);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2224C6734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::BBMessageID>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::BBMessageID>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<sft::tlv::BBMessageID>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  __int16 v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::BBMessageID>::clone()
{
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft12MessageRXAck7RequestEZNS_18ackReceivedMessageEtONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  int v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute MessageRXAck. Error code:0x%x (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I MessageRXAck succeeded", (uint8_t *)v6, 2u);
  }
  return std::function<void ()(BOOL)>::operator()(v2 + 8, v3 == 0);
}

uint64_t __copy_helper_block_e8_32c99_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver18ackReceivedMessageEtONS_8functionIFvbEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c99_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver18ackReceivedMessageEtONS_8functionIFvbEEEE3__2EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFC48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFC48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t std::__function::__value_func<void ()(BOOL,unsigned short)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  int v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    int v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_0>(QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<std::function<void ()(BOOL,unsigned short)> &&,std::default_delete<std::function<void ()(BOOL,unsigned short)> &&>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v1 = *a1;
  int v3 = a1;
  uint64_t v4 = v1;
  std::function<void ()(BOOL,unsigned short)>::operator()(v1[3], 0, 0);
  std::unique_ptr<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_0,std::default_delete<std::function<void ()(BOOL,unsigned short)> &>>::~unique_ptr[abi:ne180100](&v4);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v3);
}

void sub_2224C6AB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void **std::unique_ptr<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_0,std::default_delete<std::function<void ()(BOOL,unsigned short)> &>>::~unique_ptr[abi:ne180100](void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    int v3 = std::__function::__value_func<void ()(BOOL,unsigned short)>::~__value_func[abi:ne180100](v2);
    MEMORY[0x223C9A950](v3, 0x1020C40A5B76CDFLL);
  }
  return a1;
}

uint64_t std::function<void ()(BOOL,unsigned short)>::operator()(uint64_t a1, char a2, __int16 a3)
{
  char v5 = a2;
  __int16 v4 = a3;
  if (!a1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, char *, __int16 *))(*(void *)a1 + 48))(a1, &v5, &v4);
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::FileTransferInfo>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CFCB0;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::FileTransferInfo>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CFCB0;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x223C9A950);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::FileTransferInfo>::getSize(uint64_t a1)
{
  return tlv::size<sft::tlv::FileTransferInfo>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::FileTransferInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = *a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<sft::tlv::FileTransferInfo>(a2, a1 + 16);
  uint64_t v7 = *a2 - v5;
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::FileTransferInfo>::clone()
{
}

void sub_2224C6D1C(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x1091C4066207FBFLL);
  _Unwind_Resume(a1);
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft8SendFile7RequestEZNS_15sendFileSegmentE14StewieFileTypettONSt3__16vectorIhNS5_9allocatorIhEEEEONS5_8functionIFvbtEEEE3__2EEvRKT_OT0__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(unsigned __int16 **)(a1 + 32);
  int v3 = *((_DWORD *)a2 + 1);
  uint64_t v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(*(os_log_t *)(*(void *)v2 + 40), OS_LOG_TYPE_ERROR))
    {
      int v16 = v2[4];
      int v17 = v2[5] - 1;
      LODWORD(v18) = 67109890;
      HIDWORD(v18) = v16;
      __int16 v19 = 1024;
      int v20 = v17;
      __int16 v21 = 1024;
      int v22 = v3;
      __int16 v23 = 2080;
      uint64_t v24 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute SendFile (%d/%d). Error code:0x%x (%s)", (uint8_t *)&v18, 0x1Eu);
    }
    uint64_t v13 = *((void *)v2 + 5);
    char v14 = 0;
    __int16 v12 = 0;
  }
  else
  {
    if (os_log_type_enabled(*(os_log_t *)(*(void *)v2 + 40), OS_LOG_TYPE_DEFAULT))
    {
      int v6 = v2[4];
      int v7 = v2[5] - 1;
      LODWORD(v18) = 67109376;
      HIDWORD(v18) = v6;
      __int16 v19 = 1024;
      int v20 = v7;
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I SendFile (%d/%d) succeeded", (uint8_t *)&v18, 0xEu);
    }
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(a2);
    if (TlvValue)
    {
      uint64_t v10 = TlvValue;
      int v11 = v9;
      uint64_t v18 = TlvValue;
      LOWORD(TlvValue) = tlv::parseV<sft::tlv::ExpectedSegmentInfo>((unint64_t *)&v18, v9);
      if (!v18)
      {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 64, v10, v11);
        LOWORD(TlvValue) = 0;
      }
    }
    __int16 v12 = TlvValue;
    uint64_t v13 = *((void *)v2 + 5);
    char v14 = 1;
  }
  return std::function<void ()(BOOL,unsigned short)>::operator()(v13, v14, v12);
}

uint64_t __copy_helper_block_e8_32c146_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver15sendFileSegmentE14StewieFileTypettONS_6vectorIhNS_9allocatorIhEEEEONS_8functionIFvbtEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c146_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver15sendFileSegmentE14StewieFileTypettONS_6vectorIhNS_9allocatorIhEEEEONS_8functionIFvbtEEEE3__2EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_2,std::allocator<std::function<void ()(BOOL,unsigned short)> &>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFD18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_2,std::allocator<std::function<void ()(BOOL,unsigned short)> &>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFD18;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_2,std::allocator<std::function<void ()(BOOL,unsigned short)> &>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL,unsigned short)>::~__value_func[abi:ne180100]((void *)(a1 + 40));
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft8SendFile8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224C7074(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  std::function<void ()(BOOL)>::operator()((uint64_t)v3, 0);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v3);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2224C70FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft13GPSDataUpdate7RequestEZNS_17sendGPSDataUpdateERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNSt3__16vectorIhNSD_9allocatorIhEEEERKNSD_10shared_ptrIK13StewieHeatMapEEONSD_8functionIFvbEEEE3__4EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  uint64_t v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute GPSDataUpdate. Error code:0x%x (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I GPSDataUpdate succeeded", (uint8_t *)v6, 2u);
  }
  return std::function<void ()(BOOL)>::operator()(v2 + 8, v3 == 0);
}

uint64_t __copy_helper_block_e8_32c215_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver17sendGPSDataUpdateERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNS_6vectorIhNS_9allocatorIhEEEERKNS0_IK13StewieHeatMapEEONS_8functionIFvbEEEE3__4EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c215_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver17sendGPSDataUpdateERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNS_6vectorIhNS_9allocatorIhEEEERKNS0_IK13StewieHeatMapEEONS_8functionIFvbEEEE3__4EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFD98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFD98;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0>(QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&,std::default_delete<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v1 = *a1;
  int v3 = a1;
  uint64_t v4 = v1;
  char v5 = 0;
  char v6 = 0;
  std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::operator()(v1[3], 0);
  std::unique_ptr<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0,std::default_delete<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::~unique_ptr[abi:ne180100](&v4);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v3);
}

void sub_2224C7324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::ISO3166Alpha3>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CFE00;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ISO3166Alpha3>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CFE00;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x223C9A950);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ISO3166Alpha3>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::NextHdrProtList>((void *)(a1 + 16));
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::ISO3166Alpha3>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::NextHdrProtList>((unsigned char **)a2, a1 + 16);
  __int16 v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ISO3166Alpha3>::clone()
{
}

void sub_2224C74DC(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft22GetCellularTxDeferTime7RequestEZNS_22getCellularTxDeferTimeERKNSt3__16vectorIhNS4_9allocatorIhEEEEONS4_8functionIFvbONS4_8optionalINS4_6chrono8durationIxNS4_5ratioILl1ELl1000EEEEEEEEEEE3__2EEvRKT_OT0__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  v20[2] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  int v4 = *((_DWORD *)this + 1);
  if (v4)
  {
    int v16 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v4;
      LOWORD(v20[0]) = 2080;
      *(void *)((char *)v20 + 2) = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v16, OS_LOG_TYPE_ERROR, "Failed to execute GetCellularTxDeferTime. Error code:0x%x (%s)", buf, 0x12u);
    }
    buf[0] = 0;
    LOBYTE(v20[0]) = 0;
    uint64_t v12 = v2[4];
    goto LABEL_11;
  }
  v20[0] = 1;
  uint64_t TlvValue = qmi::MessageBase::findTlvValue(this);
  if (!TlvValue)
  {
LABEL_8:
    char v14 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v17) = 0;
      _os_log_error_impl(&dword_22231A000, v14, OS_LOG_TYPE_ERROR, "Expected TLV: CellularTXDeferTime is missing", (uint8_t *)&v17, 2u);
    }
    LOBYTE(v17) = 0;
    char v18 = 0;
    uint64_t v12 = v2[4];
LABEL_11:
    char v13 = 0;
    return std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::operator()(v12, v13);
  }
  uint64_t v8 = TlvValue;
  int v9 = v7;
  uint64_t v17 = TlvValue;
  unsigned int v10 = tlv::parseV<sft::tlv::CellularTXDeferTime>((unint64_t *)&v17, v7);
  if (!v17)
  {
    ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)this, 3, v8, v9);
    goto LABEL_8;
  }
  *(void *)buf = v10;
  int v11 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v17) = 0;
    _os_log_impl(&dword_22231A000, v11, OS_LOG_TYPE_DEFAULT, "#I GetCellularTxDeferTime succeeded", (uint8_t *)&v17, 2u);
  }
  uint64_t v12 = v2[4];
  char v13 = 1;
  return std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::operator()(v12, v13);
}

uint64_t __copy_helper_block_e8_32c197_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver22getCellularTxDeferTimeERKNS_6vectorIhNS_9allocatorIhEEEEONS_8functionIFvbONS_8optionalINS_6chrono8durationIxNS_5ratioILl1ELl1000EEEEEEEEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c197_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver22getCellularTxDeferTimeERKNS_6vectorIhNS_9allocatorIhEEEEONS_8functionIFvbONS_8optionalINS_6chrono8durationIxNS_5ratioILl1ELl1000EEEEEEEEEEE3__2EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_2,std::allocator<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFE68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_2,std::allocator<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFE68;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_2,std::allocator<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft22GetCellularTxDeferTime8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    char v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      char v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224C7858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v2 = a1;
  uint64_t v3 = *a1;
  std::function<void ()(BOOL)>::operator()((uint64_t)v3, 0);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v3);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2224C78E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::BroadcastInfoBlob>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CFED0;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::BroadcastInfoBlob>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4CFED0;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x223C9A950);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::BroadcastInfoBlob>::getSize(uint64_t a1)
{
  return tlv::size<vs::tlv::CallingNumber>((void *)(a1 + 16));
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::BroadcastInfoBlob>::write(uint64_t a1, void **a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (char *)*a2;
  uint64_t v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  uint64_t result = tlv::writeV<vs::tlv::CallingNumber>(a2, a1 + 16);
  uint64_t v7 = (char *)*a2 - v5;
  char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::BroadcastInfoBlob>::clone()
{
}

void sub_2224C7A98(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft20SetBroadcastInfoBlob7RequestEZNS_20setBroadcastInfoBlobERKNSt3__16vectorIhNS4_9allocatorIhEEEEONS4_8functionIFvbEEEE3__2EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  int v4 = *(NSObject **)(*(void *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failed to execute SetBroadcastInfoBlob. Error code:0x%x (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I SetBroadcastInfoBlob request succeeded", (uint8_t *)v6, 2u);
  }
  return std::function<void ()(BOOL)>::operator()(v2 + 8, v3 == 0);
}

uint64_t __copy_helper_block_e8_32c133_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver20setBroadcastInfoBlobERKNS_6vectorIhNS_9allocatorIhEEEEONS_8functionIFvbEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c133_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver20setBroadcastInfoBlobERKNS_6vectorIhNS_9allocatorIhEEEEONS_8functionIFvbEEEE3__2EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFF38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4CFF38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t std::optional<std::vector<unsigned char>>::operator=[abi:ne180100]<std::vector<unsigned char>,void>(uint64_t a1, __n128 *a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    std::vector<unsigned char>::__move_assign(a1, a2);
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void *std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(uint64_t a1, const void *a2, uint64_t a3, size_t __sz)
{
  uint64_t result = std::vector<unsigned char>::__vallocate[abi:ne180100]((void *)a1, __sz);
  uint64_t v8 = *(void *)(a1 + 8);
  size_t v9 = a3 - (void)a2;
  if (v9) {
    uint64_t result = memmove(*(void **)(a1 + 8), a2, v9);
  }
  *(void *)(a1 + 8) = v8 + v9;
  return result;
}

void sub_2224C7D30(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Mav20SignalStrengthCommandDriver::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_2224C7E0C(_Unwind_Exception *exception_object)
{
  if (v2) {
    dispatch_release(v2);
  }
  if (v3) {
    MEMORY[0x223C9A950](v1, 0xE1C40674E6572);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Mav20SignalStrengthCommandDriver::Mav20SignalStrengthCommandDriver(uint64_t a1, void *a2, NSObject **a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  *(void *)a1 = MEMORY[0x263F038D8] + 16;
  char v6 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v13, (const char *)*MEMORY[0x263F03770], "sig.qmi");
  void *v6 = 0;
  v6[1] = 0;
  __int16 v7 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v7) {
    dispatch_retain(v7);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x223C99A30](v12);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v13);
  v11[0] = &unk_26D4C05F8;
  v11[3] = v11;
  uint64_t v8 = (capabilities::ct *)std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)v12, (uint64_t)v11);
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v8) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100](v12);
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100](v11);
  *(void *)a1 = &unk_26D4CFF88;
  *(void *)(a1 + 56) = *a2;
  uint64_t v9 = a2[1];
  *(void *)(a1 + 64) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 72), *(os_log_s **)(a1 + 40));
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  return a1;
}

void sub_2224C80B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va2);
  MEMORY[0x223C9A950](v5, 0x10A1C40FF1576FELL);
  uint64_t v7 = *((void *)v2 + 6);
  *((void *)v2 + 6) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va);
  MEMORY[0x223C99A30](v4);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable(v3);
  SignalStrengthCommandDriver::~SignalStrengthCommandDriver(v2);
  _Unwind_Resume(a1);
}

void *Mav20SignalStrengthCommandDriver::bootstrap(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  char v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", (uint8_t *)&buf, 2u);
  }
  long long v7 = *a4;
  *(void *)a4 = 0;
  *((void *)a4 + 1) = 0;
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 96);
  *(_OWORD *)(a1 + 88) = v7;
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  subscriber::makeSimSlotRange();
  uint64_t v9 = v20;
  if (v20 != v21)
  {
    while ((v22(*v9) & 1) == 0)
    {
      if (++v9 == v21)
      {
        uint64_t v9 = v21;
        break;
      }
    }
    while (v9 != v21)
    {
      if (*v9 == 1)
      {
        uint64_t v10 = "SignalStrength.1";
      }
      else if (*v9 == 2)
      {
        uint64_t v10 = "SignalStrength.2";
      }
      else
      {
        uint64_t v10 = 0;
      }
      uint64_t v11 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v11 || (uint64_t v12 = *(void *)(a1 + 8), (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
        std::__throw_bad_weak_ptr[abi:ne180100]();
      }
      uint64_t v14 = v13;
      atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v13);
      Registry::getServerConnection((uint64_t *)&v23, *(Registry **)(a1 + 56));
      long long buf = 0u;
      long long v35 = 0u;
      std::string::basic_string[abi:ne180100]<0>(&v31, v10);
      uint64_t v15 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v15;
      if (v15) {
        dispatch_retain(v15);
      }
      std::string::basic_string[abi:ne180100]<0>(__p, "registration");
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      uint64_t v16 = std::__shared_weak_count::lock(v14);
      if (v16)
      {
        uint64_t v17 = v16;
        atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        uint64_t v25 = v12;
        uint64_t v26 = v16;
        std::__shared_weak_count::__release_weak(v14);
        std::__shared_weak_count::__release_shared[abi:ne180100](v17);
      }
      else
      {
        uint64_t v25 = 0;
        uint64_t v26 = 0;
        std::__shared_weak_count::__release_weak(v14);
      }
      long long v24 = v23;
      long long v23 = 0uLL;
      qmi::Client::createWithQueueLocal();
      if (*((void *)&v24 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v24 + 1));
      }
      if (v26) {
        std::__shared_weak_count::__release_weak(v26);
      }
      if (v29 < 0) {
        operator delete(__p[0]);
      }
      if (object) {
        dispatch_release(object);
      }
      if (SBYTE7(v33) < 0) {
        operator delete(v31);
      }
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      long long v33 = v35;
      long long v35 = 0uLL;
      qmi::ClientRouter::addClient();
      qmi::Client::~Client((qmi::Client *)&v31);
      qmi::ClientRouter::get();
      qmi::Client::~Client((qmi::Client *)&buf);
      if (*((void *)&v23 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v23 + 1));
      }
      char v18 = v9 + 1;
      uint64_t v9 = v21;
      if (v18 != v21)
      {
        uint64_t v9 = v18;
        while ((v22(*v9) & 1) == 0)
        {
          if (++v9 == v21)
          {
            uint64_t v9 = v21;
            break;
          }
        }
      }
    }
  }
  *(void *)&long long buf = &unk_26D4D0160;
  *((void *)&buf + 1) = a1;
  *((void *)&v35 + 1) = &buf;
  qmi::ClientRouter::setHandler();
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](&buf);
  uint64_t v31 = &unk_26D4D01E0;
  uint64_t v32 = a1;
  *((void *)&v33 + 1) = &v31;
  qmi::ClientRouter::setHandler();
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](&v31);
  __p[0] = &unk_26D4D0260;
  __p[1] = (void *)a1;
  int v30 = __p;
  qmi::ClientRouter::setHandler();
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](__p);
  *(void *)&long long buf = &unk_26D4D02E0;
  *((void *)&buf + 1) = a1;
  *((void *)&v35 + 1) = &buf;
  qmi::ClientRouter::setIndHandlerInternal();
  return std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&buf);
}

void sub_2224C85F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,dispatch_object_t object,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100]((void *)(v35 - 144));
  _Unwind_Resume(a1);
}

void Mav20SignalStrengthCommandDriver::getSignalStrength_sync()
{
  memset(v0, 0, sizeof(v0));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v0);
  qmi::ClientRouter::get();
  operator new();
}

void sub_2224C88A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t Mav20SignalStrengthCommandDriver::start(Mav20SignalStrengthCommandDriver *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl(&dword_22231A000, v1, OS_LOG_TYPE_DEFAULT, "#I Starting", v3, 2u);
  }
  return qmi::ClientRouter::start();
}

uint64_t Mav20SignalStrengthCommandDriver::shutdown(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl(&dword_22231A000, v1, OS_LOG_TYPE_DEFAULT, "#I Shutting down", v3, 2u);
  }
  return qmi::ClientRouter::stop();
}

void Mav20SignalStrengthCommandDriver::poll(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl(&dword_22231A000, v1, OS_LOG_TYPE_DEFAULT, "#I Polling", v2, 2u);
  }
  Mav20SignalStrengthCommandDriver::getSignalStrength_sync();
}

void Mav20SignalStrengthCommandDriver::start(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a2 - 1 >= 3) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = a2;
  }
  char v6 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#I Starting reporting", buf, 2u);
  }
  long long v7 = *(char **)a3;
  uint64_t v8 = *(void *)(a3 + 8);
  v9[0] = v7;
  v9[1] = (char *)v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  Mav20SignalStrengthCommandDriver::setThresholds_sync(a1, v5, v9);
}

void sub_2224C8B84(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void Mav20SignalStrengthCommandDriver::setThresholds_sync(uint64_t a1, uint64_t a2, char **a3)
{
  memset(v4, 0, sizeof(v4));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v4);
  prepareThresholds((uint64_t)v4);
  populateThresholds(*a3, (uint64_t)v4);
  *qmi::MutableMessageBase::getTLV<nas::tlv::LinkQualityIndicator>((uint64_t)v4, 160) = 1;
  qmi::ClientRouter::get();
  operator new();
}

void sub_2224C8D88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void Mav20SignalStrengthCommandDriver::update(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if ((a2 - 1) >= 3) {
    a2 = 0;
  }
  else {
    a2 = a2;
  }
  v4[0] = *(char **)a3;
  v4[1] = (char *)v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  Mav20SignalStrengthCommandDriver::setThresholds_sync(a1, a2, v4);
}

void sub_2224C8E7C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void Mav20SignalStrengthCommandDriver::stop(uint64_t a1, unsigned int a2)
{
  if (a2 - 1 >= 3) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = a2;
  }
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Stopping reporting", buf, 2u);
  }
  uint64_t v5 = (char *)operator new(0x38uLL);
  *((void *)v5 + 1) = 0;
  *((void *)v5 + 2) = 0;
  *(void *)uint64_t v5 = &unk_26D4D04B0;
  v5[24] = 0;
  *((void *)v5 + 6) = 0;
  *((void *)v5 + 5) = 0;
  *((void *)v5 + 4) = v5 + 40;
  v6[0] = v5 + 24;
  v6[1] = v5;
  Mav20SignalStrengthCommandDriver::setThresholds_sync(a1, v3, v6);
}

void sub_2224C8F98(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void Mav20SignalStrengthCommandDriver::~Mav20SignalStrengthCommandDriver(Mav20SignalStrengthCommandDriver *this)
{
  *(void *)this = &unk_26D4CFF88;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  uint64_t v5 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  MEMORY[0x223C99A30]((char *)this + 40);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable((void *)this + 1);

  SignalStrengthCommandDriver::~SignalStrengthCommandDriver(this);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t vars8;

  *(void *)this = &unk_26D4CFF88;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  uint64_t v5 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  MEMORY[0x223C99A30]((char *)this + 40);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable((void *)this + 1);
  SignalStrengthCommandDriver::~SignalStrengthCommandDriver(this);

  JUMPOUT(0x223C9A950);
}

void std::shared_ptr<Mav20SignalStrengthCommandDriver>::shared_ptr[abi:ne180100]<Mav20SignalStrengthCommandDriver,std::shared_ptr<Mav20SignalStrengthCommandDriver> ctu::SharedSynchronizable<Mav20SignalStrengthCommandDriver>::make_shared_ptr<Mav20SignalStrengthCommandDriver>(Mav20SignalStrengthCommandDriver*)::{lambda(Mav20SignalStrengthCommandDriver*)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2224C91FC(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<Mav20SignalStrengthCommandDriver> ctu::SharedSynchronizable<Mav20SignalStrengthCommandDriver>::make_shared_ptr<Mav20SignalStrengthCommandDriver>(Mav20SignalStrengthCommandDriver*)::{lambda(Mav20SignalStrengthCommandDriver*)#1}::operator() const(Mav20SignalStrengthCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_2224C9224(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<Mav20SignalStrengthCommandDriver *,std::shared_ptr<Mav20SignalStrengthCommandDriver> ctu::SharedSynchronizable<Mav20SignalStrengthCommandDriver>::make_shared_ptr<Mav20SignalStrengthCommandDriver>(Mav20SignalStrengthCommandDriver*)::{lambda(Mav20SignalStrengthCommandDriver *)#1},std::allocator<Mav20SignalStrengthCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<Mav20SignalStrengthCommandDriver *,std::shared_ptr<Mav20SignalStrengthCommandDriver> ctu::SharedSynchronizable<Mav20SignalStrengthCommandDriver>::make_shared_ptr<Mav20SignalStrengthCommandDriver>(Mav20SignalStrengthCommandDriver*)::{lambda(Mav20SignalStrengthCommandDriver *)#1},std::allocator<Mav20SignalStrengthCommandDriver>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<Mav20SignalStrengthCommandDriver *,std::shared_ptr<Mav20SignalStrengthCommandDriver> ctu::SharedSynchronizable<Mav20SignalStrengthCommandDriver>::make_shared_ptr<Mav20SignalStrengthCommandDriver>(Mav20SignalStrengthCommandDriver*)::{lambda(Mav20SignalStrengthCommandDriver *)#1},std::allocator<Mav20SignalStrengthCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<Mav20SignalStrengthCommandDriver> ctu::SharedSynchronizable<Mav20SignalStrengthCommandDriver>::make_shared_ptr<Mav20SignalStrengthCommandDriver>(Mav20SignalStrengthCommandDriver*)::{lambda(Mav20SignalStrengthCommandDriver*)#1}::operator() const(Mav20SignalStrengthCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void SimInstanceLoggable<Mav20SignalStrengthCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::~SimInstanceLoggable()
{
}

uint64_t SimInstanceLoggable<Mav20SignalStrengthCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::getLoggerForSlot(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D0160;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D0160;
  a2[1] = v2;
  return result;
}

void std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, int *a2)
{
  int v2 = *a2;
  memset(v4, 0, sizeof(v4));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v4);
  *qmi::MutableMessageBase::getTLV<nas::tlv::SubType>((uint64_t)v4, 1) = v2 == 2;
  qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::BindSubscription::Request>(&v3, v2);
}

void sub_2224C96F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  uint64_t v23 = a10;
  a10 = 0;
  if (v23) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v23);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D01E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D01E0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 88);
  if ((*a2 - 1) >= 3) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = *a2;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v2 + 16))(v2, v3, 0);
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D0260;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D0260;
  a2[1] = v2;
  return result;
}

void std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::operator()()
{
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D02E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D02E0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    uint64_t v44 = 0;
    uint64_t v45 = 0;
    uint64_t v46 = 0;
    QMIServiceMsg::serialize((uint64_t *)&v44, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v35, v44);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v35);
    if (v44)
    {
      uint64_t v45 = v44;
      operator delete(v44);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v35);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v38 = 0;
  int v39 = 0;
  parseInputs((qmi::MessageBase *)v35, &v38);
  if (*(void *)(v38 + 16))
  {
    uint64_t v7 = v4 - 1 >= 3 ? 0 : v4;
    uint64_t v8 = *(void *)(v6 + 88);
    uint64_t v36 = v38;
    uint64_t v37 = v39;
    uint64_t v38 = 0;
    int v39 = 0;
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v8 + 32))(v8, v7, &v36);
    if (v37) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v37);
    }
  }
  if (v4 - 1 >= 3) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = v4;
  }
  uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v35);
  uint64_t v12 = TlvValue;
  if (TlvValue)
  {
    int v13 = v11;
    uint64_t v44 = TlvValue;
    char v14 = tlv::parseV<nas::tlv::LinkQuality>((unint64_t *)&v44, v11);
    if (v44)
    {
      if (v14 == 1) {
        uint64_t v15 = 100;
      }
      else {
        uint64_t v15 = 50;
      }
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 88) + 40))(*(void *)(v6 + 88), v9, v15);
    }
    else
    {
      ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v35[0], 160, v12, v13);
    }
  }
  uint64_t v16 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v35);
  char v18 = v16;
  if (v16)
  {
    int v19 = v17;
    uint64_t v44 = v16;
    unsigned __int8 v20 = tlv::parseV<nas::tlv::DataLinkQuality>((unint64_t *)&v44, v17);
    if (v44)
    {
      uint64_t v21 = v20;
      if (v20 != 10 && v20 != 100 && v20 != 50) {
        uint64_t v21 = 50;
      }
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 88) + 40))(*(void *)(v6 + 88), v9, v21);
    }
    else
    {
      ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v35[0], 162, v18, v19);
    }
  }
  int v22 = (char *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v35);
  long long v24 = v22;
  if (v22)
  {
    int v25 = v23;
    uint64_t v42 = 0;
    long long v43 = v22;
    __n128 __p = 0;
    v41 = 0;
    tlv::parseV<nas::tlv::EnhancedVoiceLinkQuality>(&v43, v23, &__p);
    uint64_t v26 = v43;
    if (v43)
    {
      uint64_t v27 = *(void *)(v6 + 88);
      uint64_t v45 = 0;
      uint64_t v46 = 0;
      uint64_t v44 = 0;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v44, __p, (uint64_t)v41, v41 - (unsigned char *)__p);
      (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v27 + 56))(v27, v9, &v44);
      if (v44)
      {
        uint64_t v45 = v44;
        operator delete(v44);
      }
    }
    if (__p)
    {
      v41 = __p;
      operator delete(__p);
    }
    if (v26) {
      int v28 = 0;
    }
    else {
      int v28 = ((uint64_t (*)(void, uint64_t, char *, void))*MEMORY[0x263F8BD78])(v35[0], 164, v24, v25) ^ 1;
    }
  }
  else
  {
    int v28 = 1;
  }
  char v29 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v35);
  uint64_t v31 = v29;
  if (v29)
  {
    int v32 = v30;
    uint64_t v44 = v29;
    unsigned __int8 v33 = tlv::parseV<nas::tlv::VoiceLinkQuality>((unint64_t *)&v44, v30);
    if (v44)
    {
      if (v28)
      {
        uint64_t v34 = v33;
        if (v33 != 10 && v33 != 100 && v33 != 50) {
          uint64_t v34 = 50;
        }
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 88) + 48))(*(void *)(v6 + 88), v9, v34);
      }
    }
    else
    {
      ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v35[0], 163, v31, v32);
    }
  }
  if (v39) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v39);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v35);
}

void sub_2224C9E38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *__p, uint64_t a17)
{
  int v19 = *(void **)(v17 - 72);
  if (v19)
  {
    *(void *)(v17 - 64) = v19;
    operator delete(v19);
  }
  if (__p)
  {
    a17 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a15);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::target_type()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::SigInfoEvents>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  uint64_t v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::SigInfoEvents>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 9;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::SigInfoEvents>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::SigInfoEvents>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::SigInfoEvents>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::SigInfoEvents>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::SigInfoEvents>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN32Mav20SignalStrengthCommandDriver27sendIndRegisterRequest_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 4))
  {
    char v3 = *(uint64_t **)(a1 + 32);
    uint64_t v4 = *v3;
    unsigned int v5 = *((_DWORD *)v3 + 2);
    if (v5 - 1 >= 3) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = v5;
    }
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = qmi::asString();
      int v9 = *(_DWORD *)(a2 + 4);
      int v10 = 136315394;
      uint64_t v11 = v8;
      __int16 v12 = 1024;
      int v13 = v9;
      _os_log_error_impl(&dword_22231A000, v7, OS_LOG_TYPE_ERROR, "Error registering for Sig Info events: %s (0x%x)", (uint8_t *)&v10, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c121_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver27sendIndRegisterRequest_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c121_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver27sendIndRegisterRequest_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D03E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D03E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas18IndicationRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  cast_message_type<nas::IndicationRegister::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2224CA3CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN32Mav20SignalStrengthCommandDriver21bindSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 4))
  {
    char v3 = *(uint64_t **)(a1 + 32);
    uint64_t v4 = *v3;
    unsigned int v5 = *((_DWORD *)v3 + 2);
    if (v5 - 1 >= 3) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = v5;
    }
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = qmi::asString();
      int v9 = *(_DWORD *)(a2 + 4);
      int v10 = 136315394;
      uint64_t v11 = v8;
      __int16 v12 = 1024;
      int v13 = v9;
      _os_log_error_impl(&dword_22231A000, v7, OS_LOG_TYPE_ERROR, "Error binding subscription: %s (0x%x)", (uint8_t *)&v10, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D0460;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D0460;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  cast_message_type<nas::BindSubscription::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2224CA5D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<InputThresholds>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D04B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<InputThresholds>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D04B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_emplace<InputThresholds>::__on_zero_shared(uint64_t a1)
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN32Mav20SignalStrengthCommandDriver22getSignalStrength_syncENS_16SubscriptionTypeEbE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  __p[3] = *(void **)MEMORY[0x263EF8340];
  char v3 = *(uint64_t **)(a1 + 32);
  uint64_t v4 = *v3;
  if (*((_DWORD *)a2 + 1))
  {
    unsigned int v5 = *((_DWORD *)v3 + 2);
    if (v5 - 1 >= 3) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = v5;
    }
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v36 = (void *)qmi::asString();
      int v37 = *((_DWORD *)a2 + 1);
      LODWORD(__p[0]) = 136315394;
      *(void **)((char *)__p + 4) = v36;
      WORD2(__p[1]) = 1024;
      *(_DWORD *)((char *)&__p[1] + 6) = v37;
      _os_log_error_impl(&dword_22231A000, v7, OS_LOG_TYPE_ERROR, "getSignalStrength: Error in response with code = %s (0x%x)", (uint8_t *)__p, 0x12u);
    }
    if (!*((unsigned char *)v3 + 12) && *((_DWORD *)a2 + 1) != 74) {
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v4 + 88) + 24))(*(void *)(v4 + 88), 1, 3);
    }
  }
  else
  {
    LODWORD(v8) = *((_DWORD *)v3 + 2);
    uint64_t v40 = 0;
    v41 = 0;
    parseInputs(a2, &v40);
    if (*(void *)(v40 + 16))
    {
      uint64_t v9 = (v8 - 1) >= 3 ? 0 : v8;
      uint64_t v10 = *(void *)(v4 + 88);
      uint64_t v38 = v40;
      int v39 = v41;
      uint64_t v40 = 0;
      v41 = 0;
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v10 + 32))(v10, v9, &v38);
      if (v39) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v39);
      }
    }
    if ((v8 - 1) >= 3) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = v8;
    }
    uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
    int v13 = TlvValue;
    if (TlvValue)
    {
      int v14 = v12;
      __p[0] = TlvValue;
      char v15 = tlv::parseV<nas::tlv::LinkQuality>((unint64_t *)__p, v12);
      if (__p[0])
      {
        if (v15 == 1) {
          uint64_t v16 = 100;
        }
        else {
          uint64_t v16 = 50;
        }
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v4 + 88) + 40))(*(void *)(v4 + 88), v8, v16);
      }
      else
      {
        ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 160, v13, v14);
      }
    }
    uint64_t v17 = (void *)qmi::MessageBase::findTlvValue(a2);
    int v19 = v17;
    if (v17)
    {
      int v20 = v18;
      __p[0] = v17;
      unsigned __int8 v21 = tlv::parseV<nas::tlv::DataLinkQuality>((unint64_t *)__p, v18);
      if (__p[0])
      {
        uint64_t v22 = v21;
        if (v21 != 10 && v21 != 100 && v21 != 50) {
          uint64_t v22 = 50;
        }
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v4 + 88) + 40))(*(void *)(v4 + 88), v8, v22);
      }
      else
      {
        ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 162, v19, v20);
      }
    }
    int v23 = (char *)qmi::MessageBase::findTlvValue(a2);
    int v25 = v23;
    if (v23)
    {
      int v26 = v24;
      uint64_t v44 = 0;
      uint64_t v45 = v23;
      uint64_t v42 = 0;
      long long v43 = 0;
      tlv::parseV<nas::tlv::EnhancedVoiceLinkQuality>(&v45, v24, &v42);
      uint64_t v27 = v45;
      if (v45)
      {
        uint64_t v28 = *(void *)(v4 + 88);
        memset(__p, 0, 24);
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(__p, v42, (uint64_t)v43, v43 - (unsigned char *)v42);
        (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v28 + 56))(v28, v8, __p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
      }
      if (v42)
      {
        long long v43 = v42;
        operator delete(v42);
      }
      if (v27) {
        int v29 = 0;
      }
      else {
        int v29 = ((uint64_t (*)(void, uint64_t, char *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 164, v25, v26) ^ 1;
      }
    }
    else
    {
      int v29 = 1;
    }
    int v30 = (void *)qmi::MessageBase::findTlvValue(a2);
    int v32 = v30;
    if (v30)
    {
      int v33 = v31;
      __p[0] = v30;
      unsigned __int8 v34 = tlv::parseV<nas::tlv::VoiceLinkQuality>((unint64_t *)__p, v31);
      if (__p[0])
      {
        if (v29)
        {
          uint64_t v35 = v34;
          if (v34 != 10 && v34 != 100 && v34 != 50) {
            uint64_t v35 = 50;
          }
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v4 + 88) + 48))(*(void *)(v4 + 88), v8, v35);
        }
      }
      else
      {
        ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 163, v32, v33);
      }
    }
    if (v41) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v41);
    }
  }
}

void sub_2224CAB00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c117_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver22getSignalStrength_syncEN3qmi16SubscriptionTypeEbE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c117_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver22getSignalStrength_syncEN3qmi16SubscriptionTypeEbE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::getSignalStrength_sync(qmi::SubscriptionType,BOOL)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::getSignalStrength_sync(qmi::SubscriptionType,BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D0530;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::getSignalStrength_sync(qmi::SubscriptionType,BOOL)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::getSignalStrength_sync(qmi::SubscriptionType,BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D0530;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas10GetSigInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224CACD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::LinkQualityIndicator>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::LinkQualityIndicator>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 9;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::LinkQualityIndicator>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LinkQualityIndicator>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LinkQualityIndicator>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::LinkQualityIndicator>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LinkQualityIndicator>::clone()
{
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN32Mav20SignalStrengthCommandDriver18setThresholds_syncENS_16SubscriptionTypeENSt3__110shared_ptrIK15InputThresholdsEE21SignalStrengthCmdTypeE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  char v3 = *(uint64_t **)(a1 + 32);
  uint64_t v4 = *v3;
  unsigned int v5 = *((_DWORD *)v3 + 2);
  if (v5 - 1 >= 3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v5;
  }
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), v6);
  if (!*(_DWORD *)(a2 + 4))
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v13) = 0;
      _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#I sendNewThresholds: Updated thresholds", (uint8_t *)&v13, 2u);
    }
    int v9 = *((_DWORD *)v3 + 3);
    if (v9 == 1)
    {
      uint64_t v10 = *(void (**)(void))(**(void **)(v4 + 88) + 16);
    }
    else
    {
      if (v9) {
        goto LABEL_15;
      }
      uint64_t v10 = *(void (**)(void))(**(void **)(v4 + 88) + 16);
    }
    v10();
LABEL_15:
    Mav20SignalStrengthCommandDriver::getSignalStrength_sync();
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    uint64_t v11 = qmi::asString();
    int v12 = *(_DWORD *)(a2 + 4);
    int v13 = 136315394;
    uint64_t v14 = v11;
    __int16 v15 = 1024;
    int v16 = v12;
    _os_log_error_impl(&dword_22231A000, v7, OS_LOG_TYPE_ERROR, "setThresholds: Error in response with code = %s (0x%x)", (uint8_t *)&v13, 0x12u);
  }
  return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(v4 + 88) + 24))(*(void *)(v4 + 88), v6, *((unsigned int *)v3 + 3));
}

uint64_t __copy_helper_block_e8_32c160_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver18setThresholds_syncEN3qmi16SubscriptionTypeENS0_IK15InputThresholdsEE21SignalStrengthCmdTypeE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c160_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver18setThresholds_syncEN3qmi16SubscriptionTypeENS0_IK15InputThresholdsEE21SignalStrengthCmdTypeE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::setThresholds_sync(qmi::SubscriptionType,std::shared_ptr<InputThresholds const>,SignalStrengthCmdType)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::setThresholds_sync(qmi::SubscriptionType,std::shared_ptr<InputThresholds const>,SignalStrengthCmdType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D0600;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::setThresholds_sync(qmi::SubscriptionType,std::shared_ptr<InputThresholds const>,SignalStrengthCmdType)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::setThresholds_sync(qmi::SubscriptionType,std::shared_ptr<InputThresholds const>,SignalStrengthCmdType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D0600;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas14ConfigSigInfo28ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __n128 __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224CB328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t VocoderInfo::asString@<X0>(VocoderInfo *this@<X0>, void *a2@<X8>)
{
  uint64_t v24 = 0;
  long long v22 = 0u;
  memset(v23, 0, sizeof(v23));
  *(_OWORD *)__n128 __p = 0u;
  long long v21 = 0u;
  memset(v19, 0, sizeof(v19));
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v19);
  uint64_t v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"Vocoder Type: ", 14);
  unsigned int v5 = *(_DWORD *)this - 1;
  if (v5 > 0x11) {
    uint64_t v6 = "kAudioVocoderQCELP13";
  }
  else {
    uint64_t v6 = off_264610550[v5];
  }
  size_t v7 = strlen(v6);
  uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)v6, v7);
  std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(void *)(*v8 - 24)));
  int v9 = std::locale::use_facet(&v25, MEMORY[0x263F8C108]);
  ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
  std::locale::~locale(&v25);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"Sample Rate: ", 13);
  uint64_t v10 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(void *)(*v10 - 24)));
  uint64_t v11 = std::locale::use_facet(&v25, MEMORY[0x263F8C108]);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v25);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"I2S Clock Rate: ", 16);
  int v12 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  int v13 = std::locale::use_facet(&v25, MEMORY[0x263F8C108]);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v25);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"EVS Downlink Bandwidth: ", 24);
  uint64_t v14 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24)));
  __int16 v15 = std::locale::use_facet(&v25, MEMORY[0x263F8C108]);
  ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
  std::locale::~locale(&v25);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"EVS Uplink Bandwidth: ", 22);
  int v16 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(void *)(*v16 - 24)));
  uint64_t v17 = std::locale::use_facet(&v25, MEMORY[0x263F8C108]);
  ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
  std::locale::~locale(&v25);
  std::ostream::put();
  std::ostream::flush();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v19 + 8, a2);
  *(void *)&v19[0] = *MEMORY[0x263F8C2C8];
  *(void *)((char *)v19 + *(void *)(*(void *)&v19[0] - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v19[0] + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x223C9A8E0](v23);
}

void sub_2224CB7F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::locale::~locale((std::locale *)(v9 - 56));
  std::ostringstream::~ostringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

std::string *AudioStats::fillTopUsedBitRates(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(std::string **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  unint64_t v6 = (v5 - *(void *)a2) >> 5;
  if (v6 >= 3) {
    unint64_t v6 = 3;
  }
  if (v6)
  {
    std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<void> &,std::__wrap_iter<std::pair<unsigned int,std::string> *>,std::__wrap_iter<std::pair<unsigned int,std::string> *>>((uint64_t)result, (uint64_t)result + 32 * v6, v5, (uint64_t)&v8);
    uint64_t result = *(std::string **)a2;
    uint64_t v5 = *(void *)(a2 + 8);
  }
  if ((std::string *)v5 == result)
  {
    uint64_t v5 = (uint64_t)result;
  }
  else if (LODWORD(result->__r_.__value_.__l.__data_))
  {
    std::string::operator=((std::string *)(a1 + 64), (const std::string *)&result->__r_.__value_.__r.__words[1]);
    uint64_t result = *(std::string **)a2;
    uint64_t v5 = *(void *)(a2 + 8);
  }
  unint64_t v7 = v5 - (void)result;
  if ((unint64_t)(v5 - (void)result) >= 0x21)
  {
    if (LODWORD(result[1].__r_.__value_.__r.__words[1]))
    {
      std::string::operator=((std::string *)(a1 + 88), (std::string *)((char *)result + 40));
      uint64_t result = *(std::string **)a2;
      unint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
    }
    if (v7 >= 0x41)
    {
      if (LODWORD(result[2].__r_.__value_.__r.__words[2])) {
        return std::string::operator=((std::string *)(a1 + 112), result + 3);
      }
    }
  }
  return result;
}

uint64_t AudioStats::fillDistortionDurMetrics(uint64_t result, int **a2, int a3)
{
  BOOL v3 = a3 != 0;
  *(_DWORD *)(result + 204) = v3;
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    unint64_t v6 = v4 + 4;
    unint64_t v7 = *a2;
    if (v4 + 4 != v5)
    {
      unint64_t v7 = *a2;
      do
      {
        if (*v7 >= *v6) {
          char v8 = 1;
        }
        else {
          char v8 = -1;
        }
        if (*v7 == *v6)
        {
          unint64_t v9 = *((void *)v7 + 1);
          unint64_t v10 = *((void *)v6 + 1);
          BOOL v11 = v9 == v10;
          char v8 = v9 >= v10 ? 1 : -1;
          if (v11) {
            char v8 = 0;
          }
        }
        if (v8 < 0) {
          unint64_t v7 = v6;
        }
        v6 += 4;
      }
      while (v6 != v5);
    }
    int v12 = *v7;
    if (*v7 >= 0x105)
    {
      *(void *)(result + 208) = *((void *)v7 + 1);
      *(_DWORD *)(result + 216) = v12;
    }
    int v13 = 0;
    do
    {
      int v14 = *v4;
      v4 += 4;
      if (v14) {
        ++v13;
      }
    }
    while (v4 != v5);
    *(_DWORD *)(result + 204) = v13 + v3;
  }
  return result;
}

uint64_t std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<void> &,std::__wrap_iter<std::pair<unsigned int,std::string> *>,std::__wrap_iter<std::pair<unsigned int,std::string> *>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v6 = a2;
    uint64_t v8 = a2 - a1;
    uint64_t v9 = (a2 - a1) >> 5;
    if (a2 - a1 >= 33)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      int v12 = (unsigned int *)(a1 + 32 * v10);
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<void> &,std::__wrap_iter<std::pair<unsigned int,std::string> *>>(a1, a4, v9, v12);
        v12 -= 8;
        --v11;
      }
      while (v11);
    }
    if (v6 == a3)
    {
      a3 = v6;
    }
    else
    {
      int v13 = (_OWORD *)(a1 + 8);
      uint64_t v14 = v6;
      do
      {
        if (*(_DWORD *)v14 < *(_DWORD *)a1) {
          int v15 = -1;
        }
        else {
          int v15 = 1;
        }
        if (*(_DWORD *)v14 == *(_DWORD *)a1) {
          int v15 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)(v14 + 8), (void **)(a1 + 8));
        }
        if (v15 << 24 >= 1)
        {
          int v16 = *(_DWORD *)v14;
          *(_DWORD *)uint64_t v14 = *(_DWORD *)a1;
          *(_DWORD *)a1 = v16;
          uint64_t v17 = *(void *)(v14 + 24);
          long long v18 = *(_OWORD *)(v14 + 8);
          uint64_t v19 = *(void *)(a1 + 24);
          *(_OWORD *)(v14 + 8) = *v13;
          *(void *)(v14 + 24) = v19;
          *int v13 = v18;
          *(void *)(a1 + 24) = v17;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<void> &,std::__wrap_iter<std::pair<unsigned int,std::string> *>>(a1, a4, v9, (unsigned int *)a1);
        }
        v14 += 32;
      }
      while (v14 != a3);
    }
    if (v8 >= 33)
    {
      unint64_t v20 = (unint64_t)v8 >> 5;
      do
      {
        std::__pop_heap[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<void>,std::__wrap_iter<std::pair<unsigned int,std::string> *>>((int *)a1, v6, a4, v20);
        v6 -= 32;
      }
      while (v20-- > 2);
    }
  }
  return a3;
}

__n128 std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<void> &,std::__wrap_iter<std::pair<unsigned int,std::string> *>>(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  unint64_t v6 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v32 = v4;
    uint64_t v33 = v5;
    unint64_t v7 = a4;
    uint64_t v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= ((uint64_t)a4 - a1) >> 5)
    {
      uint64_t v11 = ((uint64_t)a4 - a1) >> 4;
      uint64_t v12 = v11 | 1;
      int v13 = (unsigned int *)(a1 + 32 * (v11 | 1));
      uint64_t v14 = v11 + 2;
      if (v11 + 2 < a3)
      {
        unsigned int v15 = v13[8];
        if (*v13 < v15) {
          int v16 = -1;
        }
        else {
          int v16 = 1;
        }
        if (*v13 == v15) {
          int v16 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)(a1 + 32 * v12 + 8), (void **)v13 + 5);
        }
        if (v16 << 24 > 0)
        {
          v13 += 8;
          uint64_t v12 = v14;
        }
      }
      if (*v13 < *v7) {
        int v18 = -1;
      }
      else {
        int v18 = 1;
      }
      if (*v13 == *v7) {
        int v18 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)v13 + 1, (void **)v7 + 1);
      }
      if (v18 << 24 <= 0)
      {
        unsigned int v29 = *v7;
        uint64_t v19 = *((void *)v7 + 3);
        __n128 v30 = *(__n128 *)(v7 + 2);
        uint64_t v31 = v19;
        *((void *)v7 + 2) = 0;
        *((void *)v7 + 3) = 0;
        *((void *)v7 + 1) = 0;
        do
        {
          unint64_t v20 = v7;
          unint64_t v7 = v13;
          *unint64_t v20 = *v13;
          long long v21 = v20 + 2;
          if (*((char *)v20 + 31) < 0) {
            operator delete(*(void **)v21);
          }
          long long v22 = (void **)(v13 + 2);
          long long v23 = *(_OWORD *)(v13 + 2);
          *((void *)v21 + 2) = *((void *)v13 + 3);
          *(_OWORD *)long long v21 = v23;
          *((unsigned char *)v13 + 31) = 0;
          *((unsigned char *)v13 + 8) = 0;
          if (v9 < v12)
          {
            *int v13 = v29;
            goto LABEL_40;
          }
          uint64_t v24 = (2 * v12) | 1;
          int v13 = (unsigned int *)(a1 + 32 * v24);
          uint64_t v12 = 2 * v12 + 2;
          if (v12 >= a3)
          {
            uint64_t v12 = v24;
          }
          else
          {
            unsigned int v25 = v13[8];
            if (*v13 < v25) {
              int v26 = -1;
            }
            else {
              int v26 = 1;
            }
            if (*v13 == v25) {
              int v26 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)(a1 + 32 * v24 + 8), (void **)v13 + 5);
            }
            if (v26 << 24 <= 0) {
              uint64_t v12 = v24;
            }
            else {
              v13 += 8;
            }
          }
          if (*v13 < v29) {
            int v27 = -1;
          }
          else {
            int v27 = 1;
          }
          if (*v13 == v29) {
            int v27 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)v13 + 1, (void **)&v30);
          }
        }
        while (v27 << 24 < 1);
        int v28 = *((char *)v7 + 31);
        *unint64_t v7 = v29;
        if (v28 < 0) {
          operator delete(*v22);
        }
LABEL_40:
        __n128 result = v30;
        *((void *)v7 + 3) = v31;
        *(__n128 *)long long v22 = result;
      }
    }
  }
  return result;
}

__n128 std::__pop_heap[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<void>,std::__wrap_iter<std::pair<unsigned int,std::string> *>>(int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v39[2] = *MEMORY[0x263EF8340];
  if (a4 >= 2)
  {
    uint64_t v7 = 0;
    int v33 = *a1;
    uint64_t v34 = *((void *)a1 + 1);
    v39[0] = *((void *)a1 + 2);
    *(void *)((char *)v39 + 7) = *(void *)((char *)a1 + 23);
    char v35 = *((unsigned char *)a1 + 31);
    *((void *)a1 + 2) = 0;
    *((void *)a1 + 3) = 0;
    *((void *)a1 + 1) = 0;
    int64_t v8 = (unint64_t)(a4 - 2) >> 1;
    uint64_t v9 = a1;
    do
    {
      uint64_t v10 = v7 + 1;
      uint64_t v11 = (unsigned int *)&v9[8 * v7 + 8];
      uint64_t v12 = (2 * v7) | 1;
      uint64_t v7 = 2 * v7 + 2;
      if (v7 >= a4)
      {
        *uint64_t v9 = *v11;
        int v16 = (__n128 *)(v9 + 2);
        uint64_t v7 = v12;
        uint64_t v9 = (int *)v11;
      }
      else
      {
        uint64_t v14 = (int *)(v11 + 8);
        unsigned int v13 = v11[8];
        if (*v11 < v13) {
          int v15 = -1;
        }
        else {
          int v15 = 1;
        }
        if (*v11 == v13)
        {
          int v15 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v9[8 * v10 + 2], (void **)v11 + 5);
          char v17 = *((unsigned char *)v9 + 31);
        }
        else
        {
          char v17 = 0;
        }
        if (v15 << 24 <= 0)
        {
          uint64_t v14 = (int *)v11;
          uint64_t v7 = v12;
        }
        *uint64_t v9 = v11[8 * (v15 << 24 > 0)];
        int v18 = (void **)(v9 + 2);
        if (v17 < 0) {
          operator delete(*v18);
        }
        int v16 = (__n128 *)v18;
        uint64_t v9 = v14;
      }
      __n128 result = *(__n128 *)(v9 + 2);
      v16[1].n128_u64[0] = *((void *)v9 + 3);
      *int v16 = result;
      *((unsigned char *)v9 + 31) = 0;
      *((unsigned char *)v9 + 8) = 0;
    }
    while (v7 <= v8);
    if ((int *)(a2 - 32) == v9)
    {
      *uint64_t v9 = v33;
      *((void *)v9 + 1) = v34;
      *((void *)v9 + 2) = v39[0];
      *(void *)((char *)v9 + 23) = *(void *)((char *)v39 + 7);
      *((unsigned char *)v9 + 31) = v35;
    }
    else
    {
      unint64_t v20 = (__n128 *)(v9 + 2);
      *uint64_t v9 = *(_DWORD *)(a2 - 32);
      __n128 result = *(__n128 *)(a2 - 24);
      *((void *)v9 + 3) = *(void *)(a2 - 8);
      *(__n128 *)(v9 + 2) = result;
      *(_DWORD *)(a2 - 32) = v33;
      uint64_t v21 = v39[0];
      *(void *)(a2 - 24) = v34;
      *(void *)(a2 - 16) = v21;
      *(void *)(a2 - 9) = *(void *)((char *)v39 + 7);
      *(unsigned char *)(a2 - 1) = v35;
      uint64_t v22 = (char *)v9 - (char *)a1 + 32;
      if (v22 >= 33)
      {
        unint64_t v23 = (((unint64_t)v22 >> 5) - 2) >> 1;
        uint64_t v24 = &a1[8 * v23];
        if (*v24 < *v9) {
          int v25 = -1;
        }
        else {
          int v25 = 1;
        }
        if (*v24 == *v9) {
          int v25 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)v24 + 1, (void **)v9 + 1);
        }
        if (v25 << 24 >= 1)
        {
          unsigned int v36 = *v9;
          __n128 v26 = *v20;
          uint64_t v38 = *((void *)v9 + 3);
          __n128 v37 = v26;
          *((void *)v9 + 2) = 0;
          *((void *)v9 + 3) = 0;
          v20->n128_u64[0] = 0;
          do
          {
            int v27 = v24;
            *uint64_t v9 = *v24;
            int v28 = (void **)(v9 + 2);
            if (*((char *)v9 + 31) < 0) {
              operator delete(*v28);
            }
            unsigned int v29 = (void **)(v27 + 2);
            long long v30 = *(_OWORD *)(v27 + 2);
            *((void *)v9 + 3) = *((void *)v27 + 3);
            *(_OWORD *)int v28 = v30;
            *((unsigned char *)v27 + 31) = 0;
            *((unsigned char *)v27 + 8) = 0;
            if (!v23)
            {
              *int v27 = v36;
              goto LABEL_39;
            }
            unint64_t v23 = (v23 - 1) >> 1;
            uint64_t v24 = &a1[8 * v23];
            if (*v24 < v36) {
              int v31 = -1;
            }
            else {
              int v31 = 1;
            }
            if (*v24 == v36) {
              int v31 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)v24 + 1, (void **)&v37);
            }
            uint64_t v9 = v27;
          }
          while (v31 << 24 > 0);
          int v32 = *((char *)v27 + 31);
          *int v27 = v36;
          if (v32 < 0) {
            operator delete(*v29);
          }
LABEL_39:
          __n128 result = v37;
          *((void *)v27 + 3) = v38;
          *(__n128 *)unsigned int v29 = result;
        }
      }
    }
  }
  return result;
}

uint64_t subscriber::simSlotAsSubType(uint64_t result)
{
  if ((result - 1) >= 3) {
    return 0;
  }
  else {
    return result;
  }
}

uint64_t boost::bimaps::bimap<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::~bimap(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 24) + 32);
  if ((v2 & 0xFFFFFFFFFFFFFFFELL) != 0) {
    BOOL v3 = (void *)((v2 & 0xFFFFFFFFFFFFFFFELL) - 32);
  }
  else {
    BOOL v3 = 0;
  }
  boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::delete_all_nodes(v3);
  operator delete(*(void **)(a1 + 24));
  return a1;
}

unint64_t *initProactiveCommandMap(void)
{
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 1, 1u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 2, 2u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 3, 3u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 4, 4u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 5, 5u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 6, 6u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 7, 7u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 8, 8u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 9, 9u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 10, 0xAu);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 11, 0xBu);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 12, 0xCu);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 13, 0xDu);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 14, 0xEu);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 15, 0xFu);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 16, 0x10u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 17, 0x11u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 18, 0x12u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 19, 0x13u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 21, 0x14u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 22, 0x15u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A168 - 16), 23, 0x16u);
  v0 = (unint64_t *)(qword_26AB7A168 - 16);

  return boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>(v0, 24, 0x17u);
}

uint64_t getProactiveCommand(unsigned int a1)
{
  pthread_once(&proactiveCommandMapOnce, (void (*)(void))initProactiveCommandMap);
  uint64_t v2 = *(void *)(qword_26AB7A198 - 8);
  unint64_t v3 = *(void *)(v2 + 32) & 0xFFFFFFFFFFFFFFFELL;
  if (!v3) {
    goto LABEL_9;
  }
  uint64_t v4 = *(unsigned __int8 **)(qword_26AB7A198 - 8);
  do
  {
    while (*(unsigned __int8 *)(v3 - 28) < a1)
    {
      unint64_t v3 = *(void *)(v3 + 16);
      if (!v3) {
        goto LABEL_7;
      }
    }
    uint64_t v4 = (unsigned __int8 *)(v3 - 32);
    unint64_t v3 = *(void *)(v3 + 8);
  }
  while (v3);
LABEL_7:
  if (v4 == (unsigned __int8 *)v2 || v4[4] > a1)
  {
LABEL_9:
    __TUAssertTrigger();
    uint64_t v4 = (unsigned __int8 *)v2;
  }
  return *(unsigned int *)v4;
}

uint64_t std::map<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>::~map[abi:ne180100](uint64_t a1)
{
  return a1;
}

uint64_t getQMI_ProactiveCommand_TerminalResponse(int a1)
{
  pthread_once(&proactiveCommand_TR_MapOnce, (void (*)(void))initProactiveCommand_TR_Map);
  uint64_t v2 = qword_26AB7A150;
  if (!qword_26AB7A150) {
    goto LABEL_11;
  }
  unint64_t v3 = &qword_26AB7A150;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      unint64_t v6 = (uint64_t *)v2;
    }
    else {
      unint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      unint64_t v3 = (uint64_t *)v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == &qword_26AB7A150 || *((_DWORD *)v3 + 7) > a1)
  {
LABEL_11:
    __TUAssertTrigger();
    unint64_t v3 = &qword_26AB7A150;
  }
  return *((unsigned __int8 *)v3 + 32);
}

uint64_t *initProactiveCommand_TR_Map(void)
{
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)1, 1, 1);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)2, 2, 2);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)3, 3, 3);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)4, 4, 4);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)5, 5, 5);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)6, 6, 6);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)7, 7, 17);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0xA, 10, 18);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0xB, 11, 18);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0xC, 12, 7);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0xD, 13, 8);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0xE, 14, 9);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0x11, 17, 10);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0x12, 18, 11);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0x13, 19, 12);

  return std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0x10, 16, 13);
}

uint64_t boost::bimaps::bimap<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::~bimap(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 24) + 32);
  if ((v2 & 0xFFFFFFFFFFFFFFFELL) != 0) {
    unint64_t v3 = (void *)((v2 & 0xFFFFFFFFFFFFFFFELL) - 32);
  }
  else {
    unint64_t v3 = 0;
  }
  boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::delete_all_nodes(v3);
  operator delete(*(void **)(a1 + 24));
  return a1;
}

uint64_t getQMINotificationResponse(int a1)
{
  pthread_once(&notificationResponseMapOnce, (void (*)(void))initNotificationResponseMap);
  uint64_t v2 = *(void *)(qword_26AB7A1D0 - 8);
  unint64_t v3 = *(void *)(v2 + 8) & 0xFFFFFFFFFFFFFFFELL;
  if (!v3) {
    goto LABEL_9;
  }
  int v4 = *(_DWORD **)(qword_26AB7A1D0 - 8);
  do
  {
    while (*(_DWORD *)(v3 - 8) < a1)
    {
      unint64_t v3 = *(void *)(v3 + 16);
      if (!v3) {
        goto LABEL_7;
      }
    }
    int v4 = (_DWORD *)(v3 - 8);
    unint64_t v3 = *(void *)(v3 + 8);
  }
  while (v3);
LABEL_7:
  if (v4 == (_DWORD *)v2 || *v4 > a1)
  {
LABEL_9:
    __TUAssertTrigger();
    int v4 = (_DWORD *)v2;
  }
  return v4[1];
}

unint64_t *initNotificationResponseMap(void)
{
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1A8 - 16), 0, 0);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1A8 - 16), 1, 4);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1A8 - 16), 2, 16);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1A8 - 16), 3, 17);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1A8 - 16), 4, 18);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1A8 - 16), 5, 19);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1A8 - 16), 6, 32);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1A8 - 16), 7, 33);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1A8 - 16), 8, 34);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1A8 - 16), 9, 48);
  v0 = (unint64_t *)(qword_26AB7A1A8 - 16);

  return boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>(v0, 10, 53);
}

uint64_t boost::bimaps::bimap<NotificationAdditionalResponse,tr::AdditionalResponse,mpl_::na,mpl_::na,mpl_::na>::~bimap(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 24) + 32);
  if ((v2 & 0xFFFFFFFFFFFFFFFELL) != 0) {
    unint64_t v3 = (void *)((v2 & 0xFFFFFFFFFFFFFFFELL) - 32);
  }
  else {
    unint64_t v3 = 0;
  }
  boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::delete_all_nodes(v3);
  operator delete(*(void **)(a1 + 24));
  return a1;
}

uint64_t getQMINotificationAdditionalResponse(int a1)
{
  pthread_once(&notificationAdditionalResponseMapOnce, (void (*)(void))initNotificationAdditionalResponseMap);
  uint64_t v2 = *(void *)(qword_26AB7A210 - 8);
  unint64_t v3 = *(void *)(v2 + 8) & 0xFFFFFFFFFFFFFFFELL;
  if (!v3) {
    goto LABEL_9;
  }
  int v4 = *(_DWORD **)(qword_26AB7A210 - 8);
  do
  {
    while (*(_DWORD *)(v3 - 8) < a1)
    {
      unint64_t v3 = *(void *)(v3 + 16);
      if (!v3) {
        goto LABEL_7;
      }
    }
    int v4 = (_DWORD *)(v3 - 8);
    unint64_t v3 = *(void *)(v3 + 8);
  }
  while (v3);
LABEL_7:
  if (v4 == (_DWORD *)v2 || *v4 > a1)
  {
LABEL_9:
    __TUAssertTrigger();
    int v4 = (_DWORD *)v2;
  }
  return v4[1];
}

unint64_t *initNotificationAdditionalResponseMap(void)
{
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1E8 - 16), 0, 0);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1E8 - 16), 1, 1);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1E8 - 16), 2, 2);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1E8 - 16), 3, 4);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1E8 - 16), 4, 5);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1E8 - 16), 5, 6);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1E8 - 16), 6, 7);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A1E8 - 16), 7, 9);
  v0 = (unint64_t *)(qword_26AB7A1E8 - 16);

  return boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>(v0, 8, 10);
}

uint64_t boost::bimaps::bimap<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::~bimap(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 24) + 32);
  if ((v2 & 0xFFFFFFFFFFFFFFFELL) != 0) {
    unint64_t v3 = (void *)((v2 & 0xFFFFFFFFFFFFFFFELL) - 32);
  }
  else {
    unint64_t v3 = 0;
  }
  boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::delete_all_nodes(v3);
  operator delete(*(void **)(a1 + 24));
  return a1;
}

uint64_t getQMIDataCodingScheme(unsigned int a1)
{
  pthread_once(&dataCodingSchemeMapOnce, (void (*)(void))initDataCodingSchemeMap);
  uint64_t v2 = *(unsigned __int8 **)(qword_26AB7A250 - 8);
  unint64_t v3 = *((void *)v2 + 1) & 0xFFFFFFFFFFFFFFFELL;
  if (!v3) {
    goto LABEL_9;
  }
  int v4 = *(unsigned __int8 **)(qword_26AB7A250 - 8);
  do
  {
    while (*(unsigned __int8 *)(v3 - 8) < a1)
    {
      unint64_t v3 = *(void *)(v3 + 16);
      if (!v3) {
        goto LABEL_7;
      }
    }
    int v4 = (unsigned __int8 *)(v3 - 8);
    unint64_t v3 = *(void *)(v3 + 8);
  }
  while (v3);
LABEL_7:
  if (v4 == v2 || *v4 > a1)
  {
LABEL_9:
    __TUAssertTrigger();
    int v4 = v2;
  }
  return v4[1];
}

unint64_t *initDataCodingSchemeMap(void)
{
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A228 - 16), 1u, 0);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_26AB7A228 - 16), 2u, 1u);
  v0 = (unint64_t *)(qword_26AB7A228 - 16);

  return boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>(v0, 3u, 2u);
}

uint64_t getDataCodingScheme(unsigned int a1)
{
  pthread_once(&dataCodingSchemeMapOnce, (void (*)(void))initDataCodingSchemeMap);
  uint64_t v2 = *(void *)(qword_26AB7A258 - 8);
  unint64_t v3 = *(void *)(v2 + 32) & 0xFFFFFFFFFFFFFFFELL;
  if (!v3) {
    goto LABEL_9;
  }
  int v4 = *(unsigned __int8 **)(qword_26AB7A258 - 8);
  do
  {
    while (*(unsigned __int8 *)(v3 - 31) < a1)
    {
      unint64_t v3 = *(void *)(v3 + 16);
      if (!v3) {
        goto LABEL_7;
      }
    }
    int v4 = (unsigned __int8 *)(v3 - 32);
    unint64_t v3 = *(void *)(v3 + 8);
  }
  while (v3);
LABEL_7:
  if (v4 == (unsigned __int8 *)v2 || v4[1] > a1)
  {
LABEL_9:
    __TUAssertTrigger();
    int v4 = (unsigned __int8 *)v2;
  }
  return *v4;
}

void boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::delete_all_nodes(void *a1)
{
  if (a1)
  {
    uint64_t v2 = a1[5];
    if (v2) {
      uint64_t v3 = v2 - 32;
    }
    else {
      uint64_t v3 = 0;
    }
    boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::delete_all_nodes(v3);
    uint64_t v4 = a1[6];
    if (v4) {
      uint64_t v5 = v4 - 32;
    }
    else {
      uint64_t v5 = 0;
    }
    boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::delete_all_nodes(v5);
    operator delete(a1);
  }
}

unint64_t *boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>(unint64_t *result, int a2, unsigned __int8 a3)
{
  uint64_t v4 = result;
  unsigned int v5 = a3;
  unint64_t v6 = (void *)result[1];
  uint64_t v7 = v6;
  unint64_t v8 = v6[4] & 0xFFFFFFFFFFFFFFFELL;
  if (!v8) {
    goto LABEL_7;
  }
  do
  {
    uint64_t v7 = (void *)(v8 - 32);
    unsigned int v9 = *(unsigned __int8 *)(v8 - 28);
    if (v9 <= a3) {
      uint64_t v10 = 6;
    }
    else {
      uint64_t v10 = 5;
    }
    unint64_t v8 = v7[v10];
  }
  while (v8);
  if (v9 <= a3)
  {
    int v14 = 1;
    int v15 = v7;
  }
  else
  {
LABEL_7:
    uint64_t v11 = v6[5];
    if (v11) {
      uint64_t v12 = (void *)(v11 - 32);
    }
    else {
      uint64_t v12 = 0;
    }
    unsigned int v13 = v7 + 4;
    if (v7 == v12)
    {
      int v14 = 0;
      goto LABEL_18;
    }
    __n128 v26 = v7 + 4;
    __n128 result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::decrement((unint64_t *)&v26);
    int v14 = 0;
    if (v26) {
      int v15 = v26 - 4;
    }
    else {
      int v15 = 0;
    }
  }
  if (*((unsigned __int8 *)v15 + 4) >= v5) {
    return result;
  }
  unsigned int v13 = v7 + 4;
LABEL_18:
  int v16 = v6 + 1;
  char v17 = v6;
  unint64_t v18 = v6[1] & 0xFFFFFFFFFFFFFFFELL;
  if (!v18) {
    goto LABEL_24;
  }
  do
  {
    char v17 = (void *)(v18 - 8);
    int v19 = *(_DWORD *)(v18 - 8);
    if (v19 <= a2) {
      uint64_t v20 = 3;
    }
    else {
      uint64_t v20 = 2;
    }
    unint64_t v18 = v17[v20];
  }
  while (v18);
  if (v19 <= a2)
  {
    int v24 = 1;
  }
  else
  {
LABEL_24:
    uint64_t v21 = v6[2];
    if (v21) {
      uint64_t v22 = (void *)(v21 - 8);
    }
    else {
      uint64_t v22 = 0;
    }
    unint64_t v23 = v17 + 1;
    if (v17 == v22)
    {
      int v24 = 0;
      goto LABEL_33;
    }
    __n128 v26 = v17 + 1;
    __n128 result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::decrement((unint64_t *)&v26);
    int v24 = 0;
    int v19 = *((_DWORD *)v26 - 2);
  }
  if (v19 >= a2) {
    return result;
  }
  unint64_t v23 = v17 + 1;
LABEL_33:
  int v25 = operator new(0x38uLL);
  *(_DWORD *)int v25 = a2;
  *((unsigned char *)v25 + 4) = v5;
  boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::link((unint64_t *)v25 + 1, v24, v23, v16);
  __n128 result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::link((unint64_t *)v25 + 4, v14, v13, (unint64_t *)(v4[1] + 32));
  ++v4[3];
  return result;
}

unint64_t *boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::link(unint64_t *result, int a2, unint64_t *a3, unint64_t *a4)
{
  unsigned int v5 = result;
  if (a2)
  {
    a3[2] = (unint64_t)result;
    unint64_t v6 = a4 + 2;
    uint64_t v7 = (unint64_t *)a4[2];
    goto LABEL_5;
  }
  a3[1] = (unint64_t)result;
  if (a3 != a4)
  {
    unint64_t v6 = a4 + 1;
    uint64_t v7 = (unint64_t *)a4[1];
LABEL_5:
    if (v7 != a3) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  *a3 = *a3 & 1 | (unint64_t)result;
  unint64_t v6 = a3 + 2;
LABEL_8:
  void *v6 = result;
LABEL_9:
  result[1] = 0;
  result[2] = 0;
  unint64_t v8 = (unint64_t)a3 & 0xFFFFFFFFFFFFFFFELL;
  std::string *result = (unint64_t)a3 & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v9 = *a4 & 0xFFFFFFFFFFFFFFFELL;
  if ((unint64_t *)v9 == result) {
    goto LABEL_29;
  }
  while (1)
  {
    unint64_t v10 = *(void *)v8;
    if (*(void *)v8) {
      break;
    }
    uint64_t v11 = *(void **)((v10 & 0xFFFFFFFFFFFFFFFELL) + 8);
    if (v11 == (void *)v8)
    {
      uint64_t v11 = *(void **)((v10 & 0xFFFFFFFFFFFFFFFELL) + 16);
      if (v11 && (*(unsigned char *)v11 & 1) == 0)
      {
LABEL_18:
        *(void *)unint64_t v8 = v10 | 1;
        *v11 |= 1uLL;
        *(void *)(*(void *)(*v5 & 0xFFFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL) &= ~1uLL;
        unsigned int v5 = (unint64_t *)(*(void *)(*v5 & 0xFFFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL);
        goto LABEL_25;
      }
      if (v5 == *(unint64_t **)(v8 + 16))
      {
        int v19 = a4;
        boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::rotate_left((unint64_t *)v8, &v19);
        unsigned int v13 = (unint64_t *)(*(void *)v8 & 0xFFFFFFFFFFFFFFFELL);
        unint64_t v10 = *v13;
        unsigned int v5 = (unint64_t *)v8;
      }
      else
      {
        unsigned int v13 = (unint64_t *)v8;
        unint64_t v8 = (unint64_t)v5;
      }
      *unsigned int v13 = v10 | 1;
      *(void *)(*(void *)(*(void *)v8 & 0xFFFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL) &= ~1uLL;
      int v15 = (unint64_t *)(*(void *)(*(void *)v8 & 0xFFFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL);
      unint64_t v18 = a4;
      __n128 result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::rotate_right(v15, &v18);
    }
    else
    {
      if (v11 && (*(unsigned char *)v11 & 1) == 0) {
        goto LABEL_18;
      }
      if (v5 == *(unint64_t **)(v8 + 8))
      {
        char v17 = a4;
        boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::rotate_right((unint64_t *)v8, &v17);
        uint64_t v12 = (unint64_t *)(*(void *)v8 & 0xFFFFFFFFFFFFFFFELL);
        unint64_t v10 = *v12;
        unsigned int v5 = (unint64_t *)v8;
      }
      else
      {
        uint64_t v12 = (unint64_t *)v8;
        unint64_t v8 = (unint64_t)v5;
      }
      *uint64_t v12 = v10 | 1;
      *(void *)(*(void *)(*(void *)v8 & 0xFFFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL) &= ~1uLL;
      int v14 = (unint64_t *)(*(void *)(*(void *)v8 & 0xFFFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL);
      int v16 = a4;
      __n128 result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::rotate_left(v14, &v16);
    }
LABEL_25:
    unint64_t v9 = *a4 & 0xFFFFFFFFFFFFFFFELL;
    if (v5 == (unint64_t *)v9) {
      goto LABEL_28;
    }
    unint64_t v8 = *v5 & 0xFFFFFFFFFFFFFFFELL;
  }
  unsigned int v5 = (unint64_t *)v9;
LABEL_28:
  unint64_t v8 = *v5;
LABEL_29:
  *unsigned int v5 = v8 | 1;
  return result;
}

unint64_t *boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::decrement(unint64_t *result)
{
  uint64_t v1 = (void *)*result;
  uint64_t v2 = *(void *)*result;
  if ((v2 & 1) == 0 && v1 == (void *)(*(void *)(v2 & 0xFFFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL))
  {
    unint64_t v4 = v1[2];
  }
  else
  {
    unint64_t v3 = v1[1];
    if (v3)
    {
      do
      {
        unint64_t v4 = v3;
        unint64_t v3 = *(void *)(v3 + 16);
      }
      while (v3);
    }
    else
    {
      unint64_t v4 = v2 & 0xFFFFFFFFFFFFFFFELL;
      if (v1 == *(void **)(v4 + 8))
      {
        unsigned int v5 = (void *)v4;
        do
        {
          std::string *result = (unint64_t)v5;
          unint64_t v4 = *v5 & 0xFFFFFFFFFFFFFFFELL;
          BOOL v6 = v5 == *(void **)(v4 + 8);
          unsigned int v5 = (void *)v4;
        }
        while (v6);
      }
    }
  }
  std::string *result = v4;
  return result;
}

unint64_t *boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::rotate_left(unint64_t *result, unint64_t **a2)
{
  unint64_t v2 = result[2];
  result[2] = *(void *)(v2 + 8);
  unint64_t v3 = *(unint64_t **)(v2 + 8);
  if (v3) {
    unint64_t *v3 = *v3 & 1 | (unint64_t)result;
  }
  *(void *)unint64_t v2 = *result & 0xFFFFFFFFFFFFFFFELL | *(void *)v2 & 1;
  if ((unint64_t *)(**a2 & 0xFFFFFFFFFFFFFFFELL) == result)
  {
    **a2 = **a2 & 1 | v2;
    uint64_t v4 = *result;
  }
  else
  {
    uint64_t v4 = *result;
    unint64_t v5 = *result & 0xFFFFFFFFFFFFFFFELL;
    if (*(unint64_t **)(v5 + 8) == result) {
      *(void *)(v5 + 8) = v2;
    }
    else {
      *(void *)(v5 + 16) = v2;
    }
  }
  *(void *)(v2 + 8) = result;
  std::string *result = v4 & 1 | v2;
  return result;
}

unint64_t *boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::rotate_right(unint64_t *result, unint64_t **a2)
{
  unint64_t v2 = result[1];
  result[1] = *(void *)(v2 + 16);
  unint64_t v3 = *(unint64_t **)(v2 + 16);
  if (v3) {
    unint64_t *v3 = *v3 & 1 | (unint64_t)result;
  }
  *(void *)unint64_t v2 = *result & 0xFFFFFFFFFFFFFFFELL | *(void *)v2 & 1;
  if ((unint64_t *)(**a2 & 0xFFFFFFFFFFFFFFFELL) == result)
  {
    **a2 = **a2 & 1 | v2;
    uint64_t v4 = *result;
  }
  else
  {
    uint64_t v4 = *result;
    unint64_t v5 = *result & 0xFFFFFFFFFFFFFFFELL;
    if (*(unint64_t **)(v5 + 16) == result) {
      *(void *)(v5 + 16) = v2;
    }
    else {
      *(void *)(v5 + 8) = v2;
    }
  }
  *(void *)(v2 + 16) = result;
  std::string *result = v4 & 1 | v2;
  return result;
}

uint64_t *std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>(uint64_t *result, int a2, char a3)
{
  uint64_t v5 = qword_26AB7A150;
  if (qword_26AB7A150)
  {
    while (1)
    {
      while (1)
      {
        BOOL v6 = (uint64_t *)v5;
        int v7 = *(_DWORD *)(v5 + 28);
        if (v7 <= (int)result) {
          break;
        }
        uint64_t v5 = *v6;
        unint64_t v8 = v6;
        if (!*v6) {
          goto LABEL_9;
        }
      }
      if (v7 >= (int)result) {
        break;
      }
      uint64_t v5 = v6[1];
      if (!v5)
      {
        unint64_t v8 = v6 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unint64_t v8 = &qword_26AB7A150;
    BOOL v6 = &qword_26AB7A150;
LABEL_9:
    unint64_t v9 = operator new(0x28uLL);
    v9[7] = a2;
    *((unsigned char *)v9 + 32) = a3;
    *(void *)unint64_t v9 = 0;
    *((void *)v9 + 1) = 0;
    *((void *)v9 + 2) = v6;
    *unint64_t v8 = (uint64_t)v9;
    if (*(void *)qword_26AB7A148)
    {
      qword_26AB7A148 = *(void *)qword_26AB7A148;
      unint64_t v10 = (uint64_t *)*v8;
    }
    else
    {
      unint64_t v10 = (uint64_t *)v9;
    }
    __n128 result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)qword_26AB7A150, v10);
    ++qword_26AB7A158;
  }
  return result;
}

unint64_t *boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>(unint64_t *result, int a2, int a3)
{
  uint64_t v5 = result;
  BOOL v6 = (void *)result[1];
  int v7 = v6;
  unint64_t v8 = v6[4] & 0xFFFFFFFFFFFFFFFELL;
  if (!v8) {
    goto LABEL_7;
  }
  do
  {
    int v7 = (void *)(v8 - 32);
    int v9 = *(_DWORD *)(v8 - 28);
    if (v9 <= a3) {
      uint64_t v10 = 6;
    }
    else {
      uint64_t v10 = 5;
    }
    unint64_t v8 = v7[v10];
  }
  while (v8);
  if (v9 <= a3)
  {
    int v14 = 1;
    int v15 = v7;
  }
  else
  {
LABEL_7:
    uint64_t v11 = v6[5];
    if (v11) {
      uint64_t v12 = (void *)(v11 - 32);
    }
    else {
      uint64_t v12 = 0;
    }
    unsigned int v13 = v7 + 4;
    if (v7 == v12)
    {
      int v14 = 0;
      goto LABEL_18;
    }
    __n128 v26 = v7 + 4;
    __n128 result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::decrement((unint64_t *)&v26);
    int v14 = 0;
    if (v26) {
      int v15 = v26 - 4;
    }
    else {
      int v15 = 0;
    }
  }
  if (*((_DWORD *)v15 + 1) >= a3) {
    return result;
  }
  unsigned int v13 = v7 + 4;
LABEL_18:
  int v16 = v6 + 1;
  char v17 = v6;
  unint64_t v18 = v6[1] & 0xFFFFFFFFFFFFFFFELL;
  if (!v18) {
    goto LABEL_24;
  }
  do
  {
    char v17 = (void *)(v18 - 8);
    int v19 = *(_DWORD *)(v18 - 8);
    if (v19 <= a2) {
      uint64_t v20 = 3;
    }
    else {
      uint64_t v20 = 2;
    }
    unint64_t v18 = v17[v20];
  }
  while (v18);
  if (v19 <= a2)
  {
    int v24 = 1;
  }
  else
  {
LABEL_24:
    uint64_t v21 = v6[2];
    if (v21) {
      uint64_t v22 = (void *)(v21 - 8);
    }
    else {
      uint64_t v22 = 0;
    }
    unint64_t v23 = v17 + 1;
    if (v17 == v22)
    {
      int v24 = 0;
      goto LABEL_33;
    }
    __n128 v26 = v17 + 1;
    __n128 result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::decrement((unint64_t *)&v26);
    int v24 = 0;
    int v19 = *((_DWORD *)v26 - 2);
  }
  if (v19 >= a2) {
    return result;
  }
  unint64_t v23 = v17 + 1;
LABEL_33:
  int v25 = operator new(0x38uLL);
  *(_DWORD *)int v25 = a2;
  *((_DWORD *)v25 + 1) = a3;
  boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::link((unint64_t *)v25 + 1, v24, v23, v16);
  __n128 result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::link((unint64_t *)v25 + 4, v14, v13, (unint64_t *)(v5[1] + 32));
  ++v5[3];
  return result;
}

unint64_t *boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>(unint64_t *result, unsigned __int8 a2, unsigned __int8 a3)
{
  uint64_t v4 = result;
  unsigned int v5 = a3;
  BOOL v6 = (void *)result[1];
  int v7 = v6;
  unint64_t v8 = v6[4] & 0xFFFFFFFFFFFFFFFELL;
  if (!v8) {
    goto LABEL_7;
  }
  do
  {
    int v7 = (void *)(v8 - 32);
    unsigned int v9 = *(unsigned __int8 *)(v8 - 31);
    if (v9 <= a3) {
      uint64_t v10 = 6;
    }
    else {
      uint64_t v10 = 5;
    }
    unint64_t v8 = v7[v10];
  }
  while (v8);
  if (v9 <= a3)
  {
    int v14 = 1;
    int v15 = v7;
  }
  else
  {
LABEL_7:
    uint64_t v11 = v6[5];
    if (v11) {
      uint64_t v12 = (void *)(v11 - 32);
    }
    else {
      uint64_t v12 = 0;
    }
    unsigned int v13 = v7 + 4;
    if (v7 == v12)
    {
      int v14 = 0;
      goto LABEL_18;
    }
    int v27 = v7 + 4;
    __n128 result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::decrement((unint64_t *)&v27);
    int v14 = 0;
    if (v27) {
      int v15 = v27 - 4;
    }
    else {
      int v15 = 0;
    }
  }
  if (*((unsigned __int8 *)v15 + 1) >= v5) {
    return result;
  }
  unsigned int v13 = v7 + 4;
LABEL_18:
  unsigned int v16 = a2;
  char v17 = v6 + 1;
  unint64_t v18 = v6;
  unint64_t v19 = v6[1] & 0xFFFFFFFFFFFFFFFELL;
  if (!v19) {
    goto LABEL_24;
  }
  do
  {
    unint64_t v18 = (void *)(v19 - 8);
    unsigned int v20 = *(unsigned __int8 *)(v19 - 8);
    if (v20 <= v16) {
      uint64_t v21 = 3;
    }
    else {
      uint64_t v21 = 2;
    }
    unint64_t v19 = v18[v21];
  }
  while (v19);
  if (v20 <= v16)
  {
    int v25 = 1;
  }
  else
  {
LABEL_24:
    uint64_t v22 = v6[2];
    if (v22) {
      unint64_t v23 = (void *)(v22 - 8);
    }
    else {
      unint64_t v23 = 0;
    }
    int v24 = v18 + 1;
    if (v18 == v23)
    {
      int v25 = 0;
      goto LABEL_33;
    }
    int v27 = v18 + 1;
    __n128 result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::decrement((unint64_t *)&v27);
    int v25 = 0;
    unsigned int v20 = *((unsigned __int8 *)v27 - 8);
  }
  if (v20 >= v16) {
    return result;
  }
  int v24 = v18 + 1;
LABEL_33:
  __n128 v26 = operator new(0x38uLL);
  *(unsigned char *)__n128 v26 = v16;
  *((unsigned char *)v26 + 1) = v5;
  boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::link((unint64_t *)v26 + 1, v25, v24, v17);
  __n128 result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::link((unint64_t *)v26 + 4, v14, v13, (unint64_t *)(v4[1] + 32));
  ++v4[3];
  return result;
}

uint64_t _GLOBAL__sub_I_QMI_STK_Helper_cpp()
{
  qword_26AB7A168 = (uint64_t)&unk_26AB7A180;
  v0 = operator new(0x38uLL);
  qword_26AB7A178 = (uint64_t)v0;
  v0[1] = 0;
  v0[4] = 0;
  _OWORD v0[2] = v0 + 1;
  v0[3] = v0 + 1;
  v0[5] = v0 + 4;
  v0[6] = v0 + 4;
  qword_26AB7A188 = 0;
  unk_26AB7A190 = &unk_26AB7A180;
  qword_26AB7A198 = (uint64_t)&unk_26AB7A180;
  __cxa_atexit((void (*)(void *))boost::bimaps::bimap<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::~bimap, &unk_26AB7A160, &dword_22231A000);
  qword_26AB7A158 = 0;
  qword_26AB7A150 = 0;
  qword_26AB7A148 = (uint64_t)&qword_26AB7A150;
  __cxa_atexit((void (*)(void *))std::map<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>::~map[abi:ne180100], &qword_26AB7A148, &dword_22231A000);
  qword_26AB7A1A8 = (uint64_t)&unk_26AB7A1C0;
  uint64_t v1 = operator new(0x38uLL);
  qword_26AB7A1B8 = (uint64_t)v1;
  v1[1] = 0;
  v1[4] = 0;
  v1[2] = v1 + 1;
  v1[3] = v1 + 1;
  v1[5] = v1 + 4;
  v1[6] = v1 + 4;
  qword_26AB7A1C8 = 0;
  qword_26AB7A1D0 = (uint64_t)&unk_26AB7A1C0;
  qword_26AB7A1D8 = (uint64_t)&unk_26AB7A1C0;
  __cxa_atexit((void (*)(void *))boost::bimaps::bimap<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::~bimap, &unk_26AB7A1A0, &dword_22231A000);
  qword_26AB7A1E8 = (uint64_t)&unk_26AB7A200;
  unint64_t v2 = operator new(0x38uLL);
  qword_26AB7A1F8 = (uint64_t)v2;
  v2[1] = 0;
  v2[4] = 0;
  v2[2] = v2 + 1;
  v2[3] = v2 + 1;
  v2[5] = v2 + 4;
  v2[6] = v2 + 4;
  qword_26AB7A208 = 0;
  qword_26AB7A210 = (uint64_t)&unk_26AB7A200;
  qword_26AB7A218 = (uint64_t)&unk_26AB7A200;
  __cxa_atexit((void (*)(void *))boost::bimaps::bimap<NotificationAdditionalResponse,tr::AdditionalResponse,mpl_::na,mpl_::na,mpl_::na>::~bimap, &unk_26AB7A1E0, &dword_22231A000);
  qword_26AB7A228 = (uint64_t)&unk_26AB7A240;
  unint64_t v3 = operator new(0x38uLL);
  qword_26AB7A238 = (uint64_t)v3;
  v3[1] = 0;
  v3[2] = v3 + 1;
  v3[3] = v3 + 1;
  v3[4] = 0;
  v3[5] = v3 + 4;
  v3[6] = v3 + 4;
  qword_26AB7A248 = 0;
  qword_26AB7A250 = (uint64_t)&unk_26AB7A240;
  qword_26AB7A258 = (uint64_t)&unk_26AB7A240;

  return __cxa_atexit((void (*)(void *))boost::bimaps::bimap<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::~bimap, &unk_26AB7A220, &dword_22231A000);
}

void QMIAudioRoutingCommandDriver::create()
{
}

void sub_2224CD7BC(_Unwind_Exception *exception_object)
{
  if (v2) {
    dispatch_release(v2);
  }
  if (v3) {
    MEMORY[0x223C9A950](v1, 0x10F1C4034818AECLL);
  }
  _Unwind_Resume(exception_object);
}

uint64_t QMIAudioRoutingCommandDriver::QMIAudioRoutingCommandDriver(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  dispatch_object_t object = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  AudioRoutingCommandDriver::AudioRoutingCommandDriver();
  if (object) {
    dispatch_release(object);
  }
  *(void *)a1 = &unk_26D4D0650;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = &unk_26D4D06C0;
  *(unsigned char *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 136) = 0;
  return a1;
}

void sub_2224CD8A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void QMIAudioRoutingCommandDriver::~QMIAudioRoutingCommandDriver(QMIAudioRoutingCommandDriver *this)
{
  *(void *)this = &unk_26D4D0650;
  *((void *)this + 11) = &unk_26D4D06C0;
  unint64_t v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  int v3 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }

  MEMORY[0x270EE9788](this);
}

{
  uint64_t vars8;

  QMIAudioRoutingCommandDriver::~QMIAudioRoutingCommandDriver(this);

  JUMPOUT(0x223C9A950);
}

void non-virtual thunk to'QMIAudioRoutingCommandDriver::~QMIAudioRoutingCommandDriver(QMIAudioRoutingCommandDriver *this)
{
}

{
  uint64_t vars8;

  QMIAudioRoutingCommandDriver::~QMIAudioRoutingCommandDriver((QMIAudioRoutingCommandDriver *)((char *)this - 88));

  JUMPOUT(0x223C9A950);
}

void QMIAudioRoutingCommandDriver::bootstrap(uint64_t a1, dispatch_object_t *a2, uint64_t a3, uint64_t a4)
{
  int v7 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v7);
  }
  if (*(void *)a3) {
    xpc_retain(*(xpc_object_t *)a3);
  }
  else {
    xpc_null_create();
  }
  unint64_t v8 = *(void **)(a3 + 8);
  if (v8) {
    xpc_retain(v8);
  }
  else {
    xpc_null_create();
  }
  uint64_t v9 = *(void *)(a4 + 8);
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 16);
  if (v10)
  {
    if (std::__shared_weak_count::lock(v10)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIAudioRoutingCommandDriver::shutdown(uint64_t a1, dispatch_object_t *a2)
{
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMIAudioRoutingCommandDriver::registered(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void non-virtual thunk to'QMIAudioRoutingCommandDriver::registered(uint64_t a1, uint64_t a2)
{
}

void QMIAudioRoutingCommandDriver::deregistered(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void non-virtual thunk to'QMIAudioRoutingCommandDriver::deregistered(uint64_t a1, uint64_t a2)
{
}

void QMIAudioRoutingCommandDriver::setPath(uint64_t a1, int a2, int a3)
{
  *(_DWORD *)(a1 + 140) = getQmiDownLinkAudioPath(a2);
  *(_DWORD *)(a1 + 144) = getQmiUplinkAudioPath(a3);
  *(_OWORD *)__n128 __p = 0u;
  long long v15 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 0x40000000;
  v13[2] = ___ZN28QMIAudioRoutingCommandDriver7setPathEN21AudioRoutingInterface17DownlinkAudioPathENS0_15UplinkAudioPathE_block_invoke;
  v13[3] = &__block_descriptor_tmp_26;
  v13[4] = a1;
  unsigned int v5 = (const void **)__p[1];
  if (__p[1] != (void *)v15)
  {
    while (*((unsigned char *)*v5 + 8) != 16)
    {
      if (++v5 == (const void **)v15) {
        goto LABEL_8;
      }
    }
  }
  if (v5 == (const void **)v15) {
LABEL_8:
  }
    operator new();
  if (!v6) {
    goto LABEL_25;
  }
  ___ZN28QMIAudioRoutingCommandDriver7setPathEN21AudioRoutingInterface17DownlinkAudioPathENS0_15UplinkAudioPathE_block_invoke((uint64_t)v13, v6 + 5);
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 0x40000000;
  v12[2] = ___ZN28QMIAudioRoutingCommandDriver7setPathEN21AudioRoutingInterface17DownlinkAudioPathENS0_15UplinkAudioPathE_block_invoke_2;
  v12[3] = &__block_descriptor_tmp_5_6;
  void v12[4] = a1;
  int v7 = (const void **)__p[1];
  if (__p[1] != (void *)v15)
  {
    while (*((unsigned char *)*v7 + 8) != 17)
    {
      if (++v7 == (const void **)v15) {
        goto LABEL_16;
      }
    }
  }
  if (v7 == (const void **)v15) {
LABEL_16:
  }
    operator new();
  if (!v8) {
LABEL_25:
  }
    __cxa_bad_cast();
  ___ZN28QMIAudioRoutingCommandDriver7setPathEN21AudioRoutingInterface17DownlinkAudioPathENS0_15UplinkAudioPathE_block_invoke_2((uint64_t)v12, v8 + 5);
  uint64_t v9 = *(void *)(a1 + 96);
  v11[0] = MEMORY[0x263EF8330];
  v11[1] = 0x40000000;
  v11[2] = ___ZN28QMIAudioRoutingCommandDriver7setPathEN21AudioRoutingInterface17DownlinkAudioPathENS0_15UplinkAudioPathE_block_invoke_3;
  v11[3] = &__block_descriptor_tmp_7_9;
  void v11[4] = a1;
  if (!*(unsigned char *)(v9 + 72) || !*(void *)(v9 + 56)) {
    __TUAssertTrigger();
  }
  v16[5] = v9 + 40;
  uint64_t v17 = QMIServiceMsg::create();
  int v18 = 25000;
  uint64_t v19 = 0;
  unsigned int v20 = 0;
  v16[0] = MEMORY[0x263EF8330];
  v16[1] = 0x40000000;
  unint64_t v16[2] = ___ZN16QMIVirtualClient4sendIN5audio12SetAudioPath7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke;
  v16[3] = &unk_264610748;
  void v16[4] = v11;
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_25;
  aBlock[3] = &unk_264610770;
  aBlock[4] = v16;
  uint64_t v10 = _Block_copy(aBlock);
  unsigned int v20 = v10;
  if (v17)
  {
    qmi::Client::send();
    uint64_t v10 = v20;
  }
  if (v10) {
    _Block_release(v10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224CE3E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)(v17 - 160));
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMIAudioRoutingCommandDriver7setPathEN21AudioRoutingInterface17DownlinkAudioPathENS0_15UplinkAudioPathE_block_invoke(uint64_t result, _WORD *a2)
{
  *a2 = *(_DWORD *)(*(void *)(result + 32) + 140);
  return result;
}

uint64_t ___ZN28QMIAudioRoutingCommandDriver7setPathEN21AudioRoutingInterface17DownlinkAudioPathENS0_15UplinkAudioPathE_block_invoke_2(uint64_t result, _WORD *a2)
{
  *a2 = *(_DWORD *)(*(void *)(result + 32) + 144);
  return result;
}

void ___ZN28QMIAudioRoutingCommandDriver7setPathEN21AudioRoutingInterface17DownlinkAudioPathENS0_15UplinkAudioPathE_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    int v3 = *(NSObject **)(*(void *)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N Error in set audio path response with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

void QMIAudioRoutingCommandDriver::setTtyEnabled(QMIAudioRoutingCommandDriver *this, char a2)
{
  *(_OWORD *)__n128 __p = 0u;
  long long v12 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v9[0] = MEMORY[0x263EF8330];
  v9[1] = 0x40000000;
  v9[2] = ___ZN28QMIAudioRoutingCommandDriver13setTtyEnabledEb_block_invoke;
  v9[3] = &__block_descriptor_tmp_9_6;
  char v10 = a2;
  uint64_t v4 = (const void **)__p[1];
  if (__p[1] != (void *)v12)
  {
    while (*((unsigned char *)*v4 + 8) != 1)
    {
      if (++v4 == (const void **)v12) {
        goto LABEL_8;
      }
    }
  }
  if (v4 == (const void **)v12) {
LABEL_8:
  }
    operator new();
  if (!v5) {
    __cxa_bad_cast();
  }
  ___ZN28QMIAudioRoutingCommandDriver13setTtyEnabledEb_block_invoke((uint64_t)v9, v5 + 9);
  uint64_t v6 = *((void *)this + 12);
  v8[0] = MEMORY[0x263EF8330];
  v8[1] = 0x40000000;
  _OWORD v8[2] = ___ZN28QMIAudioRoutingCommandDriver13setTtyEnabledEb_block_invoke_2;
  v8[3] = &__block_descriptor_tmp_10_10;
  v8[4] = this;
  if (!*(unsigned char *)(v6 + 72) || !*(void *)(v6 + 56)) {
    __TUAssertTrigger();
  }
  void v13[5] = v6 + 40;
  uint64_t v14 = QMIServiceMsg::create();
  int v15 = 25000;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 0x40000000;
  v13[2] = ___ZN16QMIVirtualClient4sendIN5audio6SetTTY7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke;
  v13[3] = &unk_264610798;
  v13[4] = v8;
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_25;
  aBlock[3] = &unk_264610770;
  aBlock[4] = v13;
  uint64_t v7 = _Block_copy(aBlock);
  uint64_t v17 = v7;
  if (v14)
  {
    qmi::Client::send();
    uint64_t v7 = v17;
  }
  if (v7) {
    _Block_release(v7);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224CE858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)(v11 - 144));
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMIAudioRoutingCommandDriver13setTtyEnabledEb_block_invoke(uint64_t result, _WORD *a2)
{
  *a2 = *(unsigned __int8 *)(result + 32);
  return result;
}

void ___ZN28QMIAudioRoutingCommandDriver13setTtyEnabledEb_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    int v3 = *(NSObject **)(*(void *)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N Error in set TTY response with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

void QMIAudioRoutingCommandDriver::setCtmMode(uint64_t a1, char a2)
{
  memset(v10, 0, sizeof(v10));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v10);
  v8[0] = MEMORY[0x263EF8330];
  v8[1] = 0x40000000;
  _OWORD v8[2] = ___ZN28QMIAudioRoutingCommandDriver10setCtmModeE7CtmMode_block_invoke;
  v8[3] = &__block_descriptor_tmp_12_12;
  char v9 = a2;
  uint64_t v4 = qmi::MutableMessageBase::getTLV<vs::tlv::TtyMode>((uint64_t)v10, 19);
  ___ZN28QMIAudioRoutingCommandDriver10setCtmModeE7CtmMode_block_invoke((uint64_t)v8, v4);
  uint64_t v5 = *(void *)(a1 + 120);
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 0x40000000;
  _OWORD v7[2] = ___ZN28QMIAudioRoutingCommandDriver10setCtmModeE7CtmMode_block_invoke_2;
  v7[3] = &__block_descriptor_tmp_13_10;
  v7[4] = a1;
  if (!*(unsigned char *)(v5 + 72) || !*(void *)(v5 + 56)) {
    __TUAssertTrigger();
  }
  void v11[5] = v5 + 40;
  uint64_t v12 = QMIServiceMsg::create();
  int v13 = 25000;
  uint64_t v14 = 0;
  int v15 = 0;
  v11[0] = MEMORY[0x263EF8330];
  v11[1] = 0x40000000;
  v11[2] = ___ZN16QMIVirtualClient4sendIN2vs9SetConfig7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke;
  v11[3] = &unk_2646107C0;
  void v11[4] = v7;
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_25;
  aBlock[3] = &unk_264610770;
  aBlock[4] = v11;
  uint64_t v6 = _Block_copy(aBlock);
  int v15 = v6;
  if (v12)
  {
    qmi::Client::send();
    uint64_t v6 = v15;
  }
  if (v6) {
    _Block_release(v6);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v10);
}

void sub_2224CEB34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)(v11 - 128));
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMIAudioRoutingCommandDriver10setCtmModeE7CtmMode_block_invoke(uint64_t result, char *a2)
{
  if (*(unsigned char *)(result + 32) == 1) {
    char v2 = 0;
  }
  else {
    char v2 = 3;
  }
  *a2 = v2;
  return result;
}

void ___ZN28QMIAudioRoutingCommandDriver10setCtmModeE7CtmMode_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    int v3 = *(NSObject **)(*(void *)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N Error in set CTM mode response with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

void QMIAudioRoutingCommandDriver::setVoiceMute(QMIAudioRoutingCommandDriver *this, char a2)
{
  if (capabilities::ct::supportsVoiceCall(this))
  {
    *(_OWORD *)__n128 __p = 0u;
    long long v12 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v9[0] = MEMORY[0x263EF8330];
    v9[1] = 0x40000000;
    v9[2] = ___ZN28QMIAudioRoutingCommandDriver12setVoiceMuteEb_block_invoke;
    v9[3] = &__block_descriptor_tmp_15_9;
    char v10 = a2;
    uint64_t v4 = (const void **)__p[1];
    if (__p[1] != (void *)v12)
    {
      while (*((unsigned char *)*v4 + 8) != 1)
      {
        if (++v4 == (const void **)v12) {
          goto LABEL_9;
        }
      }
    }
    if (v4 == (const void **)v12) {
LABEL_9:
    }
      operator new();
    if (!v5) {
      __cxa_bad_cast();
    }
    ___ZN28QMIAudioRoutingCommandDriver12setVoiceMuteEb_block_invoke((uint64_t)v9, v5 + 9);
    uint64_t v6 = *((void *)this + 12);
    v8[0] = MEMORY[0x263EF8330];
    v8[1] = 0x40000000;
    _OWORD v8[2] = ___ZN28QMIAudioRoutingCommandDriver12setVoiceMuteEb_block_invoke_2;
    v8[3] = &__block_descriptor_tmp_16_4;
    void v8[4] = this;
    if (!*(unsigned char *)(v6 + 72) || !*(void *)(v6 + 56)) {
      __TUAssertTrigger();
    }
    void v13[5] = v6 + 40;
    uint64_t v14 = QMIServiceMsg::create();
    int v15 = 25000;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 0x40000000;
    v13[2] = ___ZN16QMIVirtualClient4sendIN5audio13SetMuteStatus7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke;
    v13[3] = &unk_2646107E8;
    v13[4] = v8;
    aBlock[0] = MEMORY[0x263EF8330];
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_25;
    aBlock[3] = &unk_264610770;
    aBlock[4] = v13;
    uint64_t v7 = _Block_copy(aBlock);
    uint64_t v17 = v7;
    if (v14)
    {
      qmi::Client::send();
      uint64_t v7 = v17;
    }
    if (v7) {
      _Block_release(v7);
    }
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
}

void sub_2224CEFA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)(v11 - 144));
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMIAudioRoutingCommandDriver12setVoiceMuteEb_block_invoke(uint64_t result, unsigned char *a2)
{
  *a2 = *(unsigned char *)(result + 32);
  return result;
}

void ___ZN28QMIAudioRoutingCommandDriver12setVoiceMuteEb_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    int v3 = *(NSObject **)(*(void *)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N Error in set mute response with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

void QMIAudioRoutingCommandDriver::setSourceGain(uint64_t a1, int a2, int a3)
{
  *(_OWORD *)__n128 __p = 0u;
  long long v15 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v11[0] = MEMORY[0x263EF8330];
  v11[1] = 0x40000000;
  v11[2] = ___ZN28QMIAudioRoutingCommandDriver13setSourceGainEiN21AudioRoutingInterface12VolumeSourceE_block_invoke;
  v11[3] = &__block_descriptor_tmp_18_12;
  int v12 = a2;
  int v13 = a3;
  uint64_t v6 = (const void **)__p[1];
  if (__p[1] != (void *)v15)
  {
    while (*((unsigned char *)*v6 + 8) != 1)
    {
      if (++v6 == (const void **)v15) {
        goto LABEL_8;
      }
    }
  }
  if (v6 == (const void **)v15) {
LABEL_8:
  }
    operator new();
  if (!v7) {
    __cxa_bad_cast();
  }
  ___ZN28QMIAudioRoutingCommandDriver13setSourceGainEiN21AudioRoutingInterface12VolumeSourceE_block_invoke((uint64_t)v11, v7 + 9);
  uint64_t v8 = *(void *)(a1 + 96);
  v10[0] = MEMORY[0x263EF8330];
  v10[1] = 0x40000000;
  _OWORD v10[2] = ___ZN28QMIAudioRoutingCommandDriver13setSourceGainEiN21AudioRoutingInterface12VolumeSourceE_block_invoke_2;
  v10[3] = &__block_descriptor_tmp_19_9;
  v10[4] = a1;
  if (!*(unsigned char *)(v8 + 72) || !*(void *)(v8 + 56)) {
    __TUAssertTrigger();
  }
  v16[5] = v8 + 40;
  uint64_t v17 = QMIServiceMsg::create();
  int v18 = 25000;
  uint64_t v19 = 0;
  unsigned int v20 = 0;
  v16[0] = MEMORY[0x263EF8330];
  v16[1] = 0x40000000;
  unint64_t v16[2] = ___ZN16QMIVirtualClient4sendIN5audio9SetVolume7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke;
  v16[3] = &unk_264610810;
  void v16[4] = v10;
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_25;
  aBlock[3] = &unk_264610770;
  aBlock[4] = v16;
  char v9 = _Block_copy(aBlock);
  unsigned int v20 = v9;
  if (v17)
  {
    qmi::Client::send();
    char v9 = v20;
  }
  if (v9) {
    _Block_release(v9);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2224CF410(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t ___ZN28QMIAudioRoutingCommandDriver13setSourceGainEiN21AudioRoutingInterface12VolumeSourceE_block_invoke(uint64_t result, unsigned char *a2)
{
  unint64_t v2 = *(unsigned int *)(result + 36);
  a2[1] = *(_DWORD *)(result + 32);
  unint64_t v3 = 0x2050403010100uLL >> (8 * v2);
  if (v2 >= 7) {
    LOBYTE(v3) = 1;
  }
  *a2 = v3;
  return result;
}

void ___ZN28QMIAudioRoutingCommandDriver13setSourceGainEiN21AudioRoutingInterface12VolumeSourceE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    unint64_t v3 = *(NSObject **)(*(void *)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N Error in set volume response  with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

void std::shared_ptr<QMIAudioRoutingCommandDriver>::shared_ptr[abi:ne180100]<QMIAudioRoutingCommandDriver,std::shared_ptr<QMIAudioRoutingCommandDriver> ctu::SharedSynchronizable<AudioRoutingCommandDriver>::make_shared_ptr<QMIAudioRoutingCommandDriver>(QMIAudioRoutingCommandDriver*)::{lambda(QMIAudioRoutingCommandDriver*)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2224CF5EC(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMIAudioRoutingCommandDriver> ctu::SharedSynchronizable<AudioRoutingCommandDriver>::make_shared_ptr<QMIAudioRoutingCommandDriver>(QMIAudioRoutingCommandDriver*)::{lambda(QMIAudioRoutingCommandDriver*)#1}::operator() const(QMIAudioRoutingCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_2224CF614(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<QMIAudioRoutingCommandDriver *,std::shared_ptr<QMIAudioRoutingCommandDriver> ctu::SharedSynchronizable<AudioRoutingCommandDriver>::make_shared_ptr<QMIAudioRoutingCommandDriver>(QMIAudioRoutingCommandDriver*)::{lambda(QMIAudioRoutingCommandDriver *)#1},std::allocator<QMIAudioRoutingCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<QMIAudioRoutingCommandDriver *,std::shared_ptr<QMIAudioRoutingCommandDriver> ctu::SharedSynchronizable<AudioRoutingCommandDriver>::make_shared_ptr<QMIAudioRoutingCommandDriver>(QMIAudioRoutingCommandDriver*)::{lambda(QMIAudioRoutingCommandDriver *)#1},std::allocator<QMIAudioRoutingCommandDriver>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<QMIAudioRoutingCommandDriver *,std::shared_ptr<QMIAudioRoutingCommandDriver> ctu::SharedSynchronizable<AudioRoutingCommandDriver>::make_shared_ptr<QMIAudioRoutingCommandDriver>(QMIAudioRoutingCommandDriver*)::{lambda(QMIAudioRoutingCommandDriver *)#1},std::allocator<QMIAudioRoutingCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIAudioRoutingCommandDriver> ctu::SharedSynchronizable<AudioRoutingCommandDriver>::make_shared_ptr<QMIAudioRoutingCommandDriver>(QMIAudioRoutingCommandDriver*)::{lambda(QMIAudioRoutingCommandDriver*)#1}::operator() const(QMIAudioRoutingCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<AudioRoutingCommandDriver>::execute_wrapped<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0>(QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v33 = a1;
  uint64_t v34 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v4 = *(void *)(v1 + 32);
  uint64_t v3 = *(void *)(v1 + 40);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  __int16 v5 = *(std::__shared_weak_count **)(v2 + 72);
  *(void *)(v2 + 64) = v4;
  *(void *)(v2 + 72) = v3;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 48));
  uint64_t v7 = ServiceMap;
  uint64_t v8 = off_26D4CD628;
  if (((unint64_t)off_26D4CD628 & 0x8000000000000000) != 0)
  {
    char v9 = (unsigned __int8 *)((unint64_t)off_26D4CD628 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = (char *)v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = v8;
  int v12 = std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<void>>>>::find<unsigned long>(&v7[1].__m_.__sig, (unint64_t *)__p);
  if (v12)
  {
    uint64_t v14 = (void *)v12[3];
    int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v13);
      char v15 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  int v13 = 0;
  char v15 = 1;
LABEL_13:
  uint64_t v16 = MEMORY[0x223C9AD60](*(void *)(v1 + 16));
  uint64_t v17 = MEMORY[0x263EF8718];
  if (v16 == MEMORY[0x263EF8718])
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "audio");
    xpc_object_t object = xpc_null_create();
    if (MEMORY[0x223C9AD60](*(void *)(v1 + 16)) == v17)
    {
      unsigned int v20 = xpc_connection_create_from_endpoint(*(xpc_endpoint_t *)(v1 + 16));
      if (!v20) {
        unsigned int v20 = xpc_null_create();
      }
      xpc_object_t v21 = xpc_null_create();
      xpc_object_t v22 = object;
      xpc_object_t object = v20;
      xpc_release(v22);
      xpc_release(v21);
    }
    QMIClientPool::requestClient(v14, 0xE1u, (uint64_t *)__p, v2 + 88, (uint64_t)&object, v36);
    long long v23 = *(_OWORD *)v36;
    v36[0] = 0;
    v36[1] = 0;
    int v24 = *(std::__shared_weak_count **)(v2 + 104);
    *(_OWORD *)(v2 + 96) = v23;
    if (v24)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v24);
      if (v36[1]) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v36[1]);
      }
    }
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "audio");
    xpc_object_t object = xpc_null_create();
    QMIClientPool::requestClient(v14, 0xE1u, (uint64_t *)__p, v2 + 88, (uint64_t)&object, v36);
    long long v18 = *(_OWORD *)v36;
    v36[0] = 0;
    v36[1] = 0;
    uint64_t v19 = *(std::__shared_weak_count **)(v2 + 104);
    *(_OWORD *)(v2 + 96) = v18;
    if (v19)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v19);
      if (v36[1]) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v36[1]);
      }
    }
  }
  xpc_release(object);
  xpc_object_t object = 0;
  if (v41 < 0) {
    operator delete(__p[0]);
  }
  if (MEMORY[0x223C9AD60](*(void *)(v1 + 24)) == v17)
  {
    std::string::basic_string[abi:ne180100]<0>(v36, "voice");
    xpc_object_t v27 = xpc_null_create();
    xpc_object_t v35 = v27;
    if (MEMORY[0x223C9AD60](*(void *)(v1 + 24)) == v17)
    {
      int v28 = xpc_connection_create_from_endpoint(*(xpc_endpoint_t *)(v1 + 24));
      if (!v28) {
        int v28 = xpc_null_create();
      }
      xpc_object_t v29 = xpc_null_create();
      xpc_object_t v35 = v28;
      xpc_release(v27);
      xpc_release(v29);
    }
    QMIClientPool::requestClient(v14, 9u, (uint64_t *)v36, v2 + 88, (uint64_t)&v35, &v38);
    long long v30 = v38;
    long long v38 = 0uLL;
    int v31 = *(std::__shared_weak_count **)(v2 + 128);
    *(_OWORD *)(v2 + 120) = v30;
    if (v31)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v31);
      if (*((void *)&v38 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v38 + 1));
      }
    }
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(v36, "voice");
    xpc_object_t v35 = xpc_null_create();
    QMIClientPool::requestClient(v14, 9u, (uint64_t *)v36, v2 + 88, (uint64_t)&v35, &v38);
    long long v25 = v38;
    long long v38 = 0uLL;
    __n128 v26 = *(std::__shared_weak_count **)(v2 + 128);
    *(_OWORD *)(v2 + 120) = v25;
    if (v26)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v26);
      if (*((void *)&v38 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v38 + 1));
      }
    }
  }
  xpc_release(v35);
  xpc_object_t v35 = 0;
  if (v37 < 0)
  {
    operator delete(v36[0]);
    if (v15) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  if ((v15 & 1) == 0) {
LABEL_41:
  }
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
LABEL_42:
  std::unique_ptr<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0>>::~unique_ptr[abi:ne180100](&v34);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v33);
}

void sub_2224CFAA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,xpc_object_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  xpc_release(object);
  xpc_object_t object = 0;
  if (a18 < 0) {
    operator delete(__p);
  }
  if ((v29 & 1) == 0) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v28);
  }
  std::unique_ptr<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0>>::~unique_ptr[abi:ne180100](&a11);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 40);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    xpc_release(*(xpc_object_t *)(v2 + 24));
    *(void *)(v2 + 24) = 0;
    xpc_release(*(xpc_object_t *)(v2 + 16));
    *(void *)(v2 + 16) = 0;
    uint64_t v4 = *(NSObject **)(v2 + 8);
    if (v4)
    {
      dispatch_group_leave(v4);
      __int16 v5 = *(NSObject **)(v2 + 8);
      if (v5) {
        dispatch_release(v5);
      }
    }
    MEMORY[0x223C9A950](v2, 0xA0C4059E6D2FFLL);
  }
  return a1;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<AudioRoutingCommandDriver>::execute_wrapped<QMIAudioRoutingCommandDriver::shutdown(dispatch::group_session)::$_0>(QMIAudioRoutingCommandDriver::shutdown(dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIAudioRoutingCommandDriver::shutdown(dispatch::group_session)::$_0,dispatch_queue_s *::default_delete<QMIAudioRoutingCommandDriver::shutdown(dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *a1;
  char v9 = a1;
  uint64_t v10 = v4;
  uint64_t v5 = *(void *)v4;
  uint64_t v6 = *(void *)(*(void *)v4 + 96);
  if (v6)
  {
    uint64_t v11 = v6 + 88;
    uint64_t v12 = 1;
    MEMORY[0x223C999F0](v6 + 88, a2, a3, a4);
    *(unsigned char *)(v6 + 74) = 0;
    std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&v11);
  }
  uint64_t v7 = *(void *)(v5 + 120);
  if (v7)
  {
    uint64_t v11 = v7 + 88;
    uint64_t v12 = 1;
    MEMORY[0x223C999F0](v7 + 88, a2, a3, a4);
    *(unsigned char *)(v7 + 74) = 0;
    std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&v11);
  }
  std::unique_ptr<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0,std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](&v10);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v9);
}

void sub_2224CFC98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<AudioRoutingCommandDriver>::execute_wrapped<QMIAudioRoutingCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>(QMIAudioRoutingCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIAudioRoutingCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = v1[2];
  uint64_t v3 = *v1;
  if (v3 == *(void *)(v2 + 120))
  {
    *(unsigned char *)(v2 + 136) = 1;
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Voice client registered", buf, 2u);
    }
  }
  else if (v3 == *(void *)(v2 + 96))
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Audio client registered", buf, 2u);
    }
    *(unsigned char *)(v2 + 112) = 1;
  }
  if (*(unsigned char *)(v2 + 136) && *(unsigned char *)(v2 + 112)) {
    (*(void (**)(void, uint64_t))(**(void **)(v2 + 64) + 16))(*(void *)(v2 + 64), 1);
  }
  std::unique_ptr<QMIPreferredNetworksCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIPreferredNetworksCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)&v8);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v7);
}

void sub_2224CFDD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<AudioRoutingCommandDriver>::execute_wrapped<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>(QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  if (v2 == *(void *)(v3 + 120))
  {
    *(unsigned char *)(v3 + 136) = 0;
    uint64_t v5 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Voice client deregistered", buf, 2u);
    }
  }
  else if (v2 == *(void *)(v3 + 96))
  {
    uint64_t v4 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Audio client deregistered", buf, 2u);
    }
    *(unsigned char *)(v3 + 112) = 0;
  }
  if (!*(unsigned char *)(v3 + 136) && !*(unsigned char *)(v3 + 112)) {
    (*(void (**)(void, void))(**(void **)(v3 + 64) + 16))(*(void *)(v3 + 64), 0);
  }
  std::unique_ptr<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)&v8);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v7);
}

void sub_2224CFF0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *std::unique_ptr<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 16);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    MEMORY[0x223C9A950](v2, 0x20C40960023A9);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::DownLinkPath>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::DownLinkPath>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<audio::tlv::DownLinkPath>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::DownLinkPath>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::UpLinkPath>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::UpLinkPath>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<audio::tlv::UpLinkPath>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::UpLinkPath>::clone()
{
}

uint64_t ___ZN16QMIVirtualClient4sendIN5audio12SetAudioPath7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::ttyStatus>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::ttyStatus>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<audio::tlv::ttyStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::ProfileIdentifer>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::ttyStatus>::clone()
{
}

uint64_t ___ZN16QMIVirtualClient4sendIN5audio6SetTTY7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

char *qmi::MutableMessageBase::getTLV<vs::tlv::TtyMode>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<vs::tlv::TtyMode>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 9;
}

void qmi::MutableMessageBase::createTLV<vs::tlv::TtyMode>()
{
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::TtyMode>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::TtyMode>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<vs::tlv::TtyMode>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::TtyMode>::clone()
{
}

uint64_t ___ZN16QMIVirtualClient4sendIN2vs9SetConfig7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::MuteStatus>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::MuteStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<audio::tlv::MuteStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::MuteStatus>::clone()
{
}

uint64_t ___ZN16QMIVirtualClient4sendIN5audio13SetMuteStatus7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::VolumeInfo>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::VolumeInfo>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<audio::tlv::VolumeInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::ProfileIdentifer>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::VolumeInfo>::clone()
{
}

uint64_t ___ZN16QMIVirtualClient4sendIN5audio9SetVolume7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void QMIDataFactoryCommandDriver::create()
{
}

void sub_2224D0798(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object)
  {
    dispatch_release(object);
    if (!v10)
    {
LABEL_3:
      if (!v12) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if (!v10)
  {
    goto LABEL_3;
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  if (!v12) {
LABEL_5:
  }
    _Unwind_Resume(exception_object);
LABEL_4:
  MEMORY[0x223C9A950](v11, 0x10E1C40A35CF5D2);
  goto LABEL_5;
}

void *QMIDataFactoryCommandDriver::QMIDataFactoryCommandDriver(void *a1, void *a2, NSObject **a3)
{
  *a1 = MEMORY[0x263F038C8] + 16;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v8, (const char *)*MEMORY[0x263F03770], "DATA.QMIFactory");
  ctu::SharedLoggable<QMIDataFactoryCommandDriver,ctu::OsLogLogger>::SharedLoggable<ctu::OsLogContext>(a1 + 1, a3);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v8);
  a1[7] = 0;
  a1[8] = 0;
  *a1 = &unk_26D4D0978;
  a1[6] = &unk_26D4D09C8;
  a1[9] = *a2;
  uint64_t v6 = a2[1];
  a1[10] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  a1[13] = 0;
  a1[12] = 0;
  a1[11] = a1 + 12;
  return a1;
}

void sub_2224D08E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  BBDataFactoryCommandDriver::~BBDataFactoryCommandDriver(v9);
  _Unwind_Resume(a1);
}

void *ctu::SharedLoggable<QMIDataFactoryCommandDriver,ctu::OsLogLogger>::SharedLoggable<ctu::OsLogContext>(void *a1, NSObject **a2)
{
  *a1 = 0;
  a1[1] = 0;
  char v3 = *a2;
  a1[2] = *a2;
  if (v3) {
    dispatch_retain(v3);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x223C99A30](v5);
  return a1;
}

void QMIDataFactoryCommandDriver::~QMIDataFactoryCommandDriver(QMIDataFactoryCommandDriver *this)
{
  *(void *)this = &unk_26D4D0978;
  uint64_t v2 = (QMIDataFactoryCommandDriver *)((char *)this + 48);
  *((void *)this + 6) = &unk_26D4D09C8;
  std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<Mav20PreferredNetworksCommandDriver>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<Mav20PreferredNetworksCommandDriver>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<Mav20PreferredNetworksCommandDriver>>>>::destroy(*((void **)this + 12));
  char v3 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  BBDataCommandDriverEventHandler::~BBDataCommandDriverEventHandler(v2);
  MEMORY[0x223C99A30]((char *)this + 40);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable((void *)this + 1);

  BBDataFactoryCommandDriver::~BBDataFactoryCommandDriver(this);
}

{
  uint64_t vars8;

  QMIDataFactoryCommandDriver::~QMIDataFactoryCommandDriver(this);

  JUMPOUT(0x223C9A950);
}

void non-virtual thunk to'QMIDataFactoryCommandDriver::~QMIDataFactoryCommandDriver(QMIDataFactoryCommandDriver *this)
{
}

{
  uint64_t vars8;

  QMIDataFactoryCommandDriver::~QMIDataFactoryCommandDriver((QMIDataFactoryCommandDriver *)((char *)this - 48));

  JUMPOUT(0x223C9A950);
}

uint64_t **QMIDataFactoryCommandDriver::createDataCommandDriver@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t **a3@<X8>)
{
  int v6 = *(_DWORD *)(*(void *)a2 + 52);
  int v21 = v6;
  uint64_t v7 = *(void *)(a1 + 96);
  uint64_t v8 = (uint64_t **)(a1 + 88);
  if (!v7) {
    goto LABEL_17;
  }
  uint64_t v9 = a1 + 96;
  do
  {
    int v10 = *(_DWORD *)(v7 + 32);
    BOOL v11 = v10 < v6;
    if (v10 >= v6) {
      int v12 = (uint64_t *)v7;
    }
    else {
      int v12 = (uint64_t *)(v7 + 8);
    }
    if (!v11) {
      uint64_t v9 = v7;
    }
    uint64_t v7 = *v12;
  }
  while (*v12);
  if (v9 == a1 + 96
    || v6 < *(_DWORD *)(v9 + 32)
    || !std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>>>::__emplace_unique_key_args<subscriber::SimSlot,std::piecewise_construct_t const&,std::tuple<subscriber::SimSlot const&>,std::tuple<>>((uint64_t **)(a1 + 88), v6, &v21)[5])
  {
LABEL_17:
    v20[2] = 0;
    void v20[3] = 0;
    uint64_t v17 = *(void *)(a1 + 80);
    v20[0] = *(void *)(a1 + 72);
    v20[1] = v17;
    if (v17) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
    }
    long long v18 = *(NSObject **)(a1 + 24);
    dispatch_object_t v19 = v18;
    if (v18) {
      dispatch_retain(v18);
    }
    QMIDataCommandDriverInterface::create((uint64_t)v20, a2, &v19);
  }
  __n128 result = std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>>>::__emplace_unique_key_args<subscriber::SimSlot,std::piecewise_construct_t const&,std::tuple<subscriber::SimSlot const&>,std::tuple<>>(v8, v6, &v21);
  char v15 = result[5];
  uint64_t v14 = result[6];
  if (v15) {
    uint64_t v16 = v15 + 1;
  }
  else {
    uint64_t v16 = 0;
  }
  *a3 = v16;
  a3[1] = v14;
  if (v14) {
    atomic_fetch_add_explicit(v14 + 1, 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_2224D0CB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a15);
  }
  _Unwind_Resume(a1);
}

void QMIDataFactoryCommandDriver::createContextDriver(void *a1@<X0>, void *a2@<X2>, void *a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = *a3 + *(void *)(*(void *)*a3 - 56);
  int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 24))(v8);
  int v10 = (uint64_t *)a1[12];
  if (v10)
  {
    BOOL v11 = a1 + 12;
    uint64_t v12 = a1[12];
    do
    {
      int v13 = *(_DWORD *)(v12 + 32);
      BOOL v14 = v13 < v9;
      if (v13 >= v9) {
        char v15 = (uint64_t *)v12;
      }
      else {
        char v15 = (uint64_t *)(v12 + 8);
      }
      if (!v14) {
        BOOL v11 = (void *)v12;
      }
      uint64_t v12 = *v15;
    }
    while (*v15);
    if (v11 != a1 + 12 && v9 >= *((_DWORD *)v11 + 8))
    {
      while (1)
      {
        while (1)
        {
          int v16 = *((_DWORD *)v10 + 8);
          if (v16 <= v9) {
            break;
          }
          int v10 = (uint64_t *)*v10;
          if (!v10) {
            goto LABEL_17;
          }
        }
        if (v16 >= v9) {
          break;
        }
        int v10 = (uint64_t *)v10[1];
        if (!v10) {
LABEL_17:
        }
          std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
      }
      uint64_t v18 = v10[5];
      uint64_t v17 = (std::__shared_weak_count *)v10[6];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        if (!v18)
        {
          std::__shared_weak_count::__release_shared[abi:ne180100](v17);
          goto LABEL_11;
        }
      }
      else if (!v18)
      {
        goto LABEL_11;
      }
      uint64_t v19 = a1[10];
      v28[0] = a1[9];
      v28[1] = v19;
      if (v19) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t *__return_ptr))(*(void *)(*a3 + *(void *)(*(void *)*a3 - 56)) + 16))(&v27);
      unsigned int v20 = a1[3];
      dispatch_object_t object = v20;
      if (v20) {
        dispatch_retain(v20);
      }
      uint64_t v21 = a2[1];
      v25[0] = *a2;
      v25[1] = v21;
      if (v21) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v22 = a3[1];
      v24[0] = *a3;
      v24[1] = v22;
      if (v22) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
      }
      v23[0] = v18 + 8;
      v23[1] = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      QMIDataContextDriverInterface::create((uint64_t)v28, &object, (uint64_t)v25, (uint64_t)v24, (uint64_t)v23, &v29);
    }
  }
LABEL_11:
  *a4 = 0;
  a4[1] = 0;
}

void sub_2224D0F6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, std::__shared_weak_count *a15, dispatch_object_t object, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  if (a13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a13);
  }
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a15);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a18);
  }
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  }
  _Unwind_Resume(exception_object);
}

std::__shared_weak_count *QMIDataFactoryCommandDriver::createEventHandler@<X0>(QMIDataFactoryCommandDriver *this@<X0>, void *a2@<X8>)
{
  char v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (!v3 || (uint64_t v5 = *((void *)this + 1), (result = std::__shared_weak_count::lock(v3)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v7 = v5 + 48;
  if (!v5) {
    uint64_t v7 = 0;
  }
  *a2 = v7;
  a2[1] = result;
  return result;
}

void QMIDataFactoryCommandDriver::bootstrapDataCommandDriverEventHandler(QMIDataFactoryCommandDriver *this)
{
  uint64_t v1 = (char *)*((void *)this + 11);
  uint64_t v2 = (char *)this + 96;
  if (v1 != (char *)this + 96)
  {
    do
    {
      uint64_t v3 = *((void *)v1 + 5);
      uint64_t v4 = (std::__shared_weak_count *)*((void *)v1 + 6);
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t))(*(void *)v3 + 80))(v3);
      if (v4) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      }
      uint64_t v5 = (char *)*((void *)v1 + 1);
      if (v5)
      {
        do
        {
          int v6 = v5;
          uint64_t v5 = *(char **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          int v6 = (char *)*((void *)v1 + 2);
          BOOL v7 = *(void *)v6 == (void)v1;
          uint64_t v1 = v6;
        }
        while (!v7);
      }
      uint64_t v1 = v6;
    }
    while (v6 != v2);
  }
}

void sub_2224D10D0(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataFactoryCommandDriver::bootstrapDataCommandDriverEventHandler(QMIDataFactoryCommandDriver *this)
{
}

void QMIDataFactoryCommandDriver::startDataCommandDriverEventHandler(QMIDataFactoryCommandDriver *this)
{
  uint64_t v1 = (char *)*((void *)this + 11);
  uint64_t v2 = (char *)this + 96;
  if (v1 != (char *)this + 96)
  {
    do
    {
      uint64_t v3 = *((void *)v1 + 5);
      uint64_t v4 = (std::__shared_weak_count *)*((void *)v1 + 6);
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t))(*(void *)v3 + 88))(v3);
      if (v4) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      }
      uint64_t v5 = (char *)*((void *)v1 + 1);
      if (v5)
      {
        do
        {
          int v6 = v5;
          uint64_t v5 = *(char **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          int v6 = (char *)*((void *)v1 + 2);
          BOOL v7 = *(void *)v6 == (void)v1;
          uint64_t v1 = v6;
        }
        while (!v7);
      }
      uint64_t v1 = v6;
    }
    while (v6 != v2);
  }
}

void sub_2224D11A0(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataFactoryCommandDriver::startDataCommandDriverEventHandler(QMIDataFactoryCommandDriver *this)
{
}

void QMIDataFactoryCommandDriver::stopDataCommandDriverEventHandler(QMIDataFactoryCommandDriver *this)
{
  uint64_t v1 = (char *)*((void *)this + 11);
  uint64_t v2 = (char *)this + 96;
  if (v1 != (char *)this + 96)
  {
    do
    {
      uint64_t v3 = *((void *)v1 + 5);
      uint64_t v4 = (std::__shared_weak_count *)*((void *)v1 + 6);
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t))(*(void *)v3 + 96))(v3);
      if (v4) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      }
      uint64_t v5 = (char *)*((void *)v1 + 1);
      if (v5)
      {
        do
        {
          int v6 = v5;
          uint64_t v5 = *(char **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          int v6 = (char *)*((void *)v1 + 2);
          BOOL v7 = *(void *)v6 == (void)v1;
          uint64_t v1 = v6;
        }
        while (!v7);
      }
      uint64_t v1 = v6;
    }
    while (v6 != v2);
  }
}

void sub_2224D1270(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataFactoryCommandDriver::stopDataCommandDriverEventHandler(QMIDataFactoryCommandDriver *this)
{
}

void std::shared_ptr<QMIDataFactoryCommandDriver>::shared_ptr[abi:ne180100]<QMIDataFactoryCommandDriver,std::shared_ptr<QMIDataFactoryCommandDriver> ctu::SharedSynchronizable<QMIDataFactoryCommandDriver>::make_shared_ptr<QMIDataFactoryCommandDriver>(QMIDataFactoryCommandDriver*)::{lambda(QMIDataFactoryCommandDriver*)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2224D135C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMIDataFactoryCommandDriver> ctu::SharedSynchronizable<QMIDataFactoryCommandDriver>::make_shared_ptr<QMIDataFactoryCommandDriver>(QMIDataFactoryCommandDriver*)::{lambda(QMIDataFactoryCommandDriver*)#1}::operator() const(QMIDataFactoryCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_2224D1384(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<QMIDataFactoryCommandDriver *,std::shared_ptr<QMIDataFactoryCommandDriver> ctu::SharedSynchronizable<QMIDataFactoryCommandDriver>::make_shared_ptr<QMIDataFactoryCommandDriver>(QMIDataFactoryCommandDriver*)::{lambda(QMIDataFactoryCommandDriver *)#1},std::allocator<QMIDataFactoryCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<QMIDataFactoryCommandDriver *,std::shared_ptr<QMIDataFactoryCommandDriver> ctu::SharedSynchronizable<QMIDataFactoryCommandDriver>::make_shared_ptr<QMIDataFactoryCommandDriver>(QMIDataFactoryCommandDriver*)::{lambda(QMIDataFactoryCommandDriver *)#1},std::allocator<QMIDataFactoryCommandDriver>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<QMIDataFactoryCommandDriver *,std::shared_ptr<QMIDataFactoryCommandDriver> ctu::SharedSynchronizable<QMIDataFactoryCommandDriver>::make_shared_ptr<QMIDataFactoryCommandDriver>(QMIDataFactoryCommandDriver*)::{lambda(QMIDataFactoryCommandDriver *)#1},std::allocator<QMIDataFactoryCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIDataFactoryCommandDriver> ctu::SharedSynchronizable<QMIDataFactoryCommandDriver>::make_shared_ptr<QMIDataFactoryCommandDriver>(QMIDataFactoryCommandDriver*)::{lambda(QMIDataFactoryCommandDriver*)#1}::operator() const(QMIDataFactoryCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t **std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>>>::__emplace_unique_key_args<subscriber::SimSlot,std::piecewise_construct_t const&,std::tuple<subscriber::SimSlot const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  int v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        BOOL v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        int v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        int v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    BOOL v7 = a1 + 1;
LABEL_9:
    int v9 = (uint64_t *)v7;
    BOOL v7 = (uint64_t **)operator new(0x38uLL);
    *((_DWORD *)v7 + 8) = *a3;
    void v7[5] = 0;
    v7[6] = 0;
    *BOOL v7 = 0;
    v7[1] = 0;
    _OWORD v7[2] = v9;
    char *v6 = (uint64_t *)v7;
    int v10 = (uint64_t *)**a1;
    BOOL v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      BOOL v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void *EurekaCallCommandDriver::EurekaCallCommandDriver(uint64_t a1, uint64_t a2, NSObject **a3, uint64_t a4, void *a5)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  dispatch_object_t object = *a3;
  *a3 = 0;
  CallCommandDriver::CallCommandDriver();
  BOOL v7 = (capabilities::ct *)object;
  if (object) {
    dispatch_release(object);
  }
  v53[0] = &unk_26D4C05F8;
  v53[3] = v53;
  *(void *)(a1 + 112) = 0;
  if ((capabilities::ct::supportsGemini(v7) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 112)) {
    operator new();
  }
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100](v53);
  *(void *)a1 = &unk_26D4D0B18;
  *(void *)(a1 + 120) = *a5;
  uint64_t v8 = a5[1];
  *(void *)(a1 + 128) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 136), *(os_log_s **)(a1 + 40));
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 152), *(os_log_s **)(a1 + 40));
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 168), *(os_log_s **)(a1 + 40));
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 192) = a1 + 200;
  *(unsigned char *)(a1 + 184) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 232) = a1 + 240;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 264) = 0;
  int v9 = (uint64_t **)(a1 + 264);
  *(void *)(a1 + 256) = a1 + 264;
  *(void *)(a1 + 272) = 0;
  int v10 = (void *)*MEMORY[0x263F03530];
  if (*MEMORY[0x263F03530] != MEMORY[0x263F03530] + 8)
  {
    BOOL v11 = 0;
    uint64_t v12 = MEMORY[0x263F03530] + 8;
    int v13 = (uint64_t **)(a1 + 264);
    while (1)
    {
      uint64_t v14 = *(void *)((char *)v10 + 28);
      char v15 = (uint64_t *)(a1 + 264);
      if (v13 == v9) {
        goto LABEL_17;
      }
      int v16 = v11;
      uint64_t v17 = (uint64_t *)(a1 + 264);
      if (v11)
      {
        do
        {
          char v15 = v16;
          int v16 = (uint64_t *)v16[1];
        }
        while (v16);
      }
      else
      {
        do
        {
          char v15 = (uint64_t *)v17[2];
          BOOL v18 = *v15 == (void)v17;
          uint64_t v17 = v15;
        }
        while (v18);
      }
      int v19 = *((_DWORD *)v10 + 7);
      if (*((_DWORD *)v15 + 7) < v19)
      {
LABEL_17:
        if (v11) {
          unsigned int v20 = (uint64_t **)v15;
        }
        else {
          unsigned int v20 = (uint64_t **)(a1 + 264);
        }
        if (v11) {
          uint64_t v21 = (uint64_t **)(v15 + 1);
        }
        else {
          uint64_t v21 = (uint64_t **)(a1 + 264);
        }
        if (!*v21)
        {
LABEL_33:
          int v24 = (uint64_t *)operator new(0x28uLL);
          *(uint64_t *)((char *)v24 + 28) = v14;
          std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at((uint64_t **)(a1 + 256), (uint64_t)v20, v21, v24);
        }
      }
      else
      {
        uint64_t v21 = (uint64_t **)(a1 + 264);
        unsigned int v20 = (uint64_t **)(a1 + 264);
        if (!v11) {
          goto LABEL_33;
        }
        uint64_t v22 = v11;
        while (1)
        {
          while (1)
          {
            unsigned int v20 = (uint64_t **)v22;
            int v23 = *((_DWORD *)v22 + 7);
            if (v23 <= v19) {
              break;
            }
            uint64_t v22 = *v20;
            uint64_t v21 = v20;
            if (!*v20) {
              goto LABEL_33;
            }
          }
          if (v23 >= v19) {
            break;
          }
          uint64_t v22 = v20[1];
          if (!v22)
          {
            uint64_t v21 = v20 + 1;
            goto LABEL_33;
          }
        }
      }
      long long v25 = (void *)v10[1];
      if (v25)
      {
        do
        {
          __n128 v26 = v25;
          long long v25 = (void *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          __n128 v26 = (void *)v10[2];
          BOOL v18 = *v26 == (void)v10;
          int v10 = v26;
        }
        while (!v18);
      }
      if (v26 == (void *)v12) {
        break;
      }
      BOOL v11 = *v9;
      int v13 = *(uint64_t ***)(a1 + 256);
      int v10 = v26;
    }
  }
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 280) = a1 + 288;
  *(_WORD *)(a1 + 304) = 0;
  uint64_t v27 = (uint64_t **)(a1 + 312);
  int v28 = (uint64_t *)(a1 + 320);
  *(void *)(a1 + 320) = 0;
  *(void *)(a1 + 328) = 0;
  v51 = (void *)a1;
  *(void *)(a1 + 312) = a1 + 320;
  long long v29 = (void *)*MEMORY[0x263F03818];
  if (*MEMORY[0x263F03818] != MEMORY[0x263F03818] + 8)
  {
    uint64_t v30 = 0;
    uint64_t v31 = MEMORY[0x263F03818] + 8;
    int v32 = v28;
    while (1)
    {
      uint64_t v33 = *(void *)((char *)v29 + 28);
      uint64_t v34 = v28;
      if (v32 == v28) {
        goto LABEL_49;
      }
      xpc_object_t v35 = (uint64_t *)v30;
      unsigned int v36 = v28;
      if (v30)
      {
        do
        {
          uint64_t v34 = v35;
          xpc_object_t v35 = (uint64_t *)v35[1];
        }
        while (v35);
      }
      else
      {
        do
        {
          uint64_t v34 = (uint64_t *)v36[2];
          BOOL v18 = *v34 == (void)v36;
          unsigned int v36 = v34;
        }
        while (v18);
      }
      int v37 = *((_DWORD *)v29 + 7);
      if (*((_DWORD *)v34 + 7) < v37)
      {
LABEL_49:
        if (v30) {
          long long v38 = (uint64_t **)v34;
        }
        else {
          long long v38 = (uint64_t **)v28;
        }
        if (v30) {
          int v39 = (uint64_t **)(v34 + 1);
        }
        else {
          int v39 = (uint64_t **)v28;
        }
        if (!*v39)
        {
LABEL_65:
          uint64_t v42 = (uint64_t *)operator new(0x28uLL);
          *(uint64_t *)((char *)v42 + 28) = v33;
          std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(v27, (uint64_t)v38, v39, v42);
        }
      }
      else
      {
        int v39 = (uint64_t **)v28;
        long long v38 = (uint64_t **)v28;
        if (!v30) {
          goto LABEL_65;
        }
        uint64_t v40 = (uint64_t *)v30;
        while (1)
        {
          while (1)
          {
            long long v38 = (uint64_t **)v40;
            int v41 = *((_DWORD *)v40 + 7);
            if (v41 <= v37) {
              break;
            }
            uint64_t v40 = *v38;
            int v39 = v38;
            if (!*v38) {
              goto LABEL_65;
            }
          }
          if (v41 >= v37) {
            break;
          }
          uint64_t v40 = v38[1];
          if (!v40)
          {
            int v39 = v38 + 1;
            goto LABEL_65;
          }
        }
      }
      long long v43 = (void *)v29[1];
      if (v43)
      {
        do
        {
          uint64_t v44 = v43;
          long long v43 = (void *)*v43;
        }
        while (v43);
      }
      else
      {
        do
        {
          uint64_t v44 = (void *)v29[2];
          BOOL v18 = *v44 == (void)v29;
          long long v29 = v44;
        }
        while (!v18);
      }
      if (v44 == (void *)v31) {
        break;
      }
      uint64_t v30 = *v28;
      int v32 = *v27;
      long long v29 = v44;
    }
  }
  v51[42] = v51 + 42;
  v51[43] = v51 + 42;
  v51[44] = 0;
  subscriber::makeSimSlotRange();
  uint64_t v46 = v54;
  uint64_t v45 = v55;
  if (v54 != v55)
  {
    uint64_t v47 = v56;
    while ((v47(*v46) & 1) == 0)
    {
      if (++v46 == v45)
      {
        uint64_t v46 = v45;
        break;
      }
    }
    int v48 = v55;
LABEL_79:
    while (v46 != v48)
    {
      EurekaCallCommandDriver::fillUpDefaultCallCapabilities((uint64_t)v51, *v46);
      v49 = v46 + 1;
      uint64_t v46 = v45;
      if (v49 != v45)
      {
        uint64_t v46 = v49;
        while ((v47(*v46) & 1) == 0)
        {
          if (++v46 == v45)
          {
            uint64_t v46 = v45;
            goto LABEL_79;
          }
        }
      }
    }
  }
  return v51;
}

void sub_2224D1AD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, dispatch_object_t object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100](&a18);
  MEMORY[0x223C9A950](v18, 0x10A1C40FF1576FELL);
  uint64_t v21 = *((void *)v19 + 14);
  *((void *)v19 + 14) = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100](&a14);
  CallCommandDriver::~CallCommandDriver(v19);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::fillUpDefaultCallCapabilities(uint64_t a1, int a2)
{
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037B0], 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037A8], 2, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037D8], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037B8], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03698], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03690], 0, a2);
  int v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 120) + 352))();
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03680], v4 ^ 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03790], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03788], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03780], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037A0], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037E0], 0, a2);
  unint64_t v5 = *MEMORY[0x263F037D0];

  return EurekaCallCommandDriver::setCallCapability(a1, v5, 0, a2);
}

void EurekaCallCommandDriver::init(EurekaCallCommandDriver *this, long long *a2)
{
  long long v3 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  int v4 = (std::__shared_weak_count *)*((void *)this + 28);
  *(_OWORD *)((char *)this + 216) = v3;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }

  EurekaCallCommandDriver::createQMIClients(this);
}

void EurekaCallCommandDriver::createQMIClients(EurekaCallCommandDriver *this)
{
  xpc_object_t v35 = (Registry **)((char *)this + 48);
  subscriber::makeSimSlotRange();
  uint64_t v2 = v36;
  if (v36 != v37)
  {
    while ((v39(LODWORD(v2->__vftable)) & 1) == 0)
    {
      uint64_t v2 = (std::__shared_weak_count *)((char *)v2 + 4);
      if (v2 == v37)
      {
        uint64_t v2 = v37;
        break;
      }
    }
    if (v2 != v37)
    {
      int v32 = (char *)*MEMORY[0x263F8AFE8];
      while (1)
      {
        if (LODWORD(v2->__vftable) == 1) {
          long long v3 = "CallModule.Voice.Service.1";
        }
        else {
          long long v3 = LODWORD(v2->__vftable) == 2 ? "CallModule.Voice.Service.2" : 0;
        }
        int v4 = (std::__shared_weak_count *)*((void *)this + 2);
        if (!v4) {
          break;
        }
        uint64_t v5 = *((void *)this + 1);
        int v6 = std::__shared_weak_count::lock(v4);
        if (!v6) {
          break;
        }
        BOOL v7 = v6;
        Registry::getServerConnection((uint64_t *)v40, *v35);
        long long v53 = 0u;
        long long v54 = 0u;
        std::string::basic_string[abi:ne180100]<0>(&v49, v3);
        uint64_t v8 = *((void *)this + 3);
        dispatch_object_t object = v8;
        if (v8) {
          dispatch_retain(v8);
        }
        std::string::basic_string[abi:ne180100]<0>(&__p, "voice");
        *(void *)&long long v52 = v5;
        *((void *)&v52 + 1) = v7;
        atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        long long v44 = *(_OWORD *)v40;
        v40[0] = 0;
        v40[1] = 0;
        qmi::Client::createWithQueueLocal();
        if (*((void *)&v44 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v44 + 1));
        }
        if (*((void *)&v52 + 1)) {
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v52 + 1));
        }
        if (SHIBYTE(v47) < 0) {
          operator delete(__p);
        }
        if (object) {
          dispatch_release(object);
        }
        if (SBYTE7(v51) < 0) {
          operator delete(v49);
        }
        v49 = 0;
        uint64_t v50 = 0;
        long long v51 = v54;
        long long v54 = 0uLL;
        qmi::ClientRouter::addClient();
        qmi::Client::~Client((qmi::Client *)&v49);
        uint64_t v9 = qmi::ClientRouter::get();
        qmi::Client::~Client((qmi::Client *)&v53);
        v41[0] = 0;
        v41[1] = 0;
        uint64_t v10 = *(void *)(v9 + 24);
        uint64_t v42 = *(void *)(v9 + 16);
        uint64_t v43 = v10;
        if (v10) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
        }
        if (v40[1]) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v40[1]);
        }
        std::__shared_weak_count::__release_shared[abi:ne180100](v7);
        qmi::Client::set((qmi::Client *)v41, v32);
        qmi::Client::~Client((qmi::Client *)v41);
        BOOL v11 = (std::__shared_weak_count *)((char *)&v2->__vftable + 4);
        uint64_t v2 = v37;
        if (v11 != v37)
        {
          uint64_t v2 = v11;
          while ((v39(LODWORD(v2->__vftable)) & 1) == 0)
          {
            uint64_t v2 = (std::__shared_weak_count *)((char *)v2 + 4);
            if (v2 == v37)
            {
              uint64_t v2 = v37;
              break;
            }
          }
        }
        if (v2 == v37) {
          goto LABEL_36;
        }
      }
LABEL_104:
      std::__throw_bad_weak_ptr[abi:ne180100]();
    }
  }
LABEL_36:
  subscriber::makeSimSlotRange();
  int v13 = __p;
  uint64_t v12 = v46;
  if (__p != v46)
  {
    uint64_t v14 = v47;
    while ((v14(*v13) & 1) == 0)
    {
      if (++v13 == v12)
      {
        int v13 = v12;
        break;
      }
    }
    uint64_t v33 = v46;
    while (v13 != v33)
    {
      if (*v13 == 1) {
        char v15 = "CallModule.USSD.Service.1";
      }
      else {
        char v15 = *v13 == 2 ? "CallModule.USSD.Service.2" : 0;
      }
      int v16 = (std::__shared_weak_count *)*((void *)this + 2);
      if (!v16) {
        goto LABEL_104;
      }
      uint64_t v17 = std::__shared_weak_count::lock(v16);
      if (!v17) {
        goto LABEL_104;
      }
      uint64_t v18 = v17;
      Registry::getServerConnection((uint64_t *)&v44, *v35);
      long long v53 = 0u;
      long long v54 = 0u;
      std::string::basic_string[abi:ne180100]<0>(&v49, v15);
      int v19 = *((void *)this + 3);
      v40[0] = v19;
      if (v19) {
        dispatch_retain(v19);
      }
      std::string::basic_string[abi:ne180100]<0>(v41, "ussd");
      atomic_fetch_add_explicit(&v18->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      long long v52 = v44;
      long long v44 = 0uLL;
      qmi::Client::createWithQueueLocal();
      if (*((void *)&v52 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v52 + 1));
      }
      std::__shared_weak_count::__release_weak(v18);
      if (SHIBYTE(v42) < 0) {
        operator delete(v41[0]);
      }
      if (v40[0]) {
        dispatch_release(v40[0]);
      }
      if (SBYTE7(v51) < 0) {
        operator delete(v49);
      }
      v49 = 0;
      uint64_t v50 = 0;
      long long v51 = v54;
      long long v54 = 0uLL;
      qmi::ClientRouter::addClient();
      qmi::Client::~Client((qmi::Client *)&v49);
      qmi::ClientRouter::get();
      qmi::Client::~Client((qmi::Client *)&v53);
      if (*((void *)&v44 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v44 + 1));
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v18);
      unsigned int v20 = v13 + 1;
      int v13 = v12;
      if (v20 != v12)
      {
        int v13 = v20;
        while ((v14(*v13) & 1) == 0)
        {
          if (++v13 == v12)
          {
            int v13 = v12;
            break;
          }
        }
      }
    }
  }
  subscriber::makeSimSlotRange();
  uint64_t v22 = __p;
  uint64_t v21 = v46;
  if (__p != v46)
  {
    int v23 = v47;
    while ((v23(*v22) & 1) == 0)
    {
      if (++v22 == v21)
      {
        uint64_t v22 = v21;
        break;
      }
    }
    uint64_t v34 = v46;
    if (v22 != v46)
    {
      while (1)
      {
        if (*v22 == 1) {
          int v24 = "CallModule.NAS.1";
        }
        else {
          int v24 = *v22 == 2 ? "CallModule.NAS.2" : 0;
        }
        long long v25 = (std::__shared_weak_count *)*((void *)this + 2);
        if (!v25) {
          goto LABEL_104;
        }
        __n128 v26 = std::__shared_weak_count::lock(v25);
        if (!v26) {
          goto LABEL_104;
        }
        uint64_t v27 = v26;
        atomic_fetch_add_explicit(&v26->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        std::__shared_weak_count::__release_shared[abi:ne180100](v26);
        Registry::getServerConnection((uint64_t *)&v44, *v35);
        long long v53 = 0u;
        long long v54 = 0u;
        std::string::basic_string[abi:ne180100]<0>(&v49, v24);
        int v28 = *((void *)this + 3);
        v40[0] = v28;
        if (v28) {
          dispatch_retain(v28);
        }
        std::string::basic_string[abi:ne180100]<0>(v41, "voice");
        long long v29 = std::__shared_weak_count::lock(v27);
        if (v29)
        {
          uint64_t v30 = v29;
          atomic_fetch_add_explicit(&v29->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          long long v38 = v29;
          std::__shared_weak_count::__release_weak(v27);
          std::__shared_weak_count::__release_shared[abi:ne180100](v30);
        }
        else
        {
          long long v38 = 0;
          std::__shared_weak_count::__release_weak(v27);
        }
        long long v52 = v44;
        long long v44 = 0uLL;
        qmi::Client::createWithQueueLocal();
        if (*((void *)&v52 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v52 + 1));
        }
        if (v38) {
          std::__shared_weak_count::__release_weak(v38);
        }
        if (SHIBYTE(v42) < 0) {
          operator delete(v41[0]);
        }
        if (v40[0]) {
          dispatch_release(v40[0]);
        }
        if (SBYTE7(v51) < 0) {
          operator delete(v49);
        }
        v49 = 0;
        uint64_t v50 = 0;
        long long v51 = v54;
        long long v54 = 0uLL;
        qmi::ClientRouter::addClient();
        qmi::Client::~Client((qmi::Client *)&v49);
        qmi::ClientRouter::get();
        qmi::Client::~Client((qmi::Client *)&v53);
        if (*((void *)&v44 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v44 + 1));
        }
        uint64_t v31 = v22 + 1;
        uint64_t v22 = v21;
        if (v31 != v21)
        {
          uint64_t v22 = v31;
          while ((v23(*v22) & 1) == 0)
          {
            if (++v22 == v21)
            {
              uint64_t v22 = v21;
              break;
            }
          }
        }
        if (v22 == v34) {
          return;
        }
      }
    }
  }
}

void sub_2224D25A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, dispatch_object_t object, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,dispatch_object_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  uint64_t v42 = *(std::__shared_weak_count **)(v40 - 136);
  if (v42) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v42);
  }
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a27);
  }
  _Unwind_Resume(exception_object);
}

void EurekaCallCommandDriver::sendSRVCCCallConfig(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  uint64_t v2 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112));
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 120) + 328))(&v31);
  *(_OWORD *)__n128 __p = 0u;
  long long v30 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  long long v3 = (const void **)__p[1];
  if (__p[1] != (void *)v30)
  {
    while (*((unsigned char *)*v3 + 8) != 1)
    {
      if (++v3 == (const void **)v30) {
        goto LABEL_8;
      }
    }
  }
  if (v3 == (const void **)v30) {
LABEL_8:
  }
    operator new();
  if (!v4) {
    __cxa_bad_cast();
  }
  uint64_t v5 = (uint64_t *)(v4 + 16);
  uint64_t v6 = v31;
  uint64_t v7 = v32;
  if (v31 == v32)
  {
LABEL_40:
    qmi::ClientRouter::get();
    operator new();
  }
  uint64_t v28 = (uint64_t)(v4 + 32);
  while (1)
  {
    uint64_t v8 = *(int *)(v6 + 56);
    if v8 < 9 && ((0x1F3u >> v8))
    {
      std::string::value_type v10 = byte_2225858A3[v8];
      unsigned int v11 = dword_2225858AC[v8];
      if (CallInfo::operator BOOL())
      {
        memset(v34, 0, sizeof(v34));
        v34[0].__r_.__value_.__s.__data_[0] = *(_DWORD *)(v6 + 92);
        if ((*(_DWORD *)(v6 + 64) & 0xFFFFFFFE) == 2) {
          int v12 = 9;
        }
        else {
          int v12 = 0;
        }
        *(std::string::size_type *)((char *)v34[0].__r_.__value_.__r.__words + 4) = __PAIR64__(v11, v12);
        v34[0].__r_.__value_.__s.__data_[12] = v10;
        v34[0].__r_.__value_.__s.__data_[13] = *(unsigned char *)(v6 + 85);
        LODWORD(v34[0].__r_.__value_.__r.__words[2]) = *(_DWORD *)(v6 + 72);
        std::string::operator=(&v34[1], (const std::string *)(v6 + 32));
        unint64_t v13 = v5[1];
        unint64_t v14 = v5[2];
        if (v13 >= v14)
        {
          unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - *v5) >> 4);
          unint64_t v19 = v18 + 1;
          if (v18 + 1 > 0x555555555555555) {
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - *v5) >> 4);
          if (2 * v20 > v19) {
            unint64_t v19 = 2 * v20;
          }
          if (v20 >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v21 = 0x555555555555555;
          }
          else {
            unint64_t v21 = v19;
          }
          long long v38 = v5 + 2;
          if (v21) {
            uint64_t v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::AppInfo>>(v28, v21);
          }
          else {
            uint64_t v22 = 0;
          }
          long long v25 = &v22[48 * v18];
          *(void *)&long long buf = v22;
          *((void *)&buf + 1) = v25;
          int v37 = &v22[48 * v21];
          long long v26 = *(_OWORD *)&v34[0].__r_.__value_.__l.__data_;
          *((_DWORD *)v25 + 4) = v34[0].__r_.__value_.__r.__words[2];
          *(_OWORD *)long long v25 = v26;
          long long v27 = *(_OWORD *)&v34[1].__r_.__value_.__l.__data_;
          *((void *)v25 + 5) = *((void *)&v34[1].__r_.__value_.__l + 2);
          *(_OWORD *)(v25 + 24) = v27;
          memset(&v34[1], 0, sizeof(std::string));
          unsigned int v36 = v25 + 48;
          std::vector<vs::tlv::CallConfigItem>::__swap_out_circular_buffer(v5, &buf);
          uint64_t v17 = v5[1];
          std::__split_buffer<vs::tlv::CallConfigItem>::~__split_buffer((uint64_t)&buf);
        }
        else
        {
          long long v15 = *(_OWORD *)&v34[0].__r_.__value_.__l.__data_;
          *(_DWORD *)(v13 + 16) = v34[0].__r_.__value_.__r.__words[2];
          *(_OWORD *)unint64_t v13 = v15;
          long long v16 = *(_OWORD *)&v34[1].__r_.__value_.__l.__data_;
          *(void *)(v13 + 40) = *((void *)&v34[1].__r_.__value_.__l + 2);
          *(_OWORD *)(v13 + 24) = v16;
          memset(&v34[1], 0, sizeof(std::string));
          uint64_t v17 = v13 + 48;
          v5[1] = v13 + 48;
        }
        v5[1] = v17;
        if ((SHIBYTE(v34[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_15;
        }
        std::string::pointer data = v34[1].__r_.__value_.__l.__data_;
        goto LABEL_39;
      }
    }
    else
    {
      CallInfo::operator BOOL();
    }
    uint64_t v9 = *v2;
    if (!os_log_type_enabled(*v2, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    CallInfo::toString((uint64_t *)v34, (CallInfo *)v6);
    int v23 = v34;
    if ((v34[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int v23 = (std::string *)v34[0].__r_.__value_.__r.__words[0];
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v23;
    _os_log_error_impl(&dword_22231A000, v9, OS_LOG_TYPE_ERROR, "Found call in invalid state when sending handover call context: %s", (uint8_t *)&buf, 0xCu);
    if ((SHIBYTE(v34[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_15;
    }
    std::string::pointer data = (std::string::pointer)v34[0].__r_.__value_.__r.__words[0];
LABEL_39:
    operator delete(data);
LABEL_15:
    v6 += 408;
    if (v6 == v7) {
      goto LABEL_40;
    }
  }
}

void sub_2224D2E10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,std::__shared_weak_count *a30)
{
  if (a30) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a30);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v31);
  if (a16) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v30, a16);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a17);
  a17 = &a22;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a17);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::handleNotRegistered(EurekaCallCommandDriver *this)
{
  uint64_t v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#N event::registration::not registered!", v4, 2u);
  }
  return (*(uint64_t (**)(void))(**((void **)this + 27) + 16))(*((void *)this + 27));
}

void EurekaCallCommandDriver::handleRegistered(uint64_t a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void **)(a1 + 312);
  long long v3 = (void *)(a1 + 320);
  if (v2 != (void *)(a1 + 320))
  {
    uint64_t v5 = (void *)(a2 + 8);
    do
    {
      int v6 = asWirelessTechnology();
      uint64_t v7 = convertWirelessTechnologyToCallTechnology();
      uint64_t v36 = 0;
      int v37 = 0;
      EurekaCallCommandDriver::getPreferredFormatterForSim(&v36, a1, *((unsigned int *)v2 + 7));
      uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), *((unsigned int *)v2 + 7));
      if (v36)
      {
        if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v36 + 16))(v36, 1)) {
          int v9 = 8;
        }
        else {
          int v9 = 4;
        }
      }
      else
      {
        int v9 = 0;
      }
      uint64_t v10 = *v5;
      if (!*v5) {
        goto LABEL_18;
      }
      int v11 = *((_DWORD *)v2 + 7);
      int v12 = v5;
      do
      {
        int v13 = *(_DWORD *)(v10 + 28);
        BOOL v14 = v13 < v11;
        if (v13 >= v11) {
          long long v15 = (uint64_t *)v10;
        }
        else {
          long long v15 = (uint64_t *)(v10 + 8);
        }
        if (!v14) {
          int v12 = (void *)v10;
        }
        uint64_t v10 = *v15;
      }
      while (*v15);
      if (v12 != v5 && v11 >= *((_DWORD *)v12 + 7))
      {
        BOOL v16 = asWirelessTechnology() == v6;
        if (!v6) {
          goto LABEL_29;
        }
      }
      else
      {
LABEL_18:
        BOOL v16 = 0;
        if (!v6) {
          goto LABEL_29;
        }
      }
      if (v16 || v9 == 8 && isCdmaRat())
      {
        uint64_t v17 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          WirelessTechnologyAsString();
          p_p = &__p;
          if (v35 < 0) {
            p_p = (void **)__p;
          }
          *(_DWORD *)long long buf = 136315138;
          uint64_t v39 = p_p;
          _os_log_impl(&dword_22231A000, v17, OS_LOG_TYPE_DEFAULT, "#I Not handling fCurrentRat update since value didn't change, %s", buf, 0xCu);
          if (v35 < 0) {
            operator delete(__p);
          }
        }
        goto LABEL_53;
      }
LABEL_29:
      unint64_t v19 = *v8;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        WirelessTechnologyAsString();
        int v20 = v35;
        unint64_t v21 = (void **)__p;
        uint64_t v22 = callTechnologyToString();
        *(_DWORD *)long long buf = 136315394;
        int v23 = &__p;
        if (v20 < 0) {
          int v23 = v21;
        }
        uint64_t v39 = v23;
        __int16 v40 = 2080;
        uint64_t v41 = v22;
        _os_log_impl(&dword_22231A000, v19, OS_LOG_TYPE_DEFAULT, "#N WirelessTechnology has changed to (%s) and Call Tech has changed to (%s)!", buf, 0x16u);
        if (v35 < 0) {
          operator delete(__p);
        }
      }
      EurekaCallCommandDriver::setPreferredFormatter(a1, v7, *((unsigned int *)v2 + 7));
      EurekaCallCommandDriver::getPreferredFormatterForSim(&__p, a1, *((unsigned int *)v2 + 7));
      int v24 = __p;
      if (v34) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v34);
      }
      if (v24)
      {
        if (v6 == 8)
        {
          EurekaCallCommandDriver::fillUpC2KCallCapabilities(a1, *((_DWORD *)v2 + 7));
        }
        else if (v6 == 4)
        {
          EurekaCallCommandDriver::fillUpGSMCallCapabilities(a1, *((_DWORD *)v2 + 7));
        }
      }
      else
      {
        EurekaCallCommandDriver::setPreferredFormatterBasedOnCarrierCapabilities(a1, *((unsigned int *)v2 + 7));
      }
      __n128 __p = 0;
      uint64_t v34 = 0;
      EurekaCallCommandDriver::getPreferredFormatterForSim(&__p, a1, *((unsigned int *)v2 + 7));
      if ((*(unsigned int (**)(void *, uint64_t))(*(void *)__p + 16))(__p, 1)) {
        uint64_t v25 = 8;
      }
      else {
        uint64_t v25 = 4;
      }
      uint64_t v26 = *(void *)(a1 + 216);
      if (v6)
      {
        long long v27 = *(std::__shared_weak_count **)(a1 + 144);
        uint64_t v31 = *(void *)(a1 + 136);
        uint64_t v32 = v27;
        if (v27) {
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t, void))(*(void *)v26 + 80))(v26, &v31, v25, *((unsigned int *)v2 + 7));
        if (v32) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v32);
        }
      }
      else
      {
        (*(void (**)(uint64_t))(*(void *)v26 + 16))(v26);
      }
      if (v34) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v34);
      }
LABEL_53:
      if (v37) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v37);
      }
      uint64_t v28 = (void *)v2[1];
      if (v28)
      {
        do
        {
          long long v29 = v28;
          uint64_t v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          long long v29 = (void *)v2[2];
          BOOL v30 = *v29 == (void)v2;
          uint64_t v2 = v29;
        }
        while (!v30);
      }
      uint64_t v2 = v29;
    }
    while (v29 != v3);
  }
}

void sub_2224D33A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (a23) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a23);
  }
  _Unwind_Resume(exception_object);
}

void EurekaCallCommandDriver::getPreferredFormatterForSim(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 200);
  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = a2 + 200;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < (int)a3;
    if (v6 >= (int)a3) {
      uint64_t v8 = (uint64_t *)v4;
    }
    else {
      uint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 != a2 + 200 && *(_DWORD *)(v5 + 32) <= (int)a3)
  {
    uint64_t v11 = *(void *)(v5 + 40);
    uint64_t v10 = *(void *)(v5 + 48);
    *a1 = v11;
    a1[1] = v10;
    if (v10) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_11:
    int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 112) + 16))(*(void *)(a2 + 112), a3);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v12 = 0;
      _os_log_error_impl(&dword_22231A000, v9, OS_LOG_TYPE_ERROR, "Preferred formatter not found for the sim!", v12, 2u);
    }
    *a1 = 0;
    a1[1] = 0;
  }
}

void EurekaCallCommandDriver::setPreferredFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  int v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), a3);
  BOOL v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = callTechnologyToString();
    _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#I Setting preferred formatter. Call Tech: %s", buf, 0xCu);
  }
  *(_OWORD *)long long buf = 0uLL;
  EurekaCallCommandDriver::getPreferredFormatterForSim(buf, a1, a3);
  if (*(void *)buf && (*(unsigned int (**)(void, uint64_t))(**(void **)buf + 16))(*(void *)buf, a2))
  {
    uint64_t v8 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v16 = 0;
      _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#I No change in preferred formatter.", v16, 2u);
    }
  }
  else
  {
    if ((a2 - 2) < 2) {
      goto LABEL_10;
    }
    if (a2 == 1)
    {
      int v12 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)BOOL v16 = 0;
        _os_log_impl(&dword_22231A000, v12, OS_LOG_TYPE_DEFAULT, "#I Setting preferred formatter to C2K", v16, 2u);
      }
      uint64_t v13 = *(void *)(a1 + 120);
      uint64_t v14 = *(void *)(a1 + 128);
      if (v14) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
      }
      std::allocate_shared[abi:ne180100]<EurekaC2KCallFormatter,std::allocator<EurekaC2KCallFormatter>,std::shared_ptr<Registry const> const&,dispatch::queue const&,std::shared_ptr<EurekaCallCommandDriver::DelegateBase> &,void>((uint64_t)v16, (void *)(a1 + 48), a1 + 24, v13, v14);
    }
    if (a2 == 5)
    {
LABEL_10:
      int v9 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)BOOL v16 = 0;
        _os_log_impl(&dword_22231A000, v9, OS_LOG_TYPE_DEFAULT, "#I Setting preferred formatter to GSM", v16, 2u);
      }
      uint64_t v10 = *(void *)(a1 + 120);
      uint64_t v11 = *(void *)(a1 + 128);
      if (v11) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
      }
      std::allocate_shared[abi:ne180100]<EurekaGSMCallFormatter,std::allocator<EurekaGSMCallFormatter>,std::shared_ptr<Registry const> const&,dispatch::queue const&,std::shared_ptr<EurekaCallCommandDriver::DelegateBase> &,void>((uint64_t)v16, (void *)(a1 + 48), v10, v11);
    }
    long long v15 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)BOOL v16 = 136315138;
      *(void *)&void v16[4] = callTechnologyToString();
      _os_log_error_impl(&dword_22231A000, v15, OS_LOG_TYPE_ERROR, "Invalid call technology, %s. No change in preferred formatter.", v16, 0xCu);
    }
  }
  if (*(void *)&buf[8]) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
  }
}

void sub_2224D3854(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t EurekaCallCommandDriver::fillUpGSMCallCapabilities(uint64_t a1, int a2)
{
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037B0], 6, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037A8], 5, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037D8], 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037B8], 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03698], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03690], 0, a2);
  int v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 120) + 352))();
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03680], v4 ^ 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03790], 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03788], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03780], 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037A0], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037E0], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037D0], 0, a2);
  uint64_t v5 = *(uint64_t (**)(void))(**(void **)(a1 + 120) + 192);

  return v5();
}

uint64_t EurekaCallCommandDriver::fillUpC2KCallCapabilities(uint64_t a1, int a2)
{
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037B0], 2, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037A8], 2, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037D8], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037B8], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03698], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03690], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03680], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03790], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03788], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F03780], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037A0], 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037E0], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x263F037D0], 1, a2);
  int v4 = *(uint64_t (**)(void))(**(void **)(a1 + 120) + 192);

  return v4();
}

void EurekaCallCommandDriver::setPreferredFormatterBasedOnCarrierCapabilities(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  int v19 = a2;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v17, a1, a2);
  int v4 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), a2);
  uint64_t v5 = *(void *)(a1 + 264);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 264;
  do
  {
    int v7 = *(_DWORD *)(v5 + 28);
    BOOL v8 = v7 < (int)a2;
    if (v7 >= (int)a2) {
      int v9 = (uint64_t *)v5;
    }
    else {
      int v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 == a1 + 264 || *(_DWORD *)(v6 + 28) > (int)a2)
  {
LABEL_11:
    uint64_t v10 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_14;
    }
    int v11 = 0;
    goto LABEL_13;
  }
  int v11 = *(_DWORD *)(v6 + 32);
  uint64_t v10 = *v4;
  BOOL v14 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
  if (v11 != 3)
  {
    if (!v14)
    {
LABEL_14:
      uint64_t v12 = *(void *)(a1 + 120);
      uint64_t v13 = *(void *)(a1 + 128);
      if (v13) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
      }
      std::allocate_shared[abi:ne180100]<EurekaGSMCallFormatter,std::allocator<EurekaGSMCallFormatter>,std::shared_ptr<Registry const> const&,dispatch::queue const&,std::shared_ptr<EurekaCallCommandDriver::DelegateBase> &,void>((uint64_t)buf, (void *)(a1 + 48), v12, v13);
    }
LABEL_13:
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v11;
    _os_log_impl(&dword_22231A000, v10, OS_LOG_TYPE_DEFAULT, "#I Device is not CDMA based type: %d", buf, 8u);
    goto LABEL_14;
  }
  if (v14)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v10, OS_LOG_TYPE_DEFAULT, "#I Device is CDMA based", buf, 2u);
  }
  if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 16))(v17, 1) & 1) == 0)
  {
    uint64_t v15 = *(void *)(a1 + 120);
    uint64_t v16 = *(void *)(a1 + 128);
    if (v16) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
    }
    std::allocate_shared[abi:ne180100]<EurekaC2KCallFormatter,std::allocator<EurekaC2KCallFormatter>,std::shared_ptr<Registry const> const&,dispatch::queue const&,std::shared_ptr<EurekaCallCommandDriver::DelegateBase> &,void>((uint64_t)buf, (void *)(a1 + 48), a1 + 24, v15, v16);
  }
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
}

void sub_2224D3EFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN23EurekaCallCommandDriver25handleVoiceUSSDIndicationEN3qmi16SubscriptionTypeEN2vs9VoiceUSSD10IndicationE_block_invoke(uint64_t result, _DWORD *a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a2 == 2;
  return result;
}

__n128 __Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
}

void ___ZN23EurekaCallCommandDriver25handleVoiceUSSDIndicationEN3qmi16SubscriptionTypeEN2vs9VoiceUSSD10IndicationE_block_invoke_4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)a2;
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), *(std::string::value_type **)(a2 + 8), *(std::string::value_type **)(a2 + 16), *(void *)(a2 + 16) - *(void *)(a2 + 8));
}

void anonymous namespace'::sDecodeUSSDData(void *a1, uint64_t a2, int a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v9[0] = 0;
  v9[1] = 0;
  ctu::TextConverter::TextConverter((ctu::TextConverter *)v9);
  if (a3 == 3)
  {
    ctu::TextConverter::pushConversion();
    ctu::TextConverter::pushConversion();
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v6 = (const char *)a2;
    }
    else {
      uint64_t v6 = *(const char **)a2;
    }
  }
  else
  {
    ctu::TextConverter::pushConversion();
    ctu::TextConverter::pushConversion();
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v6 = (const char *)a2;
    }
    else {
      uint64_t v6 = *(const char **)a2;
    }
  }
  ctu::TextConverter::setSource((ctu::TextConverter *)v9, v6);
  ctu::TextConverter::readChars((ctu::TextConverter *)v9);
  *(_OWORD *)a1 = v7;
  a1[2] = v8;
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)v9);
}

void sub_2224D40F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)va);
  _Unwind_Resume(a1);
}

void ___ZN23EurekaCallCommandDriver25handleVoiceUSSDIndicationEN3qmi16SubscriptionTypeEN2vs9VoiceUSSD10IndicationE_block_invoke_2(uint64_t a1, __int16 **a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  __n128 __p = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  convertTo8BitVector((unint64_t *)&__p, *a2, a2[1]);
  CFStringRef v6 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x263EFFB08], (const UInt8 *)__p, v8 - (unsigned char *)__p, 0x14000100u, 0);
  bzero(buffer, 0x400uLL);
  CFStringGetCString(v6, buffer, 1024, 0x8000100u);
  std::string::__assign_external((std::string *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), buffer);
  long long v3 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v5 = (void *)(v4 + 40);
    if (*(char *)(v4 + 63) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    *(_DWORD *)long long buf = 136315138;
    int v11 = v5;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I String we got from UTF16 TLV: %s", buf, 0xCu);
  }
  ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef((const void **)&v6);
  if (__p)
  {
    uint64_t v8 = __p;
    operator delete(__p);
  }
}

void sub_2224D4264(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void convertTo8BitVector(unint64_t *a1, __int16 *a2, __int16 *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    CFStringRef v6 = 0;
    do
    {
      __int16 v7 = *v4;
      unint64_t v8 = a1[2];
      if ((unint64_t)v6 >= v8)
      {
        unint64_t v10 = *a1;
        int v11 = &v6[-*a1];
        unint64_t v12 = (unint64_t)(v11 + 1);
        if ((uint64_t)(v11 + 1) < 0) {
          goto LABEL_40;
        }
        unint64_t v13 = v8 - v10;
        if (2 * v13 > v12) {
          unint64_t v12 = 2 * v13;
        }
        if (v13 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v14 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v14 = v12;
        }
        if (v14) {
          uint64_t v15 = (char *)operator new(v14);
        }
        else {
          uint64_t v15 = 0;
        }
        uint64_t v16 = &v11[(void)v15];
        uint64_t v17 = &v11[(void)v15];
        *uint64_t v17 = v7;
        uint64_t v9 = v17 + 1;
        if (v6 != (unsigned char *)v10)
        {
          uint64_t v18 = &v6[~v10];
          do
          {
            char v19 = *--v6;
            (v18--)[(void)v15] = v19;
          }
          while (v6 != (unsigned char *)v10);
          CFStringRef v6 = (unsigned char *)*a1;
          uint64_t v16 = v15;
        }
        *a1 = (unint64_t)v16;
        a1[1] = (unint64_t)v9;
        a1[2] = (unint64_t)&v15[v14];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        unsigned char *v6 = v7;
        uint64_t v9 = v6 + 1;
      }
      a1[1] = (unint64_t)v9;
      unint64_t v20 = a1[2];
      if ((unint64_t)v9 >= v20)
      {
        unint64_t v21 = *a1;
        uint64_t v22 = &v9[-*a1];
        unint64_t v23 = (unint64_t)(v22 + 1);
        if ((uint64_t)(v22 + 1) < 0) {
LABEL_40:
        }
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        unint64_t v24 = v20 - v21;
        if (2 * v24 > v23) {
          unint64_t v23 = 2 * v24;
        }
        if (v24 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v25 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v25 = v23;
        }
        if (v25) {
          unint64_t v26 = (unint64_t)operator new(v25);
        }
        else {
          unint64_t v26 = 0;
        }
        long long v27 = (char *)(v26 + v25);
        v22[v26] = 0;
        CFStringRef v6 = &v22[v26 + 1];
        if (v9 == (unsigned char *)v21)
        {
          *a1 = (unint64_t)&v22[v26];
          a1[1] = (unint64_t)v6;
          a1[2] = (unint64_t)v27;
        }
        else
        {
          uint64_t v28 = &v9[~v21];
          do
          {
            char v29 = *--v9;
            (v28--)[v26] = v29;
          }
          while (v9 != (unsigned char *)v21);
          uint64_t v9 = (unsigned char *)*a1;
          *a1 = v26;
          a1[1] = (unint64_t)v6;
          a1[2] = (unint64_t)v27;
          if (!v9) {
            goto LABEL_38;
          }
        }
        operator delete(v9);
      }
      else
      {
        *uint64_t v9 = 0;
        CFStringRef v6 = v9 + 1;
      }
LABEL_38:
      a1[1] = (unint64_t)v6;
      ++v4;
    }
    while (v4 != a3);
  }
}

void sub_2224D4470(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    *(void *)(v1 + 8) = v2;
    operator delete(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke(uint64_t result, _WORD *a2)
{
  *(_WORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a2;
  return result;
}

void ___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)a2;
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), *(std::string::value_type **)(a2 + 8), *(std::string::value_type **)(a2 + 16), *(void *)(a2 + 16) - *(void *)(a2 + 8));
}

void ___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke_3(uint64_t a1, __int16 **a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  __n128 __p = 0;
  unint64_t v8 = 0;
  uint64_t v9 = 0;
  convertTo8BitVector((unint64_t *)&__p, *a2, a2[1]);
  CFStringRef v6 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x263EFFB08], (const UInt8 *)__p, v8 - (unsigned char *)__p, 0x14000100u, 0);
  bzero(buffer, 0x400uLL);
  CFStringGetCString(v6, buffer, 1024, 0x8000100u);
  std::string::__assign_external((std::string *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), buffer);
  long long v3 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v5 = (void *)(v4 + 40);
    if (*(char *)(v4 + 63) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    *(_DWORD *)long long buf = 136315138;
    int v11 = v5;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I String we got from UTF16 No Wait TLV: %s", buf, 0xCu);
  }
  ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef((const void **)&v6);
  if (__p)
  {
    unint64_t v8 = __p;
    operator delete(__p);
  }
}

void sub_2224D462C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke_15(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v4 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    int v8 = *a2;
    v9[0] = 67109120;
    v9[1] = v8;
    _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Failure cause is present in the response with value (0x%x)", (uint8_t *)v9, 8u);
  }
  int v5 = *a2;
  BOOL v7 = v5 == 25 || v5 == 29 || v5 == 145;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v7;
}

void EurekaCallCommandDriver::cancelUssdSession(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112));
  memset(v1, 0, sizeof(v1));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v1);
  qmi::ClientRouter::get();
  operator new();
}

void sub_2224D4924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::sendUSSDProcedure(uint64_t a1, uint64_t a2)
{
  memset(v8, 0, sizeof(v8));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v8);
  v4[0] = MEMORY[0x263EF8330];
  v4[1] = 1174405120;
  int v5 = ___ZN23EurekaCallCommandDriver17sendUSSDProcedureENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEN10subscriber7SimSlotE_block_invoke;
  CFStringRef v6 = &__block_descriptor_tmp_19_15;
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  long long v3 = qmi::MutableMessageBase::getTLV<vs::tlv::USSInfo>((uint64_t)v8);
  v5((uint64_t)v4, (uint64_t)v3);
  qmi::ClientRouter::get();
  operator new();
}

void sub_2224D4BF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
}

void *___ZN23EurekaCallCommandDriver17sendUSSDProcedureENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEN10subscriber7SimSlotE_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a2 = 1;
  if (*(char *)(a1 + 55) < 0)
  {
    uint64_t v2 = *(char **)(a1 + 32);
    unint64_t v3 = *(void *)(a1 + 40);
  }
  else
  {
    uint64_t v2 = (char *)(a1 + 32);
    unint64_t v3 = *(unsigned __int8 *)(a1 + 55);
  }
  return std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>((void *)(a2 + 8), v2, &v2[v3], v3);
}

void EurekaCallCommandDriver::sendUSSDUserReply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), a3);
  memset(v9, 0, sizeof(v9));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v9);
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 1174405120;
  CFStringRef v6 = ___ZN23EurekaCallCommandDriver17sendUSSDUserReplyENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEN10subscriber7SimSlotE_block_invoke;
  BOOL v7 = &__block_descriptor_tmp_22_16;
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  uint64_t v4 = qmi::MutableMessageBase::getTLV<vs::tlv::USSInfo>((uint64_t)v9);
  v6((uint64_t)v5, (uint64_t)v4);
  qmi::ClientRouter::get();
  operator new();
}

void sub_2224D4F48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
}

void *___ZN23EurekaCallCommandDriver17sendUSSDUserReplyENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEN10subscriber7SimSlotE_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a2 = 1;
  if (*(char *)(a1 + 55) < 0)
  {
    uint64_t v2 = *(char **)(a1 + 32);
    unint64_t v3 = *(void *)(a1 + 40);
  }
  else
  {
    uint64_t v2 = (char *)(a1 + 32);
    unint64_t v3 = *(unsigned __int8 *)(a1 + 55);
  }
  return std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>((void *)(a2 + 8), v2, &v2[v3], v3);
}

uint64_t EurekaCallCommandDriver::setCallCapability(uint64_t a1, unint64_t a2, int a3, int a4)
{
  uint64_t result = subscriber::isValidSimSlot();
  if (result)
  {
    uint64_t v9 = *(uint64_t **)(a1 + 288);
    if (v9)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v10 = (uint64_t **)v9;
          int v11 = *((_DWORD *)v9 + 8);
          if (v11 <= a4) {
            break;
          }
          uint64_t v9 = *v10;
          unint64_t v12 = v10;
          if (!*v10) {
            goto LABEL_10;
          }
        }
        if (v11 >= a4) {
          break;
        }
        uint64_t v9 = v10[1];
        if (!v9)
        {
          unint64_t v12 = v10 + 1;
          goto LABEL_10;
        }
      }
    }
    else
    {
      unint64_t v12 = (uint64_t **)(a1 + 288);
      uint64_t v10 = (uint64_t **)(a1 + 288);
LABEL_10:
      uint64_t v13 = (uint64_t *)v10;
      uint64_t v10 = (uint64_t **)operator new(0x40uLL);
      *((_DWORD *)v10 + 8) = a4;
      v10[7] = 0;
      v10[6] = 0;
      void v10[5] = (uint64_t *)(v10 + 6);
      *uint64_t v10 = 0;
      v10[1] = 0;
      _OWORD v10[2] = v13;
      *unint64_t v12 = (uint64_t *)v10;
      uint64_t v14 = **(void **)(a1 + 280);
      uint64_t v15 = (uint64_t *)v10;
      if (v14)
      {
        *(void *)(a1 + 280) = v14;
        uint64_t v15 = *v12;
      }
      uint64_t result = (uint64_t)std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 288), v15);
      ++*(void *)(a1 + 296);
    }
    uint64_t v18 = (uint64_t)v10[6];
    uint64_t v17 = v10 + 6;
    uint64_t v16 = v18;
    if (v18)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v19 = v16;
          unint64_t v20 = *(void *)(v16 + 32);
          if (v20 <= a2) {
            break;
          }
          uint64_t v16 = *(void *)v19;
          uint64_t v21 = (uint64_t **)v19;
          if (!*(void *)v19) {
            goto LABEL_21;
          }
        }
        if (v20 >= a2) {
          break;
        }
        uint64_t v16 = *(void *)(v19 + 8);
        if (!v16)
        {
          uint64_t v21 = (uint64_t **)(v19 + 8);
          goto LABEL_21;
        }
      }
    }
    else
    {
      uint64_t v21 = v17;
      uint64_t v19 = (uint64_t)v17;
LABEL_21:
      uint64_t v22 = operator new(0x30uLL);
      void v22[4] = a2;
      *((_DWORD *)v22 + 10) = 0;
      uint64_t result = (uint64_t)std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(v17 - 1, v19, v21, v22);
      uint64_t v19 = (uint64_t)v22;
    }
    *(_DWORD *)(v19 + 40) = a3;
  }
  return result;
}

void EurekaCallCommandDriver::setupDefaultCallCapabilities(void *a1, int a2)
{
  v8[0] = MEMORY[0x263EF8330];
  v8[1] = 0x40000000;
  _OWORD v8[2] = ___ZN23EurekaCallCommandDriver28setupDefaultCallCapabilitiesEN10subscriber7SimSlotE_block_invoke;
  v8[3] = &__block_descriptor_tmp_24_8;
  void v8[4] = a1;
  int v9 = a2;
  unint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (v4 = a1[1], (int v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  CFStringRef v6 = v5;
  BOOL v7 = a1[3];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 1174405120;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17CallCommandDriverE15execute_wrappedEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_26D4D22F0;
  block[5] = v4;
  int v11 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v6);
}

void ___ZN23EurekaCallCommandDriver28setupDefaultCallCapabilitiesEN10subscriber7SimSlotE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v6 = 0;
  BOOL v7 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v6, v2, *(unsigned int *)(a1 + 40));
  if (v6)
  {
    int v3 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 16))(v6, 1);
    int v4 = *(_DWORD *)(a1 + 40);
    if (v3) {
      EurekaCallCommandDriver::fillUpC2KCallCapabilities(v2, v4);
    }
    else {
      EurekaCallCommandDriver::fillUpGSMCallCapabilities(v2, v4);
    }
  }
  else
  {
    EurekaCallCommandDriver::setPreferredFormatterBasedOnCarrierCapabilities(v2, *(unsigned int *)(a1 + 40));
  }
  int v5 = v7;
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void sub_2224D5354(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t EurekaCallCommandDriver::isAbleToMakeCalls(uint64_t a1, char a2, uint64_t a3)
{
  int v3 = a3;
  uint64_t v6 = (capabilities::ct *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), a3);
  uint64_t v7 = capabilities::ct::supportsVoiceCall(v6);
  if ((v7 & 1) == 0)
  {
    int v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#E Device does not support CS voice calls. Cannot dial. Returning.", buf, 2u);
    }
  }
  if (*(unsigned char *)(a1 + 305))
  {
    int v9 = *(NSObject **)v6;
    if (os_log_type_enabled(*(os_log_t *)v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_error_impl(&dword_22231A000, v9, OS_LOG_TYPE_ERROR, "There is a silent voice call going on in Settings Model, can't dial a call. Returning", v13, 2u);
    }
    uint64_t v7 = 0;
  }
  if ((a2 & 1) == 0 && !EurekaCallCommandDriver::findCallCapability(a1, *MEMORY[0x263F03680], v3))
  {
    uint64_t v10 = *(NSObject **)v6;
    if (os_log_type_enabled(*(os_log_t *)v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t v12 = 0;
      _os_log_error_impl(&dword_22231A000, v10, OS_LOG_TYPE_ERROR, "Adding a new call is not allowed yet. Returning", v12, 2u);
    }
    return 0;
  }
  return v7;
}

uint64_t EurekaCallCommandDriver::findCallCapability(uint64_t a1, unint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 288);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = a1 + 288;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a3;
    if (v5 >= a3) {
      uint64_t v7 = (uint64_t *)v3;
    }
    else {
      uint64_t v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 288) {
    return 0;
  }
  if (*(_DWORD *)(v4 + 32) > a3) {
    return 0;
  }
  uint64_t v10 = *(void **)(v4 + 48);
  int v8 = (void *)(v4 + 48);
  int v9 = v10;
  if (!v10) {
    return 0;
  }
  int v11 = v8;
  do
  {
    unint64_t v12 = v9[4];
    BOOL v13 = v12 >= a2;
    if (v12 >= a2) {
      uint64_t v14 = v9;
    }
    else {
      uint64_t v14 = v9 + 1;
    }
    if (v13) {
      int v11 = v9;
    }
    int v9 = (void *)*v14;
  }
  while (*v14);
  if (v11 != v8 && v11[4] <= a2) {
    return *((unsigned int *)v11 + 10);
  }
  else {
    return 0;
  }
}

uint64_t EurekaCallCommandDriver::prepareToDial(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (capabilities::ct *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), *(unsigned int *)(a2 + 252));
  uint64_t v5 = capabilities::ct::supportsVoiceCall(v4);
  if ((v5 & 1) == 0)
  {
    BOOL v6 = *(NSObject **)v4;
    if (os_log_type_enabled(*(os_log_t *)v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_22231A000, v6, OS_LOG_TYPE_ERROR, "Device does not support CS voice calls. Cannot dial. Returning.", buf, 2u);
    }
  }
  if (*(unsigned char *)(a2 + 84))
  {
    if (*(unsigned char *)(a1 + 304))
    {
      uint64_t v7 = *(NSObject **)v4;
      uint64_t v5 = 0;
      if (os_log_type_enabled(*(os_log_t *)v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v9 = 0;
        _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#I In ECBM mode. Pending dial till BB is out of ECBM mode", v9, 2u);
        return 0;
      }
    }
  }
  return v5;
}

void EurekaCallCommandDriver::dial(CallCommandDriver *a1, uint64_t a2)
{
  uint64_t v109 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(unsigned int *)(a2 + 252);
  uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void *, uint64_t))(**((void **)a1 + 14) + 16))(*((void **)a1 + 14), v4);
  BOOL v6 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = (void *)(a2 + 32);
    if (*(char *)(a2 + 55) < 0) {
      uint64_t v7 = (void *)*v7;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = subscriber::asString();
    _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#I Dialing call to %s on slot %s", buf, 0x16u);
  }
  if (*(_DWORD *)(a2 + 64) == 7)
  {
    int v8 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#I Visible OTASP started", buf, 2u);
    }
    (*(void (**)(void *, uint64_t))(**((void **)a1 + 27) + 24))(*((void **)a1 + 27), 1);
  }
  if (*(unsigned char *)(a2 + 84))
  {
    long long v78 = 0u;
    memset(&v77[8], 0, 400);
    *(void *)v77 = a1;
    CallInfo::CallInfo((CallInfo *)&v77[8], (const CallInfo *)a2);
    DWORD2(v78) = v4;
    CallInfo::CallInfo((CallInfo *)&v75, (const CallInfo *)&v77[8]);
    *(void *)long long buf = a1;
    CallInfo::CallInfo((CallInfo *)&buf[8], (const CallInfo *)&v77[8]);
    int v9 = DWORD2(v78);
    int v107 = DWORD2(v78);
    v108 = 0;
    uint64_t v10 = (char *)operator new(0x1B0uLL);
    *(void *)uint64_t v10 = &unk_26D4D0EA0;
    long long v11 = *(_OWORD *)&buf[16];
    *(_OWORD *)(v10 + 8) = *(_OWORD *)buf;
    *(void *)&uint8_t buf[16] = 0;
    *(void *)&uint8_t buf[8] = 0;
    *(_OWORD *)(v10 + 24) = v11;
    uint64_t v12 = v82;
    *((void *)v10 + 5) = v80;
    *(void *)&uint8_t buf[24] = 0;
    uint64_t v80 = 0;
    *((_OWORD *)v10 + 3) = v81;
    *((void *)v10 + 8) = v12;
    long long v81 = 0uLL;
    long long v13 = v84;
    *(_OWORD *)(v10 + 72) = v83;
    long long v14 = v85;
    long long v15 = *(_OWORD *)v86;
    *(void *)(v10 + 133) = *(void *)&v86[13];
    *(_OWORD *)(v10 + 120) = v15;
    *(_OWORD *)(v10 + 104) = v14;
    *(_OWORD *)(v10 + 88) = v13;
    long long v16 = v87;
    *((void *)v10 + 20) = v88;
    *((_OWORD *)v10 + 9) = v16;
    uint64_t v82 = 0;
    long long v87 = 0uLL;
    uint64_t v88 = 0;
    *((_DWORD *)v10 + 42) = v89;
    long long v17 = v90;
    *((void *)v10 + 24) = v91;
    *((_OWORD *)v10 + 11) = v17;
    long long v90 = 0uLL;
    uint64_t v91 = 0;
    long long v18 = v92[0];
    *(_OWORD *)(v10 + 209) = *(_OWORD *)((char *)v92 + 9);
    *(_OWORD *)(v10 + 200) = v18;
    v10[232] = 0;
    v10[256] = 0;
    if (v95)
    {
      *(_OWORD *)(v10 + 232) = v93;
      *((void *)v10 + 31) = v94;
      uint64_t v94 = 0;
      long long v93 = 0uLL;
      v10[256] = 1;
    }
    v10[280] = v97;
    *(_OWORD *)(v10 + 264) = v96;
    *((void *)v10 + 38) = v99;
    *((_OWORD *)v10 + 18) = v98;
    long long v98 = 0uLL;
    *((void *)v10 + 41) = v101;
    *(_OWORD *)(v10 + 312) = v100;
    uint64_t v99 = 0;
    long long v100 = 0uLL;
    uint64_t v101 = 0;
    long long v19 = v103;
    *((_OWORD *)v10 + 21) = v102;
    *((_OWORD *)v10 + 22) = v19;
    long long v20 = v104;
    long long v21 = v105;
    long long v22 = *(_OWORD *)v106;
    *(void *)(v10 + 413) = *(void *)&v106[13];
    *((_OWORD *)v10 + 24) = v21;
    *((_OWORD *)v10 + 25) = v22;
    *((_OWORD *)v10 + 23) = v20;
    *((_DWORD *)v10 + 106) = v9;
    v108 = v10;
    EurekaCallCommandDriver::sendDialReq(a1, (uint64_t)&v75);
  }
  uint64_t v74 = 0;
  uint64_t v73 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v73, (uint64_t)a1, v4);
  uint64_t v23 = v73;
  if (v73)
  {
    memset(v77, 0, 64);
    CallInfo::CallInfo((CallInfo *)v72, (const CallInfo *)a2);
    (*(void (**)(unsigned char *__return_ptr, uint64_t, void **, void **))(*(void *)v23 + 24))(v77, v23, v72, (void **)a1 + 17);
    CallInfo::~CallInfo(v72);
    long long v24 = *(_OWORD *)v77;
    if (*(void *)&v77[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v77[8] + 8), 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v24 + 1));
    }
    if ((void)v24)
    {
      if ((v4 - 1) >= 3) {
        int v25 = 0;
      }
      else {
        int v25 = v4;
      }
      if (*(void *)&v77[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v77[8] + 8), 1uLL, memory_order_relaxed);
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(&v71, v25);
    }
    long long v27 = *v5;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v27, OS_LOG_TYPE_DEFAULT, "#I Formatter requires a normal dial", buf, 2u);
    }
    CallInfo::CallInfo((CallInfo *)v70, (const CallInfo *)a2);
    *(void *)&long long v40 = a1;
    CallInfo::CallInfo((CallInfo *)((char *)&v40 + 8), (const CallInfo *)a2);
    int v69 = v4;
    v76 = 0;
    uint64_t v28 = (char *)operator new(0x1B0uLL);
    *(void *)uint64_t v28 = &unk_26D4D23E0;
    long long v29 = v41;
    *(_OWORD *)(v28 + 8) = v40;
    *((void *)&v40 + 1) = 0;
    *(void *)&long long v41 = 0;
    *(_OWORD *)(v28 + 24) = v29;
    *((void *)v28 + 5) = v42;
    *((void *)&v41 + 1) = 0;
    uint64_t v42 = 0;
    *((_OWORD *)v28 + 3) = v43;
    *((void *)v28 + 8) = v44;
    long long v43 = 0uLL;
    long long v30 = v46;
    *(_OWORD *)(v28 + 72) = v45;
    long long v31 = v47;
    long long v32 = *(_OWORD *)v48;
    *(void *)(v28 + 133) = *(void *)&v48[13];
    *(_OWORD *)(v28 + 120) = v32;
    *(_OWORD *)(v28 + 104) = v31;
    *(_OWORD *)(v28 + 88) = v30;
    long long v33 = v49;
    *((void *)v28 + 20) = v50;
    *((_OWORD *)v28 + 9) = v33;
    uint64_t v44 = 0;
    long long v49 = 0uLL;
    uint64_t v50 = 0;
    *((_DWORD *)v28 + 42) = v51;
    long long v34 = v52;
    *((void *)v28 + 24) = v53;
    *((_OWORD *)v28 + 11) = v34;
    long long v52 = 0uLL;
    uint64_t v53 = 0;
    long long v35 = v54[0];
    *(_OWORD *)(v28 + 209) = *(_OWORD *)((char *)v54 + 9);
    *(_OWORD *)(v28 + 200) = v35;
    v28[232] = 0;
    v28[256] = 0;
    if (v57)
    {
      *(_OWORD *)(v28 + 232) = v55;
      *((void *)v28 + 31) = v56;
      uint64_t v56 = 0;
      long long v55 = 0uLL;
      v28[256] = 1;
    }
    v28[280] = v59;
    *(_OWORD *)(v28 + 264) = v58;
    *((void *)v28 + 38) = v61;
    *((_OWORD *)v28 + 18) = v60;
    long long v60 = 0uLL;
    *((void *)v28 + 41) = v63;
    *(_OWORD *)(v28 + 312) = v62;
    uint64_t v61 = 0;
    long long v62 = 0uLL;
    uint64_t v63 = 0;
    long long v36 = v65;
    *((_OWORD *)v28 + 21) = v64;
    *((_OWORD *)v28 + 22) = v36;
    long long v37 = v66;
    long long v38 = v67;
    long long v39 = *(_OWORD *)v68;
    *(void *)(v28 + 413) = *(void *)&v68[13];
    *((_OWORD *)v28 + 24) = v38;
    *((_OWORD *)v28 + 25) = v39;
    *((_OWORD *)v28 + 23) = v37;
    *((_DWORD *)v28 + 106) = v4;
    v76 = v28;
    EurekaCallCommandDriver::sendDialReq(a1, (uint64_t)v70);
  }
  unint64_t v26 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl(&dword_22231A000, v26, OS_LOG_TYPE_ERROR, "Second call cannot be dialed out if preferred formatter is not set. Not dialing.", buf, 2u);
  }
  if (v74) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v74);
  }
}

void sub_2224D5FA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,void *a62)
{
  std::__function::__value_func<void ()(vs::VoiceDialCall::Response const&)>::~__value_func[abi:ne180100](&STACK[0x690]);
  CallInfo::~CallInfo(v62);
  CallInfo::~CallInfo(&a62);
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)&STACK[0x6B0]);
  if (STACK[0x4F0]) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)STACK[0x4F0]);
  }
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::dial(CallInfo)::$_1::~$_1(uint64_t a1)
{
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  return a1;
}

void EurekaCallCommandDriver::sendDialReq(CallCommandDriver *a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  long long v31 = 0u;
  long long v32 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v31);
  uint64_t v4 = *(unsigned int *)(a2 + 252);
  uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void *, uint64_t))(**((void **)a1 + 14) + 16))(*((void **)a1 + 14), v4);
  v29[0] = MEMORY[0x263EF8330];
  v29[1] = 1174405120;
  v29[2] = ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke;
  v29[3] = &__block_descriptor_tmp_25_8;
  CallInfo::CallInfo((CallInfo *)&v30, (const CallInfo *)a2);
  BOOL v6 = qmi::MutableMessageBase::getTLV<vs::tlv::CallingNumber>((uint64_t)&v31, 1);
  ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke((uint64_t)v29, v6);
  int v7 = *(_DWORD *)(a2 + 64);
  if (v7 == 3)
  {
    *(void *)long long v34 = 0;
    *(void *)&v34[8] = 0;
    EurekaCallCommandDriver::getPreferredFormatterForSim(v34, (uint64_t)a1, v4);
    if (*(void *)v34)
    {
      if ((*(unsigned int (**)(void))(**(void **)v34 + 144))(*(void *)v34)) {
        int v7 = 2;
      }
      else {
        int v7 = 1;
      }
    }
    else
    {
      int v8 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#I Dialing test emergency number but not registered to a network as yet, so don't know if it's okay to dial test number. Dialing as normal call to BB", buf, 2u);
      }
      int v7 = 1;
    }
    *(_DWORD *)(a2 + 64) = v7;
    if (*(void *)&v34[8])
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v34[8]);
      int v7 = *(_DWORD *)(a2 + 64);
    }
  }
  if (v7 == 2)
  {
    int v11 = *(_DWORD *)(a2 + 96);
    uint64_t v12 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      long long v13 = (void *)(a2 + 32);
      if (*(char *)(a2 + 55) < 0) {
        long long v13 = (void *)*v13;
      }
      *(_DWORD *)long long v34 = 136315394;
      *(void *)&v34[4] = v13;
      *(_WORD *)&v34[12] = 1024;
      *(_DWORD *)&v34[14] = v11;
      _os_log_impl(&dword_22231A000, v12, OS_LOG_TYPE_DEFAULT, "#I Dialing emergency call, %s, with category, %d", v34, 0x12u);
    }
    v27[0] = MEMORY[0x263EF8330];
    v27[1] = 0x40000000;
    v27[2] = ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke_31;
    v27[3] = &__block_descriptor_tmp_33_6;
    int v28 = v11;
    long long v14 = (const void **)*((void *)&v31 + 1);
    if (*((void *)&v31 + 1) != (void)v32)
    {
      while (*((unsigned char *)*v14 + 8) != 20)
      {
        if (++v14 == (const void **)v32) {
          goto LABEL_29;
        }
      }
    }
    if (v14 == (const void **)v32) {
LABEL_29:
    }
      operator new();
    if (!v15) {
      __cxa_bad_cast();
    }
    ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke_31((uint64_t)v27, v15 + 9);
    *qmi::MutableMessageBase::getTLV<vs::tlv::CallType>((uint64_t)&v31, 16) = 9;
  }
  else if (v7 == 1)
  {
    int v9 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = (void *)(a2 + 32);
      if (*(char *)(a2 + 55) < 0) {
        uint64_t v10 = (void *)*v10;
      }
      *(_DWORD *)long long v34 = 136315138;
      *(void *)&v34[4] = v10;
      _os_log_impl(&dword_22231A000, v9, OS_LOG_TYPE_DEFAULT, "#I Dialing Normal Voice Call(%s)", v34, 0xCu);
    }
    *qmi::MutableMessageBase::getTLV<vs::tlv::CallType>((uint64_t)&v31, 16) = 0;
  }
  unsigned int v16 = CallCommandDriver::computeClirValue_sync(a1, (const CallInfo *)a2);
  if (v16 <= 1)
  {
    if (v16 == 1) {
      int v17 = 2;
    }
    else {
      int v17 = 1;
    }
    long long v18 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = asString();
      *(_DWORD *)long long v34 = 136315138;
      *(void *)&v34[4] = v19;
      _os_log_impl(&dword_22231A000, v18, OS_LOG_TYPE_DEFAULT, "#I Setting CLIR - %s", v34, 0xCu);
    }
    v25[0] = MEMORY[0x263EF8330];
    v25[1] = 0x40000000;
    void v25[2] = ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke_37;
    v25[3] = &__block_descriptor_tmp_39_6;
    int v26 = v17;
    long long v20 = (const void **)*((void *)&v31 + 1);
    if (*((void *)&v31 + 1) != (void)v32)
    {
      while (*((unsigned char *)*v20 + 8) != 17)
      {
        if (++v20 == (const void **)v32) {
          goto LABEL_43;
        }
      }
    }
    if (v20 == (const void **)v32) {
LABEL_43:
    }
      operator new();
    if (!v21) {
      __cxa_bad_cast();
    }
    ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke_37((uint64_t)v25, v21 + 9);
  }
  if ((*(unsigned int (**)(void *, uint64_t))(**((void **)a1 + 15) + 360))(*((void **)a1 + 15), a2))
  {
    v24[0] = MEMORY[0x263EF8330];
    v24[1] = 0x40000000;
    void v24[2] = ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke_2_40;
    v24[3] = &__block_descriptor_tmp_42_5;
    v24[4] = v5;
    long long v22 = qmi::MutableMessageBase::getTLV<vs::tlv::TtyMode>((uint64_t)&v31, 96);
    ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke_2_40((uint64_t)v24, v22);
  }
  if ((v4 - 1) >= 3) {
    LODWORD(v4) = 0;
  }
  qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::VoiceDialCall::Request>(&v23, v4);
}

void sub_2224D6A64(_Unwind_Exception *a1)
{
  CallInfo::~CallInfo(v1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v2 - 256));
  _Unwind_Resume(a1);
}

void *___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke(uint64_t a1, void *a2)
{
  if (*(char *)(a1 + 87) < 0)
  {
    uint64_t v3 = *(char **)(a1 + 64);
    unint64_t v4 = *(void *)(a1 + 72);
  }
  else
  {
    uint64_t v3 = (char *)(a1 + 64);
    unint64_t v4 = *(unsigned __int8 *)(a1 + 87);
  }
  return std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(a2, v3, &v3[v4], v4);
}

void __copy_helper_block_e8_32c13_ZTS8CallInfo(uint64_t a1, uint64_t a2)
{
}

void __destroy_helper_block_e8_32c13_ZTS8CallInfo(uint64_t a1)
{
}

uint64_t ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke_31(uint64_t result, unsigned char *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

uint64_t ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke_37(uint64_t result, unsigned char *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

void ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke_2_40(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = **(NSObject ***)(a1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v4 = 0;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I Setting TTY to On, Full", v4, 2u);
  }
  *a2 = 0;
}

void EurekaCallCommandDriver::handleNormalVoiceDialResp(uint64_t a1, qmi::MessageBase *a2, const void **a3, uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  uint64_t v53 = 0;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  memset(v32, 0, sizeof(v32));
  CallInfo::CallInfo((CallInfo *)v32);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::operator=((const void **)v32, a3);
  HIDWORD(v43) = a4;
  int v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), a4);
  int v9 = v8;
  int v10 = *((_DWORD *)a2 + 1);
  if (v10)
  {
    int v11 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v27 = qmi::asString();
      int v28 = *((_DWORD *)a2 + 1);
      *(_DWORD *)long long v55 = 136315394;
      *(void *)&v55[4] = v27;
      *(_WORD *)&v55[12] = 1024;
      *(_DWORD *)&v55[14] = v28;
      _os_log_error_impl(&dword_22231A000, v11, OS_LOG_TYPE_ERROR, "Error in voice dial response with %s (0x%x)", v55, 0x12u);
      int v10 = *((_DWORD *)a2 + 1);
    }
    int v12 = (unsigned __int16)v10;
    if ((unsigned __int16)v10 <= 0x5Au)
    {
      if (!(_WORD)v10) {
        goto LABEL_22;
      }
      if ((unsigned __int16)v10 == 35)
      {
        int v12 = 36;
        goto LABEL_22;
      }
    }
    else
    {
      switch((unsigned __int16)v10)
      {
        case '[':
          int v12 = 41;
          goto LABEL_22;
        case 'j':
          int v12 = 37;
          goto LABEL_22;
        case 'f':
          int v12 = 35;
          goto LABEL_22;
      }
    }
    int v12 = 1;
LABEL_22:
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    int v17 = ServiceMap;
    uint64_t v18 = *(void *)(MEMORY[0x263F035B0] + 8);
    if (v18 < 0)
    {
      uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v20 = 5381;
      do
      {
        uint64_t v18 = v20;
        unsigned int v21 = *v19++;
        uint64_t v20 = (33 * v20) ^ v21;
      }
      while (v21);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long v55 = v18;
    long long v22 = std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<void>>>>::find<unsigned long>(&v17[1].__m_.__sig, (unint64_t *)v55);
    if (v22)
    {
      uint64_t v24 = v22[3];
      int v23 = (std::__shared_weak_count *)v22[4];
      if (v23)
      {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v17);
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        std::__shared_weak_count::__release_shared[abi:ne180100](v23);
        char v25 = 0;
        goto LABEL_30;
      }
    }
    else
    {
      uint64_t v24 = 0;
    }
    std::mutex::unlock(v17);
    int v23 = 0;
    char v25 = 1;
LABEL_30:
    if (v10 <= 89)
    {
      if (v10 > 0x30 || ((1 << v10) & 0x1040001826010) == 0) {
        goto LABEL_51;
      }
    }
    else
    {
      if (v10 <= 241)
      {
        switch(v10)
        {
          case 'Z':
            goto LABEL_37;
          case '[':
            (*(void (**)(uint64_t, uint64_t))(*(void *)v24 + 240))(v24, a4);
            int v26 = *v9;
            if (!os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR)) {
              goto LABEL_38;
            }
            *(_WORD *)long long v55 = 0;
            break;
          case '\\':
          case ']':
          case '^':
            goto LABEL_51;
          case '_':
            if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v24 + 248))(v24, a4) & 1) == 0) {
              goto LABEL_56;
            }
            goto LABEL_38;
            goto LABEL_49;
          default:
            if (v10 != 228) {
              goto LABEL_51;
            }
            goto LABEL_37;
        }
LABEL_58:
        _os_log_error_impl(&dword_22231A000, v26, OS_LOG_TYPE_ERROR, "Accepted this error. Don't do anything besides ending the call.", v55, 2u);
LABEL_38:
        if ((v25 & 1) == 0) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v23);
        }
LABEL_40:
        (*(void (**)(void, _OWORD *))(**(void **)(a1 + 120) + 16))(*(void *)(a1 + 120), v32);
        goto LABEL_41;
      }
      if (v10 > 513)
      {
        if (v10 != 514 && v10 != 65537) {
          goto LABEL_51;
        }
      }
      else
      {
        if (v10 == 242)
        {
LABEL_49:
          (*(void (**)(uint64_t, uint64_t))(*(void *)v24 + 248))(v24, a4);
          goto LABEL_38;
        }
        if (v10 != 243)
        {
LABEL_51:
          std::string::basic_string[abi:ne180100]<0>(&__p, "Error in Dial Response");
          rest::ResetPayload::ResetPayload();
          ctu::rest::event_t<rest::reset_request,rest::ResetPayload>::send();
          if ((v55[23] & 0x80000000) != 0) {
            operator delete(*(void **)v55);
          }
          if (v31 < 0) {
            operator delete(__p);
          }
LABEL_56:
          WORD2(v35) = v10;
          DWORD2(v35) = v12;
          BYTE12(v35) = 1;
          goto LABEL_38;
        }
      }
    }
LABEL_37:
    int v26 = *v9;
    if (!os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    *(_WORD *)long long v55 = 0;
    goto LABEL_58;
  }
  *(void *)long long v55 = 0;
  *(void *)&v55[8] = v55;
  *(void *)&v55[16] = 0x2000000000;
  int v56 = -1;
  v29[0] = MEMORY[0x263EF8330];
  v29[1] = 0x40000000;
  v29[2] = ___ZN23EurekaCallCommandDriver25handleNormalVoiceDialRespERKN2vs13VoiceDialCall8ResponseEN3ctu2cf11CFSharedRefIK8__CFUUIDEEN10subscriber7SimSlotE_block_invoke;
  v29[3] = &unk_2646109D0;
  void v29[4] = v55;
  *(void *)long long buf = v29;
  char v13 = qmi::MessageBase::applyTlv<vs::tlv::CallIdentifier,void({block_pointer})(vs::tlv::CallIdentifier const&)>(a2, 16, (uint64_t)buf);
  long long v14 = *v9;
  if (v13)
  {
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = *(_DWORD *)(*(void *)&v55[8] + 24);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v15;
      _os_log_impl(&dword_22231A000, v14, OS_LOG_TYPE_DEFAULT, "#I The dialed call got a call ID: %d", buf, 8u);
    }
    HIDWORD(v33) = *(_DWORD *)(*(void *)&v55[8] + 24);
    _Block_object_dispose(v55, 8);
    goto LABEL_40;
  }
  if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl(&dword_22231A000, v14, OS_LOG_TYPE_ERROR, "Mandatory TLV, callId, (0x01) not present. Ignoring response.", buf, 2u);
  }
  _Block_object_dispose(v55, 8);
LABEL_41:
  CallInfo::~CallInfo((void **)v32);
}

void sub_2224D71A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20)
{
  if ((v21 & 1) == 0) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  }
  CallInfo::~CallInfo(&a20);
  _Unwind_Resume(a1);
}

uint64_t ___ZN23EurekaCallCommandDriver25handleNormalVoiceDialRespERKN2vs13VoiceDialCall8ResponseEN3ctu2cf11CFSharedRefIK8__CFUUIDEEN10subscriber7SimSlotE_block_invoke(uint64_t result, unsigned __int8 *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a2;
  return result;
}

uint64_t ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke(uint64_t result, unsigned char *a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a2;
  return result;
}

uint64_t ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_47(uint64_t result, unsigned __int8 *a2)
{
  *(_WORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a2;
  return result;
}

std::string *___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_50(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned char *)a2;
  return std::string::operator=((std::string *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), (const std::string *)(a2 + 8));
}

double ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_2(uint64_t a1, char **a2)
{
  std::string::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(&v6, *a2, a2[1], a2[1] - *a2);
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v4 = v3 + 40;
  if (*(char *)(v3 + 63) < 0) {
    operator delete(*(void **)v4);
  }
  double result = *(double *)&v6;
  *(_OWORD *)uint64_t v4 = v6;
  *(void *)(v4 + 16) = v7;
  return result;
}

double ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_3(uint64_t a1, char **a2)
{
  std::string::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(&v6, *a2, a2[1], a2[1] - *a2);
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v4 = v3 + 40;
  if (*(char *)(v3 + 63) < 0) {
    operator delete(*(void **)v4);
  }
  double result = *(double *)&v6;
  *(_OWORD *)uint64_t v4 = v6;
  *(void *)(v4 + 16) = v7;
  return result;
}

uint64_t ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_4(uint64_t result, unsigned char *a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a2;
  return result;
}

uint64_t ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_56(uint64_t result, unsigned char *a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a2;
  *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = a2[2];
  return result;
}

void ___ZN23EurekaCallCommandDriver29handleVoiceHandoverIndicationEN3qmi16SubscriptionTypeEN2vs13VoiceHandover10IndicationE_block_invoke(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  unsigned int v3 = *(_DWORD *)(a1 + 64);
  if (v3 - 1 >= 3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 112) + 16))(*(void *)(v2 + 112), v4);
  long long v6 = v5;
  int v7 = *(_DWORD *)(a1 + 44);
  if (!v7)
  {
    int v9 = (unsigned __int16 *)(a1 + 40);
    uint64_t v19 = 0;
    uint64_t v20 = &v19;
    uint64_t v21 = 0x2000000000;
    int v22 = 4;
    *(void *)long long buf = MEMORY[0x263EF8330];
    *(void *)&long long v26 = 0x40000000;
    *((void *)&v26 + 1) = ___ZN23EurekaCallCommandDriver34handleVoiceHandoverIndication_syncEN3qmi16SubscriptionTypeERKN2vs13VoiceHandover10IndicationE_block_invoke;
    uint64_t v27 = &unk_264610B10;
    int v28 = &v19;
    uint64_t TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)(a1 + 40));
    uint64_t v12 = TlvValue;
    if (TlvValue)
    {
      int v13 = v11;
      *(void *)uint64_t v24 = TlvValue;
      int v23 = tlv::parseV<vs::tlv::HandoverState>((unint64_t *)v24, v11);
      if (*(void *)v24)
      {
        (*((void (**)(uint8_t *, int *))&v26 + 1))(buf, &v23);
        long long v14 = *v6;
LABEL_12:
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v16 = vs::callList::asString(*((_DWORD *)v20 + 6));
          *(_DWORD *)uint64_t v24 = 136315138;
          *(void *)&v24[4] = v16;
          _os_log_impl(&dword_22231A000, v14, OS_LOG_TYPE_DEFAULT, "#I HO state: %s", v24, 0xCu);
        }
        int v17 = 1;
        uint64_t v18 = 1;
        switch(*((_DWORD *)v20 + 6))
        {
          case 2:
            int v17 = 0;
            uint64_t v18 = 2;
            break;
          case 3:
            int v17 = 0;
            uint64_t v18 = 3;
            break;
          case 4:
            int v17 = 0;
            uint64_t v18 = 4;
            break;
          case 0xA:
            int v17 = 0;
            uint64_t v18 = 5;
            break;
          default:
            break;
        }
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 120) + 160))(*(void *)(v2 + 120), v18, v4);
        if (v17) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 120) + 160))(*(void *)(v2 + 120), 6, v4);
        }
LABEL_23:
        _Block_object_dispose(&v19, 8);
        return;
      }
      char v15 = ((uint64_t (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*v9, 1, v12, v13);
      long long v14 = *v6;
      if (v15) {
        goto LABEL_12;
      }
    }
    else
    {
      long long v14 = *v6;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v24 = 0;
      _os_log_error_impl(&dword_22231A000, v14, OS_LOG_TYPE_ERROR, "handleVoiceHandoverIndication_sync did not receive the mandatory state TLV", v24, 2u);
    }
    goto LABEL_23;
  }
  int v8 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = v7;
    LOWORD(v26) = 2080;
    *(void *)((char *)&v26 + 2) = qmi::asString();
    _os_log_error_impl(&dword_22231A000, v8, OS_LOG_TYPE_ERROR, "handleVoiceHandoverIndication_sync: Error in indication with code = 0x%x (%s)", buf, 0x12u);
  }
}

void sub_2224D7710(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *__copy_helper_block_e8_40c36_ZTSN2vs13VoiceHandover10IndicationE(void *result, void *a2)
{
  result[5] = a2[5];
  uint64_t v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_40c36_ZTSN2vs13VoiceHandover10IndicationE(uint64_t a1)
{
}

uint64_t ___ZN23EurekaCallCommandDriver34handleVoiceHandoverIndication_syncEN3qmi16SubscriptionTypeERKN2vs13VoiceHandover10IndicationE_block_invoke(uint64_t result, _DWORD *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a2;
  return result;
}

__n128 __Block_byref_object_copy__62(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__63(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

char *___ZN23EurekaCallCommandDriver32parseAndUpdateParentCallIds_syncERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke(char *result, const void **a2)
{
  uint64_t v2 = *(void **)(*((void *)result + 4) + 8);
  if (v2 + 5 != a2)
  {
    unsigned int v3 = (char *)*a2;
    uint64_t v4 = (char *)a2[1];
    size_t v5 = v4 - (unsigned char *)*a2;
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * v5;
    uint64_t v7 = v2[7];
    int v8 = (char *)v2[5];
    if (0xAAAAAAAAAAAAAAABLL * (v7 - (void)v8) >= 0xAAAAAAAAAAAAAAABLL * v5)
    {
      char v15 = (char *)v2[6];
      uint64_t v12 = (char **)(v2 + 6);
      long long v14 = v15;
      size_t v16 = v15 - v8;
      unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (v15 - v8);
      if (v17 < v6)
      {
        uint64_t v18 = &v3[3 * v17];
        if (v14 != v8)
        {
          __n128 result = (char *)memmove(v8, *a2, v16);
          int v8 = *v12;
        }
        size_t v5 = v4 - v18;
        if (v4 == v18) {
          goto LABEL_21;
        }
        uint64_t v19 = v8;
        uint64_t v20 = v18;
        goto LABEL_20;
      }
    }
    else
    {
      if (v8)
      {
        v2[6] = v8;
        operator delete(v8);
        uint64_t v7 = 0;
        v2[5] = 0;
        v2[6] = 0;
        v2[7] = 0;
      }
      if (v6 >= 0x5555555555555556) {
        goto LABEL_23;
      }
      unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * v7;
      uint64_t v10 = 2 * v9;
      if (2 * v9 <= v6) {
        uint64_t v10 = 0xAAAAAAAAAAAAAAABLL * v5;
      }
      unint64_t v11 = v9 >= 0x2AAAAAAAAAAAAAAALL ? 0x5555555555555555 : v10;
      if (v11 >= 0x5555555555555556) {
LABEL_23:
      }
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::ParentCallInfoItem>>((uint64_t)(v2 + 7), v11);
      int v8 = result;
      v2[6] = result;
      uint64_t v12 = (char **)(v2 + 6);
      *(v12 - 1) = result;
      v12[1] = &result[3 * v13];
    }
    if (v4 == v3)
    {
LABEL_21:
      *uint64_t v12 = &v8[v5];
      return result;
    }
    uint64_t v19 = v8;
    uint64_t v20 = v3;
LABEL_20:
    __n128 result = (char *)memmove(v19, v20, v5);
    goto LABEL_21;
  }
  return result;
}

void EurekaCallCommandDriver::endThisCall(uint64_t a1, unsigned int *a2)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v4 = a2[63];
  size_t v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), v4);
  uint64_t v19 = 0;
  uint64_t v18 = 0;
  uint64_t v20 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 120) + 328))(&v18);
  if (v19 - v18 == 408)
  {
    unint64_t v6 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#I There is one call. End this call generically. EndCall request.", buf, 2u);
    }
    memset(v17, 0, sizeof(v17));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v17);
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 1174405120;
    _OWORD v15[2] = ___ZN23EurekaCallCommandDriver11endThisCallE8CallInfo_block_invoke;
    v15[3] = &__block_descriptor_tmp_95_4;
    CallInfo::CallInfo((CallInfo *)&v16, (const CallInfo *)a2);
    uint64_t v7 = qmi::MutableMessageBase::getTLV<vs::tlv::CallIdentifier>((uint64_t)v17, 1);
    ___ZN23EurekaCallCommandDriver11endThisCallE8CallInfo_block_invoke((uint64_t)v15, v7);
    if ((v4 - 1) >= 3) {
      LODWORD(v4) = 0;
    }
    qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<vs::EndCall::Request>(&v14, v4);
  }
  int v22 = 0;
  uint64_t aBlock = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&aBlock, a1, v4);
  uint64_t v8 = aBlock;
  unint64_t v9 = *v5;
  if (aBlock)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v9, OS_LOG_TYPE_DEFAULT, "#I There is more than one call when trying to end this call. Ask the formatter how to end.", buf, 2u);
    }
    *(_OWORD *)long long buf = 0u;
    memset(v24, 0, sizeof(v24));
    CallInfo::CallInfo((CallInfo *)v13, (const CallInfo *)a2);
    (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v8 + 56))(buf, v8, v13);
    CallInfo::~CallInfo(v13);
    uint64_t v10 = *(void *)buf;
    unint64_t v11 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v11);
    }
    if (v10)
    {
      if ((v4 - 1) >= 3) {
        int v12 = 0;
      }
      else {
        int v12 = v4;
      }
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(v17, v12);
    }
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v24);
    if (*(void *)&buf[8]) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
    }
  }
  else if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl(&dword_22231A000, v9, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in endThisCall", buf, 2u);
  }
  if (v22) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  }
  *(void *)long long buf = &v18;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
}

void sub_2224D7FD4(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100]((void *)(v3 - 136));
  uint64_t v5 = STACK[0x368];
  STACK[0x368] = 0;
  if (v5) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v2, v5);
  }
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)&STACK[0x3C0]);
  if (STACK[0x3A0]) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)STACK[0x3A0]);
  }
  STACK[0x3C0] = (unint64_t)&STACK[0x380];
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x3C0]);
  _Unwind_Resume(a1);
}

void sub_2224D80D0()
{
}

void EurekaCallCommandDriver::handleVoiceAllCallStatusIndication(uint64_t a1, uint64_t a2, qmi::MessageBase *a3)
{
  unsigned int v4 = a2;
  uint64_t v5 = a1;
  uint64_t v260 = *MEMORY[0x263EF8340];
  unsigned int v6 = a2 - 1;
  if ((a2 - 1) >= 3) {
    a2 = 0;
  }
  else {
    a2 = a2;
  }
  uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), a2);
  uint64_t v8 = v7;
  int v9 = *((_DWORD *)a3 + 1);
  if (v9)
  {
    uint64_t v10 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v9;
      *(_WORD *)&uint8_t buf[8] = 2080;
      *(void *)&buf[10] = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v10, OS_LOG_TYPE_ERROR, "handleVoiceAllCallStatusIndication: Error in indication with code = 0x%x (%s)", buf, 0x12u);
    }
    return;
  }
  if (*(unsigned char *)(v5 + 305))
  {
    unint64_t v11 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v11, OS_LOG_TYPE_DEFAULT, "#N Active call in Settings, ignoring the Call Status Indication", buf, 2u);
    }
    return;
  }
  if (v6 >= 3) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = v4;
  }
  uint64_t v201 = 0;
  v202 = &v201;
  uint64_t v203 = 0x4002000000;
  v204 = __Block_byref_object_copy__65;
  v205 = __Block_byref_object_dispose__66;
  v206 = 0;
  uint64_t v208 = 0;
  v207 = 0;
  v200[0] = MEMORY[0x263EF8330];
  v200[1] = 0x40000000;
  v200[2] = ___ZN23EurekaCallCommandDriver34handleVoiceAllCallStatusIndicationEN3qmi16SubscriptionTypeERKN2vs15VoiceCallStatus10IndicationE_block_invoke;
  v200[3] = &unk_264610B60;
  v200[4] = &v201;
  *(void *)long long buf = v200;
  char v13 = qmi::MessageBase::applyTlv<vs::tlv::CallList,void({block_pointer})(vs::tlv::CallList const&)>(a3, 1, (uint64_t)buf);
  uint64_t v14 = v202[5];
  if (v14 != v202[6]) {
    EurekaCallCommandDriver::setPreferredFormatter(v5, *(unsigned __int8 *)(v14 + 4), v12);
  }
  if ((v13 & 1) == 0)
  {
    uint64_t v20 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_22231A000, v20, OS_LOG_TYPE_ERROR, "Mandatory TLV, Array of Call Information (0x01), is not present!", buf, 2u);
    }
    goto LABEL_299;
  }
  v199 = 0;
  uint64_t v198 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v198, v5, v12);
  if (*(unsigned char *)(v5 + 305) || !v198 || !(*(unsigned int (**)(uint64_t))(*(void *)v198 + 128))(v198)) {
    goto LABEL_18;
  }
  uint64_t v197 = 0;
  std::string __p = 0;
  v196 = 0;
  std::vector<vs::tlv::CallListItem>::__init_with_size[abi:ne180100]<vs::tlv::CallListItem*,vs::tlv::CallListItem*>(&__p, (const void *)v202[5], v202[6], 0x6DB6DB6DB6DB6DB7 * (v202[6] - v202[5]));
  char v21 = EurekaCallCommandDriver::validateCallCollisionScenario(v5, (unsigned __int8 *)__p, (uint64_t)v196);
  if (__p)
  {
    v196 = __p;
    operator delete(__p);
  }
  if (v21)
  {
LABEL_18:
    v193 = 0;
    v192 = 0;
    uint64_t v194 = 0;
    char v15 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v5 + 112) + 16))(*(void *)(v5 + 112), v12);
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x4002000000;
    *(void *)&uint8_t buf[24] = __Block_byref_object_copy__70;
    long long v237 = 0uLL;
    *(void *)&long long v236 = __Block_byref_object_dispose__71;
    *((void *)&v236 + 1) = &v237;
    v217 = (void *)MEMORY[0x263EF8330];
    uint64_t v218 = 0x40000000;
    v219 = ___ZN23EurekaCallCommandDriver26parseRemotePartyNumberNameERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke;
    v220 = &unk_264610B88;
    v221 = buf;
    int v222 = v12;
    *(void *)&long long v227 = &v217;
    qmi::MessageBase::applyTlv<vs::tlv::RemoteNumberList,void({block_pointer})(vs::tlv::RemoteNumberList const&)>(a3, 16, (uint64_t)&v227);
    v216 = 0;
    uint64_t v215 = 0;
    EurekaCallCommandDriver::getPreferredFormatterForSim(&v215, v5, v12);
    if (v215 && ((*(uint64_t (**)(uint64_t))(*(void *)v215 + 152))(v215) & 1) == 0)
    {
      *(void *)v232 = MEMORY[0x263EF8330];
      *(void *)&v232[8] = 0x40000000;
      *(void *)&v232[16] = ___ZN23EurekaCallCommandDriver26parseRemotePartyNumberNameERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke_2;
      *(void *)&v232[24] = &unk_264610BB0;
      *(void *)&v232[32] = buf;
      v233 = v15;
      int v234 = v12;
      *(void *)&long long v227 = v232;
      qmi::MessageBase::applyTlv<vs::tlv::CallList,void({block_pointer})(vs::tlv::CallList const&)>(a3, 1, (uint64_t)&v227);
    }
    unsigned int v187 = v12;
    v189 = v8;
    *(void *)&long long v227 = 0;
    *((void *)&v227 + 1) = &v227;
    uint64_t v228 = 0x4002000000;
    v229 = __Block_byref_object_copy__74;
    v186 = a3;
    v230 = (uint8_t *)__Block_byref_object_dispose__75;
    memset(v231, 0, sizeof(v231));
    v211[0] = (void *)MEMORY[0x263EF8330];
    v211[1] = (void *)0x40000000;
    v212 = ___ZN23EurekaCallCommandDriver26parseRemotePartyNumberNameERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke_76;
    v213 = &unk_264610BD8;
    v214 = &v227;
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(a3);
    uint64_t v18 = TlvValue;
    uint64_t v190 = v5;
    if (!TlvValue) {
      goto LABEL_56;
    }
    int v19 = v17;
    *(void *)v224 = TlvValue;
    memset(&v223, 0, sizeof(v223));
    tlv::parseV<vs::tlv::RemoteNameList>((unsigned __int8 **)v224, v17, (uint64_t *)&v223);
    if (*(void *)v224)
    {
      v212((uint64_t)v211, (__int16 **)&v223);
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v223;
      std::vector<vs::tlv::RemoteNumberListItem>::__destroy_vector::operator()[abi:ne180100]((void ***)&__str);
    }
    else
    {
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v223;
      std::vector<vs::tlv::RemoteNumberListItem>::__destroy_vector::operator()[abi:ne180100]((void ***)&__str);
      if (!((unsigned int (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a3, 17, v18, v19))
      {
LABEL_56:
        uint64_t v194 = 0;
        v193 = 0;
        v192 = &v193;
        long long v37 = *(void **)(*(void *)&buf[8] + 40);
        uint64_t v38 = *(void *)&buf[8] + 48;
        if (v37 != (void *)(*(void *)&buf[8] + 48))
        {
          while (1)
          {
            long long v39 = &v193;
            if (v192 != &v193)
            {
              long long v40 = v193;
              long long v41 = &v193;
              if (v193)
              {
                do
                {
                  long long v39 = (uint64_t **)v40;
                  long long v40 = (uint64_t *)v40[1];
                }
                while (v40);
              }
              else
              {
                do
                {
                  long long v39 = (uint64_t **)v41[2];
                  BOOL v42 = *v39 == (uint64_t *)v41;
                  long long v41 = v39;
                }
                while (v42);
              }
              unsigned int v43 = *((unsigned __int8 *)v37 + 32);
              if (*((unsigned __int8 *)v39 + 32) >= v43) {
                break;
              }
            }
            if (v193) {
              long long v44 = v39;
            }
            else {
              long long v44 = &v193;
            }
            if (v193)
            {
              long long v45 = v39 + 1;
            }
            else
            {
              long long v39 = (uint64_t **)&v192;
              long long v45 = &v193;
            }
            if (!v39[1]) {
              goto LABEL_79;
            }
LABEL_82:
            long long v49 = (void *)v37[1];
            if (v49)
            {
              do
              {
                long long v50 = v49;
                long long v49 = (void *)*v49;
              }
              while (v49);
            }
            else
            {
              do
              {
                long long v50 = (void *)v37[2];
                BOOL v42 = *v50 == (void)v37;
                long long v37 = v50;
              }
              while (!v42);
            }
            long long v37 = v50;
            if (v50 == (void *)v38) {
              goto LABEL_88;
            }
          }
          long long v45 = &v193;
          long long v44 = &v193;
          if (v193)
          {
            long long v46 = v193;
            while (1)
            {
              while (1)
              {
                long long v44 = (uint64_t **)v46;
                unsigned int v47 = *((unsigned __int8 *)v46 + 32);
                if (v47 <= v43) {
                  break;
                }
                long long v46 = *v44;
                long long v45 = v44;
                if (!*v44) {
                  goto LABEL_79;
                }
              }
              if (v47 >= v43) {
                goto LABEL_82;
              }
              long long v46 = v44[1];
              if (!v46)
              {
                long long v45 = v44 + 1;
                break;
              }
            }
          }
LABEL_79:
          v223.__r_.__value_.__r.__words[2] = 0;
          long long v48 = (char *)operator new(0x1C0uLL);
          v223.__r_.__value_.__r.__words[0] = (std::string::size_type)v48;
          v223.__r_.__value_.__l.__size_ = (std::string::size_type)&v193;
          v48[32] = *((unsigned char *)v37 + 32);
          CallInfo::CallInfo((CallInfo *)(v48 + 40), (const CallInfo *)(v37 + 5));
          v223.__r_.__value_.__s.__data_[16] = 1;
          *(void *)long long v48 = 0;
          *((void *)v48 + 1) = 0;
          *((void *)v48 + 2) = v44;
          *long long v45 = (uint64_t *)v48;
          if (*v192)
          {
            v192 = (uint64_t **)*v192;
            long long v48 = (char *)*v45;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v193, (uint64_t *)v48);
          ++v194;
          v223.__r_.__value_.__r.__words[0] = 0;
          std::unique_ptr<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>>>>::reset[abi:ne180100]((uint64_t)&v223);
          goto LABEL_82;
        }
LABEL_88:
        _Block_object_dispose(&v227, 8);
        v223.__r_.__value_.__r.__words[0] = (std::string::size_type)v231;
        std::vector<vs::tlv::RemoteNumberListItem>::__destroy_vector::operator()[abi:ne180100]((void ***)&v223);
        if (v216) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v216);
        }
        _Block_object_dispose(buf, 8);
        std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::destroy((void **)v237);
        memset(&v223, 0, sizeof(v223));
        long long v51 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v5 + 112) + 16))(*(void *)(v5 + 112), v187);
        *(_OWORD *)&v223.__r_.__value_.__r.__words[1] = 0uLL;
        v223.__r_.__value_.__r.__words[0] = (std::string::size_type)&v223.__r_.__value_.__l.__size_;
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&uint8_t buf[16] = 0x4002000000;
        *(void *)&uint8_t buf[24] = __Block_byref_object_copy__78;
        *(void *)&long long v236 = __Block_byref_object_dispose__79;
        *((void *)&v236 + 1) = 0;
        long long v237 = 0uLL;
        *(void *)&long long v227 = MEMORY[0x263EF8330];
        *((void *)&v227 + 1) = 0x40000000;
        uint64_t v228 = (uint64_t)___ZN23EurekaCallCommandDriver20parseSRVCCCalls_syncERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke;
        v229 = (__n128 (*)(void *, uint64_t))&unk_264610C00;
        v230 = buf;
        long long v52 = (void *)qmi::MessageBase::findTlvValue(v186);
        long long v54 = v52;
        if (v52)
        {
          int v55 = v53;
          v217 = v52;
          memset(v232, 0, 24);
          tlv::parseV<vs::tlv::IsHandoverCallList>((unsigned __int8 **)&v217, v53, v232);
          int v56 = v217;
          if (v217) {
            ((void (*)(long long *, unsigned char *))v228)(&v227, v232);
          }
          if (*(void *)v232)
          {
            *(void *)&v232[8] = *(void *)v232;
            operator delete(*(void **)v232);
          }
          if (v56
            || (((uint64_t (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)v186, 31, v54, v55) & 1) != 0)
          {
            uint64_t v57 = *(_WORD **)(*(void *)&buf[8] + 40);
            for (uint64_t i = *(_WORD **)(*(void *)&buf[8] + 48); v57 != i; ++v57)
            {
              *(_WORD *)v232 = *v57;
              if (*(unsigned __int16 *)v232 >= 0x100u) {
                *((unsigned char *)std::__tree<std::__value_type<unsigned char,BOOL>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,BOOL>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,BOOL>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v223, v232[0], v232)+ 26) = 1;
              }
            }
            if (v223.__r_.__value_.__r.__words[2] > 1)
            {
              char v59 = *v51;
              if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)v232 = 0;
                _os_log_error_impl(&dword_22231A000, v59, OS_LOG_TYPE_ERROR, "Received multiple calls with handover status set to true", v232, 2u);
              }
            }
          }
        }
        _Block_object_dispose(buf, 8);
        if (*((void *)&v236 + 1))
        {
          *(void *)&long long v237 = *((void *)&v236 + 1);
          operator delete(*((void **)&v236 + 1));
        }
        long long v60 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v5 + 112) + 16))(*(void *)(v5 + 112), v187);
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&uint8_t buf[16] = 0x4002000000;
        *(void *)&uint8_t buf[24] = __Block_byref_object_copy__62;
        *(void *)&long long v236 = __Block_byref_object_dispose__63;
        *((void *)&v236 + 1) = 0;
        long long v237 = 0uLL;
        *(void *)&long long v227 = MEMORY[0x263EF8330];
        *((void *)&v227 + 1) = 0x40000000;
        uint64_t v228 = (uint64_t)___ZN23EurekaCallCommandDriver32parseAndUpdateParentCallIds_syncERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke;
        v229 = (__n128 (*)(void *, uint64_t))&unk_264610B38;
        v230 = buf;
        uint64_t v61 = (void *)qmi::MessageBase::findTlvValue(v186);
        uint64_t v63 = v61;
        if (v61)
        {
          int v64 = v62;
          v217 = v61;
          memset(v232, 0, 24);
          tlv::parseV<vs::tlv::ParentCallInfo>((unsigned __int8 **)&v217, v62, v232);
          long long v65 = v217;
          if (v217) {
            ((void (*)(long long *, unsigned char *))v228)(&v227, v232);
          }
          if (*(void *)v232)
          {
            *(void *)&v232[8] = *(void *)v232;
            operator delete(*(void **)v232);
          }
          if (v65
            || ((unsigned int (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)v186, 32, v63, v64))
          {
            long long v66 = *v60;
            if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v232 = 0;
              _os_log_impl(&dword_22231A000, v66, OS_LOG_TYPE_DEFAULT, "#I Indication has parent call info. Need to update our call's ids with BB call ids!", v232, 2u);
            }
            *(void *)&v232[16] = 0;
            *(void *)&v232[8] = 0;
            *(void *)v232 = &v232[8];
            long long v67 = *(char **)(*(void *)&buf[8] + 40);
            long long v68 = *(char **)(*(void *)&buf[8] + 48);
            while (v67 != v68)
            {
              char v69 = *v67;
              unsigned int v70 = v67[1];
              int v71 = (uint64_t **)&v232[8];
              long long v72 = (uint64_t **)&v232[8];
              if (*(void *)&v232[8])
              {
                uint64_t v73 = *(uint64_t **)&v232[8];
                while (1)
                {
                  while (1)
                  {
                    long long v72 = (uint64_t **)v73;
                    unsigned int v74 = *((unsigned __int8 *)v73 + 25);
                    if (v74 <= v70) {
                      break;
                    }
                    uint64_t v73 = *v72;
                    int v71 = v72;
                    if (!*v72) {
                      goto LABEL_125;
                    }
                  }
                  if (v74 >= v70) {
                    break;
                  }
                  uint64_t v73 = v72[1];
                  if (!v73)
                  {
                    int v71 = v72 + 1;
                    goto LABEL_125;
                  }
                }
                uint64_t v75 = v72;
              }
              else
              {
LABEL_125:
                uint64_t v75 = operator new(0x20uLL);
                v75[25] = v70;
                v75[26] = 0;
                *(void *)uint64_t v75 = 0;
                *((void *)v75 + 1) = 0;
                *((void *)v75 + 2) = v72;
                *int v71 = (uint64_t *)v75;
                v76 = (uint64_t *)v75;
                if (**(void **)v232)
                {
                  *(void *)v232 = **(void **)v232;
                  v76 = *v71;
                }
                std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)&v232[8], v76);
                ++*(void *)&v232[16];
              }
              v75[26] = v69;
              v67 += 3;
            }
            (*(void (**)(void, unsigned char *, void))(**(void **)(v5 + 120) + 336))(*(void *)(v5 + 120), v232, v187);
            std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*(void **)&v232[8]);
          }
        }
        _Block_object_dispose(buf, 8);
        if (*((void *)&v236 + 1))
        {
          *(void *)&long long v237 = *((void *)&v236 + 1);
          operator delete(*((void **)&v236 + 1));
        }
        v77 = (unsigned __int8 *)v202[5];
        v188 = (unsigned __int8 *)v202[6];
        uint64_t v78 = v187;
        if (v77 == v188)
        {
LABEL_296:
          std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy((void *)v223.__r_.__value_.__l.__size_);
          std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::destroy((void **)v193);
          goto LABEL_297;
        }
        v183 = (char *)*MEMORY[0x263F03680];
        __s = (std::string::value_type *)*MEMORY[0x263F03760];
        while (1)
        {
          int v79 = v77[2];
          uint64_t v80 = *v77;
          uint64_t v81 = v77[1];
          int v82 = v77[3];
          int v83 = v77[5];
          switch(v77[2])
          {
            case 0u:
            case 9u:
              goto LABEL_151;
            case 6u:
              (*(void (**)(void, void, void, uint64_t))(**(void **)(v190 + 216) + 56))(*(void *)(v190 + 216), v77[1], *v77, v78);
              goto LABEL_171;
            case 7u:
              goto LABEL_148;
            case 8u:
              (*(void (**)(void, qmi::MessageBase *, uint64_t))(**(void **)(v190 + 216) + 48))(*(void *)(v190 + 216), v186, v78);
LABEL_148:
              int v88 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v190 + 216) + 56))(*(void *)(v190 + 216), v81, v80, v78);
              int v89 = *v189;
              if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v90 = CSIBOOLAsString();
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = v90;
                _os_log_impl(&dword_22231A000, v89, OS_LOG_TYPE_DEFAULT, "#I OTASP type of call; handled as OTASP: %s",
                  buf,
                  0xCu);
              }
              if (!v88) {
                goto LABEL_171;
              }
LABEL_151:
              v224[0] = v80;
              *((_DWORD *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224)+ 33) = v80;
              *((_DWORD *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224)+ 73) = v78;
              *((_DWORD *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224)+ 28) = v82;
              std::string::size_type size = v223.__r_.__value_.__l.__size_;
              if (!v223.__r_.__value_.__l.__size_) {
                goto LABEL_161;
              }
              v92 = (std::string *)&v223.__r_.__value_.__r.__words[1];
              do
              {
                std::string::size_type v93 = size;
                uint64_t v94 = v92;
                unsigned int v95 = *(unsigned __int8 *)(size + 25);
                if (v95 >= v80) {
                  v92 = (std::string *)size;
                }
                else {
                  size += 8;
                }
                std::string::size_type size = *(void *)size;
              }
              while (size);
              if (v92 == (std::string *)&v223.__r_.__value_.__r.__words[1]) {
                goto LABEL_161;
              }
              if (v95 < v80) {
                std::string::size_type v93 = (std::string::size_type)v94;
              }
              if (v80 >= *(unsigned __int8 *)(v93 + 25)) {
                BOOL v96 = *((unsigned char *)std::__tree<std::__value_type<unsigned char,BOOL>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,BOOL>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,BOOL>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v223, v80, v224)+ 26) != 0;
              }
              else {
LABEL_161:
              }
                BOOL v96 = 0;
              if (v198)
              {
                int v97 = (*(uint64_t (**)(uint64_t))(*(void *)v198 + 152))(v198);
                int v98 = v81 == 1 ? 0 : v97;
                if (v98 == 1)
                {
                  uint64_t v99 = *v189;
                  if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl(&dword_22231A000, v99, OS_LOG_TYPE_DEFAULT, "#I Resetting RPN (if needed) since this is a technology that gets caller id later", buf, 2u);
                  }
                  long long v100 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224);
                  std::string::__assign_external((std::string *)v100 + 3, __s);
                  uint64_t v101 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224);
                  if (*((char *)v101 + 71) < 0)
                  {
                    v101[7] = 0;
                    long long v102 = v101[6];
                  }
                  else
                  {
                    long long v102 = (uint64_t *)(v101 + 6);
                    *((unsigned char *)v101 + 71) = 0;
                  }
                  *(unsigned char *)long long v102 = 0;
                  *((_DWORD *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224)+ 30) = 2;
                  *((_DWORD *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224)+ 73) = v187;
                }
              }
              if (v96)
              {
                long long v104 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224);
                long long v105 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v190 + 112) + 16))(*(void *)(v190 + 112), *((unsigned int *)v104 + 73));
                if (v81 <= 0xA)
                {
                  if (((1 << v81) & 0xEC) != 0)
                  {
                    v114 = *v105;
                    if (os_log_type_enabled(*v105, OS_LOG_TYPE_DEFAULT))
                    {
                      v115 = vs::callList::asString(v81);
                      int v116 = *((_DWORD *)v104 + 33);
                      *(_DWORD *)long long buf = 136315394;
                      *(void *)&uint8_t buf[4] = v115;
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v116;
                      _os_log_impl(&dword_22231A000, v114, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming SRVCC Indication: %s, for: %d", buf, 0x12u);
                    }
                    v117 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v190 + 112) + 16))(*(void *)(v190 + 112), *((unsigned int *)v104 + 73));
                    long long v227 = 0uLL;
                    uint64_t v228 = 0;
                    (*(void (**)(long long *__return_ptr))(**(void **)(v190 + 120) + 328))(&v227);
                    v118 = (const CallInfo *)(v104 + 5);
                    if (*((void *)&v227 + 1) != (void)v227)
                    {
                      *(void *)long long buf = v190;
                      CallInfo::CallInfo((CallInfo *)&buf[8], (const CallInfo *)(v104 + 5));
                      v119 = *(std::__shared_weak_count **)(v190 + 16);
                      if (v119 && std::__shared_weak_count::lock(v119)) {
                        operator new();
                      }
                      std::__throw_bad_weak_ptr[abi:ne180100]();
                    }
                    v126 = *v117;
                    if (os_log_type_enabled(*v117, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)long long buf = 0;
                      _os_log_impl(&dword_22231A000, v126, OS_LOG_TYPE_DEFAULT, "#N No VoLTE call around but BB gave us a SRVCC call. End this BB call and ignore the indication.", buf, 2u);
                    }
                    CallInfo::CallInfo((CallInfo *)buf, v118);
                    EurekaCallCommandDriver::endThisCall(v190, (unsigned int *)buf);
                    CallInfo::~CallInfo((void **)buf);
                    *(void *)v232 = &v227;
                    std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)v232);
                    goto LABEL_291;
                  }
                  if (((1 << v81) & 0x712) != 0) {
                    goto LABEL_180;
                  }
                }
                if (v81 == 104)
                {
LABEL_180:
                  os_log_t v106 = *v105;
                  if (!os_log_type_enabled(*v105, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_291;
                  }
                  int v107 = vs::callList::asString(v81);
                  int v108 = *((_DWORD *)v104 + 33);
                  *(_DWORD *)long long buf = 136315394;
                  *(void *)&uint8_t buf[4] = v107;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v108;
                  uint64_t v109 = v106;
                  v110 = "Got unhandled call state for handover: %s, call ID: %d";
                }
                else
                {
                  os_log_t v123 = *v105;
                  if (!os_log_type_enabled(*v105, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_291;
                  }
                  v124 = vs::callList::asString(v81);
                  int v125 = *((_DWORD *)v104 + 33);
                  *(_DWORD *)long long buf = 136315394;
                  *(void *)&uint8_t buf[4] = v124;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v125;
                  uint64_t v109 = v123;
                  v110 = "Uknown call state for handover: %s, call ID: %d";
                }
                uint32_t v111 = 18;
LABEL_183:
                _os_log_error_impl(&dword_22231A000, v109, OS_LOG_TYPE_ERROR, v110, buf, v111);
              }
              else
              {
                switch((int)v81)
                {
                  case 1:
                    v112 = *v189;
                    if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 67109120;
                      *(_DWORD *)&uint8_t buf[4] = v80;
                      _os_log_impl(&dword_22231A000, v112, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: ORIGINATION for %d", buf, 8u);
                    }
                    if (!*(unsigned char *)(v190 + 305))
                    {
                      uint64_t v176 = *(void *)(v190 + 120);
                      v177 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224);
                      (*(void (**)(uint64_t, uint64_t **))(*(void *)v176 + 24))(v176, v177 + 5);
                      v128 = *(void **)(v190 + 120);
                      v129 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224)+ 5;
                      v130 = (void (**)(void *, uint64_t **))(*v128 + 32);
                      goto LABEL_281;
                    }
                    os_log_t v113 = *v189;
                    if (os_log_type_enabled(*v189, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)long long buf = 0;
                      uint64_t v109 = v113;
                      v110 = "Got ORIGINATION for a silent call that's happening in Settings Model, ignoring";
                      uint32_t v111 = 2;
                      goto LABEL_183;
                    }
                    break;
                  case 2:
                    v139 = *v189;
                    if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 67109120;
                      *(_DWORD *)&uint8_t buf[4] = v80;
                      _os_log_impl(&dword_22231A000, v139, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: INCOMING for %d", buf, 8u);
                    }
                    uint64_t v259 = 0;
                    long long v257 = 0u;
                    long long v258 = 0u;
                    long long v255 = 0u;
                    long long v256 = 0u;
                    long long v253 = 0u;
                    long long v254 = 0u;
                    long long v251 = 0u;
                    long long v252 = 0u;
                    long long v249 = 0u;
                    long long v250 = 0u;
                    long long v247 = 0u;
                    long long v248 = 0u;
                    long long v245 = 0u;
                    long long v246 = 0u;
                    long long v243 = 0u;
                    long long v244 = 0u;
                    long long v241 = 0u;
                    long long v242 = 0u;
                    long long v239 = 0u;
                    long long v240 = 0u;
                    long long v237 = 0u;
                    long long v238 = 0u;
                    long long v236 = 0u;
                    memset(buf, 0, sizeof(buf));
                    v140 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224);
                    CallInfo::CallInfo((CallInfo *)buf, (const CallInfo *)(v140 + 5));
                    if (CallCommandDriver::shouldMTCallContinue((CallCommandDriver *)v190, 0, (const CallInfo *)buf)&& (*(unsigned int (**)(void, uint8_t *, uint64_t))(**(void **)(v190 + 120) + 184))(*(void *)(v190 + 120), buf, 1))
                    {
                      uint64_t v141 = *(void *)(v190 + 120);
                      LODWORD(v227) = 0;
                      (*(void (**)(uint64_t, uint8_t *, long long *))(*(void *)v141 + 72))(v141, buf, &v227);
                    }
                    goto LABEL_271;
                  case 3:
                    v132 = *v189;
                    if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 67109120;
                      *(_DWORD *)&uint8_t buf[4] = v80;
                      _os_log_impl(&dword_22231A000, v132, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: CONVERSATION for %d", buf, 8u);
                    }
                    v133 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224);
                    v134 = v133 + 5;
                    if (v82 == 2 || v82 == 1 && (CallCommandDriver::carrierSupportsCallingTimewithFWIM() & 1) == 0)
                    {
                      *((unsigned char *)v133 + 125) = v83 != 0;
                      (*(void (**)(void, uint64_t **, uint64_t))(**(void **)(v190 + 120) + 48))(*(void *)(v190 + 120), v134, 1);
                    }
                    else
                    {
                      v135 = *v189;
                      if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_impl(&dword_22231A000, v135, OS_LOG_TYPE_DEFAULT, "#I Delaying setting call to active because carrier supports FWIM, but fake the call to go to Alerting state", buf, 2u);
                      }
                      (*(void (**)(void, uint64_t **))(**(void **)(v190 + 120) + 40))(*(void *)(v190 + 120), v134);
                    }
                    v170 = *v189;
                    if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
                    {
                      int v171 = (*(uint64_t (**)(void, uint64_t **))(**(void **)(v190 + 120) + 360))(*(void *)(v190 + 120), v134);
                      int v172 = EurekaCallCommandDriver::findCallCapability(v190, (unint64_t)v183, *((_DWORD *)v133 + 73));
                      *(_DWORD *)long long buf = 67109376;
                      *(_DWORD *)&uint8_t buf[4] = v171;
                      *(_WORD *)&uint8_t buf[8] = 1024;
                      *(_DWORD *)&buf[10] = v172;
                      _os_log_impl(&dword_22231A000, v170, OS_LOG_TYPE_DEFAULT, "#I Call went to active. Normally we would turn on Add call. Sould we do so now? TTY: %d. AddCallKey: %d", buf, 0xEu);
                    }
                    if (!EurekaCallCommandDriver::findCallCapability(v190, (unint64_t)v183, *((_DWORD *)v133 + 73))&& ((*(uint64_t (**)(void, uint64_t **))(**(void **)(v190 + 120) + 360))(*(void *)(v190 + 120), v134) & 1) == 0)
                    {
                      EurekaCallCommandDriver::setCallCapability(v190, v183, v82 != 2, 1, *((unsigned int *)v133 + 73));
                    }
                    break;
                  case 4:
                    os_log_t v136 = *v189;
                    if (!os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT)) {
                      break;
                    }
                    *(_DWORD *)long long buf = 67109120;
                    *(_DWORD *)&uint8_t buf[4] = v80;
                    v121 = v136;
                    v122 = "#I --->BB Incoming Indication: CC_IN_PROGRESS for %d";
                    goto LABEL_222;
                  case 5:
                    v127 = *v189;
                    if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 67109120;
                      *(_DWORD *)&uint8_t buf[4] = v80;
                      _os_log_impl(&dword_22231A000, v127, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: ALERTING for %d", buf, 8u);
                    }
                    v128 = *(void **)(v190 + 120);
                    v129 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224)+ 5;
                    v130 = (void (**)(void *, uint64_t **))(*v128 + 40);
                    goto LABEL_281;
                  case 6:
                    v142 = *v189;
                    if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 67109120;
                      *(_DWORD *)&uint8_t buf[4] = v80;
                      _os_log_impl(&dword_22231A000, v142, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: HOLD for %d", buf, 8u);
                    }
                    *((unsigned char *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224)+ 125) = v83 != 0;
                    v128 = *(void **)(v190 + 120);
                    v129 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224)+ 5;
                    v130 = (void (**)(void *, uint64_t **))(*v128 + 104);
LABEL_281:
                    (*v130)(v128, v129);
                    break;
                  case 7:
                    v143 = *v189;
                    if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 67109120;
                      *(_DWORD *)&uint8_t buf[4] = v80;
                      _os_log_impl(&dword_22231A000, v143, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: WAITING for %d", buf, 8u);
                    }
                    uint64_t v259 = 0;
                    long long v257 = 0u;
                    long long v258 = 0u;
                    long long v255 = 0u;
                    long long v256 = 0u;
                    long long v253 = 0u;
                    long long v254 = 0u;
                    long long v251 = 0u;
                    long long v252 = 0u;
                    long long v249 = 0u;
                    long long v250 = 0u;
                    long long v247 = 0u;
                    long long v248 = 0u;
                    long long v245 = 0u;
                    long long v246 = 0u;
                    long long v243 = 0u;
                    long long v244 = 0u;
                    long long v241 = 0u;
                    long long v242 = 0u;
                    long long v239 = 0u;
                    long long v240 = 0u;
                    long long v237 = 0u;
                    long long v238 = 0u;
                    long long v236 = 0u;
                    memset(buf, 0, sizeof(buf));
                    v144 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224);
                    CallInfo::CallInfo((CallInfo *)buf, (const CallInfo *)(v144 + 5));
                    if (CallCommandDriver::shouldMTCallContinue((CallCommandDriver *)v190, 1, (const CallInfo *)buf)&& (*(unsigned int (**)(void, uint8_t *, uint64_t))(**(void **)(v190 + 120) + 184))(*(void *)(v190 + 120), buf, 1))
                    {
                      (*(void (**)(void, uint8_t *))(**(void **)(v190 + 120) + 88))(*(void *)(v190 + 120), buf);
                    }
                    else
                    {
                      v169 = *v189;
                      if (os_log_type_enabled(*v189, OS_LOG_TYPE_ERROR))
                      {
                        LOWORD(v227) = 0;
                        _os_log_error_impl(&dword_22231A000, v169, OS_LOG_TYPE_ERROR, "Waiting call is not allowed, sending to voicemail.", (uint8_t *)&v227, 2u);
                      }
                      CallInfo::CallInfo((CallInfo *)v191, (const CallInfo *)buf);
                      EurekaCallCommandDriver::sendToVoicemail(v190, (uint64_t)v191);
                      CallInfo::~CallInfo(v191);
                    }
LABEL_271:
                    CallInfo::~CallInfo((void **)buf);
                    break;
                  case 8:
                    os_log_t v137 = *v189;
                    if (!os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT)) {
                      break;
                    }
                    *(_DWORD *)long long buf = 67109120;
                    *(_DWORD *)&uint8_t buf[4] = v80;
                    v121 = v137;
                    v122 = "#I --->BB Incoming Indication: DISCONNECTING for %d";
                    goto LABEL_222;
                  case 9:
                    v145 = *v189;
                    if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 67109120;
                      *(_DWORD *)&uint8_t buf[4] = v80;
                      _os_log_impl(&dword_22231A000, v145, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: END for %d", buf, 8u);
                    }
                    v146 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v190 + 112) + 16))(*(void *)(v190 + 112), v187);
                    *(void *)long long buf = 0;
                    *(void *)&uint8_t buf[8] = buf;
                    *(void *)&uint8_t buf[16] = 0x4002000000;
                    *(void *)&uint8_t buf[24] = __Block_byref_object_copy__81;
                    *(void *)&long long v236 = __Block_byref_object_dispose__82;
                    long long v237 = 0uLL;
                    *((void *)&v236 + 1) = 0;
                    *(void *)&long long v227 = MEMORY[0x263EF8330];
                    *((void *)&v227 + 1) = 0x40000000;
                    uint64_t v228 = (uint64_t)___ZN23EurekaCallCommandDriver18parseEndIndicationERKN2vs15VoiceCallStatus10IndicationERNSt3__13mapIh8CallInfoNS5_4lessIhEENS5_9allocatorINS5_4pairIKhS7_EEEEEEN10subscriber7SimSlotE_block_invoke;
                    v229 = (__n128 (*)(void *, uint64_t))&unk_264610C28;
                    v230 = buf;
                    v147 = (void *)qmi::MessageBase::findTlvValue(v186);
                    v149 = v147;
                    if (!v147) {
                      goto LABEL_278;
                    }
                    int v150 = v148;
                    v217 = v147;
                    memset(v232, 0, 24);
                    tlv::parseV<vs::tlv::CallEndReasonList>((unsigned __int8 **)&v217, v148, (uint64_t *)v232);
                    v151 = v217;
                    if (v217) {
                      ((void (*)(long long *, unsigned char *))v228)(&v227, v232);
                    }
                    if (*(void *)v232)
                    {
                      *(void *)&v232[8] = *(void *)v232;
                      operator delete(*(void **)v232);
                    }
                    if (!v151
                      && (((uint64_t (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)v186, 20, v149, v150) & 1) == 0)
                    {
LABEL_278:
                      os_log_t v173 = *v146;
                      if (!os_log_type_enabled(*v146, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_283;
                      }
                      *(_WORD *)v232 = 0;
                      v174 = v173;
                      v175 = "In END indication, CallEndReason TLV is not present. Ending all the calls with no error reason";
LABEL_295:
                      _os_log_error_impl(&dword_22231A000, v174, OS_LOG_TYPE_ERROR, v175, v232, 2u);
                      goto LABEL_283;
                    }
                    v152 = *(unsigned __int8 **)(*(void *)&buf[8] + 40);
                    v153 = *(unsigned __int8 **)(*(void *)&buf[8] + 48);
                    v184 = v77;
                    if (v153 == v152)
                    {
                      os_log_t v178 = *v146;
                      if (!os_log_type_enabled(*v146, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_283;
                      }
                      *(_WORD *)v232 = 0;
                      v174 = v178;
                      v175 = "In END indication, number of call instances are 0";
                      goto LABEL_295;
                    }
                    do
                    {
                      int v154 = *v152;
                      __str.__r_.__value_.__s.__data_[0] = *v152;
                      int v155 = *((unsigned __int16 *)v152 + 1);
                      uint64_t v218 = 0;
                      v217 = 0;
                      v219 = 0;
                      convertCallEndReasonToString(v155, &v217);
                      v156 = *v146;
                      if (os_log_type_enabled(*v146, OS_LOG_TYPE_DEFAULT))
                      {
                        convertCallEndReasonToString(v155, v211);
                        v157 = v211;
                        if (SHIBYTE(v212) < 0) {
                          v157 = (void **)v211[0];
                        }
                        v158 = &v217;
                        if (SHIBYTE(v219) < 0) {
                          v158 = v217;
                        }
                        *(_DWORD *)v232 = 136315650;
                        *(void *)&v232[4] = v157;
                        *(_WORD *)&v232[12] = 2080;
                        *(void *)&v232[14] = v158;
                        *(_WORD *)&v232[22] = 1024;
                        *(_DWORD *)&v232[24] = v154;
                        _os_log_impl(&dword_22231A000, v156, OS_LOG_TYPE_DEFAULT, "#I BB Call End Reason: %s. As String: %s. Call id: %d", v232, 0x1Cu);
                        if (SHIBYTE(v212) < 0) {
                          operator delete(v211[0]);
                        }
                      }
                      int v159 = convertCallEndBBCodeToCSIError(v155);
                      uint64_t v160 = CSIErrorString();
                      *((_WORD *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v154, (char *)&__str)+ 78) = v155;
                      v161 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v154, (char *)&__str);
                      *((_DWORD *)v161 + 40) = v159;
                      *((unsigned char *)v161 + 164) = 1;
                      v162 = *v146;
                      if (os_log_type_enabled(*v146, OS_LOG_TYPE_DEFAULT))
                      {
                        v163 = v146;
                        int v164 = SHIBYTE(v219);
                        v165 = (void **)v217;
                        convertCallEndReasonToString(v155, v211);
                        v166 = &v217;
                        if (v164 < 0) {
                          v166 = v165;
                        }
                        v167 = v211;
                        if (SHIBYTE(v212) < 0) {
                          v167 = (void **)v211[0];
                        }
                        *(_DWORD *)v232 = 136315906;
                        *(void *)&v232[4] = v160;
                        *(_WORD *)&v232[12] = 1024;
                        *(_DWORD *)&v232[14] = v159;
                        *(_WORD *)&v232[18] = 2080;
                        *(void *)&v232[20] = v166;
                        *(_WORD *)&v232[28] = 2080;
                        *(void *)&v232[30] = v167;
                        _os_log_impl(&dword_22231A000, v162, OS_LOG_TYPE_DEFAULT, "#I Call End Reason: %s, %d (BB Reason: %s(%s))", v232, 0x26u);
                        if (SHIBYTE(v212) < 0) {
                          operator delete(v211[0]);
                        }
                        v146 = v163;
                        v77 = v184;
                      }
                      if (SHIBYTE(v219) < 0) {
                        operator delete(v217);
                      }
                      v152 += 4;
                    }
                    while (v152 != v153);
LABEL_283:
                    _Block_object_dispose(buf, 8);
                    if (*((void *)&v236 + 1))
                    {
                      *(void *)&long long v237 = *((void *)&v236 + 1);
                      operator delete(*((void **)&v236 + 1));
                    }
                    v179 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224);
                    if ((*((_WORD *)v179 + 78) & 0xFFFE) == 0x17A)
                    {
                      v180 = *v189;
                      if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_impl(&dword_22231A000, v180, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: END with REDIAL OVER PS", buf, 2u);
                      }
                      v181 = *(void **)(v190 + 120);
                      v182 = (void (**)(void *, uint64_t **, void))(*v181 + 216);
                    }
                    else
                    {
                      v181 = *(void **)(v190 + 120);
                      v179 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v192, v80, (char *)v224);
                      v182 = (void (**)(void *, uint64_t **, void))(*v181 + 64);
                    }
                    (*v182)(v181, v179 + 5, 0);
                    break;
                  case 10:
                    os_log_t v131 = *v189;
                    if (!os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT)) {
                      break;
                    }
                    *(_DWORD *)long long buf = 67109120;
                    *(_DWORD *)&uint8_t buf[4] = v80;
                    v121 = v131;
                    v122 = "#I --->BB Incoming Indication: CALL_STATE_SETUP for %d";
                    goto LABEL_222;
                  default:
                    if (v81 == 104)
                    {
                      os_log_t v120 = *v189;
                      if (!os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT)) {
                        break;
                      }
                      *(_DWORD *)long long buf = 67109120;
                      *(_DWORD *)&uint8_t buf[4] = v80;
                      v121 = v120;
                      v122 = "#I --->BB Incoming Indication: SILENT_REDIAL for %d";
LABEL_222:
                      uint32_t v138 = 8;
                      goto LABEL_223;
                    }
                    os_log_t v168 = *v189;
                    if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 67109376;
                      *(_DWORD *)&uint8_t buf[4] = v81;
                      *(_WORD *)&uint8_t buf[8] = 1024;
                      *(_DWORD *)&buf[10] = v80;
                      v121 = v168;
                      v122 = "#I --->BB Incoming Indication: %d Unknown. For call %d. Ignoring.";
                      uint32_t v138 = 14;
LABEL_223:
                      _os_log_impl(&dword_22231A000, v121, OS_LOG_TYPE_DEFAULT, v122, buf, v138);
                      break;
                    }
                    break;
                }
              }
LABEL_291:
              uint64_t v78 = v187;
LABEL_292:
              v77 += 7;
              if (v77 == v188) {
                goto LABEL_296;
              }
              break;
            default:
              long long v84 = *v189;
              if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
              {
                long long v85 = "Call Type Other";
                if (v79 == 10) {
                  long long v85 = "Call Type Supplementary Service";
                }
                if (v79) {
                  v86 = (char *)v85;
                }
                else {
                  v86 = "Call Type Voice";
                }
                std::string::basic_string[abi:ne180100]<0>(buf, v86);
                long long v87 = buf;
                if ((buf[23] & 0x80u) != 0) {
                  long long v87 = *(uint8_t **)buf;
                }
                LODWORD(v227) = 136315138;
                *(void *)((char *)&v227 + 4) = v87;
                _os_log_impl(&dword_22231A000, v84, OS_LOG_TYPE_DEFAULT, "#I Ignoring the indication for %s", (uint8_t *)&v227, 0xCu);
                if ((char)buf[23] < 0) {
                  operator delete(*(void **)buf);
                }
              }
LABEL_171:
              long long v103 = *v189;
              if (os_log_type_enabled(*v189, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl(&dword_22231A000, v103, OS_LOG_TYPE_DEFAULT, "#I Ignoring BB Incoming Indication due to it getting processed earlier as OTASP call or other", buf, 2u);
              }
              goto LABEL_292;
          }
        }
      }
    }
    uint64_t v22 = *(void *)(*((void *)&v227 + 1) + 40);
    uint64_t v23 = *(void *)(*((void *)&v227 + 1) + 48);
    if (v22 != v23)
    {
      uint64_t v24 = (long long *)(v22 + 8);
      do
      {
        uint64_t v25 = (uint64_t)v24 - 8;
        unsigned __int8 v26 = *((unsigned char *)v24 - 8);
        unsigned __int8 v210 = v26;
        int v27 = *((unsigned __int8 *)v24 - 7);
        int v28 = *((unsigned __int8 *)v24 - 6);
        memset(&v223, 0, sizeof(v223));
        if (*((char *)v24 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(&v223, *(const std::string::value_type **)v24, *((void *)v24 + 1));
        }
        else
        {
          long long v29 = *v24;
          v223.__r_.__value_.__r.__words[2] = *((void *)v24 + 2);
          *(_OWORD *)&v223.__r_.__value_.__l.__data_ = v29;
        }
        memset(&__str, 0, sizeof(__str));
        std::string::basic_string[abi:ne180100]<0>(&__str, (char *)&unk_222543CCE);
        decodeString();
        uint64_t v30 = *v15;
        if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
        {
          p_str = &__str;
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)v224 = 67109378;
          *(_DWORD *)&v224[4] = v28;
          __int16 v225 = 2080;
          v226 = p_str;
          _os_log_impl(&dword_22231A000, v30, OS_LOG_TYPE_DEFAULT, "#I Got RemoteNameArray. Codeing_Scheme is: %d. Parsed Name is: %s", v224, 0x12u);
        }
        if (v27 == 1) {
          int v32 = 1;
        }
        else {
          int v32 = 2 * (v27 == 2);
        }
        long long v33 = (uint64_t **)(*(void *)&buf[8] + 40);
        uint64_t v5 = v190;
        if (v32)
        {
          long long v34 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(v33, v26, (char *)&v210);
          if (*((char *)v34 + 71) < 0)
          {
            v34[7] = 0;
            long long v35 = v34[6];
          }
          else
          {
            long long v35 = (uint64_t *)(v34 + 6);
            *((unsigned char *)v34 + 71) = 0;
          }
          *(unsigned char *)long long v35 = 0;
        }
        else
        {
          long long v36 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(v33, v26, (char *)&v210);
          std::string::operator=((std::string *)v36 + 2, &__str);
        }
        *((_DWORD *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)(*(void *)&buf[8] + 40), v26, (char *)&v210)+ 30) = v32;
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v223.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v223.__r_.__value_.__l.__data_);
        }
        v24 += 2;
      }
      while (v25 + 32 != v23);
    }
    goto LABEL_56;
  }
LABEL_297:
  if (v199) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v199);
  }
LABEL_299:
  _Block_object_dispose(&v201, 8);
  if (v206)
  {
    v207 = v206;
    operator delete(v206);
  }
}

void sub_2224DA58C(_Unwind_Exception *a1)
{
  CallInfo::~CallInfo((void **)&STACK[0x480]);
  std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy((void *)STACK[0x3C8]);
  std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::destroy((void **)STACK[0x298]);
  if (STACK[0x2C8]) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)STACK[0x2C8]);
  }
  _Block_object_dispose(&STACK[0x2F8], 8);
  uint64_t v2 = (void *)STACK[0x320];
  if (STACK[0x320])
  {
    STACK[0x328] = (unint64_t)v2;
    operator delete(v2);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__65(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__66(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

char *___ZN23EurekaCallCommandDriver34handleVoiceAllCallStatusIndicationEN3qmi16SubscriptionTypeERKN2vs15VoiceCallStatus10IndicationE_block_invoke(uint64_t a1, uint64_t a2)
{
  __n128 result = (char *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  if (result != (char *)a2) {
    return std::vector<vs::tlv::CallListItem>::__assign_with_size[abi:ne180100]<vs::tlv::CallListItem*,vs::tlv::CallListItem*>(result, *(char **)a2, *(void *)(a2 + 8), 0x6DB6DB6DB6DB6DB7 * (*(void *)(a2 + 8) - *(void *)a2));
  }
  return result;
}

uint64_t EurekaCallCommandDriver::validateCallCollisionScenario(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  memset(&v10, 0, sizeof(v10));
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * (a3 - (void)a2)) >= 3)
  {
    std::string::__assign_external(&v10, "Cannot have more than two calls happening at the same time in CDMA. Reset.", 0x4AuLL);
LABEL_3:
    unsigned int v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = &v10;
      if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v8 = (std::string *)v10.__r_.__value_.__r.__words[0];
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = v8;
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "%s", (uint8_t *)__p, 0xCu);
    }
    if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v9, v10.__r_.__value_.__l.__data_, v10.__r_.__value_.__l.__size_);
    }
    else {
      std::string v9 = v10;
    }
    rest::ResetPayload::ResetPayload();
    ctu::rest::event_t<rest::reset_request,rest::ResetPayload>::send();
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v9.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v10.__r_.__value_.__l.__data_);
    }
    return 0;
  }
  if (a3 - (void)a2 != 14 || a2[2] | a2[9]) {
    return 1;
  }
  unsigned int v5 = a2[1];
  if (v5 > 9 || (uint64_t result = 1, ((1 << v5) & 0x310) == 0))
  {
    unsigned int v7 = a2[8];
    if (v7 > 9 || (uint64_t result = 1, ((1 << v7) & 0x310) == 0))
    {
      std::string::__assign_external(&v10, "CDMA: Two calls active and both are in non-disconnecting or non CC_IN_PROGRESS states. Cannot happen. Reset", 0x6BuLL);
      goto LABEL_3;
    }
  }
  return result;
}

void sub_2224DAAA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t EurekaCallCommandDriver::getCallCommandDriverType(EurekaCallCommandDriver *this)
{
  return 0;
}

void EurekaCallCommandDriver::setCallCapability(uint64_t a1, char *a2, int a3, int a4, uint64_t a5)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  std::string v10 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), a5);
  std::string::basic_string[abi:ne180100]<0>(buf, a2);
  unint64_t v11 = std::__tree<std::string>::find<std::string>(a1 + 232, (void **)buf);
  if (v36 < 0) {
    operator delete(*(void **)buf);
  }
  if ((void **)(a1 + 240) != v11)
  {
    char v12 = v11[7];
    if (v12)
    {
      (*(void (**)(void *))(*(void *)v12 + 16))(v12);
      uint64_t v13 = v11[7];
      v11[7] = 0;
      if (v13) {
        (*(void (**)(void *))(*(void *)v13 + 8))(v13);
      }
    }
    std::string::basic_string[abi:ne180100]<0>(buf, a2);
    uint64_t v14 = (uint64_t *)std::__tree<std::string>::find<std::string>(a1 + 232, (void **)buf);
    if ((uint64_t *)(a1 + 240) != v14)
    {
      char v15 = v14;
      std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::__remove_node_pointer((uint64_t **)(a1 + 232), v14);
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<ctu::Timer>>,0>((uint64_t)(v15 + 4));
      operator delete(v15);
    }
    if (v36 < 0) {
      operator delete(*(void **)buf);
    }
  }
  uint64_t v16 = *v10;
  BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
  if (a3 && a4)
  {
    if (v17)
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = a2;
      _os_log_impl(&dword_22231A000, v16, OS_LOG_TYPE_DEFAULT, "#I Will turn on %s after a delay. Creating a timer now.", buf, 0xCu);
    }
    Registry::getTimerService(&v31, *(Registry **)(a1 + 48));
    uint64_t v18 = v31;
    std::string::basic_string[abi:ne180100]<0>(__p, "kDelayForAddMergeButton");
    int v19 = *(NSObject **)(a1 + 24);
    dispatch_object_t object = v19;
    if (v19) {
      dispatch_retain(v19);
    }
    v24[0] = MEMORY[0x263EF8330];
    v24[1] = 0x40000000;
    void v24[2] = ___ZN23EurekaCallCommandDriver17setCallCapabilityEPKcbbN10subscriber7SimSlotE_block_invoke;
    _OWORD v24[3] = &__block_descriptor_tmp_97_1;
    v24[4] = a1;
    void v24[5] = a2;
    char v26 = a4;
    int v25 = a5;
    uint64_t aBlock = _Block_copy(v24);
    ctu::TimerService::createOneShotTimer(v18, (uint64_t)__p, 1, 15000000, &object, &aBlock);
    std::string::basic_string[abi:ne180100]<0>(buf, a2);
    long long v34 = buf;
    uint64_t v20 = std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(a1 + 232), (void **)buf, &v34);
    uint64_t v21 = v33;
    uint64_t v33 = 0;
    uint64_t v22 = v20[7];
    v20[7] = v21;
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
    }
    if (v36 < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v23 = v33;
    uint64_t v33 = 0;
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
    }
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v30 < 0) {
      operator delete(__p[0]);
    }
    if (v32) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v32);
    }
  }
  else
  {
    if (v17)
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = a2;
      _os_log_impl(&dword_22231A000, v16, OS_LOG_TYPE_DEFAULT, "#I Will turn on or off %s immediately!", buf, 0xCu);
    }
    EurekaCallCommandDriver::handleSetCallCapabilityTimerExpired((void **)a1, a2, a4, a5);
  }
}

void sub_2224DAEC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *aBlock, dispatch_object_t object, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void EurekaCallCommandDriver::sendToVoicemail(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(unsigned int *)(a2 + 252);
  unsigned int v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), v4);
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v13, a1, v4);
  uint64_t v6 = v13;
  if (v13)
  {
    *(_OWORD *)long long buf = 0u;
    memset(v16, 0, sizeof(v16));
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v12, (const void **)a2);
    (*(void (**)(uint8_t *__return_ptr, uint64_t, const void **, uint64_t))(*(void *)v6 + 88))(buf, v6, &v12, v4);
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v12);
    uint64_t v8 = *(void *)buf;
    unsigned int v7 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
    if (v8)
    {
      if ((v4 - 1) >= 3) {
        int v9 = 0;
      }
      else {
        int v9 = v4;
      }
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(&v11, v9);
    }
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v16);
    if (*(void *)&buf[8]) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
    }
  }
  else
  {
    std::string v10 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_22231A000, v10, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in sendToVoicemail", buf, 2u);
    }
  }
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
}

void sub_2224DB1A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, std::__shared_weak_count *a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  if (a4) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v8, a4);
  }
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)va1);
  if (a7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a7);
  }
  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__70(void *result, void *a2)
{
  result[5] = a2[5];
  uint64_t v2 = a2 + 6;
  uint64_t v3 = a2[6];
  result[6] = v3;
  uint64_t v4 = result + 6;
  uint64_t v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[5] = v2;
    void *v2 = 0;
    a2[7] = 0;
  }
  else
  {
    result[5] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__71(uint64_t a1)
{
}

void ___ZN23EurekaCallCommandDriver26parseRemotePartyNumberNameERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v2 = a2[1];
  if (*a2 != v2)
  {
    uint64_t v4 = *a2 + 8;
    do
    {
      uint64_t v6 = v4 - 8;
      int v5 = *(unsigned __int8 *)(v4 - 8);
      char v14 = *(unsigned char *)(v4 - 8);
      memset(&__p, 0, sizeof(__p));
      if (*(char *)(v4 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v4, *(void *)(v4 + 8));
      }
      else
      {
        long long v7 = *(_OWORD *)v4;
        __p.__r_.__value_.__r.__words[2] = *(void *)(v4 + 16);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v7;
      }
      int v8 = *(unsigned __int8 *)(v4 - 7);
      if (v8 == 1) {
        int v9 = 1;
      }
      else {
        int v9 = 2 * (v8 == 2);
      }
      if (v9)
      {
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          __p.__r_.__value_.__l.__size_ = 0;
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        else
        {
          *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
          p_p = &__p;
        }
        p_p->__r_.__value_.__s.__data_[0] = 0;
      }
      if (numberContainsAlphabet())
      {
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          __p.__r_.__value_.__l.__size_ = 0;
          int v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        else
        {
          *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
          int v11 = &__p;
        }
        v11->__r_.__value_.__s.__data_[0] = 0;
        int v9 = 1;
      }
      uint64_t v12 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)(*(void *)(*(void *)(a1 + 32) + 8) + 40), v5, &v14);
      std::string::operator=((std::string *)v12 + 3, &__p);
      *((_DWORD *)v12 + 33) = v5;
      *((_DWORD *)v12 + 30) = v9;
      *((_DWORD *)v12 + 73) = *(_DWORD *)(a1 + 40);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      v4 += 32;
    }
    while (v6 + 32 != v2);
  }
}

void sub_2224DB3A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **___ZN23EurekaCallCommandDriver26parseRemotePartyNumberNameERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke_2(uint64_t **result, unsigned __int8 **a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 != v3)
  {
    uint64_t v4 = result;
    do
    {
      uint64_t v5 = v4[4][1];
      uint64_t v6 = *(uint64_t ***)(v5 + 48);
      if (v6)
      {
        unsigned int v7 = *v2;
        do
        {
          unsigned int v8 = *((unsigned __int8 *)v6 + 32);
          if (v7 >= v8)
          {
            if (v8 >= v7) {
              goto LABEL_15;
            }
            ++v6;
          }
          uint64_t v6 = (uint64_t **)*v6;
        }
        while (v6);
      }
      int v9 = *v4[5];
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = *v2;
        *(_DWORD *)long long buf = 67109120;
        int v13 = v10;
        _os_log_impl(&dword_22231A000, v9, OS_LOG_TYPE_DEFAULT, "#I Setting caller id to \"\" for callid %d, Available since we don't want to wait for any other indication", buf, 8u);
        uint64_t v5 = v4[4][1];
      }
      uint64_t result = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)(v5 + 40), *v2, (char *)v2);
      if (*((char *)result + 95) < 0)
      {
        result[10] = 0;
        int v11 = result[9];
      }
      else
      {
        int v11 = (uint64_t *)(result + 9);
        *((unsigned char *)result + 95) = 0;
      }
      *(unsigned char *)int v11 = 0;
      *((_DWORD *)result + 33) = *v2;
      *((_DWORD *)result + 30) = 0;
      *((_DWORD *)result + 73) = *((_DWORD *)v4 + 12);
LABEL_15:
      v2 += 7;
    }
    while (v2 != v3);
  }
  return result;
}

__n128 __Block_byref_object_copy__74(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__75(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 40);
  std::vector<vs::tlv::RemoteNumberListItem>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void ___ZN23EurekaCallCommandDriver26parseRemotePartyNumberNameERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke_76(uint64_t a1, __int16 **a2)
{
  uint64_t v2 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v3 = (void **)(v2 + 5);
  if (v2 + 5 != (uint64_t *)a2)
  {
    uint64_t v5 = *a2;
    uint64_t v4 = (uint64_t)a2[1];
    uint64_t v6 = v4 - (void)*a2;
    unint64_t v7 = v6 >> 5;
    uint64_t v8 = v2[7];
    uint64_t v9 = v2[5];
    if (v6 >> 5 > (unint64_t)((v8 - v9) >> 5))
    {
      if (v9)
      {
        std::vector<vs::tlv::RemoteNumberListItem>::__clear[abi:ne180100](v2 + 5);
        operator delete(*v3);
        uint64_t v8 = 0;
        unsigned __int8 *v3 = 0;
        v2[6] = 0;
        v2[7] = 0;
      }
      if (v6 < 0) {
        goto LABEL_22;
      }
      uint64_t v10 = v8 >> 4;
      if (v8 >> 4 <= v7) {
        uint64_t v10 = v6 >> 5;
      }
      unint64_t v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0 ? 0x7FFFFFFFFFFFFFFLL : v10;
      if (v11 >> 59) {
LABEL_22:
      }
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      uint64_t v12 = std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>((uint64_t)(v2 + 7), v11);
      v2[5] = (uint64_t)v12;
      v2[6] = (uint64_t)v12;
      v2[7] = (uint64_t)v12 + 32 * v13;
      uint64_t v14 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<vs::tlv::RemoteNameListItem>,vs::tlv::RemoteNameListItem*,vs::tlv::RemoteNameListItem*,vs::tlv::RemoteNameListItem*>((uint64_t)(v2 + 7), (uint64_t)v5, v4, (uint64_t)v12);
      goto LABEL_15;
    }
    unint64_t v15 = (v2[6] - v9) >> 5;
    if (v15 < v7)
    {
      uint64_t v16 = &v5[16 * v15];
      std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,vs::tlv::RemoteNameListItem *,vs::tlv::RemoteNameListItem *,vs::tlv::RemoteNameListItem *,0>(*a2, v16, v9);
      uint64_t v14 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<vs::tlv::RemoteNameListItem>,vs::tlv::RemoteNameListItem*,vs::tlv::RemoteNameListItem*,vs::tlv::RemoteNameListItem*>((uint64_t)(v2 + 7), (uint64_t)v16, v4, v2[6]);
LABEL_15:
      v2[6] = v14;
      return;
    }
    uint64_t v17 = std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,vs::tlv::RemoteNameListItem *,vs::tlv::RemoteNameListItem *,vs::tlv::RemoteNameListItem *,0>(*a2, a2[1], v9);
    for (uint64_t i = v2[6]; i != v17; i -= 32)
    {
      if (*(char *)(i - 1) < 0) {
        operator delete(*(void **)(i - 24));
      }
    }
    v2[6] = v17;
  }
}

void sub_2224DB6EC(_Unwind_Exception *a1)
{
  *(void *)(v2 + 48) = v1;
  _Unwind_Resume(a1);
}

void sub_2224DB6F4(_Unwind_Exception *a1)
{
  *(void *)(v2 + 48) = v1;
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__78(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__79(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

char *___ZN23EurekaCallCommandDriver20parseSRVCCCalls_syncERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke(char *result, const void **a2)
{
  uint64_t v2 = *(void **)(*((void *)result + 4) + 8);
  if (v2 + 5 != a2)
  {
    uint64_t v3 = (char *)*a2;
    uint64_t v4 = (char *)a2[1];
    int64_t v5 = v4 - (unsigned char *)*a2;
    unint64_t v6 = v5 >> 1;
    unint64_t v7 = v2[7];
    uint64_t v8 = (char *)v2[5];
    if (v5 >> 1 <= (unint64_t)((uint64_t)(v7 - (void)v8) >> 1))
    {
      uint64_t v14 = (char *)v2[6];
      unint64_t v11 = (char **)(v2 + 6);
      uint64_t v13 = v14;
      size_t v15 = v14 - v8;
      unint64_t v16 = (v14 - v8) >> 1;
      if (v16 < v6)
      {
        uint64_t v17 = &v3[2 * v16];
        if (v13 != v8)
        {
          __n128 result = (char *)memmove(v8, *a2, v15);
          uint64_t v8 = *v11;
        }
        int64_t v5 = v4 - v17;
        if (v4 == v17) {
          goto LABEL_22;
        }
        uint64_t v18 = v8;
        int v19 = v17;
        goto LABEL_21;
      }
    }
    else
    {
      if (v8)
      {
        v2[6] = v8;
        operator delete(v8);
        unint64_t v7 = 0;
        v2[5] = 0;
        v2[6] = 0;
        v2[7] = 0;
      }
      if (v5 < 0
        || (v7 <= v6 ? (uint64_t v9 = v5 >> 1) : (uint64_t v9 = v7),
            v7 >= 0x7FFFFFFFFFFFFFFELL ? (uint64_t v10 = 0x7FFFFFFFFFFFFFFFLL) : (uint64_t v10 = v9),
            v10 < 0))
      {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>((uint64_t)(v2 + 7), v10);
      uint64_t v8 = result;
      v2[6] = result;
      unint64_t v11 = (char **)(v2 + 6);
      *(v11 - 1) = result;
      v11[1] = &result[2 * v12];
    }
    if (v4 == v3)
    {
LABEL_22:
      *unint64_t v11 = &v8[v5];
      return result;
    }
    uint64_t v18 = v8;
    int v19 = v3;
LABEL_21:
    __n128 result = (char *)memmove(v18, v19, v5);
    goto LABEL_22;
  }
  return result;
}

__n128 __Block_byref_object_copy__81(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__82(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

char *___ZN23EurekaCallCommandDriver18parseEndIndicationERKN2vs15VoiceCallStatus10IndicationERNSt3__13mapIh8CallInfoNS5_4lessIhEENS5_9allocatorINS5_4pairIKhS7_EEEEEEN10subscriber7SimSlotE_block_invoke(char *result, const void **a2)
{
  uint64_t v2 = *(void **)(*((void *)result + 4) + 8);
  if (v2 + 5 != a2)
  {
    uint64_t v3 = (char *)*a2;
    uint64_t v4 = (char *)a2[1];
    int64_t v5 = v4 - (unsigned char *)*a2;
    unint64_t v6 = v5 >> 2;
    uint64_t v7 = v2[7];
    uint64_t v8 = (char *)v2[5];
    if (v5 >> 2 <= (unint64_t)((v7 - (uint64_t)v8) >> 2))
    {
      uint64_t v14 = (char *)v2[6];
      unint64_t v11 = (char **)(v2 + 6);
      uint64_t v13 = v14;
      size_t v15 = v14 - v8;
      unint64_t v16 = (v14 - v8) >> 2;
      if (v16 < v6)
      {
        uint64_t v17 = &v3[4 * v16];
        if (v13 != v8)
        {
          __n128 result = (char *)memmove(v8, *a2, v15);
          uint64_t v8 = *v11;
        }
        int64_t v5 = v4 - v17;
        if (v4 == v17) {
          goto LABEL_21;
        }
        uint64_t v18 = v8;
        int v19 = v17;
        goto LABEL_20;
      }
    }
    else
    {
      if (v8)
      {
        v2[6] = v8;
        operator delete(v8);
        uint64_t v7 = 0;
        v2[5] = 0;
        v2[6] = 0;
        v2[7] = 0;
      }
      if (v5 < 0) {
        goto LABEL_23;
      }
      uint64_t v9 = v7 >> 1;
      if (v7 >> 1 <= v6) {
        uint64_t v9 = v5 >> 2;
      }
      unint64_t v10 = (unint64_t)v7 >= 0x7FFFFFFFFFFFFFFCLL ? 0x3FFFFFFFFFFFFFFFLL : v9;
      if (v10 >> 62) {
LABEL_23:
      }
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,4ul>>>((uint64_t)(v2 + 7), v10);
      uint64_t v8 = result;
      v2[6] = result;
      unint64_t v11 = (char **)(v2 + 6);
      *(v11 - 1) = result;
      v11[1] = &result[4 * v12];
    }
    if (v4 == v3)
    {
LABEL_21:
      *unint64_t v11 = &v8[v5];
      return result;
    }
    uint64_t v18 = v8;
    int v19 = v3;
LABEL_20:
    __n128 result = (char *)memmove(v18, v19, v5);
    goto LABEL_21;
  }
  return result;
}

void EurekaCallCommandDriver::sendCallWaitingTone(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112));
  uint64_t v10 = 0;
  unint64_t v11 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v10, a1, a2);
  if (v10 && ((*(uint64_t (**)(uint64_t))(*(void *)v10 + 168))(v10) & 1) == 0)
  {
    *(void *)long long buf = 0;
    uint64_t v9 = 0;
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 120) + 288))(buf);
    if (*(void *)buf)
    {
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)buf + 40))(*(void *)buf, 7, 3);
    }
    else
    {
      unint64_t v6 = *v4;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v7 = 0;
        _os_log_error_impl(&dword_22231A000, v6, OS_LOG_TYPE_ERROR, "Did not get a valid CallAudioDriver", v7, 2u);
      }
    }
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    }
  }
  else
  {
    int64_t v5 = *v4;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Not playing call waiting tones since Network will generate the tones in band", buf, 2u);
    }
  }
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
}

void sub_2224DBB90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void EurekaCallCommandDriver::sendEndCallAudio(EurekaCallCommandDriver *this, const CallInfo *a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**((void **)this + 14) + 16))(*((void *)this + 14), *((unsigned int *)a2 + 63));
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 15) + 288))(&v7);
  if (v7)
  {
    if (CallInfo::getCCDisconnectErrorCode(a2) != 28) {
      CallInfo::getCCDisconnectErrorCode(a2);
    }
    (*(void (**)(void))(*(void *)v7 + 40))();
  }
  else
  {
    int64_t v5 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t v6 = 0;
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Did not get a valid CallAudioDriver", v6, 2u);
    }
  }
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
}

void sub_2224DBD6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t EurekaCallCommandDriver::areVoiceCallsAllowedRightNow(EurekaCallCommandDriver *this)
{
  if (*((unsigned char *)this + 304)) {
    return 1;
  }
  else {
    return (*(uint64_t (**)(void))(**((void **)this + 15) + 176))();
  }
}

void EurekaCallCommandDriver::handleECBMChanged(EurekaCallCommandDriver *this, int a2)
{
  uint64_t v4 = *((void *)this + 5);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I ECBM mode is enabled!", buf, 2u);
    }
    *((unsigned char *)this + 304) = a2;
  }
  else
  {
    if (v5)
    {
      *(_WORD *)unint64_t v6 = 0;
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I ECBM mode is disabled!", v6, 2u);
    }
    *((unsigned char *)this + 304) = 0;
    (*(void (**)(void, uint64_t))(**((void **)this + 15) + 128))(*((void *)this + 15), 1);
  }
}

void EurekaCallCommandDriver::answerWaitingHoldOther(uint64_t a1, const void **a2)
{
  v34[7] = *MEMORY[0x263EF8340];
  uint64_t v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  memset(v19, 0, sizeof(v19));
  CallInfo::CallInfo((CallInfo *)v19);
  uint64_t v4 = *(void *)(a1 + 120);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v18, a2);
  LOBYTE(v4) = (*(uint64_t (**)(uint64_t, const void **, _OWORD *))(*(void *)v4 + 296))(v4, &v18, v19);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v18);
  if (v4)
  {
    uint64_t v5 = HIDWORD(v20);
    unint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), HIDWORD(v20));
    uint64_t v15 = 0;
    unint64_t v16 = 0;
    EurekaCallCommandDriver::getPreferredFormatterForSim(&v15, a1, v5);
    uint64_t v7 = v15;
    if (v15)
    {
      long long v33 = 0u;
      memset(v34, 0, 48);
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v14, a2);
      (*(void (**)(long long *__return_ptr, uint64_t, const void **, uint64_t))(*(void *)v7 + 32))(&v33, v7, &v14, v5);
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v14);
      long long v8 = v33;
      if (*((void *)&v33 + 1))
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v33 + 1) + 8), 1uLL, memory_order_relaxed);
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v8 + 1));
      }
      if ((void)v8)
      {
        if ((HIDWORD(v20) - 1) >= 3) {
          int v9 = 0;
        }
        else {
          int v9 = HIDWORD(v20);
        }
        if (*((void *)&v33 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v33 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        qmi::ClientRouter::get();
        qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(&v13, v9);
      }
      std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v34);
      if (*((void *)&v33 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v33 + 1));
      }
    }
    else
    {
      uint64_t v12 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v33) = 0;
        _os_log_error_impl(&dword_22231A000, v12, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in answerWaitingHoldOther", (uint8_t *)&v33, 2u);
      }
    }
    if (v16) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v16);
    }
  }
  else
  {
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v17, a2);
      printUuid();
      if (v34[0] >= 0) {
        unint64_t v11 = &v33;
      }
      else {
        unint64_t v11 = (long long *)v33;
      }
      *(_DWORD *)long long buf = 136315138;
      int v32 = v11;
      _os_log_error_impl(&dword_22231A000, v10, OS_LOG_TYPE_ERROR, "Could not find call with UUID %s when trying to wait-hold", buf, 0xCu);
      if (SHIBYTE(v34[0]) < 0) {
        operator delete((void *)v33);
      }
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v17);
    }
  }
  CallInfo::~CallInfo((void **)v19);
}

void sub_2224DC204(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, std::__shared_weak_count *a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100]((void *)(v11 - 176));
  if (a4) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v10, a4);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v11 - 144));
  if (a7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a7);
  }
  CallInfo::~CallInfo((void **)va);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::answerWaitingEndActive(EurekaCallCommandDriver *this, int *a2)
{
  v43[7] = *MEMORY[0x263EF8340];
  long long v40 = 0u;
  memset(v41, 0, 24);
  long long v38 = 0u;
  long long v39 = 0u;
  long long v37 = 0u;
  memset(v36, 0, sizeof(v36));
  long long v34 = 0u;
  memset(v35, 0, sizeof(v35));
  long long v33 = 0u;
  memset(v32, 0, sizeof(v32));
  memset(v31, 0, sizeof(v31));
  CallInfo::CallInfo((CallInfo *)v31);
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  long long v24 = this;
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 15) + 304))(&v28);
  uint64_t v4 = v28;
  for (uint64_t i = v29; v4 != i; v4 += 408)
  {
    unsigned int v5 = *(unsigned __int8 *)(v4 + 68);
    BOOL v6 = v5 > 8;
    int v7 = (1 << v5) & 0x114;
    if (v6 || v7 == 0)
    {
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::operator=((const void **)v31, (const void **)v4);
      std::string::operator=((std::string *)((char *)v31 + 8), (const std::string *)(v4 + 8));
      std::string::operator=(v32, (const std::string *)(v4 + 32));
      *(_OWORD *)&v32[1].__r_.__value_.__l.__data_ = *(_OWORD *)(v4 + 56);
      long long v9 = *(_OWORD *)(v4 + 72);
      long long v10 = *(_OWORD *)(v4 + 88);
      long long v11 = *(_OWORD *)(v4 + 104);
      *(std::string::size_type *)((char *)&v32[3].__r_.__value_.__r.__words[1] + 5) = *(void *)(v4 + 117);
      *(_OWORD *)&v32[2].__r_.__value_.__r.__words[1] = v10;
      *(_OWORD *)&v32[3].__r_.__value_.__l.__data_ = v11;
      *(_OWORD *)&v32[1].__r_.__value_.__r.__words[2] = v9;
      std::string::operator=((std::string *)&v33, (const std::string *)(v4 + 128));
      DWORD2(v34) = *(_DWORD *)(v4 + 152);
      std::string::operator=((std::string *)v35, (const std::string *)(v4 + 160));
      long long v12 = *(_OWORD *)(v4 + 184);
      *(_OWORD *)&v35[33] = *(_OWORD *)(v4 + 193);
      *(_OWORD *)&v35[24] = v12;
      std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<unsigned int>,false> const&>((uint64_t)&v35[56], v4 + 216);
      long long v13 = *(_OWORD *)(v4 + 248);
      v35[104] = *(unsigned char *)(v4 + 264);
      *(_OWORD *)&v35[88] = v13;
      std::string::operator=(v36, (const std::string *)(v4 + 272));
      std::string::operator=(&v36[1], (const std::string *)(v4 + 296));
      long long v14 = *(_OWORD *)(v4 + 336);
      long long v37 = *(_OWORD *)(v4 + 320);
      long long v38 = v14;
      long long v15 = *(_OWORD *)(v4 + 352);
      long long v16 = *(_OWORD *)(v4 + 368);
      long long v17 = *(_OWORD *)(v4 + 384);
      *(void *)((char *)v41 + 13) = *(void *)(v4 + 397);
      long long v40 = v16;
      v41[0] = v17;
      long long v39 = v15;
    }
  }
  uint64_t v18 = *(unsigned int *)&v35[92];
  int v19 = (os_log_t *)(*(uint64_t (**)(void, void))(**((void **)v24 + 14) + 16))(*((void *)v24 + 14), *(unsigned int *)&v35[92]);
  uint64_t v26 = 0;
  long long v27 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v26, (uint64_t)v24, v18);
  if (v26)
  {
    long long buf = 0u;
    memset(v43, 0, 48);
    (*(void (**)(long long *__return_ptr))(*(void *)v26 + 40))(&buf);
    long long v20 = buf;
    if (*((void *)&buf + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&buf + 1) + 8), 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v20 + 1));
    }
    if ((void)v20 && !*a2)
    {
      if ((*(_DWORD *)&v35[92] - 1) >= 3) {
        int v21 = 0;
      }
      else {
        int v21 = *(_DWORD *)&v35[92];
      }
      if (*((void *)&buf + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&buf + 1) + 8), 1uLL, memory_order_relaxed);
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(&v25, v21);
    }
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v43);
    if (*((void *)&buf + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&buf + 1));
    }
  }
  else
  {
    long long v22 = *v19;
    if (os_log_type_enabled(*v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&dword_22231A000, v22, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in answerWaitingEndActive", (uint8_t *)&buf, 2u);
    }
  }
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
  *(void *)&long long buf = &v28;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&buf);
  CallInfo::~CallInfo((void **)v31);
}

void sub_2224DC6C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, ...)
{
  va_start(va1, a14);
  va_start(va, a14);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v20 = va_arg(va1, void);
  uint64_t v21 = va_arg(va1, void);
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100]((void *)(v16 - 208));
  if (a12) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v15, a12);
  }
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v16 - 176));
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  *(void *)(v16 - 176) = va;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)(v16 - 176));
  CallInfo::~CallInfo((void **)va1);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::answerIncomingCall(uint64_t a1, unsigned int *a2)
{
  v15[7] = *MEMORY[0x263EF8340];
  uint64_t v4 = a2[63];
  unsigned int v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), v4);
  uint64_t v12 = 0;
  long long v13 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v12, a1, v4);
  uint64_t v6 = v12;
  if (v12)
  {
    long long buf = 0u;
    memset(v15, 0, 48);
    CallInfo::CallInfo((CallInfo *)v11, (const CallInfo *)a2);
    (*(void (**)(long long *__return_ptr, uint64_t, void **))(*(void *)v6 + 48))(&buf, v6, v11);
    CallInfo::~CallInfo(v11);
    long long v7 = buf;
    if (*((void *)&buf + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&buf + 1) + 8), 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v7 + 1));
    }
    if ((void)v7)
    {
      if ((v4 - 1) >= 3) {
        int v8 = 0;
      }
      else {
        int v8 = v4;
      }
      if (*((void *)&buf + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&buf + 1) + 8), 1uLL, memory_order_relaxed);
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(&v10, v8);
    }
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v15);
    if (*((void *)&buf + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&buf + 1));
    }
  }
  else
  {
    long long v9 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&dword_22231A000, v9, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in answerIncomingCall", (uint8_t *)&buf, 2u);
    }
  }
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
}

void sub_2224DC978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100]((void *)(v12 - 160));
  uint64_t v14 = a11;
  a11 = 0;
  if (v14) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a11, v14);
  }
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v12 - 128));
  uint64_t v15 = *(std::__shared_weak_count **)(v12 - 168);
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::mergeCalls(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(unsigned int *)(a2 + 252);
  unsigned int v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), v4);
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v14, a1, v4);
  uint64_t v6 = v14;
  if (v14)
  {
    *(_OWORD *)long long buf = 0u;
    memset(v17, 0, sizeof(v17));
    CallInfo::CallInfo((CallInfo *)v12, (const CallInfo *)a2);
    if (*(char *)(a2 + 431) < 0) {
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a2 + 408), *(void *)(a2 + 416));
    }
    else {
      std::string __p = *(std::string *)(a2 + 408);
    }
    (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v6 + 72))(buf, v6, v12);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    CallInfo::~CallInfo(v12);
    uint64_t v9 = *(void *)buf;
    int v8 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
    if (v9)
    {
      if ((v4 - 1) >= 3) {
        int v10 = 0;
      }
      else {
        int v10 = v4;
      }
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(&v11, v10);
    }
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v17);
    if (*(void *)&buf[8]) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
    }
  }
  else
  {
    long long v7 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_22231A000, v7, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in mergeCalls", buf, 2u);
    }
  }
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
}

void sub_2224DCC54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  CallInfo::~CallInfo((void **)va);
  unsigned int v5 = *(std::__shared_weak_count **)(v3 - 168);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  _Unwind_Resume(a1);
}

void CallOperationContext::~CallOperationContext(void **this)
{
  if (*((char *)this + 431) < 0) {
    operator delete(this[51]);
  }

  CallInfo::~CallInfo(this);
}

void EurekaCallCommandDriver::createPrivateConversation(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(unsigned int *)(a2 + 252);
  unsigned int v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), v4);
  uint64_t v6 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#I Creating a private conversation.", buf, 2u);
  }
  uint64_t v16 = 0;
  long long v17 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v16, a1, v4);
  uint64_t v7 = v16;
  if (v16)
  {
    *(_OWORD *)long long buf = 0u;
    memset(v20, 0, sizeof(v20));
    CallInfo::CallInfo((CallInfo *)v14, (const CallInfo *)a2);
    if (*(char *)(a2 + 431) < 0) {
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a2 + 408), *(void *)(a2 + 416));
    }
    else {
      std::string __p = *(std::string *)(a2 + 408);
    }
    (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v7 + 80))(buf, v7, v14);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    CallInfo::~CallInfo(v14);
    uint64_t v10 = *(void *)buf;
    uint64_t v9 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    }
    if (v10)
    {
      if ((v4 - 1) >= 3) {
        int v11 = 0;
      }
      else {
        int v11 = v4;
      }
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(&v13, v11);
    }
    uint64_t v12 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v18 = 0;
      _os_log_error_impl(&dword_22231A000, v12, OS_LOG_TYPE_ERROR, "Failed to create private conversation!", v18, 2u);
    }
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v20);
    if (*(void *)&buf[8]) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
    }
  }
  else
  {
    int v8 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_22231A000, v8, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in createPrivateConversation", buf, 2u);
    }
  }
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  }
}

void sub_2224DD008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  CallInfo::~CallInfo((void **)va);
  unsigned int v5 = *(std::__shared_weak_count **)(v3 - 184);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::holdUnHoldActiveCall(uint64_t a1, const void **a2)
{
  v34[7] = *MEMORY[0x263EF8340];
  uint64_t v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  memset(v19, 0, sizeof(v19));
  CallInfo::CallInfo((CallInfo *)v19);
  uint64_t v4 = *(void *)(a1 + 120);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v18, a2);
  LOBYTE(v4) = (*(uint64_t (**)(uint64_t, const void **, _OWORD *))(*(void *)v4 + 296))(v4, &v18, v19);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v18);
  if (v4)
  {
    uint64_t v5 = HIDWORD(v20);
    uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), HIDWORD(v20));
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    EurekaCallCommandDriver::getPreferredFormatterForSim(&v15, a1, v5);
    uint64_t v7 = v15;
    if (v15)
    {
      long long v33 = 0u;
      memset(v34, 0, 48);
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v14, a2);
      (*(void (**)(long long *__return_ptr, uint64_t, const void **, uint64_t))(*(void *)v7 + 32))(&v33, v7, &v14, v5);
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v14);
      long long v8 = v33;
      if (*((void *)&v33 + 1))
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v33 + 1) + 8), 1uLL, memory_order_relaxed);
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v8 + 1));
      }
      if ((void)v8)
      {
        if ((v5 - 1) >= 3) {
          int v9 = 0;
        }
        else {
          int v9 = v5;
        }
        if (*((void *)&v33 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v33 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        qmi::ClientRouter::get();
        qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(&v13, v9);
      }
      std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v34);
      if (*((void *)&v33 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v33 + 1));
      }
    }
    else
    {
      uint64_t v12 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v33) = 0;
        _os_log_error_impl(&dword_22231A000, v12, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in holdUnHoldActiveCall", (uint8_t *)&v33, 2u);
      }
    }
    if (v16) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v16);
    }
  }
  else
  {
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v17, a2);
      printUuid();
      if (v34[0] >= 0) {
        int v11 = &v33;
      }
      else {
        int v11 = (long long *)v33;
      }
      *(_DWORD *)long long buf = 136315138;
      int v32 = v11;
      _os_log_error_impl(&dword_22231A000, v10, OS_LOG_TYPE_ERROR, "Could not find call with UUID %s when trying to hold/unhold", buf, 0xCu);
      if (SHIBYTE(v34[0]) < 0) {
        operator delete((void *)v33);
      }
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v17);
    }
  }
  CallInfo::~CallInfo((void **)v19);
}

void sub_2224DD3FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, std::__shared_weak_count *a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100]((void *)(v11 - 176));
  if (a4) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v10, a4);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v11 - 144));
  if (a7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a7);
  }
  CallInfo::~CallInfo((void **)va);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::swapCalls(uint64_t a1, const void **a2)
{
  v34[7] = *MEMORY[0x263EF8340];
  uint64_t v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  memset(v19, 0, sizeof(v19));
  CallInfo::CallInfo((CallInfo *)v19);
  uint64_t v4 = *(void *)(a1 + 120);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v18, a2);
  LOBYTE(v4) = (*(uint64_t (**)(uint64_t, const void **, _OWORD *))(*(void *)v4 + 296))(v4, &v18, v19);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v18);
  if (v4)
  {
    uint64_t v5 = HIDWORD(v20);
    uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), HIDWORD(v20));
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    EurekaCallCommandDriver::getPreferredFormatterForSim(&v15, a1, v5);
    uint64_t v7 = v15;
    if (v15)
    {
      long long v33 = 0u;
      memset(v34, 0, 48);
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v14, a2);
      (*(void (**)(long long *__return_ptr, uint64_t, const void **, uint64_t))(*(void *)v7 + 64))(&v33, v7, &v14, v5);
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v14);
      long long v8 = v33;
      if (*((void *)&v33 + 1))
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v33 + 1) + 8), 1uLL, memory_order_relaxed);
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v8 + 1));
      }
      if ((void)v8)
      {
        if ((v5 - 1) >= 3) {
          int v9 = 0;
        }
        else {
          int v9 = v5;
        }
        if (*((void *)&v33 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v33 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        qmi::ClientRouter::get();
        qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(&v13, v9);
      }
      std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v34);
      if (*((void *)&v33 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v33 + 1));
      }
    }
    else
    {
      uint64_t v12 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v33) = 0;
        _os_log_error_impl(&dword_22231A000, v12, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in swapCalls", (uint8_t *)&v33, 2u);
      }
    }
    if (v16) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v16);
    }
  }
  else
  {
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v17, a2);
      printUuid();
      if (v34[0] >= 0) {
        uint64_t v11 = &v33;
      }
      else {
        uint64_t v11 = (long long *)v33;
      }
      *(_DWORD *)long long buf = 136315138;
      int v32 = v11;
      _os_log_error_impl(&dword_22231A000, v10, OS_LOG_TYPE_ERROR, "Could not find call with UUID %s when trying to swap", buf, 0xCu);
      if (SHIBYTE(v34[0]) < 0) {
        operator delete((void *)v33);
      }
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v17);
    }
  }
  CallInfo::~CallInfo((void **)v19);
}

void sub_2224DD808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, std::__shared_weak_count *a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100]((void *)(v11 - 176));
  if (a4) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v10, a4);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v11 - 144));
  if (a7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a7);
  }
  CallInfo::~CallInfo((void **)va);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::endHeldCalls(EurekaCallCommandDriver *this)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 15) + 312))(&v35);
  long long v33 = 0u;
  memset(v34, 0, sizeof(v34));
  long long v31 = 0u;
  long long v32 = 0u;
  long long v30 = 0u;
  memset(v29, 0, sizeof(v29));
  long long v27 = 0u;
  memset(v28, 0, sizeof(v28));
  long long v26 = 0u;
  memset(v25, 0, sizeof(v25));
  memset(v24, 0, sizeof(v24));
  CallInfo::CallInfo((CallInfo *)v24);
  uint64_t v2 = v35;
  if (v35 != v36)
  {
    while (1)
    {
      unsigned int v3 = *(unsigned __int8 *)(v2 + 68);
      BOOL v4 = v3 > 8;
      int v5 = (1 << v3) & 0x114;
      if (v4 || v5 == 0) {
        break;
      }
      v2 += 408;
      if (v2 == v36) {
        goto LABEL_9;
      }
    }
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::operator=((const void **)v24, (const void **)v2);
    std::string::operator=((std::string *)((char *)v24 + 8), (const std::string *)(v2 + 8));
    std::string::operator=(v25, (const std::string *)(v2 + 32));
    *(_OWORD *)&v25[1].__r_.__value_.__l.__data_ = *(_OWORD *)(v2 + 56);
    long long v7 = *(_OWORD *)(v2 + 72);
    long long v8 = *(_OWORD *)(v2 + 88);
    long long v9 = *(_OWORD *)(v2 + 104);
    *(std::string::size_type *)((char *)&v25[3].__r_.__value_.__r.__words[1] + 5) = *(void *)(v2 + 117);
    *(_OWORD *)&v25[3].__r_.__value_.__l.__data_ = v9;
    *(_OWORD *)&v25[2].__r_.__value_.__r.__words[1] = v8;
    *(_OWORD *)&v25[1].__r_.__value_.__r.__words[2] = v7;
    std::string::operator=((std::string *)&v26, (const std::string *)(v2 + 128));
    DWORD2(v27) = *(_DWORD *)(v2 + 152);
    std::string::operator=((std::string *)v28, (const std::string *)(v2 + 160));
    long long v10 = *(_OWORD *)(v2 + 184);
    *(_OWORD *)&v28[33] = *(_OWORD *)(v2 + 193);
    *(_OWORD *)&v28[24] = v10;
    std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<unsigned int>,false> const&>((uint64_t)&v28[56], v2 + 216);
    long long v11 = *(_OWORD *)(v2 + 248);
    v28[104] = *(unsigned char *)(v2 + 264);
    *(_OWORD *)&v28[88] = v11;
    std::string::operator=(v29, (const std::string *)(v2 + 272));
    std::string::operator=(&v29[1], (const std::string *)(v2 + 296));
    long long v12 = *(_OWORD *)(v2 + 352);
    long long v13 = *(_OWORD *)(v2 + 368);
    long long v14 = *(_OWORD *)(v2 + 384);
    *(void *)&v34[13] = *(void *)(v2 + 397);
    long long v15 = *(_OWORD *)(v2 + 336);
    long long v30 = *(_OWORD *)(v2 + 320);
    long long v31 = v15;
    long long v33 = v13;
    *(_OWORD *)long long v34 = v14;
    long long v32 = v12;
  }
LABEL_9:
  uint64_t v16 = *(unsigned int *)&v28[92];
  long long v17 = (os_log_t *)(*(uint64_t (**)(void, void))(**((void **)this + 14) + 16))(*((void *)this + 14), *(unsigned int *)&v28[92]);
  uint64_t v22 = 0;
  long long v23 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v22, (uint64_t)this, v16);
  if (v22)
  {
    *(_OWORD *)long long buf = 0u;
    memset(v39, 0, sizeof(v39));
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v22 + 96))(buf);
    uint64_t v19 = *(void *)buf;
    uint64_t v18 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v18);
    }
    if (v19)
    {
      if ((v16 - 1) >= 3) {
        LODWORD(v16) = 0;
      }
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(&v21, v16);
    }
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v39);
    if (*(void *)&buf[8]) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
    }
  }
  else
  {
    long long v20 = *v17;
    if (os_log_type_enabled(*v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_22231A000, v20, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in endHeldCalls", buf, 2u);
    }
  }
  if (v23) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v23);
  }
  CallInfo::~CallInfo((void **)v24);
  *(void *)&v24[0] = &v35;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)v24);
}

void sub_2224DDC78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, void *a13)
{
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100]((void *)(v15 - 160));
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v14, a10);
  }
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v15 - 128));
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  CallInfo::~CallInfo(&a13);
  a13 = (void *)(v15 - 184);
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::endCallDueToSRVCC(uint64_t a1, const CallInfo *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  unsigned int v3 = *((_DWORD *)a2 + 63);
  BOOL v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *((_DWORD *)a2 + 23);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v5;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Ending call due to handover: %d", buf, 8u);
  }
  memset(v10, 0, 32);
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v10);
  v8[0] = MEMORY[0x263EF8330];
  v8[1] = 1174405120;
  _OWORD v8[2] = ___ZN23EurekaCallCommandDriver17endCallDueToSRVCCE8CallInfo_block_invoke;
  v8[3] = &__block_descriptor_tmp_92_3;
  CallInfo::CallInfo((CallInfo *)&v9, a2);
  uint64_t v6 = qmi::MutableMessageBase::getTLV<vs::tlv::CallIdentifier>((uint64_t)v10, 1);
  ___ZN23EurekaCallCommandDriver17endCallDueToSRVCCE8CallInfo_block_invoke((uint64_t)v8, v6);
  if (v3 - 1 >= 3) {
    unsigned int v3 = 0;
  }
  qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::EndCall::Request>(&v7, v3);
}

void sub_2224DDFD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v15 = *(std::__shared_weak_count **)(v13 - 104);
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  uint64_t v16 = a11;
  a11 = 0;
  if (v16) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a11, v16);
  }
  CallInfo::~CallInfo(v11);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v13 - 224));
  _Unwind_Resume(a1);
}

uint64_t ___ZN23EurekaCallCommandDriver17endCallDueToSRVCCE8CallInfo_block_invoke(uint64_t result, unsigned char *a2)
{
  *a2 = *(_DWORD *)(result + 124);
  return result;
}

uint64_t ___ZN23EurekaCallCommandDriver11endThisCallE8CallInfo_block_invoke(uint64_t result, unsigned char *a2)
{
  *a2 = *(_DWORD *)(result + 124);
  return result;
}

void EurekaCallCommandDriver::endAllCalls(uint64_t a1, uint64_t a2)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 120) + 328))(&v39);
  long long v37 = 0u;
  memset(v38, 0, sizeof(v38));
  long long v35 = 0u;
  long long v36 = 0u;
  long long v34 = 0u;
  memset(v33, 0, sizeof(v33));
  long long v31 = 0u;
  memset(v32, 0, sizeof(v32));
  long long v30 = 0u;
  memset(v29, 0, sizeof(v29));
  memset(v28, 0, sizeof(v28));
  CallInfo::CallInfo((CallInfo *)v28);
  uint64_t v4 = v39;
  if (v39 != v40)
  {
    while (1)
    {
      unsigned int v5 = *(unsigned __int8 *)(v4 + 68);
      BOOL v6 = v5 > 8;
      int v7 = (1 << v5) & 0x114;
      if (v6 || v7 == 0) {
        break;
      }
      v4 += 408;
      if (v4 == v40) {
        goto LABEL_9;
      }
    }
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::operator=((const void **)v28, (const void **)v4);
    std::string::operator=((std::string *)((char *)v28 + 8), (const std::string *)(v4 + 8));
    std::string::operator=(v29, (const std::string *)(v4 + 32));
    *(_OWORD *)&v29[1].__r_.__value_.__l.__data_ = *(_OWORD *)(v4 + 56);
    long long v9 = *(_OWORD *)(v4 + 72);
    long long v10 = *(_OWORD *)(v4 + 88);
    long long v11 = *(_OWORD *)(v4 + 104);
    *(std::string::size_type *)((char *)&v29[3].__r_.__value_.__r.__words[1] + 5) = *(void *)(v4 + 117);
    *(_OWORD *)&v29[3].__r_.__value_.__l.__data_ = v11;
    *(_OWORD *)&v29[2].__r_.__value_.__r.__words[1] = v10;
    *(_OWORD *)&v29[1].__r_.__value_.__r.__words[2] = v9;
    std::string::operator=((std::string *)&v30, (const std::string *)(v4 + 128));
    DWORD2(v31) = *(_DWORD *)(v4 + 152);
    std::string::operator=((std::string *)v32, (const std::string *)(v4 + 160));
    long long v12 = *(_OWORD *)(v4 + 184);
    *(_OWORD *)&v32[33] = *(_OWORD *)(v4 + 193);
    *(_OWORD *)&v32[24] = v12;
    std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<unsigned int>,false> const&>((uint64_t)&v32[56], v4 + 216);
    long long v13 = *(_OWORD *)(v4 + 248);
    v32[104] = *(unsigned char *)(v4 + 264);
    *(_OWORD *)&v32[88] = v13;
    std::string::operator=(v33, (const std::string *)(v4 + 272));
    std::string::operator=(&v33[1], (const std::string *)(v4 + 296));
    long long v14 = *(_OWORD *)(v4 + 352);
    long long v15 = *(_OWORD *)(v4 + 368);
    long long v16 = *(_OWORD *)(v4 + 384);
    *(void *)&v38[13] = *(void *)(v4 + 397);
    long long v17 = *(_OWORD *)(v4 + 336);
    long long v34 = *(_OWORD *)(v4 + 320);
    long long v35 = v17;
    long long v37 = v15;
    *(_OWORD *)long long v38 = v16;
    long long v36 = v14;
  }
LABEL_9:
  uint64_t v26 = 0;
  long long v27 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v26, a1, a2);
  uint64_t v18 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), a2);
  if (v26)
  {
    long long v47 = 0x61A8uLL;
    memset(v46, 0, sizeof(v46));
    *(_OWORD *)long long buf = 0u;
    (*(void (**)(long long *__return_ptr))(*(void *)v26 + 104))(&v42);
    long long v19 = v42;
    long long v42 = 0uLL;
    long long v20 = *(std::__shared_weak_count **)&buf[8];
    *(_OWORD *)long long buf = v19;
    if (v20) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v20);
    }
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::operator=[abi:ne180100](v46, (uint64_t)v43);
    long long v47 = v44;
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v43);
    if (*((void *)&v42 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v42 + 1));
    }
    uint64_t v22 = *(void *)buf;
    int v21 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v21);
    }
    if (v22)
    {
      if ((a2 - 1) >= 3) {
        int v23 = 0;
      }
      else {
        int v23 = a2;
      }
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(&v25, v23);
    }
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v46);
    if (*(void *)&buf[8]) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
    }
  }
  else
  {
    long long v24 = *v18;
    if (os_log_type_enabled(*v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_22231A000, v24, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in endAllCalls", buf, 2u);
    }
  }
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
  CallInfo::~CallInfo((void **)v28);
  *(void *)&v28[0] = &v39;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)v28);
}

void sub_2224DE484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, void *a13)
{
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100]((void *)(v15 - 192));
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v14, a10);
  }
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v15 - 128));
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  CallInfo::~CallInfo(&a13);
  a13 = (void *)(v15 - 216);
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::createExplicitCallTransfer(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v4 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112));
  uint64_t v12 = 0;
  long long v13 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v12, a1, a2);
  if (v12)
  {
    memset(v18, 0, sizeof(v18));
    *(_OWORD *)long long buf = 0u;
    long long v19 = 0x61A8uLL;
    (*(void (**)(long long *__return_ptr))(*(void *)v12 + 112))(&v14);
    long long v5 = v14;
    long long v14 = 0uLL;
    BOOL v6 = *(std::__shared_weak_count **)&buf[8];
    *(_OWORD *)long long buf = v5;
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    }
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::operator=[abi:ne180100](v18, (uint64_t)v15);
    long long v19 = v16;
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v15);
    if (*((void *)&v14 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v14 + 1));
    }
    uint64_t v8 = *(void *)buf;
    int v7 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
    if (v8)
    {
      if ((a2 - 1) >= 3) {
        int v9 = 0;
      }
      else {
        int v9 = a2;
      }
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(&v11, v9);
    }
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v18);
    if (*(void *)&buf[8]) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
    }
  }
  else
  {
    long long v10 = *v4;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_22231A000, v10, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in createExplicitCallTransfer", buf, 2u);
    }
  }
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
}

void sub_2224DE788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  if (a3) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v6, a3);
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)va1);
  if (a5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a5);
  }
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::getAllCallCapabilities@<X0>(uint64_t result@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v3 = *(void *)(result + 288);
  if (v3)
  {
    uint64_t v4 = result + 288;
    do
    {
      int v5 = *(_DWORD *)(v3 + 32);
      BOOL v6 = v5 < a2;
      if (v5 >= a2) {
        int v7 = (uint64_t *)v3;
      }
      else {
        int v7 = (uint64_t *)(v3 + 8);
      }
      if (!v6) {
        uint64_t v4 = v3;
      }
      uint64_t v3 = *v7;
    }
    while (*v7);
    if (v4 != result + 288 && *(_DWORD *)(v4 + 32) <= a2) {
      return std::map<char const*,int>::map[abi:ne180100]((uint64_t)a3, (void *)(v4 + 40));
    }
  }
  a3[2] = 0;
  a3[1] = 0;
  *a3 = a3 + 1;
  return result;
}

void EurekaCallCommandDriver::enableVoicePrivacy(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 120) + 320))(&v41);
  long long v39 = 0u;
  memset(v40, 0, sizeof(v40));
  long long v37 = 0u;
  long long v38 = 0u;
  long long v36 = 0u;
  memset(v35, 0, sizeof(v35));
  long long v33 = 0u;
  memset(v34, 0, sizeof(v34));
  long long v32 = 0u;
  memset(v31, 0, sizeof(v31));
  memset(v30, 0, sizeof(v30));
  CallInfo::CallInfo((CallInfo *)v30);
  uint64_t v6 = v41;
  if (v41 != v42)
  {
    while (1)
    {
      unsigned int v7 = *(unsigned __int8 *)(v6 + 68);
      BOOL v8 = v7 > 8;
      int v9 = (1 << v7) & 0x114;
      if (v8 || v9 == 0) {
        break;
      }
      v6 += 408;
      if (v6 == v42) {
        goto LABEL_9;
      }
    }
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::operator=((const void **)v30, (const void **)v6);
    std::string::operator=((std::string *)((char *)v30 + 8), (const std::string *)(v6 + 8));
    std::string::operator=(v31, (const std::string *)(v6 + 32));
    *(_OWORD *)&v31[1].__r_.__value_.__l.__data_ = *(_OWORD *)(v6 + 56);
    long long v11 = *(_OWORD *)(v6 + 72);
    long long v12 = *(_OWORD *)(v6 + 88);
    long long v13 = *(_OWORD *)(v6 + 104);
    *(std::string::size_type *)((char *)&v31[3].__r_.__value_.__r.__words[1] + 5) = *(void *)(v6 + 117);
    *(_OWORD *)&v31[3].__r_.__value_.__l.__data_ = v13;
    *(_OWORD *)&v31[2].__r_.__value_.__r.__words[1] = v12;
    *(_OWORD *)&v31[1].__r_.__value_.__r.__words[2] = v11;
    std::string::operator=((std::string *)&v32, (const std::string *)(v6 + 128));
    DWORD2(v33) = *(_DWORD *)(v6 + 152);
    std::string::operator=((std::string *)v34, (const std::string *)(v6 + 160));
    long long v14 = *(_OWORD *)(v6 + 184);
    *(_OWORD *)&v34[33] = *(_OWORD *)(v6 + 193);
    *(_OWORD *)&unsigned char v34[24] = v14;
    std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<unsigned int>,false> const&>((uint64_t)&v34[56], v6 + 216);
    long long v15 = *(_OWORD *)(v6 + 248);
    v34[104] = *(unsigned char *)(v6 + 264);
    *(_OWORD *)&v34[88] = v15;
    std::string::operator=(v35, (const std::string *)(v6 + 272));
    std::string::operator=(&v35[1], (const std::string *)(v6 + 296));
    long long v16 = *(_OWORD *)(v6 + 352);
    long long v17 = *(_OWORD *)(v6 + 368);
    long long v18 = *(_OWORD *)(v6 + 384);
    *(void *)&v40[13] = *(void *)(v6 + 397);
    long long v19 = *(_OWORD *)(v6 + 336);
    long long v36 = *(_OWORD *)(v6 + 320);
    long long v37 = v19;
    long long v39 = v17;
    *(_OWORD *)uint64_t v40 = v18;
    long long v38 = v16;
  }
LABEL_9:
  uint64_t v20 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), a3);
  uint64_t v28 = 0;
  long long v29 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v28, a1, a3);
  uint64_t v21 = v28;
  uint64_t v22 = *v20;
  if (v28)
  {
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = CSIBOOLAsString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v23;
      _os_log_impl(&dword_22231A000, v22, OS_LOG_TYPE_DEFAULT, "#I Setting voice privacy to %s", buf, 0xCu);
    }
    *(_OWORD *)long long buf = 0u;
    memset(v45, 0, sizeof(v45));
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v21 + 120))(buf, v21, a2, a3);
    uint64_t v25 = *(void *)buf;
    long long v24 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v24);
    }
    if (v25)
    {
      if ((a3 - 1) >= 3) {
        int v26 = 0;
      }
      else {
        int v26 = a3;
      }
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(&v27, v26);
    }
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v45);
    if (*(void *)&buf[8]) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
    }
  }
  else if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl(&dword_22231A000, v22, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in enableVoicePrivacy", buf, 2u);
  }
  if (v29) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v29);
  }
  CallInfo::~CallInfo((void **)v30);
  *(void *)&v30[0] = &v41;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)v30);
}

void sub_2224DEC80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, void *a13)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  CallInfo::~CallInfo(&a13);
  a13 = (void *)(v13 - 200);
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::reportDisconnectStats(EurekaCallCommandDriver *this, const CallInfo *a2)
{
  uint64_t v2 = *((void *)this + 40);
  if (!v2) {
    goto LABEL_11;
  }
  int v3 = *((_DWORD *)a2 + 63);
  uint64_t v4 = (_DWORD *)((char *)this + 320);
  do
  {
    int v5 = *(_DWORD *)(v2 + 28);
    BOOL v6 = v5 < v3;
    if (v5 >= v3) {
      unsigned int v7 = (uint64_t *)v2;
    }
    else {
      unsigned int v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = (_DWORD *)v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 != (_DWORD *)((char *)this + 320) && v3 >= v4[7]) {
    uint64_t v8 = v4[8];
  }
  else {
LABEL_11:
  }
    uint64_t v8 = 11;
  return (*(uint64_t (**)(void, const CallInfo *, uint64_t))(**((void **)this + 15) + 344))(*((void *)this + 15), a2, v8);
}

void EurekaCallCommandDriver::resetCallRelatedState(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112));
  int v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Resetting call related state!", buf, 2u);
  }
  EurekaCallCommandDriver::resetCallCapabilities(a1, a2);
  if (*(unsigned char *)(a1 + 184))
  {
    BOOL v6 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#I Call ended somehow, there is a busy tone being played. Ending it.", buf, 2u);
    }
    *(void *)long long buf = 0;
    uint64_t v10 = 0;
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 120) + 288))(buf);
    if (*(void *)buf)
    {
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 120) + 288))(&v7);
      (*(void (**)(uint64_t))(*(void *)v7 + 48))(v7);
      if (v8) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v8);
      }
    }
    *(unsigned char *)(a1 + 184) = 0;
    if (v10) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v10);
    }
  }
}

void sub_2224DEF44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void EurekaCallCommandDriver::resetCallCapabilities(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112));
  int v5 = *(uint64_t **)(a1 + 232);
  BOOL v6 = (uint64_t *)(a1 + 240);
  if (v5 != (uint64_t *)(a1 + 240))
  {
    do
    {
      uint64_t v7 = v5[7];
      if (v7)
      {
        (*(void (**)(uint64_t))(*(void *)v7 + 16))(v7);
        uint64_t v8 = v5[7];
        v5[7] = 0;
        if (v8) {
          (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
        }
      }
      int v9 = (uint64_t *)v5[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          int v9 = (uint64_t *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (uint64_t *)v5[2];
          BOOL v11 = *v10 == (void)v5;
          int v5 = v10;
        }
        while (!v11);
      }
      int v5 = v10;
    }
    while (v10 != v6);
    int v5 = *(uint64_t **)(a1 + 232);
  }
  if (v5 != v6)
  {
    do
    {
      long long v12 = std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::__remove_node_pointer((uint64_t **)(a1 + 232), v5);
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<ctu::Timer>>,0>((uint64_t)(v5 + 4));
      operator delete(v5);
      int v5 = v12;
    }
    while (v6 != v12);
  }
  uint64_t v15 = 0;
  long long v16 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v15, a1, a2);
  if (v15)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 136))(v15, a2);
  }
  else
  {
    uint64_t v13 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      v14[0] = 0;
      _os_log_error_impl(&dword_22231A000, v13, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL. Can't reset all call capabilities.", (uint8_t *)v14, 2u);
    }
  }
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
}

void sub_2224DF154(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN23EurekaCallCommandDriver17setCallCapabilityEPKcbbN10subscriber7SimSlotE_block_invoke(uint64_t a1)
{
  return EurekaCallCommandDriver::handleSetCallCapabilityTimerExpired(*(void ***)(a1 + 32), *(char **)(a1 + 40), *(unsigned char *)(a1 + 52), *(unsigned int *)(a1 + 48));
}

uint64_t EurekaCallCommandDriver::handleSetCallCapabilityTimerExpired(void **a1, char *a2, char a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[14] + 16))(a1[14], a4);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#I Call Capabilities, %s, timer exipred!", buf, 0xCu);
  }
  std::string::basic_string[abi:ne180100]<0>(buf, a2);
  uint64_t v13 = buf;
  int v9 = std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1 + 29, (void **)buf, &v13);
  uint64_t v10 = v9[7];
  v9[7] = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  if (v15 < 0)
  {
    operator delete(*(void **)buf);
    if (a3) {
      goto LABEL_7;
    }
LABEL_10:
    int v12 = 0;
    goto LABEL_11;
  }
  if ((a3 & 1) == 0) {
    goto LABEL_10;
  }
LABEL_7:
  uint64_t result = EurekaCallCommandDriver::findCallCapability((uint64_t)a1, (unint64_t)a2, a4);
  if (result) {
    return result;
  }
  int v12 = 1;
LABEL_11:
  EurekaCallCommandDriver::setCallCapability((uint64_t)a1, (unint64_t)a2, v12, a4);
  return (*(uint64_t (**)(void *, uint64_t))(*a1[15] + 192))(a1[15], a4);
}

void sub_2224DF334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void EurekaCallCommandDriver::startOTASP(EurekaCallCommandDriver *this)
{
  uint64_t v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I User requseted to start a non-visual OTASP!", buf, 2u);
  }
  uint64_t v3 = *((void *)this + 27);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 18);
  uint64_t v5 = *((void *)this + 17);
  BOOL v6 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v3 + 40))(v3, &v5, 1);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

void sub_2224DF410(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void EurekaCallCommandDriver::sendDTMFDigits(EurekaCallCommandDriver *a1, uint64_t a2, int *a3)
{
  (*(void (**)(void *, void))(**((void **)a1 + 14) + 16))(*((void **)a1 + 14), a3[63]);
  if (EurekaCallCommandDriver::findCallCapability((uint64_t)a1, *MEMORY[0x263F037D0], a3[63])) {
    EurekaCallCommandDriver::sendVoiceBurstDtmfReq((uint64_t)a1, a2, (uint64_t)a3);
  }
  if (*(void *)a2 != *(void *)(a2 + 8)) {
    EurekaCallCommandDriver::sendStartContDtmfReq(a1, **(unsigned char **)a2, (const CallInfo *)a3);
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**((void **)a1 + 15) + 288))(&v6);
  if (v6) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 56))(v6, a2, 1);
  }
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
}

void sub_2224DF564(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void EurekaCallCommandDriver::sendVoiceBurstDtmfReq(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(void, void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), *(unsigned int *)(a3 + 252));
  *(_OWORD *)std::string __p = 0u;
  long long v9 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 0x40000000;
  _OWORD v7[2] = ___ZN23EurekaCallCommandDriver21sendVoiceBurstDtmfReqERKNSt3__16vectorIhNS0_9allocatorIhEEEERK8CallInfo_block_invoke;
  v7[3] = &__block_descriptor_tmp_98_3;
  v7[4] = a3;
  void v7[5] = a2;
  uint64_t v5 = (const void **)__p[1];
  if (__p[1] != (void *)v9)
  {
    while (*((unsigned char *)*v5 + 8) != 1)
    {
      if (++v5 == (const void **)v9) {
        goto LABEL_8;
      }
    }
  }
  if (v5 != (const void **)v9)
  {
    if (v6)
    {
      ___ZN23EurekaCallCommandDriver21sendVoiceBurstDtmfReqERKNSt3__16vectorIhNS0_9allocatorIhEEEERK8CallInfo_block_invoke(v7, v6 + 16);
      qmi::ClientRouter::get();
      operator new();
    }
    __cxa_bad_cast();
  }
LABEL_8:
  operator new();
}

void sub_2224DF978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  if (a27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a27);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v28);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v27, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a17);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::sendStartContDtmfReq(EurekaCallCommandDriver *this, char a2, const CallInfo *a3)
{
  (*(void (**)(void, void))(**((void **)this + 14) + 16))(*((void *)this + 14), *((unsigned int *)a3 + 63));
  *(_OWORD *)std::string __p = 0u;
  long long v10 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 0x40000000;
  _OWORD v7[2] = ___ZN23EurekaCallCommandDriver20sendStartContDtmfReqEhRK8CallInfo_block_invoke;
  v7[3] = &__block_descriptor_tmp_100_2;
  v7[4] = a3;
  char v8 = a2;
  uint64_t v5 = (const void **)__p[1];
  if (__p[1] != (void *)v10)
  {
    while (*((unsigned char *)*v5 + 8) != 1)
    {
      if (++v5 == (const void **)v10) {
        goto LABEL_8;
      }
    }
  }
  if (v5 != (const void **)v10)
  {
    if (v6)
    {
      ___ZN23EurekaCallCommandDriver20sendStartContDtmfReqEhRK8CallInfo_block_invoke((uint64_t)v7, v6 + 9);
      qmi::ClientRouter::get();
      operator new();
    }
    __cxa_bad_cast();
  }
LABEL_8:
  operator new();
}

void sub_2224DFDE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  if (a27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a27);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v28);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v27, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a17);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::sendStopContDtmfReq(EurekaCallCommandDriver *this, const CallInfo *a2)
{
  (*(void (**)(void, void))(**((void **)this + 14) + 16))(*((void *)this + 14), *((unsigned int *)a2 + 63));
  memset(v5, 0, sizeof(v5));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v5);
  v4[0] = MEMORY[0x263EF8330];
  v4[1] = 0x40000000;
  void v4[2] = ___ZN23EurekaCallCommandDriver19sendStopContDtmfReqERK8CallInfo_block_invoke;
  v4[3] = &__block_descriptor_tmp_101_0;
  v4[4] = a2;
  uint64_t v3 = qmi::MutableMessageBase::getTLV<vs::tlv::CallIdentifier>((uint64_t)v5, 1);
  ___ZN23EurekaCallCommandDriver19sendStopContDtmfReqERK8CallInfo_block_invoke((uint64_t)v4, v3);
  qmi::ClientRouter::get();
  operator new();
}

void sub_2224E00B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  if (a27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a27);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v28);
  if (a11) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v27, a11);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a17);
  _Unwind_Resume(a1);
}

void *___ZN23EurekaCallCommandDriver21sendVoiceBurstDtmfReqERKNSt3__16vectorIhNS0_9allocatorIhEEEERK8CallInfo_block_invoke(void *result, unsigned char *a2)
{
  uint64_t v2 = (char **)result[5];
  *a2 = *(_DWORD *)(result[4] + 92);
  uint64_t v3 = (char **)(a2 + 8);
  if (v3 != v2) {
    return std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v3, *v2, v2[1], v2[1] - *v2);
  }
  return result;
}

uint64_t ___ZN23EurekaCallCommandDriver20sendStartContDtmfReqEhRK8CallInfo_block_invoke(uint64_t result, unsigned char *a2)
{
  *a2 = *(_DWORD *)(*(void *)(result + 32) + 92);
  a2[1] = *(unsigned char *)(result + 40);
  return result;
}

uint64_t ___ZN23EurekaCallCommandDriver19sendStopContDtmfReqERK8CallInfo_block_invoke(uint64_t result, unsigned char *a2)
{
  *a2 = *(_DWORD *)(*(void *)(result + 32) + 92);
  return result;
}

void EurekaCallCommandDriver::startDTMFTone(EurekaCallCommandDriver *a1, int a2, int *a3, int a4)
{
  __p[3] = *(void **)MEMORY[0x263EF8340];
  char v8 = *(NSObject **)(*(uint64_t (**)(void *, void))(**((void **)a1 + 14) + 16))(*((void **)a1 + 14), a3[63]);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(__p[0]) = 67109120;
    HIDWORD(__p[0]) = a2;
    _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#I Sending single DTMF char = %d", (uint8_t *)__p, 8u);
  }
  int v9 = EurekaCallCommandDriver::findCallCapability((uint64_t)a1, *MEMORY[0x263F037D0], a3[63]);
  if (!a4)
  {
    if (v9)
    {
      long long v10 = operator new(1uLL);
      *long long v10 = a2;
      __p[0] = v10;
      __p[2] = v10 + 1;
      __p[1] = v10 + 1;
      EurekaCallCommandDriver::sendVoiceBurstDtmfReq((uint64_t)a1, (uint64_t)__p, (uint64_t)a3);
    }
  }
  EurekaCallCommandDriver::sendStartContDtmfReq(a1, a2, (const CallInfo *)a3);
}

void sub_2224E02E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t EurekaCallCommandDriver::stopDTMFTone(EurekaCallCommandDriver *a1, const CallInfo *a2, int a3)
{
  unsigned int v6 = *((_DWORD *)a2 + 63);
  uint64_t v7 = (NSObject **)(*(uint64_t (**)(void *, void))(**((void **)a1 + 14) + 16))(*((void **)a1 + 14), v6);
  uint64_t result = EurekaCallCommandDriver::findCallCapability((uint64_t)a1, *MEMORY[0x263F037D0], v6);
  if (a3 || !result)
  {
    int v9 = *v7;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v10 = 0;
      _os_log_impl(&dword_22231A000, v9, OS_LOG_TYPE_DEFAULT, "#I Stop DTMF", v10, 2u);
    }
    EurekaCallCommandDriver::sendStopContDtmfReq(a1, a2);
  }
  return result;
}

uint64_t EurekaCallCommandDriver::isMMIUSSDSupported(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112));
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  unsigned int v6 = ServiceMap;
  unint64_t v7 = *(void *)(MEMORY[0x263F03568] + 8);
  if ((v7 & 0x8000000000000000) != 0)
  {
    char v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v19 = v7;
  BOOL v11 = std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<void>>>>::find<unsigned long>(&v6[1].__m_.__sig, &v19);
  if (v11)
  {
    uint64_t v13 = v11[3];
    int v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  int v12 = 0;
  char v14 = 1;
LABEL_9:
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v13 + 408))(v13, a2);
  if ((v14 & 1) == 0) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  if ((v15 & 1) == 0)
  {
    uint64_t v16 = *v4;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v18 = 0;
      _os_log_impl(&dword_22231A000, v16, OS_LOG_TYPE_DEFAULT, "#I We are CDMA technology; USSD is not supported",
        v18,
        2u);
    }
  }
  return v15;
}

void sub_2224E0570(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t EurekaCallCommandDriver::isUSSDFeatureSupportedByDriver()
{
  return 1;
}

uint64_t EurekaCallCommandDriver::supportsCallSwapWhenMax(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v4, a1, a2);
  if (v4) {
    uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 160))(v4);
  }
  else {
    uint64_t v2 = 0;
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return v2;
}

void sub_2224E0614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void EurekaCallCommandDriver::dumpState(NSObject **this)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  CallCommandDriver::dumpState((CallCommandDriver *)this);
  uint64_t v2 = this[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = CSIBOOLAsString();
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I In ECBM Mode: %s", (uint8_t *)&buf, 0xCu);
  }
  subscriber::makeSimSlotRange();
  uint64_t v3 = (unsigned int *)*((void *)&buf + 1);
  uint64_t v4 = (unsigned int *)buf;
  if ((void)buf != *((void *)&buf + 1))
  {
    uint64_t v5 = v40;
    while ((v5(*v4) & 1) == 0)
    {
      if (++v4 == v3)
      {
        uint64_t v4 = v3;
        break;
      }
    }
    long long v30 = (unsigned int *)*((void *)&buf + 1);
    if (v4 != *((unsigned int **)&buf + 1))
    {
      unsigned int v6 = (char **)(this + 36);
      do
      {
        uint64_t v7 = *v4;
        char v8 = (os_log_t *)(*((uint64_t (**)(NSObject *, uint64_t))this[14]->isa + 2))(this[14], v7);
        uint64_t v31 = 0;
        long long v32 = 0;
        EurekaCallCommandDriver::getPreferredFormatterForSim(&v31, (uint64_t)this, v7);
        uint64_t v9 = v31;
        os_log_t v10 = *v8;
        BOOL v11 = os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT);
        if (v9)
        {
          if (v11)
          {
            uint64_t v12 = *(void *)(v9 + 48);
            LODWORD(v37) = 136315138;
            *(void *)((char *)&v37 + 4) = v12;
            uint64_t v13 = v10;
            char v14 = "#I Preferred Formatter: %s";
            uint32_t v15 = 12;
LABEL_15:
            _os_log_impl(&dword_22231A000, v13, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v37, v15);
          }
        }
        else if (v11)
        {
          LOWORD(v37) = 0;
          uint64_t v13 = v10;
          char v14 = "#I Preferred Formatter is NULL";
          uint32_t v15 = 2;
          goto LABEL_15;
        }
        uint64_t v16 = *v6;
        if (*v6)
        {
          long long v17 = (char **)(this + 36);
          do
          {
            int v18 = *((_DWORD *)v16 + 8);
            BOOL v19 = v18 < (int)v7;
            if (v18 >= (int)v7) {
              uint64_t v20 = (char **)v16;
            }
            else {
              uint64_t v20 = (char **)(v16 + 8);
            }
            if (!v19) {
              long long v17 = (char **)v16;
            }
            uint64_t v16 = *v20;
          }
          while (*v20);
          if (v17 != v6 && (int)v7 >= *((_DWORD *)v17 + 8))
          {
            long long v37 = 0uLL;
            uint64_t v38 = 0;
            std::map<char const*,int>::map[abi:ne180100]((uint64_t)&v37, v17 + 5);
            uint64_t v21 = *v8;
            if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long v33 = 0;
              _os_log_impl(&dword_22231A000, v21, OS_LOG_TYPE_DEFAULT, "#I Call Capabilities:", v33, 2u);
            }
            uint64_t v22 = (_OWORD *)v37;
            if ((long long *)v37 != (long long *)((char *)&v37 + 8))
            {
              do
              {
                uint64_t v23 = *v8;
                if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
                {
                  int v24 = *((_DWORD *)v22 + 10);
                  uint64_t v25 = *((void *)v22 + 4);
                  *(_DWORD *)long long v33 = 136315394;
                  uint64_t v34 = v25;
                  __int16 v35 = 1024;
                  int v36 = v24;
                  _os_log_impl(&dword_22231A000, v23, OS_LOG_TYPE_DEFAULT, "#I \t%s = %d", v33, 0x12u);
                }
                int v26 = (void *)*((void *)v22 + 1);
                if (v26)
                {
                  do
                  {
                    uint64_t v27 = v26;
                    int v26 = (void *)*v26;
                  }
                  while (v26);
                }
                else
                {
                  do
                  {
                    uint64_t v27 = (_OWORD *)*((void *)v22 + 2);
                    BOOL v28 = *(void *)v27 == (void)v22;
                    uint64_t v22 = v27;
                  }
                  while (!v28);
                }
                uint64_t v22 = v27;
              }
              while (v27 != (long long *)((char *)&v37 + 8));
            }
            std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy((uint64_t)&v37, *((void **)&v37 + 1));
          }
        }
        if (v32) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v32);
        }
        long long v29 = v4 + 1;
        uint64_t v4 = v3;
        if (v29 != v3)
        {
          uint64_t v4 = v29;
          while ((v5(*v4) & 1) == 0)
          {
            if (++v4 == v3)
            {
              uint64_t v4 = v3;
              break;
            }
          }
        }
      }
      while (v4 != v30);
    }
  }
}

void sub_2224E09A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t EurekaCallCommandDriver::start(EurekaCallCommandDriver *this)
{
  qmi::ClientRouter::start();
  qmi::ClientRouter::start();

  return qmi::ClientRouter::start();
}

void EurekaCallCommandDriver::bootstrap(NSObject *a1, NSObject **a2)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a2;
  group = *a2;
  if (*a2)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  CallCommandDriver::bootstrap();
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  isa = a1[5].isa;
  if (os_log_type_enabled(isa, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, isa, OS_LOG_TYPE_DEFAULT, "#I Eureka base class registering for QMI indications", buf, 2u);
  }
  __p[0] = &unk_26D4D1360;
  __p[1] = a1;
  *((void *)&v30 + 1) = __p;
  qmi::ClientRouter::setHandler();
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](__p);
  uint64_t aBlock = &unk_26D4D13E0;
  uint64_t v23 = (uint64_t)a1;
  p_uint64_t aBlock = &aBlock;
  qmi::ClientRouter::setHandler();
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](&aBlock);
  uint64_t v31 = (uint64_t (**)(int, int))&unk_26D4D1460;
  v32[0] = a1;
  v32[2] = &v31;
  qmi::ClientRouter::setHandler();
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](&v31);
  BOOL v19 = &unk_26D4D14E0;
  uint64_t v20 = a1;
  uint64_t v21 = &v19;
  qmi::ClientRouter::setHandler();
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](&v19);
  uint64_t v16 = &unk_26D4D1560;
  long long v17 = a1;
  int v18 = &v16;
  qmi::ClientRouter::setHandler();
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](&v16);
  *(void *)long long buf = &unk_26D4D15E0;
  *(void *)&uint8_t buf[8] = a1;
  *((void *)&v34 + 1) = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](buf);
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)&a1[17]);
  *(void *)long long buf = &unk_26D4D1660;
  *(void *)&uint8_t buf[8] = a1;
  *((void *)&v34 + 1) = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](buf);
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)&a1[17]);
  *(void *)long long buf = &unk_26D4D16E0;
  *(void *)&uint8_t buf[8] = a1;
  *((void *)&v34 + 1) = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](buf);
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)&a1[17]);
  *(void *)long long buf = &unk_26D4D1760;
  *(void *)&uint8_t buf[8] = a1;
  *((void *)&v34 + 1) = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](buf);
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)&a1[17]);
  *(void *)long long buf = &unk_26D4D17E0;
  *(void *)&uint8_t buf[8] = a1;
  *((void *)&v34 + 1) = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](buf);
  *(void *)long long buf = &unk_26D4D1860;
  *(void *)&uint8_t buf[8] = a1;
  *((void *)&v34 + 1) = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](buf);
  *(void *)long long buf = &unk_26D4D18E0;
  *(void *)&uint8_t buf[8] = a1;
  *((void *)&v34 + 1) = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](buf);
  *(void *)long long buf = &unk_26D4D1960;
  *(void *)&uint8_t buf[8] = a1;
  *((void *)&v34 + 1) = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](buf);
  uint64_t aBlock = (void *)MEMORY[0x263EF8330];
  uint64_t v23 = 0x40000000;
  int v24 = ___ZN3ctu20SharedSynchronizableI17CallCommandDriverE13connect_eventIN5event11EventLoggerIFvvENS4_14CSIEventLoggerEEE23EurekaCallCommandDrivervJEEEDTcl7connectfp_cvNSt3__110shared_ptrIS1_EE_EcvP16dispatch_queue_s_EcvPFT1_DpT2_ELi0EEERT_MT0_FSF_SH_E_block_invoke;
  p_uint64_t aBlock = (void **)&__block_descriptor_tmp_235_0;
  int v26 = a1 + 1;
  uint64_t v27 = EurekaCallCommandDriver::handleNotRegistered;
  uint64_t v28 = 0;
  uint64_t v5 = _Block_copy(&aBlock);
  unsigned int v6 = (std::__shared_weak_count *)a1[2].isa;
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      char v8 = v7;
      uint64_t v9 = a1[3].isa;
      if (v5) {
        os_log_t v10 = _Block_copy(v5);
      }
      else {
        os_log_t v10 = 0;
      }
      dispatch_retain(v9);
      *(_OWORD *)std::string __p = 0u;
      long long v30 = 0u;
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot(v12, v9, v10);
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot(v13, v12[0], v12[1]);
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot(v14, v13[0], v13[1]);
      uint64_t v31 = 0;
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot(v15, v14[0], v14[1]);
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot(&v16, v15[0], v15[1]);
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot(&v19, v16, v17);
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot((NSObject **)buf, v19, v20);
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot(v32, *(NSObject **)buf, *(void **)&buf[8]);
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)buf);
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)&v19);
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)&v16);
      uint64_t v31 = &boost::function0<void>::assign_to<ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>>(ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>)::stored_vtable;
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)v15);
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)v14);
      *(_OWORD *)long long buf = 0u;
      long long v34 = 0u;
      boost::function0<void>::move_assign((uint64_t)buf, (uint64_t *)&v31);
      boost::function0<void>::move_assign((uint64_t)&v31, (uint64_t *)&v30 + 1);
      boost::function0<void>::move_assign((uint64_t)&v30 + 8, (uint64_t *)buf);
      boost::function0<void>::~function0((uint64_t *)buf);
      boost::function0<void>::~function0((uint64_t *)&v31);
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)v13);
      ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)v12);
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void sub_2224E1E30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  if (a2)
  {
    a55 = v59;
    std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a55);
    MEMORY[0x223C9A950](v59, 0x10E2C40015BD3E7);
    *(void *)uint64_t v60 = &unk_26D4D1BD8;
    boost::detail::weak_count::~weak_count((atomic_uint **)(v60 + 16));
    MEMORY[0x223C9A950](v60, 0x10A1C4004CC96CELL);
    boost::signals2::detail::garbage_collecting_lock<boost::signals2::mutex>::~garbage_collecting_lock((uint64_t)&a59);
    boost::signals2::slot<void ()(void),boost::function<void ()(void)>>::~slot((uint64_t)&a47);
    ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)&a22);
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_2224E1E40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  if (a2)
  {
    std::__split_buffer<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::~__split_buffer((uint64_t)&a59);
    boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content((uint64_t)&a55);
    if (a36) {
      (*(void (**)(uint64_t))(*(void *)a36 + 8))(a36);
    }
    std::__shared_weak_count::__release_weak(a16);
    JUMPOUT(0x2224E2270);
  }
  _Unwind_Resume(a1);
}

void sub_2224E1E4C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x2224E211CLL);
}

void sub_2224E1E64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    boost::checked_delete<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>(a13);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_2224E1E84(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    boost::detail::shared_count::~shared_count(v2);
    JUMPOUT(0x2224E2268);
  }
  _Unwind_Resume(a1);
}

void sub_2224E1E9C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    boost::checked_delete<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_2224E1EBC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    boost::detail::shared_count::~shared_count(v2);
    JUMPOUT(0x2224E2264);
  }
  _Unwind_Resume(a1);
}

void sub_2224E1ED8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x2224E2264);
}

void sub_2224E1EE4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x2224E211CLL);
}

void sub_2224E1EF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62)
{
  if (a52 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_2224E1F20(_Unwind_Exception *a1)
{
  boost::detail::weak_count::~weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_2224E1F38(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_2224E1F78(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    JUMPOUT(0x2224E2168);
  }
  _Unwind_Resume(a1);
}

void sub_2224E1F8C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    boost::checked_delete<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_2224E1FAC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    boost::detail::shared_count::~shared_count(v2);
    JUMPOUT(0x2224E21B4);
  }
  _Unwind_Resume(a1);
}

void sub_2224E1FC8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x2224E21B4);
}

void sub_2224E1FD4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x2224E2270);
}

void sub_2224E1FE0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x2224E2124);
}

void sub_2224E1FEC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x2224E2150);
}

void sub_2224E1FFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59)
{
}

void sub_2224E2028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
}

void sub_2224E2068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(a1);
}

void sub_2224E2088(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55)
{
  if (a2)
  {
    std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100](&a55);
    MEMORY[0x223C9A950](v55, 0x10E2C40015BD3E7);
    *int v56 = &unk_26D4D1BD8;
    boost::detail::weak_count::~weak_count((boost::detail::weak_count *)(v56 + 2));
    JUMPOUT(0x2224E2264);
  }
  _Unwind_Resume(a1);
}

void sub_2224E209C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void **a59)
{
  if (a2)
  {
    boost::function0<void>::~function0((uint64_t *)&a59);
    boost::function0<void>::~function0(&a55);
    ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)&a26);
    ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)&a24);
    boost::function0<void>::~function0(v59);
    a59 = (void **)&a47;
    std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100](&a59);
    JUMPOUT(0x2224E2278);
  }
  _Unwind_Resume(a1);
}

void sub_2224E20E4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  std::__list_imp<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>::clear(v2);
  MEMORY[0x223C9A950](v2, 0x1020C40A2524F59);
  JUMPOUT(0x2224E2250);
}

void sub_2224E20F0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59)
{
  if (a2)
  {
    if (v60 != -24)
    {
      uint64_t v61 = v60 + 24;
      do
      {
        boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content(v59 + v61);
        v61 += 24;
      }
      while (v61);
    }
    std::__split_buffer<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::~__split_buffer((uint64_t)&a59);
    boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content((uint64_t)&a55);
    if (a36) {
      (*(void (**)(uint64_t))(*(void *)a36 + 8))(a36);
    }
    std::__shared_weak_count::__release_weak(a16);
    JUMPOUT(0x2224E2270);
  }
  _Unwind_Resume(a1);
}

void sub_2224E215C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x2224E2164);
  }
  _Unwind_Resume(a1);
}

void sub_2224E2170(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    for (; v2; v2 -= 24)
      boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content(v3 - 24 + v2);
    *(void *)(v4 + 8) = v3;
    JUMPOUT(0x2224E2194);
  }
  _Unwind_Resume(a1);
}

void sub_2224E21F4(_Unwind_Exception *a1)
{
}

void sub_2224E2200(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x2224E2268);
}

void sub_2224E220C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x2224E2280);
}

void sub_2224E2218(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x2224E2220);
  }
  std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*v2);
  JUMPOUT(0x2224E2230);
}

uint64_t EurekaCallCommandDriver::shutdown(uint64_t a1, NSObject **a2)
{
  uint64_t v3 = *a2;
  group = *a2;
  if (*a2)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  CallCommandDriver::shutdown();
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  for (uint64_t i = *(void **)(a1 + 344); i != (void *)(a1 + 336); uint64_t i = (void *)i[1])
  {
    uint64_t v5 = (atomic_uint *)i[3];
    uint64_t v12 = v5;
    if (v5)
    {
      uint64_t v6 = v5[2];
      do
      {
        if (!v6)
        {
          uint64_t v12 = 0;
          goto LABEL_15;
        }
        uint64_t v7 = v6;
        atomic_compare_exchange_strong_explicit(v5 + 2, (unsigned int *)&v7, v6 + 1, memory_order_relaxed, memory_order_relaxed);
        BOOL v8 = v7 == v6;
        uint64_t v6 = v7;
      }
      while (!v8);
      uint64_t v9 = (boost::signals2::detail::connection_body_base *)i[2];
      if (v9) {
        boost::signals2::detail::connection_body_base::disconnect(v9);
      }
    }
LABEL_15:
    boost::detail::shared_count::~shared_count(&v12);
  }
  std::__list_imp<boost::signals2::connection>::clear((atomic_uint **)(a1 + 336));
  qmi::ClientRouter::stop();
  qmi::ClientRouter::stop();
  return qmi::ClientRouter::stop();
}

void sub_2224E2398(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

void EurekaCallCommandDriver::updateWifiCallStatus(uint64_t a1, int *a2, uint64_t a3, int a4)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), a3);
  if (capabilities::ct::shouldSendWiFiCallStatus((capabilities::ct *)v6))
  {
    *(_OWORD *)std::string __p = 0u;
    long long v19 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v16[0] = MEMORY[0x263EF8330];
    v16[1] = 0x40000000;
    unint64_t v16[2] = ___ZNK23EurekaCallCommandDriver20updateWifiCallStatusERK9CallStateN10subscriber7SimSlotEb_block_invoke;
    _OWORD v16[3] = &__block_descriptor_tmp_103_3;
    char v17 = a4;
    uint64_t v7 = (const void **)__p[1];
    if (__p[1] != (void *)v19)
    {
      while (*((unsigned char *)*v7 + 8) != 16)
      {
        if (++v7 == (const void **)v19) {
          goto LABEL_11;
        }
      }
    }
    if (v7 != (const void **)v19)
    {
      if (v9)
      {
        ___ZNK23EurekaCallCommandDriver20updateWifiCallStatusERK9CallStateN10subscriber7SimSlotEb_block_invoke((uint64_t)v16, v9 + 9);
        v15[0] = MEMORY[0x263EF8330];
        v15[1] = 0x40000000;
        _OWORD v15[2] = ___ZNK23EurekaCallCommandDriver20updateWifiCallStatusERK9CallStateN10subscriber7SimSlotEb_block_invoke_2;
        v15[3] = &__block_descriptor_tmp_105_2;
        void v15[4] = a2;
        os_log_t v10 = (const void **)__p[1];
        if (__p[1] != (void *)v19)
        {
          while (*((unsigned char *)*v10 + 8) != 17)
          {
            if (++v10 == (const void **)v19) {
              goto LABEL_19;
            }
          }
        }
        if (v10 == (const void **)v19) {
LABEL_19:
        }
          operator new();
        if (v11)
        {
          ___ZNK23EurekaCallCommandDriver20updateWifiCallStatusERK9CallStateN10subscriber7SimSlotEb_block_invoke_2((uint64_t)v15, v11 + 9);
          uint64_t v12 = *v6;
          if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
          {
            int v14 = *a2;
            *(_DWORD *)long long buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v14;
            __int16 v21 = 1024;
            int v22 = a4;
            _os_log_impl(&dword_22231A000, v12, OS_LOG_TYPE_DEFAULT, "#I Sending wifi call status to BB: status: %d isWifiSupported: %d", buf, 0xEu);
          }
          qmi::ClientRouter::get();
          operator new();
        }
      }
      __cxa_bad_cast();
    }
LABEL_11:
    operator new();
  }
  BOOL v8 = *v6;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl(&dword_22231A000, v8, OS_LOG_TYPE_ERROR, "Failed to send wifi call status to BB as fNASClient is not ready! Returning.", buf, 2u);
  }
}

void sub_2224E2A44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  char v17 = *(std::__shared_weak_count **)(v15 - 120);
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  if (a3) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v13, a3);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK23EurekaCallCommandDriver20updateWifiCallStatusERK9CallStateN10subscriber7SimSlotEb_block_invoke(uint64_t result, unsigned char *a2)
{
  *a2 = *(unsigned char *)(result + 32);
  return result;
}

uint64_t ___ZNK23EurekaCallCommandDriver20updateWifiCallStatusERK9CallStateN10subscriber7SimSlotEb_block_invoke_2(uint64_t result, BOOL *a2)
{
  *a2 = **(_DWORD **)(result + 32) == 0;
  return result;
}

void EurekaCallCommandDriver::sendImsCallStatusToBaseband(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  if ((a2 - 3) < 2)
  {
    int v10 = 1;
LABEL_8:
    int v8 = 1;
    int v9 = 1;
    goto LABEL_9;
  }
  if (a2 == 1)
  {
    int v10 = 0;
    goto LABEL_8;
  }
  int v8 = 0;
  int v9 = 0;
  int v10 = 0;
  if (a2 == 2)
  {
    BOOL v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      uint64_t v12 = "#N *** IMS call state notification to BB: Dropping the request for %s as it is not supported.";
      uint64_t v13 = v11;
      uint32_t v14 = 12;
LABEL_13:
      _os_log_impl(&dword_22231A000, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
      return;
    }
    return;
  }
LABEL_9:
  uint64_t v15 = (capabilities::ct *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), a3);
  int v16 = capabilities::ct::supports5G(v15);
  if ((v10 & 1) != 0 || !v16)
  {
    int v48 = v9;
    char v47 = a5;
    uint64_t v57 = 0;
    uint64_t v58 = 0;
    uint64_t v59 = 0;
    PersonalityIdFromSlotId();
    uint64_t v55 = 0;
    int v56 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    long long v19 = ServiceMap;
    uint64_t v20 = *(void *)(MEMORY[0x263F03610] + 8);
    if (v20 < 0)
    {
      __int16 v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v22 = 5381;
      do
      {
        uint64_t v20 = v22;
        unsigned int v23 = *v21++;
        uint64_t v22 = (33 * v22) ^ v23;
      }
      while (v23);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v20;
    int v24 = std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<void>>>>::find<unsigned long>(&v19[1].__m_.__sig, (unint64_t *)buf);
    if (v24)
    {
      uint64_t v26 = v24[3];
      uint64_t v25 = (std::__shared_weak_count *)v24[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v19);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::__shared_weak_count::__release_shared[abi:ne180100](v25);
        char v27 = 0;
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    std::mutex::unlock(v19);
    uint64_t v25 = 0;
    char v27 = 1;
LABEL_22:
    (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(void *)v26 + 40))(&v55, v26, &v57);
    if ((v27 & 1) == 0) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v25);
    }
    if (v55 && (*(unsigned int (**)(uint64_t))(*(void *)v55 + 216))(v55))
    {
      uint64_t v28 = *(NSObject **)v15;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        long long v29 = nas::asString(v48);
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v29;
        _os_log_impl(&dword_22231A000, v28, OS_LOG_TYPE_DEFAULT, "#I Active pseudo-VoLTE call. Not sending IMS call state notification to BB: %s", buf, 0xCu);
      }
      if (v56) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v56);
      }
      if (SHIBYTE(v59) < 0) {
        operator delete(v57);
      }
      return;
    }
    long long v30 = *(NSObject **)v15;
    if (os_log_type_enabled(*(os_log_t *)v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v31 = HIBYTE(v59);
      if (v59 < 0) {
        uint64_t v31 = v58;
      }
      long long v32 = (const char *)&v57;
      if (v59 < 0) {
        long long v32 = (const char *)v57;
      }
      if (v31) {
        long long v33 = v32;
      }
      else {
        long long v33 = "<invalid>";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v33;
      _os_log_impl(&dword_22231A000, v30, OS_LOG_TYPE_DEFAULT, "#I IMS config is not found or IMS status update to baseband is not blocked for personalityId: %s!", buf, 0xCu);
      long long v30 = *(NSObject **)v15;
    }
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      long long v34 = nas::asString(v48);
      uint64_t v35 = CSIBOOLAsString();
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v34;
      __int16 v61 = 2080;
      uint64_t v62 = v35;
      _os_log_impl(&dword_22231A000, v30, OS_LOG_TYPE_DEFAULT, "#N *** IMS call state notification to BB: Sending IMS Call Status: %s. Is is to end RAT selection: %s.", buf, 0x16u);
    }
    *(_OWORD *)std::string __p = 0u;
    long long v54 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    long long v37 = (const void **)__p[1];
    int v36 = (const void **)v54;
    uint64_t v38 = (const void **)__p[1];
    if (__p[1] != (void *)v54)
    {
      uint64_t v38 = (const void **)__p[1];
      while (*((unsigned char *)*v38 + 8) != 1)
      {
        if (++v38 == (const void **)v54) {
          goto LABEL_47;
        }
      }
    }
    if (v38 == (const void **)v54) {
LABEL_47:
    }
      operator new();
    if (!v39) {
      __cxa_bad_cast();
    }
    _OWORD v39[3] = v48;
    if (v37 == v36) {
      goto LABEL_55;
    }
    while (*((unsigned char *)*v37 + 8) != 16)
    {
      if (++v37 == v36) {
        goto LABEL_55;
      }
    }
    if (v37 == v36) {
LABEL_55:
    }
      operator new();
    if (!v40) {
      __cxa_bad_cast();
    }
    dispatch_object_t v40[2] = 1;
    if (v10)
    {
      for (uint64_t i = (const void **)__p[1]; ; ++i)
      {
        if (i == v36) {
          goto LABEL_64;
        }
        if (*((unsigned char *)*i + 8) == 17) {
          break;
        }
      }
      if (i == v36) {
LABEL_64:
      }
        operator new();
      if (!v40) {
        __cxa_bad_cast();
      }
      *((unsigned char *)v40 + 9) = 12;
    }
    if (!v8)
    {
LABEL_84:
      qmi::ClientRouter::get();
      operator new();
    }
    uint64_t v42 = (capabilities::ct *)capabilities::ct::supportsNASCallEndReason((capabilities::ct *)v40);
    if (v42)
    {
      v51[0] = MEMORY[0x263EF8330];
      v51[1] = 0x40000000;
      v51[2] = ___ZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbb_block_invoke;
      v51[3] = &__block_descriptor_tmp_107_0;
      char v52 = v47;
      uint64_t v43 = (const void **)__p[1];
      if (__p[1] != (void *)v54)
      {
        while (*((unsigned char *)*v43 + 8) != 10)
        {
          if (++v43 == (const void **)v54) {
            goto LABEL_74;
          }
        }
      }
      if (v43 == (const void **)v54) {
LABEL_74:
      }
        operator new();
      if (!v44) {
        goto LABEL_91;
      }
      uint64_t v42 = (capabilities::ct *)___ZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbb_block_invoke((uint64_t)v51, v44 + 9);
    }
    if (!capabilities::ct::supportsCSFBFastSAReturn(v42)) {
      goto LABEL_84;
    }
    v49[0] = MEMORY[0x263EF8330];
    v49[1] = 0x40000000;
    v49[2] = ___ZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbb_block_invoke_2;
    v49[3] = &__block_descriptor_tmp_109;
    int v50 = a2;
    long long v45 = (const void **)__p[1];
    if (__p[1] != (void *)v54)
    {
      while (*((unsigned char *)*v45 + 8) != 20)
      {
        if (++v45 == (const void **)v54) {
          goto LABEL_83;
        }
      }
    }
    if (v45 == (const void **)v54) {
LABEL_83:
    }
      operator new();
    if (v46)
    {
      ___ZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbb_block_invoke_2((uint64_t)v49, v46 + 9);
      goto LABEL_84;
    }
LABEL_91:
    __cxa_bad_cast();
  }
  char v17 = *(NSObject **)v15;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    uint64_t v12 = "#N *** IMS call state notification to BB: Dropping the request as it is handled by IPT on device that supports 5G.";
    uint64_t v13 = v17;
    uint32_t v14 = 2;
    goto LABEL_13;
  }
}

void sub_2224E38FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a28) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a28);
  }
  if (a34 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbb_block_invoke(uint64_t result, unsigned char *a2)
{
  *a2 = *(unsigned char *)(result + 32);
  return result;
}

uint64_t ___ZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbb_block_invoke_2(uint64_t result, BOOL *a2)
{
  *a2 = *(_DWORD *)(result + 32) != 4;
  return result;
}

uint64_t EurekaCallCommandDriver::selectCallRat(NSObject **this, const CallInfo *a2)
{
  uint64_t result = capabilities::ct::supports5G((capabilities::ct *)this);
  if (result)
  {
    uint64_t v4 = this[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Re-selecting LTE as the current RAT", buf, 2u);
    }
    *(_OWORD *)std::string __p = 0u;
    long long v11 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    uint64_t v5 = (const void **)__p[1];
    uint64_t v6 = (const void **)v11;
    uint64_t v7 = (const void **)__p[1];
    if (__p[1] != (void *)v11)
    {
      uint64_t v7 = (const void **)__p[1];
      while (*((unsigned char *)*v7 + 8) != 1)
      {
        if (++v7 == (const void **)v11) {
          goto LABEL_12;
        }
      }
    }
    if (v7 != (const void **)v11)
    {
      if (!v8) {
        __cxa_bad_cast();
      }
      void v8[5] = 16;
      while (1)
      {
        if (v5 == v6) {
          goto LABEL_19;
        }
        if (*((unsigned char *)*v5 + 8) == 2) {
          break;
        }
        ++v5;
      }
      if (v5 != v6)
      {
        if (v9)
        {
          _OWORD v9[2] = 1;
          qmi::ClientRouter::get();
          operator new();
        }
        __cxa_bad_cast();
      }
LABEL_19:
      operator new();
    }
LABEL_12:
    operator new();
  }
  return result;
}

void sub_2224E3F34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v20, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::~EurekaCallCommandDriver(atomic_uint **this)
{
  EurekaCallCommandDriver::~EurekaCallCommandDriver(this);

  JUMPOUT(0x223C9A950);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  atomic_uint *v7;
  uint64_t vars8;

  std::__list_imp<boost::signals2::connection>::clear(this + 42);
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy((uint64_t)(this + 39), this[40]);
  std::__tree<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>>>::destroy((uint64_t)(this + 35), this[36]);
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy((uint64_t)(this + 32), this[33]);
  std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::destroy((uint64_t)(this + 29), this[30]);
  uint64_t v2 = (std::__shared_weak_count *)this[28];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>>>::destroy((uint64_t)(this + 24), this[25]);
  uint64_t v3 = (std::__shared_weak_count *)this[22];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)this[20];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)this[18];
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)this[16];
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  uint64_t v7 = this[14];
  this[14] = 0;
  if (v7) {
    (*(void (**)(atomic_uint *))(*(void *)v7 + 8))(v7);
  }

  CallCommandDriver::~CallCommandDriver((CallCommandDriver *)this);
}

void std::__list_imp<boost::signals2::connection>::clear(atomic_uint **a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (atomic_uint **)a1[1];
    uint64_t v4 = *v3;
    *((void *)v4 + 1) = *((void *)*a1 + 1);
    **((void **)v2 + 1) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (atomic_uint **)v3[1];
        boost::detail::weak_count::~weak_count(v3 + 3);
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  char v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        CallInfo::~CallInfo(v4 - 51);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void boost::detail::weak_count::~weak_count(atomic_uint **this)
{
  char v1 = *this;
  if (v1)
  {
    if (atomic_fetch_add(v1 + 3, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v1 + 24))(v1);
    }
  }
}

uint64_t std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_26D4D0EA0;
  CallInfo::~CallInfo((void **)(a1 + 16));
  return a1;
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_26D4D0EA0;
  CallInfo::~CallInfo((void **)(a1 + 16));

  JUMPOUT(0x223C9A950);
}

void *std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x1B0uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_26D4D0EA0;
  v2[1] = v3;
  CallInfo::CallInfo((CallInfo *)(v2 + 2), (const CallInfo *)(a1 + 16));
  *((_DWORD *)v2 + 106) = *(_DWORD *)(a1 + 424);
  return v2;
}

void sub_2224E427C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26D4D0EA0;
  *(void *)(a2 + 8) = v4;
  CallInfo::CallInfo((CallInfo *)(a2 + 16), (const CallInfo *)(a1 + 16));
  *(_DWORD *)(a2 + 424) = *(_DWORD *)(a1 + 424);
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::destroy(uint64_t a1)
{
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::destroy_deallocate(void **a1)
{
  CallInfo::~CallInfo(a1 + 2);

  operator delete(a1);
}

const void **std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::operator()(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v6, (const void **)(a1 + 16));
  EurekaCallCommandDriver::handleNormalVoiceDialResp(v4, a2, &v6, *(unsigned int *)(a1 + 424));
  return ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v6);
}

void sub_2224E438C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::target_type()
{
}

void *std::vector<vs::tlv::CallListItem>::__init_with_size[abi:ne180100]<vs::tlv::CallListItem*,vs::tlv::CallListItem*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<PlmnPriorityData>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_2224E444C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<vs::tlv::RemoteNameListItem>,vs::tlv::RemoteNameListItem*,vs::tlv::RemoteNameListItem*,vs::tlv::RemoteNameListItem*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v14 = a4;
  uint64_t v15 = a4;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  uint64_t v13 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = (long long *)(a2 + 8);
    do
    {
      uint64_t v8 = (uint64_t)v6 - 8;
      __int16 v7 = *((_WORD *)v6 - 4);
      *(unsigned char *)(v4 + 2) = *((unsigned char *)v6 - 6);
      *(_WORD *)uint64_t v4 = v7;
      int v9 = (std::string *)(v4 + 8);
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v6, *((void *)v6 + 1));
        uint64_t v4 = v15;
      }
      else
      {
        long long v10 = *v6;
        *(void *)(v4 + 24) = *((void *)v6 + 2);
        *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
      }
      v4 += 32;
      uint64_t v15 = v4;
      v6 += 2;
    }
    while (v8 + 32 != a3);
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<cat::tlv::Item>,cat::tlv::Item*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v4;
}

void sub_2224E4528(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,vs::tlv::RemoteNameListItem *,vs::tlv::RemoteNameListItem *,vs::tlv::RemoteNameListItem *,0>(__int16 *a1, __int16 *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      __int16 v6 = *v5;
      *(unsigned char *)(a3 + 2) = *((unsigned char *)v5 + 2);
      *(_WORD *)a3 = v6;
      std::string::operator=((std::string *)(a3 + 8), (const std::string *)(v5 + 4));
      a3 += 32;
      v5 += 16;
    }
    while (v5 != a2);
  }
  return a3;
}

void std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<unsigned int>,false> const&>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (a1 != a2 && *(unsigned char *)(a1 + 24))
    {
      uint64_t v3 = *(void *)(a2 + 8);
      unint64_t v4 = (v3 - *(void *)a2) >> 2;
      uint64_t v5 = *(char **)a2;
      std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>((char *)a1, v5, v3, v4);
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    __int16 v6 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v6;
      operator delete(v6);
    }
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    *(unsigned char *)(a1 + 24) = 1;
  }
}

void SimInstanceLoggable<EurekaCallCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::~SimInstanceLoggable()
{
}

uint64_t SimInstanceLoggable<EurekaCallCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::getLoggerForSlot(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>>>::destroy(a1, a2[1]);
    unint64_t v4 = (std::__shared_weak_count *)a2[6];
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<ctu::Timer>>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<ctu::Timer>>,0>(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

void std::__tree<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>>>::destroy(a1, a2[1]);
    std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy((uint64_t)(a2 + 5), (void *)a2[6]);
    operator delete(a2);
  }
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::VoiceIndRegCallEventsNotify>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::VoiceIndRegCallEventsNotify>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<vs::tlv::VoiceIndRegCallEventsNotify>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  __int16 v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::VoiceIndRegCallEventsNotify>::clone()
{
}

void qmi::ClientRouter::SendProxy::SendProxy<vs::SendVoiceIndRegister::Request>(_DWORD *a1, int a2)
{
  *a1 = a2;
  operator new();
}

void sub_2224E4A3C(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x10F0C401BA14CC5);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver25sendVSIndRegisterReq_syncENS_16SubscriptionTypeEE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    char v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "Error in response while unregistering for voice events on USSD client. With code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c110_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver25sendVSIndRegisterReq_syncEN3qmi16SubscriptionTypeEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c110_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver25sendVSIndRegisterReq_syncEN3qmi16SubscriptionTypeEE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_1,std::allocator<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D0FF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_1,std::allocator<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D0FF0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::HandoverEventEnable>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::HandoverEventEnable>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<vs::tlv::HandoverEventEnable>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::HandoverEventEnable>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver25sendVSIndRegisterReq_syncENS_16SubscriptionTypeEE3__3EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    char v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I Error in response while registering for Handover Events. With code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c110_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver25sendVSIndRegisterReq_syncEN3qmi16SubscriptionTypeEE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c110_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver25sendVSIndRegisterReq_syncEN3qmi16SubscriptionTypeEE3__3EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_3,std::allocator<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D10C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_3,std::allocator<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D10C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver23bindVSSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  if (*(_DWORD *)(a2 + 4))
  {
    unsigned int v5 = *((_DWORD *)v2 + 2);
    uint64_t v6 = v5 - 1 >= 3 ? 0 : v5;
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 112) + 16))(*(void *)(v3 + 112), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = qmi::asString();
      int v9 = *(_DWORD *)(a2 + 4);
      buf[0] = 136315394;
      *(void *)&buf[1] = v8;
      __int16 v19 = 1024;
      LODWORD(v20) = v9;
      _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#N Error binding VS subscription: %s (0x%x)", (uint8_t *)buf, 0x12u);
    }
  }
  unsigned int v10 = *((_DWORD *)v2 + 2);
  if (v10 - 1 >= 3) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = v10;
  }
  uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 112) + 16))(*(void *)(v3 + 112), v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf[0]) = 0;
    _os_log_impl(&dword_22231A000, v12, OS_LOG_TYPE_DEFAULT, "#I Sending VS indication registration requests", (uint8_t *)buf, 2u);
  }
  *(_OWORD *)std::string __p = 0u;
  long long v17 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v13 = (const void **)__p[1];
  if (__p[1] != (void *)v17)
  {
    while (*((unsigned char *)*v13 + 8) != 19)
    {
      if (++v13 == (const void **)v17) {
        goto LABEL_19;
      }
    }
  }
  if (v13 != (const void **)v17)
  {
    if (v14)
    {
      v14[9] = 0;
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<vs::SendVoiceIndRegister::Request>(&v15, v10);
    }
    __cxa_bad_cast();
  }
LABEL_19:
  operator new();
}

void sub_2224E556C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  if (a26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a26);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v26);
  uint64_t v28 = a10;
  a10 = 0;
  if (v28) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v28);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c108_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver23bindVSSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c108_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver23bindVSSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::bindVSSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::bindVSSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D1140;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::bindVSSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::bindVSSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D1140;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  cast_message_type<vs::BindSubscription::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2224E56E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver24bindNASSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(BOOL a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(_DWORD **)(a1 + 32);
  if (*(_DWORD *)(a2 + 4))
  {
    unsigned int v4 = v2[2];
    uint64_t v5 = v4 - 1 >= 3 ? 0 : v4;
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v2 + 112) + 16))(*(void *)(*(void *)v2 + 112), v5);
    a1 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    if (a1)
    {
      uint64_t v7 = qmi::asString();
      int v8 = *(_DWORD *)(a2 + 4);
      buf[0] = 136315394;
      *(void *)&buf[1] = v7;
      __int16 v17 = 1024;
      LODWORD(v18) = v8;
      _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#N Error binding NAS subscription: %s (0x%x)", (uint8_t *)buf, 0x12u);
    }
  }
  int v9 = v2[2];
  uint64_t result = capabilities::ct::supports5G((capabilities::ct *)a1);
  if (result)
  {
    *(_OWORD *)std::string __p = 0u;
    long long v15 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    uint64_t v11 = (const void **)__p[1];
    if (__p[1] != (void *)v15)
    {
      while (*((unsigned char *)*v11 + 8) != 63)
      {
        if (++v11 == (const void **)v15) {
          goto LABEL_15;
        }
      }
    }
    if (v11 != (const void **)v15)
    {
      if (v12)
      {
        v12[9] = 1;
        qmi::ClientRouter::get();
        qmi::ClientRouter::SendProxy::SendProxy<nas::IndicationRegister::Request>(&v13, v9);
      }
      __cxa_bad_cast();
    }
LABEL_15:
    operator new();
  }
  return result;
}

void sub_2224E5AF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  if (a26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a26);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v26);
  uint64_t v28 = a10;
  a10 = 0;
  if (v28) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v28);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c109_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver24bindNASSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c109_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver24bindNASSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D11C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D11C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_5(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  cast_message_type<nas::BindSubscription::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2224E5C44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver27bindVsUSSDSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 4))
  {
    uint64_t v3 = *(uint64_t **)(a1 + 32);
    uint64_t v4 = *v3;
    unsigned int v5 = *((_DWORD *)v3 + 2);
    if (v5 - 1 >= 3) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = v5;
    }
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 112) + 16))(*(void *)(v4 + 112), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = qmi::asString();
      int v9 = *(_DWORD *)(a2 + 4);
      int v10 = 136315394;
      uint64_t v11 = v8;
      __int16 v12 = 1024;
      int v13 = v9;
      _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#N Error binding NAS subscription: %s (0x%x)", (uint8_t *)&v10, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c112_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver27bindVsUSSDSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c112_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver27bindVsUSSDSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::bindVsUSSDSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::bindVsUSSDSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D1240;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::bindVsUSSDSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::bindVsUSSDSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D1240;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallReadyInd>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallReadyInd>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallReadyInd>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallReadyInd>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver26sendNASIndRegisterReq_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  char v3 = *(uint64_t **)(a1 + 32);
  uint64_t v4 = *v3;
  unsigned int v5 = *((_DWORD *)v3 + 2);
  if (v5 - 1 >= 3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v5;
  }
  uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 112) + 16))(*(void *)(v4 + 112), v6);
  int v8 = *(_DWORD *)(a2 + 4);
  if (v8)
  {
    int v9 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      v10[0] = 67109378;
      v10[1] = v8;
      __int16 v11 = 2080;
      uint64_t v12 = qmi::asString();
      _os_log_impl(&dword_22231A000, v9, OS_LOG_TYPE_DEFAULT, "#N Register for NAS indications failed: Error in response with code %d (%s)", (uint8_t *)v10, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver26sendNASIndRegisterReq_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver26sendNASIndRegisterReq_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendNASIndRegisterReq_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::sendNASIndRegisterReq_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D1310;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendNASIndRegisterReq_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::sendNASIndRegisterReq_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D1310;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D1360;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D1360;
  a2[1] = v2;
  return result;
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, unsigned int *a2)
{
  unsigned int v2 = *a2;
  if (*a2 - 1 >= 3) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = v2;
  }
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112) + 16))(*(void *)(*(void *)(a1 + 8) + 112), v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Eureka CallCommandDriver VSClient started", buf, 2u);
  }
  memset(v6, 0, sizeof(v6));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v6);
  *qmi::MutableMessageBase::getTLV<vs::tlv::SubscriptionType>((uint64_t)v6, 1) = v2 == 2;
  qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::BindSubscription::Request>(&v5, v2);
}

void sub_2224E630C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  uint64_t v22 = a10;
  a10 = 0;
  if (v22) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v22);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D13E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D13E0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, _DWORD *a2)
{
  if ((*a2 - 1) >= 3) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = *a2;
  }
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112) + 16))(*(void *)(*(void *)(a1 + 8) + 112), v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I Eureka CallCommandDriver VSClient stopped", v4, 2u);
  }
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D1460;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D1460;
  a2[1] = v2;
  return result;
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, _DWORD *a2)
{
  if ((*a2 - 1) >= 3) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = *a2;
  }
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112) + 16))(*(void *)(*(void *)(a1 + 8) + 112), v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I Eureka CallCommandDriver VSClient server error", v4, 2u);
  }
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D14E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D14E0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, unsigned int *a2)
{
  unsigned int v2 = *a2;
  if (*a2 - 1 >= 3) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = v2;
  }
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112) + 16))(*(void *)(*(void *)(a1 + 8) + 112), v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Eureka CallCommandDriver NAS Client started", buf, 2u);
  }
  memset(v6, 0, sizeof(v6));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v6);
  *qmi::MutableMessageBase::getTLV<nas::tlv::SubType>((uint64_t)v6, 1) = v2 == 2;
  qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::BindSubscription::Request>(&v5, v2);
}

void sub_2224E692C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  uint64_t v22 = a10;
  a10 = 0;
  if (v22) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v22);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D1560;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D1560;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, unsigned int *a2)
{
  unsigned int v2 = *a2;
  if (*a2 - 1 >= 3) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = v2;
  }
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112) + 16))(*(void *)(*(void *)(a1 + 8) + 112), v3);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Eureka CallCommandDriver USSD Client started", buf, 2u);
  }
  uint64_t result = capabilities::ct::supports5G((capabilities::ct *)v5);
  if (result)
  {
    memset(v8, 0, sizeof(v8));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v8);
    *qmi::MutableMessageBase::getTLV<vs::tlv::SubscriptionType>((uint64_t)v8, 1) = v2 == 2;
    qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<vs::BindSubscription::Request>(&v7, v2);
  }
  return result;
}

void sub_2224E6C6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  uint64_t v22 = a10;
  a10 = 0;
  if (v22) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v22);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_5>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_5>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D15E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_5>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D15E0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_5>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  cast_message_type<vs::VoiceCallStatus::Indication const&>::cast(a3, (qmi::MessageBase *)v5);
  EurekaCallCommandDriver::handleVoiceAllCallStatusIndication(*(void *)(a1 + 8), v4, (qmi::MessageBase *)v5);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v5);
}

void sub_2224E6DE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_5>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_5>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_6>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_6>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D1660;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_6>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D1660;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_6>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&,QMIServiceMsg const)>::operator()(uint64_t a1, _DWORD *a2, QMIServiceMsg *this)
{
  uint64_t v143 = *MEMORY[0x263EF8340];
  LODWORD(v4) = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p[1] = 0;
    __p[0] = 0;
    *(void *)&long long v112 = 0;
    QMIServiceMsg::serialize((uint64_t *)__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v54, __p[0]);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v54);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v54);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v134 = 0;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  long long v126 = 0u;
  long long v127 = 0u;
  long long v124 = 0u;
  long long v125 = 0u;
  long long v122 = 0u;
  long long v123 = 0u;
  long long v120 = 0u;
  long long v121 = 0u;
  long long v118 = 0u;
  long long v119 = 0u;
  long long v116 = 0u;
  long long v117 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  long long v112 = 0u;
  memset(v113, 0, sizeof(v113));
  *(_OWORD *)std::string __p = 0u;
  CallInfo::CallInfo((CallInfo *)__p);
  if ((v4 - 1) >= 3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v4;
  }
  int v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 112) + 16))(*(void *)(v6 + 112), v7);
  if ((v4 - 1) >= 3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = v4;
  }
  uint64_t v107 = 0;
  int v108 = &v107;
  uint64_t v109 = 0x2000000000;
  char v110 = 0;
  v106[0] = MEMORY[0x263EF8330];
  v106[1] = 0x40000000;
  v106[2] = ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke;
  v106[3] = &unk_2646109F8;
  v106[4] = &v107;
  *(void *)long long buf = v106;
  if (qmi::MessageBase::applyTlv<vs::tlv::CallIdentifier,void({block_pointer})(vs::tlv::CallIdentifier const&)>((qmi::MessageBase *)v54, 1, (uint64_t)buf))
  {
    HIDWORD(v114) = *((unsigned __int8 *)v108 + 24);
    HIDWORD(v124) = v4;
    if (!CallCommandDriver::carrierSupportsCallingTimewithFWIM()) {
      goto LABEL_27;
    }
    *(void *)long long buf = 0;
    BOOL v96 = buf;
    uint64_t v97 = 0x2000000000;
    LOWORD(v98) = 0;
    v102[0] = MEMORY[0x263EF8330];
    v102[1] = 0x40000000;
    long long v103 = ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_47;
    long long v104 = &unk_264610A20;
    long long v105 = buf;
    uint64_t TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v54);
    uint64_t v11 = TlvValue;
    if (TlvValue)
    {
      int v12 = v10;
      *(void *)int v88 = TlvValue;
      LODWORD(v79[0]) = tlv::parseV<vs::tlv::LineControl>((unsigned char **)v88, v10);
      if (*(void *)v88)
      {
        v103((uint64_t)v102, (unsigned __int8 *)v79);
        goto LABEL_22;
      }
      if (((unsigned int (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v54[0], 29, v11, v12))
      {
LABEL_22:
        if (*((_WORD *)v96 + 12))
        {
          uint64_t v14 = *v8;
          if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)int v88 = 0;
            _os_log_impl(&dword_22231A000, v14, OS_LOG_TYPE_DEFAULT, "#I Telling the call to go active now that we got correct TLV (polarity)", v88, 2u);
          }
          (*(void (**)(void, void **))(**(void **)(v6 + 120) + 56))(*(void *)(v6 + 120), __p);
        }
      }
    }
    _Block_object_dispose(buf, 8);
LABEL_27:
    *(void *)long long buf = 0;
    BOOL v96 = buf;
    uint64_t v97 = 0x4002000000;
    int v98 = __Block_byref_object_copy__8;
    uint64_t v99 = __Block_byref_object_dispose__8;
    v100[0] = 0;
    v100[1] = 0;
    uint64_t v101 = 0;
    std::string::basic_string[abi:ne180100]<0>(v100, (char *)&unk_222543CCE);
    *(void *)int v88 = 0;
    int v89 = v88;
    uint64_t v90 = 0x4002000000;
    uint64_t v91 = __Block_byref_object_copy__8;
    v92 = __Block_byref_object_dispose__8;
    v93[0] = 0;
    v93[1] = 0;
    uint64_t v94 = 0;
    std::string::basic_string[abi:ne180100]<0>(v93, (char *)&unk_222543CCE);
    uint64_t v84 = 0;
    long long v85 = &v84;
    uint64_t v86 = 0x2000000000;
    char v87 = 2;
    v79[0] = MEMORY[0x263EF8330];
    v79[1] = 0x40000000;
    uint64_t v80 = ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_50;
    uint64_t v81 = &unk_264610A48;
    int v82 = &v84;
    int v83 = buf;
    uint64_t v15 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v54);
    uint64_t v17 = v15;
    if (!v15)
    {
LABEL_35:
      if (numberContainsAlphabet())
      {
        *((unsigned char *)v85 + 24) = 1;
        uint64_t v20 = v96;
        if ((char)v96[63] < 0)
        {
          *((void *)v96 + 6) = 0;
          uint64_t v21 = (unsigned char *)*((void *)v20 + 5);
        }
        else
        {
          uint64_t v21 = v96 + 40;
          v96[63] = 0;
        }
        *uint64_t v21 = 0;
      }
      v75[0] = MEMORY[0x263EF8330];
      v75[1] = 0x40000000;
      v76 = ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_2;
      v77 = &unk_264610A70;
      uint64_t v78 = v88;
      uint64_t v22 = (char *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v54);
      int v24 = v22;
      if (v22)
      {
        int v25 = v23;
        v71[0] = v22;
        memset(v139, 0, sizeof(v139));
        *(void *)&long long v140 = 0;
        tlv::parseV<vs::tlv::CallerName>(v71, v23, v139);
        uint64_t v26 = v71[0];
        if (v71[0]) {
          v76((uint64_t)v75, (char **)v139);
        }
        if (*(void *)v139)
        {
          *(void *)&v139[8] = *(void *)v139;
          operator delete(*(void **)v139);
        }
        if (!v26) {
          ((void (*)(void, uint64_t, char *, void))*MEMORY[0x263F8BD78])(v54[0], 20, v24, v25);
        }
      }
      v71[0] = (char *)MEMORY[0x263EF8330];
      v71[1] = (char *)0x40000000;
      long long v72 = ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_3;
      uint64_t v73 = &unk_264610A98;
      unsigned int v74 = v88;
      char v27 = (char *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v54);
      long long v29 = v27;
      if (v27)
      {
        int v30 = v28;
        v63[0] = v27;
        memset(v139, 0, sizeof(v139));
        *(void *)&long long v140 = 0;
        tlv::parseV<vs::tlv::DisplayBuffer>(v63, v28, v139);
        uint64_t v31 = v63[0];
        if (v63[0]) {
          v72((uint64_t)v71, (char **)v139);
        }
        if (*(void *)v139)
        {
          *(void *)&v139[8] = *(void *)v139;
          operator delete(*(void **)v139);
        }
        if (!v31) {
          ((void (*)(void, uint64_t, char *, void))*MEMORY[0x263F8BD78])(v54[0], 18, v29, v30);
        }
      }
      if (*((unsigned char *)v85 + 24))
      {
        long long v32 = v96;
        if ((char)v96[63] < 0)
        {
          *((void *)v96 + 6) = 0;
          long long v33 = (unsigned char *)*((void *)v32 + 5);
        }
        else
        {
          long long v33 = v96 + 40;
          v96[63] = 0;
        }
        *long long v33 = 0;
      }
      std::string::operator=(v113, (const std::string *)(v96 + 40));
      std::string::operator=((std::string *)&__p[1], (const std::string *)(v89 + 40));
      LODWORD(v114) = *((unsigned __int8 *)v85 + 24);
      uint64_t v67 = 0;
      long long v68 = &v67;
      uint64_t v69 = 0x2000000000;
      char v70 = 0;
      v63[0] = (char *)MEMORY[0x263EF8330];
      v63[1] = (char *)0x40000000;
      int v64 = (uint64_t (*)(uint64_t, uint64_t *))___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_4;
      long long v65 = &unk_264610AC0;
      long long v66 = &v67;
      uint64_t v34 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v54);
      uint64_t v36 = v34;
      if (v34)
      {
        int v37 = v35;
        *(void *)v139 = v34;
        LOBYTE(v59) = tlv::parseV<vs::tlv::CallWaitingInfo>((unint64_t *)v139, v35);
        if (*(void *)v139) {
          v64((uint64_t)v63, &v59);
        }
        else {
          ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v54[0], 21, v36, v37);
        }
      }
      if (!*((unsigned char *)v68 + 24)) {
        goto LABEL_69;
      }
      int v38 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 120) + 224))(*(void *)(v6 + 120), v4);
      int v39 = *((unsigned __int8 *)v108 + 24);
      if (v38 != v39)
      {
        long long v49 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v139 = 67109376;
          *(_DWORD *)&v139[4] = v39;
          *(_WORD *)&v139[8] = 1024;
          *(_DWORD *)&v139[10] = v38;
          _os_log_impl(&dword_22231A000, v49, OS_LOG_TYPE_DEFAULT, "#I Got a traffic channel id, %d, that does not match the one we have, %d. Dropping the Voice Info Record indication.", v139, 0xEu);
        }
        goto LABEL_94;
      }
      if (*((unsigned char *)v68 + 24))
      {
        uint64_t v40 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v139 = 67109120;
          *(_DWORD *)&v139[4] = v38;
          _os_log_impl(&dword_22231A000, v40, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming VoiceInfoRecord Indication: WAITING for %d", v139, 8u);
        }
        (*(void (**)(void, void **, uint64_t))(**(void **)(v6 + 120) + 96))(*(void *)(v6 + 120), __p, 22000);
      }
      else
      {
LABEL_69:
        uint64_t v41 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          int v42 = *((unsigned __int8 *)v108 + 24);
          *(_DWORD *)v139 = 67109120;
          *(_DWORD *)&v139[4] = v42;
          _os_log_impl(&dword_22231A000, v41, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming VoiceInfoRecord Indication: Caller Id for %d", v139, 8u);
        }
        if ((v17 & 1) == 0)
        {
          uint64_t v43 = *v8;
          if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v139 = 0;
            _os_log_impl(&dword_22231A000, v43, OS_LOG_TYPE_DEFAULT, "#I There is no caller id information but we are setting caller id to Unknown/kUnavailable since this indication came", v139, 2u);
          }
        }
        (*(void (**)(void, void **))(**(void **)(v6 + 120) + 200))(*(void *)(v6 + 120), __p);
      }
      uint64_t v59 = 0;
      uint64_t v60 = &v59;
      uint64_t v61 = 0x2000000000;
      char v62 = -1;
      uint64_t v55 = 0;
      int v56 = &v55;
      uint64_t v57 = 0x2000000000;
      char v58 = -1;
      *(void *)v139 = MEMORY[0x263EF8330];
      *(void *)&v139[8] = 0x40000000;
      *(void *)&long long v140 = ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_56;
      *((void *)&v140 + 1) = &unk_264610AE8;
      uint64_t v141 = &v55;
      v142 = &v59;
      uint64_t v44 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v54);
      uint64_t v46 = v44;
      if (v44)
      {
        int v47 = v45;
        *(void *)os_log_t v137 = v44;
        uint64_t v48 = tlv::parseV<vs::tlv::SignalInfo>((unsigned char **)v137, v45);
        __int16 v135 = v48;
        char v136 = BYTE2(v48);
        if (*(void *)v137)
        {
          ((void (*)(uint8_t *, __int16 *))v140)(v139, &v135);
LABEL_81:
          if (!*((unsigned char *)v56 + 24) && *((unsigned char *)v60 + 24) == 6)
          {
            int v50 = *v8;
            if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)os_log_t v137 = 0;
              _os_log_impl(&dword_22231A000, v50, OS_LOG_TYPE_DEFAULT, "#I Carrier provided busy signal info. Playing that busy tone", v137, 2u);
              uint64_t v51 = *((unsigned __int8 *)v60 + 24);
              char v52 = 0;
              switch(*((unsigned char *)v60 + 24))
              {
                case 0:
                case 1:
                case 2:
                  break;
                case 4:
                  char v52 = 0;
                  uint64_t v51 = 3;
                  break;
                case 6:
                  goto LABEL_86;
                case 7:
                  char v52 = 0;
                  uint64_t v51 = 5;
                  break;
                case 8:
                  char v52 = 0;
                  uint64_t v51 = 6;
                  break;
                case 9:
                  char v52 = 0;
                  uint64_t v51 = 7;
                  break;
                default:
                  int v53 = *(NSObject **)(v6 + 40);
                  if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)os_log_t v137 = 67109120;
                    *(_DWORD *)&v137[4] = v51;
                    _os_log_impl(&dword_22231A000, v53, OS_LOG_TYPE_DEFAULT, "#I QMI does not support tone id sent by network, %d", v137, 8u);
                  }
                  uint64_t v51 = 10;
                  char v52 = 1;
                  break;
              }
            }
            else
            {
LABEL_86:
              char v52 = 0;
              uint64_t v51 = 4;
            }
            *(void *)os_log_t v137 = 0;
            uint32_t v138 = 0;
            (*(void (**)(uint8_t *__return_ptr))(**(void **)(v6 + 120) + 288))(v137);
            if ((v52 & 1) == 0)
            {
              if (*(void *)v137) {
                (*(void (**)(void, uint64_t, void))(**(void **)v137 + 40))(*(void *)v137, v51, 0);
              }
              *(unsigned char *)(v6 + 184) = 1;
            }
            if (v138) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v138);
            }
          }
          goto LABEL_93;
        }
        if (((unsigned int (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v54[0], 16, v46, v47))
        {
          goto LABEL_81;
        }
      }
LABEL_93:
      _Block_object_dispose(&v55, 8);
      _Block_object_dispose(&v59, 8);
LABEL_94:
      _Block_object_dispose(&v67, 8);
      _Block_object_dispose(&v84, 8);
      _Block_object_dispose(v88, 8);
      if (SHIBYTE(v94) < 0) {
        operator delete(v93[0]);
      }
      _Block_object_dispose(buf, 8);
      if (SHIBYTE(v101) < 0) {
        operator delete(v100[0]);
      }
      goto LABEL_98;
    }
    int v18 = v16;
    v75[0] = v15;
    *(_OWORD *)v139 = 0u;
    long long v140 = 0u;
    tlv::parseV<vs::tlv::CallerIdInfo>(v75, v16, v139);
    unint64_t v19 = v75[0];
    if (v75[0]) {
      v80((uint64_t)v79, (uint64_t)v139);
    }
    if (SHIBYTE(v140) < 0)
    {
      operator delete(*(void **)&v139[8]);
      if (v19) {
        goto LABEL_32;
      }
    }
    else if (v19)
    {
LABEL_32:
      LOBYTE(v17) = 1;
      goto LABEL_35;
    }
    LOBYTE(v17) = ((uint64_t (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v54[0], 17, v17, v18);
    goto LABEL_35;
  }
  uint64_t v13 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl(&dword_22231A000, v13, OS_LOG_TYPE_ERROR, "Invalid Voice Info Record indication. Mandatory TLV, CallId, not present", buf, 2u);
  }
LABEL_98:
  _Block_object_dispose(&v107, 8);
  CallInfo::~CallInfo(__p);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v54);
}

void sub_2224E7BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *__p,uint64_t a55,int a56,__int16 a57,char a58,char a59,char a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  long long v72 = *(std::__shared_weak_count **)(v70 - 184);
  if (v72) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v72);
  }
  _Block_object_dispose(&a12, 8);
  _Block_object_dispose(&a16, 8);
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a45, 8);
  _Block_object_dispose(&a49, 8);
  if (a59 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a60, 8);
  if (a70 < 0) {
    operator delete(a65);
  }
  _Block_object_dispose(&STACK[0x210], 8);
  CallInfo::~CallInfo((void **)&STACK[0x230]);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_6>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_6>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_7>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_7>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D16E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_7>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D16E0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_7>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  uint64_t v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v14, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v14);
    if (__p)
    {
      uint64_t v16 = (uint64_t)__p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v14);
  }
  uint64_t v6 = *(void **)(a1 + 8);
  uint64_t v25 = 0;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x2000000000;
  char v28 = *MEMORY[0x263F03540];
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x2000000000;
  char v24 = -1;
  std::string __p = (void *)MEMORY[0x263EF8330];
  uint64_t v16 = 0x40000000;
  uint64_t v17 = (uint64_t (*)(uint64_t, long long *))___ZZN23EurekaCallCommandDriver25registerForQMIIndicationsEvENK3__7clEN3qmi16SubscriptionTypeERKN2vs14OtaspStatusInd10IndicationE_block_invoke;
  int v18 = &unk_264610DC8;
  unint64_t v19 = &v25;
  uint64_t v20 = &v21;
  uint64_t TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v14);
  int v9 = TlvValue;
  if (TlvValue)
  {
    int v10 = v8;
    uint64_t v31 = TlvValue;
    long long v29 = 0u;
    long long v30 = 0u;
    tlv::parseV<vs::tlv::OtaspStatus>(&v31, v8, &v29);
    uint64_t v11 = v31;
    if (v31) {
      v17((uint64_t)&__p, &v29);
    }
    if (*((void *)&v29 + 1))
    {
      *(void *)&long long v30 = *((void *)&v29 + 1);
      operator delete(*((void **)&v29 + 1));
    }
    if (!v11) {
      ((void (*)(void, uint64_t, unsigned __int8 *, void))*MEMORY[0x263F8BD78])(v14[0], 1, v9, v10);
    }
  }
  uint64_t v12 = v6[27];
  uint64_t v13 = v6[18];
  *(void *)&long long v29 = v6[17];
  *((void *)&v29 + 1) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t, long long *, void, void))(*(void *)v12 + 72))(v12, v4, &v29, *((unsigned __int8 *)v26 + 24), *((unsigned __int8 *)v22 + 24));
  if (*((void *)&v29 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v29 + 1));
  }
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v25, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v14);
}

void sub_2224E806C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  uint64_t v25 = *(void **)(v23 - 104);
  if (v25)
  {
    *(void *)(v23 - 96) = v25;
    operator delete(v25);
  }
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose(&a23, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_7>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_7>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&,QMIServiceMsg const)>::target_type()
{
}

uint64_t ___ZZN23EurekaCallCommandDriver25registerForQMIIndicationsEvENK3__7clEN3qmi16SubscriptionTypeERKN2vs14OtaspStatusInd10IndicationE_block_invoke(uint64_t result, unsigned char *a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a2;
  *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = a2[1];
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_8>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_8>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D1760;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_8>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D1760;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_8>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&,QMIServiceMsg const)>::operator()(uint64_t a1, int *a2, QMIServiceMsg *this)
{
  int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)&v15, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)&v15);
    if (__p)
    {
      uint64_t v20 = (uint64_t)__p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)&v15);
  }
  uint64_t v6 = *(void **)(a1 + 8);
  uint64_t v7 = v15;
  uint64_t v8 = v16;
  v18[0] = v15;
  v18[1] = v16;
  uint64_t v9 = v17;
  _OWORD v18[2] = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  std::string __p = (void *)MEMORY[0x263EF8330];
  uint64_t v20 = 1174405120;
  uint64_t v21 = ___ZN23EurekaCallCommandDriver29handleVoiceHandoverIndicationEN3qmi16SubscriptionTypeEN2vs13VoiceHandover10IndicationE_block_invoke;
  uint64_t v22 = &__block_descriptor_tmp_59_7;
  int v25 = v4;
  uint64_t v23 = v6;
  v24[0] = v7;
  v24[1] = v8;
  _OWORD v24[2] = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  int v10 = (std::__shared_weak_count *)v6[2];
  if (!v10 || (uint64_t v11 = v6[1], (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v13 = v12;
  uint64_t v14 = v6[3];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 1174405120;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17CallCommandDriverE15execute_wrappedEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_26D4D22F0;
  block[5] = v11;
  uint64_t v27 = v13;
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = &__p;
  dispatch_async(v14, block);
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v24);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v18);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&v15);
}

void sub_2224E83E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_8>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_8>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_9>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_9>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D17E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_9>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D17E0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_9>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    p_p = 0;
    uint64_t v37 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v19, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v19);
    if (__p)
    {
      p_p = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v19);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  v21[0] = v19[0];
  v21[1] = v19[1];
  v21[2] = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  if (v4 - 1 >= 3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v4;
  }
  uint64_t v8 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 112) + 16))(*(void *)(v6 + 112), v7);
  if (v4 - 1 >= 3) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = v4;
  }
  uint64_t v47 = 0;
  uint64_t v48 = &v47;
  uint64_t v49 = 0x2000000000;
  char v50 = 0;
  v43[0] = MEMORY[0x263EF8330];
  v43[1] = 0x40000000;
  uint64_t v44 = (uint64_t (*)(uint64_t, std::string *))___ZN23EurekaCallCommandDriver25handleVoiceUSSDIndicationEN3qmi16SubscriptionTypeEN2vs9VoiceUSSD10IndicationE_block_invoke;
  int v45 = &unk_264610838;
  uint64_t v46 = &v47;
  uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v21);
  uint64_t v12 = TlvValue;
  if (TlvValue)
  {
    int v13 = v11;
    std::string __p = TlvValue;
    LODWORD(v23.__r_.__value_.__l.__data_) = tlv::parseV<vs::tlv::NotificationType>((unint64_t *)&__p, v11);
    if (__p) {
      v44((uint64_t)v43, &v23);
    }
    else {
      ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(LOWORD(v21[0]), 1, v12, v13);
    }
  }
  std::string __p = 0;
  p_p = &__p;
  uint64_t v37 = 0x4002000000;
  int v38 = __Block_byref_object_copy__8;
  int v39 = __Block_byref_object_dispose__8;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v31 = 0;
  long long v32 = &v31;
  uint64_t v33 = 0x2000000000;
  int v34 = 0;
  v30[0] = MEMORY[0x263EF8330];
  v30[1] = 0x40000000;
  _OWORD v30[2] = ___ZN23EurekaCallCommandDriver25handleVoiceUSSDIndicationEN3qmi16SubscriptionTypeEN2vs9VoiceUSSD10IndicationE_block_invoke_4;
  v30[3] = &unk_264610860;
  void v30[4] = &v31;
  v30[5] = &__p;
  v23.__r_.__value_.__r.__words[0] = (std::string::size_type)v30;
  int v14 = qmi::MessageBase::applyTlv<vs::tlv::USSInfo,void({block_pointer})(vs::tlv::USSInfo const&)>((qmi::MessageBase *)v21, 16, (uint64_t)&v23);
  memset(&v29, 0, sizeof(v29));
  if (v14)
  {
    std::string v29 = v23;
  }
  v23.__r_.__value_.__r.__words[0] = 0;
  v23.__r_.__value_.__l.__size_ = (std::string::size_type)&v23;
  v23.__r_.__value_.__r.__words[2] = 0x4002000000;
  char v24 = __Block_byref_object_copy__8;
  int v25 = __Block_byref_object_dispose__8;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  v22[0] = MEMORY[0x263EF8330];
  v22[1] = 0x40000000;
  _OWORD v22[2] = ___ZN23EurekaCallCommandDriver25handleVoiceUSSDIndicationEN3qmi16SubscriptionTypeEN2vs9VoiceUSSD10IndicationE_block_invoke_2;
  v22[3] = &unk_264610888;
  void v22[4] = &v23;
  v22[5] = v8;
  *(void *)long long buf = v22;
  if (qmi::MessageBase::applyTlv<vs::tlv::UTF16Data,void({block_pointer})(vs::tlv::UTF16Data const&)>((qmi::MessageBase *)v21, 17, (uint64_t)buf))
  {
    std::string::operator=(&v29, (const std::string *)(v23.__r_.__value_.__l.__size_ + 40));
    uint64_t v15 = 1;
  }
  else
  {
    uint64_t v15 = 0;
  }
  uint64_t v16 = *v8;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = &v29;
    if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v17 = (std::string *)v29.__r_.__value_.__r.__words[0];
    }
    if (*((unsigned char *)v48 + 24)) {
      int v18 = "needed";
    }
    else {
      int v18 = "not needed";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v17;
    __int16 v52 = 2080;
    int v53 = v18;
    _os_log_impl(&dword_22231A000, v16, OS_LOG_TYPE_DEFAULT, "#I Received Voice USSD Indication with \"%s\" and user response %s", buf, 0x16u);
  }
  (*(void (**)(void, void, std::string *, uint64_t, uint64_t, uint64_t))(**(void **)(v6 + 120) + 144))(*(void *)(v6 + 120), *((unsigned __int8 *)v48 + 24), &v29, v15, 1, v9);
  _Block_object_dispose(&v23, 8);
  if (SHIBYTE(v28) < 0) {
    operator delete(v26);
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  _Block_object_dispose(&v31, 8);
  _Block_object_dispose(&__p, 8);
  if (SHIBYTE(v42) < 0) {
    operator delete(v40);
  }
  _Block_object_dispose(&v47, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v21);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v19);
}

void sub_2224E89E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  _Block_object_dispose(&a44, 8);
  _Block_object_dispose(&a48, 8);
  if (a58 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose((const void *)(v58 - 160), 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a12);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_9>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_9>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_10>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_10>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D1860;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_10>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D1860;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_10>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    int v10 = 0;
    uint64_t v11 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v8, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v8);
    if (__p)
    {
      int v10 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v8);
  }
  if (v4 - 1 >= 3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v4;
  }
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112) + 16))(*(void *)(*(void *)(a1 + 8) + 112), v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#N Received a USSD release indication that BB is terminating the USSD Session", (uint8_t *)&__p, 2u);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v8);
}

void sub_2224E8CBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_10>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_10>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_11>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_11>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D18E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_11>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D18E0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_11>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    *(void *)uint64_t v49 = 0;
    uint64_t v50 = 0;
    uint64_t v51 = 0;
    QMIServiceMsg::serialize((uint64_t *)v49, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v20, *(const void **)v49);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v20);
    if (*(void *)v49)
    {
      uint64_t v50 = *(void *)v49;
      operator delete(*(void **)v49);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v20);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  v22[0] = v20[0];
  v22[1] = v20[1];
  _OWORD v22[2] = v21;
  if (v21) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
  }
  if (v4 - 1 >= 3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v4;
  }
  uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 112) + 16))(*(void *)(v6 + 112), v7);
  if (v4 - 1 >= 3) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = v4;
  }
  uint64_t v44 = 0;
  int v45 = &v44;
  uint64_t v46 = 0x2000000000;
  char v47 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = &v40;
  uint64_t v42 = 0x2000000000;
  __int16 v43 = 0;
  v36[0] = MEMORY[0x263EF8330];
  v36[1] = 0x40000000;
  uint64_t v37 = (uint64_t (*)(uint64_t, std::string *))___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke;
  int v38 = &unk_2646108B0;
  int v39 = &v40;
  uint64_t TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v22);
  uint64_t v12 = TlvValue;
  if (TlvValue)
  {
    int v13 = v11;
    *(void *)uint64_t v49 = TlvValue;
    LOWORD(v24.__r_.__value_.__l.__data_) = tlv::parseV<vs::tlv::Error>((unint64_t *)v49, v11);
    if (*(void *)v49) {
      v37((uint64_t)v36, &v24);
    }
    else {
      ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(LOWORD(v22[0]), 16, v12, v13);
    }
  }
  memset(&__p, 0, sizeof(__p));
  std::string::basic_string[abi:ne180100]<0>(&__p, (char *)&unk_222543CCE);
  int v14 = *((unsigned __int16 *)v41 + 12);
  if (*((_WORD *)v41 + 12))
  {
    uint64_t v15 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v49 = 67109120;
      *(_DWORD *)&void v49[4] = v14;
      _os_log_error_impl(&dword_22231A000, v15, OS_LOG_TYPE_ERROR, "Send USSD failed with error code: %d", v49, 8u);
    }
    *(void *)uint64_t v49 = MEMORY[0x263EF8330];
    uint64_t v50 = 0x40000000;
    uint64_t v51 = (uint64_t)___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke_15;
    __int16 v52 = (__n128 (*)(uint64_t, uint64_t))&unk_264610928;
    int v53 = (void (*)(uint64_t))&v44;
    uint64_t v54 = v8;
    v24.__r_.__value_.__r.__words[0] = (std::string::size_type)v49;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v22, 17, (uint64_t)&v24);
    uint64_t v16 = v45;
    uint64_t v17 = 0;
    if (*((_WORD *)v41 + 12) == 4) {
      *((unsigned char *)v45 + 24) = 1;
    }
  }
  else
  {
    *(void *)uint64_t v49 = 0;
    uint64_t v50 = (uint64_t)v49;
    uint64_t v51 = 0x4002000000;
    __int16 v52 = __Block_byref_object_copy__8;
    int v53 = __Block_byref_object_dispose__8;
    uint64_t v54 = 0;
    uint64_t v55 = 0;
    uint64_t v56 = 0;
    uint64_t v31 = 0;
    long long v32 = &v31;
    uint64_t v33 = 0x2000000000;
    int v34 = 0;
    v30[0] = MEMORY[0x263EF8330];
    v30[1] = 0x40000000;
    _OWORD v30[2] = ___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke_2;
    v30[3] = &unk_2646108D8;
    void v30[4] = &v31;
    v30[5] = v49;
    v24.__r_.__value_.__r.__words[0] = (std::string::size_type)v30;
    if (qmi::MessageBase::applyTlv<vs::tlv::USSInfo,void({block_pointer})(vs::tlv::USSInfo const&)>((qmi::MessageBase *)v22, 18, (uint64_t)&v24))
    {
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      std::string __p = v24;
    }
    v24.__r_.__value_.__r.__words[0] = 0;
    v24.__r_.__value_.__l.__size_ = (std::string::size_type)&v24;
    v24.__r_.__value_.__r.__words[2] = 0x4002000000;
    int v25 = __Block_byref_object_copy__8;
    uint64_t v26 = __Block_byref_object_dispose__8;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    v23[0] = MEMORY[0x263EF8330];
    v23[1] = 0x40000000;
    void v23[2] = ___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke_3;
    v23[3] = &unk_264610900;
    void v23[4] = &v24;
    v23[5] = v8;
    *(void *)long long buf = v23;
    if (qmi::MessageBase::applyTlv<vs::tlv::UTF16Data,void({block_pointer})(vs::tlv::UTF16Data const&)>((qmi::MessageBase *)v22, 20, (uint64_t)buf))
    {
      std::string::operator=(&__p, (const std::string *)(v24.__r_.__value_.__l.__size_ + 40));
      uint64_t v17 = 1;
    }
    else
    {
      uint64_t v17 = 0;
    }
    *((unsigned char *)v45 + 24) = 1;
    int v18 = *v8;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = p_p;
      _os_log_impl(&dword_22231A000, v18, OS_LOG_TYPE_DEFAULT, "#I BB returned success for USSD Send Message with reply \"%s\"", buf, 0xCu);
    }
    _Block_object_dispose(&v24, 8);
    if (SHIBYTE(v29) < 0) {
      operator delete(v27);
    }
    _Block_object_dispose(&v31, 8);
    _Block_object_dispose(v49, 8);
    if (SHIBYTE(v56) < 0) {
      operator delete(v54);
    }
    uint64_t v16 = v45;
  }
  (*(void (**)(void, void, std::string *, uint64_t, void, uint64_t))(**(void **)(v6 + 120) + 144))(*(void *)(v6 + 120), 0, &__p, v17, *((unsigned __int8 *)v16 + 24), v9);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  _Block_object_dispose(&v40, 8);
  _Block_object_dispose(&v44, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v22);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v20);
}

void sub_2224E93B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  _Block_object_dispose(&a21, 8);
  if (a31 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a38, 8);
  _Block_object_dispose((const void *)(v47 - 176), 8);
  if (*(char *)(v47 - 113) < 0) {
    operator delete(*(void **)(v47 - 136));
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  _Block_object_dispose((const void *)(v47 - 256), 8);
  _Block_object_dispose((const void *)(v47 - 224), 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a12);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_11>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_11>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_12>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_12>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D1960;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_12>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D1960;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_12>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&long long v20 = 0;
    QMIServiceMsg::serialize((uint64_t *)__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v18, __p[0]);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v18);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v18);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v4 - 1 >= 3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v4;
  }
  uint64_t v8 = (capabilities::ct *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 112) + 16))(*(void *)(v6 + 112), v7);
  if (capabilities::ct::supports5G(v8))
  {
    uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v18);
    int v11 = TlvValue;
    if (TlvValue)
    {
      int v12 = v10;
      __p[0] = TlvValue;
      unsigned __int8 v13 = tlv::parseV<nas::tlv::SysMode>((unint64_t *)__p, v10);
      if (__p[0])
      {
LABEL_16:
        int v14 = *(NSObject **)v8;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v15 = nas::asString(v13);
          LODWORD(__p[0]) = 136315394;
          *(void **)((char *)__p + 4) = (void *)v15;
          WORD2(__p[1]) = 256;
          BYTE6(__p[1]) = v13;
          _os_log_impl(&dword_22231A000, v14, OS_LOG_TYPE_DEFAULT, "#I BB notified call ready with sys mode: %s(%hhu)", (uint8_t *)__p, 0xFu);
        }
        uint64_t v16 = *(void *)(v6 + 120);
        *(_OWORD *)std::string __p = 0u;
        long long v20 = 0u;
        std::string::basic_string[abi:ne180100]<0>(v21, (char *)*MEMORY[0x263F03760]);
        int v22 = 9;
        char v23 = 0;
        int v24 = 1;
        char v25 = 1;
        uint64_t v26 = 0x400000001;
        uint64_t v27 = 2;
        char v28 = 0;
        int v29 = *MEMORY[0x263F03540];
        char v32 = 0;
        char v33 = 0;
        uint64_t v30 = 0;
        v31[0] = 0;
        *(void *)((char *)v31 + 6) = 0;
        std::string::basic_string[abi:ne180100]<0>(v34, (char *)&unk_222543CCE);
        int v35 = 0;
        std::string::basic_string[abi:ne180100]<0>(v36, (char *)&unk_222543CCE);
        int v37 = 0;
        __int16 v38 = 0;
        int v39 = 0;
        __int16 v40 = 0;
        int v41 = 0;
        char v42 = 0;
        char v43 = 0;
        char v44 = 0;
        char v45 = 0;
        __int16 v46 = 0;
        int v47 = v7;
        char v48 = 0;
        int v49 = 0;
        char v50 = 0;
        long long v51 = 0u;
        long long v52 = 0u;
        memset(v53, 0, sizeof(v53));
        int v54 = 1;
        char v55 = 0;
        char v56 = 0;
        char v57 = 0;
        (*(void (**)(uint64_t, void **, BOOL))(*(void *)v16 + 368))(v16, __p, v13 == 8);
        CallInfo::~CallInfo(__p);
        goto LABEL_21;
      }
      ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v18[0], 1, v11, v12);
    }
    unsigned __int8 v13 = 8;
    goto LABEL_16;
  }
  uint64_t v17 = *(NSObject **)v8;
  if (os_log_type_enabled(*(os_log_t *)v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl(&dword_22231A000, v17, OS_LOG_TYPE_DEFAULT, "#I Dropping the call ready indication!", (uint8_t *)__p, 2u);
  }
LABEL_21:
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v18);
}

void sub_2224E9900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_12>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_12>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&,QMIServiceMsg const)>::target_type()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallConfigList>::~TlvWrapper(uint64_t a1)
{
  *(void *)a1 = &unk_26D4D19F8;
  uint64_t v3 = (void **)(a1 + 16);
  std::vector<vs::tlv::CallConfigItem>::__destroy_vector::operator()[abi:ne180100](&v3);
  return a1;
}

{
  void **v3;

  *(void *)a1 = &unk_26D4D19F8;
  uint64_t v3 = (void **)(a1 + 16);
  std::vector<vs::tlv::CallConfigItem>::__destroy_vector::operator()[abi:ne180100](&v3);
  return MEMORY[0x223C9A950](a1, 0x10A1C403082B835);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallConfigList>::getSize(uint64_t a1)
{
  return tlv::size<vs::tlv::CallConfigList>((uint64_t *)(a1 + 16));
}

unsigned char *qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallConfigList>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<vs::tlv::CallConfigList>((unsigned char **)a2, (_DWORD *)(a1 + 16));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallConfigList>::clone()
{
}

void sub_2224E9C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<vs::tlv::CallConfigItem>::__destroy_vector::operator()[abi:ne180100](&a9);
  MEMORY[0x223C9A950](v9, 0x10A1C403082B835);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::CallConfigItem>,vs::tlv::CallConfigItem*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void **)(a1 + 8);
    for (uint64_t i = **(void **)(a1 + 16); i != v3; i -= 48)
    {
      if (*(char *)(i - 1) < 0) {
        operator delete(*(void **)(i - 24));
      }
    }
  }
  return a1;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver19sendSRVCCCallConfigEN10subscriber7SimSlotEE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  uint64_t v3 = ***(NSObject ****)(a1 + 32);
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "Error in response when sending call context during handover. Code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I Successfully sent call context for handover", (uint8_t *)v4, 2u);
  }
}

uint64_t __copy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver19sendSRVCCCallConfigEN10subscriber7SimSlotEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver19sendSRVCCCallConfigEN10subscriber7SimSlotEE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendSRVCCCallConfig(subscriber::SimSlot)::$_1,std::allocator<EurekaCallCommandDriver::sendSRVCCCallConfig(subscriber::SimSlot)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D1A60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendSRVCCCallConfig(subscriber::SimSlot)::$_1,std::allocator<EurekaCallCommandDriver::sendSRVCCCallConfig(subscriber::SimSlot)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D1A60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t ___ZN3ctu20SharedSynchronizableI17CallCommandDriverE13connect_eventIN5event11EventLoggerIFvvENS4_14CSIEventLoggerEEE23EurekaCallCommandDrivervJEEEDTcl7connectfp_cvNSt3__110shared_ptrIS1_EE_EcvP16dispatch_queue_s_EcvPFT1_DpT2_ELi0EEERT_MT0_FSF_SH_E_block_invoke(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t boost::signals2::slot<void ()(void),boost::function<void ()(void)>>::~slot(uint64_t a1)
{
  boost::function0<void>::~function0((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100](&v3);
  return a1;
}

uint64_t boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::operator->(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::operator->(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::nolock_cleanup_connections_from(uint64_t *a1, void *a2, uint64_t **a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  uint64_t v7 = *a3;
  uint64_t v8 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::operator->(*a1);
  uint64_t result = boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::operator*(*v8);
  if ((uint64_t *)result != v7)
  {
    unsigned int v10 = 0;
    unsigned int v11 = a4 - 1;
    int v12 = v7;
    unsigned int v35 = v11;
    do
    {
      uint64_t v13 = v12[2];
      boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::operator->(v13);
      int v14 = *(boost::signals2::slot_base **)(v13 + 32);
      if (v14 && boost::signals2::slot_base::expired(v14) && *(unsigned char *)(v13 + 24))
      {
        *(unsigned char *)(v13 + 24) = 0;
        boost::signals2::detail::connection_body_base::dec_slot_refcount<boost::signals2::mutex>((_DWORD *)v13, a2);
      }
      if (*(unsigned char *)(boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::operator->(v12[2])
                    + 24))
      {
        uint64_t v7 = (uint64_t *)v12[1];
      }
      else
      {
        uint64_t v15 = *(void *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::operator->(*a1);
        boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::operator*(v15);
        uint64_t v16 = boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::operator->(v12[2]);
        if (v12 == (uint64_t *)v15) {
          __assert_rtn("erase", "slot_groups.hpp", 148, "it != _list.end()");
        }
        uint64_t v17 = (uint64_t *)(v15 + 32);
        int v18 = *(void **)(v15 + 32);
        if (!v18) {
          goto LABEL_41;
        }
        uint64_t v19 = v16 + 64;
        __int16 v38 = (uint64_t **)(v15 + 24);
        long long v20 = (uint64_t *)(v15 + 32);
        do
        {
          BOOL v21 = boost::signals2::detail::group_key_less<int,std::less<int>>::operator()(v15 + 48, (uint64_t)(v18 + 4), v19);
          int v22 = v18 + 1;
          if (!v21)
          {
            int v22 = v18;
            long long v20 = v18;
          }
          int v18 = (void *)*v22;
        }
        while (*v22);
        if (v20 == v17) {
LABEL_41:
        }
          __assert_rtn("erase", "slot_groups.hpp", 150, "map_it != _group_map.end()");
        if (!boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>::weakly_equivalent(v15, (uint64_t)(v20 + 4), v19))__assert_rtn("erase", "slot_groups.hpp", 151, "weakly_equivalent(map_it->first, key)"); {
        if ((uint64_t *)v20[6] == v12)
        }
        {
          uint64_t v37 = v12[1];
          char v23 = (void *)*v17;
          uint64_t v24 = v15;
          if (*v17)
          {
            char v25 = (uint64_t *)(v15 + 32);
            do
            {
              BOOL v26 = boost::signals2::detail::group_key_less<int,std::less<int>>::operator()(v15 + 48, v19, (uint64_t)(v23 + 4));
              uint64_t v27 = v23 + 1;
              if (v26)
              {
                uint64_t v27 = v23;
                char v25 = v23;
              }
              char v23 = (void *)*v27;
            }
            while (*v27);
            uint64_t v24 = v15;
            if (v25 != v17) {
              uint64_t v24 = v25[6];
            }
          }
          if (v37 == v24)
          {
            std::__tree<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>,std::__map_value_compare<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>,boost::signals2::detail::group_key_less<int,std::less<int>>,false>,std::allocator<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>>>::__remove_node_pointer(v38, v20);
            operator delete(v20);
            unsigned int v11 = v35;
          }
          else
          {
            uint64_t v39 = 0;
            char v28 = (void **)std::__tree<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>,std::__map_value_compare<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>,boost::signals2::detail::group_key_less<int,std::less<int>>,false>,std::allocator<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>>>::__find_equal<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>>((uint64_t)v38, &v39, v19);
            int v29 = *v28;
            unsigned int v11 = v35;
            if (!*v28)
            {
              uint64_t v30 = (uint64_t **)v28;
              int v29 = operator new(0x38uLL);
              int v31 = *(_DWORD *)(v19 + 8);
              std::string v29[4] = *(void *)v19;
              *((_DWORD *)v29 + 10) = v31;
              v29[6] = 0;
              std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(v38, v39, v30, v29);
            }
            v29[6] = v37;
          }
        }
        uint64_t v32 = *v12;
        uint64_t v7 = (uint64_t *)v12[1];
        *(void *)(v32 + 8) = v7;
        *(void *)v12[1] = v32;
        --*(void *)(v15 + 16);
        boost::detail::shared_count::~shared_count((atomic_uint **)v12 + 3);
        operator delete(v12);
      }
      ++v10;
      char v33 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::operator->(*a1);
      uint64_t result = boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::operator*(*v33);
      BOOL v34 = v7 != (uint64_t *)result && v11 >= v10;
      int v12 = v7;
    }
    while (v34);
  }
  a1[2] = (uint64_t)v7;
  return result;
}

void boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::~sp_counted_impl_p()
{
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::dispose(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    boost::detail::shared_count::~shared_count((atomic_uint **)(v1 + 24));
    boost::detail::shared_count::~shared_count((atomic_uint **)(v1 + 8));
    JUMPOUT(0x223C9A950);
  }
  return result;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::get_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::get_local_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::get_untyped_deleter()
{
  return 0;
}

void boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::~sp_counted_impl_p()
{
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::dispose(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*(void **)(v1 + 32));
    std::__list_imp<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>::clear((atomic_uint **)v1);
    JUMPOUT(0x223C9A950);
  }
  return result;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::get_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::get_local_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::get_untyped_deleter()
{
  return 0;
}

uint64_t boost::shared_ptr<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>::operator*(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

BOOL boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>::weakly_equivalent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1 + 56;
  return !boost::signals2::detail::group_key_less<int,std::less<int>>::operator()(a1 + 56, a2, a3)
      && !boost::signals2::detail::group_key_less<int,std::less<int>>::operator()(v5, a3, a2);
}

uint64_t *std::__tree<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>,std::__map_value_compare<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>,boost::signals2::detail::group_key_less<int,std::less<int>>,false>,std::allocator<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      uint64_t v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      uint64_t v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  uint64_t v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  return std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
}

void boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>::~connection_body(uint64_t a1)
{
  boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>::~connection_body(a1);

  JUMPOUT(0x223C9A950);
}

BOOL boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>::connected(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  long long v8 = 0u;
  memset(v7, 0, sizeof(v7));
  uint64_t v2 = (pthread_mutex_t *)boost::shared_ptr<boost::signals2::mutex>::operator*((uint64_t *)(a1 + 48));
  boost::signals2::detail::garbage_collecting_lock<boost::signals2::mutex>::garbage_collecting_lock(v7, v2);
  uint64_t v3 = *(_DWORD ***)(a1 + 32);
  if (v3)
  {
    for (uint64_t i = *v3;
          i != *(_DWORD **)(boost::shared_ptr<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>::operator*((uint64_t)v3)
                          + 8);
          i += 6)
    {
      memset(v9, 0, sizeof(v9));
      boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::apply_visitor<boost::signals2::detail::lock_weak_ptr_visitor const>(i, (uint64_t)v9);
      if (boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::apply_visitor<boost::signals2::detail::expired_weak_ptr_visitor const>((uint64_t)i))
      {
        if (*(unsigned char *)(a1 + 24))
        {
          *(unsigned char *)(a1 + 24) = 0;
          boost::signals2::detail::connection_body_base::dec_slot_refcount<boost::signals2::mutex>((_DWORD *)a1, v7);
        }
        boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::destroy_content((uint64_t)v9);
        break;
      }
      boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::destroy_content((uint64_t)v9);
      uint64_t v3 = *(_DWORD ***)(a1 + 32);
    }
  }
  int v5 = *(unsigned __int8 *)(a1 + 24);
  boost::signals2::mutex::unlock(*((pthread_mutex_t **)&v8 + 1));
  boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(v7);
  return v5 != 0;
}

void sub_2224EA664(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::destroy_content(v3 - 64);
  boost::signals2::detail::garbage_collecting_lock<boost::signals2::mutex>::~garbage_collecting_lock((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>::lock(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)boost::shared_ptr<boost::signals2::mutex>::operator->(*(void *)(a1 + 48));

  return boost::signals2::mutex::lock(v1);
}

uint64_t boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>::unlock(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)boost::shared_ptr<boost::signals2::mutex>::operator->(*(void *)(a1 + 48));

  return boost::signals2::mutex::unlock(v1);
}

void boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>::release_slot(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v6 + 1) = *((void *)&v5 + 1);
  boost::detail::shared_count::~shared_count((atomic_uint **)&v6 + 1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>>(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(24 * a1);
}

uint64_t boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::variant(uint64_t a1, uint64_t a2)
{
  switch(*(_DWORD *)a2 ^ (*(int *)a2 >> 31))
  {
    case 0:
    case 1:
      uint64_t v4 = *(void *)(a2 + 16);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)(a1 + 16) = v4;
      if (v4) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 12), 1u, memory_order_relaxed);
      }
      break;
    case 2:
      uint64_t v5 = boost::scoped_ptr<boost::signals2::detail::foreign_weak_ptr_impl_base>::operator->((uint64_t *)(a2 + 8));
      *(void *)(a1 + 8) = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(v5);
      break;
    default:
      boost::detail::variant::forced_return<void>();
  }
  *(_DWORD *)a1 = *(_DWORD *)a2 ^ (*(int *)a2 >> 31);
  return a1;
}

{
  uint64_t *v3;
  int v4;
  uint64_t v6;

  uint64_t v3 = (uint64_t *)(a2 + 8);
  switch(*(_DWORD *)a2 ^ (*(int *)a2 >> 31))
  {
    case 0:
      uint64_t v4 = 0;
      *(_OWORD *)(a1 + 8) = *(_OWORD *)v3;
      uint64_t *v3 = 0;
      *(void *)(a2 + 16) = 0;
      break;
    case 1:
      *(_OWORD *)(a1 + 8) = *(_OWORD *)v3;
      uint64_t *v3 = 0;
      *(void *)(a2 + 16) = 0;
      uint64_t v4 = 1;
      break;
    case 2:
      long long v6 = boost::scoped_ptr<boost::signals2::detail::foreign_weak_ptr_impl_base>::operator->(v3);
      *(void *)(a1 + 8) = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 32))(v6);
      uint64_t v4 = *(_DWORD *)a2 ^ (*(int *)a2 >> 31);
      break;
    default:
      boost::detail::variant::forced_return<void>();
  }
  *(_DWORD *)a1 = v4;
  return a1;
}

void boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)a1 ^ (*(int *)a1 >> 31);
  if (v1 == 2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    if (v3)
    {
      uint64_t v4 = *(void (**)(void))(*(void *)v3 + 8);
      v4();
    }
  }
  else
  {
    if (v1 > 1) {
      boost::detail::variant::forced_return<void>();
    }
    uint64_t v2 = (atomic_uint **)(a1 + 16);
    boost::detail::weak_count::~weak_count(v2);
  }
}

void std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  unsigned int v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 24;
        boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t boost::checked_delete<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>(uint64_t result)
{
  if (result)
  {
    unsigned int v1 = (void **)result;
    boost::function0<void>::~function0((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100](&v2);
    JUMPOUT(0x223C9A950);
  }
  return result;
}

void boost::detail::sp_counted_impl_p<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>::~sp_counted_impl_p()
{
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>::dispose(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    boost::function0<void>::~function0((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100](&v2);
    JUMPOUT(0x223C9A950);
  }
  return result;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>::get_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>::get_local_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>::get_untyped_deleter()
{
  return 0;
}

uint64_t boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>::~connection_body(uint64_t a1)
{
  *(void *)a1 = &unk_26D4D1B70;
  boost::detail::shared_count::~shared_count((atomic_uint **)(a1 + 56));
  boost::detail::shared_count::~shared_count((atomic_uint **)(a1 + 40));
  *(void *)a1 = &unk_26D4D1BD8;
  boost::detail::weak_count::~weak_count((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t boost::shared_ptr<boost::signals2::mutex>::operator->(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

void boost::detail::sp_counted_impl_p<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::~sp_counted_impl_p()
{
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::dispose(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::get_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::get_local_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::get_untyped_deleter()
{
  return 0;
}

uint64_t boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::operator*(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

NSObject **ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot(NSObject **a1, NSObject *a2, void *aBlock)
{
  *a1 = a2;
  if (aBlock)
  {
    uint64_t v4 = _Block_copy(aBlock);
    a2 = *a1;
  }
  else
  {
    uint64_t v4 = 0;
  }
  a1[1] = v4;
  dispatch_retain(a2);
  return a1;
}

uint64_t boost::detail::function::functor_manager<ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>>::manage(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot((NSObject **)a2, *(NSObject **)result, *(void **)(result + 8));
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvvEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvvEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

void boost::detail::function::void_function_obj_invoker0<ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>,void>::invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 8);
  if (v1 && (v2 = _Block_copy(v1)) != 0 && (uint64_t v3 = _Block_copy(v2), (v4 = v3) != 0))
  {
    uint64_t v5 = _Block_copy(v3);
    uint64_t v6 = v5;
    if (v5)
    {
      uint64_t v7 = _Block_copy(v5);
      long long v8 = v7;
      if (v7)
      {
        uint64_t v9 = _Block_copy(v7);
        uint64_t v10 = v9;
        if (v9)
        {
          unsigned int v11 = _Block_copy(v9);
          int v12 = v11;
          if (v11)
          {
            *(void *)&long long v14 = _Block_copy(v11);
            _Block_release(v12);
          }
          else
          {
            *(void *)&long long v14 = 0;
          }
          _Block_release(v10);
        }
        else
        {
          *(void *)&long long v14 = 0;
        }
        _Block_release(v8);
      }
      else
      {
        *(void *)&long long v14 = 0;
      }
      uint64_t v13 = boost::function0<void>::assign_to<dispatch::block<void({block_pointer})(void)>>(dispatch::block<void({block_pointer})(void)>)::stored_vtable;
      _Block_release(v6);
    }
    else
    {
      uint64_t v13 = boost::function0<void>::assign_to<dispatch::block<void({block_pointer})(void)>>(dispatch::block<void({block_pointer})(void)>)::stored_vtable;
      *(void *)&long long v14 = 0;
    }
    _Block_release(v4);
  }
  else
  {
    uint64_t v13 = boost::function0<void>::assign_to<dispatch::block<void({block_pointer})(void)>>(dispatch::block<void({block_pointer})(void)>)::stored_vtable;
    *(void *)&long long v14 = 0;
  }
  operator new();
}

void sub_2224EAF6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MEMORY[0x223C9A950](v3, 0x10E2C406E9A86C3);
  boost::function0<void>::~function0((uint64_t *)va);
  if ((v4 & 1) == 0) {
    _Block_release(v2);
  }
  _Unwind_Resume(a1);
}

uint64_t *___Z13execute_blockP16dispatch_queue_sRKN5boost8functionIFvvEEE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (!*v1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&unk_26D4CB870;
    boost::throw_exception<boost::bad_function_call>(&v4);
  }
  (*(void (**)(void *))((*v1 & 0xFFFFFFFFFFFFFFFELL) + 8))(v1 + 1);
  uint64_t result = *(uint64_t **)(a1 + 32);
  if (result)
  {
    boost::function0<void>::~function0(result);
    JUMPOUT(0x223C9A950);
  }
  return result;
}

void sub_2224EB078(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void boost::detail::function::functor_manager<dispatch::block<void({block_pointer})(void)>>::manage(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      long long v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvvEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvvEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else
    {
      if (a3 != 2)
      {
LABEL_2:
        a2[4] = 0;
        return;
      }
      uint64_t v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_9:
      }
        _Block_release(v7);
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      uint64_t v7 = *a1;
      if (*a1) {
        goto LABEL_9;
      }
    }
  }
}

uint64_t boost::detail::function::void_function_obj_invoker0<dispatch::block<void({block_pointer})(void)>,void>::invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t boost::function0<void>::move_assign(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    uint64_t *v2 = 0;
  }
  return result;
}

void sub_2224EB214(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_rethrow();
}

void sub_2224EB224(_Unwind_Exception *a1)
{
}

uint64_t *boost::function0<void>::~function0(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t std::__split_buffer<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content(i - 24);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *boost::signals2::detail::foreign_weak_ptr_impl<std::weak_ptr<CallCommandDriver>>::~foreign_weak_ptr_impl(void *a1)
{
  *a1 = &unk_26D4D1D18;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void boost::signals2::detail::foreign_weak_ptr_impl<std::weak_ptr<CallCommandDriver>>::~foreign_weak_ptr_impl(void *a1)
{
  *a1 = &unk_26D4D1D18;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  JUMPOUT(0x223C9A950);
}

void boost::signals2::detail::foreign_weak_ptr_impl<std::weak_ptr<CallCommandDriver>>::lock(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_2224EB554(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL boost::signals2::detail::foreign_weak_ptr_impl<std::weak_ptr<CallCommandDriver>>::expired(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void boost::signals2::detail::foreign_weak_ptr_impl<std::weak_ptr<CallCommandDriver>>::clone()
{
}

void *boost::signals2::detail::foreign_shared_ptr_impl<std::shared_ptr<CallCommandDriver>>::~foreign_shared_ptr_impl(void *a1)
{
  *a1 = &unk_26D4D1D78;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  return a1;
}

void boost::signals2::detail::foreign_shared_ptr_impl<std::shared_ptr<CallCommandDriver>>::~foreign_shared_ptr_impl(void *a1)
{
  *a1 = &unk_26D4D1D78;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }

  JUMPOUT(0x223C9A950);
}

void boost::signals2::detail::foreign_shared_ptr_impl<std::shared_ptr<CallCommandDriver>>::clone()
{
}

uint64_t ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void std::__function::__func<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::~__func()
{
}

void *std::__function::__func<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D1DC8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D1DC8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)(a1 + 8);
  uint64_t result = xpc::dyn_cast_or_default();
  *uint64_t v1 = result;
  return result;
}

uint64_t std::__function::__func<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::target_type()
{
}

void std::__function::__func<void ctu::rest::property_sink_t<rest::rats>::bind_impl<void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&),EurekaCallCommandDriver>(ctu::RestModule &,EurekaCallCommandDriver *,void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&) &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::~__func()
{
}

__n128 std::__function::__func<void ctu::rest::property_sink_t<rest::rats>::bind_impl<void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&),EurekaCallCommandDriver>(ctu::RestModule &,EurekaCallCommandDriver *,void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&) &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_26D4D1E48;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<void ctu::rest::property_sink_t<rest::rats>::bind_impl<void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&),EurekaCallCommandDriver>(ctu::RestModule &,EurekaCallCommandDriver *,void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&) &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26D4D1E48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<void ctu::rest::property_sink_t<rest::rats>::bind_impl<void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&),EurekaCallCommandDriver>(ctu::RestModule &,EurekaCallCommandDriver *,void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&) &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::operator()(void *a1, void *a2)
{
  uint64_t v3 = a1[1];
  uint64_t v5 = (uint64_t **)(v3 + 8);
  uint64_t v4 = *(void **)(v3 + 8);
  uint64_t v30 = *(uint64_t **)v3;
  int v31 = v4;
  if (*(void *)(v3 + 16))
  {
    _DWORD v4[2] = &v31;
    *(void *)uint64_t v3 = v5;
    *uint64_t v5 = 0;
    *(void *)(v3 + 16) = 0;
  }
  else
  {
    uint64_t v30 = (uint64_t *)&v31;
  }
  xpc_object_t v6 = (xpc_object_t)*a2;
  uint64_t v7 = MEMORY[0x263EF86D8];
  if (*a2 && MEMORY[0x223C9AD60](*a2) == v7) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t v6 = xpc_null_create();
  }
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy(v3, *(void **)(v3 + 8));
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  *(void *)uint64_t v3 = v5;
  if (MEMORY[0x223C9AD60](v6) == v7)
  {
    xpc_object_t object = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    xpc::array::iterator::iterator(&v36, &object, 0);
    xpc_release(object);
    xpc_object_t object = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    if (MEMORY[0x223C9AD60](v6) == v7) {
      count = (void *)xpc_array_get_count(v6);
    }
    else {
      count = 0;
    }
    xpc::array::iterator::iterator(&v34, &object, count);
    xpc_release(object);
    xpc_object_t v9 = v36;
    size_t v10 = index;
    if (index != v35 || v36 != v34)
    {
      while (1)
      {
        xpc_object_t v33 = 0;
        xpc::array::object_proxy::operator xpc::dict(&v33, v9, v10);
        xpc_object_t v11 = v33;
        uint64_t v12 = MEMORY[0x223C9AD60](v33);
        uint64_t v13 = MEMORY[0x263EF8708];
        if (v12 == MEMORY[0x263EF8708]) {
          break;
        }
LABEL_54:
        xpc_release(v33);
        xpc_object_t v9 = v36;
        size_t v10 = index + 1;
        size_t index = v10;
        if (v10 == v35 && v36 == v34) {
          goto LABEL_59;
        }
      }
      if (v11)
      {
        xpc_retain(v11);
        xpc_object_t v41 = v11;
      }
      else
      {
        xpc_object_t v11 = xpc_null_create();
        xpc_object_t v41 = v11;
        if (!v11)
        {
          xpc_object_t v14 = xpc_null_create();
          xpc_object_t v11 = 0;
          goto LABEL_28;
        }
      }
      if (MEMORY[0x223C9AD60](v11) == v13)
      {
        xpc_retain(v11);
        xpc_object_t v14 = v41;
        goto LABEL_29;
      }
      xpc_object_t v14 = xpc_null_create();
LABEL_28:
      xpc_object_t v41 = v14;
LABEL_29:
      if (MEMORY[0x223C9AD60](v14) == v13)
      {
        xpc_object_t object = &v41;
        uint64_t v39 = "first";
        xpc::dict::object_proxy::operator xpc::object((uint64_t)&object, &v40);
        uint64_t v17 = MEMORY[0x223C9AD60](v40);
        uint64_t v18 = MEMORY[0x263EF8798];
        uint64_t v19 = MEMORY[0x263EF86E0];
        if (v17 == MEMORY[0x263EF8798])
        {
          int v42 = 0;
          ctu::rest::detail::read_enum_string_value();
          int v16 = v42;
        }
        else if (v17 == MEMORY[0x263EF86E0] || v17 == MEMORY[0x263EF8738] || v17 == MEMORY[0x263EF87A0])
        {
          int v16 = xpc::dyn_cast_or_default();
        }
        else
        {
          int v16 = 0;
        }
        xpc_release(v40);
        xpc_object_t object = &v41;
        uint64_t v39 = "second";
        xpc::dict::object_proxy::operator xpc::object((uint64_t)&object, &v40);
        uint64_t v20 = MEMORY[0x223C9AD60](v40);
        if (v20 == v18)
        {
          int v42 = 0;
          ctu::rest::detail::read_enum_string_value();
          int v15 = v42;
        }
        else if (v20 == v19 || v20 == MEMORY[0x263EF8738] || v20 == MEMORY[0x263EF87A0])
        {
          int v15 = xpc::dyn_cast_or_default();
        }
        else
        {
          int v15 = 0;
        }
        xpc_release(v40);
      }
      else
      {
        int v15 = 0;
        int v16 = 0;
      }
      xpc_release(v41);
      xpc_release(v11);
      BOOL v21 = *v5;
      int v22 = (uint64_t **)(v3 + 8);
      char v23 = (uint64_t **)(v3 + 8);
      if (*v5)
      {
        while (1)
        {
          while (1)
          {
            char v23 = (uint64_t **)v21;
            int v24 = *((_DWORD *)v21 + 7);
            if (v24 <= v16) {
              break;
            }
            BOOL v21 = *v23;
            int v22 = v23;
            if (!*v23) {
              goto LABEL_53;
            }
          }
          if (v24 >= v16) {
            break;
          }
          BOOL v21 = v23[1];
          if (!v21)
          {
            int v22 = v23 + 1;
            goto LABEL_53;
          }
        }
      }
      else
      {
LABEL_53:
        char v25 = (uint64_t *)operator new(0x28uLL);
        *((_DWORD *)v25 + 7) = v16;
        *((_DWORD *)v25 + 8) = v15;
        std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at((uint64_t **)v3, (uint64_t)v23, v22, v25);
      }
      goto LABEL_54;
    }
LABEL_59:
    xpc_release(v9);
    xpc_release(v36);
  }
  xpc_release(v6);
  uint64_t v27 = (void (*)(void *, uint64_t **))a1[3];
  uint64_t v28 = a1[4];
  int v29 = (void *)(a1[2] + (v28 >> 1));
  if (v28) {
    uint64_t v27 = *(void (**)(void *, uint64_t **))(*v29 + v27);
  }
  v27(v29, &v30);
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy((uint64_t)&v30, v31);
}

void sub_2224EBD58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, xpc_object_t a13, xpc_object_t a14, uint64_t a15, xpc_object_t a16, uint64_t a17, xpc_object_t object, uint64_t a19, xpc_object_t a20)
{
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(a16);
  xpc_release(v20);
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void ctu::rest::property_sink_t<rest::rats>::bind_impl<void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&),EurekaCallCommandDriver>(ctu::RestModule &,EurekaCallCommandDriver *,void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&) &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void ctu::rest::property_sink_t<rest::rats>::bind_impl<void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&),EurekaCallCommandDriver>(ctu::RestModule &,EurekaCallCommandDriver *,void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&) &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::target_type()
{
}

void xpc::array::object_proxy::operator xpc::dict(void *a1, xpc_object_t xarray, size_t index)
{
  xpc_object_t value = xpc_array_get_value(xarray, index);
  if (value)
  {
    xpc_object_t v5 = value;
    xpc_retain(value);
    *a1 = v5;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    *a1 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (MEMORY[0x223C9AD60](v5) != MEMORY[0x263EF8708])
  {
    xpc_object_t v6 = xpc_null_create();
LABEL_8:
    *a1 = v6;
    goto LABEL_9;
  }
  xpc_retain(v5);
LABEL_9:
  xpc_release(v5);
}

void std::__function::__func<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::~__func()
{
}

void *std::__function::__func<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D1EC8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D1EC8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  xpc_object_t v3 = (xpc_object_t)*a2;
  uint64_t v4 = MEMORY[0x263EF86D8];
  if (*a2 && MEMORY[0x223C9AD60](*a2) == v4) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  xpc_object_t v5 = (uint64_t **)(v2 + 8);
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy(v2, *(void **)(v2 + 8));
  *(void *)uint64_t v2 = v2 + 8;
  *(void *)(v2 + 16) = 0;
  *(void *)(v2 + 8) = 0;
  if (MEMORY[0x223C9AD60](v3) == v4)
  {
    xpc_object_t object = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    xpc::array::iterator::iterator(&v28, &object, 0);
    xpc_release(object);
    xpc_object_t object = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    if (MEMORY[0x223C9AD60](v3) == v4) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    xpc::array::iterator::iterator(&v26, &object, count);
    xpc_release(object);
    xpc_object_t v7 = v28;
    size_t v8 = index;
    if (index != v27 || v28 != v26)
    {
      while (1)
      {
        xpc_object_t v25 = 0;
        xpc::array::object_proxy::operator xpc::dict(&v25, v7, v8);
        xpc_object_t v9 = v25;
        uint64_t v10 = MEMORY[0x223C9AD60](v25);
        uint64_t v11 = MEMORY[0x263EF8708];
        if (v10 == MEMORY[0x263EF8708]) {
          break;
        }
LABEL_51:
        xpc_release(v25);
        xpc_object_t v7 = v28;
        size_t v8 = index + 1;
        size_t index = v8;
        if (v8 == v27 && v28 == v26) {
          goto LABEL_56;
        }
      }
      if (v9)
      {
        xpc_retain(v9);
        xpc_object_t v33 = v9;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v33 = v9;
        if (!v9)
        {
          xpc_object_t v12 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_25;
        }
      }
      if (MEMORY[0x223C9AD60](v9) == v11)
      {
        xpc_retain(v9);
        xpc_object_t v12 = v33;
        goto LABEL_26;
      }
      xpc_object_t v12 = xpc_null_create();
LABEL_25:
      xpc_object_t v33 = v12;
LABEL_26:
      if (MEMORY[0x223C9AD60](v12) == v11)
      {
        xpc_object_t object = &v33;
        int v31 = "first";
        xpc::dict::object_proxy::operator xpc::object((uint64_t)&object, &v32);
        uint64_t v15 = MEMORY[0x223C9AD60](v32);
        uint64_t v16 = MEMORY[0x263EF8798];
        uint64_t v17 = MEMORY[0x263EF86E0];
        if (v15 == MEMORY[0x263EF8798])
        {
          int v34 = 0;
          ctu::rest::detail::read_enum_string_value();
          int v14 = v34;
        }
        else if (v15 == MEMORY[0x263EF86E0] || v15 == MEMORY[0x263EF8738] || v15 == MEMORY[0x263EF87A0])
        {
          int v14 = xpc::dyn_cast_or_default();
        }
        else
        {
          int v14 = 0;
        }
        xpc_release(v32);
        xpc_object_t object = &v33;
        int v31 = "second";
        xpc::dict::object_proxy::operator xpc::object((uint64_t)&object, &v32);
        uint64_t v18 = MEMORY[0x223C9AD60](v32);
        if (v18 == v16)
        {
          int v34 = 0;
          ctu::rest::detail::read_enum_string_value();
          int v13 = v34;
        }
        else if (v18 == v17 || v18 == MEMORY[0x263EF8738] || v18 == MEMORY[0x263EF87A0])
        {
          int v13 = xpc::dyn_cast_or_default();
        }
        else
        {
          int v13 = 0;
        }
        xpc_release(v32);
      }
      else
      {
        int v13 = 0;
        int v14 = 0;
      }
      xpc_release(v33);
      xpc_release(v9);
      uint64_t v19 = *v5;
      uint64_t v20 = (uint64_t **)(v2 + 8);
      BOOL v21 = (uint64_t **)(v2 + 8);
      if (*v5)
      {
        while (1)
        {
          while (1)
          {
            BOOL v21 = (uint64_t **)v19;
            int v22 = *((_DWORD *)v19 + 7);
            if (v22 <= v14) {
              break;
            }
            uint64_t v19 = *v21;
            uint64_t v20 = v21;
            if (!*v21) {
              goto LABEL_50;
            }
          }
          if (v22 >= v14) {
            break;
          }
          uint64_t v19 = v21[1];
          if (!v19)
          {
            uint64_t v20 = v21 + 1;
            goto LABEL_50;
          }
        }
      }
      else
      {
LABEL_50:
        char v23 = (uint64_t *)operator new(0x28uLL);
        *((_DWORD *)v23 + 7) = v14;
        *((_DWORD *)v23 + 8) = v13;
        std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at((uint64_t **)v2, (uint64_t)v21, v20, v23);
      }
      goto LABEL_51;
    }
LABEL_56:
    xpc_release(v7);
    xpc_release(v28);
  }
  xpc_release(v3);
}

void sub_2224EC384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t a10, uint64_t a11, xpc_object_t a12, uint64_t a13, xpc_object_t object, uint64_t a15, xpc_object_t a16, xpc_object_t a17)
{
  xpc_release(object);
  xpc_release(a12);
  xpc_release(v17);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::target_type()
{
}

uint64_t qmi::MessageBase::applyTlv<vs::tlv::USSInfo,void({block_pointer})(vs::tlv::USSInfo const&)>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    uint64_t v8 = result;
    int v9 = v7;
    unint64_t v15 = result;
    *(_OWORD *)std::string __p = 0u;
    long long v14 = 0u;
    tlv::parseV<vs::tlv::USSInfo>(&v15, v7, __p);
    unint64_t v10 = v15;
    if (v15) {
      (*(void (**)(void))(*(void *)a3 + 16))();
    }
    if (__p[1])
    {
      *(void **)&long long v14 = __p[1];
      operator delete(__p[1]);
    }
    if (v10)
    {
      return 1;
    }
    else
    {
      uint64_t v11 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v12 = *(unsigned __int16 *)a1;
      return v11(v12, a2, v8, v9);
    }
  }
  return result;
}

void sub_2224EC58C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t qmi::MessageBase::applyTlv<vs::tlv::UTF16Data,void({block_pointer})(vs::tlv::UTF16Data const&)>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    uint64_t v8 = result;
    int v9 = v7;
    uint64_t v15 = 0;
    unint64_t v16 = result;
    std::string __p = 0;
    long long v14 = 0;
    tlv::parseV<vs::tlv::UTF16Data>(&v16, v7, (uint64_t)&__p);
    unint64_t v10 = v16;
    if (v16) {
      (*(void (**)(void))(*(void *)a3 + 16))();
    }
    if (__p)
    {
      long long v14 = __p;
      operator delete(__p);
    }
    if (v10)
    {
      return 1;
    }
    else
    {
      uint64_t v11 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v12 = *(unsigned __int16 *)a1;
      return v11(v12, a2, v8, v9);
    }
  }
  return result;
}

void sub_2224EC684(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    unint64_t v8 = result;
    int v9 = v7;
    if (qmi::MessageBase::tryTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>((uint64_t)a1, result, v7, a3))
    {
      return 1;
    }
    else
    {
      unint64_t v10 = (uint64_t (*)(uint64_t, uint64_t, unint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v11 = *(unsigned __int16 *)a1;
      return v10(v11, a2, v8, v9);
    }
  }
  return result;
}

BOOL qmi::MessageBase::tryTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>(uint64_t a1, unint64_t a2, int a3, uint64_t a4)
{
  unint64_t v7 = a2;
  tlv::parseV<vs::tlv::FailureCause>(&v7, a3);
  unint64_t v5 = v7;
  if (v7) {
    (*(void (**)(void))(*(void *)a4 + 16))();
  }
  return v5 != 0;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver17cancelUssdSessionEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v2 = **(os_log_t ***)(a1 + 32);
  xpc_object_t v3 = *v2;
  if (*(_DWORD *)(a2 + 4))
  {
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = qmi::asString();
      int v6 = *(_DWORD *)(a2 + 4);
      int v7 = 136315394;
      uint64_t v8 = v5;
      __int16 v9 = 1024;
      int v10 = v6;
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "USSD Session cancelling failed with error code %s (0x%x)", (uint8_t *)&v7, 0x12u);
    }
  }
  else if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v7) = 0;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N USSD Session successfully cancelled", (uint8_t *)&v7, 2u);
  }
}

uint64_t __copy_helper_block_e8_32c100_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17cancelUssdSessionEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c100_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17cancelUssdSessionEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::cancelUssdSession(subscriber::SimSlot)::$_0,std::allocator<EurekaCallCommandDriver::cancelUssdSession(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D1F78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::cancelUssdSession(subscriber::SimSlot)::$_0,std::allocator<EurekaCallCommandDriver::cancelUssdSession(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D1F78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs10CancelUSSD8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224ECA18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

char *qmi::MutableMessageBase::getTLV<vs::tlv::USSInfo>(uint64_t a1)
{
  uint64_t v1 = *(const void ***)(a1 + 8);
  uint64_t v2 = *(const void ***)(a1 + 16);
  if (v1 != v2)
  {
    while (*((unsigned char *)*v1 + 8) != 1)
    {
      if (++v1 == v2) {
        goto LABEL_8;
      }
    }
  }
  if (v1 == v2) {
LABEL_8:
  }
    operator new();
  if (!v3) {
    __cxa_bad_cast();
  }
  return v3 + 16;
}

void *qmi::MutableMessageBase::TlvWrapper<vs::tlv::USSInfo>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4D1FE0;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::USSInfo>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4D1FE0;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x223C9A950);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::USSInfo>::getSize(uint64_t a1)
{
  return tlv::size<vs::tlv::USSInfo>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<vs::tlv::USSInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  unint64_t result = tlv::writeV<vs::tlv::USSInfo>((unsigned char **)a2, a1 + 16);
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::USSInfo>::clone()
{
}

void sub_2224ECDBC(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x1091C40970CA704);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver17sendUSSDProcedureENSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  unsigned int v4 = *((_DWORD *)v2 + 2) - 1;
  uint64_t v5 = a2[1];
  v10[0] = *a2;
  v10[1] = v5;
  uint64_t v6 = a2[2];
  _DWORD v10[2] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  if (v4 >= 3) {
    unsigned int v4 = -1;
  }
  if (v4 < 3) {
    uint64_t v7 = v4 + 1;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 112) + 16))(*(void *)(v3 + 112), v7);
  if (HIDWORD(v10[0]))
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = qmi::asString();
      __int16 v12 = 1024;
      int v13 = HIDWORD(v10[0]);
      _os_log_error_impl(&dword_22231A000, v8, OS_LOG_TYPE_ERROR, "Send USSD failed with error code %s (0x%x)", buf, 0x12u);
    }
  }
  else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#I Successfully started USSD session from BB", buf, 2u);
  }
  uint64_t v9 = *(void *)(v3 + 120);
  std::string::basic_string[abi:ne180100]<0>(buf, (char *)&unk_222543CCE);
  (*(void (**)(uint64_t, unsigned char *, BOOL, BOOL))(*(void *)v9 + 152))(v9, buf, HIDWORD(v10[0]) != 0, HIDWORD(v10[0]) == 0);
  if (v14 < 0) {
    operator delete(*(void **)buf);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v10);
}

void sub_2224ECFA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c158_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17sendUSSDProcedureENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c158_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17sendUSSDProcedureENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendUSSDProcedure(std::string,subscriber::SimSlot)::$_0,std::allocator<EurekaCallCommandDriver::sendUSSDProcedure(std::string,subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2048;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendUSSDProcedure(std::string,subscriber::SimSlot)::$_0,std::allocator<EurekaCallCommandDriver::sendUSSDProcedure(std::string,subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2048;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs19OriginateUSSDNoWait8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224ED13C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver17sendUSSDUserReplyENSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *(NSObject **)v2[1];
  if (*(_DWORD *)(a2 + 4))
  {
    uint64_t v5 = *v2;
    if (os_log_type_enabled(*(os_log_t *)v2[1], OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = qmi::asString();
      int v7 = *(_DWORD *)(a2 + 4);
      int v8 = 136315394;
      uint64_t v9 = v6;
      __int16 v10 = 1024;
      int v11 = v7;
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "USSD Answer failed with error code %s (0x%x). Cancelling USSD Session.", (uint8_t *)&v8, 0x12u);
    }
    (*(void (**)(void))(**(void **)(v5 + 120) + 208))(*(void *)(v5 + 120));
  }
  else if (os_log_type_enabled(*(os_log_t *)v2[1], OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8) = 0;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N USSD Answer successfully completed", (uint8_t *)&v8, 2u);
  }
}

uint64_t __copy_helper_block_e8_32c158_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17sendUSSDUserReplyENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c158_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17sendUSSDUserReplyENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendUSSDUserReply(std::string,subscriber::SimSlot)::$_0,std::allocator<EurekaCallCommandDriver::sendUSSDUserReply(std::string,subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D20C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendUSSDUserReply(std::string,subscriber::SimSlot)::$_0,std::allocator<EurekaCallCommandDriver::sendUSSDUserReply(std::string,subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D20C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs10AnswerUSSD8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224ED420(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void std::allocate_shared[abi:ne180100]<EurekaC2KCallFormatter,std::allocator<EurekaC2KCallFormatter>,std::shared_ptr<Registry const> const&,dispatch::queue const&,std::shared_ptr<EurekaCallCommandDriver::DelegateBase> &,void>(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8 = operator new(0x60uLL);
  v8[1] = 0;
  _OWORD v8[2] = 0;
  *int v8 = &unk_26D4D2118;
  if (a5)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a5 + 8), 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = a4;
  uint64_t v10 = a5;
  EurekaCallFormatter::EurekaCallFormatter<EurekaCallCommandDriver::DelegateBase>(v8 + 3, a2, (uint64_t)"EurekaC2KCallFormatter");
}

void sub_2224ED5CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, dispatch_object_t object, dispatch_object_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  shared_weak_owners = (std::__shared_weak_count *)v19[3].__shared_weak_owners_;
  if (shared_weak_owners) {
    std::__shared_weak_count::__release_shared[abi:ne180100](shared_weak_owners);
  }
  EurekaCallFormatter::~EurekaCallFormatter(v21);
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  }
  std::__shared_weak_count::~__shared_weak_count(v19);
  operator delete(v24);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<EurekaC2KCallFormatter>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2118;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaC2KCallFormatter>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2118;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::__shared_ptr_emplace<EurekaC2KCallFormatter>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void EurekaCallFormatter::EurekaCallFormatter<EurekaCallCommandDriver::DelegateBase>(void *a1, void *a2, uint64_t a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v7, (const char *)*MEMORY[0x263F03770], (const char *)*MEMORY[0x263F036B0]);
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x223C99A30](v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v7);
  *a1 = &unk_26D4C51C8;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = *a2;
  uint64_t v6 = a2[1];
  a1[5] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  a1[6] = a3;
  operator new();
}

void sub_2224ED8A8(_Unwind_Exception *a1)
{
  uint64_t v5 = v4;
  (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(v1 + 40);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  int v8 = *(std::__shared_weak_count **)(v1 + 24);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  MEMORY[0x223C99A30](v2);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase> *,std::shared_ptr<EurekaCallFormatter::DelegateBase>::__shared_ptr_default_delete<EurekaCallFormatter::DelegateBase,EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>>,std::allocator<EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::__shared_ptr_pointer<EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase> *,std::shared_ptr<EurekaCallFormatter::DelegateBase>::__shared_ptr_default_delete<EurekaCallFormatter::DelegateBase,EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>>,std::allocator<EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase> *,std::shared_ptr<EurekaCallFormatter::DelegateBase>::__shared_ptr_default_delete<EurekaCallFormatter::DelegateBase,EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>>,std::allocator<EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::~FormatterDelegate(void *a1)
{
  *a1 = &unk_26D4D21E0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  return a1;
}

void EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::~FormatterDelegate(void *a1)
{
  *a1 = &unk_26D4D21E0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }

  JUMPOUT(0x223C9A950);
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleVoiceDialCallResp(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleCallActiveInd(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleCallHeldInd(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 104))();
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleCallEndInd(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)result + 64))(result, a2, 0);
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleMergedCalls(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 112))();
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleMergeCallsFailed(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 120))();
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::getTrafficChannelId(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 224))();
  }
  else {
    return *MEMORY[0x263F03540];
  }
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleCallHoldFailure(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 232))();
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleCallAnswerFailure(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 240))();
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::getNumberOfCurrentCalls(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 248))();
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::notifyCallCapabilities(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 192))();
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::setCallCapability(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 256))();
  }
  return result;
}

{
  uint64_t result;

  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 264))();
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleVoicePrivacySet(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 272))();
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handlePrivateConversation(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 136))();
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::setExpectDisconnectionOnAllCalls(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 280))();
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleCallDialedAndMediaInitializedInd(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleCallDialedInd(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void std::allocate_shared[abi:ne180100]<EurekaGSMCallFormatter,std::allocator<EurekaGSMCallFormatter>,std::shared_ptr<Registry const> const&,dispatch::queue const&,std::shared_ptr<EurekaCallCommandDriver::DelegateBase> &,void>(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = operator new(0x50uLL);
  v6[1] = 0;
  _OWORD v6[2] = 0;
  void *v6 = &unk_26D4D22A8;
  if (a4)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a4 + 8), 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a4 + 8), 1uLL, memory_order_relaxed);
  }
  EurekaCallFormatter::EurekaCallFormatter<EurekaCallCommandDriver::DelegateBase>(v6 + 3, a2, (uint64_t)"EurekaGSMCallFormatter");
}

void sub_2224EDF24(_Unwind_Exception *a1)
{
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v4);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<EurekaGSMCallFormatter>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D22A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaGSMCallFormatter>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D22A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::__shared_ptr_emplace<EurekaGSMCallFormatter>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t ___ZNK3ctu20SharedSynchronizableI17CallCommandDriverE15execute_wrappedEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t __copy_helper_block_e8_40c46_ZTSNSt3__110shared_ptrIK17CallCommandDriverEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_40c46_ZTSNSt3__110shared_ptrIK17CallCommandDriverEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void *std::__function::__value_func<void ()(vs::VoiceDialCall::Response const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver4dialE8CallInfoE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t *a2)
{
  _OWORD v20[3] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = a2[1];
  uint64_t v10 = *a2;
  uint64_t v11 = v3;
  uint64_t v4 = a2[2];
  uint64_t v12 = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  int64_t v5 = v2[9];
  if (v5)
  {
    uint64_t v6 = *v2;
    dispatch_time_t v7 = dispatch_time(0, v5);
    int v8 = *(NSObject **)(v6 + 24);
    block[0] = MEMORY[0x263EF8330];
    block[1] = 1174405120;
    block[2] = ___ZZN23EurekaCallCommandDriver4dialE8CallInfoENK3__1clEN3qmi12ResponseBaseE_block_invoke;
    char v14 = &__block_descriptor_tmp_341;
    uint64_t v15 = v2[1];
    uint64_t v16 = v2[2];
    uint64_t v9 = (std::__shared_weak_count *)v2[3];
    uint64_t v17 = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::__value_func[abi:ne180100]((uint64_t)v18, (uint64_t)(v2 + 4));
    long long v19 = *((_OWORD *)v2 + 4);
    v20[0] = v10;
    v20[1] = v11;
    void v20[2] = v12;
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
    }
    dispatch_after(v7, v8, block);
    qmi::MessageBase::~MessageBase((qmi::MessageBase *)v20);
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v18);
    if (v17) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v17);
    }
  }
  else
  {
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::__value_func[abi:ne180100]((uint64_t)block, (uint64_t)(v2 + 4));
    if (!v14) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(void *, uint64_t *))(*(void *)v14 + 48))(v14, &v10);
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](block);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&v10);
}

void sub_2224EE274(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
}

uint64_t __copy_helper_block_e8_32c73_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver4dialE8CallInfoE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c73_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver4dialE8CallInfoE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::dial(CallInfo)::$_1,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2360;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::dial(CallInfo)::$_1,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2360;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::dial(CallInfo)::$_1,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_1>>::__on_zero_shared(uint64_t a1)
{
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100]((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void ___ZNO3qmi6Client9SendProxy8callbackINS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224EE448(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *___ZZN23EurekaCallCommandDriver4dialE8CallInfoENK3__1clEN3qmi12ResponseBaseE_block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  uint64_t v2 = **(NSObject ***)(a1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I Delaying half a second and calling the dial response callback", v4, 2u);
  }
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::__value_func[abi:ne180100]((uint64_t)v4, a1 + 56);
  if (!v5) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 48))(v5, a1 + 104);
  return std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](v4);
}

void sub_2224EE554(_Unwind_Exception *exception_object)
{
}

uint64_t __copy_helper_block_e8_40c31_ZTS25EurekaVoiceRequestMessage104c25_ZTSKN3qmi12ResponseBaseE(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t result = std::__function::__value_func<void ()(qmi::ResponseBase const&)>::__value_func[abi:ne180100](a1 + 56, a2 + 56);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  uint64_t v6 = *(void *)(a2 + 120);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a1 + 120) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_2224EE5E0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c31_ZTS25EurekaVoiceRequestMessage104c25_ZTSKN3qmi12ResponseBaseE(void *a1)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)(a1 + 13));
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::~__value_func[abi:ne180100](a1 + 7);
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

uint64_t std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_26D4D23E0;
  CallInfo::~CallInfo((void **)(a1 + 16));
  return a1;
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_26D4D23E0;
  CallInfo::~CallInfo((void **)(a1 + 16));

  JUMPOUT(0x223C9A950);
}

void *std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x1B0uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_26D4D23E0;
  v2[1] = v3;
  CallInfo::CallInfo((CallInfo *)(v2 + 2), (const CallInfo *)(a1 + 16));
  *((_DWORD *)v2 + 106) = *(_DWORD *)(a1 + 424);
  return v2;
}

void sub_2224EE754(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26D4D23E0;
  *(void *)(a2 + 8) = v4;
  CallInfo::CallInfo((CallInfo *)(a2 + 16), (const CallInfo *)(a1 + 16));
  *(_DWORD *)(a2 + 424) = *(_DWORD *)(a1 + 424);
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::destroy(uint64_t a1)
{
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::destroy_deallocate(void **a1)
{
  CallInfo::~CallInfo(a1 + 2);

  operator delete(a1);
}

const void **std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::operator()(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v6, (const void **)(a1 + 16));
  EurekaCallCommandDriver::handleNormalVoiceDialResp(v4, a2, &v6, *(unsigned int *)(a1 + 424));
  return ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v6);
}

void sub_2224EE864(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::target_type()
{
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::EmergencyCategory>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::EmergencyCategory>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<vs::tlv::EmergencyCategory>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::EmergencyCategory>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::ClirType>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::ClirType>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<vs::tlv::ClirType>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::ClirType>::clone()
{
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIRNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEEEEOS1_OT__block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 24);
  if (!v1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);

  return v2();
}

uint64_t __copy_helper_block_e8_32c75_ZTSNSt3__110shared_ptrINS_8functionIFvRKN2vs13VoiceDialCall8ResponseEEEEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c75_ZTSNSt3__110shared_ptrINS_8functionIFvRKN2vs13VoiceDialCall8ResponseEEEEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<std::function<void ()(vs::VoiceDialCall::Response const&)>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2530;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::function<void ()(vs::VoiceDialCall::Response const&)>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2530;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<std::function<void ()(vs::VoiceDialCall::Response const&)>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(vs::VoiceDialCall::Response const&)>::~__value_func[abi:ne180100]((void *)(a1 + 24));
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs13VoiceDialCall8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  cast_message_type<vs::VoiceDialCall::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2224EEBC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<CallCommandDriver>::execute_wrapped<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0>(EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0,dispatch_queue_s *::default_delete<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v3 = a1;
  uint64_t v4 = v1;
  (*(void (**)(void, uint64_t))(**(void **)(*(void *)v1 + 120) + 168))(*(void *)(*(void *)v1 + 120), v1 + 8);
  std::unique_ptr<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0,std::default_delete<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0>>::~unique_ptr[abi:ne180100](&v4);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v3);
}

void sub_2224EEC40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *std::unique_ptr<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0,std::default_delete<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    CallInfo::~CallInfo((void **)(v2 + 8));
    MEMORY[0x223C9A950](v2, 0x1072C402A3CAFC1);
  }
  return a1;
}

void std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::destroy(void **a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::destroy(a1[1]);
    CallInfo::~CallInfo(a1 + 5);
    operator delete(a1);
  }
}

uint64_t **std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(uint64_t **a1, unsigned __int8 a2, char *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  uint64_t v7 = a1 + 1;
  int v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int v8 = (uint64_t **)v5;
        unsigned int v9 = *((unsigned __int8 *)v5 + 32);
        if (v9 <= a2) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a2) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    uint64_t v13 = 0;
    uint64_t v10 = (char *)operator new(0x1C0uLL);
    v12[0] = v10;
    v12[1] = v6;
    v10[32] = *a3;
    *(_OWORD *)(v10 + 56) = 0u;
    *(_OWORD *)(v10 + 72) = 0u;
    *(_OWORD *)(v10 + 88) = 0u;
    *(_OWORD *)(v10 + 104) = 0u;
    *(_OWORD *)(v10 + 120) = 0u;
    *(_OWORD *)(v10 + 136) = 0u;
    *(_OWORD *)(v10 + 152) = 0u;
    *(_OWORD *)(v10 + 168) = 0u;
    *(_OWORD *)(v10 + 184) = 0u;
    *(_OWORD *)(v10 + 200) = 0u;
    *(_OWORD *)(v10 + 216) = 0u;
    *(_OWORD *)(v10 + 232) = 0u;
    *(_OWORD *)(v10 + 248) = 0u;
    *(_OWORD *)(v10 + 40) = 0u;
    *((void *)v10 + 55) = 0;
    *(_OWORD *)(v10 + 296) = 0u;
    *(_OWORD *)(v10 + 312) = 0u;
    *(_OWORD *)(v10 + 328) = 0u;
    *(_OWORD *)(v10 + 344) = 0u;
    *(_OWORD *)(v10 + 360) = 0u;
    *(_OWORD *)(v10 + 376) = 0u;
    *(_OWORD *)(v10 + 392) = 0u;
    *(_OWORD *)(v10 + 408) = 0u;
    *(_OWORD *)(v10 + 424) = 0u;
    *(_OWORD *)(v10 + 264) = 0u;
    *(_OWORD *)(v10 + 280) = 0u;
    CallInfo::CallInfo((CallInfo *)(v10 + 40));
    LOBYTE(v13) = 1;
    std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(a1, (uint64_t)v8, v7, (uint64_t *)v10);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>>>>::reset[abi:ne180100]((uint64_t)v12);
    return (uint64_t **)v10;
  }
  return v8;
}

void sub_2224EEE38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void ***)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      CallInfo::~CallInfo(v1 + 5);
    }
    operator delete(v1);
  }
}

void *std::__tree<std::__value_type<unsigned char,BOOL>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,BOOL>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,BOOL>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(uint64_t **a1, unsigned __int8 a2, unsigned char *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = (unsigned __int8 *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = v5;
        unsigned int v8 = v5[25];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = (unsigned __int8 *)*v7;
        uint64_t v6 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = (unsigned __int8 *)v7[1];
      if (!v5)
      {
        uint64_t v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    unsigned int v9 = v7;
    uint64_t v7 = operator new(0x20uLL);
    *((unsigned char *)v7 + 25) = *a3;
    *((unsigned char *)v7 + 26) = 0;
    *uint64_t v7 = 0;
    v7[1] = 0;
    _OWORD v7[2] = v9;
    const void *v6 = v7;
    uint64_t v10 = (uint64_t *)**a1;
    uint64_t v11 = v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver17endCallDueToSRVCCE8CallInfoE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 4))
  {
    uint64_t v2 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136315138;
      uint64_t v4 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v2, OS_LOG_TYPE_ERROR, "Got error when trying to end call due to handover. Error: %s", (uint8_t *)&v3, 0xCu);
    }
  }
}

uint64_t __copy_helper_block_e8_32c87_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17endCallDueToSRVCCE8CallInfoE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c87_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17endCallDueToSRVCCE8CallInfoE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::endCallDueToSRVCC(CallInfo)::$_0,std::allocator<EurekaCallCommandDriver::endCallDueToSRVCC(CallInfo)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D25B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::endCallDueToSRVCC(CallInfo)::$_0,std::allocator<EurekaCallCommandDriver::endCallDueToSRVCC(CallInfo)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D25B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs7EndCall8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  cast_message_type<vs::EndCall::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2224EF124(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver11endThisCallE8CallInfoE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    uint64_t v4 = *(uint64_t **)(a1 + 32);
    uint64_t v5 = *v4;
    uint64_t v6 = *(NSObject **)v4[52];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v7 = 136315138;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v6, OS_LOG_TYPE_ERROR, "Got error when trying to end specific call. Error: %s", (uint8_t *)&v7, 0xCu);
      int v2 = *(_DWORD *)(a2 + 4);
    }
    if (v2 == 41) {
      (*(void (**)(void, uint64_t *, void))(**(void **)(v5 + 120) + 64))(*(void *)(v5 + 120), v4 + 1, 0);
    }
  }
}

uint64_t __copy_helper_block_e8_32c81_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver11endThisCallE8CallInfoE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c81_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver11endThisCallE8CallInfoE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::endThisCall(CallInfo)::$_0,std::allocator<EurekaCallCommandDriver::endThisCall(CallInfo)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2630;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::endThisCall(CallInfo)::$_0,std::allocator<EurekaCallCommandDriver::endThisCall(CallInfo)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2630;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::endThisCall(CallInfo)::$_0,std::allocator<EurekaCallCommandDriver::endThisCall(CallInfo)::$_0>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::map<char const*,int>::map[abi:ne180100](uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  int v3 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  uint64_t v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      unint64_t v6 = v5[4];
      uint64_t v7 = *(void *)(a1 + 8);
      uint64_t v8 = v3;
      if (*(void **)a1 == v3) {
        goto LABEL_8;
      }
      uint64_t v9 = *(void **)(a1 + 8);
      uint64_t v10 = v3;
      if (v7)
      {
        do
        {
          uint64_t v8 = v9;
          uint64_t v9 = (void *)v9[1];
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v10[2];
          BOOL v11 = *v8 == (void)v10;
          uint64_t v10 = v8;
        }
        while (v11);
      }
      if (v8[4] < v6)
      {
LABEL_8:
        if (v7) {
          uint64_t v12 = (uint64_t **)v8;
        }
        else {
          uint64_t v12 = (uint64_t **)v3;
        }
        if (v7) {
          uint64_t v13 = (uint64_t **)(v8 + 1);
        }
        else {
          uint64_t v13 = (uint64_t **)v3;
        }
        if (*v13) {
          goto LABEL_25;
        }
      }
      else
      {
        uint64_t v13 = (uint64_t **)v3;
        uint64_t v12 = (uint64_t **)v3;
        if (v7)
        {
          char v14 = *(uint64_t **)(a1 + 8);
          while (1)
          {
            while (1)
            {
              uint64_t v12 = (uint64_t **)v14;
              unint64_t v15 = v14[4];
              if (v15 <= v6) {
                break;
              }
              char v14 = *v12;
              uint64_t v13 = v12;
              if (!*v12) {
                goto LABEL_24;
              }
            }
            if (v15 >= v6) {
              goto LABEL_25;
            }
            char v14 = v12[1];
            if (!v14)
            {
              uint64_t v13 = v12 + 1;
              break;
            }
          }
        }
      }
LABEL_24:
      uint64_t v16 = (uint64_t *)operator new(0x30uLL);
      *((_OWORD *)v16 + 2) = *((_OWORD *)v5 + 2);
      std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v12, v13, v16);
LABEL_25:
      uint64_t v17 = (void *)v5[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v5[2];
          BOOL v11 = *v18 == (void)v5;
          uint64_t v5 = v18;
        }
        while (!v11);
      }
      uint64_t v5 = v18;
    }
    while (v18 != v4);
  }
  return a1;
}

void sub_2224EF454(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy(v1, v2);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      int v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v4 = a2;
    do
    {
      int v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      uint64_t v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  unint64_t v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, void **a2, _OWORD **a3)
{
  unint64_t v6 = a1 + 1;
  BOOL v5 = a1[1];
  if (!v5)
  {
    uint64_t v8 = a1 + 1;
LABEL_9:
    uint64_t v10 = (uint64_t *)operator new(0x40uLL);
    BOOL v11 = *a3;
    uint64_t v12 = *((void *)*a3 + 2);
    *((_OWORD *)v10 + 2) = **a3;
    v10[6] = v12;
    *BOOL v11 = 0;
    v11[1] = 0;
    v11[2] = 0;
    v10[7] = 0;
    *uint64_t v10 = 0;
    v10[1] = 0;
    _DWORD v10[2] = (uint64_t)v8;
    uint64_t *v6 = v10;
    uint64_t v13 = (uint64_t *)**a1;
    char v14 = v10;
    if (v13)
    {
      *a1 = v13;
      char v14 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return v10;
  }
  while (1)
  {
    while (1)
    {
      uint64_t v8 = (uint64_t **)v5;
      uint64_t v9 = v5 + 4;
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      BOOL v5 = *v8;
      unint64_t v6 = v8;
      if (!*v8) {
        goto LABEL_9;
      }
    }
    if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v9, a2) & 0x80) == 0) {
      break;
    }
    unint64_t v6 = v8 + 1;
    BOOL v5 = v8[1];
    if (!v5) {
      goto LABEL_9;
    }
  }
  uint64_t v10 = *v6;
  if (!*v6) {
    goto LABEL_9;
  }
  return v10;
}

void *qmi::MutableMessageBase::TlvWrapper<vs::tlv::BurstDtmfInfo>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4D2698;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::BurstDtmfInfo>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4D2698;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x223C9A950);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::BurstDtmfInfo>::getSize(uint64_t a1)
{
  return tlv::size<vs::tlv::USSInfo>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<vs::tlv::BurstDtmfInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<vs::tlv::BurstDtmfInfo>((unsigned char **)a2, a1 + 16);
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::BurstDtmfInfo>::clone()
{
}

void sub_2224EF788(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x1091C40AD8DF7F0);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver21sendVoiceBurstDtmfReqERKNSt3__16vectorIhNS4_9allocatorIhEEEERK8CallInfoE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 4))
  {
    char v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = qmi::asString();
      int v5 = *(_DWORD *)(a2 + 4);
      int v6 = 136315394;
      uint64_t v7 = v4;
      __int16 v8 = 1024;
      int v9 = v5;
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "Sending remote audio burst DTMF failed with error %s (%d)", (uint8_t *)&v6, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c126_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver21sendVoiceBurstDtmfReqERKNS_6vectorIhNS_9allocatorIhEEEERK8CallInfoE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c126_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver21sendVoiceBurstDtmfReqERKNS_6vectorIhNS_9allocatorIhEEEERK8CallInfoE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendVoiceBurstDtmfReq(std::vector<unsigned char> const&,CallInfo const&)::$_0,std::allocator<EurekaCallCommandDriver::sendVoiceBurstDtmfReq(std::vector<unsigned char> const&,CallInfo const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2700;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendVoiceBurstDtmfReq(std::vector<unsigned char> const&,CallInfo const&)::$_0,std::allocator<EurekaCallCommandDriver::sendVoiceBurstDtmfReq(std::vector<unsigned char> const&,CallInfo const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2700;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::DtmfDigit>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::DtmfDigit>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<vs::tlv::DtmfDigit>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::ProfileIdentifer>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::DtmfDigit>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver20sendStartContDtmfReqEhRK8CallInfoE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 4))
  {
    char v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = qmi::asString();
      int v5 = *(_DWORD *)(a2 + 4);
      int v6 = 136315394;
      uint64_t v7 = v4;
      __int16 v8 = 1024;
      int v9 = v5;
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "Sending dtmf digit failed with error %s (%d)", (uint8_t *)&v6, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c93_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver20sendStartContDtmfReqEhRK8CallInfoE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c93_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver20sendStartContDtmfReqEhRK8CallInfoE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendStartContDtmfReq(unsigned char,CallInfo const&)::$_0,std::allocator<EurekaCallCommandDriver::sendStartContDtmfReq(unsigned char,CallInfo const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D27D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendStartContDtmfReq(unsigned char,CallInfo const&)::$_0,std::allocator<EurekaCallCommandDriver::sendStartContDtmfReq(unsigned char,CallInfo const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D27D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver19sendStopContDtmfReqERK8CallInfoE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 4))
  {
    char v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = qmi::asString();
      int v5 = *(_DWORD *)(a2 + 4);
      int v6 = 136315394;
      uint64_t v7 = v4;
      __int16 v8 = 1024;
      int v9 = v5;
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "Sending stop DTMF audio failed with error %s (%d)", (uint8_t *)&v6, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c91_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver19sendStopContDtmfReqERK8CallInfoE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c91_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver19sendStopContDtmfReqERK8CallInfoE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendStopContDtmfReq(CallInfo const&)::$_0,std::allocator<EurekaCallCommandDriver::sendStopContDtmfReq(CallInfo const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2850;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendStopContDtmfReq(CallInfo const&)::$_0,std::allocator<EurekaCallCommandDriver::sendStopContDtmfReq(CallInfo const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2850;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallSupport>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallSupport>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallSupport>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallSupport>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallState>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallState>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallState>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallState>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZNK23EurekaCallCommandDriver20updateWifiCallStatusERK9CallStateN10subscriber7SimSlotEbE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v2 = **(os_log_t ***)(a1 + 32);
  char v3 = *v2;
  if (*(_DWORD *)(a2 + 4))
  {
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = qmi::asString();
      int v6 = *(_DWORD *)(a2 + 4);
      int v7 = 136315394;
      uint64_t v8 = v5;
      __int16 v9 = 1024;
      int v10 = v6;
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "Send WiFi call status info failed: %s (%d)", (uint8_t *)&v7, 0x12u);
    }
  }
  else if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v7) = 0;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I Send WiFi call status info was successful", (uint8_t *)&v7, 2u);
  }
}

uint64_t __copy_helper_block_e8_32c117_ZTSNSt3__110shared_ptrIZNK23EurekaCallCommandDriver20updateWifiCallStatusERK9CallStateN10subscriber7SimSlotEbE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c117_ZTSNSt3__110shared_ptrIZNK23EurekaCallCommandDriver20updateWifiCallStatusERK9CallStateN10subscriber7SimSlotEbE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::updateWifiCallStatus(CallState const&,subscriber::SimSlot,BOOL)::$_0,std::allocator<EurekaCallCommandDriver::updateWifiCallStatus(CallState const&,subscriber::SimSlot,BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2970;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::updateWifiCallStatus(CallState const&,subscriber::SimSlot,BOOL)::$_0,std::allocator<EurekaCallCommandDriver::updateWifiCallStatus(CallState const&,subscriber::SimSlot,BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2970;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallState>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallState>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallState>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallState>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallType>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallType>::getSize()
{
  return tlv::size<wds::tlv::ProfileTypeMask>();
}

void **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallType>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (void *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::ProfileTypeMask>((void **)a2, (void *)(a1 + 16));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallType>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ImsSystemMode>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ImsSystemMode>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::ImsSystemMode>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  int v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ImsSystemMode>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallEndReason>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallEndReason>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallEndReason>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  int v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallEndReason>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallTermination>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallTermination>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallTermination>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  int v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallTermination>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbbE3__3EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 4))
  {
    char v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = qmi::asString();
      int v5 = *(_DWORD *)(a2 + 4);
      int v6 = 136315394;
      uint64_t v7 = v4;
      __int16 v8 = 1024;
      int v9 = v5;
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "IMS call status update failed with error code %s (%d)", (uint8_t *)&v6, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c128_ZTSNSt3__110shared_ptrIZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbbE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c128_ZTSNSt3__110shared_ptrIZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbbE3__3EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendImsCallStatusToBaseband(CallIMSStatus,subscriber::SimSlot,BOOL,BOOL)::$_3,std::allocator<EurekaCallCommandDriver::sendImsCallStatusToBaseband(CallIMSStatus,subscriber::SimSlot,BOOL,BOOL)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2B80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendImsCallStatusToBaseband(CallIMSStatus,subscriber::SimSlot,BOOL,BOOL)::$_3,std::allocator<EurekaCallCommandDriver::sendImsCallStatusToBaseband(CallIMSStatus,subscriber::SimSlot,BOOL,BOOL)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2B80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas20ImsStateNotification8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224F06D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallModePreference>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallModePreference>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallModePreference>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallModePreference>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::PrefCallType>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::PrefCallType>::getSize()
{
  return tlv::size<wds::tlv::ProfileTypeMask>();
}

void **qmi::MutableMessageBase::TlvWrapper<nas::tlv::PrefCallType>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (void *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::ProfileTypeMask>((void **)a2, (void *)(a1 + 16));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::PrefCallType>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZNK23EurekaCallCommandDriver13selectCallRatERK8CallInfoE3__2EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  char v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 32) + 112) + 16))(*(void *)(**(void **)(a1 + 32) + 112), *(unsigned int *)(*(void *)(a1 + 32) + 8));
  if (*(_DWORD *)(a2 + 4))
  {
    uint64_t v4 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = qmi::asString();
      int v6 = *(_DWORD *)(a2 + 4);
      int v7 = 136315394;
      uint64_t v8 = v5;
      __int16 v9 = 1024;
      int v10 = v6;
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Call preference update failed with error code %s (%d)", (uint8_t *)&v7, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c86_ZTSNSt3__110shared_ptrIZNK23EurekaCallCommandDriver13selectCallRatERK8CallInfoE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c86_ZTSNSt3__110shared_ptrIZNK23EurekaCallCommandDriver13selectCallRatERK8CallInfoE3__2EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::selectCallRat(CallInfo const&)::$_2,std::allocator<EurekaCallCommandDriver::selectCallRat(CallInfo const&)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2CA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::selectCallRat(CallInfo const&)::$_2,std::allocator<EurekaCallCommandDriver::selectCallRat(CallInfo const&)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D2CA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void QMINetworkListCommandDriver::create()
{
}

void sub_2224F0B4C(_Unwind_Exception *exception_object)
{
  if (v2) {
    dispatch_release(v2);
  }
  if (v3) {
    MEMORY[0x223C9A950](v1, 0xF1C408BA644E3);
  }
  _Unwind_Resume(exception_object);
}

void QMINetworkListCommandDriver::QMINetworkListCommandDriver(uint64_t a1, uint64_t a2, dispatch_object_t *a3, void *a4)
{
  v10[8] = *MEMORY[0x263EF8340];
  xpc_object_t object = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  NetworkListCommandDriver::NetworkListCommandDriver();
  if (object) {
    dispatch_release(object);
  }
  v9[0] = &unk_26D4C05F8;
  v9[3] = v9;
  int v6 = (capabilities::ct *)std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)v10, (uint64_t)v9);
  *(void *)(a1 + 88) = 0;
  if ((capabilities::ct::supportsGemini(v6) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 88)) {
    operator new();
  }
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100](v10);
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100](v9);
  *(void *)a1 = &unk_26D4D2CF0;
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 96), *(os_log_s **)(a1 + 40));
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = *a4;
  uint64_t v7 = a4[1];
  *(void *)(a1 + 144) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  ctu::enable_make_unique<qmi::NotifyHelper>::make_unique<std::shared_ptr<Registry const> const&>();
}

void sub_2224F0DC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va2);
  MEMORY[0x223C9A950](v3, 0x10A1C40FF1576FELL);
  uint64_t v5 = *((void *)v2 + 11);
  *((void *)v2 + 11) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va);
  NetworkListCommandDriver::~NetworkListCommandDriver(v2);
  _Unwind_Resume(a1);
}

void sub_2224F0EAC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x2224F0EA4);
}

void QMINetworkListCommandDriver::bootstrap(uint64_t a1, dispatch_object_t *a2, uint64_t a3)
{
  uint64_t v5 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v5);
  }
  uint64_t v6 = *(void *)(a3 + 8);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMINetworkListCommandDriver::start(QMINetworkListCommandDriver *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMINetworkListCommandDriver::shutdown(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMINetworkListCommandDriver::~QMINetworkListCommandDriver(qmi::NotifyHelper **this)
{
  *this = (qmi::NotifyHelper *)&unk_26D4D2CF0;
  std::unique_ptr<qmi::NotifyHelper>::reset[abi:ne180100](this + 19, 0);
  uint64_t v2 = (std::__shared_weak_count *)this[18];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = this[14];
  if (v3)
  {
    this[15] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)this[13];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  uint64_t v5 = this[11];
  this[11] = 0;
  if (v5) {
    (*(void (**)(qmi::NotifyHelper *))(*(void *)v5 + 8))(v5);
  }

  NetworkListCommandDriver::~NetworkListCommandDriver((NetworkListCommandDriver *)this);
}

{
  uint64_t vars8;

  QMINetworkListCommandDriver::~QMINetworkListCommandDriver(this);

  JUMPOUT(0x223C9A950);
}

void QMINetworkListCommandDriver::performNetworkScan(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMINetworkListCommandDriver::applyNetworkSelection(uint64_t a1, int a2, int a3, NetworkListOperator *a4)
{
  NetworkListOperator::NetworkListOperator(&v6, a4);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMINetworkListCommandDriver::applySelection_sync(uint64_t a1, int a2, int a3, const NetworkListOperator *a4)
{
  uint64_t v75 = *MEMORY[0x263EF8340];
  uint64_t v8 = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
  if (capabilities::ct::supports5G(v8))
  {
    *(_OWORD *)uint64_t v58 = 0uLL;
    long long v59 = 0uLL;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v58);
    LODWORD(v45.__r_.__value_.__l.__data_) = a3;
    NetworkListOperator::NetworkListOperator((std::string *)&v45.__r_.__value_.__r.__words[1], a4);
    uint64_t v9 = qmi::MutableMessageBase::getTLV<nas::tlv::NetworkSelectionPreference>((uint64_t)v58, 22);
    *uint64_t v9 = a3 == 1;
    if (a3 == 1)
    {
      NetworkListOperator::getMCC(&aBlock, (NetworkListOperator *)&v45.__r_.__value_.__r.__words[1]);
      *((_WORD *)v9 + 1) = MCC::getIntValue((MCC *)&aBlock);
      if (v62 < 0) {
        operator delete(__p);
      }
      NetworkListOperator::getMNC(&aBlock, (NetworkListOperator *)&v45.__r_.__value_.__r.__words[1]);
      *((_WORD *)v9 + 2) = MCC::getIntValue((MCC *)&aBlock);
      if (v62 < 0) {
        operator delete(__p);
      }
    }
    if (v57 < 0) {
      operator delete(v55);
    }
    if (SHIBYTE(v54) < 0) {
      operator delete(v52);
    }
    if (v50 < 0) {
      operator delete(v48);
    }
    if (v46 < 0) {
      operator delete((void *)v45.__r_.__value_.__l.__size_);
    }
    if (a3 == 1)
    {
      uint64_t v10 = (const void **)v58[1];
      if (v58[1] != (void *)v59)
      {
        while (*((unsigned char *)*v10 + 8) != 23)
        {
          if (++v10 == (const void **)v59) {
            goto LABEL_31;
          }
        }
      }
      if (v10 == (const void **)v59) {
LABEL_31:
      }
        operator new();
      if (!v13) {
        __cxa_bad_cast();
      }
      v13[9] = 0;
      NetworkListOperator::NetworkListOperator(&v45, a4);
      int v29 = (const void **)v58[1];
      if (v58[1] != (void *)v59)
      {
        while (*((unsigned char *)*v29 + 8) != 26)
        {
          if (++v29 == (const void **)v59) {
            goto LABEL_69;
          }
        }
      }
      if (v29 == (const void **)v59) {
LABEL_69:
      }
        operator new();
      if (!v30) {
        __cxa_bad_cast();
      }
      int v31 = v30 + 9;
      NetworkListOperator::getMNC(&aBlock, (NetworkListOperator *)&v45);
      char isThreeDigit = MNC::isThreeDigit((MNC *)&aBlock);
      *int v31 = isThreeDigit;
      if (v62 < 0) {
        operator delete(__p);
      }
      if (v56 < 0) {
        operator delete(v54);
      }
      if (v53 < 0) {
        operator delete(v51);
      }
      if (v49 < 0) {
        operator delete(v47);
      }
      if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v45.__r_.__value_.__l.__data_);
      }
      if (NetworkListOperator::getRAT(a4) != 11)
      {
        NetworkListOperator::NetworkListOperator(&v45, a4);
        xpc_object_t v33 = (const void **)v58[1];
        if (v58[1] != (void *)v59)
        {
          while (*((unsigned char *)*v33 + 8) != 34)
          {
            if (++v33 == (const void **)v59) {
              goto LABEL_88;
            }
          }
        }
        if (v33 == (const void **)v59) {
LABEL_88:
        }
          operator new();
        if (!v34) {
          __cxa_bad_cast();
        }
        uint64_t v35 = v34 + 12;
        int RAT = NetworkListOperator::getRAT((NetworkListOperator *)&v45);
        *uint64_t v35 = RAT;
        if (v56 < 0) {
          operator delete(v54);
        }
        if (v53 < 0) {
          operator delete(v51);
        }
        if (v49 < 0) {
          operator delete(v47);
        }
        if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v45.__r_.__value_.__l.__data_);
        }
      }
      __int16 v38 = *(NSObject **)v8;
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        NetworkListOperator::getMCC((uint64_t *)&v45, a4);
        int IntValue = MCC::getIntValue((MCC *)&v45);
        NetworkListOperator::getMNC(&aBlock, a4);
        int IntegerWidth = MNC::getIntegerWidth((MNC *)&aBlock);
        NetworkListOperator::getMNC((uint64_t *)buf, a4);
        int v41 = MCC::getIntValue((MCC *)buf);
        NetworkListOperator::getMNC(v43, a4);
        MNC::isThreeDigit((MNC *)v43);
        uint64_t v42 = CSIBOOLAsString();
        *(_DWORD *)uint64_t v67 = 67109890;
        int v68 = IntValue;
        __int16 v69 = 1024;
        int v70 = IntegerWidth;
        __int16 v71 = 1024;
        int v72 = v41;
        __int16 v73 = 2080;
        uint64_t v74 = v42;
        _os_log_impl(&dword_22231A000, v38, OS_LOG_TYPE_DEFAULT, "#I Network MCC: %03d, MNC: %0.*d is a 3-digit MNC: %s", v67, 0x1Eu);
        if (v44 < 0) {
          operator delete((void *)v43[1]);
        }
        if (v66 < 0) {
          operator delete(v64);
        }
        if (v62 < 0) {
          operator delete(__p);
        }
        if (v46 < 0) {
          operator delete((void *)v45.__r_.__value_.__l.__size_);
        }
      }
    }
    if ((a2 - 1) >= 3) {
      a2 = 0;
    }
    qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>(v43, a2);
  }
  *(_OWORD *)uint64_t v58 = 0uLL;
  long long v59 = 0uLL;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v58);
  uint64_t v11 = (const void **)v58[1];
  if (v58[1] != (void *)v59)
  {
    while (*((unsigned char *)*v11 + 8) != 1)
    {
      if (++v11 == (const void **)v59) {
        goto LABEL_27;
      }
    }
  }
  if (v11 != (const void **)v59)
  {
    if (!v12) {
      __cxa_bad_cast();
    }
    if (a3 == 1) {
      char v14 = 2;
    }
    else {
      char v14 = 1;
    }
    v12[9] = v14;
    if (a3 == 1)
    {
      NetworkListOperator::getMCC((uint64_t *)&v45, a4);
      NetworkListOperator::getMNC(&aBlock, a4);
      uint64_t v15 = (const void **)v58[1];
      if (v58[1] != (void *)v59)
      {
        while (*((unsigned char *)*v15 + 8) != 16)
        {
          if (++v15 == (const void **)v59) {
            goto LABEL_43;
          }
        }
      }
      if (v15 == (const void **)v59) {
LABEL_43:
      }
        operator new();
      if (!v16) {
        __cxa_bad_cast();
      }
      uint64_t v17 = (char *)(v16 + 5);
      v16[5] = MCC::getIntValue((MCC *)&v45);
      __int16 v18 = MCC::getIntValue((MCC *)&aBlock);
      *((_WORD *)v17 + 1) = v18;
      v17[4] = -1;
      long long v19 = *(unsigned __int16 **)(a1 + 112);
      uint64_t v20 = *(unsigned __int16 **)(a1 + 120);
      if (v19 == v20) {
        goto LABEL_51;
      }
      do
      {
        if (MCC::getIntValue((MCC *)&v45) == *v19
          && MCC::getIntValue((MCC *)&aBlock) == v19[1])
        {
          goto LABEL_49;
        }
        v19 += 3;
      }
      while (v19 != v20);
      long long v19 = v20;
LABEL_49:
      if (v19 == *(unsigned __int16 **)(a1 + 120)) {
LABEL_51:
      }
        char v21 = MNC::isThreeDigit((MNC *)&aBlock);
      else {
        char v21 = *((unsigned char *)v19 + 4) != 0;
      }
      int v22 = *(NSObject **)v8;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        int v23 = MCC::getIntValue((MCC *)&v45);
        int v24 = MNC::getIntegerWidth((MNC *)&aBlock);
        int v25 = MCC::getIntValue((MCC *)&aBlock);
        uint64_t v26 = CSIBOOLAsString();
        *(_DWORD *)long long buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v23;
        LOWORD(v64) = 1024;
        *(_DWORD *)((char *)&v64 + 2) = v24;
        HIWORD(v64) = 1024;
        *(_DWORD *)long long v65 = v25;
        *(_WORD *)&v65[4] = 2080;
        *(void *)&v65[6] = v26;
        _os_log_impl(&dword_22231A000, v22, OS_LOG_TYPE_DEFAULT, "#I Network MCC: %03d, MNC: %0.*d is a 3-digit MNC: %s", buf, 0x1Eu);
      }
      uint64_t v27 = (const void **)v58[1];
      if (v58[1] != (void *)v59)
      {
        while (*((unsigned char *)*v27 + 8) != 18)
        {
          if (++v27 == (const void **)v59) {
            goto LABEL_61;
          }
        }
      }
      if (v27 == (const void **)v59) {
LABEL_61:
      }
        operator new();
      if (!v28) {
        __cxa_bad_cast();
      }
      v28[9] = v21;
      if (v62 < 0) {
        operator delete(__p);
      }
      if (v46 < 0) {
        operator delete((void *)v45.__r_.__value_.__l.__size_);
      }
    }
    if ((a2 - 1) >= 3) {
      int v36 = 0;
    }
    else {
      int v36 = a2;
    }
    qmi::ClientRouter::get();
    LODWORD(v43[0]) = v36;
    operator new();
  }
LABEL_27:
  operator new();
}

void sub_2224F26A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if (*(char *)(v48 - 145) < 0) {
    operator delete(*(void **)(v48 - 168));
  }
  if (a48 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a37);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_1::~$_1(uint64_t a1)
{
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_3::~$_3(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_9::~$_9(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 16);
    if (v3) {
      dispatch_release(v3);
    }
  }
  return a1;
}

void QMINetworkListCommandDriver::handleInitiateNetworkRegisterResp_sync(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (a2 - 1 >= 3) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = a2;
  }
  std::string v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), v5);
  int v7 = *(_DWORD *)(a3 + 4);
  if (!v7) {
    goto LABEL_9;
  }
  uint64_t v8 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = asString();
    int v10 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v9;
    __int16 v17 = 1024;
    int v18 = v10;
    __int16 v19 = 2080;
    uint64_t v20 = qmi::asString();
    _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#N Network register initiate (%s) failed with error: %d (%s)", buf, 0x1Cu);
    int v7 = *(_DWORD *)(a3 + 4);
  }
  if (v7 == 26)
  {
LABEL_9:
    uint64_t v11 = (std::__shared_weak_count *)operator new(0x20uLL);
    v11->__shared_owners_ = 0;
    v11->__shared_weak_owners_ = 0;
    v11->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D36A8;
    uint64_t v12 = NetworkListSelectionResult::NetworkListSelectionResult();
    uint64_t v13 = *(void *)(a1 + 48);
    uint64_t v14 = v12;
    uint64_t v15 = v11;
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v13 + 40))(v13, v5, &v14);
    if (v15) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v15);
    }
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  else
  {
    *(void *)long long buf = 0;
    NetworkListCommandDriverResponseError::NetworkListCommandDriverResponseError();
    (*(void (**)(void, uint64_t, void))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48), v5, *(void *)buf);
  }
}

void sub_2224F2BD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  _Unwind_Resume(a1);
}

void QMINetworkListCommandDriver::getNetworkSelectionSetting(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMINetworkListCommandDriver::dumpState(QMINetworkListCommandDriver *this)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v1 = (unsigned __int16 *)*((void *)this + 14);
  for (uint64_t i = (unsigned __int16 *)*((void *)this + 15); v1 != i; v1 += 3)
  {
    uint64_t v4 = *((void *)this + 5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *v1;
      if (*((unsigned char *)v1 + 4)) {
        int v6 = 3;
      }
      else {
        int v6 = 2;
      }
      int v7 = v1[1];
      uint64_t v8 = CSIBOOLAsString();
      *(_DWORD *)long long buf = 67109890;
      int v10 = v5;
      __int16 v11 = 1024;
      int v12 = v6;
      __int16 v13 = 1024;
      int v14 = v7;
      __int16 v15 = 2080;
      uint64_t v16 = v8;
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I MCC: %03d MNC: %0.*d three digit: %s", buf, 0x1Eu);
    }
  }
}

void NetworkListOperator::NetworkListOperator(std::string *this, const NetworkListOperator *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *(_OWORD *)a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  LODWORD(this[1].__r_.__value_.__l.__data_) = *((_DWORD *)a2 + 6);
  MCC::MCC();
  MCC::MCC((MCC *)&this[2].__r_.__value_.__r.__words[2], (const NetworkListOperator *)((char *)a2 + 64));
  int v5 = this + 4;
  if (*((char *)a2 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 12), *((void *)a2 + 13));
  }
  else
  {
    long long v6 = *((_OWORD *)a2 + 6);
    this[4].__r_.__value_.__r.__words[2] = *((void *)a2 + 14);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  *(_OWORD *)&this[5].__r_.__value_.__l.__data_ = *(_OWORD *)((char *)a2 + 120);
}

void sub_2224F2EC0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 95) < 0) {
    operator delete(*(void **)(v1 + 72));
  }
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*(void **)(v1 + 40));
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *std::__optional_copy_base<MCCAndMNC,false>::__optional_copy_base[abi:ne180100](unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[64] = 0;
  if (*(unsigned char *)(a2 + 64))
  {
    MCC::MCC();
    MCC::MCC((MCC *)(a1 + 32), (const MCC *)(a2 + 32));
    a1[64] = 1;
  }
  return a1;
}

void sub_2224F2F60(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*(void **)(v1 + 8));
  }
  std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void std::shared_ptr<QMINetworkListCommandDriver>::shared_ptr[abi:ne180100]<QMINetworkListCommandDriver,std::shared_ptr<QMINetworkListCommandDriver> ctu::SharedSynchronizable<NetworkListCommandDriver>::make_shared_ptr<QMINetworkListCommandDriver>(QMINetworkListCommandDriver*)::{lambda(QMINetworkListCommandDriver*)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2224F3058(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMINetworkListCommandDriver> ctu::SharedSynchronizable<NetworkListCommandDriver>::make_shared_ptr<QMINetworkListCommandDriver>(QMINetworkListCommandDriver*)::{lambda(QMINetworkListCommandDriver*)#1}::operator() const(QMINetworkListCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_2224F3080(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<QMINetworkListCommandDriver *,std::shared_ptr<QMINetworkListCommandDriver> ctu::SharedSynchronizable<NetworkListCommandDriver>::make_shared_ptr<QMINetworkListCommandDriver>(QMINetworkListCommandDriver*)::{lambda(QMINetworkListCommandDriver *)#1},std::allocator<QMINetworkListCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<QMINetworkListCommandDriver *,std::shared_ptr<QMINetworkListCommandDriver> ctu::SharedSynchronizable<NetworkListCommandDriver>::make_shared_ptr<QMINetworkListCommandDriver>(QMINetworkListCommandDriver*)::{lambda(QMINetworkListCommandDriver *)#1},std::allocator<QMINetworkListCommandDriver>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<QMINetworkListCommandDriver *,std::shared_ptr<QMINetworkListCommandDriver> ctu::SharedSynchronizable<NetworkListCommandDriver>::make_shared_ptr<QMINetworkListCommandDriver>(QMINetworkListCommandDriver*)::{lambda(QMINetworkListCommandDriver *)#1},std::allocator<QMINetworkListCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMINetworkListCommandDriver> ctu::SharedSynchronizable<NetworkListCommandDriver>::make_shared_ptr<QMINetworkListCommandDriver>(QMINetworkListCommandDriver*)::{lambda(QMINetworkListCommandDriver*)#1}::operator() const(QMINetworkListCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void SimInstanceLoggable<QMINetworkListCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::~SimInstanceLoggable()
{
}

uint64_t SimInstanceLoggable<QMINetworkListCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::getLoggerForSlot(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkListCommandDriverDelegateInterface>)::$_0>(QMINetworkListCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkListCommandDriverDelegateInterface>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkListCommandDriverDelegateInterface>)::$_0,std::default_delete<QMINetworkListCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkListCommandDriverDelegateInterface>)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  uint64_t v1 = *a1;
  int v18 = a1;
  __int16 v19 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstraping", (uint8_t *)&buf, 2u);
  }
  uint64_t v5 = v1[2];
  uint64_t v4 = v1[3];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  long long v6 = *(std::__shared_weak_count **)(v2 + 56);
  *(void *)(v2 + 48) = v5;
  *(void *)(v2 + 56) = v4;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  subscriber::makeSimSlotRange();
  int v7 = v20;
  if (v20 != v21)
  {
    while ((v22(*v7) & 1) == 0)
    {
      if (++v7 == v21)
      {
        int v7 = v21;
        break;
      }
    }
    while (v7 != v21)
    {
      if (*v7 == 1)
      {
        uint64_t v8 = "QMINetworkListCommandDriver.1";
      }
      else if (*v7 == 2)
      {
        uint64_t v8 = "QMINetworkListCommandDriver.2";
      }
      else
      {
        uint64_t v8 = 0;
      }
      uint64_t v9 = *(std::__shared_weak_count **)(v2 + 16);
      if (!v9 || (uint64_t v10 = *(void *)(v2 + 8), (v11 = std::__shared_weak_count::lock(v9)) == 0)) {
        std::__throw_bad_weak_ptr[abi:ne180100]();
      }
      int v12 = v11;
      atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v11);
      Registry::getServerConnection((uint64_t *)&v23, *(Registry **)(v2 + 64));
      long long buf = 0u;
      long long v35 = 0u;
      std::string::basic_string[abi:ne180100]<0>(&v31, v8);
      __int16 v13 = *(NSObject **)(v2 + 24);
      dispatch_object_t object = v13;
      if (v13) {
        dispatch_retain(v13);
      }
      std::string::basic_string[abi:ne180100]<0>(__p, "registration");
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      int v14 = std::__shared_weak_count::lock(v12);
      if (v14)
      {
        __int16 v15 = v14;
        atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        uint64_t v25 = v10;
        uint64_t v26 = v14;
        std::__shared_weak_count::__release_weak(v12);
        std::__shared_weak_count::__release_shared[abi:ne180100](v15);
      }
      else
      {
        uint64_t v25 = 0;
        uint64_t v26 = 0;
        std::__shared_weak_count::__release_weak(v12);
      }
      long long v24 = v23;
      long long v23 = 0uLL;
      qmi::Client::createWithQueueLocal();
      if (*((void *)&v24 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v24 + 1));
      }
      if (v26) {
        std::__shared_weak_count::__release_weak(v26);
      }
      if (v29 < 0) {
        operator delete(__p[0]);
      }
      if (object) {
        dispatch_release(object);
      }
      if (SBYTE7(v33) < 0) {
        operator delete(v31);
      }
      int v31 = 0;
      uint64_t v32 = 0;
      long long v33 = v35;
      long long v35 = 0uLL;
      qmi::ClientRouter::addClient();
      qmi::Client::~Client((qmi::Client *)&v31);
      qmi::ClientRouter::get();
      qmi::Client::~Client((qmi::Client *)&buf);
      if (*((void *)&v23 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v23 + 1));
      }
      uint64_t v16 = v7 + 1;
      int v7 = v21;
      if (v16 != v21)
      {
        int v7 = v16;
        while ((v22(*v7) & 1) == 0)
        {
          if (++v7 == v21)
          {
            int v7 = v21;
            break;
          }
        }
      }
    }
  }
  *(void *)&long long buf = &unk_26D4D2E58;
  *((void *)&buf + 1) = v2;
  *((void *)&v35 + 1) = &buf;
  qmi::ClientRouter::setHandler();
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](&buf);
  int v31 = &unk_26D4D2ED8;
  uint64_t v32 = v2;
  *((void *)&v33 + 1) = &v31;
  qmi::ClientRouter::setHandler();
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](&v31);
  __p[0] = &unk_26D4D2F58;
  __p[1] = (void *)v2;
  uint64_t v30 = __p;
  qmi::ClientRouter::setHandler();
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](__p);
  *(void *)&long long buf = &unk_26D4D2FD8;
  *((void *)&buf + 1) = v2;
  *((void *)&v35 + 1) = &buf;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&buf);
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 96));
  *(void *)&long long buf = &unk_26D4D3058;
  *((void *)&buf + 1) = v2;
  *((void *)&v35 + 1) = &buf;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&buf);
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 96));
  *(void *)&long long buf = &unk_26D4D30D8;
  *((void *)&buf + 1) = v2;
  *((void *)&v35 + 1) = &buf;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&buf);
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 96));
  std::unique_ptr<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)&v19);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v18);
}

void sub_2224F3650(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,dispatch_object_t object,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100]((void *)(v37 - 144));
  std::unique_ptr<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0>>::~unique_ptr[abi:ne180100](&a13);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::start(void)::$_0>(QMINetworkListCommandDriver::start(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::start(void)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::start(void)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = *(void *)a1;
  uint64_t v2 = *(NSObject **)(**(void **)a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  qmi::ClientRouter::start();
  MEMORY[0x223C9A950](v1, 0x20C4093837F09);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v4);
}

void sub_2224F37FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MEMORY[0x223C9A950](v2, 0x20C4093837F09);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::shutdown(dispatch::group_session)::$_0>(QMINetworkListCommandDriver::shutdown(dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::shutdown(dispatch::group_session)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::shutdown(dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  qmi::ClientRouter::stop();
  std::unique_ptr<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0,std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_2224F38B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D2E58;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D2E58;
  a2[1] = v2;
  return result;
}

void std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::operator()(capabilities::ct *a1, int *a2)
{
  int v2 = *a2;
  if (capabilities::ct::supportsGemini(a1))
  {
    *(_OWORD *)std::string __p = 0u;
    long long v7 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    *qmi::MutableMessageBase::getTLV<nas::tlv::SubType>((uint64_t)__p, 1) = v2 == 2;
    qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::BindSubscription::Request>(&v5, v2);
  }
  *(_OWORD *)std::string __p = 0u;
  long long v7 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  *qmi::MutableMessageBase::getTLV<nas::tlv::ServingSysEvents>((uint64_t)__p, 19) = 0;
  *qmi::MutableMessageBase::getTLV<nas::tlv::SysInfoEvents>((uint64_t)__p, 24) = 0;
  uint64_t v3 = (const void **)__p[1];
  if (__p[1] != (void *)v7)
  {
    while (*((unsigned __int8 *)*v3 + 8) != 209)
    {
      if (++v3 == (const void **)v7) {
        goto LABEL_10;
      }
    }
  }
  if (v3 != (const void **)v7)
  {
    if (v4)
    {
      v4[9] = 1;
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<nas::IndicationRegister::Request>(&v5, v2);
    }
    __cxa_bad_cast();
  }
LABEL_10:
  operator new();
}

void sub_2224F3E68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  uint64_t v23 = a10;
  a10 = 0;
  if (v23) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v23);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D2ED8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D2ED8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t result = qmi::NotifyHelper::shouldNotifyStop(*(unint64_t ***)(v1 + 152));
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(**(void **)(v1 + 48) + 16);
    return v3();
  }
  return result;
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D2F58;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D2F58;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D2FD8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D2FD8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&long long v33 = 0;
    QMIServiceMsg::serialize((uint64_t *)__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v29, __p[0]);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v29);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v29);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v4 - 1 >= 3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v4;
  }
  uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v7);
  uint64_t v36 = 0;
  long long v34 = 0u;
  long long v35 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v33 = 0u;
  uint64_t TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v29);
  uint64_t v11 = TlvValue;
  if (TlvValue)
  {
    int v12 = v10;
    *(void *)&long long v40 = TlvValue;
    unint64_t v13 = tlv::parseV<nas::tlv::ManuallySelectedPLMN>((unint64_t *)&v40, v10);
    LODWORD(v39) = v13;
    WORD2(v39) = WORD2(v13);
    if ((void)v40)
    {
      long long v42 = 0u;
      long long v43 = 0u;
      MCC::MCC((MCC *)&v42);
      *(_OWORD *)uint64_t v30 = 0u;
      long long v31 = 0u;
      MNC::MNC((MNC *)v30);
      convertMccAndMnc((unsigned __int8 *)&v39, (unsigned __int8 *)&v39 + 3, (const MCC *)&v42, (const MNC *)v30);
      int v14 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        int IntValue = MCC::getIntValue((MCC *)&v42);
        int IntegerWidth = MNC::getIntegerWidth((MNC *)v30);
        int v17 = MCC::getIntValue((MCC *)v30);
        LODWORD(buf) = 67109632;
        DWORD1(buf) = IntValue;
        WORD4(buf) = 1024;
        *(_DWORD *)((char *)&buf + 10) = IntegerWidth;
        HIWORD(buf) = 1024;
        LODWORD(v47) = v17;
        _os_log_impl(&dword_22231A000, v14, OS_LOG_TYPE_DEFAULT, "#I Manually selected PLMN %03d-%0.*d", (uint8_t *)&buf, 0x14u);
      }
      MEMORY[0x223C99FA0](&buf, &v42, v30);
      std::optional<MCCAndMNC>::operator=[abi:ne180100]<MCCAndMNC,void>((uint64_t)__p, (uint64_t)&buf);
      if (SHIBYTE(v49) < 0) {
        operator delete(*((void **)&v48 + 1));
      }
      if (SHIBYTE(v47) < 0) {
        operator delete(*((void **)&buf + 1));
      }
      if (SHIBYTE(v31) < 0) {
        operator delete(v30[1]);
      }
      if (SHIBYTE(v43) < 0) {
        operator delete(*((void **)&v42 + 1));
      }
    }
    else
    {
      ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v29[0], 16, v11, v12);
    }
  }
  uint64_t v50 = 0;
  long long v48 = 0u;
  long long v49 = 0u;
  long long buf = 0u;
  long long v47 = 0u;
  uint64_t v18 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v29);
  uint64_t v20 = v18;
  if (v18)
  {
    int v21 = v19;
    uint64_t v39 = v18;
    unint64_t v22 = tlv::parseV<nas::tlv::BasebandSelectedPLMN>((unint64_t *)&v39, v19);
    int v37 = v22;
    __int16 v38 = WORD2(v22);
    if (v39)
    {
      *(_OWORD *)uint64_t v30 = 0u;
      long long v31 = 0u;
      MCC::MCC((MCC *)v30);
      long long v40 = 0u;
      long long v41 = 0u;
      MNC::MNC((MNC *)&v40);
      convertMccAndMnc((unsigned __int8 *)&v37, (unsigned __int8 *)&v37 + 3, (const MCC *)v30, (const MNC *)&v40);
      uint64_t v23 = *v8;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = MCC::getIntValue((MCC *)v30);
        int v25 = MNC::getIntegerWidth((MNC *)&v40);
        int v26 = MCC::getIntValue((MCC *)&v40);
        LODWORD(v42) = 67109632;
        DWORD1(v42) = v24;
        WORD4(v42) = 1024;
        *(_DWORD *)((char *)&v42 + 10) = v25;
        HIWORD(v42) = 1024;
        LODWORD(v43) = v26;
        _os_log_impl(&dword_22231A000, v23, OS_LOG_TYPE_DEFAULT, "#I Baseband selected PLMN %03d-%0.*d", (uint8_t *)&v42, 0x14u);
      }
      MEMORY[0x223C99FA0](&v42, v30, &v40);
      std::optional<MCCAndMNC>::operator=[abi:ne180100]<MCCAndMNC,void>((uint64_t)&buf, (uint64_t)&v42);
      if (v45 < 0) {
        operator delete(v44);
      }
      if (SHIBYTE(v43) < 0) {
        operator delete(*((void **)&v42 + 1));
      }
      if (SHIBYTE(v41) < 0) {
        operator delete(*((void **)&v40 + 1));
      }
      if (SHIBYTE(v31) < 0) {
        operator delete(v30[1]);
      }
    }
    else
    {
      ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v29[0], 17, v20, v21);
    }
  }
  uint64_t v27 = *(void *)(v6 + 48);
  if (v4 - 1 >= 3) {
    uint64_t v28 = 0;
  }
  else {
    uint64_t v28 = v4;
  }
  std::__optional_copy_base<MCCAndMNC,false>::__optional_copy_base[abi:ne180100](&v42, (uint64_t)__p);
  std::__optional_copy_base<MCCAndMNC,false>::__optional_copy_base[abi:ne180100](v30, (uint64_t)&buf);
  (*(void (**)(uint64_t, uint64_t, long long *, void **))(*(void *)v27 + 48))(v27, v28, &v42, v30);
  std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v30);
  std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v42);
  std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&buf);
  std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)__p);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v29);
}

void sub_2224F4684(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,uint64_t a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  if (a58 < 0) {
    operator delete(__p);
  }
  if (a51 < 0) {
    operator delete(a46);
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100](v58 - 160);
  std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a26);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D3058;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D3058;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v14, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v14);
    if (__p)
    {
      uint64_t v16 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v14);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v14);
  uint64_t v9 = TlvValue;
  if (TlvValue)
  {
    int v10 = v8;
    std::string __p = TlvValue;
    BOOL v11 = tlv::parseV<nas::tlv::PlmnMode>((unint64_t *)&__p, v8);
    if (__p)
    {
      if (v4 - 1 >= 3) {
        uint64_t v12 = 0;
      }
      else {
        uint64_t v12 = v4;
      }
      if (v11) {
        uint64_t v13 = 2;
      }
      else {
        uint64_t v13 = 1;
      }
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 48) + 56))(*(void *)(v6 + 48), v12, v13);
    }
    else
    {
      ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v14[0], 16, v9, v10);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v14);
}

void sub_2224F49FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D30D8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D30D8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  uint64_t v83 = *MEMORY[0x263EF8340];
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    memset(buf, 0, 24);
    QMIServiceMsg::serialize((uint64_t *)buf, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v60, *(const void **)buf);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v60);
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v60);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (char *)operator new(0x38uLL);
  *((void *)v7 + 1) = 0;
  *((void *)v7 + 2) = 0;
  *(void *)uint64_t v7 = &unk_26D4D3778;
  *(_OWORD *)(v7 + 24) = 0u;
  long long v59 = v7 + 24;
  *(_OWORD *)(v7 + 40) = 0u;
  unsigned int v57 = v4 - 1;
  if (v4 - 1 >= 3) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = v4;
  }
  uint64_t v58 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v8);
  uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v60);
  if (!TlvValue)
  {
LABEL_16:
    __int16 v15 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v60);
    uint64_t v17 = v15;
    if (!v15)
    {
      int v21 = 0;
      int v26 = 0;
LABEL_51:
      long long v34 = (unsigned __int16 *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v60);
      uint64_t v36 = v34;
      if (v34)
      {
        int v37 = v35;
        uint64_t v63 = 0;
        int v64 = v34;
        uint64_t v61 = 0;
        uint64_t v62 = 0;
        tlv::parseV<nas::tlv::IncrementalNetworkInfo>(&v64, v35, &v61);
        if (v64)
        {
          uint64_t v38 = v61;
          if (v62 == v61)
          {
            *(void *)long long buf = &v61;
            std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
          }
          else
          {
            unsigned int v55 = v4;
            uint64_t v53 = v6;
            unint64_t v39 = 0;
            unint64_t v40 = (v26 - v21) >> 2;
            unsigned int v41 = 1;
            do
            {
              v73[0] = 0;
              v73[1] = 0;
              uint64_t v74 = 0;
              createPLMN();
              if (v40 <= v39)
              {
                long long v43 = *v58;
                uint64_t v42 = 0;
                if (os_log_type_enabled(*v58, OS_LOG_TYPE_DEFAULT))
                {
                  char v44 = v73;
                  if (v74 < 0) {
                    char v44 = (void **)v73[0];
                  }
                  *(_DWORD *)long long buf = 67109634;
                  *(_DWORD *)&uint8_t buf[4] = v41;
                  *(_WORD *)&uint8_t buf[8] = 2048;
                  *(void *)&buf[10] = 0xCCCCCCCCCCCCCCCDLL * ((v62 - v61) >> 3);
                  *(_WORD *)&buf[18] = 2082;
                  *(void *)&buf[20] = v44;
                  _os_log_impl(&dword_22231A000, v43, OS_LOG_TYPE_DEFAULT, "#N Could not find network name source for interface %d of %ld: %{public}s", buf, 0x1Cu);
                  uint64_t v42 = 0;
                }
              }
              else
              {
                uint64_t v42 = *(unsigned int *)&v21[4 * v39];
              }
              long long v71 = 0u;
              long long v72 = 0u;
              long long v70 = 0u;
              *(_OWORD *)__int16 v69 = 0u;
              MEMORY[0x223C99FB0](v69, v73);
              uint64_t v82 = 0;
              long long v80 = 0u;
              long long v81 = 0u;
              long long v78 = 0u;
              long long v79 = 0u;
              long long v76 = 0u;
              long long v77 = 0u;
              memset(buf, 0, sizeof(buf));
              uint64_t v45 = v38 + 40 * v39;
              uint64_t v46 = *(unsigned int *)(v45 + 8);
              MCCAndMNC::getMcc(v67, (MCCAndMNC *)v69);
              MCCAndMNC::getMnc(v65, (MCCAndMNC *)v69);
              MEMORY[0x223C99430](buf, v45 + 16, v46, v67, v65, v42);
              if (v66 < 0) {
                operator delete((void *)v65[1]);
              }
              if (v68 < 0) {
                operator delete((void *)v67[1]);
              }
              NetworkListScanResult::addOperator();
              if (SBYTE7(v81) < 0) {
                operator delete((void *)v80);
              }
              if (SHIBYTE(v79) < 0) {
                operator delete(*((void **)&v78 + 1));
              }
              if (SHIBYTE(v77) < 0) {
                operator delete(*((void **)&v76 + 1));
              }
              if ((buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
              if (SHIBYTE(v72) < 0) {
                operator delete(*((void **)&v71 + 1));
              }
              if (SHIBYTE(v70) < 0) {
                operator delete(v69[1]);
              }
              if (SHIBYTE(v74) < 0) {
                operator delete(v73[0]);
              }
              unint64_t v39 = v41;
              uint64_t v38 = v61;
            }
            while (0xCCCCCCCCCCCCCCCDLL * ((v62 - v61) >> 3) > v41++);
            *(void *)long long buf = &v61;
            std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
            uint64_t v6 = v53;
            unsigned int v4 = v55;
          }
        }
        else
        {
          *(void *)long long buf = &v61;
          std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
          ((void (*)(void, uint64_t, unsigned __int16 *, void))*MEMORY[0x263F8BD78])(v60[0], 16, v36, v37);
        }
      }
      if (v57 >= 3) {
        uint64_t v48 = 0;
      }
      else {
        uint64_t v48 = v4;
      }
      uint64_t v49 = *(void *)(v6 + 48);
      *(void *)long long buf = v59;
      *(void *)&uint8_t buf[8] = v7;
      atomic_fetch_add_explicit((atomic_ullong *volatile)v7 + 1, 1uLL, memory_order_relaxed);
      (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v49 + 32))(v49, v48, buf);
      if (*(void *)&buf[8]) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
      }
      if (v21) {
        operator delete(v21);
      }
      goto LABEL_90;
    }
    int v18 = v16;
    v69[0] = v15;
    memset(buf, 0, 24);
    tlv::parseV<nas::tlv::NetworkNameSourceList>((unsigned __int8 **)v69, v16, (std::vector<unsigned int> *)buf);
    uint64_t v52 = v6;
    unsigned int v54 = v4;
    int v50 = v18;
    char v56 = v69[0];
    if (v69[0])
    {
      uint64_t v20 = *(unsigned int **)buf;
      int v19 = *(unsigned int **)&buf[8];
      if (*(void *)buf == *(void *)&buf[8])
      {
        int v21 = 0;
        int v26 = 0;
        goto LABEL_46;
      }
      uint64_t v51 = v7;
      int v21 = 0;
      unint64_t v22 = 0;
      uint64_t v23 = 0;
      do
      {
        int v24 = nas::convert(*v20);
        int v25 = v24;
        if (v22 >= v23)
        {
          uint64_t v27 = (v22 - v21) >> 2;
          unint64_t v28 = v27 + 1;
          if ((unint64_t)(v27 + 1) >> 62) {
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          }
          if ((v23 - v21) >> 1 > v28) {
            unint64_t v28 = (v23 - v21) >> 1;
          }
          if ((unint64_t)(v23 - v21) >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v29 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v29 = v28;
          }
          if (v29)
          {
            if (v29 >> 62) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            uint64_t v30 = (char *)operator new(4 * v29);
          }
          else
          {
            uint64_t v30 = 0;
          }
          long long v31 = &v30[4 * v27];
          *(_DWORD *)long long v31 = v25;
          int v26 = v31 + 4;
          while (v22 != v21)
          {
            int v32 = *((_DWORD *)v22 - 1);
            v22 -= 4;
            *((_DWORD *)v31 - 1) = v32;
            v31 -= 4;
          }
          uint64_t v23 = &v30[4 * v29];
          if (v21) {
            operator delete(v21);
          }
          int v21 = v31;
        }
        else
        {
          *(_DWORD *)unint64_t v22 = v24;
          int v26 = v22 + 4;
        }
        ++v20;
        unint64_t v22 = v26;
      }
      while (v20 != v19);
    }
    else
    {
      uint64_t v51 = v7;
      int v21 = 0;
      int v26 = 0;
    }
    uint64_t v20 = *(unsigned int **)buf;
    uint64_t v7 = v51;
LABEL_46:
    unsigned int v4 = v54;
    if (v20)
    {
      *(void *)&uint8_t buf[8] = v20;
      operator delete(v20);
    }
    if (!v56) {
      ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v60[0], 18, v17, v50);
    }
    uint64_t v6 = v52;
    goto LABEL_51;
  }
  v69[0] = TlvValue;
  unsigned __int16 v11 = tlv::parseV<nas::tlv::ScanStatus>((unint64_t *)v69, v10);
  if (v69[0])
  {
    unsigned __int16 v12 = v11;
    uint64_t v13 = *v58;
    if (os_log_type_enabled(*v58, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = nas::asString(v12);
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v14;
      _os_log_impl(&dword_22231A000, v13, OS_LOG_TYPE_DEFAULT, "#I Incremental scan status: %s", buf, 0xCu);
    }
    NetworkListScanResult::setState();
    goto LABEL_16;
  }
  long long v33 = *v58;
  if (os_log_type_enabled(*v58, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl(&dword_22231A000, v33, OS_LOG_TYPE_ERROR, "Did not find incremental scan status TLV", buf, 2u);
  }
LABEL_90:
  std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v7);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v60);
}

void sub_2224F524C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a20);
  uint64_t v63 = *(void **)(v61 - 240);
  if (v63)
  {
    *(void *)(v61 - 232) = v63;
    operator delete(v63);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::target_type()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN27QMINetworkListCommandDriver21bindSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(uint64_t **)(a1 + 32);
  uint64_t v4 = *v3;
  unsigned int v5 = *((_DWORD *)v3 + 2);
  if (v5 - 1 >= 3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v5;
  }
  uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 88) + 16))(*(void *)(v4 + 88), v6);
  if (*(_DWORD *)(a2 + 4))
  {
    uint64_t v8 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = qmi::asString();
      int v10 = *(_DWORD *)(a2 + 4);
      int v11 = 136315394;
      uint64_t v12 = v9;
      __int16 v13 = 1024;
      int v14 = v10;
      _os_log_error_impl(&dword_22231A000, v8, OS_LOG_TYPE_ERROR, "Error binding subscription: %s (0x%x)", (uint8_t *)&v11, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c110_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c110_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMINetworkListCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3188;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMINetworkListCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3188;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_6(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  cast_message_type<nas::BindSubscription::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2224F5618(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualModeEvents>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualModeEvents>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualModeEvents>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualModeEvents>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN27QMINetworkListCommandDriver27sendIndRegisterRequest_syncENS_16SubscriptionTypeEE3__3EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  char v3 = *(uint64_t **)(a1 + 32);
  uint64_t v4 = *v3;
  unsigned int v5 = *((_DWORD *)v3 + 2);
  if (v5 - 1 >= 3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v5;
  }
  uint64_t v7 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 88) + 16))(*(void *)(v4 + 88), v6);
  int v8 = *(_DWORD *)(a2 + 4);
  uint64_t v9 = *v7;
  int v10 = *v7;
  if (v8)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11[0] = 67109378;
      v11[1] = v8;
      __int16 v12 = 2080;
      uint64_t v13 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v9, OS_LOG_TYPE_ERROR, "Register for indications failed: Error in response with code %d (%s)", (uint8_t *)v11, 0x12u);
    }
  }
  else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v11[0]) = 0;
    _os_log_impl(&dword_22231A000, v9, OS_LOG_TYPE_DEFAULT, "#I Register for indications succeeded", (uint8_t *)v11, 2u);
  }
}

uint64_t __copy_helper_block_e8_32c116_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver27sendIndRegisterRequest_syncEN3qmi16SubscriptionTypeEE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c116_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver27sendIndRegisterRequest_syncEN3qmi16SubscriptionTypeEE3__3EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_3,std::allocator<QMINetworkListCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3258;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_3,std::allocator<QMINetworkListCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3258;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas18IndicationRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  cast_message_type<nas::IndicationRegister::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2224F592C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0>(QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v1 = *a1;
  *(void *)(*(void *)*a1 + 120) = *(void *)(*(void *)*a1 + 112);
  *(_OWORD *)std::string __p = 0u;
  long long v7 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v2 = (const void **)__p[1];
  if (__p[1] != (void *)v7)
  {
    while (*((unsigned char *)*v2 + 8) != 16)
    {
      if (++v2 == (const void **)v7) {
        goto LABEL_8;
      }
    }
  }
  if (v2 != (const void **)v7)
  {
    if (v3)
    {
      uint64_t v4 = (char *)v3 + 9;
      unsigned char *v4 = 0;
      char v5 = *(unsigned char *)(v1 + 12);
      if (v5)
      {
        char v3 = (capabilities::ct *)nas::operator|=(v4, 1);
        char v5 = *(unsigned char *)(v1 + 12);
      }
      if ((v5 & 2) != 0)
      {
        char v3 = (capabilities::ct *)nas::operator|=(v4, 2);
        char v5 = *(unsigned char *)(v1 + 12);
      }
      if ((v5 & 0x10) != 0)
      {
        char v3 = (capabilities::ct *)nas::operator|=(v4, 4);
        char v5 = *(unsigned char *)(v1 + 12);
      }
      if ((v5 & 0x20) != 0) {
        char v3 = (capabilities::ct *)nas::operator|=(v4, 8);
      }
      if (capabilities::ct::supports5G(v3))
      {
        if ((*(unsigned char *)(v1 + 12) & 0x40) != 0) {
          nas::operator|=(v4, 16);
        }
      }
      qmi::ClientRouter::get();
      operator new();
    }
    __cxa_bad_cast();
  }
LABEL_8:
  operator new();
}

void sub_2224F5D30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a22);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v24);
  uint64_t v26 = a12;
  a12 = 0;
  if (v26) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v23, v26);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a13);
  MEMORY[0x223C9A950](v22, 0x1020C4034E03FFCLL);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTypesToScan>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTypesToScan>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTypesToScan>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  long long v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTypesToScan>::clone()
{
}

os_log_t *___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN27QMINetworkListCommandDriver18performNetworkScanEN10subscriber7SimSlotEhENK3__0clEvEUlNS_16SubscriptionTypeERKN3nas29PerformIncrementalNetworkScan8ResponseEE_EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  v9[3] = *MEMORY[0x263EF8340];
  unsigned int v3 = *(_DWORD *)(a1 + 48);
  uint64_t v4 = **(void **)(a1 + 32);
  if (v3 - 1 >= 3) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v3;
  }
  uint64_t result = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 88) + 16))(*(void *)(v4 + 88), v5);
  if (*(_DWORD *)(a2 + 4))
  {
    long long v7 = *result;
    if (os_log_type_enabled(*result, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v9[0]) = 136315138;
      *(void *)((char *)v9 + 4) = qmi::asString();
      _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#N Incremental network scan failed: %s", (uint8_t *)v9, 0xCu);
    }
    v9[0] = 0;
    NetworkListCommandDriverResponseError::NetworkListCommandDriverResponseError();
    if (v3 - 1 >= 3) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = v3;
    }
    return (os_log_t *)(*(uint64_t (**)(void, uint64_t, void))(**(void **)(v4 + 48) + 24))(*(void *)(v4 + 48), v8, v9[0]);
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c190_ZTSNSt3__110shared_ptrIZZN27QMINetworkListCommandDriver18performNetworkScanEN10subscriber7SimSlotEhENK3__0clEvEUlN3qmi16SubscriptionTypeERKN3nas29PerformIncrementalNetworkScan8ResponseEE_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c190_ZTSNSt3__110shared_ptrIZZN27QMINetworkListCommandDriver18performNetworkScanEN10subscriber7SimSlotEhENK3__0clEvEUlN3qmi16SubscriptionTypeERKN3nas29PerformIncrementalNetworkScan8ResponseEE_EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::PerformIncrementalNetworkScan::Response const&)#1},std::allocator<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::PerformIncrementalNetworkScan::Response const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3328;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::PerformIncrementalNetworkScan::Response const&)#1},std::allocator<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::PerformIncrementalNetworkScan::Response const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3328;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas29PerformIncrementalNetworkScan8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224F6158(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0>(QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  uint64_t v1 = *a1;
  uint64_t v27 = a1;
  uint64_t v28 = v1;
  uint64_t v2 = *(void ***)v1;
  unsigned int v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 88) + 16))(*(void *)(*(void *)v1 + 88), *(unsigned int *)(v1 + 8));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = asString();
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I Request is to set the network selection mode to %s", (uint8_t *)&buf, 0xCu);
  }
  int v4 = *(_DWORD *)(v1 + 12);
  char v5 = *(unsigned char *)(v1 + 16);
  int v6 = *(_DWORD *)(v1 + 20);
  uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void *, void))(*v2[11] + 16))(v2[11], *(unsigned int *)(v1 + 8));
  uint64_t v8 = v7;
  if (v6 == 3)
  {
    unint64_t v29 = 0;
    uint64_t v9 = *MEMORY[0x263F03778];
    uint64_t v10 = *MEMORY[0x263F03768];
    uint64_t v11 = *MEMORY[0x263EFFE70];
    uint64_t v26 = *MEMORY[0x263EFFE50];
    (*(void (**)(std::string *__return_ptr))(*v2[17] + 40))(&buf);
    uint64_t v25 = v10;
    ctu::cf::CFSharedRef<__CFBoolean const>::CFSharedRef<void const,void>(&v29, (CFTypeRef *)&buf.__r_.__value_.__l.__data_);
    ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef((const void **)&buf.__r_.__value_.__l.__data_);
    buf.__r_.__value_.__s.__data_[0] = 0;
    ctu::cf::assign((ctu::cf *)&buf, v29, v12);
    int v13 = buf.__r_.__value_.__s.__data_[0];
    uint64_t v14 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = CSIBOOLAsString();
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v15;
      _os_log_impl(&dword_22231A000, v14, OS_LOG_TYPE_DEFAULT, "#I Device currently locked for GWL for manual selection status: %s", (uint8_t *)&buf, 0xCu);
      uint64_t v14 = *v8;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      ratSelectionAsStr();
      int v16 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &buf
          : (std::string *)buf.__r_.__value_.__r.__words[0];
      *(_DWORD *)int v37 = 136446210;
      *(void *)&v37[4] = v16;
      _os_log_impl(&dword_22231A000, v14, OS_LOG_TYPE_DEFAULT, "#I Current RAT Selection %{public}s", v37, 0xCu);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }
    if (v4 == 1)
    {
      int v17 = v5 & 0xC;
      int v18 = *v8;
      BOOL v19 = os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT);
      if (v17)
      {
        if (v19)
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl(&dword_22231A000, v18, OS_LOG_TYPE_DEFAULT, "#I CDMA is present and BB supports scan with CH mode, not removing CDMA", (uint8_t *)&buf, 2u);
        }
        (*(void (**)(void *, uint64_t, void, uint64_t, uint64_t, uint64_t))(*v2[17] + 16))(v2[17], v9, *MEMORY[0x263EFFB40], v25, v11, v26);
      }
      else if (v19)
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl(&dword_22231A000, v18, OS_LOG_TYPE_DEFAULT, "#I CDMA is not present, no need to change mode preference", (uint8_t *)&buf, 2u);
      }
    }
    else if (v13)
    {
      int v21 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl(&dword_22231A000, v21, OS_LOG_TYPE_DEFAULT, "#I Requested mode is not manual, GWL lock status is still true, resetting it", (uint8_t *)&buf, 2u);
      }
      (*(void (**)(void *, uint64_t, void, uint64_t, uint64_t, uint64_t))(*v2[17] + 16))(v2[17], v9, *MEMORY[0x263EFFB38], v25, v11, v26);
    }
    ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::~SharedRef((const void **)&v29);
  }
  else
  {
    uint64_t v20 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_22231A000, v20, OS_LOG_TYPE_DEFAULT, "#I CDMA roaming not supported", (uint8_t *)&buf, 2u);
    }
  }
  uint64_t v22 = *(unsigned int *)(v1 + 8);
  uint64_t v23 = *(unsigned int *)(v1 + 12);
  NetworkListOperator::NetworkListOperator(&buf, (const NetworkListOperator *)(v1 + 24));
  *(void *)int v37 = 0;
  ((void (*)(void **, uint64_t, uint64_t, std::string *, unsigned char *))(*v2)[8])(v2, v22, v23, &buf, v37);
  if (*(void *)v37)
  {
    dispatch_group_leave(*(dispatch_group_t *)v37);
    if (*(void *)v37) {
      dispatch_release(*(dispatch_object_t *)v37);
    }
  }
  if (v36 < 0) {
    operator delete(__p);
  }
  if (v34 < 0) {
    operator delete(v33);
  }
  if (v32 < 0) {
    operator delete(v31);
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  std::unique_ptr<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0,std::default_delete<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0>>::~unique_ptr[abi:ne180100](&v28);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v27);
}

void sub_2224F6674(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
}

uint64_t *std::unique_ptr<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0,std::default_delete<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(char *)(v2 + 143) < 0) {
      operator delete(*(void **)(v2 + 120));
    }
    if (*(char *)(v2 + 119) < 0) {
      operator delete(*(void **)(v2 + 96));
    }
    if (*(char *)(v2 + 87) < 0) {
      operator delete(*(void **)(v2 + 64));
    }
    if (*(char *)(v2 + 47) < 0) {
      operator delete(*(void **)(v2 + 24));
    }
    MEMORY[0x223C9A950](v2, 0x1072C40E83DF3DCLL);
  }
  return a1;
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::NetworkSelectionPreference>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  unsigned int v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::NetworkSelectionPreference>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::NetworkSelectionPreference>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreference>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreference>::getSize()
{
  return tlv::size<wms::tlv::MemoryStorageIdentification>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreference>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = *a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<nas::tlv::NetworkSelectionPreference>(a2, a1 + 10);
  uint64_t v7 = *a2 - v5;
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreference>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionChangeDuration>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionChangeDuration>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionChangeDuration>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionChangeDuration>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceMNC>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceMNC>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceMNC>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceMNC>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceRAT>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceRAT>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_ProfileIdentifier>();
}

char *qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceRAT>::write(uint64_t a1, char **a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = *a2;
  uint64_t v5 = (uint64_t)(*a2 + 3);
  *a2 = (char *)v5;
  uint64_t result = tlv::writeV<nas::tlv::NetworkSelectionPreferenceRAT>(a2, (int *)(a1 + 12));
  uint64_t v7 = &(*a2)[-v5];
  char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceRAT>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN27QMINetworkListCommandDriver19applySelection_syncEN10subscriber7SimSlotE20NetworkSelectionMode19NetworkListOperatorN8dispatch13group_sessionEE3__5EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
}

uint64_t __copy_helper_block_e8_32c175_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver19applySelection_syncEN10subscriber7SimSlotE20NetworkSelectionMode19NetworkListOperatorN8dispatch13group_sessionEE3__5EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c175_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver19applySelection_syncEN10subscriber7SimSlotE20NetworkSelectionMode19NetworkListOperatorN8dispatch13group_sessionEE3__5EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_5,std::allocator<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_5>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D34E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_5,std::allocator<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_5>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D34E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_5,std::allocator<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_5>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 32);
  if (v2)
  {
    dispatch_group_leave(v2);
    char v3 = *(NSObject **)(a1 + 32);
    if (v3)
    {
      dispatch_release(v3);
    }
  }
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas28SetSystemSelectionPreference8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  cast_message_type<nas::SetSystemSelectionPreference::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2224F6E5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void cast_message_type<nas::SetSystemSelectionPreference::Response const&>::cast(uint64_t a1@<X0>, qmi::ResponseBase *a2@<X8>)
{
  if (*(_DWORD *)(a1 + 40) != 1 || *(_WORD *)(a1 + 44) == 3)
  {
    std::string __p = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, (QMIServiceMsg *)a1);
    qmi::Response<(unsigned short)51,nas::SetSystemSelectionPreference::ResponseTLVList>::Response(a2, __p);
    if (__p)
    {
      uint64_t v5 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError((QMIServiceMsg *)a1);
    qmi::Response<(unsigned short)51,nas::SetSystemSelectionPreference::ResponseTLVList>::Response((uint64_t)a2);
  }
}

void sub_2224F6F10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t qmi::Response<(unsigned short)51,nas::SetSystemSelectionPreference::ResponseTLVList>::Response(uint64_t a1)
{
  uint64_t v2 = (qmi::MessageBase *)qmi::MessageBase::MessageBase();
  qmi::MessageBase::validateMsgId(v2);
  return a1;
}

void sub_2224F6F5C(_Unwind_Exception *a1)
{
  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

qmi::ResponseBase *qmi::Response<(unsigned short)51,nas::SetSystemSelectionPreference::ResponseTLVList>::Response(qmi::ResponseBase *a1, const void *a2)
{
  char v3 = (qmi::MessageBase *)qmi::ResponseBase::ResponseBase(a1, a2);
  qmi::MessageBase::validateMsgId(v3);
  return a1;
}

void sub_2224F6FA0(_Unwind_Exception *a1)
{
  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegisterAction>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegisterAction>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegisterAction>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegisterAction>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualNetworkRegisterInformation>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualNetworkRegisterInformation>::getSize()
{
  return tlv::size<wms::tlv::MemoryStorageIdentification>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualNetworkRegisterInformation>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = *a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<nas::tlv::ManualNetworkRegisterInformation>(a2, a1 + 10);
  uint64_t v7 = *a2 - v5;
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualNetworkRegisterInformation>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::MNCDigitIncludeStatus>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::MNCDigitIncludeStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::MNCDigitIncludeStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::MNCDigitIncludeStatus>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN27QMINetworkListCommandDriver19applySelection_syncEN10subscriber7SimSlotE20NetworkSelectionMode19NetworkListOperatorN8dispatch13group_sessionEE3__9EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
}

uint64_t __copy_helper_block_e8_32c175_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver19applySelection_syncEN10subscriber7SimSlotE20NetworkSelectionMode19NetworkListOperatorN8dispatch13group_sessionEE3__9EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c175_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver19applySelection_syncEN10subscriber7SimSlotE20NetworkSelectionMode19NetworkListOperatorN8dispatch13group_sessionEE3__9EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_9,std::allocator<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_9>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3658;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_9,std::allocator<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_9>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3658;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_9,std::allocator<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_9>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (v2)
  {
    dispatch_group_leave(v2);
    char v3 = *(NSObject **)(a1 + 40);
    if (v3)
    {
      dispatch_release(v3);
    }
  }
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas23InitiateNetworkRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224F741C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void std::__shared_ptr_emplace<NetworkListSelectionResult>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D36A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NetworkListSelectionResult>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D36A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::optional<MCCAndMNC>::operator=[abi:ne180100]<MCCAndMNC,void>(uint64_t a1, uint64_t a2)
{
  char v3 = (MCC *)(a1 + 32);
  uint64_t v4 = (const MCC *)(a2 + 32);
  if (*(unsigned char *)(a1 + 64))
  {
    MCC::operator=();
    MCC::operator=();
  }
  else
  {
    MCC::MCC();
    MCC::MCC(v3, v4);
    *(unsigned char *)(a1 + 64) = 1;
  }
  return a1;
}

void sub_2224F7540(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*(void **)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

void dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0>(QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  memset(v4, 0, sizeof(v4));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v4);
  char v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 88) + 16))(*(void *)(v2 + 88), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I Requesting current network selection setting in baseband", buf, 2u);
  }
  qmi::ClientRouter::get();
  operator new();
}

void sub_2224F77C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a22);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v24);
  uint64_t v26 = a12;
  a12 = 0;
  if (v26) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v23, v26);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a13);
  MEMORY[0x223C9A950](v22, 0x1020C403A5D3213);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN27QMINetworkListCommandDriver26getNetworkSelectionSettingEN10subscriber7SimSlotEENK3__0clEvEUlNS_16SubscriptionTypeERKN3nas14GetPlmnModeBit8ResponseEE_EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  char v3 = *(uint64_t **)(a1 + 32);
  unsigned int v4 = *(_DWORD *)(a1 + 48);
  uint64_t v5 = *v3;
  if (v4 - 1 >= 3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v4;
  }
  int v7 = *((_DWORD *)this + 1);
  if (v7)
  {
    uint64_t v8 = *(NSObject **)v3[1];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v15) = 67109378;
      HIDWORD(v15) = v7;
      __int16 v16 = 2080;
      uint64_t v17 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v8, OS_LOG_TYPE_ERROR, "PLMN mode bit request failed: Error in response with code %d (%s)", (uint8_t *)&v15, 0x12u);
      int v7 = *((_DWORD *)this + 1);
    }
    if (v7 == 80) {
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v5 + 48) + 56))(*(void *)(v5 + 48), v6, 3);
    }
  }
  else
  {
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(this);
    if (TlvValue)
    {
      uint64_t v11 = TlvValue;
      int v12 = v10;
      uint64_t v15 = TlvValue;
      BOOL v13 = tlv::parseV<nas::tlv::PlmnMode>((unint64_t *)&v15, v10);
      if (v15)
      {
        if (v13) {
          uint64_t v14 = 2;
        }
        else {
          uint64_t v14 = 1;
        }
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v5 + 48) + 56))(*(void *)(v5 + 48), v6, v14);
      }
      else
      {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)this, 16, v11, v12);
      }
    }
  }
}

uint64_t __copy_helper_block_e8_32c182_ZTSNSt3__110shared_ptrIZZN27QMINetworkListCommandDriver26getNetworkSelectionSettingEN10subscriber7SimSlotEENK3__0clEvEUlN3qmi16SubscriptionTypeERKN3nas14GetPlmnModeBit8ResponseEE_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c182_ZTSNSt3__110shared_ptrIZZN27QMINetworkListCommandDriver26getNetworkSelectionSettingEN10subscriber7SimSlotEENK3__0clEvEUlN3qmi16SubscriptionTypeERKN3nas14GetPlmnModeBit8ResponseEE_EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GetPlmnModeBit::Response const&)#1},std::allocator<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GetPlmnModeBit::Response const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3728;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GetPlmnModeBit::Response const&)#1},std::allocator<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GetPlmnModeBit::Response const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3728;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas14GetPlmnModeBit8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224F7B84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void std::__shared_ptr_emplace<NetworkListScanResult>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3778;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NetworkListScanResult>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3778;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_emplace<NetworkListScanResult>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    unsigned int v4 = *(void **)(a1 + 24);
    if (v3 != v1)
    {
      do
      {
        if (*(char *)(v3 - 17) < 0) {
          operator delete(*(void **)(v3 - 40));
        }
        if (*(char *)(v3 - 41) < 0) {
          operator delete(*(void **)(v3 - 64));
        }
        if (*(char *)(v3 - 73) < 0) {
          operator delete(*(void **)(v3 - 96));
        }
        if (*(char *)(v3 - 113) < 0) {
          operator delete(*(void **)(v3 - 136));
        }
        v3 -= 136;
      }
      while (v3 != v1);
      unsigned int v4 = *(void **)(a1 + 24);
    }
    *(void *)(a1 + 32) = v1;
    operator delete(v4);
  }
}

void disableNasServingSystemIndications(uint64_t a1, qmi::Client *a2)
{
  if (*((void *)a2 + 2) && qmi::Client::getSvcType(a2) == 3)
  {
    memset(v10, 0, sizeof(v10));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v10);
    *qmi::MutableMessageBase::getTLV<nas::tlv::ServingSysEvents>((uint64_t)v10, 19) = 0;
    v5[5] = a2;
    uint64_t v6 = QMIServiceMsg::create();
    int v7 = 25000;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    v5[0] = MEMORY[0x263EF8330];
    v5[1] = 0x40000000;
    _OWORD v5[2] = ___Z34disableNasServingSystemIndicationsPKN3ctu11OsLogLoggerEN3qmi6ClientE_block_invoke_2;
    v5[3] = &__block_descriptor_tmp_3_2;
    v5[4] = a1;
    aBlock[0] = MEMORY[0x263EF8330];
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_27;
    aBlock[3] = &unk_264611058;
    aBlock[4] = v5;
    unsigned int v4 = _Block_copy(aBlock);
    uint64_t v9 = v4;
    if (v6)
    {
      qmi::Client::send();
      unsigned int v4 = v9;
    }
    if (v4) {
      _Block_release(v4);
    }
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v10);
  }
}

void sub_2224F7E30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___Z34disableNasServingSystemIndicationsPKN3ctu11OsLogLoggerEN3qmi6ClientE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    uint64_t v3 = **(NSObject ***)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "Error in response to disabling serving system indications with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

void dataModesFromSysMode(capabilities::ct *a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  switch(a2)
  {
    case 1u:
      *(_DWORD *)uint64_t v6 = 10;
      std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>((char *)a3, v6, (uint64_t)&v6[4], 1uLL);
      break;
    case 2u:
      *(_DWORD *)uint64_t v6 = 13;
      std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>((char *)a3, v6, (uint64_t)&v6[4], 1uLL);
      break;
    case 4u:
      *(void *)uint64_t v6 = 0x200000001;
      std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>((char *)a3, v6, (uint64_t)&v6[8], 2uLL);
      break;
    case 5u:
    case 9u:
      *(void *)uint64_t v6 = 0x400000003;
      *(_DWORD *)&v6[8] = 5;
      std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>((char *)a3, v6, (uint64_t)&v7, 3uLL);
      break;
    case 8u:
      if (capabilities::ct::supports5G(a1))
      {
        *(void *)uint64_t v6 = 0x100000000ELL;
        std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>((char *)a3, v6, (uint64_t)&v6[8], 2uLL);
      }
      else
      {
        *(_DWORD *)uint64_t v6 = 14;
        std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>((char *)a3, v6, (uint64_t)&v6[4], 1uLL);
      }
      break;
    case 0xCu:
      *(_DWORD *)uint64_t v6 = 17;
      std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>((char *)a3, v6, (uint64_t)&v6[4], 1uLL);
      break;
    default:
      __int16 v5 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v6 = 136315394;
        *(void *)&v6[4] = nas::asString(a2);
        __int16 v7 = 1024;
        unsigned int v8 = a2;
        _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#N IMS Pref status response has invalid Data Mode mask: %s (0x%x)", v6, 0x12u);
      }
      break;
  }
}

void sub_2224F8120(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  __int16 v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 2)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *__int16 v7 = 0;
      v7[1] = 0;
      _OWORD v7[2] = 0;
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<unsigned int>::__vallocate[abi:ne180100](v7, v11);
    BOOL v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_15:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      BOOL v19 = __src;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  uint64_t v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 2;
  if (v15 >= a4) {
    goto LABEL_15;
  }
  __int16 v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    BOOL v19 = v16;
LABEL_17:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_18:
  *uint64_t v12 = &v9[v17];
  return result;
}

void Mav7SignalStrengthCommandDriver::create(void *a1@<X0>, NSObject **a2@<X1>, std::__shared_weak_count **a3@<X8>)
{
  uint64_t v6 = (std::__shared_weak_count *)operator new(0x80uLL);
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3928;
  __int16 v7 = v6 + 1;
  uint64_t v8 = *a2;
  *a2 = 0;
  dispatch_object_t object = v8;
  Mav7SignalStrengthCommandDriver::Mav7SignalStrengthCommandDriver(&v6[1].__vftable, a1, &object);
  if (object) {
    dispatch_release(object);
  }
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3978;
  v6[1].__shared_owners_ = (uint64_t)&unk_26D4D39F8;
  uint64_t v9 = (std::__shared_weak_count *)v6[2].__vftable;
  if (!v9)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v6[1].__shared_weak_owners_ = (uint64_t)v7;
    v6[2].__vftable = (std::__shared_weak_count_vtbl *)v6;
    goto LABEL_7;
  }
  if (v9->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v6[1].__shared_weak_owners_ = (uint64_t)v7;
    v6[2].__vftable = (std::__shared_weak_count_vtbl *)v6;
    std::__shared_weak_count::__release_weak(v9);
LABEL_7:
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  *a3 = v7;
  a3[1] = v6;
}

void sub_2224F83D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  std::__shared_weak_count::~__shared_weak_count(v10);
  operator delete(v12);
  _Unwind_Resume(a1);
}

void *Mav7SignalStrengthCommandDriver::Mav7SignalStrengthCommandDriver(void *a1, void *a2, dispatch_object_t *a3)
{
  dispatch_object_t object = *a3;
  *a3 = 0;
  QMISignalStrengthCommandDriver::QMISignalStrengthCommandDriver((uint64_t)a1, a2, &object);
  if (object) {
    dispatch_release(object);
  }
  *a1 = &unk_26D4D3850;
  a1[1] = &unk_26D4D38D0;
  return a1;
}

void sub_2224F847C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void Mav7SignalStrengthCommandDriver::start(Mav7SignalStrengthCommandDriver *this)
{
  v1[0] = 0;
  v1[1] = 0;
  std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(v1, (void *)this + 2);
  operator new();
}

void Mav7SignalStrengthCommandDriver::registered(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Mav7SignalStrengthCommandDriver Registered", buf, 2u);
  }
  __int16 v5 = *(QMIVirtualClient **)a2;
  uint64_t v6 = *(atomic_ullong **)(a2 + 8);
  v11[0] = v5;
  v11[1] = (QMIVirtualClient *)v6;
  if (v6) {
    atomic_fetch_add_explicit(v6 + 1, 1uLL, memory_order_relaxed);
  }
  QMISignalStrengthCommandDriver::registered(a1, v11);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v6);
  }
  memset(v10, 0, sizeof(v10));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v10);
  *qmi::MutableMessageBase::getTLV<nas::tlv::SigInfoEvents>((uint64_t)v10, 25) = 1;
  uint64_t v7 = *(void *)(a1 + 72);
  v9[0] = MEMORY[0x263EF8330];
  v9[1] = 0x40000000;
  _OWORD v9[2] = ___ZN31Mav7SignalStrengthCommandDriver10registeredENSt3__110shared_ptrI16QMIVirtualClientEE_block_invoke_2;
  v9[3] = &__block_descriptor_tmp_3_3;
  void v9[4] = a1;
  if (!*(unsigned char *)(v7 + 72) || !*(void *)(v7 + 56)) {
    __TUAssertTrigger();
  }
  void v12[5] = v7 + 40;
  uint64_t v13 = QMIServiceMsg::create();
  int v14 = 25000;
  uint64_t v15 = 0;
  uint64_t aBlock = 0;
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 0x40000000;
  void v12[2] = ___ZN16QMIVirtualClient4sendIN3nas18IndicationRegister7RequestEU13block_pointerFvRKNS2_8ResponseEEEEvRKT_T0__block_invoke;
  void v12[3] = &unk_2646111A8;
  void v12[4] = v9;
  *(void *)std::string buf = MEMORY[0x263EF8330];
  uint64_t v18 = 0x40000000;
  BOOL v19 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_28;
  uint64_t v20 = &unk_2646111D0;
  int v21 = v12;
  uint64_t v8 = _Block_copy(buf);
  uint64_t aBlock = v8;
  if (v13)
  {
    qmi::Client::send();
    uint64_t v8 = aBlock;
  }
  if (v8) {
    _Block_release(v8);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v10);
}

void sub_2224F8780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void ___ZN31Mav7SignalStrengthCommandDriver10registeredENSt3__110shared_ptrI16QMIVirtualClientEE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    uint64_t v3 = *(NSObject **)(*(void *)(a1 + 32) + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#E :registered: Error registering for Sig Info events = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

void non-virtual thunk to'Mav7SignalStrengthCommandDriver::registered(uint64_t a1, uint64_t a2)
{
}

void Mav7SignalStrengthCommandDriver::sendNewThresholds(uint64_t a1, char **a2, int a3)
{
  memset(v10, 0, sizeof(v10));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v10);
  prepareThresholds((uint64_t)v10);
  populateThresholds(*a2, (uint64_t)v10);
  *qmi::MutableMessageBase::getTLV<nas::tlv::LinkQualityIndicator>((uint64_t)v10, 160) = 1;
  uint64_t v6 = *(void *)(a1 + 72);
  v8[0] = MEMORY[0x263EF8330];
  v8[1] = 0x40000000;
  _OWORD v8[2] = ___ZN31Mav7SignalStrengthCommandDriver17sendNewThresholdsENSt3__110shared_ptrIK15InputThresholdsEE21SignalStrengthCmdType_block_invoke_2;
  v8[3] = &__block_descriptor_tmp_8_13;
  void v8[4] = a1;
  int v9 = a3;
  if (!*(unsigned char *)(v6 + 72) || !*(void *)(v6 + 56)) {
    __TUAssertTrigger();
  }
  void v11[5] = v6 + 40;
  uint64_t v12 = QMIServiceMsg::create();
  int v13 = 25000;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  v11[0] = MEMORY[0x263EF8330];
  v11[1] = 0x40000000;
  _DWORD v11[2] = ___ZN16QMIVirtualClient4sendIN3nas14ConfigSigInfo27RequestEU13block_pointerFvRKNS2_8ResponseEEEEvRKT_T0__block_invoke;
  v11[3] = &unk_2646111F8;
  void v11[4] = v8;
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_28;
  aBlock[3] = &unk_2646111D0;
  aBlock[4] = v11;
  uint64_t v7 = _Block_copy(aBlock);
  uint64_t v15 = v7;
  if (v12)
  {
    qmi::Client::send();
    uint64_t v7 = v15;
  }
  if (v7) {
    _Block_release(v7);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v10);
}

void sub_2224F8A3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN31Mav7SignalStrengthCommandDriver17sendNewThresholdsENSt3__110shared_ptrIK15InputThresholdsEE21SignalStrengthCmdType_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(_DWORD *)(a2 + 4);
  __int16 v5 = *(NSObject **)(v3 + 48);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (!v4)
  {
    if (v6)
    {
      LOWORD(v10[0]) = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I sendNewThresholds: Updated thresholds", (uint8_t *)v10, 2u);
    }
    int v8 = *(_DWORD *)(a1 + 40);
    if (v8 == 1)
    {
      int v9 = *(void (**)(void))(**(void **)(v3 + 88) + 16);
    }
    else
    {
      if (v8) {
        return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 104))(v3, 1);
      }
      int v9 = *(void (**)(void))(**(void **)(v3 + 88) + 16);
    }
    v9();
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 104))(v3, 1);
  }
  if (v6)
  {
    v10[0] = 67109378;
    v10[1] = v4;
    __int16 v11 = 2080;
    uint64_t v12 = qmi::asString();
    _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#E sendNewThresholds: Error in response with code = 0x%x (%s)", (uint8_t *)v10, 0x12u);
  }
  return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(v3 + 88) + 24))(*(void *)(v3 + 88), 1, *(unsigned int *)(a1 + 40));
}

void Mav7SignalStrengthCommandDriver::sendGetSignalStrength(Mav7SignalStrengthCommandDriver *this, char a2)
{
  memset(v8, 0, sizeof(v8));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v8);
  uint64_t v4 = *((void *)this + 9);
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 0x40000000;
  _OWORD v6[2] = ___ZN31Mav7SignalStrengthCommandDriver21sendGetSignalStrengthEb_block_invoke;
  v6[3] = &__block_descriptor_tmp_9_7;
  v6[4] = this;
  char v7 = a2;
  if (!*(unsigned char *)(v4 + 72) || !*(void *)(v4 + 56)) {
    __TUAssertTrigger();
  }
  void v9[5] = v4 + 40;
  uint64_t v10 = QMIServiceMsg::create();
  int v11 = 25000;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  v9[0] = MEMORY[0x263EF8330];
  v9[1] = 0x40000000;
  _OWORD v9[2] = ___ZN16QMIVirtualClient4sendIN3nas10GetSigInfo7RequestEU13block_pointerFvRKNS2_8ResponseEEEEvRKT_T0__block_invoke;
  v9[3] = &unk_2646112A0;
  void v9[4] = v6;
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_28;
  aBlock[3] = &unk_2646111D0;
  aBlock[4] = v9;
  __int16 v5 = _Block_copy(aBlock);
  uint64_t v13 = v5;
  if (v10)
  {
    qmi::Client::send();
    __int16 v5 = v13;
  }
  if (v5) {
    _Block_release(v5);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v8);
}

void sub_2224F8DB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN31Mav7SignalStrengthCommandDriver21sendGetSignalStrengthEb_block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *((_DWORD *)a2 + 1);
  if (v4)
  {
    BOOL v6 = *(NSObject **)(v3 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v4;
      LOWORD(v18) = 2080;
      *(void *)((char *)&v18 + 2) = qmi::asString();
      _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#E sendGetSignalStrength: Error in response with code = 0x%x (%s)", buf, 0x12u);
      int v4 = *((_DWORD *)a2 + 1);
    }
    if (!*(unsigned char *)(a1 + 40) && v4 != 74) {
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v3 + 88) + 24))(*(void *)(v3 + 88), 1, 3);
    }
  }
  else
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    parseInputs(a2, &v14);
    if (*(void *)(v14 + 16))
    {
      uint64_t v7 = *(void *)(v3 + 88);
      uint64_t v12 = v14;
      uint64_t v13 = v15;
      if (v15) {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v7 + 32))(v7, 1, &v12);
      if (v13) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v13);
      }
    }
    v11[0] = MEMORY[0x263EF8330];
    v11[1] = 0x40000000;
    _DWORD v11[2] = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke;
    v11[3] = &__block_descriptor_tmp_49_9;
    void v11[4] = v3;
    *(void *)std::string buf = v11;
    qmi::MessageBase::applyTlv<nas::tlv::LinkQuality,void({block_pointer}&)(nas::tlv::LinkQuality const&)>(a2, (uint64_t)buf);
    v10[0] = MEMORY[0x263EF8330];
    v10[1] = 0x40000000;
    _DWORD v10[2] = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke_2;
    void v10[3] = &__block_descriptor_tmp_50_3;
    v10[4] = v3;
    *(void *)std::string buf = v10;
    qmi::MessageBase::applyTlv<nas::tlv::DataLinkQuality,void({block_pointer}&)(nas::tlv::DataLinkQuality const&)>(a2, (uint64_t)buf);
    v9[0] = MEMORY[0x263EF8330];
    v9[1] = 0x40000000;
    _OWORD v9[2] = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke_3;
    v9[3] = &__block_descriptor_tmp_51_6;
    void v9[4] = v3;
    *(void *)std::string buf = v9;
    char v8 = qmi::MessageBase::applyTlv<nas::tlv::EnhancedVoiceLinkQuality,void({block_pointer}&)(nas::tlv::EnhancedVoiceLinkQuality const&)>(a2, (uint64_t)buf);
    uint64_t v16 = buf;
    *(void *)std::string buf = MEMORY[0x263EF8330];
    *(void *)&long long v18 = 0x40000000;
    *((void *)&v18 + 1) = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke_4;
    BOOL v19 = &__block_descriptor_tmp_52_4;
    uint64_t v20 = v3;
    char v21 = v8;
    qmi::MessageBase::applyTlv<nas::tlv::VoiceLinkQuality,void({block_pointer}&)(nas::tlv::VoiceLinkQuality const&)>(a2, (uint64_t)&v16);
    if (v15) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v15);
    }
  }
}

void sub_2224F90BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,uint64_t a26,std::__shared_weak_count *a27)
{
  if (a25) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a25);
  }
  if (a27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a27);
  }
  _Unwind_Resume(exception_object);
}

void Mav7SignalStrengthCommandDriver::~Mav7SignalStrengthCommandDriver(Mav7SignalStrengthCommandDriver *this)
{
  QMISignalStrengthCommandDriver::~QMISignalStrengthCommandDriver(this);

  JUMPOUT(0x223C9A950);
}

void non-virtual thunk to'Mav7SignalStrengthCommandDriver::~Mav7SignalStrengthCommandDriver(Mav7SignalStrengthCommandDriver *this)
{
}

{
  uint64_t vars8;

  QMISignalStrengthCommandDriver::~QMISignalStrengthCommandDriver((Mav7SignalStrengthCommandDriver *)((char *)this - 8));

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_emplace<Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler,std::allocator<Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3928;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler,std::allocator<Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3928;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::__shared_ptr_emplace<Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler,std::allocator<Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler::~MakeSharedEnabler(QMISignalStrengthCommandDriver *a1)
{
  QMISignalStrengthCommandDriver::~QMISignalStrengthCommandDriver(a1);

  JUMPOUT(0x223C9A950);
}

void non-virtual thunk to'Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler::~MakeSharedEnabler(uint64_t a1)
{
}

{
  uint64_t vars8;

  QMISignalStrengthCommandDriver::~QMISignalStrengthCommandDriver((QMISignalStrengthCommandDriver *)(a1 - 8));

  JUMPOUT(0x223C9A950);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMISignalStrengthCommandDriver>::execute_wrapped<Mav7SignalStrengthCommandDriver::start(void)::$_0>(Mav7SignalStrengthCommandDriver::start(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<Mav7SignalStrengthCommandDriver::start(void)::$_0,dispatch_queue_s *::default_delete<Mav7SignalStrengthCommandDriver::start(void)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  int v24 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(void *)(v2 + 72);
  v25[0] = MEMORY[0x263EF8330];
  v25[1] = 0x40000000;
  void v25[2] = ___ZZN31Mav7SignalStrengthCommandDriver5startEvENK3__0clEv_block_invoke;
  v25[3] = &__block_descriptor_tmp_30_5;
  std::string v25[4] = v2;
  int v4 = *(std::__shared_weak_count **)(v3 + 8);
  if (v4)
  {
    int v4 = std::__shared_weak_count::lock(v4);
    if (v4)
    {
      uint64_t v12 = v4;
      uint64_t v13 = *(void *)v3;
      if (*(void *)v3)
      {
        uint64_t v26 = v3 + 88;
        uint64_t v27 = 1;
        MEMORY[0x223C999F0](v3 + 88, v5, v6, v7, v8, v9, v10, v11);
        uint64_t v14 = *(void *)(v3 + 24);
        if (v14)
        {
          uint64_t v15 = v3 + 24;
          do
          {
            unsigned int v16 = *(unsigned __int16 *)(v14 + 32);
            BOOL v17 = v16 >= 0x51;
            if (v16 >= 0x51) {
              long long v18 = (uint64_t *)v14;
            }
            else {
              long long v18 = (uint64_t *)(v14 + 8);
            }
            if (v17) {
              uint64_t v15 = v14;
            }
            uint64_t v14 = *v18;
          }
          while (*v18);
          if (v15 != v3 + 24 && *(unsigned __int16 *)(v15 + 32) <= 0x51u) {
            __TUAssertTrigger();
          }
        }
        aBlock[0] = MEMORY[0x263EF8330];
        aBlock[1] = 0x40000000;
        aBlock[2] = ___ZN16QMIVirtualClient26registerUnsolicitedHandlerIN3nas7SigInfo10IndicationEEEvU13block_pointerFvRKT_E_block_invoke;
        aBlock[3] = &unk_264611100;
        aBlock[4] = v25;
        BOOL v19 = (uint64_t *)_Block_copy(aBlock);
        unsigned __int16 v30 = 81;
        char v32 = &v30;
        uint64_t v20 = std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short &&>,std::tuple<>>((uint64_t **)(v3 + 16), &v30, (uint64_t)&std::piecewise_construct, &v32);
        char v21 = v20[5];
        v20[5] = v19;
        if (v21) {
          _Block_release(v21);
        }
        std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&v26);
        uint64_t v26 = 0;
        uint64_t v27 = 0;
        uint64_t v22 = *(void *)(v3 + 64);
        uint64_t v28 = *(void *)(v3 + 56);
        uint64_t v29 = v22;
        if (v22) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
        }
        QMIClientPool::registerUnsolicitedHandler(v13, (uint64_t)&v26, v3, 0x51u);
        qmi::Client::~Client((qmi::Client *)&v26);
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    }
  }
  if (capabilities::ct::supportsEcoDataMode((capabilities::ct *)v4)) {
    QMIVirtualClient::addToPowerMode(*(QMIVirtualClient **)(v2 + 72));
  }
  MEMORY[0x223C9A950](v1, 0x20C4093837F09);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v24);
}

void sub_2224F94B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&a15);
  std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  MEMORY[0x223C9A950](v15, 0x20C4093837F09);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void ___ZZN31Mav7SignalStrengthCommandDriver5startEvENK3__0clEv_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = a2[1];
  v7[0] = *a2;
  v7[1] = v3;
  uint64_t v4 = a2[2];
  _OWORD v7[2] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = 0;
  unsigned int v16 = 0;
  parseInputs((qmi::MessageBase *)v7, &v15);
  if (*(void *)(v15 + 16))
  {
    uint64_t v5 = *(void *)(v2 + 88);
    uint64_t v13 = v15;
    uint64_t v14 = v16;
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v5 + 32))(v5, 1, &v13);
    if (v14) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v14);
    }
  }
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 0x40000000;
  void v12[2] = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke;
  void v12[3] = &__block_descriptor_tmp_34_6;
  void v12[4] = v2;
  v8[0] = v12;
  qmi::MessageBase::applyTlv<nas::tlv::LinkQuality,void({block_pointer}&)(nas::tlv::LinkQuality const&)>((qmi::MessageBase *)v7, (uint64_t)v8);
  v11[0] = MEMORY[0x263EF8330];
  v11[1] = 0x40000000;
  _DWORD v11[2] = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke_2;
  v11[3] = &__block_descriptor_tmp_36_6;
  void v11[4] = v2;
  v8[0] = v11;
  qmi::MessageBase::applyTlv<nas::tlv::DataLinkQuality,void({block_pointer}&)(nas::tlv::DataLinkQuality const&)>((qmi::MessageBase *)v7, (uint64_t)v8);
  v10[0] = MEMORY[0x263EF8330];
  v10[1] = 0x40000000;
  _DWORD v10[2] = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke_3;
  void v10[3] = &__block_descriptor_tmp_37_8;
  v10[4] = v2;
  v8[0] = v10;
  char v6 = qmi::MessageBase::applyTlv<nas::tlv::EnhancedVoiceLinkQuality,void({block_pointer}&)(nas::tlv::EnhancedVoiceLinkQuality const&)>((qmi::MessageBase *)v7, (uint64_t)v8);
  v8[0] = MEMORY[0x263EF8330];
  v8[1] = 0x40000000;
  _OWORD v8[2] = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke_4;
  v8[3] = &__block_descriptor_tmp_39_7;
  void v8[4] = v2;
  char v9 = v6;
  BOOL v17 = v8;
  qmi::MessageBase::applyTlv<nas::tlv::VoiceLinkQuality,void({block_pointer}&)(nas::tlv::VoiceLinkQuality const&)>((qmi::MessageBase *)v7, (uint64_t)&v17);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v7);
}

void sub_2224F9758(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  uint64_t v4 = *(std::__shared_weak_count **)(v2 - 80);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 - 64);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN16QMIVirtualClient26registerUnsolicitedHandlerIN3nas7SigInfo10IndicationEEEvU13block_pointerFvRKT_E_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = a2[1];
  v5[0] = *a2;
  v5[1] = v3;
  uint64_t v4 = a2[2];
  _OWORD v5[2] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v5);
  (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v5);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v5);
}

void sub_2224F9808(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke(uint64_t a1, unsigned char *a2)
{
  if (*a2 == 1) {
    uint64_t v2 = 100;
  }
  else {
    uint64_t v2 = 50;
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 32) + 88) + 40))(*(void *)(*(void *)(a1 + 32) + 88), 1, v2);
}

uint64_t ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke_2(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  if (v2 == 100) {
    unsigned int v3 = 100;
  }
  else {
    unsigned int v3 = 50;
  }
  if (v2 == 10) {
    uint64_t v4 = 10;
  }
  else {
    uint64_t v4 = v3;
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 32) + 88) + 40))(*(void *)(*(void *)(a1 + 32) + 88), 1, v4);
}

void ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 88);
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  std::string __p = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v2 + 56))(v2, 1, &__p);
  if (__p)
  {
    uint64_t v4 = __p;
    operator delete(__p);
  }
}

void sub_2224F9944(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke_4(uint64_t result, unsigned __int8 *a2)
{
  if (!*(unsigned char *)(result + 40))
  {
    int v2 = *a2;
    if (v2 == 100) {
      unsigned int v3 = 100;
    }
    else {
      unsigned int v3 = 50;
    }
    if (v2 == 10) {
      uint64_t v4 = 10;
    }
    else {
      uint64_t v4 = v3;
    }
    return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)(result + 32) + 88) + 48))(*(void *)(*(void *)(result + 32) + 88), 1, v4);
  }
  return result;
}

uint64_t qmi::MessageBase::applyTlv<nas::tlv::LinkQuality,void({block_pointer}&)(nas::tlv::LinkQuality const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    uint64_t v6 = result;
    int v7 = v5;
    uint64_t v10 = result;
    tlv::parseV<nas::tlv::LinkQuality>((unint64_t *)&v10, v5);
    if (v10)
    {
      return (*(uint64_t (**)(void))(*(void *)a2 + 16))();
    }
    else
    {
      uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v9 = *(unsigned __int16 *)a1;
      return v8(v9, 160, v6, v7);
    }
  }
  return result;
}

uint64_t qmi::MessageBase::applyTlv<nas::tlv::DataLinkQuality,void({block_pointer}&)(nas::tlv::DataLinkQuality const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    uint64_t v6 = result;
    int v7 = v5;
    uint64_t v10 = result;
    tlv::parseV<nas::tlv::DataLinkQuality>((unint64_t *)&v10, v5);
    if (v10)
    {
      return (*(uint64_t (**)(void))(*(void *)a2 + 16))();
    }
    else
    {
      uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v9 = *(unsigned __int16 *)a1;
      return v8(v9, 162, v6, v7);
    }
  }
  return result;
}

uint64_t qmi::MessageBase::applyTlv<nas::tlv::EnhancedVoiceLinkQuality,void({block_pointer}&)(nas::tlv::EnhancedVoiceLinkQuality const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    uint64_t v6 = result;
    int v7 = v5;
    uint64_t v13 = 0;
    uint64_t v14 = (char *)result;
    std::string __p = 0;
    uint64_t v12 = 0;
    tlv::parseV<nas::tlv::EnhancedVoiceLinkQuality>(&v14, v5, &__p);
    uint64_t v8 = v14;
    if (v14) {
      (*(void (**)(void))(*(void *)a2 + 16))();
    }
    if (__p)
    {
      uint64_t v12 = __p;
      operator delete(__p);
    }
    if (v8)
    {
      return 1;
    }
    else
    {
      uint64_t v9 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v10 = *(unsigned __int16 *)a1;
      return v9(v10, 164, v6, v7);
    }
  }
  return result;
}

void sub_2224F9C08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t qmi::MessageBase::applyTlv<nas::tlv::VoiceLinkQuality,void({block_pointer}&)(nas::tlv::VoiceLinkQuality const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    uint64_t v6 = result;
    int v7 = v5;
    uint64_t v10 = result;
    tlv::parseV<nas::tlv::VoiceLinkQuality>((unint64_t *)&v10, v5);
    if (v10)
    {
      return (*(uint64_t (**)(void))(*(void *)a2 + 16))();
    }
    else
    {
      uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v9 = *(unsigned __int16 *)a1;
      return v8(v9, 163, v6, v7);
    }
  }
  return result;
}

void ___ZN16QMIVirtualClient4sendIN3nas18IndicationRegister7RequestEU13block_pointerFvRKNS2_8ResponseEEEEvRKT_T0__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = a2[1];
  v5[0] = *a2;
  v5[1] = v3;
  uint64_t v4 = a2[2];
  _OWORD v5[2] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v5);
  (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v5);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v5);
}

void sub_2224F9D48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN16QMIVirtualClient4sendIN3nas14ConfigSigInfo27RequestEU13block_pointerFvRKNS2_8ResponseEEEEvRKT_T0__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = a2[1];
  v5[0] = *a2;
  v5[1] = v3;
  uint64_t v4 = a2[2];
  _OWORD v5[2] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v5);
  (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v5);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v5);
}

void sub_2224F9DD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke(uint64_t a1, unsigned char *a2)
{
  if (*a2 == 1) {
    uint64_t v2 = 100;
  }
  else {
    uint64_t v2 = 50;
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 32) + 88) + 40))(*(void *)(*(void *)(a1 + 32) + 88), 1, v2);
}

uint64_t ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke_2(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  if (v2 == 100) {
    unsigned int v3 = 100;
  }
  else {
    unsigned int v3 = 50;
  }
  if (v2 == 10) {
    uint64_t v4 = 10;
  }
  else {
    uint64_t v4 = v3;
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 32) + 88) + 40))(*(void *)(*(void *)(a1 + 32) + 88), 1, v4);
}

void ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 88);
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  std::string __p = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v2 + 56))(v2, 1, &__p);
  if (__p)
  {
    uint64_t v4 = __p;
    operator delete(__p);
  }
}

void sub_2224F9F0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke_4(uint64_t result, unsigned __int8 *a2)
{
  if (!*(unsigned char *)(result + 40))
  {
    int v2 = *a2;
    if (v2 == 100) {
      unsigned int v3 = 100;
    }
    else {
      unsigned int v3 = 50;
    }
    if (v2 == 10) {
      uint64_t v4 = 10;
    }
    else {
      uint64_t v4 = v3;
    }
    return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)(result + 32) + 88) + 48))(*(void *)(*(void *)(result + 32) + 88), 1, v4);
  }
  return result;
}

void ___ZN16QMIVirtualClient4sendIN3nas10GetSigInfo7RequestEU13block_pointerFvRKNS2_8ResponseEEEEvRKT_T0__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = a2[1];
  v5[0] = *a2;
  v5[1] = v3;
  uint64_t v4 = a2[2];
  _OWORD v5[2] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v5);
  (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v5);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v5);
}

void sub_2224F9FFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void QMIDMSCommandDriver::create()
{
  uint64_t v0 = *MEMORY[0x263EF8340];
  operator new();
}

void sub_2224FA390(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va2);
  MEMORY[0x223C9A950](v3, 0x10A1C40FF1576FELL);
  uint64_t v5 = *((void *)v2 + 31);
  *((void *)v2 + 31) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va);
  DMSCommandDriver::~DMSCommandDriver(v2);
  MEMORY[0x223C9A950](v2, 0x10E1C40A140B717);
  _Unwind_Resume(a1);
}

void sub_2224FA3C4(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    dispatch_barrier_async_f(v2[3], v2, (dispatch_function_t)std::shared_ptr<QMIDMSCommandDriver> ctu::SharedSynchronizable<DMSCommandDriver>::make_shared_ptr<QMIDMSCommandDriver>(QMIDMSCommandDriver*)::{lambda(QMIDMSCommandDriver*)#1}::operator() const(QMIDMSCommandDriver*)::{lambda(void *)#1}::__invoke);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_2224FA3F8(_Unwind_Exception *a1)
{
}

void sub_2224FA408()
{
  uint64_t v1 = *(void *)(v0 + 248);
  *(void *)(v0 + 248) = 0;
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x2224FA484);
}

void sub_2224FA4A8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x2224FA48CLL);
}

void sub_2224FA4BC(void *a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x2224FA4C4);
  }
  __clang_call_terminate(a1);
}

uint64_t QMIDMSCommandDriver::start(QMIDMSCommandDriver *this)
{
  DMSCommandDriver::start(this);

  return qmi::ClientRouter::start();
}

uint64_t QMIDMSCommandDriver::stop(QMIDMSCommandDriver *this)
{
  qmi::ClientRouter::stop();

  return MEMORY[0x270EE9528](this);
}

void QMIDMSCommandDriver::setupRequestsAndIndications_sync(uint64_t a1, unsigned int a2)
{
  unsigned int v10 = 255;
  if (subscriber::isSet()) {
    subscriber::clearFlag();
  }
  if (subscriber::isSet()) {
    subscriber::clearFlag();
  }
  if (subscriber::isSet()) {
    subscriber::clearFlag();
  }
  if (subscriber::isSet()) {
    subscriber::clearFlag();
  }
  if (a2 - 1 >= 3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = a2;
  }
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 40))(a1, v4, v10);
  *(_OWORD *)std::string __p = 0u;
  long long v9 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v5 = (const void **)__p[1];
  if (__p[1] != (void *)v9)
  {
    while (*((unsigned char *)*v5 + 8) != 23)
    {
      if (++v5 == (const void **)v9) {
        goto LABEL_19;
      }
    }
  }
  if (v5 != (const void **)v9)
  {
    if (v6)
    {
      v6[9] = 1;
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<dms::SetEventReport::Request>(&v7, a2);
    }
    __cxa_bad_cast();
  }
LABEL_19:
  operator new();
}

void sub_2224FA948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  uint64_t v23 = a10;
  a10 = 0;
  if (v23) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v23);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t QMIDMSCommandDriver::get(uint64_t a1, uint64_t a2)
{
  if (subscriber::isSet())
  {
    if ((a2 - 1) >= 3) {
      int v4 = 0;
    }
    else {
      int v4 = a2;
    }
    long long v7 = 0u;
    long long v8 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v7);
    qmi::ClientRouter::get();
    int v9 = v4;
    operator new();
  }
  if (subscriber::isSet()) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 72))(a1, a2);
  }
  uint64_t result = subscriber::isSet();
  if (result)
  {
    if ((a2 - 1) >= 3) {
      int v6 = 0;
    }
    else {
      int v6 = a2;
    }
    long long v7 = 0u;
    long long v8 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v7);
    qmi::ClientRouter::get();
    int v9 = v6;
    operator new();
  }
  return result;
}

void sub_2224FAD58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  uint64_t v24 = a15;
  a15 = 0;
  if (v24) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, v24);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void QMIDMSCommandDriver::queryPRLVersion(uint64_t a1, int a2)
{
  if ((a2 - 1) >= 3) {
    int v2 = 0;
  }
  else {
    int v2 = a2;
  }
  memset(v3, 0, sizeof(v3));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v3);
  qmi::ClientRouter::get();
  int v4 = v2;
  operator new();
}

void sub_2224FAFA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  uint64_t v24 = a15;
  a15 = 0;
  if (v24) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, v24);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void QMIDMSCommandDriver::started(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = a2;
  if ((a2 - 1) >= 3) {
    a2 = 0;
  }
  else {
    a2 = a2;
  }
  int v4 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 248) + 16))(*(void *)(a1 + 248), a2);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I DMS client started", buf, 2u);
  }
  if (capabilities::ct::supportsGemini((capabilities::ct *)v5))
  {
    memset(v9, 0, sizeof(v9));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v9);
    int v6 = qmi::MutableMessageBase::getTLV<dms::tlv::SubscriptionType>((uint64_t)v9, 1);
    if (v2 == 2) {
      int v7 = 2;
    }
    else {
      int v7 = 1;
    }
    *(_DWORD *)int v6 = v7;
    qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<dms::BindSubscription::Request>(&v8, v2);
  }
  QMIDMSCommandDriver::setupRequestsAndIndications_sync(a1, v2);
}

void sub_2224FB244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  uint64_t v22 = a10;
  a10 = 0;
  if (v22) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v22);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t QMIDMSCommandDriver::stopped(uint64_t a1, uint64_t a2)
{
  if ((a2 - 1) >= 3) {
    a2 = 0;
  }
  else {
    a2 = a2;
  }
  unsigned int v2 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 248) + 16))(*(void *)(a1 + 248), a2);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I DMS client stopped", v4, 2u);
  }
  DMSCommandDriver::clearMin();
  return DMSCommandDriver::clearPrlVersion();
}

void QMIDMSCommandDriver::~QMIDMSCommandDriver(QMIDMSCommandDriver *this)
{
  *(void *)this = &unk_26D4D3A50;
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 33);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = *((void *)this + 31);
  *((void *)this + 31) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }

  DMSCommandDriver::~DMSCommandDriver(this);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_26D4D3A50;
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 33);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = *((void *)this + 31);
  *((void *)this + 31) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  DMSCommandDriver::~DMSCommandDriver(this);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<QMIDMSCommandDriver *,std::shared_ptr<QMIDMSCommandDriver> ctu::SharedSynchronizable<DMSCommandDriver>::make_shared_ptr<QMIDMSCommandDriver>(QMIDMSCommandDriver*)::{lambda(QMIDMSCommandDriver *)#1},std::allocator<QMIDMSCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<QMIDMSCommandDriver *,std::shared_ptr<QMIDMSCommandDriver> ctu::SharedSynchronizable<DMSCommandDriver>::make_shared_ptr<QMIDMSCommandDriver>(QMIDMSCommandDriver*)::{lambda(QMIDMSCommandDriver *)#1},std::allocator<QMIDMSCommandDriver>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<QMIDMSCommandDriver *,std::shared_ptr<QMIDMSCommandDriver> ctu::SharedSynchronizable<DMSCommandDriver>::make_shared_ptr<QMIDMSCommandDriver>(QMIDMSCommandDriver*)::{lambda(QMIDMSCommandDriver *)#1},std::allocator<QMIDMSCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIDMSCommandDriver> ctu::SharedSynchronizable<DMSCommandDriver>::make_shared_ptr<QMIDMSCommandDriver>(QMIDMSCommandDriver*)::{lambda(QMIDMSCommandDriver*)#1}::operator() const(QMIDMSCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<DMSCommandDriver>::execute_wrapped<QMIDMSCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::$_0>(QMIDMSCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIDMSCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::$_0,std::default_delete<QMIDMSCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::$_0>>)::{lambda(void *)#1}::__invoke(void ***a1)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v1 = *a1;
  uint64_t v15 = a1;
  unsigned int v16 = v1;
  unsigned int v2 = *v1;
  uint64_t v14 = (Registry **)(*v1 + 9);
  subscriber::makeSimSlotRange();
  uint64_t v3 = v17;
  if (v17 != v18)
  {
    while ((v19(*v3) & 1) == 0)
    {
      if (++v3 == v18)
      {
        uint64_t v3 = v18;
        break;
      }
    }
    while (v3 != v18)
    {
      if (*v3 == 1)
      {
        int v4 = "QMIDMSCommandDriver.1";
      }
      else if (*v3 == 2)
      {
        int v4 = "QMIDMSCommandDriver.2";
      }
      else
      {
        int v4 = "QMIDMSCommandDriver.?";
      }
      BOOL v5 = (std::__shared_weak_count *)v2[2];
      if (!v5 || (v6 = v2[1], (int v7 = std::__shared_weak_count::lock(v5)) == 0)) {
        std::__throw_bad_weak_ptr[abi:ne180100]();
      }
      int v8 = v7;
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
      Registry::getServerConnection((uint64_t *)&v20, *v14);
      long long v31 = 0u;
      long long v32 = 0u;
      std::string::basic_string[abi:ne180100]<0>(&v28, v4);
      int v9 = v2[3];
      dispatch_object_t object = v9;
      if (v9) {
        dispatch_retain(v9);
      }
      std::string::basic_string[abi:ne180100]<0>(__p, "dms");
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      unsigned int v10 = std::__shared_weak_count::lock(v8);
      if (v10)
      {
        uint64_t v11 = v10;
        atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        uint64_t v22 = v6;
        uint64_t v23 = v10;
        std::__shared_weak_count::__release_weak(v8);
        std::__shared_weak_count::__release_shared[abi:ne180100](v11);
      }
      else
      {
        uint64_t v22 = 0;
        uint64_t v23 = 0;
        std::__shared_weak_count::__release_weak(v8);
      }
      long long v21 = v20;
      long long v20 = 0uLL;
      qmi::Client::createWithQueueLocal();
      if (*((void *)&v21 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v21 + 1));
      }
      if (v23) {
        std::__shared_weak_count::__release_weak(v23);
      }
      if (v26 < 0) {
        operator delete(__p[0]);
      }
      if (object) {
        dispatch_release(object);
      }
      if (SBYTE7(v30) < 0) {
        operator delete(v28);
      }
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      long long v30 = v32;
      long long v32 = 0uLL;
      qmi::ClientRouter::addClient();
      qmi::Client::~Client((qmi::Client *)&v28);
      qmi::ClientRouter::get();
      qmi::Client::~Client((qmi::Client *)&v31);
      if (*((void *)&v20 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v20 + 1));
      }
      uint64_t v12 = v3 + 1;
      uint64_t v3 = v18;
      if (v12 != v18)
      {
        uint64_t v3 = v12;
        while ((v19(*v3) & 1) == 0)
        {
          if (++v3 == v18)
          {
            uint64_t v3 = v18;
            break;
          }
        }
      }
    }
  }
  uint64_t v28 = &unk_26D4D3BB0;
  uint64_t v29 = v2;
  *((void *)&v30 + 1) = &v28;
  qmi::ClientRouter::setHandler();
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](&v28);
  __p[0] = &unk_26D4D3C30;
  __p[1] = v2;
  uint64_t v27 = __p;
  qmi::ClientRouter::setHandler();
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](__p);
  *(void *)&long long v31 = &unk_26D4D3CB0;
  *((void *)&v31 + 1) = v2;
  *((void *)&v32 + 1) = &v31;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v31);
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 32));
  std::unique_ptr<Mav20PreferredNetworksFactoryCommandDriver::create(std::shared_ptr<Registry const>,dispatch::queue)::$_0,std::default_delete<Mav20PreferredNetworksFactoryCommandDriver::create(std::shared_ptr<Registry const>,dispatch::queue)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)&v16);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v15);
}

void sub_2224FB8F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,dispatch_object_t object,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100]((void *)(v37 - 144));
  std::unique_ptr<Mav20PreferredNetworksFactoryCommandDriver::create(std::shared_ptr<Registry const>,dispatch::queue)::$_0,std::default_delete<Mav20PreferredNetworksFactoryCommandDriver::create(std::shared_ptr<Registry const>,dispatch::queue)::$_0>>::~unique_ptr[abi:ne180100](&a13);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void SimInstanceLoggable<QMIDMSCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::~SimInstanceLoggable()
{
}

uint64_t SimInstanceLoggable<QMIDMSCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::getLoggerForSlot(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_0,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_0,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D3BB0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_0,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D3BB0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_0,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, unsigned int *a2)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8), *a2);
}

uint64_t std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_0,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

void *std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_0,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_1,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_1,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D3C30;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_1,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D3C30;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_1,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, unsigned int *a2)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 64))(*(void *)(a1 + 8), *a2);
}

uint64_t std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_1,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

void *std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_1,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMIDMSCommandDriver::init_sync(void)::$_3>(unsigned short,QMIDMSCommandDriver::init_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMIDMSCommandDriver::init_sync(void)::$_3 &&,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMIDMSCommandDriver::init_sync(void)::$_3>(unsigned short,QMIDMSCommandDriver::init_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMIDMSCommandDriver::init_sync(void)::$_3 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D3CB0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMIDMSCommandDriver::init_sync(void)::$_3>(unsigned short,QMIDMSCommandDriver::init_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMIDMSCommandDriver::init_sync(void)::$_3 &&,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D3CB0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMIDMSCommandDriver::init_sync(void)::$_3>(unsigned short,QMIDMSCommandDriver::init_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMIDMSCommandDriver::init_sync(void)::$_3 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    long long v21 = 0uLL;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v16, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v16);
    if (__p)
    {
      *(void *)&long long v21 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v16);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v4 - 1 >= 3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v4;
  }
  int v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 248) + 16))(*(void *)(v6 + 248), v7);
  int v9 = v17;
  if (v17)
  {
    unsigned int v10 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = qmi::asString();
      LODWORD(__p) = 67109378;
      HIDWORD(__p) = v9;
      LOWORD(v21) = 2080;
      *(void *)((char *)&v21 + 2) = v11;
      _os_log_impl(&dword_22231A000, v10, OS_LOG_TYPE_DEFAULT, "#N handleSetEventReportInd returned error=0x%04x (%s)", (uint8_t *)&__p, 0x12u);
    }
  }
  else
  {
    std::string __p = (void *)MEMORY[0x263EF8330];
    *(void *)&long long v21 = 0x40000000;
    *((void *)&v21 + 1) = ___ZZN19QMIDMSCommandDriver9init_syncEvENK3__3clEN3qmi16SubscriptionTypeERKN3dms11EventReport10IndicationE_block_invoke;
    uint64_t v22 = &__block_descriptor_tmp_39_8;
    uint64_t v23 = v6;
    uint64_t v24 = v8;
    unsigned int v25 = v4;
    uint64_t TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v16);
    uint64_t v14 = TlvValue;
    if (TlvValue)
    {
      int v15 = v13;
      uint64_t v19 = TlvValue;
      char v18 = tlv::parseV<dms::tlv::PRLInitNotification>((unint64_t *)&v19, v13);
      if (v19) {
        (*((void (**)(void **, char *))&v21 + 1))(&__p, &v18);
      }
      else {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v16[0], 23, v14, v15);
      }
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v16);
}

void sub_2224FBED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMIDMSCommandDriver::init_sync(void)::$_3>(unsigned short,QMIDMSCommandDriver::init_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMIDMSCommandDriver::init_sync(void)::$_3 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMIDMSCommandDriver::init_sync(void)::$_3>(unsigned short,QMIDMSCommandDriver::init_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMIDMSCommandDriver::init_sync(void)::$_3 &&,QMIServiceMsg const)>::target_type()
{
}

uint64_t ___ZZN19QMIDMSCommandDriver9init_syncEvENK3__3clEN3qmi16SubscriptionTypeERKN3dms11EventReport10IndicationE_block_invoke(uint64_t result, unsigned char *a2)
{
  if (*a2 == 1)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 32);
    unsigned int v4 = **(NSObject ***)(result + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I PRL available", v7, 2u);
    }
    unsigned int v5 = *(_DWORD *)(v2 + 48);
    if (v5 - 1 >= 3) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = v5;
    }
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 40))(v3, v6, 128);
  }
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver21bindSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)v3;
  unsigned int v5 = *(_DWORD *)(v3 + 8);
  if (v5 - 1 >= 3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v5;
  }
  uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 248) + 16))(*(void *)(v4 + 248), v6);
  if (!*(_DWORD *)(a2 + 4))
  {
    unsigned int v9 = *(_DWORD *)(v3 + 8);
    QMIDMSCommandDriver::setupRequestsAndIndications_sync(v4, v9);
  }
  int v8 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = qmi::asString();
    int v11 = *(_DWORD *)(a2 + 4);
    int v12 = 136315394;
    uint64_t v13 = v10;
    __int16 v14 = 1024;
    int v15 = v11;
    _os_log_error_impl(&dword_22231A000, v8, OS_LOG_TYPE_ERROR, "Error binding subscription: %s (0x%x)", (uint8_t *)&v12, 0x12u);
  }
}

uint64_t __copy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMIDMSCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3D60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMIDMSCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3D60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3dms16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  cast_message_type<dms::BindSubscription::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2224FC268(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<dms::tlv::ReportPRLInitialized>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dms::tlv::ReportPRLInitialized>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<dms::tlv::ReportPRLInitialized>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<dms::tlv::ReportPRLInitialized>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver32setupRequestsAndIndications_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 4))
  {
    char v3 = *(uint64_t **)(a1 + 32);
    uint64_t v4 = *v3;
    unsigned int v5 = *((_DWORD *)v3 + 2);
    if (v5 - 1 >= 3) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = v5;
    }
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 248) + 16))(*(void *)(v4 + 248), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *(_DWORD *)(a2 + 4);
      v9[0] = 67109378;
      v9[1] = v8;
      __int16 v10 = 2080;
      uint64_t v11 = qmi::asString();
      _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#N Failed to register for PRL Init report with error=0x%04x (%s)", (uint8_t *)v9, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c113_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver32setupRequestsAndIndications_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c113_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver32setupRequestsAndIndications_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::setupRequestsAndIndications_sync(qmi::SubscriptionType)::$_0,std::allocator<QMIDMSCommandDriver::setupRequestsAndIndications_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3E30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::setupRequestsAndIndications_sync(qmi::SubscriptionType)::$_0,std::allocator<QMIDMSCommandDriver::setupRequestsAndIndications_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3E30;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  char v3 = *(uint64_t **)(a1 + 32);
  uint64_t v4 = *v3;
  if (*((_DWORD *)a2 + 1))
  {
    unsigned int v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 248) + 16))(*(void *)(v4 + 248), *((unsigned int *)v3 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *((_DWORD *)a2 + 1);
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109378;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v6;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = qmi::asString();
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#N GetDeviceSerialNumbers returned error=0x%04x (%s)", (uint8_t *)&buf, 0x12u);
    }
  }
  else
  {
    if (subscriber::isSet())
    {
      v36[0] = MEMORY[0x263EF8330];
      v36[1] = 0x40000000;
      uint64_t v37 = ___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke;
      uint64_t v38 = &__block_descriptor_tmp_55_5;
      uint64_t v39 = v4;
      uint64_t TlvValue = qmi::MessageBase::findTlvValue(a2);
      uint64_t v9 = TlvValue;
      if (TlvValue)
      {
        int v10 = v8;
        __p.__r_.__value_.__r.__words[0] = TlvValue;
        memset(&buf, 0, sizeof(buf));
        tlv::parseV<dms::tlv::ESN>(&__p.__r_.__value_.__l.__data_, v8, &buf);
        std::string::size_type v11 = __p.__r_.__value_.__r.__words[0];
        if (__p.__r_.__value_.__r.__words[0]) {
          v37((uint64_t)v36, (uint64_t)&buf);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        if (!v11) {
          ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 16, v9, v10);
        }
      }
    }
    if (subscriber::isSet())
    {
      v32[0] = MEMORY[0x263EF8330];
      v32[1] = 0x40000000;
      uint64_t v33 = ___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke_2;
      char v34 = &__block_descriptor_tmp_57_5;
      uint64_t v35 = v4;
      uint64_t v12 = qmi::MessageBase::findTlvValue(a2);
      uint64_t v14 = v12;
      if (!v12) {
        goto LABEL_20;
      }
      int v15 = v13;
      __p.__r_.__value_.__r.__words[0] = v12;
      memset(&buf, 0, sizeof(buf));
      tlv::parseV<dms::tlv::MEID>(&__p.__r_.__value_.__l.__data_, v13, &buf);
      std::string::size_type v16 = __p.__r_.__value_.__r.__words[0];
      if (__p.__r_.__value_.__r.__words[0]) {
        v33((uint64_t)v32, (uint64_t)&buf);
      }
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      if (!v16
        && (((uint64_t (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 18, v14, v15) & 1) == 0)
      {
LABEL_20:
        xpc_object_t object = xpc_string_create((const char *)&unk_222543CCE);
        if (!object) {
          xpc_object_t object = xpc_null_create();
        }
        DMSCommandDriver::setMeid();
        xpc_release(object);
        xpc_object_t object = 0;
      }
    }
    if (subscriber::isSet())
    {
      buf.__r_.__value_.__r.__words[0] = MEMORY[0x263EF8330];
      buf.__r_.__value_.__l.__size_ = 0x40000000;
      buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke_3;
      long long v43 = &__block_descriptor_tmp_58_3;
      uint64_t v44 = v4;
      int v45 = *((_DWORD *)v3 + 2);
      uint64_t v17 = qmi::MessageBase::findTlvValue(a2);
      uint64_t v19 = v17;
      if (v17)
      {
        int v20 = v18;
        v40.__r_.__value_.__r.__words[0] = v17;
        memset(&__p, 0, sizeof(__p));
        tlv::parseV<dms::tlv::IMEI>(&v40.__r_.__value_.__l.__data_, v18, &__p);
        std::string::size_type v21 = v40.__r_.__value_.__r.__words[0];
        if (v40.__r_.__value_.__r.__words[0]) {
          ((void (*)(std::string *, std::string *))buf.__r_.__value_.__r.__words[2])(&buf, &__p);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (!v21) {
          ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 17, v19, v20);
        }
      }
    }
    if (subscriber::isSet())
    {
      __p.__r_.__value_.__r.__words[0] = MEMORY[0x263EF8330];
      __p.__r_.__value_.__l.__size_ = 0x40000000;
      __p.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke_4;
      uint64_t v28 = &__block_descriptor_tmp_59_4;
      uint64_t v29 = v4;
      int v30 = *((_DWORD *)v3 + 2);
      uint64_t v22 = (std::string::value_type *)qmi::MessageBase::findTlvValue(a2);
      uint64_t v24 = v22;
      if (v22)
      {
        int v25 = v23;
        unsigned int v41 = v22;
        memset(&v40, 0, sizeof(v40));
        tlv::parseV<dms::tlv::IMEISVN>(&v41, v23, &v40);
        uint64_t v26 = v41;
        if (v41) {
          ((void (*)(std::string *, std::string *))__p.__r_.__value_.__r.__words[2])(&__p, &v40);
        }
        if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v40.__r_.__value_.__l.__data_);
        }
        if (!v26) {
          ((void (*)(void, uint64_t, std::string::value_type *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 19, v24, v25);
        }
      }
    }
  }
}

void sub_2224FC9B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c130_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c130_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::querySerialNumbers(subscriber::SimSlot,DMSCommandDriver::Information)::$_0,std::allocator<QMIDMSCommandDriver::querySerialNumbers(subscriber::SimSlot,DMSCommandDriver::Information)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3EB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::querySerialNumbers(subscriber::SimSlot,DMSCommandDriver::Information)::$_0,std::allocator<QMIDMSCommandDriver::querySerialNumbers(subscriber::SimSlot,DMSCommandDriver::Information)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3EB0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3dms22GetDeviceSerialNumbers8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224FCB9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v2 = (const char *)a2;
  }
  else {
    uint64_t v2 = *(const char **)a2;
  }
  xpc_object_t object = xpc_string_create(v2);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  subscriber::setFlagIf();
  std::string::basic_string[abi:ne180100]<0>(&__p, "/cc/device_info/esn");
  xpc_object_t v4 = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_object_t v4 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v4);
  if (v6 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
}

void sub_2224FCCA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  xpc_release(a10);
  _Unwind_Resume(a1);
}

void ___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) == 0) {
    char v3 = (const char *)a2;
  }
  else {
    char v3 = *(const char **)a2;
  }
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (!v2) {
    goto LABEL_15;
  }
  uint64_t v4 = 0;
  while (v3[v4] == 48)
  {
    if (v2 == ++v4) {
      goto LABEL_15;
    }
  }
  if (v4 == -1)
  {
LABEL_15:
    xpc_object_t v5 = xpc_string_create((const char *)&unk_222543CCE);
    if (!v5) {
      xpc_object_t v5 = xpc_null_create();
    }
    DMSCommandDriver::setMeid();
    xpc_release(v5);
  }
  else
  {
    xpc_object_t object = xpc_string_create(v3);
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    DMSCommandDriver::setMeid();
    xpc_release(object);
  }
}

void sub_2224FCDBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t object)
{
}

void ___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke_3(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  DMSCommandDriver::setImei();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_2224FCE70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke_4(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  DMSCommandDriver::setImeiSvn();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_2224FCF04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver15queryPRLVersionEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  char v3 = *(uint64_t **)(a1 + 32);
  uint64_t v4 = *v3;
  if (*((_DWORD *)this + 1))
  {
    xpc_object_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 248) + 16))(*(void *)(v4 + 248), *((unsigned int *)v3 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *((_DWORD *)this + 1);
      *(_DWORD *)std::string buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v6;
      LOWORD(v14) = 2080;
      *(void *)((char *)&v14 + 2) = qmi::asString();
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#N GetCurrentPRLInfo returned error=0x%04x (%s)", buf, 0x12u);
    }
  }
  else
  {
    *(void *)std::string buf = MEMORY[0x263EF8330];
    *(void *)&long long v14 = 0x40000000;
    *((void *)&v14 + 1) = ___ZZN19QMIDMSCommandDriver15queryPRLVersionEN10subscriber7SimSlotEENK3__0clERKN3dms17GetCurrentPRLInfo8ResponseE_block_invoke;
    int v15 = &__block_descriptor_tmp_64_4;
    uint64_t v16 = v4;
    int v17 = *((_DWORD *)v3 + 2);
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(this);
    if (TlvValue)
    {
      uint64_t v9 = TlvValue;
      int v10 = v8;
      uint64_t v12 = TlvValue;
      __int16 v11 = tlv::parseV<dms::tlv::PRLVersion>((unint64_t *)&v12, v8);
      if (v12) {
        (*((void (**)(uint8_t *, __int16 *))&v14 + 1))(buf, &v11);
      }
      else {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)this, 16, v9, v10);
      }
    }
  }
}

uint64_t __copy_helper_block_e8_32c94_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver15queryPRLVersionEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c94_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver15queryPRLVersionEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::queryPRLVersion(subscriber::SimSlot)::$_0,std::allocator<QMIDMSCommandDriver::queryPRLVersion(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3F30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::queryPRLVersion(subscriber::SimSlot)::$_0,std::allocator<QMIDMSCommandDriver::queryPRLVersion(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3F30;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3dms17GetCurrentPRLInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224FD23C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t ___ZZN19QMIDMSCommandDriver15queryPRLVersionEN10subscriber7SimSlotEENK3__0clERKN3dms17GetCurrentPRLInfo8ResponseE_block_invoke(uint64_t a1, unsigned __int16 *a2)
{
  return MEMORY[0x270EE9510](*(void *)(a1 + 32), *(unsigned int *)(a1 + 40), *a2);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver11queryMSISDNEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  char v3 = *(uint64_t **)(a1 + 32);
  uint64_t v4 = *v3;
  if (*((_DWORD *)a2 + 1))
  {
    xpc_object_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 248) + 16))(*(void *)(v4 + 248), *((unsigned int *)v3 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *((_DWORD *)a2 + 1);
      *(_DWORD *)std::string buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v6;
      LOWORD(v15) = 2080;
      *(void *)((char *)&v15 + 2) = qmi::asString();
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#N GetMSISDN returned error=0x%04x (%s)", buf, 0x12u);
    }
  }
  else if (subscriber::isSet())
  {
    *(void *)std::string buf = MEMORY[0x263EF8330];
    *(void *)&long long v15 = 0x40000000;
    *((void *)&v15 + 1) = ___ZZN19QMIDMSCommandDriver11queryMSISDNEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms9GetMSISDN8ResponseE_block_invoke;
    uint64_t v16 = &__block_descriptor_tmp_68_1;
    uint64_t v17 = v4;
    int v18 = *((_DWORD *)v3 + 2);
    uint64_t TlvValue = (std::string::value_type *)qmi::MessageBase::findTlvValue(a2);
    uint64_t v9 = TlvValue;
    if (!TlvValue) {
      goto LABEL_12;
    }
    int v10 = v8;
    int v13 = TlvValue;
    memset(&__p, 0, sizeof(__p));
    tlv::parseV<dms::tlv::TLVMIN>(&v13, v8, &__p);
    __int16 v11 = v13;
    if (v13) {
      (*((void (**)(uint8_t *, std::string *))&v15 + 1))(buf, &__p);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (!v11
      && (((uint64_t (*)(void, uint64_t, std::string::value_type *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 16, v9, v10) & 1) == 0)
    {
LABEL_12:
      memset(&__p, 0, sizeof(__p));
      DMSCommandDriver::setMin();
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
}

void sub_2224FD4A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c123_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver11queryMSISDNEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c123_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver11queryMSISDNEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::queryMSISDN(subscriber::SimSlot,DMSCommandDriver::Information)::$_0,std::allocator<QMIDMSCommandDriver::queryMSISDN(subscriber::SimSlot,DMSCommandDriver::Information)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3FB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::queryMSISDN(subscriber::SimSlot,DMSCommandDriver::Information)::$_0,std::allocator<QMIDMSCommandDriver::queryMSISDN(subscriber::SimSlot,DMSCommandDriver::Information)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D3FB0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3dms9GetMSISDN8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2224FD638(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZZN19QMIDMSCommandDriver11queryMSISDNEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms9GetMSISDN8ResponseE_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  DMSCommandDriver::setMin();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_2224FD6F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *prepareThresholds(uint64_t a1)
{
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::GsmRssiDelta>(a1, 29) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::WcdmaRssiDelta>(a1, 31) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::WcdmaEcioDelta>(a1, 33) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::CdmaRssiDelta>(a1, 17) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::HdrRssiDelta>(a1, 21) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::CdmaEcioDelta>(a1, 19) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::HdrSinrDelta>(a1, 25) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::LteRssiDelta>(a1, 35) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::LteRsrqDelta>(a1, 39) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::LteRsrpDelta>(a1, 41) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::LteSnrDelta>(a1, 37) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::TDSCDMAEcioDelta>(a1, 162) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::TDSCDMARscpDelta>(a1, 161) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::NrSnrDelta>(a1, 52) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::NrRsrpDelta>(a1, 54) = -1;
  uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::NrRsrqDelta>(a1, 57);
  *(_WORD *)uint64_t result = -1;
  return result;
}

char *populateThresholds(char *result, uint64_t a2)
{
  uint64_t v2 = (char *)*((void *)result + 1);
  char v3 = result + 16;
  if (v2 != result + 16)
  {
    while (1)
    {
      int v5 = *((_DWORD *)v2 + 9);
      double v6 = fmax(*((double *)v2 + 6), 1.0);
      switch(*((_DWORD *)v2 + 8))
      {
        case 0:
          if (v5 == 4)
          {
            uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::WcdmaEcioDelta>(a2, 33);
            goto LABEL_29;
          }
          if (!v5)
          {
            int v7 = (int)(v6 * 10.0 + 0.5);
            *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::GsmRssiDelta>(a2, 29) = v7;
            uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::WcdmaRssiDelta>(a2, 31);
            goto LABEL_10;
          }
          goto LABEL_30;
        case 1:
          switch(v5)
          {
            case 6:
              uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::HdrSinrDelta>(a2, 25);
              goto LABEL_29;
            case 1:
              uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::CdmaEcioDelta>(a2, 19);
              goto LABEL_29;
            case 0:
              int v7 = (int)(v6 * 10.0 + 0.5);
              *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::CdmaRssiDelta>(a2, 17) = v7;
              uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::HdrRssiDelta>(a2, 21);
LABEL_10:
              *(_WORD *)uint64_t result = v7;
              break;
          }
          goto LABEL_30;
        case 2:
          switch(v5)
          {
            case 0:
              uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::LteRssiDelta>(a2, 35);
              goto LABEL_29;
            case 6:
              uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::LteSnrDelta>(a2, 37);
              goto LABEL_29;
            case 7:
              uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::LteRsrpDelta>(a2, 41);
              goto LABEL_29;
            case 8:
              uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::LteRsrqDelta>(a2, 39);
              goto LABEL_29;
            default:
              goto LABEL_30;
          }
          goto LABEL_30;
        case 3:
          if (v5 == 3)
          {
            uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::TDSCDMARscpDelta>(a2, 161);
            goto LABEL_29;
          }
          if (v5 == 1)
          {
            uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::TDSCDMAEcioDelta>(a2, 162);
            goto LABEL_29;
          }
          goto LABEL_30;
        case 4:
          switch(v5)
          {
            case 6:
              uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::NrSnrDelta>(a2, 52);
              goto LABEL_29;
            case 7:
              uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::NrRsrpDelta>(a2, 54);
              goto LABEL_29;
            case 8:
              uint64_t result = qmi::MutableMessageBase::getTLV<nas::tlv::NrRsrqDelta>(a2, 57);
LABEL_29:
              *(_WORD *)uint64_t result = (int)(v6 * 10.0 + 0.5);
              break;
          }
LABEL_30:
          int v8 = (char *)*((void *)v2 + 1);
          if (v8)
          {
            do
            {
              uint64_t v9 = v8;
              int v8 = *(char **)v8;
            }
            while (v8);
          }
          else
          {
            do
            {
              uint64_t v9 = (char *)*((void *)v2 + 2);
              BOOL v10 = *(void *)v9 == (void)v2;
              uint64_t v2 = v9;
            }
            while (!v10);
          }
          uint64_t v2 = v9;
          if (v9 == v3) {
            return result;
          }
          break;
        default:
          goto LABEL_30;
      }
    }
  }
  return result;
}

uint64_t parseInputs@<X0>(qmi::MessageBase *a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  uint64_t v4 = operator new(0x30uLL);
  v4[1] = 0;
  _DWORD v4[2] = 0;
  void *v4 = &unk_26D4D4500;
  v4[4] = 0;
  v4[3] = v4 + 4;
  int v5 = (uint64_t **)(v4 + 3);
  void v4[5] = 0;
  *a2 = v4 + 3;
  a2[1] = v4;
  uint64_t TlvValue = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  int v8 = TlvValue;
  if (TlvValue)
  {
    int v9 = v7;
    uint64_t v53 = TlvValue;
    char v10 = tlv::parseV<nas::tlv::GsmSigInfo>((unsigned char **)&v53, v7);
    if (v53)
    {
      uint64_t v54 = 0;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 0, 0, (uint64_t **)&v54)+ 5) = (double)v10;
    }
    else
    {
      ((void (*)(void, uint64_t, _WORD *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 18, v8, v9);
    }
  }
  __int16 v11 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  int v13 = v11;
  if (v11)
  {
    int v14 = v12;
    uint64_t v53 = v11;
    int v15 = tlv::parseV<nas::tlv::WCdmaSigInfo>((unsigned char **)&v53, v12);
    if (v53)
    {
      int v16 = v15;
      uint64_t v54 = 0;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 0, 0, (uint64_t **)&v54)+ 5) = (double)(char)v15;
      uint64_t v54 = 0x400000000;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 0, 4, (uint64_t **)&v54)+ 5) = (double)(v16 >> 16) * -0.5;
    }
    else
    {
      ((void (*)(void, uint64_t, _WORD *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 19, v13, v14);
    }
  }
  uint64_t v17 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  uint64_t v19 = v17;
  if (v17)
  {
    int v20 = v18;
    uint64_t v53 = v17;
    int v21 = tlv::parseV<nas::tlv::CdmaSigInfo>((unsigned char **)&v53, v18);
    if (v53)
    {
      int v22 = v21;
      uint64_t v54 = 1;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 0, (uint64_t **)&v54)+ 5) = (double)(char)v21;
      uint64_t v54 = 0x100000001;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 1, (uint64_t **)&v54)+ 5) = (double)(v22 >> 16) * -0.5;
    }
    else
    {
      ((void (*)(void, uint64_t, _WORD *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 16, v19, v20);
    }
  }
  int v23 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  int v25 = v23;
  if (v23)
  {
    int v26 = v24;
    uint64_t v53 = v23;
    uint64_t v27 = tlv::parseV<nas::tlv::HdrSigInfo>((char **)&v53, v24);
    if (v53)
    {
      unsigned __int8 v28 = BYTE4(v27);
      uint64_t v54 = 0x500000001;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 5, (uint64_t **)&v54)+ 5) = (double)(char)v27;
      uint64_t v54 = 0x600000001;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 6, (uint64_t **)&v54)+ 5) = (double)v28;
    }
    else
    {
      ((void (*)(void, uint64_t, _WORD *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 17, v25, v26);
    }
  }
  uint64_t v29 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  long long v31 = v29;
  if (v29)
  {
    int v32 = v30;
    uint64_t v53 = v29;
    unint64_t v33 = tlv::parseV<nas::tlv::LteSigInfo>((unsigned char **)&v53, v30);
    if (v53)
    {
      unint64_t v34 = v33;
      uint64_t v54 = 2;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 0, (uint64_t **)&v54)+ 5) = (double)(char)v33;
      uint64_t v54 = 0x700000002;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 7, (uint64_t **)&v54)+ 5) = (double)((int)v34 >> 16);
      uint64_t v54 = 0x800000002;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 8, (uint64_t **)&v54)+ 5) = (double)SBYTE1(v34);
      uint64_t v54 = 0x600000002;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 6, (uint64_t **)&v54)+ 5) = (double)SWORD2(v34) / 10.0;
    }
    else
    {
      ((void (*)(void, uint64_t, _WORD *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 20, v31, v32);
    }
  }
  uint64_t v35 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  uint64_t v37 = v35;
  if (v35)
  {
    int v38 = v36;
    uint64_t v53 = v35;
    int v39 = tlv::parseV<nas::tlv::TDSCDMASigInfo>((unsigned char **)&v53, v36);
    if (v53)
    {
      int v40 = v39;
      uint64_t v54 = 0x300000003;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 3, 3, (uint64_t **)&v54)+ 5) = (double)(char)v39;
      uint64_t v54 = 0x100000003;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 3, 1, (uint64_t **)&v54)+ 5) = (double)(v40 >> 16) * -0.5;
    }
    else
    {
      ((void (*)(void, uint64_t, _WORD *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 161, v37, v38);
    }
  }
  unsigned int v41 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  long long v43 = v41;
  if (v41)
  {
    int v44 = v42;
    uint64_t v53 = v41;
    int v45 = tlv::parseV<nas::tlv::NrSigInfo>(&v53, v42);
    if (v53)
    {
      int v46 = v45;
      uint64_t v54 = 0x700000004;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 4, 7, (uint64_t **)&v54)+ 5) = (double)(__int16)v45;
      uint64_t v54 = 0x600000004;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 4, 6, (uint64_t **)&v54)+ 5) = (double)(v46 >> 16) / 10.0;
    }
    else
    {
      ((void (*)(void, uint64_t, _WORD *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 23, v43, v44);
    }
  }
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  uint64_t v49 = result;
  if (result)
  {
    int v50 = v48;
    uint64_t v53 = (_WORD *)result;
    __int16 v51 = tlv::parseV<nas::tlv::NrSigInfoExt>(&v53, v48);
    if (v53)
    {
      __int16 v52 = v51;
      uint64_t v54 = 0x800000004;
      uint64_t result = (uint64_t)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 4, 8, (uint64_t **)&v54);
      *(double *)(result + 40) = (double)v52;
    }
    else
    {
      return ((uint64_t (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 24, v49, v50);
    }
  }
  return result;
}

{
  void *v4;
  uint64_t **v5;
  _WORD *TlvValue;
  int v7;
  _WORD *v8;
  int v9;
  char v10;
  _WORD *v11;
  int v12;
  _WORD *v13;
  int v14;
  int v15;
  int v16;
  _WORD *v17;
  int v18;
  _WORD *v19;
  int v20;
  int v21;
  int v22;
  _WORD *v23;
  int v24;
  _WORD *v25;
  int v26;
  uint64_t v27;
  unsigned __int8 v28;
  _WORD *v29;
  int v30;
  _WORD *v31;
  int v32;
  unint64_t v33;
  unint64_t v34;
  _WORD *v35;
  int v36;
  _WORD *v37;
  int v38;
  int v39;
  int v40;
  _WORD *v41;
  int v42;
  _WORD *v43;
  int v44;
  int v45;
  int v46;
  uint64_t result;
  int v48;
  uint64_t v49;
  int v50;
  __int16 v51;
  __int16 v52;
  _WORD *v53;
  uint64_t v54;

  *a2 = 0;
  a2[1] = 0;
  uint64_t v4 = operator new(0x30uLL);
  v4[1] = 0;
  _DWORD v4[2] = 0;
  void *v4 = &unk_26D4D4500;
  v4[4] = 0;
  v4[3] = v4 + 4;
  int v5 = (uint64_t **)(v4 + 3);
  void v4[5] = 0;
  *a2 = v4 + 3;
  a2[1] = v4;
  uint64_t TlvValue = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  int v8 = TlvValue;
  if (TlvValue)
  {
    int v9 = v7;
    uint64_t v53 = TlvValue;
    char v10 = tlv::parseV<nas::tlv::GsmSigInfo>((unsigned char **)&v53, v7);
    if (v53)
    {
      uint64_t v54 = 0;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 0, 0, (uint64_t **)&v54)+ 5) = (double)v10;
    }
    else
    {
      ((void (*)(void, uint64_t, _WORD *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 18, v8, v9);
    }
  }
  __int16 v11 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  int v13 = v11;
  if (v11)
  {
    int v14 = v12;
    uint64_t v53 = v11;
    int v15 = tlv::parseV<nas::tlv::WCdmaSigInfo>((unsigned char **)&v53, v12);
    if (v53)
    {
      int v16 = v15;
      uint64_t v54 = 0;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 0, 0, (uint64_t **)&v54)+ 5) = (double)(char)v15;
      uint64_t v54 = 0x400000000;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 0, 4, (uint64_t **)&v54)+ 5) = (double)(v16 >> 16) * -0.5;
    }
    else
    {
      ((void (*)(void, uint64_t, _WORD *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 19, v13, v14);
    }
  }
  uint64_t v17 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  uint64_t v19 = v17;
  if (v17)
  {
    int v20 = v18;
    uint64_t v53 = v17;
    int v21 = tlv::parseV<nas::tlv::CdmaSigInfo>((unsigned char **)&v53, v18);
    if (v53)
    {
      int v22 = v21;
      uint64_t v54 = 1;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 0, (uint64_t **)&v54)+ 5) = (double)(char)v21;
      uint64_t v54 = 0x100000001;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 1, (uint64_t **)&v54)+ 5) = (double)(v22 >> 16) * -0.5;
    }
    else
    {
      ((void (*)(void, uint64_t, _WORD *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 16, v19, v20);
    }
  }
  int v23 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  int v25 = v23;
  if (v23)
  {
    int v26 = v24;
    uint64_t v53 = v23;
    uint64_t v27 = tlv::parseV<nas::tlv::HdrSigInfo>((char **)&v53, v24);
    if (v53)
    {
      unsigned __int8 v28 = BYTE4(v27);
      uint64_t v54 = 0x500000001;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 5, (uint64_t **)&v54)+ 5) = (double)(char)v27;
      uint64_t v54 = 0x600000001;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 6, (uint64_t **)&v54)+ 5) = (double)v28;
    }
    else
    {
      ((void (*)(void, uint64_t, _WORD *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 17, v25, v26);
    }
  }
  uint64_t v29 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  long long v31 = v29;
  if (v29)
  {
    int v32 = v30;
    uint64_t v53 = v29;
    unint64_t v33 = tlv::parseV<nas::tlv::LteSigInfo>((unsigned char **)&v53, v30);
    if (v53)
    {
      unint64_t v34 = v33;
      uint64_t v54 = 2;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 0, (uint64_t **)&v54)+ 5) = (double)(char)v33;
      uint64_t v54 = 0x700000002;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 7, (uint64_t **)&v54)+ 5) = (double)((int)v34 >> 16);
      uint64_t v54 = 0x800000002;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 8, (uint64_t **)&v54)+ 5) = (double)SBYTE1(v34);
      uint64_t v54 = 0x600000002;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 6, (uint64_t **)&v54)+ 5) = (double)SWORD2(v34) / 10.0;
    }
    else
    {
      ((void (*)(void, uint64_t, _WORD *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 20, v31, v32);
    }
  }
  uint64_t v35 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  uint64_t v37 = v35;
  if (v35)
  {
    int v38 = v36;
    uint64_t v53 = v35;
    int v39 = tlv::parseV<nas::tlv::TDSCDMASigInfo>((unsigned char **)&v53, v36);
    if (v53)
    {
      int v40 = v39;
      uint64_t v54 = 0x300000003;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 3, 3, (uint64_t **)&v54)+ 5) = (double)(char)v39;
      uint64_t v54 = 0x100000003;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 3, 1, (uint64_t **)&v54)+ 5) = (double)(v40 >> 16) * -0.5;
    }
    else
    {
      ((void (*)(void, uint64_t, _WORD *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 161, v37, v38);
    }
  }
  unsigned int v41 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  long long v43 = v41;
  if (v41)
  {
    int v44 = v42;
    uint64_t v53 = v41;
    int v45 = tlv::parseV<nas::tlv::NrSigInfo>(&v53, v42);
    if (v53)
    {
      int v46 = v45;
      uint64_t v54 = 0x700000004;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 4, 7, (uint64_t **)&v54)+ 5) = (double)(__int16)v45;
      uint64_t v54 = 0x600000004;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 4, 6, (uint64_t **)&v54)+ 5) = (double)(v46 >> 16) / 10.0;
    }
    else
    {
      ((void (*)(void, uint64_t, _WORD *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 23, v43, v44);
    }
  }
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  uint64_t v49 = result;
  if (result)
  {
    int v50 = v48;
    uint64_t v53 = (_WORD *)result;
    __int16 v51 = tlv::parseV<nas::tlv::NrSigInfoExt>(&v53, v48);
    if (v53)
    {
      __int16 v52 = v51;
      uint64_t v54 = 0x800000004;
      uint64_t result = (uint64_t)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 4, 8, (uint64_t **)&v54);
      *(double *)(result + 40) = (double)v52;
    }
    else
    {
      return ((uint64_t (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a1, 24, v49, v50);
    }
  }
  return result;
}

void sub_2224FE0C0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_2224FE6EC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::GsmRssiDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::GsmRssiDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::GsmRssiDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::GsmRssiDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::GsmRssiDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::GsmRssiDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::GsmRssiDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::WcdmaRssiDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::WcdmaRssiDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::WcdmaRssiDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaRssiDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaRssiDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaRssiDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaRssiDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::WcdmaEcioDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::WcdmaEcioDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::WcdmaEcioDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaEcioDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaEcioDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaEcioDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaEcioDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::CdmaRssiDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::CdmaRssiDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::CdmaRssiDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaRssiDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaRssiDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaRssiDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaRssiDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::HdrRssiDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::HdrRssiDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::HdrRssiDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrRssiDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrRssiDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrRssiDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrRssiDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::CdmaEcioDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::CdmaEcioDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::CdmaEcioDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaEcioDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaEcioDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaEcioDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaEcioDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::HdrSinrDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::HdrSinrDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::HdrSinrDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrSinrDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrSinrDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrSinrDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrSinrDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::LteRssiDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::LteRssiDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::LteRssiDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRssiDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRssiDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRssiDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRssiDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::LteRsrqDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::LteRsrqDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::LteRsrqDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrqDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrqDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrqDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrqDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::LteRsrpDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::LteRsrpDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::LteRsrpDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrpDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrpDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrpDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrpDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::LteSnrDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::LteSnrDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::LteSnrDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteSnrDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteSnrDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteSnrDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteSnrDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::TDSCDMAEcioDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::TDSCDMAEcioDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::TDSCDMAEcioDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMAEcioDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMAEcioDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMAEcioDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMAEcioDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::TDSCDMARscpDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::TDSCDMARscpDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::TDSCDMARscpDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMARscpDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMARscpDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMARscpDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMARscpDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::NrSnrDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::NrSnrDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::NrSnrDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrSnrDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrSnrDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrSnrDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrSnrDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::NrRsrpDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::NrRsrpDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::NrRsrpDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrpDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrpDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrpDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrpDelta>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::NrRsrqDelta>(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  char v3 = *(const void ***)(a1 + 16);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    qmi::MutableMessageBase::createTLV<nas::tlv::NrRsrqDelta>();
  }
  if (!v4) {
    __cxa_bad_cast();
  }
  return v4 + 10;
}

void qmi::MutableMessageBase::createTLV<nas::tlv::NrRsrqDelta>()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrqDelta>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrqDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrqDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrqDelta>::clone()
{
}

void std::__shared_ptr_emplace<Inputs>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4500;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Inputs>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4500;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_emplace<Inputs>::__on_zero_shared(uint64_t a1)
{
}

uint64_t **std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(uint64_t **a1, int a2, int a3, uint64_t **a4)
{
  int v7 = a1 + 1;
  double v6 = a1[1];
  if (!v6)
  {
    int v8 = a1 + 1;
    goto LABEL_21;
  }
  do
  {
    while (1)
    {
      int v8 = (uint64_t **)v6;
      int v9 = *((_DWORD *)v6 + 8);
      if (v9 == a2) {
        break;
      }
      if (v9 <= a2)
      {
        if (v9 >= a2) {
          char v13 = 1;
        }
        else {
          char v13 = -1;
        }
        if ((v13 & 0x80) == 0) {
          return v8;
        }
        goto LABEL_18;
      }
LABEL_12:
      double v6 = *v8;
      int v7 = v8;
      if (!*v8) {
        goto LABEL_21;
      }
    }
    int v10 = *((_DWORD *)v8 + 9);
    BOOL v11 = v10 == a3;
    if (v10 > a3) {
      goto LABEL_12;
    }
    if (v10 >= a3) {
      char v12 = 1;
    }
    else {
      char v12 = -1;
    }
    if (v11) {
      char v12 = 0;
    }
    if ((v12 & 0x80) == 0) {
      return v8;
    }
LABEL_18:
    double v6 = v8[1];
  }
  while (v6);
  int v7 = v8 + 1;
LABEL_21:
  int v14 = (uint64_t *)v8;
  int v8 = (uint64_t **)operator new(0x30uLL);
  void v8[4] = *a4;
  void v8[5] = 0;
  *int v8 = 0;
  v8[1] = 0;
  _OWORD v8[2] = v14;
  *int v7 = (uint64_t *)v8;
  int v15 = (uint64_t *)**a1;
  int v16 = (uint64_t *)v8;
  if (v15)
  {
    *a1 = v15;
    int v16 = *v7;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v16);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return v8;
}

void ctu::enable_make_unique<qmi::NotifyHelper>::make_unique<std::shared_ptr<Registry const> const&>()
{
}

void sub_222501504(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x1010C4044AD791CLL);
  _Unwind_Resume(a1);
}

void qmi::NotifyHelper::~NotifyHelper(qmi::NotifyHelper *this)
{
  if (!boost::dynamic_bitset<unsigned long,std::allocator<unsigned long>>::m_check_invariants((uint64_t *)this)) {
    __assert_rtn("~dynamic_bitset", "dynamic_bitset.hpp", 702, "m_check_invariants()");
  }
  uint64_t v2 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

uint64_t qmi::NotifyHelper::shouldNotifyStart(void *a1)
{
  if (boost::dynamic_bitset<unsigned long,std::allocator<unsigned long>>::all((uint64_t)a1)) {
    return 0;
  }
  unsigned int v3 = subscriber::simSlotAsInstance();
  boost::dynamic_bitset<unsigned long,std::allocator<unsigned long>>::set(a1, v3, 1);

  return boost::dynamic_bitset<unsigned long,std::allocator<unsigned long>>::all((uint64_t)a1);
}

uint64_t boost::dynamic_bitset<unsigned long,std::allocator<unsigned long>>::all(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    uint64_t v1 = *(char **)a1;
    uint64_t v2 = *(char **)(a1 + 8);
    uint64_t v3 = *(void *)(a1 + 24) & 0x3FLL;
    if (v3)
    {
      uint64_t v4 = ((v2 - v1) >> 3) - 1;
      if ((v2 - v1) >> 3 != 1)
      {
        uint64_t v5 = *(char **)a1;
        do
        {
          uint64_t v6 = *(void *)v5;
          v5 += 8;
          if (v6 != -1) {
            return 0;
          }
        }
        while (--v4);
      }
      if (v2 == v1) {
        __assert_rtn("m_highest_block", "dynamic_bitset.hpp", 2025, "size() > 0 && num_blocks() > 0");
      }
      if (*((void *)v2 - 1) != ~(-1 << v3)) {
        return 0;
      }
    }
    else
    {
      uint64_t v8 = v2 - v1;
      if (v8)
      {
        unint64_t v9 = v8 >> 3;
        if (v9 <= 1) {
          unint64_t v9 = 1;
        }
        while (1)
        {
          uint64_t v10 = *(void *)v1;
          v1 += 8;
          if (v10 != -1) {
            break;
          }
          if (!--v9) {
            return 1;
          }
        }
        return 0;
      }
    }
  }
  return 1;
}

uint64_t qmi::NotifyHelper::shouldNotifyStop(unint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)a1[1] - (char *)*a1;
  if (!v2) {
    return 0;
  }
  unint64_t v4 = v2 >> 3;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  unint64_t v6 = *v1;
  if (!*v1)
  {
    int v15 = v1 + 1;
    uint64_t v16 = v5 - 1;
    while (v16 != v6)
    {
      if (v15[v6++])
      {
        if (v6 < v4) {
          goto LABEL_6;
        }
        return 0;
      }
    }
    return 0;
  }
LABEL_6:
  unsigned int v7 = subscriber::simSlotAsInstance();
  boost::dynamic_bitset<unsigned long,std::allocator<unsigned long>>::reset(a1, v7);
  uint64_t v8 = *a1;
  uint64_t v9 = (char *)a1[1] - (char *)*a1;
  if (!v9) {
    return 1;
  }
  unint64_t v10 = v9 >> 3;
  uint64_t v11 = v10 <= 1 ? 1 : v10;
  unint64_t v12 = *v8;
  if (*v8) {
    return 0;
  }
  char v13 = v8 + 1;
  while (v11 - 1 != v12)
  {
    if (v13[v12++]) {
      return v12 >= v10;
    }
  }
  unint64_t v12 = v11;
  return v12 >= v10;
}

void QMIActivationCommandDriver::create()
{
}

void sub_22250184C(_Unwind_Exception *exception_object)
{
  if (v2) {
    dispatch_release(v2);
  }
  if (v3) {
    MEMORY[0x223C9A950](v1, 0xF1C40497CDD23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t QMIActivationCommandDriver::bootstrap(uint64_t a1, uint64_t a2, long long *a3)
{
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Initializing legacy command driver", buf, 2u);
  }
  long long v6 = *a3;
  *(void *)a3 = 0;
  *((void *)a3 + 1) = 0;
  unsigned int v7 = *(std::__shared_weak_count **)(a1 + 56);
  *(_OWORD *)(a1 + 48) = v6;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  std::string::basic_string[abi:ne180100]<0>(&v21, "Activation: BSP Service");
  uint64_t v8 = *(NSObject **)(a1 + 24);
  dispatch_object_t v20 = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, "bsp");
  std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(&v14, (void *)(a1 + 8));
  uint64_t v16 = v14;
  uint64_t v17 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  Registry::getServerConnection(&v12, *(Registry **)(a1 + 64));
  qmi::Client::createWithQueueLocal();
  long long v9 = v24;
  long long v24 = 0uLL;
  unint64_t v10 = *(std::__shared_weak_count **)(a1 + 112);
  *(_OWORD *)(a1 + 104) = v9;
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  qmi::Client::~Client((qmi::Client *)buf);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  if (v19 < 0) {
    operator delete(__p);
  }
  if (v20) {
    dispatch_release(v20);
  }
  if (v22 < 0) {
    operator delete(v21);
  }
  qmi::Client::setHandler();
  qmi::Client::setHandler();
  return qmi::Client::set((qmi::Client *)(a1 + 88), (const char *)*MEMORY[0x263F8AFE8]);
}

void sub_222501AC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,std::__shared_weak_count *a23,uint64_t a24,std::__shared_weak_count *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  if (a25) {
    std::__shared_weak_count::__release_weak(a25);
  }
  if (a23) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a23);
  }
  if (a31 < 0) {
    operator delete(__p);
  }
  unint64_t v33 = *(NSObject **)(v31 - 112);
  if (v33) {
    dispatch_release(v33);
  }
  if (*(char *)(v31 - 81) < 0) {
    operator delete(*(void **)(v31 - 104));
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN26QMIActivationCommandDriver9bootstrapEN8dispatch13group_sessionENSt3__110shared_ptrI40ActivationCommandDriverDelegateInterfaceEE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 32) + 48) + 16))(*(void *)(*(void *)(a1 + 32) + 48), 1);
}

uint64_t ___ZN26QMIActivationCommandDriver9bootstrapEN8dispatch13group_sessionENSt3__110shared_ptrI40ActivationCommandDriverDelegateInterfaceEE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 32) + 48) + 16))(*(void *)(*(void *)(a1 + 32) + 48), 0);
}

uint64_t QMIActivationCommandDriver::start(QMIActivationCommandDriver *this)
{
  return qmi::Client::start((QMIActivationCommandDriver *)((char *)this + 88));
}

uint64_t QMIActivationCommandDriver::stop(uint64_t a1)
{
  return qmi::Client::stop((qmi::Client *)(a1 + 88));
}

uint64_t QMIActivationCommandDriver::QMIActivationCommandDriver(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  xpc_object_t object = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ActivationCommandDriver::ActivationCommandDriver();
  if (object) {
    dispatch_release(object);
  }
  *(void *)a1 = &unk_26D4D4550;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  return a1;
}

void sub_222501C3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void QMIActivationCommandDriver::~QMIActivationCommandDriver(QMIActivationCommandDriver *this)
{
  *(void *)this = &unk_26D4D4550;
  qmi::Client::~Client((QMIActivationCommandDriver *)((char *)this + 88));

  ActivationCommandDriver::~ActivationCommandDriver(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26D4D4550;
  qmi::Client::~Client((QMIActivationCommandDriver *)((char *)this + 88));

  ActivationCommandDriver::~ActivationCommandDriver(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26D4D4550;
  qmi::Client::~Client((QMIActivationCommandDriver *)((char *)this + 88));
  ActivationCommandDriver::~ActivationCommandDriver(this);

  JUMPOUT(0x223C9A950);
}

BOOL QMIActivationCommandDriver::issueActivationTicket(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  long long v6 = *(NSObject **)(a1 + 40);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v4 == v5)
  {
    if (v7)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#N Cannot issue empty activation ticket!", buf, 2u);
    }
    (*(void (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 0);
  }
  else
  {
    if (v7)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#I issuing postponement ticket", buf, 2u);
    }
    memset(v17, 0, sizeof(v17));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v17);
    v16[0] = MEMORY[0x263EF8330];
    v16[1] = 0x40000000;
    _WORD v16[2] = ___ZN26QMIActivationCommandDriver21issueActivationTicketERKNSt3__16vectorIhNS0_9allocatorIhEEEE_block_invoke;
    _OWORD v16[3] = &__block_descriptor_tmp_8_14;
    void v16[4] = a2;
    uint64_t v8 = qmi::MutableMessageBase::getTLV<bsp::tlv::ActivationManifest>((uint64_t)v17, 1);
    ___ZN26QMIActivationCommandDriver21issueActivationTicketERKNSt3__16vectorIhNS0_9allocatorIhEEEE_block_invoke(v16, (char **)v8);
    void v11[5] = a1 + 88;
    uint64_t v12 = QMIServiceMsg::create();
    uint64_t v14 = 0;
    uint64_t aBlock = 0;
    int v13 = 60000;
    v11[0] = MEMORY[0x263EF8330];
    v11[1] = 0x40000000;
    _DWORD v11[2] = ___ZN26QMIActivationCommandDriver21issueActivationTicketERKNSt3__16vectorIhNS0_9allocatorIhEEEE_block_invoke_2;
    v11[3] = &__block_descriptor_tmp_10_11;
    void v11[4] = a1;
    *(void *)std::string buf = MEMORY[0x263EF8330];
    uint64_t v19 = 0x40000000;
    dispatch_object_t v20 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3bsp22SendActivationManifest8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    int v21 = &unk_264611578;
    char v22 = v11;
    long long v9 = _Block_copy(buf);
    uint64_t aBlock = v9;
    if (v12)
    {
      qmi::Client::send();
      long long v9 = aBlock;
    }
    if (v9) {
      _Block_release(v9);
    }
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v17);
  }
  return v4 != v5;
}

void sub_222501FA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void *___ZN26QMIActivationCommandDriver21issueActivationTicketERKNSt3__16vectorIhNS0_9allocatorIhEEEE_block_invoke(void *result, char **a2)
{
  uint64_t v2 = (char **)result[4];
  if (v2 != a2) {
    return std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a2, *v2, v2[1], v2[1] - *v2);
  }
  return result;
}

void ___ZN26QMIActivationCommandDriver21issueActivationTicketERKNSt3__16vectorIhNS0_9allocatorIhEEEE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(_DWORD *)(a2 + 4);
  if (v4)
  {
    uint64_t v5 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v39 = qmi::asString();
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#N Unable to send activation manifest: %s", buf, 0xCu);
      int v4 = *(_DWORD *)(a2 + 4);
    }
    if (v4 == 65537)
    {
      uint64_t v6 = 0x100000001;
    }
    else if (qmi::isInternalError())
    {
      uint64_t v6 = 0x400000001;
    }
    else
    {
      uint64_t v6 = 1;
    }
    (*(void (**)(void, uint64_t))(**(void **)(v3 + 48) + 24))(*(void *)(v3 + 48), v6);
    return;
  }
  bzero(buf, 0x210uLL);
  MEMORY[0x223C98FB0](buf);
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 0x40000000;
  _OWORD v15[2] = ___ZL21parseActivationStatusIN3bsp22SendActivationManifest8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke;
  v15[3] = &__block_descriptor_tmp_29_3;
  void v15[4] = buf;
  *(void *)uint64_t v29 = v15;
  BOOL v7 = (os_log_t *)(v3 + 40);
  if (qmi::MessageBase::applyTlv<bsp::tlv::ActivationProvisioningStatus,void({block_pointer}&)(bsp::tlv::ActivationProvisioningStatus const&)>((qmi::MessageBase *)a2, v29))
  {
    v14[0] = MEMORY[0x263EF8330];
    v14[1] = 0x40000000;
    v14[2] = ___ZL21parseActivationStatusIN3bsp22SendActivationManifest8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke_30;
    v14[3] = &__block_descriptor_tmp_32_7;
    v14[4] = buf;
    *(void *)uint64_t v29 = v14;
    if (qmi::MessageBase::applyTlv<bsp::tlv::ActivationInfo,void({block_pointer}&)(bsp::tlv::ActivationInfo const&)>((qmi::MessageBase *)a2, (uint64_t)v29))
    {
      uint64_t v8 = *(void *)(a2 + 8);
      v13[0] = *(void *)a2;
      v13[1] = v8;
      uint64_t v9 = *(void *)(a2 + 16);
      v13[2] = v9;
      if (v9) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
      }
      v27[0] = MEMORY[0x263EF8330];
      v27[1] = 0x40000000;
      v27[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke;
      v27[3] = &__block_descriptor_tmp_33_7;
      void v27[4] = v40;
      *(void *)uint64_t v29 = v27;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationRootManifestHash,void({block_pointer}&)(bsp::tlv::ActivationRootManifestHash const&)>((qmi::MessageBase *)v13, (uint64_t)v29);
      v26[0] = MEMORY[0x263EF8330];
      v26[1] = 0x40000000;
      v26[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_2;
      v26[3] = &__block_descriptor_tmp_34_7;
      void v26[4] = v40;
      *(void *)uint64_t v29 = v26;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationPublicKeyHash,void({block_pointer}&)(bsp::tlv::ActivationPublicKeyHash const&)>((qmi::MessageBase *)v13, 7, (uint64_t)v29);
      v25[0] = MEMORY[0x263EF8330];
      v25[1] = 0x40000000;
      void v25[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_3;
      v25[3] = &__block_descriptor_tmp_35_4;
      std::string v25[4] = v40;
      *(void *)uint64_t v29 = v25;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationFactoryKeyHash,void({block_pointer}&)(bsp::tlv::ActivationFactoryKeyHash const&)>((qmi::MessageBase *)v13, 16, (uint64_t)v29);
      v24[0] = MEMORY[0x263EF8330];
      v24[1] = 0x40000000;
      _OWORD v24[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4;
      void v24[3] = &__block_descriptor_tmp_36_7;
      v24[4] = buf;
      *(void *)uint64_t v29 = v24;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationImei,void({block_pointer}&)(bsp::tlv::ActivationImei const&)>((qmi::MessageBase *)v13, 17, (uint64_t)v29);
      v23[0] = MEMORY[0x263EF8330];
      v23[1] = 0x40000000;
      void v23[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5;
      v23[3] = &__block_descriptor_tmp_37_9;
      void v23[4] = v40;
      *(void *)uint64_t v29 = v23;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationMeid,void({block_pointer}&)(bsp::tlv::ActivationMeid const&)>((qmi::MessageBase *)v13, 18, v29);
      v22[0] = MEMORY[0x263EF8330];
      v22[1] = 0x40000000;
      _OWORD v22[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6;
      void v22[3] = &__block_descriptor_tmp_38_7;
      void v22[4] = v46;
      *(void *)uint64_t v29 = v22;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationImsi,void({block_pointer}&)(bsp::tlv::ActivationImsi const&)>((qmi::MessageBase *)v13, (uint64_t)v29);
      *(void *)uint64_t v29 = MEMORY[0x263EF8330];
      uint64_t v30 = 0x40000000;
      uint64_t v31 = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_7;
      int v32 = &__block_descriptor_tmp_40_9;
      uint64_t v33 = v3 + 40;
      unint64_t v34 = &v45;
      v21[0] = v29;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationType,void({block_pointer}&)(bsp::tlv::ActivationType const&)>((qmi::MessageBase *)v13, (uint64_t)v21);
      v21[0] = MEMORY[0x263EF8330];
      v21[1] = 0x40000000;
      v21[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_41;
      void v21[3] = &__block_descriptor_tmp_42_6;
      void v21[4] = v46;
      v20[0] = v21;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationIccid,void({block_pointer}&)(bsp::tlv::ActivationIccid const&)>((qmi::MessageBase *)v13, (uint64_t)v20);
      v20[0] = MEMORY[0x263EF8330];
      v20[1] = 0x40000000;
      void v20[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_2_43;
      _OWORD v20[3] = &__block_descriptor_tmp_44_6;
      void v20[4] = v46;
      v19[0] = v20;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationGid1,void({block_pointer}&)(bsp::tlv::ActivationGid1 const&)>((qmi::MessageBase *)v13, (uint64_t)v19);
      v19[0] = MEMORY[0x263EF8330];
      v19[1] = 0x40000000;
      void v19[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_3_45;
      v19[3] = &__block_descriptor_tmp_46_7;
      _OWORD v19[4] = v46;
      v18[0] = v19;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationGid2,void({block_pointer}&)(bsp::tlv::ActivationGid2 const&)>((qmi::MessageBase *)v13, (uint64_t)v18);
      v18[0] = MEMORY[0x263EF8330];
      v18[1] = 0x40000000;
      _OWORD v18[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4_47;
      void v18[3] = &__block_descriptor_tmp_49_10;
      void v18[4] = buf;
      v17[0] = v18;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationVersion,void({block_pointer}&)(bsp::tlv::ActivationVersion const&)>((qmi::MessageBase *)v13, 23, (uint64_t)v17);
      v17[0] = MEMORY[0x263EF8330];
      v17[1] = 0x40000000;
      _OWORD v17[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5_50;
      _OWORD v17[3] = &__block_descriptor_tmp_52_5;
      v17[4] = buf;
      v16[0] = v17;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationMode,void({block_pointer}&)(bsp::tlv::ActivationMode const&)>((qmi::MessageBase *)v13, 25, (uint64_t)v16);
      v16[0] = MEMORY[0x263EF8330];
      v16[1] = 0x40000000;
      _WORD v16[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6_53;
      _OWORD v16[3] = &__block_descriptor_tmp_55_6;
      void v16[4] = buf;
      unsigned __int8 v28 = v16;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationFactoryDebug,void({block_pointer}&)(bsp::tlv::ActivationFactoryDebug const&)>((qmi::MessageBase *)v13, 26, (uint64_t)&v28);
      char v48 = v47;
      char v49 = v47;
      char v44 = v41;
      qmi::MessageBase::~MessageBase((qmi::MessageBase *)v13);
      uint64_t v10 = *(void *)(v3 + 48);
      ActivationInfo::ActivationInfo((ActivationInfo *)v29, (const ActivationInfo *)buf);
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v10 + 40))(v10, v29);
      UMTSProvisioningInfo::~UMTSProvisioningInfo(&v37);
      if (__p)
      {
        int v36 = __p;
        operator delete(__p);
      }
      if (v31)
      {
        int v32 = v31;
        operator delete(v31);
      }
      goto LABEL_24;
    }
    uint64_t v11 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v29 = 0;
      uint64_t v12 = "#I Missing activation info TLV!";
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v11 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v29 = 0;
      uint64_t v12 = "#N Missing activation provisioning status TLV!";
LABEL_22:
      _os_log_impl(&dword_22231A000, v11, OS_LOG_TYPE_DEFAULT, v12, v29, 2u);
    }
  }
  (*(void (**)(void, uint64_t))(**(void **)(v3 + 48) + 24))(*(void *)(v3 + 48), 0x200000001);
LABEL_24:
  UMTSProvisioningInfo::~UMTSProvisioningInfo(&v45);
  if (v42)
  {
    long long v43 = v42;
    operator delete(v42);
  }
  if (v40[0])
  {
    v40[1] = v40[0];
    operator delete(v40[0]);
  }
}

void sub_2225027AC(_Unwind_Exception *a1)
{
  UMTSProvisioningInfo::~UMTSProvisioningInfo((void **)(v1 + 96));
  uint64_t v3 = (void *)STACK[0x280];
  if (STACK[0x280])
  {
    STACK[0x288] = (unint64_t)v3;
    operator delete(v3);
  }
  int v4 = (void *)STACK[0x260];
  if (STACK[0x260])
  {
    STACK[0x268] = (unint64_t)v4;
    operator delete(v4);
  }
  UMTSProvisioningInfo::~UMTSProvisioningInfo((void **)&STACK[0x4C0]);
  uint64_t v5 = (void *)STACK[0x490];
  if (STACK[0x490])
  {
    STACK[0x498] = (unint64_t)v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)STACK[0x470];
  if (STACK[0x470])
  {
    STACK[0x478] = (unint64_t)v6;
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

void QMIActivationCommandDriver::queryActivationStatus(QMIActivationCommandDriver *this)
{
  uint64_t v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I Asking baseband for postponement state", buf, 2u);
  }
  memset(v13, 0, sizeof(v13));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v13);
  uint64_t v8 = (char *)this + 88;
  uint64_t v9 = QMIServiceMsg::create();
  int v10 = 25000;
  uint64_t v11 = 0;
  uint64_t aBlock = 0;
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 0x40000000;
  _OWORD v7[2] = ___ZN26QMIActivationCommandDriver21queryActivationStatusEv_block_invoke;
  void v7[3] = &__block_descriptor_tmp_11_8;
  v7[4] = this;
  *(void *)std::string buf = MEMORY[0x263EF8330];
  uint64_t v15 = 0x40000000;
  uint64_t v16 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3bsp21GetChipIdSerialNumber8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0;
  uint64_t v17 = &unk_2646115A0;
  uint64_t v18 = v7;
  uint64_t v3 = _Block_copy(buf);
  uint64_t aBlock = v3;
  if (v9)
  {
    qmi::Client::send();
    uint64_t v3 = aBlock;
  }
  if (v3) {
    _Block_release(v3);
  }
  memset(v6, 0, sizeof(v6));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v6);
  uint64_t v8 = (char *)this + 88;
  uint64_t v9 = QMIServiceMsg::create();
  int v10 = 25000;
  uint64_t v11 = 0;
  uint64_t aBlock = 0;
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 0x40000000;
  _OWORD v5[2] = ___ZN26QMIActivationCommandDriver21queryActivationStatusEv_block_invoke_2;
  void v5[3] = &__block_descriptor_tmp_12_13;
  v5[4] = this;
  *(void *)std::string buf = MEMORY[0x263EF8330];
  uint64_t v15 = 0x40000000;
  uint64_t v16 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3bsp18GetActivationState8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  uint64_t v17 = &unk_2646115C8;
  uint64_t v18 = v5;
  int v4 = _Block_copy(buf);
  uint64_t aBlock = v4;
  if (v9)
  {
    qmi::Client::send();
    int v4 = aBlock;
  }
  if (v4) {
    _Block_release(v4);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v6);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v13);
}

void sub_222502A78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v7 - 128));
  _Unwind_Resume(a1);
}

void ___ZN26QMIActivationCommandDriver21queryActivationStatusEv_block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)a2 + 1))
  {
    uint64_t v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N Unable to get chip id and serial number: %s", (uint8_t *)&buf, 0xCu);
    }
    (*(void (**)(void, void))(**(void **)(v2 + 48) + 24))(*(void *)(v2 + 48), 0);
  }
  else
  {
    *(void *)&long long buf = MEMORY[0x263EF8330];
    *((void *)&buf + 1) = 0x40000000;
    uint64_t v7 = ___ZN26QMIActivationCommandDriver35handleChipIdAndSerialNumberResponseERKN3bsp21GetChipIdSerialNumber8ResponseE_block_invoke;
    uint64_t v8 = &__block_descriptor_tmp_15_10;
    uint64_t v9 = v2;
    *(void *)uint64_t v5 = &buf;
    if ((qmi::MessageBase::applyTlv<bsp::tlv::ChipInformation,void({block_pointer}&)(bsp::tlv::ChipInformation const&)>(a2, 1, v5) & 1) == 0)
    {
      int v4 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v5 = 0;
        _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#N Missing chip id and serial number", v5, 2u);
      }
    }
  }
}

void ___ZN26QMIActivationCommandDriver21queryActivationStatusEv_block_invoke_2(uint64_t a1, unsigned __int16 *a2)
{
  v57[54] = *(void **)MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *((_DWORD *)a2 + 1);
  if (v4)
  {
    uint64_t v5 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v4;
      LOWORD(v49) = 2080;
      *(void *)((char *)&v49 + 2) = qmi::asString();
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#N Unable to get baseband postponement state: %d (%s)", buf, 0x12u);
      int v4 = *((_DWORD *)a2 + 1);
    }
    if (v4 == 65537)
    {
      uint64_t v6 = 0x100000001;
    }
    else if (qmi::isInternalError())
    {
      uint64_t v6 = 0x400000001;
    }
    else
    {
      uint64_t v6 = 1;
    }
    (*(void (**)(void, uint64_t))(**(void **)(v3 + 48) + 24))(*(void *)(v3 + 48), v6);
    return;
  }
  *(void *)long long buf = 0;
  *(void *)&long long v49 = buf;
  *((void *)&v49 + 1) = 0x23802000000;
  uint64_t v50 = __Block_byref_object_copy__9;
  __int16 v51 = __Block_byref_object_dispose__9;
  bzero(v52, 0x210uLL);
  MEMORY[0x223C98FB0](v52);
  v20[0] = MEMORY[0x263EF8330];
  v20[1] = 0x40000000;
  int v21 = ___ZN26QMIActivationCommandDriver29handleActivationStateResponseERKN3bsp18GetActivationState8ResponseE_block_invoke;
  char v22 = &unk_264611530;
  int v23 = buf;
  uint64_t TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)a2);
  uint64_t v9 = TlvValue;
  if (TlvValue)
  {
    int v10 = v8;
    v38[0] = TlvValue;
    uint64_t v41 = 0;
    *(void *)int v40 = 0;
    *(_DWORD *)((char *)&v42 + 7) = 0;
    *(void *)&long long v42 = 0;
    tlv::parseV<bsp::tlv::ActivationProvisioningInfo>(v38, v8, (uint64_t)v40);
    if (v38[0]) {
      v21((uint64_t)v20, (uint64_t)v40);
    }
    else {
      ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*a2, 5, v9, v10);
    }
  }
  uint64_t v11 = (unsigned char *)v49;
  uint64_t v12 = v49 + 40;
  v26[0] = MEMORY[0x263EF8330];
  v26[1] = 0x40000000;
  v26[2] = ___ZL21parseActivationStatusIN3bsp18GetActivationState8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke;
  v26[3] = &__block_descriptor_tmp_58_4;
  void v26[4] = v49 + 40;
  *(void *)int v40 = v26;
  uint64_t v13 = (os_log_t *)(v3 + 40);
  if (qmi::MessageBase::applyTlv<bsp::tlv::ActivationProvisioningStatus,void({block_pointer}&)(bsp::tlv::ActivationProvisioningStatus const&)>((qmi::MessageBase *)a2, v40))
  {
    v25[0] = MEMORY[0x263EF8330];
    v25[1] = 0x40000000;
    void v25[2] = ___ZL21parseActivationStatusIN3bsp18GetActivationState8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke_60;
    v25[3] = &__block_descriptor_tmp_61_9;
    std::string v25[4] = v12;
    *(void *)int v40 = v25;
    if (qmi::MessageBase::applyTlv<bsp::tlv::ActivationInfo,void({block_pointer}&)(bsp::tlv::ActivationInfo const&)>((qmi::MessageBase *)a2, (uint64_t)v40))
    {
      uint64_t v14 = *((void *)a2 + 1);
      v24[0] = *(void *)a2;
      v24[1] = v14;
      uint64_t v15 = *((void *)a2 + 2);
      _OWORD v24[2] = v15;
      if (v15) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
      }
      v38[0] = MEMORY[0x263EF8330];
      v38[1] = 0x40000000;
      v38[2] = (unint64_t)___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke;
      v38[3] = (unint64_t)&__block_descriptor_tmp_63_4;
      v38[4] = (unint64_t)(v11 + 56);
      *(void *)int v40 = v38;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationRootManifestHash,void({block_pointer}&)(bsp::tlv::ActivationRootManifestHash const&)>((qmi::MessageBase *)v24, (uint64_t)v40);
      v37[0] = MEMORY[0x263EF8330];
      v37[1] = 0x40000000;
      v37[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_2;
      v37[3] = &__block_descriptor_tmp_64_5;
      v37[4] = v11 + 56;
      *(void *)int v40 = v37;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationPublicKeyHash,void({block_pointer}&)(bsp::tlv::ActivationPublicKeyHash const&)>((qmi::MessageBase *)v24, 7, (uint64_t)v40);
      v36[0] = MEMORY[0x263EF8330];
      v36[1] = 0x40000000;
      void v36[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_3;
      void v36[3] = &__block_descriptor_tmp_65_3;
      v36[4] = v11 + 56;
      *(void *)int v40 = v36;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationFactoryKeyHash,void({block_pointer}&)(bsp::tlv::ActivationFactoryKeyHash const&)>((qmi::MessageBase *)v24, 16, (uint64_t)v40);
      v35[0] = MEMORY[0x263EF8330];
      v35[1] = 0x40000000;
      std::string v35[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4;
      v35[3] = &__block_descriptor_tmp_66_4;
      v35[4] = v12;
      *(void *)int v40 = v35;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationImei,void({block_pointer}&)(bsp::tlv::ActivationImei const&)>((qmi::MessageBase *)v24, 17, (uint64_t)v40);
      v34[0] = MEMORY[0x263EF8330];
      v34[1] = 0x40000000;
      std::string v34[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5;
      void v34[3] = &__block_descriptor_tmp_67_6;
      v34[4] = v11 + 56;
      *(void *)int v40 = v34;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationMeid,void({block_pointer}&)(bsp::tlv::ActivationMeid const&)>((qmi::MessageBase *)v24, 18, v40);
      v33[0] = MEMORY[0x263EF8330];
      v33[1] = 0x40000000;
      std::string v33[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6;
      v33[3] = &__block_descriptor_tmp_68_2;
      uint8_t v33[4] = v11 + 144;
      *(void *)int v40 = v33;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationImsi,void({block_pointer}&)(bsp::tlv::ActivationImsi const&)>((qmi::MessageBase *)v24, (uint64_t)v40);
      *(void *)int v40 = MEMORY[0x263EF8330];
      uint64_t v41 = 0x40000000;
      *(void *)&long long v42 = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_7;
      *((void *)&v42 + 1) = &__block_descriptor_tmp_70_2;
      uint64_t v43 = v3 + 40;
      char v44 = v11 + 136;
      v32[0] = v40;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationType,void({block_pointer}&)(bsp::tlv::ActivationType const&)>((qmi::MessageBase *)v24, (uint64_t)v32);
      v32[0] = MEMORY[0x263EF8330];
      v32[1] = 0x40000000;
      void v32[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_71;
      v32[3] = &__block_descriptor_tmp_72_5;
      std::string v32[4] = v11 + 144;
      v31[0] = v32;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationIccid,void({block_pointer}&)(bsp::tlv::ActivationIccid const&)>((qmi::MessageBase *)v24, (uint64_t)v31);
      v31[0] = MEMORY[0x263EF8330];
      v31[1] = 0x40000000;
      void v31[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_2_73;
      v31[3] = &__block_descriptor_tmp_74_4;
      std::string v31[4] = v11 + 144;
      v30[0] = v31;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationGid1,void({block_pointer}&)(bsp::tlv::ActivationGid1 const&)>((qmi::MessageBase *)v24, (uint64_t)v30);
      v30[0] = MEMORY[0x263EF8330];
      v30[1] = 0x40000000;
      _OWORD v30[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_3_75;
      v30[3] = &__block_descriptor_tmp_76_4;
      void v30[4] = v11 + 144;
      v29[0] = v30;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationGid2,void({block_pointer}&)(bsp::tlv::ActivationGid2 const&)>((qmi::MessageBase *)v24, (uint64_t)v29);
      v29[0] = MEMORY[0x263EF8330];
      v29[1] = 0x40000000;
      std::string v29[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4_77;
      v29[3] = &__block_descriptor_tmp_78_4;
      std::string v29[4] = v12;
      v28[0] = v29;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationVersion,void({block_pointer}&)(bsp::tlv::ActivationVersion const&)>((qmi::MessageBase *)v24, 23, (uint64_t)v28);
      v28[0] = MEMORY[0x263EF8330];
      v28[1] = 0x40000000;
      _OWORD v28[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5_79;
      v28[3] = &__block_descriptor_tmp_80_3;
      v28[4] = v12;
      v27[0] = v28;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationMode,void({block_pointer}&)(bsp::tlv::ActivationMode const&)>((qmi::MessageBase *)v24, 25, (uint64_t)v27);
      v27[0] = MEMORY[0x263EF8330];
      v27[1] = 0x40000000;
      v27[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6_81;
      v27[3] = &__block_descriptor_tmp_82_4;
      void v27[4] = v12;
      uint64_t v39 = v27;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationFactoryDebug,void({block_pointer}&)(bsp::tlv::ActivationFactoryDebug const&)>((qmi::MessageBase *)v24, 26, (uint64_t)&v39);
      char v16 = v11[163];
      v11[312] = v16;
      v11[496] = v16;
      v11[128] = v11[80];
      qmi::MessageBase::~MessageBase((qmi::MessageBase *)v24);
      uint64_t v17 = *(void *)(v3 + 48);
      ActivationInfo::ActivationInfo((ActivationInfo *)v40, (const ActivationInfo *)(v49 + 40));
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v17 + 40))(v17, v40);
      UMTSProvisioningInfo::~UMTSProvisioningInfo(&v47);
      if (__p)
      {
        int v46 = __p;
        operator delete(__p);
      }
      if ((void)v42)
      {
        *((void *)&v42 + 1) = v42;
        operator delete((void *)v42);
      }
      goto LABEL_28;
    }
    uint64_t v18 = *v13;
    if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v40 = 0;
      uint64_t v19 = "#I Missing activation info TLV!";
      goto LABEL_26;
    }
  }
  else
  {
    uint64_t v18 = *v13;
    if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v40 = 0;
      uint64_t v19 = "#N Missing activation provisioning status TLV!";
LABEL_26:
      _os_log_impl(&dword_22231A000, v18, OS_LOG_TYPE_DEFAULT, v19, v40, 2u);
    }
  }
  (*(void (**)(void, uint64_t))(**(void **)(v3 + 48) + 24))(*(void *)(v3 + 48), 0x200000001);
LABEL_28:
  _Block_object_dispose(buf, 8);
  UMTSProvisioningInfo::~UMTSProvisioningInfo(v57);
  if (v55)
  {
    char v56 = v55;
    operator delete(v55);
  }
  if (v53)
  {
    uint64_t v54 = v53;
    operator delete(v53);
  }
}

void sub_222503518(_Unwind_Exception *a1)
{
  UMTSProvisioningInfo::~UMTSProvisioningInfo((void **)(v1 + 96));
  uint64_t v3 = (void *)STACK[0x2B0];
  if (STACK[0x2B0])
  {
    STACK[0x2B8] = (unint64_t)v3;
    operator delete(v3);
  }
  int v4 = (void *)STACK[0x290];
  if (STACK[0x290])
  {
    STACK[0x298] = (unint64_t)v4;
    operator delete(v4);
  }
  _Block_object_dispose(&STACK[0x490], 8);
  UMTSProvisioningInfo::~UMTSProvisioningInfo((void **)&STACK[0x518]);
  uint64_t v5 = (void *)STACK[0x4E8];
  if (STACK[0x4E8])
  {
    STACK[0x4F0] = (unint64_t)v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)STACK[0x4C8];
  if (STACK[0x4C8])
  {
    STACK[0x4D0] = (unint64_t)v6;
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__9(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 56) = 0;
  *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80);
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(unsigned char *)(a1 + 112) = *(unsigned char *)(a2 + 112);
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  *(unsigned char *)(a1 + 128) = *(unsigned char *)(a2 + 128);
  *(_WORD *)(a1 + 136) = *(_WORD *)(a2 + 136);
  long long v2 = *(_OWORD *)(a2 + 144);
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 144) = v2;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
  *(void *)(a1 + 184) = *(void *)(a2 + 184);
  *(void *)(a2 + 176) = 0;
  *(void *)(a2 + 184) = 0;
  *(void *)(a2 + 168) = 0;
  *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 200) = *(_OWORD *)(a2 + 200);
  *(void *)(a1 + 216) = *(void *)(a2 + 216);
  *(void *)(a2 + 200) = 0;
  *(void *)(a2 + 208) = 0;
  *(void *)(a2 + 216) = 0;
  *(unsigned char *)(a1 + 224) = *(unsigned char *)(a2 + 224);
  long long v3 = *(_OWORD *)(a2 + 232);
  *(void *)(a1 + 248) = *(void *)(a2 + 248);
  *(_OWORD *)(a1 + 232) = v3;
  *(void *)(a2 + 240) = 0;
  *(void *)(a2 + 248) = 0;
  *(void *)(a2 + 232) = 0;
  *(unsigned char *)(a1 + 256) = *(unsigned char *)(a2 + 256);
  long long v4 = *(_OWORD *)(a2 + 264);
  *(void *)(a1 + 280) = *(void *)(a2 + 280);
  *(_OWORD *)(a1 + 264) = v4;
  *(void *)(a2 + 272) = 0;
  *(void *)(a2 + 280) = 0;
  *(void *)(a2 + 264) = 0;
  *(unsigned char *)(a1 + 288) = *(unsigned char *)(a2 + 288);
  uint64_t v5 = *(void *)(a2 + 296);
  *(_WORD *)(a1 + 304) = *(_WORD *)(a2 + 304);
  *(void *)(a1 + 296) = v5;
  *(unsigned char *)(a1 + 312) = *(unsigned char *)(a2 + 312);
  long long v6 = *(_OWORD *)(a2 + 320);
  *(_DWORD *)(a1 + 336) = *(_DWORD *)(a2 + 336);
  *(_OWORD *)(a1 + 320) = v6;
  *(void *)(a1 + 352) = 0;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 344) = 0;
  uint64_t v7 = *(void *)(a2 + 352);
  *(void *)(a1 + 344) = *(void *)(a2 + 344);
  *(void *)(a1 + 352) = v7;
  *(void *)(a1 + 360) = *(void *)(a2 + 360);
  *(void *)(a2 + 352) = 0;
  *(void *)(a2 + 360) = 0;
  *(void *)(a2 + 344) = 0;
  *(unsigned char *)(a1 + 368) = *(unsigned char *)(a2 + 368);
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 376) = 0;
  uint64_t v8 = *(void *)(a2 + 384);
  *(void *)(a1 + 376) = *(void *)(a2 + 376);
  *(void *)(a1 + 384) = v8;
  *(void *)(a1 + 392) = *(void *)(a2 + 392);
  *(void *)(a2 + 384) = 0;
  *(void *)(a2 + 392) = 0;
  *(void *)(a2 + 376) = 0;
  *(unsigned char *)(a1 + 400) = *(unsigned char *)(a2 + 400);
  long long v9 = *(_OWORD *)(a2 + 408);
  *(void *)(a1 + 424) = *(void *)(a2 + 424);
  *(_OWORD *)(a1 + 408) = v9;
  *(void *)(a2 + 416) = 0;
  *(void *)(a2 + 424) = 0;
  *(void *)(a2 + 408) = 0;
  *(unsigned char *)(a1 + 432) = *(unsigned char *)(a2 + 432);
  long long v10 = *(_OWORD *)(a2 + 440);
  *(void *)(a1 + 456) = *(void *)(a2 + 456);
  *(_OWORD *)(a1 + 440) = v10;
  *(void *)(a2 + 448) = 0;
  *(void *)(a2 + 456) = 0;
  *(void *)(a2 + 440) = 0;
  *(unsigned char *)(a1 + 464) = *(unsigned char *)(a2 + 464);
  uint64_t v11 = *(void *)(a2 + 472);
  *(_WORD *)(a1 + 480) = *(_WORD *)(a2 + 480);
  *(void *)(a1 + 472) = v11;
  *(unsigned char *)(a1 + 488) = *(unsigned char *)(a2 + 488);
  *(unsigned char *)(a1 + 496) = *(unsigned char *)(a2 + 496);
  __n128 result = *(__n128 *)(a2 + 504);
  long long v13 = *(_OWORD *)(a2 + 520);
  long long v14 = *(_OWORD *)(a2 + 536);
  *(_OWORD *)(a1 + 549) = *(_OWORD *)(a2 + 549);
  *(_OWORD *)(a1 + 520) = v13;
  *(_OWORD *)(a1 + 536) = v14;
  *(__n128 *)(a1 + 504) = result;
  return result;
}

void __Block_byref_object_dispose__9(uint64_t a1)
{
  UMTSProvisioningInfo::~UMTSProvisioningInfo((void **)(a1 + 136));
  long long v2 = *(void **)(a1 + 88);
  if (v2)
  {
    *(void *)(a1 + 96) = v2;
    operator delete(v2);
  }
  long long v3 = *(void **)(a1 + 56);
  if (v3)
  {
    *(void *)(a1 + 64) = v3;
    operator delete(v3);
  }
}

void *___ZN26QMIActivationCommandDriver29handleActivationStateResponseERKN3bsp18GetActivationState8ResponseE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  __n128 result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((void *)(v4 + 56), (char *)a2, (char *)(a2 + 20), 0x14uLL);
  *(unsigned char *)(v4 + 80) = 1;
  int v6 = *(_DWORD *)(a2 + 20);
  __int16 v7 = *(_WORD *)(a2 + 24);
  *(unsigned char *)(v4 + 126) = *(unsigned char *)(a2 + 26);
  *(_WORD *)(v4 + 124) = v7;
  *(_DWORD *)(v4 + 120) = v6;
  *(unsigned char *)(v4 + 127) = 1;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 128) = 1;
  return result;
}

void ___ZN26QMIActivationCommandDriver35handleChipIdAndSerialNumberResponseERKN3bsp21GetChipIdSerialNumber8ResponseE_block_invoke(uint64_t a1, int *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Reading chip id and serial number", buf, 2u);
  }
  uint64_t v21 = 0;
  *(_OWORD *)long long buf = 0u;
  long long v20 = 0u;
  ChipInformation::ChipInformation((ChipInformation *)buf);
  int __src = *a2;
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&buf[8], (char *)&__src, (char *)buf, 4uLL);
  uint64_t v5 = *(const void **)&buf[8];
  uint64_t v6 = v20;
  __int16 v7 = (unsigned char *)(v20 - 1);
  if (*(void *)&buf[8] != (void)v20 && (unint64_t)v7 > *(void *)&buf[8])
  {
    unint64_t v9 = *(void *)&buf[8] + 1;
    do
    {
      char v10 = *(unsigned char *)(v9 - 1);
      *(unsigned char *)(v9 - 1) = *v7;
      *v7-- = v10;
    }
    while (v9++ < (unint64_t)v7);
    uint64_t v5 = *(const void **)&buf[8];
    uint64_t v6 = v20;
  }
  LOBYTE(v21) = 1;
  *(_DWORD *)long long buf = a2[1];
  uint8_t buf[4] = 1;
  uint64_t v12 = *(void *)(v3 + 48);
  uint64_t v13 = *(void *)buf;
  std::string __p = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  std::vector<char>::__init_with_size[abi:ne180100]<char *,char *>(&__p, v5, v6, v6 - (void)v5);
  char v17 = v21;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v12 + 32))(v12, &v13);
  if (__p)
  {
    uint64_t v15 = __p;
    operator delete(__p);
  }
  if (*(void *)&buf[8])
  {
    *(void *)&long long v20 = *(void *)&buf[8];
    operator delete(*(void **)&buf[8]);
  }
}

void sub_222503A00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void std::shared_ptr<QMIMav13ActivationCommandDriver>::shared_ptr[abi:ne180100]<QMIMav13ActivationCommandDriver,std::shared_ptr<QMIMav13ActivationCommandDriver> ctu::SharedSynchronizable<ActivationCommandDriver>::make_shared_ptr<QMIMav13ActivationCommandDriver>(QMIMav13ActivationCommandDriver*)::{lambda(QMIMav13ActivationCommandDriver*)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_222503B00(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMIMav13ActivationCommandDriver> ctu::SharedSynchronizable<ActivationCommandDriver>::make_shared_ptr<QMIMav13ActivationCommandDriver>(QMIMav13ActivationCommandDriver*)::{lambda(QMIMav13ActivationCommandDriver*)#1}::operator() const(QMIMav13ActivationCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_222503B28(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<QMIMav13ActivationCommandDriver *,std::shared_ptr<QMIMav13ActivationCommandDriver> ctu::SharedSynchronizable<ActivationCommandDriver>::make_shared_ptr<QMIMav13ActivationCommandDriver>(QMIMav13ActivationCommandDriver*)::{lambda(QMIMav13ActivationCommandDriver *)#1},std::allocator<QMIMav13ActivationCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<QMIMav13ActivationCommandDriver *,std::shared_ptr<QMIMav13ActivationCommandDriver> ctu::SharedSynchronizable<ActivationCommandDriver>::make_shared_ptr<QMIMav13ActivationCommandDriver>(QMIMav13ActivationCommandDriver*)::{lambda(QMIMav13ActivationCommandDriver *)#1},std::allocator<QMIMav13ActivationCommandDriver>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<QMIMav13ActivationCommandDriver *,std::shared_ptr<QMIMav13ActivationCommandDriver> ctu::SharedSynchronizable<ActivationCommandDriver>::make_shared_ptr<QMIMav13ActivationCommandDriver>(QMIMav13ActivationCommandDriver*)::{lambda(QMIMav13ActivationCommandDriver *)#1},std::allocator<QMIMav13ActivationCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIMav13ActivationCommandDriver> ctu::SharedSynchronizable<ActivationCommandDriver>::make_shared_ptr<QMIMav13ActivationCommandDriver>(QMIMav13ActivationCommandDriver*)::{lambda(QMIMav13ActivationCommandDriver*)#1}::operator() const(QMIMav13ActivationCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3bsp22SendActivationManifest8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222503CC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3bsp21GetChipIdSerialNumber8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  cast_message_type<bsp::GetChipIdSerialNumber::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_222503D58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3bsp18GetActivationState8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222503E30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t ___ZL21parseActivationStatusIN3bsp22SendActivationManifest8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke(uint64_t result, unsigned __int16 *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  int v3 = *((unsigned __int8 *)a2 + 2);
  *(_DWORD *)uint64_t v2 = *a2;
  *(_DWORD *)(v2 + 4) = v3;
  if (*((_DWORD *)a2 + 1)) {
    char v4 = 1;
  }
  else {
    char v4 = 2;
  }
  *(unsigned char *)(v2 + 8) = v4;
  *(unsigned char *)(v2 + 12) = 1;
  return result;
}

uint64_t ___ZL21parseActivationStatusIN3bsp22SendActivationManifest8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke_30(uint64_t result, _WORD *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  *(_WORD *)(v2 + 258) = *a2;
  unsigned int v3 = (unsigned __int16)a2[1];
  *(_WORD *)(v2 + 256) = v3;
  *(unsigned char *)(v2 + 260) = 1;
  *(unsigned char *)(v2 + 272) = 1;
  if (v3 >= 0x3E8) {
    return __TUAssertTrigger();
  }
  return result;
}

uint64_t qmi::MessageBase::applyTlv<bsp::tlv::ActivationProvisioningStatus,void({block_pointer}&)(bsp::tlv::ActivationProvisioningStatus const&)>(qmi::MessageBase *a1, void *a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    uint64_t v6 = result;
    int v7 = v5;
    uint64_t v10 = result;
    tlv::parseV<bsp::tlv::ActivationProvisioningStatus>((unint64_t *)&v10, v5);
    if (v10)
    {
      (*(void (**)(void))(*a2 + 16))(*a2);
      return 1;
    }
    else
    {
      uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v9 = *(unsigned __int16 *)a1;
      return v8(v9, 3, v6, v7);
    }
  }
  return result;
}

uint64_t qmi::MessageBase::applyTlv<bsp::tlv::ActivationInfo,void({block_pointer}&)(bsp::tlv::ActivationInfo const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    uint64_t v8 = result;
    int v9 = v5;
    uint64_t v12 = (bsp::tlv *)result;
    tlv::parseV<bsp::tlv::ActivationInfo>(&v12, v5, v6, v7);
    if (v12)
    {
      (*(void (**)(void))(*(void *)a2 + 16))();
      return 1;
    }
    else
    {
      uint64_t v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v11 = *(unsigned __int16 *)a1;
      return v10(v11, 4, v8, v9);
    }
  }
  return result;
}

void *___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke(uint64_t a1, uint64_t a2)
{
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(*(void **)(a1 + 32), (char *)a2, (char *)(a2 + 20), 0x14uLL);
  uint64_t v4 = *(void *)(a1 + 32);
  *(unsigned char *)(v4 + 24) = 1;
  uint64_t result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((void *)(v4 + 32), *(char **)(a2 + 24), *(char **)(a2 + 32), *(void *)(a2 + 32) - *(void *)(a2 + 24));
  *(unsigned char *)(*(void *)(a1 + 32) + 56) = *(void *)(a2 + 24) != *(void *)(a2 + 32);
  return result;
}

void *___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_2(uint64_t a1, char **a2)
{
  uint64_t result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(*(void **)(a1 + 32), *a2, a2[1], a2[1] - *a2);
  *(unsigned char *)(*(void *)(a1 + 32) + 24) = 1;
  return result;
}

void *___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_3(uint64_t a1, char **a2)
{
  uint64_t result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((void *)(*(void *)(a1 + 32) + 32), *a2, a2[1], a2[1] - *a2);
  *(unsigned char *)(*(void *)(a1 + 32) + 56) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4(uint64_t a1, unsigned __int8 *a2)
{
  *(void *)(*(void *)(a1 + 32) + 464) = *(void *)a2;
  uint64_t result = ActivationCommandDriver::parseImei((ActivationCommandDriver *)(*(void *)(a1 + 32) + 464), a2);
  *(unsigned char *)(*(void *)(a1 + 32) + 472) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5(uint64_t result, int *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  int v3 = *a2;
  __int16 v4 = *((_WORD *)a2 + 2);
  *(unsigned char *)(v2 + 70) = *((unsigned char *)a2 + 6);
  *(_WORD *)(v2 + 68) = v4;
  *(_DWORD *)(v2 + 64) = v3;
  *(unsigned char *)(*(void *)(result + 32) + 71) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6(uint64_t result, void *a2)
{
  **(void **)(result + 32) = *a2;
  *(unsigned char *)(*(void *)(result + 32) + 8) = 1;
  return result;
}

void ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_7(uint64_t a1, unsigned __int16 *a2)
{
  __int16 v4 = **(NSObject ***)(a1 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I OQC activation mode detected, overriding IMSI", v6, 2u);
  }
  int v5 = *(BOOL **)(a1 + 40);
  *int v5 = *a2 == 1;
  v5[1] = 1;
}

void *___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_41(void *result, uint64_t a2)
{
  int v3 = result;
  __int16 v4 = *(unsigned char **)a2;
  int v5 = *(unsigned char **)(a2 + 8);
  if (v5 != v4) {
    uint64_t result = memmove((void *)(result[4] + 9), v4, v5 - v4);
  }
  *(unsigned char *)(v3[4] + 19) = 1;
  return result;
}

void *___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_2_43(uint64_t a1, char **a2)
{
  uint64_t result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((void *)(*(void *)(a1 + 32) + 24), *a2, a2[1], a2[1] - *a2);
  *(unsigned char *)(*(void *)(a1 + 32) + 48) = 1;
  return result;
}

void *___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_3_45(uint64_t a1, char **a2)
{
  uint64_t result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((void *)(*(void *)(a1 + 32) + 56), *a2, a2[1], a2[1] - *a2);
  *(unsigned char *)(*(void *)(a1 + 32) + 80) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4_47(uint64_t result, _DWORD *a2)
{
  *(_DWORD *)(*(void *)(result + 32) + 482) = *a2;
  *(unsigned char *)(*(void *)(result + 32) + 486) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5_50(uint64_t result, unsigned __int8 *a2)
{
  int v2 = *a2;
  if ((v2 - 1) <= 1)
  {
    uint64_t v3 = *(void *)(result + 32);
    *(_DWORD *)(v3 + 488) = v2;
    *(unsigned char *)(v3 + 492) = 1;
  }
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6_53(uint64_t result, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  *(_DWORD *)(v2 + 496) = *a2;
  *(unsigned char *)(v2 + 500) = 1;
  return result;
}

void qmi::MessageBase::applyTlv<bsp::tlv::ActivationRootManifestHash,void({block_pointer}&)(bsp::tlv::ActivationRootManifestHash const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t TlvValue = qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    uint64_t v6 = TlvValue;
    int v7 = v5;
    unint64_t v11 = TlvValue;
    *(_OWORD *)std::string __p = 0u;
    long long v14 = 0u;
    long long v12 = 0u;
    tlv::parseV<bsp::tlv::ActivationRootManifestHash>(&v11, v5, &v12);
    unint64_t v8 = v11;
    if (v11) {
      (*(void (**)(void))(*(void *)a2 + 16))();
    }
    if (__p[1])
    {
      *(void **)&long long v14 = __p[1];
      operator delete(__p[1]);
    }
    if (!v8)
    {
      int v9 = (void (*)(uint64_t, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v10 = *(unsigned __int16 *)a1;
      v9(v10, 6, v6, v7);
    }
  }
}

void sub_2225044A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t qmi::MessageBase::applyTlv<bsp::tlv::ActivationImsi,void({block_pointer}&)(bsp::tlv::ActivationImsi const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  _DWORD v10[2] = *MEMORY[0x263EF8340];
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    uint64_t v6 = result;
    int v7 = v5;
    v10[0] = result;
    v10[1] = tlv::parseV<bsp::tlv::ActivationImsi>(v10, v5);
    if (v10[0])
    {
      return (*(uint64_t (**)(void))(*(void *)a2 + 16))();
    }
    else
    {
      unint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v9 = *(unsigned __int16 *)a1;
      return v8(v9, 19, v6, v7);
    }
  }
  return result;
}

uint64_t qmi::MessageBase::applyTlv<bsp::tlv::ActivationType,void({block_pointer}&)(bsp::tlv::ActivationType const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    uint64_t v6 = result;
    int v7 = v5;
    uint64_t v10 = result;
    tlv::parseV<bsp::tlv::ActivationType>((unint64_t *)&v10, v5);
    if (v10)
    {
      return (*(uint64_t (**)(void))(*(void *)a2 + 16))();
    }
    else
    {
      unint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v9 = *(unsigned __int16 *)a1;
      return v8(v9, 24, v6, v7);
    }
  }
  return result;
}

void qmi::MessageBase::applyTlv<bsp::tlv::ActivationIccid,void({block_pointer}&)(bsp::tlv::ActivationIccid const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t TlvValue = (char *)qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    uint64_t v6 = TlvValue;
    int v7 = v5;
    uint64_t v13 = 0;
    long long v14 = TlvValue;
    std::string __p = 0;
    long long v12 = 0;
    tlv::parseV<bsp::tlv::ActivationIccid>(&v14, v5, &__p);
    unint64_t v8 = v14;
    if (v14) {
      (*(void (**)(void))(*(void *)a2 + 16))();
    }
    if (__p)
    {
      long long v12 = __p;
      operator delete(__p);
    }
    if (!v8)
    {
      uint64_t v9 = (void (*)(uint64_t, uint64_t, char *, void))*MEMORY[0x263F8BD78];
      uint64_t v10 = *(unsigned __int16 *)a1;
      v9(v10, 22, v6, v7);
    }
  }
}

void sub_222504750(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void qmi::MessageBase::applyTlv<bsp::tlv::ActivationGid1,void({block_pointer}&)(bsp::tlv::ActivationGid1 const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t TlvValue = (char *)qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    uint64_t v6 = TlvValue;
    int v7 = v5;
    uint64_t v13 = 0;
    long long v14 = TlvValue;
    std::string __p = 0;
    long long v12 = 0;
    tlv::parseV<bsp::tlv::ActivationGid1>(&v14, v5, &__p);
    unint64_t v8 = v14;
    if (v14) {
      (*(void (**)(void))(*(void *)a2 + 16))();
    }
    if (__p)
    {
      long long v12 = __p;
      operator delete(__p);
    }
    if (!v8)
    {
      uint64_t v9 = (void (*)(uint64_t, uint64_t, char *, void))*MEMORY[0x263F8BD78];
      uint64_t v10 = *(unsigned __int16 *)a1;
      v9(v10, 20, v6, v7);
    }
  }
}

void sub_222504844(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void qmi::MessageBase::applyTlv<bsp::tlv::ActivationGid2,void({block_pointer}&)(bsp::tlv::ActivationGid2 const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t TlvValue = (char *)qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    uint64_t v6 = TlvValue;
    int v7 = v5;
    uint64_t v13 = 0;
    long long v14 = TlvValue;
    std::string __p = 0;
    long long v12 = 0;
    tlv::parseV<bsp::tlv::ActivationGid2>(&v14, v5, &__p);
    unint64_t v8 = v14;
    if (v14) {
      (*(void (**)(void))(*(void *)a2 + 16))();
    }
    if (__p)
    {
      long long v12 = __p;
      operator delete(__p);
    }
    if (!v8)
    {
      uint64_t v9 = (void (*)(uint64_t, uint64_t, char *, void))*MEMORY[0x263F8BD78];
      uint64_t v10 = *(unsigned __int16 *)a1;
      v9(v10, 21, v6, v7);
    }
  }
}

void sub_222504938(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZL21parseActivationStatusIN3bsp18GetActivationState8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke(uint64_t result, unsigned __int16 *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  int v3 = *((unsigned __int8 *)a2 + 2);
  *(_DWORD *)uint64_t v2 = *a2;
  *(_DWORD *)(v2 + 4) = v3;
  if (*((_DWORD *)a2 + 1)) {
    char v4 = 1;
  }
  else {
    char v4 = 2;
  }
  *(unsigned char *)(v2 + 8) = v4;
  *(unsigned char *)(v2 + 12) = 1;
  return result;
}

uint64_t ___ZL21parseActivationStatusIN3bsp18GetActivationState8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke_60(uint64_t result, _WORD *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  *(_WORD *)(v2 + 258) = *a2;
  unsigned int v3 = (unsigned __int16)a2[1];
  *(_WORD *)(v2 + 256) = v3;
  *(unsigned char *)(v2 + 260) = 1;
  *(unsigned char *)(v2 + 272) = 1;
  if (v3 >= 0x3E8) {
    return __TUAssertTrigger();
  }
  return result;
}

void *___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke(uint64_t a1, uint64_t a2)
{
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(*(void **)(a1 + 32), (char *)a2, (char *)(a2 + 20), 0x14uLL);
  uint64_t v4 = *(void *)(a1 + 32);
  *(unsigned char *)(v4 + 24) = 1;
  uint64_t result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((void *)(v4 + 32), *(char **)(a2 + 24), *(char **)(a2 + 32), *(void *)(a2 + 32) - *(void *)(a2 + 24));
  *(unsigned char *)(*(void *)(a1 + 32) + 56) = *(void *)(a2 + 24) != *(void *)(a2 + 32);
  return result;
}

void *___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_2(uint64_t a1, char **a2)
{
  uint64_t result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(*(void **)(a1 + 32), *a2, a2[1], a2[1] - *a2);
  *(unsigned char *)(*(void *)(a1 + 32) + 24) = 1;
  return result;
}

void *___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_3(uint64_t a1, char **a2)
{
  uint64_t result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((void *)(*(void *)(a1 + 32) + 32), *a2, a2[1], a2[1] - *a2);
  *(unsigned char *)(*(void *)(a1 + 32) + 56) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4(uint64_t a1, unsigned __int8 *a2)
{
  *(void *)(*(void *)(a1 + 32) + 464) = *(void *)a2;
  uint64_t result = ActivationCommandDriver::parseImei((ActivationCommandDriver *)(*(void *)(a1 + 32) + 464), a2);
  *(unsigned char *)(*(void *)(a1 + 32) + 472) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5(uint64_t result, int *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  int v3 = *a2;
  __int16 v4 = *((_WORD *)a2 + 2);
  *(unsigned char *)(v2 + 70) = *((unsigned char *)a2 + 6);
  *(_WORD *)(v2 + 68) = v4;
  *(_DWORD *)(v2 + 64) = v3;
  *(unsigned char *)(*(void *)(result + 32) + 71) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6(uint64_t result, void *a2)
{
  **(void **)(result + 32) = *a2;
  *(unsigned char *)(*(void *)(result + 32) + 8) = 1;
  return result;
}

void ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_7(uint64_t a1, unsigned __int16 *a2)
{
  __int16 v4 = **(NSObject ***)(a1 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I OQC activation mode detected, overriding IMSI", v6, 2u);
  }
  int v5 = *(BOOL **)(a1 + 40);
  *int v5 = *a2 == 1;
  v5[1] = 1;
}

void *___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_71(void *result, uint64_t a2)
{
  int v3 = result;
  __int16 v4 = *(unsigned char **)a2;
  int v5 = *(unsigned char **)(a2 + 8);
  if (v5 != v4) {
    uint64_t result = memmove((void *)(result[4] + 9), v4, v5 - v4);
  }
  *(unsigned char *)(v3[4] + 19) = 1;
  return result;
}

void *___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_2_73(uint64_t a1, char **a2)
{
  uint64_t result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((void *)(*(void *)(a1 + 32) + 24), *a2, a2[1], a2[1] - *a2);
  *(unsigned char *)(*(void *)(a1 + 32) + 48) = 1;
  return result;
}

void *___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_3_75(uint64_t a1, char **a2)
{
  uint64_t result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((void *)(*(void *)(a1 + 32) + 56), *a2, a2[1], a2[1] - *a2);
  *(unsigned char *)(*(void *)(a1 + 32) + 80) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4_77(uint64_t result, _DWORD *a2)
{
  *(_DWORD *)(*(void *)(result + 32) + 482) = *a2;
  *(unsigned char *)(*(void *)(result + 32) + 486) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5_79(uint64_t result, unsigned __int8 *a2)
{
  int v2 = *a2;
  if ((v2 - 1) <= 1)
  {
    uint64_t v3 = *(void *)(result + 32);
    *(_DWORD *)(v3 + 488) = v2;
    *(unsigned char *)(v3 + 492) = 1;
  }
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6_81(uint64_t result, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  *(_DWORD *)(v2 + 496) = *a2;
  *(unsigned char *)(v2 + 500) = 1;
  return result;
}

uint64_t QMISuppServicesCommandDriver::mapQMIErrorToCSI(QMISuppServicesCommandDriver *this, int a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  __int16 v4 = *((void *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 67109120;
    v8[1] = a2;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause provided in the response %d", (uint8_t *)v8, 8u);
  }
  if ((a2 - 129) >= 2)
  {
    if (a2)
    {
      int v7 = *((void *)this + 5);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v8[0]) = 0;
        _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#I Unknown Error", (uint8_t *)v8, 2u);
      }
    }
    return 1;
  }
  else
  {
    int v5 = *((void *)this + 5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8[0]) = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Mapping to Incorrect Password", (uint8_t *)v8, 2u);
    }
    return 42;
  }
}

void QMISuppServicesCommandDriver::create()
{
}

void sub_222504EE4(_Unwind_Exception *exception_object)
{
  if (v2) {
    dispatch_release(v2);
  }
  if (v3) {
    MEMORY[0x223C9A950](v1, 0x10E1C40A824EF22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t QMISuppServicesCommandDriver::QMISuppServicesCommandDriver(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  unsigned char v8[8] = *MEMORY[0x263EF8340];
  xpc_object_t object = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  SuppServicesCommandDriver::SuppServicesCommandDriver();
  if (object) {
    dispatch_release(object);
  }
  v7[0] = &unk_26D4C05F8;
  void v7[3] = v7;
  __int16 v4 = (capabilities::ct *)std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)v8, (uint64_t)v7);
  *(void *)(a1 + 80) = 0;
  if ((capabilities::ct::supportsGemini(v4) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 80)) {
    operator new();
  }
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100](v8);
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100](v7);
  *(void *)a1 = &unk_26D4D4610;
  *(unsigned char *)(a1 + 88) = 15;
  *(void *)(a1 + 96) = 0;
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 104), *(os_log_s **)(a1 + 40));
  return a1;
}

void sub_222505120(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va2);
  MEMORY[0x223C9A950](v3, 0x10A1C40FF1576FELL);
  uint64_t v5 = *((void *)v2 + 10);
  *((void *)v2 + 10) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va);
  SuppServicesCommandDriver::~SuppServicesCommandDriver(v2);
  _Unwind_Resume(a1);
}

void sub_2225051E8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x2225051E0);
}

void QMISuppServicesCommandDriver::~QMISuppServicesCommandDriver(QMISuppServicesCommandDriver *this)
{
  *(void *)this = &unk_26D4D4610;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 14);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = *((void *)this + 12);
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }

  SuppServicesCommandDriver::~SuppServicesCommandDriver(this);
}

{
  uint64_t vars8;

  QMISuppServicesCommandDriver::~QMISuppServicesCommandDriver(this);

  JUMPOUT(0x223C9A950);
}

const char *QMISuppServicesCommandDriver::getName(QMISuppServicesCommandDriver *this)
{
  return "QMISuppServicesCommandDriver";
}

const char *QMISuppServicesCommandDriver::getTransportName(QMISuppServicesCommandDriver *this)
{
  return "Baseband";
}

void QMISuppServicesCommandDriver::bootstrap(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *a3;
  if (*a3)
  {
    dispatch_retain(*a3);
    dispatch_group_enter(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMISuppServicesCommandDriver::start(QMISuppServicesCommandDriver *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

uint64_t QMISuppServicesCommandDriver::stop()
{
  return qmi::ClientRouter::stop();
}

void QMISuppServicesCommandDriver::setAutoAnswerMode(uint64_t a1, uint64_t a2, char a3)
{
  *(_OWORD *)std::string __p = 0u;
  long long v9 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 0x40000000;
  _OWORD v6[2] = ___ZN28QMISuppServicesCommandDriver17setAutoAnswerModeEN10subscriber7SimSlotEb_block_invoke;
  v6[3] = &__block_descriptor_tmp_28;
  char v7 = a3;
  uint64_t v4 = (const void **)__p[1];
  if (__p[1] != (void *)v9)
  {
    while (*((unsigned char *)*v4 + 8) != 16)
    {
      if (++v4 == (const void **)v9) {
        goto LABEL_8;
      }
    }
  }
  if (v4 != (const void **)v9)
  {
    if (v5)
    {
      ___ZN28QMISuppServicesCommandDriver17setAutoAnswerModeEN10subscriber7SimSlotEb_block_invoke((uint64_t)v6, v5 + 9);
      qmi::ClientRouter::get();
      operator new();
    }
    __cxa_bad_cast();
  }
LABEL_8:
  operator new();
}

void sub_2225058D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  if (a27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a27);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v28);
  if (a11) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v27, a11);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a17);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver17setAutoAnswerModeEN10subscriber7SimSlotEb_block_invoke(uint64_t result, unsigned char *a2)
{
  *a2 = *(unsigned char *)(result + 32);
  return result;
}

void QMISuppServicesCommandDriver::fetchCallForwarding(uint64_t a1, uint64_t a2, int a3, int a4)
{
  memset(v15, 0, sizeof(v15));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v15);
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 0x40000000;
  v13[2] = ___ZN28QMISuppServicesCommandDriver19fetchCallForwardingEN10subscriber7SimSlotE22CTCallForwardingReasonj_block_invoke;
  void v13[3] = &__block_descriptor_tmp_5_7;
  v13[4] = a1;
  int v14 = a3;
  uint64_t v8 = qmi::MutableMessageBase::getTLV<vs::tlv::Reason>((uint64_t)v15);
  ___ZN28QMISuppServicesCommandDriver19fetchCallForwardingEN10subscriber7SimSlotE22CTCallForwardingReasonj_block_invoke((uint64_t)v13, v8);
  if (a4)
  {
    v11[0] = MEMORY[0x263EF8330];
    v11[1] = 0x40000000;
    _DWORD v11[2] = ___ZN28QMISuppServicesCommandDriver19fetchCallForwardingEN10subscriber7SimSlotE22CTCallForwardingReasonj_block_invoke_2;
    v11[3] = &__block_descriptor_tmp_7_11;
    int v12 = a4;
    long long v9 = qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>((uint64_t)v15);
    ___ZN28QMISuppServicesCommandDriver19fetchCallForwardingEN10subscriber7SimSlotE22CTCallForwardingReasonj_block_invoke_2((uint64_t)v11, v9);
  }
  else
  {
    uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v10, OS_LOG_TYPE_DEFAULT, "#I Call class is not available, not setting it", buf, 2u);
    }
  }
  qmi::ClientRouter::get();
  operator new();
}

void sub_222505C6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver19fetchCallForwardingEN10subscriber7SimSlotE22CTCallForwardingReasonj_block_invoke(uint64_t result, unsigned char *a2)
{
  unsigned int v2 = *(_DWORD *)(result + 40);
  if (v2 < 6) {
    char v3 = v2 + 1;
  }
  else {
    char v3 = 0;
  }
  *a2 = v3;
  return result;
}

uint64_t ___ZN28QMISuppServicesCommandDriver19fetchCallForwardingEN10subscriber7SimSlotE22CTCallForwardingReasonj_block_invoke_2(uint64_t result, unsigned char *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

void ___ZN28QMISuppServicesCommandDriver28handleCallForwardingResponseEN10subscriber7SimSlotERKN2vs14CallForwarding8ResponseE22CTCallForwardingReasonj_block_invoke(uint64_t a1, _WORD *a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 40) + 80) + 16))(*(void *)(*(void *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
}

__n128 __Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__10(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void ___ZN28QMISuppServicesCommandDriver28handleCallForwardingResponseEN10subscriber7SimSlotERKN2vs14CallForwarding8ResponseE22CTCallForwardingReasonj_block_invoke_10(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = *(uint64_t **)(v3 + 40);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 48);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v43 = v4;
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  std::vector<vs::tlv::ServiceParam>::__clear[abi:ne180100](v5);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a2[1] - *a2) >> 3);
  uint64_t v9 = *v5;
  if (0xCCCCCCCCCCCCCCCDLL * ((v5[2] - *v5) >> 3) < v8)
  {
    if (v8 > 0x666666666666666) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v5[1];
    uint64_t v50 = v5 + 2;
    uint64_t v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SelectionItem>>(v8);
    uint64_t v14 = *v5;
    uint64_t v13 = v5[1];
    if (v13 == *v5)
    {
      uint64_t v19 = v5[1];
      uint64_t v15 = &v11[v10 - v9];
    }
    else
    {
      uint64_t v15 = &v11[v10 - v9];
      do
      {
        __int16 v16 = *(_WORD *)(v13 - 40);
        v13 -= 40;
        char v17 = *(unsigned char *)(v13 + 2);
        *((_WORD *)v15 - 20) = v16;
        v15 -= 40;
        _OWORD v15[2] = v17;
        long long v18 = *(_OWORD *)(v13 + 8);
        *((void *)v15 + 3) = *(void *)(v13 + 24);
        *(_OWORD *)(v15 + 8) = v18;
        *(void *)(v13 + 16) = 0;
        *(void *)(v13 + 24) = 0;
        *(void *)(v13 + 8) = 0;
        v15[32] = *(unsigned char *)(v13 + 32);
      }
      while (v13 != v14);
      uint64_t v19 = *v5;
      uint64_t v13 = v5[1];
    }
    *uint64_t v5 = (uint64_t)v15;
    int v46 = (unsigned char *)v19;
    uint64_t v47 = v19;
    v5[1] = (uint64_t)&v11[v10 - v9];
    char v48 = (char *)v13;
    uint64_t v20 = v5[2];
    _OWORD v5[2] = (uint64_t)&v11[40 * v12];
    long long v49 = (char *)v20;
    std::__split_buffer<CallForwardServiceParameter>::~__split_buffer((uint64_t)&v46);
  }
  for (; v6 != v7; v6 += 40)
  {
    uint64_t v45 = 0;
    memset(__p, 0, sizeof(__p));
    *(_WORD *)((char *)__p + 1) = *(_WORD *)v6;
    std::string::operator=((std::string *)&__p[1], (const std::string *)(v6 + 8));
    LOBYTE(v45) = *(unsigned char *)(v6 + 32);
    unint64_t v22 = v5[1];
    unint64_t v21 = v5[2];
    if (v22 >= v21)
    {
      unint64_t v25 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v22 - *v5) >> 3);
      unint64_t v26 = v25 + 1;
      if (v25 + 1 > 0x666666666666666) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v27 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v21 - *v5) >> 3);
      if (2 * v27 > v26) {
        unint64_t v26 = 2 * v27;
      }
      if (v27 >= 0x333333333333333) {
        unint64_t v28 = 0x666666666666666;
      }
      else {
        unint64_t v28 = v26;
      }
      uint64_t v50 = v5 + 2;
      if (v28)
      {
        uint64_t v30 = std::__allocate_at_least[abi:ne180100]<std::allocator<SelectionItem>>(v28);
      }
      else
      {
        uint64_t v30 = 0;
        uint64_t v29 = 0;
      }
      int v32 = &v30[40 * v25];
      int v46 = v30;
      uint64_t v47 = (uint64_t)v32;
      char v48 = v32;
      long long v49 = &v30[40 * v29];
      void v32[2] = BYTE2(__p[0]);
      *(_WORD *)int v32 = __p[0];
      uint64_t v33 = (std::string *)(v32 + 8);
      if (SHIBYTE(__p[3]) < 0)
      {
        std::string::__init_copy_ctor_external(v33, (const std::string::value_type *)__p[1], (std::string::size_type)__p[2]);
        int v32 = (char *)v47;
        uint64_t v35 = v48;
      }
      else
      {
        long long v34 = *(_OWORD *)&__p[1];
        *((void **)v32 + 3) = __p[3];
        *(_OWORD *)&v33->__r_.__value_.__l.__data_ = v34;
        uint64_t v35 = &v30[40 * v25];
      }
      v30[40 * v25 + 32] = v45;
      uint64_t v37 = *v5;
      uint64_t v36 = v5[1];
      if (v36 == *v5)
      {
        uint64_t v41 = v5[1];
      }
      else
      {
        do
        {
          __int16 v38 = *(_WORD *)(v36 - 40);
          v36 -= 40;
          char v39 = *(unsigned char *)(v36 + 2);
          *((_WORD *)v32 - 20) = v38;
          v32 -= 40;
          void v32[2] = v39;
          long long v40 = *(_OWORD *)(v36 + 8);
          *((void *)v32 + 3) = *(void *)(v36 + 24);
          *(_OWORD *)(v32 + 8) = v40;
          *(void *)(v36 + 16) = 0;
          *(void *)(v36 + 24) = 0;
          *(void *)(v36 + 8) = 0;
          v32[32] = *(unsigned char *)(v36 + 32);
        }
        while (v36 != v37);
        uint64_t v41 = *v5;
        uint64_t v36 = v5[1];
      }
      uint64_t v31 = (uint64_t)(v35 + 40);
      *uint64_t v5 = (uint64_t)v32;
      int v46 = (unsigned char *)v41;
      uint64_t v47 = v41;
      v5[1] = (uint64_t)(v35 + 40);
      char v48 = (char *)v36;
      uint64_t v42 = v5[2];
      _OWORD v5[2] = (uint64_t)v49;
      long long v49 = (char *)v42;
      std::__split_buffer<CallForwardServiceParameter>::~__split_buffer((uint64_t)&v46);
    }
    else
    {
      *(unsigned char *)(v22 + 2) = BYTE2(__p[0]);
      *(_WORD *)unint64_t v22 = __p[0];
      int v23 = (std::string *)(v22 + 8);
      if (SHIBYTE(__p[3]) < 0)
      {
        std::string::__init_copy_ctor_external(v23, (const std::string::value_type *)__p[1], (std::string::size_type)__p[2]);
      }
      else
      {
        long long v24 = *(_OWORD *)&__p[1];
        *(void **)(v22 + 24) = __p[3];
        *(_OWORD *)&v23->__r_.__value_.__l.__data_ = v24;
      }
      *(unsigned char *)(v22 + 32) = v45;
      uint64_t v31 = v22 + 40;
      v5[1] = v31;
    }
    v5[1] = v31;
    if (SHIBYTE(__p[3]) < 0) {
      operator delete(__p[1]);
    }
  }
  if (v43)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v43);
  }
}

void sub_222506168(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, char a19)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void QMISuppServicesCommandDriver::setCallForwarding(uint64_t a1, uint64_t a2, int a3, CSIPhoneNumber *a4, int a5, int a6, int a7)
{
  long long v34 = 0u;
  long long v35 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v34);
  v31[0] = MEMORY[0x263EF8330];
  v31[1] = 0x40000000;
  void v31[2] = ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke;
  v31[3] = &__block_descriptor_tmp_14_7;
  std::string v31[4] = a1;
  char v33 = a3;
  int v32 = a5;
  uint64_t v14 = qmi::MutableMessageBase::getTLV<vs::tlv::SupsService>((uint64_t)&v34);
  ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke((uint64_t)v31, v14);
  if (a6)
  {
    v29[0] = MEMORY[0x263EF8330];
    v29[1] = 0x40000000;
    std::string v29[2] = ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke_2;
    v29[3] = &__block_descriptor_tmp_15_11;
    int v30 = a6;
    uint64_t v15 = qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>((uint64_t)&v34);
    ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke_2((uint64_t)v29, v15);
  }
  else
  {
    __int16 v16 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_22231A000, v16, OS_LOG_TYPE_DEFAULT, "#I Not including the service class as it is unknown", (uint8_t *)&buf, 2u);
    }
  }
  if (a3)
  {
    memset(&buf, 0, sizeof(buf));
    CSIPhoneNumber::getFullNumber((uint64_t *)&buf, a4);
    v25[0] = MEMORY[0x263EF8330];
    v25[1] = 1174405120;
    unint64_t v26 = ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke_16;
    unint64_t v27 = &__block_descriptor_tmp_18_15;
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v28, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    }
    else {
      std::string v28 = buf;
    }
    char v17 = (const void **)*((void *)&v34 + 1);
    if (*((void *)&v34 + 1) != (void)v35)
    {
      while (*((unsigned char *)*v17 + 8) != 18)
      {
        if (++v17 == (const void **)v35) {
          goto LABEL_16;
        }
      }
    }
    if (v17 == (const void **)v35) {
LABEL_16:
    }
      operator new();
    if (!v18) {
      __cxa_bad_cast();
    }
    v26((uint64_t)v25, (std::string *)(v18 + 16));
    if (a7)
    {
      v23[0] = MEMORY[0x263EF8330];
      v23[1] = 0x40000000;
      void v23[2] = ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke_19;
      v23[3] = &__block_descriptor_tmp_21_8;
      char v24 = a7;
      uint64_t v19 = (const void **)*((void *)&v34 + 1);
      if (*((void *)&v34 + 1) != (void)v35)
      {
        while (*((unsigned char *)*v19 + 8) != 19)
        {
          if (++v19 == (const void **)v35) {
            goto LABEL_25;
          }
        }
      }
      if (v19 == (const void **)v35) {
LABEL_25:
      }
        operator new();
      if (!v20) {
        __cxa_bad_cast();
      }
      ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke_19((uint64_t)v23, v20 + 9);
    }
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v28.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
  }
  if ((a2 - 1) >= 3) {
    int v21 = 0;
  }
  else {
    int v21 = a2;
  }
  qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::SetSupsService::Request>(&v22, v21);
}

void sub_2225068F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  if (*(char *)(v40 - 185) < 0) {
    operator delete(*(void **)(v40 - 208));
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a40);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke(uint64_t result, char *a2)
{
  if (*(unsigned char *)(result + 44)) {
    char v2 = 3;
  }
  else {
    char v2 = 4;
  }
  *a2 = v2;
  unsigned int v3 = *(_DWORD *)(result + 40);
  if (v3 < 6) {
    char v4 = v3 + 1;
  }
  else {
    char v4 = 0;
  }
  a2[1] = v4;
  return result;
}

uint64_t ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke_2(uint64_t result, unsigned char *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

void ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke_16(uint64_t a1, std::string *this)
{
  if (*(char *)(a1 + 55) < 0)
  {
    unsigned int v3 = *(std::string::value_type **)(a1 + 32);
    std::string::size_type v4 = *(void *)(a1 + 40);
  }
  else
  {
    unsigned int v3 = (std::string::value_type *)(a1 + 32);
    std::string::size_type v4 = *(unsigned __int8 *)(a1 + 55);
  }
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(this, v3, &v3[v4], v4);
}

uint64_t ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke_19(uint64_t result, unsigned char *a2)
{
  *a2 = *(unsigned char *)(result + 32);
  return result;
}

void QMISuppServicesCommandDriver::activateCallForwarding(uint64_t a1, uint64_t a2, char a3, int a4, int a5)
{
  memset(v20, 0, sizeof(v20));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v20);
  v17[0] = MEMORY[0x263EF8330];
  v17[1] = 0x40000000;
  _OWORD v17[2] = ___ZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedure_block_invoke;
  _OWORD v17[3] = &__block_descriptor_tmp_22_9;
  v17[4] = a1;
  char v19 = a3;
  int v18 = a4;
  uint64_t v10 = qmi::MutableMessageBase::getTLV<vs::tlv::SupsService>((uint64_t)v20);
  ___ZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedure_block_invoke((uint64_t)v17, v10);
  if (a5)
  {
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 0x40000000;
    _OWORD v15[2] = ___ZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedure_block_invoke_2;
    v15[3] = &__block_descriptor_tmp_23_7;
    int v16 = a5;
    uint64_t v11 = qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>((uint64_t)v20);
    ___ZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedure_block_invoke_2((uint64_t)v15, v11);
  }
  else
  {
    uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_22231A000, v12, OS_LOG_TYPE_DEFAULT, "#I Call class is not provided, not including in the message", buf, 2u);
    }
  }
  if ((a2 - 1) >= 3) {
    int v13 = 0;
  }
  else {
    int v13 = a2;
  }
  qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::SetSupsService::Request>(&v14, v13);
}

void sub_222506CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedure_block_invoke(uint64_t result, char *a2)
{
  if (*(unsigned char *)(result + 44)) {
    char v2 = 1;
  }
  else {
    char v2 = 2;
  }
  *a2 = v2;
  unsigned int v3 = *(_DWORD *)(result + 40);
  if (v3 < 6) {
    char v4 = v3 + 1;
  }
  else {
    char v4 = 0;
  }
  a2[1] = v4;
  return result;
}

uint64_t ___ZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedure_block_invoke_2(uint64_t result, unsigned char *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

void QMISuppServicesCommandDriver::fetchCallBarring(uint64_t a1, uint64_t a2, int a3, int a4)
{
  memset(v15, 0, sizeof(v15));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v15);
  if (a4)
  {
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 0x40000000;
    v13[2] = ___ZN28QMISuppServicesCommandDriver16fetchCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityj_block_invoke;
    void v13[3] = &__block_descriptor_tmp_24_9;
    int v14 = a4;
    unint64_t v8 = qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>((uint64_t)v15);
    ___ZN28QMISuppServicesCommandDriver16fetchCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityj_block_invoke((uint64_t)v13, v8);
  }
  else
  {
    uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_22231A000, v9, OS_LOG_TYPE_DEFAULT, "#I Call class is not provided, not including in the message", buf, 2u);
    }
  }
  v11[0] = MEMORY[0x263EF8330];
  v11[1] = 0x40000000;
  _DWORD v11[2] = ___ZN28QMISuppServicesCommandDriver16fetchCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityj_block_invoke_25;
  v11[3] = &__block_descriptor_tmp_26_4;
  void v11[4] = a1;
  int v12 = a3;
  uint64_t v10 = qmi::MutableMessageBase::getTLV<vs::tlv::Reason>((uint64_t)v15);
  ___ZN28QMISuppServicesCommandDriver16fetchCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityj_block_invoke_25((uint64_t)v11, v10);
  qmi::ClientRouter::get();
  operator new();
}

void sub_2225070A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver16fetchCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityj_block_invoke(uint64_t result, unsigned char *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

uint64_t ___ZN28QMISuppServicesCommandDriver16fetchCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityj_block_invoke_25(uint64_t result, char *a2)
{
  uint64_t v2 = *(int *)(result + 40);
  if (v2 > 8) {
    char v3 = 0;
  }
  else {
    char v3 = asc_222588EA7[v2];
  }
  *a2 = v3;
  return result;
}

void ___ZN28QMISuppServicesCommandDriver25handleCallBarringInfo_resEN10subscriber7SimSlotE21CTCallBarringFacilityjRKN2vs14GetCallBarring8ResponseE_block_invoke(uint64_t a1, _WORD *a2)
{
  char v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 40) + 80) + 16))(*(void *)(*(void *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
}

uint64_t ___ZN28QMISuppServicesCommandDriver25handleCallBarringInfo_resEN10subscriber7SimSlotE21CTCallBarringFacilityjRKN2vs14GetCallBarring8ResponseE_block_invoke_28(uint64_t result, unsigned char *a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a2;
  return result;
}

BOOL QMISuppServicesCommandDriver::setCallBarring(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, char a6)
{
  if (*(char *)(a5 + 23) >= 0) {
    uint64_t v8 = *(unsigned __int8 *)(a5 + 23);
  }
  else {
    uint64_t v8 = *(void *)(a5 + 8);
  }
  if (v8 == 4)
  {
    *(_OWORD *)std::string __p = 0u;
    long long v29 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v25[0] = MEMORY[0x263EF8330];
    v25[1] = 0x40000000;
    void v25[2] = ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke;
    v25[3] = &__block_descriptor_tmp_31_1;
    std::string v25[4] = a1;
    char v27 = a6;
    int v26 = a3;
    int v13 = qmi::MutableMessageBase::getTLV<vs::tlv::SupsService>((uint64_t)__p);
    ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke((uint64_t)v25, v13);
    if (a4)
    {
      v23[0] = MEMORY[0x263EF8330];
      v23[1] = 0x40000000;
      void v23[2] = ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke_2;
      v23[3] = &__block_descriptor_tmp_32_8;
      int v24 = a4;
      int v14 = qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>((uint64_t)__p);
      ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke_2((uint64_t)v23, v14);
    }
    else
    {
      int v16 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_22231A000, v16, OS_LOG_TYPE_DEFAULT, "#I Call class is not provided, not including in the message", buf, 2u);
      }
    }
    v22[0] = MEMORY[0x263EF8330];
    v22[1] = 0x40000000;
    _OWORD v22[2] = ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke_33;
    void v22[3] = &__block_descriptor_tmp_34_8;
    void v22[4] = a5;
    char v17 = (const void **)__p[1];
    if (__p[1] != (void *)v29)
    {
      while (*((unsigned char *)*v17 + 8) != 17)
      {
        if (++v17 == (const void **)v29) {
          goto LABEL_18;
        }
      }
    }
    if (v17 != (const void **)v29)
    {
      if (v18)
      {
        ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke_33((uint64_t)v22, v18 + 9);
        if ((a2 - 1) >= 3) {
          int v19 = 0;
        }
        else {
          int v19 = a2;
        }
        qmi::ClientRouter::get();
        qmi::ClientRouter::SendProxy::SendProxy<vs::SetSupsService::Request>(&v21, v19);
      }
      __cxa_bad_cast();
    }
LABEL_18:
    operator new();
  }
  uint64_t v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl(&dword_22231A000, v15, OS_LOG_TYPE_ERROR, "SetCallBarringStatus:: Password must be of length 4", buf, 2u);
  }
  return v8 == 4;
}

void sub_222507790(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke(uint64_t result, char *a2)
{
  if (*(unsigned char *)(result + 44)) {
    char v2 = 1;
  }
  else {
    char v2 = 2;
  }
  *a2 = v2;
  uint64_t v3 = *(int *)(result + 40);
  if (v3 > 8) {
    char v4 = 0;
  }
  else {
    char v4 = asc_222588EA7[v3];
  }
  a2[1] = v4;
  return result;
}

uint64_t ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke_2(uint64_t result, unsigned char *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

uint64_t ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke_33(uint64_t result, unsigned char *a2)
{
  char v2 = *(uint64_t ***)(result + 32);
  if (*((char *)v2 + 23) < 0) {
    char v2 = (uint64_t **)*v2;
  }
  *a2 = *(unsigned char *)v2;
  uint64_t v3 = *(uint64_t **)(result + 32);
  if (*((char *)v3 + 23) < 0) {
    uint64_t v3 = (uint64_t *)*v3;
  }
  a2[1] = *((unsigned char *)v3 + 1);
  char v4 = *(uint64_t **)(result + 32);
  if (*((char *)v4 + 23) < 0) {
    char v4 = (uint64_t *)*v4;
  }
  a2[2] = *((unsigned char *)v4 + 2);
  uint64_t v5 = *(uint64_t **)(result + 32);
  if (*((char *)v5 + 23) < 0) {
    uint64_t v5 = (uint64_t *)*v5;
  }
  a2[3] = *((unsigned char *)v5 + 3);
  return result;
}

BOOL QMISuppServicesCommandDriver::setCallBarringPassword(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = *(unsigned __int8 *)(a4 + 23);
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *(void *)(a4 + 8);
  }
  if (v7 == 4)
  {
    uint64_t v9 = *(unsigned __int8 *)(a5 + 23);
    if ((v9 & 0x80u) != 0) {
      uint64_t v9 = *(void *)(a5 + 8);
    }
    if (v9 == 4)
    {
      uint64_t v11 = *(unsigned __int8 *)(a6 + 23);
      if ((v11 & 0x80u) != 0) {
        uint64_t v11 = *(void *)(a6 + 8);
      }
      if (v11 == 4)
      {
        *(_OWORD *)std::string __p = 0u;
        long long v21 = 0u;
        qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
        v18[0] = MEMORY[0x263EF8330];
        v18[1] = 0x40000000;
        _OWORD v18[2] = ___ZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_SB__block_invoke;
        void v18[3] = &__block_descriptor_tmp_35_5;
        int v19 = a3;
        void v18[4] = a1;
        void v18[5] = a4;
        v18[6] = a5;
        v18[7] = a6;
        int v14 = (const void **)__p[1];
        if (__p[1] != (void *)v21)
        {
          while (*((unsigned char *)*v14 + 8) != 1)
          {
            if (++v14 == (const void **)v21) {
              goto LABEL_20;
            }
          }
        }
        if (v14 != (const void **)v21)
        {
          if (v17)
          {
            ___ZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_SB__block_invoke((uint64_t)v18, v17 + 9);
            qmi::ClientRouter::get();
            operator new();
          }
          __cxa_bad_cast();
        }
LABEL_20:
        operator new();
      }
    }
  }
  uint64_t v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
  BOOL result = os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl(&dword_22231A000, v15, OS_LOG_TYPE_ERROR, "setCallBarringPassword:: Password must be of length 4", buf, 2u);
    return 0;
  }
  return result;
}

void sub_222507D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30)
{
  if (a30) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a30);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v31);
  if (a11) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v30, a11);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a21);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_SB__block_invoke(uint64_t result, char *a2)
{
  uint64_t v2 = *(int *)(result + 64);
  if (v2 > 8) {
    char v3 = 0;
  }
  else {
    char v3 = asc_222588EA7[v2];
  }
  uint64_t v4 = 0;
  *a2 = v3;
  uint64_t v5 = a2 + 5;
  do
  {
    uint64_t v6 = *(uint64_t **)(result + 40);
    if (*((char *)v6 + 23) < 0) {
      uint64_t v6 = (uint64_t *)*v6;
    }
    v5[v4 - 4] = *((unsigned char *)v6 + v4);
    uint64_t v7 = *(uint64_t **)(result + 48);
    if (*((char *)v7 + 23) < 0) {
      uint64_t v7 = (uint64_t *)*v7;
    }
    v5[v4] = *((unsigned char *)v7 + v4);
    uint64_t v8 = *(uint64_t **)(result + 56);
    if (*((char *)v8 + 23) < 0) {
      uint64_t v8 = (uint64_t *)*v8;
    }
    v5[v4 + 4] = *((unsigned char *)v8 + v4);
    ++v4;
  }
  while (v4 != 4);
  return result;
}

void QMISuppServicesCommandDriver::fetchCallWaiting(uint64_t a1, uint64_t a2, int a3)
{
  memset(v7, 0, sizeof(v7));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v7);
  if (SuppServicesCommandDriver::supportsCallWaitingServiceClass())
  {
    v5[0] = MEMORY[0x263EF8330];
    v5[1] = 0x40000000;
    _OWORD v5[2] = ___ZN28QMISuppServicesCommandDriver16fetchCallWaitingEN10subscriber7SimSlotEj_block_invoke;
    void v5[3] = &__block_descriptor_tmp_36_8;
    int v6 = a3;
    uint64_t v4 = qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>((uint64_t)v7);
    ___ZN28QMISuppServicesCommandDriver16fetchCallWaitingEN10subscriber7SimSlotEj_block_invoke((uint64_t)v5, v4);
  }
  qmi::ClientRouter::get();
  operator new();
}

void sub_22250808C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  if (a27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a27);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v28);
  if (a11) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v27, a11);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a17);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver16fetchCallWaitingEN10subscriber7SimSlotEj_block_invoke(uint64_t result, unsigned char *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

void ___ZN28QMISuppServicesCommandDriver25handleCallWaitingResponseEN10subscriber7SimSlotERKN2vs14GetCallWaiting8ResponseEj_block_invoke(uint64_t a1, _WORD *a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 40) + 80) + 16))(*(void *)(*(void *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
}

__n128 __Block_byref_object_copy__38(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__39(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

uint64_t ___ZN28QMISuppServicesCommandDriver25handleCallWaitingResponseEN10subscriber7SimSlotERKN2vs14GetCallWaiting8ResponseEj_block_invoke_40(uint64_t result, unsigned char *a2)
{
  **(unsigned char **)(*(void *)(*(void *)(result + 32) + 8) + 40) = *a2;
  return result;
}

void QMISuppServicesCommandDriver::setCallWaiting(uint64_t a1, uint64_t a2, char a3, int a4)
{
  memset(v17, 0, sizeof(v17));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v17);
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 0x40000000;
  _OWORD v15[2] = ___ZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedure_block_invoke;
  v15[3] = &__block_descriptor_tmp_42_7;
  void v15[4] = a1;
  char v16 = a3;
  uint64_t v8 = qmi::MutableMessageBase::getTLV<vs::tlv::SupsService>((uint64_t)v17);
  ___ZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedure_block_invoke((uint64_t)v15, v8);
  if (a4)
  {
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 0x40000000;
    v13[2] = ___ZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedure_block_invoke_2;
    void v13[3] = &__block_descriptor_tmp_43_7;
    int v14 = a4;
    uint64_t v9 = qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>((uint64_t)v17);
    ___ZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedure_block_invoke_2((uint64_t)v13, v9);
  }
  else
  {
    uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_22231A000, v10, OS_LOG_TYPE_DEFAULT, "#I Not setting service class as it is unknown", buf, 2u);
    }
  }
  if ((a2 - 1) >= 3) {
    int v11 = 0;
  }
  else {
    int v11 = a2;
  }
  qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::SetSupsService::Request>(&v12, v11);
}

void sub_2225084F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedure_block_invoke(uint64_t result, char *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  if (*(unsigned char *)(result + 40)) {
    char v3 = 1;
  }
  else {
    char v3 = 2;
  }
  *a2 = v3;
  a2[1] = *(unsigned char *)(v2 + 88);
  return result;
}

uint64_t ___ZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedure_block_invoke_2(uint64_t result, unsigned char *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

void QMISuppServicesCommandDriver::fetchCLIR()
{
  memset(v0, 0, sizeof(v0));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v0);
  qmi::ClientRouter::get();
  operator new();
}

void sub_222508750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver18handleCLIRResponseEN10subscriber7SimSlotERKN2vs7GetCLIR8ResponseE_block_invoke(uint64_t result, _WORD *a2)
{
  *(_WORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a2;
  return result;
}

__n128 __Block_byref_object_copy__45_0(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__46_0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

uint64_t ___ZN28QMISuppServicesCommandDriver18handleCLIRResponseEN10subscriber7SimSlotERKN2vs7GetCLIR8ResponseE_block_invoke_47(uint64_t result, unsigned char *a2)
{
  **(unsigned char **)(*(void *)(*(void *)(result + 32) + 8) + 40) = *a2;
  *(unsigned char *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 40) + 1) = a2[1];
  return result;
}

uint64_t QMISuppServicesCommandDriver::setCLIR(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)char v3 = 0;
    _os_log_error_impl(&dword_22231A000, v1, OS_LOG_TYPE_ERROR, "setCLIR not supported", v3, 2u);
  }
  return 0;
}

void QMISuppServicesCommandDriver::fetchCLIP()
{
  memset(v0, 0, sizeof(v0));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v0);
  qmi::ClientRouter::get();
  operator new();
}

void sub_222508A84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void ___ZN28QMISuppServicesCommandDriver18handleCLIPResponseEN10subscriber7SimSlotERKN2vs7GetCLIP8ResponseE_block_invoke(uint64_t a1, _WORD *a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 40) + 80) + 16))(*(void *)(*(void *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
}

__n128 __Block_byref_object_copy__51(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__52(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

uint64_t ___ZN28QMISuppServicesCommandDriver18handleCLIPResponseEN10subscriber7SimSlotERKN2vs7GetCLIP8ResponseE_block_invoke_53(uint64_t result, unsigned char *a2)
{
  **(unsigned char **)(*(void *)(*(void *)(result + 32) + 8) + 40) = *a2;
  *(unsigned char *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 40) + 1) = a2[1];
  return result;
}

uint64_t QMISuppServicesCommandDriver::setCLIP(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)char v3 = 0;
    _os_log_error_impl(&dword_22231A000, v1, OS_LOG_TYPE_ERROR, "setCLIP not supported", v3, 2u);
  }
  return 0;
}

void QMISuppServicesCommandDriver::fetchCOLR()
{
  memset(v0, 0, sizeof(v0));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v0);
  qmi::ClientRouter::get();
  operator new();
}

void sub_222508E50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMISuppServicesCommandDriver::fetchCNAP()
{
  memset(v0, 0, sizeof(v0));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v0);
  qmi::ClientRouter::get();
  operator new();
}

void sub_222509090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver18handleCNAPResponseEN10subscriber7SimSlotERKN2vs7GetCNAP8ResponseE_block_invoke(uint64_t result, _WORD *a2)
{
  *(_WORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a2;
  return result;
}

__n128 __Block_byref_object_copy__56(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__57(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

uint64_t ___ZN28QMISuppServicesCommandDriver18handleCNAPResponseEN10subscriber7SimSlotERKN2vs7GetCNAP8ResponseE_block_invoke_58(uint64_t result, unsigned char *a2)
{
  **(unsigned char **)(*(void *)(*(void *)(result + 32) + 8) + 40) = *a2;
  *(unsigned char *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 40) + 1) = a2[1];
  return result;
}

uint64_t std::__split_buffer<CallForwardServiceParameter>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 40;
      *(void *)(a1 + 16) = v2 - 40;
      if (*(char *)(v2 - 9) < 0)
      {
        operator delete(*(void **)(v2 - 32));
        uint64_t v4 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::shared_ptr<QMISuppServicesCommandDriver>::shared_ptr[abi:ne180100]<QMISuppServicesCommandDriver,std::shared_ptr<QMISuppServicesCommandDriver> ctu::SharedSynchronizable<SuppServicesCommandDriver>::make_shared_ptr<QMISuppServicesCommandDriver>(QMISuppServicesCommandDriver*)::{lambda(QMISuppServicesCommandDriver*)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_222509294(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMISuppServicesCommandDriver> ctu::SharedSynchronizable<SuppServicesCommandDriver>::make_shared_ptr<QMISuppServicesCommandDriver>(QMISuppServicesCommandDriver*)::{lambda(QMISuppServicesCommandDriver*)#1}::operator() const(QMISuppServicesCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_2225092BC(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<QMISuppServicesCommandDriver *,std::shared_ptr<QMISuppServicesCommandDriver> ctu::SharedSynchronizable<SuppServicesCommandDriver>::make_shared_ptr<QMISuppServicesCommandDriver>(QMISuppServicesCommandDriver*)::{lambda(QMISuppServicesCommandDriver *)#1},std::allocator<QMISuppServicesCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<QMISuppServicesCommandDriver *,std::shared_ptr<QMISuppServicesCommandDriver> ctu::SharedSynchronizable<SuppServicesCommandDriver>::make_shared_ptr<QMISuppServicesCommandDriver>(QMISuppServicesCommandDriver*)::{lambda(QMISuppServicesCommandDriver *)#1},std::allocator<QMISuppServicesCommandDriver>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<QMISuppServicesCommandDriver *,std::shared_ptr<QMISuppServicesCommandDriver> ctu::SharedSynchronizable<SuppServicesCommandDriver>::make_shared_ptr<QMISuppServicesCommandDriver>(QMISuppServicesCommandDriver*)::{lambda(QMISuppServicesCommandDriver *)#1},std::allocator<QMISuppServicesCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMISuppServicesCommandDriver> ctu::SharedSynchronizable<SuppServicesCommandDriver>::make_shared_ptr<QMISuppServicesCommandDriver>(QMISuppServicesCommandDriver*)::{lambda(QMISuppServicesCommandDriver*)#1}::operator() const(QMISuppServicesCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void SimInstanceLoggable<QMISuppServicesCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::~SimInstanceLoggable()
{
}

uint64_t SimInstanceLoggable<QMISuppServicesCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::getLoggerForSlot(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<SuppServicesCommandDriver>::execute_wrapped<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0>(QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0,std::default_delete<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v1 = *a1;
  char v16 = a1;
  char v17 = v1;
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v4 = v1[2];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v3 + 72);
  *(void *)(v3 + 64) = v2;
  *(void *)(v3 + 72) = v4;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  uint64_t SimSlotRange = subscriber::makeSimSlotRange();
  uint64_t v7 = v18;
  if (v18 != v19)
  {
    while (1)
    {
      uint64_t SimSlotRange = v20(*v7);
      if (SimSlotRange) {
        break;
      }
      if (++v7 == v19)
      {
        uint64_t v7 = v19;
        break;
      }
    }
    while (v7 != v19)
    {
      if (*v7 == 1)
      {
        uint64_t v8 = "SuppServices.1";
      }
      else if (*v7 == 2)
      {
        uint64_t v8 = "SuppServices.2";
      }
      else
      {
        uint64_t v8 = 0;
      }
      uint64_t v9 = *(std::__shared_weak_count **)(v3 + 16);
      if (!v9 || (uint64_t v10 = *(void *)(v3 + 8), (v11 = std::__shared_weak_count::lock(v9)) == 0)) {
        std::__throw_bad_weak_ptr[abi:ne180100]();
      }
      int v12 = v11;
      Registry::getServerConnection((uint64_t *)&v21, *(Registry **)(v3 + 48));
      long long v30 = 0u;
      long long v31 = 0u;
      std::string::basic_string[abi:ne180100]<0>(v22, v8);
      int v13 = *(NSObject **)(v3 + 24);
      dispatch_object_t v29 = v13;
      if (v13) {
        dispatch_retain(v13);
      }
      std::string::basic_string[abi:ne180100]<0>(&__p, "supp");
      uint64_t v25 = v10;
      int v26 = v12;
      atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      long long v24 = v21;
      long long v21 = 0uLL;
      qmi::Client::createWithQueueLocal();
      if (*((void *)&v24 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v24 + 1));
      }
      if (v26) {
        std::__shared_weak_count::__release_weak(v26);
      }
      if (v28 < 0) {
        operator delete(__p);
      }
      if (v29) {
        dispatch_release(v29);
      }
      if (SBYTE7(v23) < 0) {
        operator delete(v22[0]);
      }
      v22[0] = 0;
      v22[1] = 0;
      long long v23 = v31;
      long long v31 = 0uLL;
      qmi::ClientRouter::addClient();
      qmi::Client::~Client((qmi::Client *)v22);
      qmi::ClientRouter::get();
      qmi::Client::~Client((qmi::Client *)&v30);
      if (*((void *)&v21 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v21 + 1));
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
      int v14 = v7 + 1;
      uint64_t v7 = v19;
      if (v14 != v19)
      {
        uint64_t v7 = v14;
        while (1)
        {
          uint64_t SimSlotRange = v20(*v7);
          if (SimSlotRange) {
            break;
          }
          if (++v7 == v19)
          {
            uint64_t v7 = v19;
            break;
          }
        }
      }
    }
  }
  if (capabilities::ct::supportsGemini((capabilities::ct *)SimSlotRange))
  {
    *(void *)&long long v30 = &unk_26D4D4800;
    *((void *)&v30 + 1) = v3;
    *((void *)&v31 + 1) = &v30;
    qmi::ClientRouter::setHandler();
    std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](&v30);
  }
  std::unique_ptr<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0,std::default_delete<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)&v17);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v16);
}

void sub_2225096C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100]((void *)(v35 - 144));
  std::unique_ptr<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0,std::default_delete<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](&a13);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0,std::default_delete<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(NSObject **)(v2 + 24);
    if (v3)
    {
      dispatch_group_leave(v3);
      uint64_t v4 = *(NSObject **)(v2 + 24);
      if (v4) {
        dispatch_release(v4);
      }
    }
    uint64_t v5 = *(std::__shared_weak_count **)(v2 + 16);
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    }
    MEMORY[0x223C9A950](v2, 0x20C40DC1BFBCFLL);
  }
  return a1;
}

void _ZNSt3__110__function6__funcIZZN28QMISuppServicesCommandDriver9bootstrapENS_10shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_NS_9allocatorISA_EEFvN3qmi16SubscriptionTypeEEED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZZN28QMISuppServicesCommandDriver9bootstrapENS_10shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_NS_9allocatorISA_EEFvN3qmi16SubscriptionTypeEEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D4800;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN28QMISuppServicesCommandDriver9bootstrapENS_10shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_NS_9allocatorISA_EEFvN3qmi16SubscriptionTypeEEE7__cloneEPNS0_6__baseISF_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D4800;
  a2[1] = v2;
  return result;
}

void _ZNSt3__110__function6__funcIZZN28QMISuppServicesCommandDriver9bootstrapENS_10shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_NS_9allocatorISA_EEFvN3qmi16SubscriptionTypeEEEclEOSE_(uint64_t a1, int *a2)
{
  int v2 = *a2;
  memset(v4, 0, sizeof(v4));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v4);
  *qmi::MutableMessageBase::getTLV<vs::tlv::SubscriptionType>((uint64_t)v4, 1) = v2 == 2;
  qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::BindSubscription::Request>(&v3, v2);
}

void sub_222509A2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  uint64_t v23 = a10;
  a10 = 0;
  if (v23) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v23);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t _ZNKSt3__110__function6__funcIZZN28QMISuppServicesCommandDriver9bootstrapENS_10shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_NS_9allocatorISA_EEFvN3qmi16SubscriptionTypeEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZN28QMISuppServicesCommandDriver9bootstrapENSt3__110shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZN28QMISuppServicesCommandDriver9bootstrapENS_10shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_NS_9allocatorISA_EEFvN3qmi16SubscriptionTypeEEE11target_typeEv()
{
  return &_ZTIZZN28QMISuppServicesCommandDriver9bootstrapENSt3__110shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<SuppServicesCommandDriver>::execute_wrapped<QMISuppServicesCommandDriver::start(void)::$_0>(QMISuppServicesCommandDriver::start(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMISuppServicesCommandDriver::start(void)::$_0,dispatch_queue_s *::default_delete<QMISuppServicesCommandDriver::start(void)::$_0>>)::{lambda(void *)#1}::__invoke(void *a1)
{
  int v3 = a1;
  uint64_t v1 = *a1;
  qmi::ClientRouter::start();
  MEMORY[0x223C9A950](v1, 0x60C4044C4A2DFLL);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v3);
}

void sub_222509B28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MEMORY[0x223C9A950](v2, 0x60C4044C4A2DFLL);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver21bindSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 4))
  {
    int v3 = *(uint64_t **)(a1 + 32);
    uint64_t v4 = *v3;
    unsigned int v5 = *((_DWORD *)v3 + 2);
    if (v5 - 1 >= 3) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = v5;
    }
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 80) + 16))(*(void *)(v4 + 80), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = qmi::asString();
      int v9 = *(_DWORD *)(a2 + 4);
      int v10 = 136315394;
      uint64_t v11 = v8;
      __int16 v12 = 1024;
      int v13 = v9;
      _os_log_error_impl(&dword_22231A000, v7, OS_LOG_TYPE_ERROR, "Error binding subscription: %s (0x%x)", (uint8_t *)&v10, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMISuppServicesCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D48B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMISuppServicesCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D48B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_1(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  cast_message_type<vs::BindSubscription::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_222509D4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::AutoAnswer>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::AutoAnswer>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<vs::tlv::AutoAnswer>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::AutoAnswer>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver17setAutoAnswerModeEN10subscriber7SimSlotEbE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 4))
  {
    char v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 32) + 80) + 16))(*(void *)(**(void **)(a1 + 32) + 80), *(unsigned int *)(*(void *)(a1 + 32) + 8));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v4 = *(_DWORD *)(a2 + 4);
      v5[0] = 67109378;
      v5[1] = v4;
      __int16 v6 = 2080;
      uint64_t v7 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "setAutoAnswerMode::Response returned error 0x%x (%s)", (uint8_t *)v5, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c106_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver17setAutoAnswerModeEN10subscriber7SimSlotEbE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c106_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver17setAutoAnswerModeEN10subscriber7SimSlotEbE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setAutoAnswerMode(subscriber::SimSlot,BOOL)::$_0,std::allocator<QMISuppServicesCommandDriver::setAutoAnswerMode(subscriber::SimSlot,BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4980;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setAutoAnswerMode(subscriber::SimSlot,BOOL)::$_0,std::allocator<QMISuppServicesCommandDriver::setAutoAnswerMode(subscriber::SimSlot,BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4980;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

char *qmi::MutableMessageBase::getTLV<vs::tlv::Reason>(uint64_t a1)
{
  uint64_t v1 = *(const void ***)(a1 + 8);
  uint64_t v2 = *(const void ***)(a1 + 16);
  if (v1 != v2)
  {
    while (*((unsigned char *)*v1 + 8) != 1)
    {
      if (++v1 == v2) {
        goto LABEL_8;
      }
    }
  }
  if (v1 == v2) {
LABEL_8:
  }
    operator new();
  if (!v3) {
    __cxa_bad_cast();
  }
  return v3 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::Reason>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::Reason>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<vs::tlv::Reason>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::Reason>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>(uint64_t a1)
{
  uint64_t v1 = *(const void ***)(a1 + 8);
  uint64_t v2 = *(const void ***)(a1 + 16);
  if (v1 != v2)
  {
    while (*((unsigned char *)*v1 + 8) != 16)
    {
      if (++v1 == v2) {
        goto LABEL_8;
      }
    }
  }
  if (v1 == v2) {
LABEL_8:
  }
    operator new();
  if (!v3) {
    __cxa_bad_cast();
  }
  return v3 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::ServiceClass>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::ServiceClass>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<vs::tlv::ServiceClass>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::ServiceClass>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver19fetchCallForwardingEN10subscriber7SimSlotE22CTCallForwardingReasonjE3__0EEOS1_OT__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  uint64_t v4 = *((unsigned int *)v2 + 2);
  uint64_t v5 = a2[1];
  v14[0] = *a2;
  v14[1] = v5;
  uint64_t v6 = a2[2];
  v14[2] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v14);
  uint64_t v7 = *((unsigned int *)v2 + 3);
  uint64_t v8 = *((unsigned int *)v2 + 4);
  if (!HIDWORD(v14[0]))
  {
    uint64_t v19 = 0;
    uint64_t v20 = (uint64_t)&v19;
    uint64_t v21 = 0x3802000000;
    int v22 = __Block_byref_object_copy__10;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = __Block_byref_object_dispose__10;
    operator new();
  }
  uint64_t v15 = 0;
  char v16 = &v15;
  uint64_t v17 = 0x2000000000;
  LOWORD(v18) = 0;
  uint64_t v19 = MEMORY[0x263EF8330];
  uint64_t v20 = 0x40000000;
  uint64_t v21 = (uint64_t)___ZN28QMISuppServicesCommandDriver28handleCallForwardingResponseEN10subscriber7SimSlotERKN2vs14CallForwarding8ResponseE22CTCallForwardingReasonj_block_invoke;
  int v22 = (__n128 (*)(uint64_t, uint64_t))&unk_264611A10;
  LODWORD(v25) = v4;
  uint64_t v23 = (void (*)(uint64_t))&v15;
  uint64_t v24 = v3;
  *(void *)std::string buf = &v19;
  qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v14, 17, (uint64_t)buf);
  int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 80) + 16))(*(void *)(v3 + 80), v4);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    int v12 = HIDWORD(v14[0]);
    uint64_t v13 = qmi::asString();
    *(_DWORD *)std::string buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = v12;
    __int16 v27 = 2080;
    uint64_t v28 = v13;
    _os_log_error_impl(&dword_22231A000, v9, OS_LOG_TYPE_ERROR, "CallForwarding::Response returned error 0x%x (%s)", buf, 0x12u);
  }
  uint64_t v10 = *(void *)(v3 + 64);
  uint64_t v11 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v16 + 12));
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v10 + 24))(v10, v4, v7, v8, v11, 0);
  _Block_object_dispose(&v15, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v14);
}

void sub_22250A900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  *(void *)(v25 - 104) = v24;
  std::vector<vs::tlv::ServiceParam>::__destroy_vector::operator()[abi:ne180100]((void ***)(v25 - 104));
  _Block_object_dispose(&a18, 8);
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a24);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c132_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver19fetchCallForwardingEN10subscriber7SimSlotE22CTCallForwardingReasonjE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c132_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver19fetchCallForwardingEN10subscriber7SimSlotE22CTCallForwardingReasonjE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCallForwarding(subscriber::SimSlot,CTCallForwardingReason,unsigned int)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCallForwarding(subscriber::SimSlot,CTCallForwardingReason,unsigned int)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4AA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCallForwarding(subscriber::SimSlot,CTCallForwardingReason,unsigned int)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCallForwarding(subscriber::SimSlot,CTCallForwardingReason,unsigned int)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4AA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<std::vector<CallForwardServiceParameter> *,std::shared_ptr<std::vector<CallForwardServiceParameter>>::__shared_ptr_default_delete<std::vector<CallForwardServiceParameter>,std::vector<CallForwardServiceParameter>>,std::allocator<std::vector<CallForwardServiceParameter>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::__shared_ptr_pointer<std::vector<CallForwardServiceParameter> *,std::shared_ptr<std::vector<CallForwardServiceParameter>>::__shared_ptr_default_delete<std::vector<CallForwardServiceParameter>,std::vector<CallForwardServiceParameter>>,std::allocator<std::vector<CallForwardServiceParameter>>>::__on_zero_shared(uint64_t result)
{
  if (*(void *)(result + 24))
  {
    uint64_t v1 = *(void ***)(result + 24);
    std::vector<vs::tlv::ServiceParam>::__destroy_vector::operator()[abi:ne180100](&v1);
    JUMPOUT(0x223C9A950);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<std::vector<CallForwardServiceParameter> *,std::shared_ptr<std::vector<CallForwardServiceParameter>>::__shared_ptr_default_delete<std::vector<CallForwardServiceParameter>,std::vector<CallForwardServiceParameter>>,std::allocator<std::vector<CallForwardServiceParameter>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void ***std::unique_ptr<std::vector<CallForwardServiceParameter>>::reset[abi:ne180100](void ***result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = v1;
    std::vector<vs::tlv::ServiceParam>::__destroy_vector::operator()[abi:ne180100](&v2);
    JUMPOUT(0x223C9A950);
  }
  return result;
}

char *qmi::MutableMessageBase::getTLV<vs::tlv::SupsService>(uint64_t a1)
{
  uint64_t v1 = *(const void ***)(a1 + 8);
  uint64_t v2 = *(const void ***)(a1 + 16);
  if (v1 != v2)
  {
    while (*((unsigned char *)*v1 + 8) != 1)
    {
      if (++v1 == v2) {
        goto LABEL_8;
      }
    }
  }
  if (v1 == v2) {
LABEL_8:
  }
    operator new();
  if (!v3) {
    __cxa_bad_cast();
  }
  return v3 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::SupsService>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::SupsService>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<vs::tlv::SupsService>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::ProfileIdentifer>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::SupsService>::clone()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallFwdingNumber>::~TlvWrapper(uint64_t a1)
{
  *(void *)a1 = &unk_26D4D4BD0;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallFwdingNumber>::~TlvWrapper(uint64_t a1)
{
  *(void *)a1 = &unk_26D4D4BD0;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  JUMPOUT(0x223C9A950);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallFwdingNumber>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Dnn>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallFwdingNumber>::write(uint64_t a1, void **a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (char *)*a2;
  uint64_t v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  __n128 result = tlv::writeV<wds::tlv::Dnn>(a2, (void *)(a1 + 16));
  uint64_t v7 = (char *)*a2 - v5;
  char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallFwdingNumber>::clone()
{
}

void sub_22250AFDC(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::NoReplyTimer>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::NoReplyTimer>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<vs::tlv::NoReplyTimer>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::NoReplyTimer>::clone()
{
}

void qmi::ClientRouter::SendProxy::SendProxy<vs::SetSupsService::Request>(_DWORD *a1, int a2)
{
  *a1 = a2;
  operator new();
}

void sub_22250B14C(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x10F0C401BA14CC5);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedureE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  if (*((_DWORD *)a2 + 1))
  {
    uint64_t v17 = 0;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x2000000000;
    __int16 v20 = 0;
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 0x40000000;
    _OWORD v15[2] = ___ZZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke;
    v15[3] = &unk_264611E28;
    void v15[5] = v3;
    int v16 = *((_DWORD *)v2 + 2);
    void v15[4] = &v17;
    *(void *)std::string buf = v15;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>(a2, 16, (uint64_t)buf);
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 80) + 16))(*(void *)(v3 + 80), *((unsigned int *)v2 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v13 = *((_DWORD *)a2 + 1);
      uint64_t v14 = qmi::asString();
      *(_DWORD *)std::string buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v13;
      __int16 v22 = 2080;
      uint64_t v23 = v14;
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "SetSupsService::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    uint64_t v6 = *(void *)(v3 + 64);
    uint64_t v7 = *((unsigned int *)v2 + 2);
    uint64_t v8 = *((unsigned int *)v2 + 3);
    uint64_t v9 = *((unsigned int *)v2 + 4);
    uint64_t v10 = *((unsigned int *)v2 + 6);
    uint64_t v11 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v18 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v6 + 40))(v6, v7, v8, v9, v10, v11, 0);
    _Block_object_dispose(&v17, 8);
  }
  else
  {
    int v12 = *(void (**)(void))(**(void **)(v3 + 64) + 32);
    v12();
  }
}

void sub_22250B3D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c164_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedureE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c164_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedureE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallForwarding(subscriber::SimSlot,BOOL,CSIPhoneNumber const&,CTCallForwardingReason,unsigned int,unsigned char,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallForwarding(subscriber::SimSlot,BOOL,CSIPhoneNumber const&,CTCallForwardingReason,unsigned int,unsigned char,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4C88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallForwarding(subscriber::SimSlot,BOOL,CSIPhoneNumber const&,CTCallForwardingReason,unsigned int,unsigned char,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallForwarding(subscriber::SimSlot,BOOL,CSIPhoneNumber const&,CTCallForwardingReason,unsigned int,unsigned char,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4C88;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs14SetSupsService8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_22250B564(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke(uint64_t a1, _WORD *a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 40) + 80) + 16))(*(void *)(*(void *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedureE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  if (*((_DWORD *)a2 + 1))
  {
    uint64_t v17 = 0;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x2000000000;
    __int16 v20 = 0;
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 0x40000000;
    _OWORD v15[2] = ___ZZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke;
    v15[3] = &unk_264611E50;
    void v15[5] = v3;
    int v16 = *((_DWORD *)v2 + 2);
    void v15[4] = &v17;
    *(void *)std::string buf = v15;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>(a2, 16, (uint64_t)buf);
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 80) + 16))(*(void *)(v3 + 80), *((unsigned int *)v2 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v13 = *((_DWORD *)a2 + 1);
      uint64_t v14 = qmi::asString();
      *(_DWORD *)std::string buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v13;
      __int16 v22 = 2080;
      uint64_t v23 = v14;
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "SetSupsService::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    uint64_t v6 = *(void *)(v3 + 64);
    uint64_t v7 = *((unsigned int *)v2 + 2);
    uint64_t v8 = *((unsigned int *)v2 + 3);
    uint64_t v9 = *((unsigned int *)v2 + 4);
    uint64_t v10 = *((unsigned int *)v2 + 6);
    uint64_t v11 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v18 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v6 + 40))(v6, v7, v8, v9, v10, v11, 0);
    _Block_object_dispose(&v17, 8);
  }
  else
  {
    int v12 = *(void (**)(void))(**(void **)(v3 + 64) + 32);
    v12();
  }
}

void sub_22250B8B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c150_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedureE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c150_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedureE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::activateCallForwarding(subscriber::SimSlot,BOOL,CTCallForwardingReason,unsigned int,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::activateCallForwarding(subscriber::SimSlot,BOOL,CTCallForwardingReason,unsigned int,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4D08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::activateCallForwarding(subscriber::SimSlot,BOOL,CTCallForwardingReason,unsigned int,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::activateCallForwarding(subscriber::SimSlot,BOOL,CTCallForwardingReason,unsigned int,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4D08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke(uint64_t a1, _WORD *a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 40) + 80) + 16))(*(void *)(*(void *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver16fetchCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjE3__0EEOS1_OT__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  uint64_t v5 = *((unsigned int *)v2 + 2);
  uint64_t v4 = *((unsigned int *)v2 + 3);
  uint64_t v6 = *((unsigned int *)v2 + 4);
  uint64_t v7 = a2[1];
  v14[0] = *a2;
  v14[1] = v7;
  uint64_t v8 = a2[2];
  v14[2] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v14);
  if (HIDWORD(v14[0]))
  {
    uint64_t v22 = 0;
    uint64_t v23 = &v22;
    uint64_t v24 = 0x2000000000;
    __int16 v25 = 0;
    uint64_t v15 = MEMORY[0x263EF8330];
    uint64_t v16 = 0x40000000;
    uint64_t v17 = ___ZN28QMISuppServicesCommandDriver25handleCallBarringInfo_resEN10subscriber7SimSlotE21CTCallBarringFacilityjRKN2vs14GetCallBarring8ResponseE_block_invoke;
    uint64_t v18 = &unk_264611B40;
    int v21 = v5;
    uint64_t v19 = &v22;
    uint64_t v20 = v3;
    *(void *)std::string buf = &v15;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v14, 17, (uint64_t)buf);
    uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 80) + 16))(*(void *)(v3 + 80), v5);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v12 = HIDWORD(v14[0]);
      uint64_t v13 = qmi::asString();
      *(_DWORD *)std::string buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v12;
      __int16 v27 = 2080;
      uint64_t v28 = v13;
      _os_log_error_impl(&dword_22231A000, v9, OS_LOG_TYPE_ERROR, "fetchCallBarring::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    uint64_t v10 = *(void *)(v3 + 64);
    uint64_t v11 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v23 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v10 + 56))(v10, v5, v4, v6, v11, 0);
  }
  else
  {
    uint64_t v22 = 0;
    uint64_t v23 = &v22;
    uint64_t v24 = 0x2000000000;
    LOBYTE(v25) = 0;
    uint64_t v15 = MEMORY[0x263EF8330];
    uint64_t v16 = 0x40000000;
    uint64_t v17 = ___ZN28QMISuppServicesCommandDriver25handleCallBarringInfo_resEN10subscriber7SimSlotE21CTCallBarringFacilityjRKN2vs14GetCallBarring8ResponseE_block_invoke_28;
    uint64_t v18 = &unk_264611B68;
    uint64_t v19 = &v22;
    *(void *)std::string buf = &v15;
    qmi::MessageBase::applyTlv<vs::tlv::ServiceClass,void({block_pointer})(vs::tlv::ServiceClass const&)>((qmi::MessageBase *)v14, (uint64_t)buf);
    (*(void (**)(void, uint64_t, uint64_t, uint64_t, void))(**(void **)(v3 + 64) + 48))(*(void *)(v3 + 64), v5, v4, v6, *((unsigned __int8 *)v23 + 24));
  }
  _Block_object_dispose(&v22, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v14);
}

void sub_22250BCF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

uint64_t __copy_helper_block_e8_32c128_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver16fetchCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c128_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver16fetchCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4D88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4D88;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t qmi::MessageBase::applyTlv<vs::tlv::ServiceClass,void({block_pointer})(vs::tlv::ServiceClass const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    uint64_t v6 = result;
    int v7 = v5;
    uint64_t v10 = result;
    tlv::parseV<vs::tlv::ServiceClass>((unint64_t *)&v10, v5);
    if (v10)
    {
      return (*(uint64_t (**)(void))(*(void *)a2 + 16))();
    }
    else
    {
      uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v9 = *(unsigned __int16 *)a1;
      return v8(v9, 16, v6, v7);
    }
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPasswd>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPasswd>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPasswd>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 9));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPasswd>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEEb12MmiProcedureE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  if (*((_DWORD *)a2 + 1))
  {
    uint64_t v17 = 0;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x2000000000;
    __int16 v20 = 0;
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 0x40000000;
    _OWORD v15[2] = ___ZZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke;
    v15[3] = &unk_264611E78;
    void v15[5] = v3;
    int v16 = *((_DWORD *)v2 + 2);
    void v15[4] = &v17;
    *(void *)std::string buf = v15;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>(a2, 16, (uint64_t)buf);
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 80) + 16))(*(void *)(v3 + 80), *((unsigned int *)v2 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v13 = *((_DWORD *)a2 + 1);
      uint64_t v14 = qmi::asString();
      *(_DWORD *)std::string buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v13;
      __int16 v22 = 2080;
      uint64_t v23 = v14;
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "SetSupsService::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    uint64_t v6 = *(void *)(v3 + 64);
    uint64_t v7 = *((unsigned int *)v2 + 2);
    uint64_t v8 = *((unsigned int *)v2 + 3);
    uint64_t v9 = *((unsigned int *)v2 + 4);
    uint64_t v10 = *((unsigned int *)v2 + 6);
    uint64_t v11 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v18 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v6 + 72))(v6, v7, v8, v9, v10, v11, 0);
    _Block_object_dispose(&v17, 8);
  }
  else
  {
    int v12 = *(void (**)(void))(**(void **)(v3 + 64) + 64);
    v12();
  }
}

void sub_22250C1D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c201_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEb12MmiProcedureE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c201_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEb12MmiProcedureE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int,std::string const&,BOOL,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int,std::string const&,BOOL,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4E58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int,std::string const&,BOOL,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int,std::string const&,BOOL,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4E58;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke(uint64_t a1, _WORD *a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 40) + 80) + 16))(*(void *)(*(void *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPassword>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPassword>::getSize()
{
  return tlv::size<vs::tlv::CallBarringPassword>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPassword>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = *a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<vs::tlv::CallBarringPassword>(a2, a1 + 9);
  uint64_t v7 = *a2 - v5;
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPassword>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEESF_SF_E3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  if (*((_DWORD *)a2 + 1))
  {
    uint64_t v15 = 0;
    int v16 = &v15;
    uint64_t v17 = 0x2000000000;
    __int16 v18 = 0;
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 0x40000000;
    v13[2] = ___ZZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_SB_ENK3__0clERKN2vs22SetCallBarringPassword8ResponseE_block_invoke;
    void v13[3] = &unk_264611EC8;
    void v13[5] = v3;
    int v14 = *((_DWORD *)v2 + 2);
    void v13[4] = &v15;
    *(void *)std::string buf = v13;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>(a2, 16, (uint64_t)buf);
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 80) + 16))(*(void *)(v3 + 80), *((unsigned int *)v2 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v11 = *((_DWORD *)a2 + 1);
      uint64_t v12 = qmi::asString();
      *(_DWORD *)std::string buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v11;
      __int16 v20 = 2080;
      uint64_t v21 = v12;
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "setCallBarringPassword::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    uint64_t v6 = *(void *)(v3 + 64);
    uint64_t v7 = *((unsigned int *)v2 + 2);
    uint64_t v8 = *((unsigned int *)v2 + 3);
    uint64_t v9 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v16 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v6 + 88))(v6, v7, v8, v9);
    _Block_object_dispose(&v15, 8);
  }
  else
  {
    uint64_t v10 = *(void (**)(void))(**(void **)(v3 + 64) + 80);
    v10();
  }
}

void sub_22250C66C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c199_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESC_SC_E3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c199_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESC_SC_E3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallBarringPassword(subscriber::SimSlot,CTCallBarringFacility,std::string const&,std::string const&,std::string const&)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallBarringPassword(subscriber::SimSlot,CTCallBarringFacility,std::string const&,std::string const&,std::string const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4F28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallBarringPassword(subscriber::SimSlot,CTCallBarringFacility,std::string const&,std::string const&,std::string const&)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallBarringPassword(subscriber::SimSlot,CTCallBarringFacility,std::string const&,std::string const&,std::string const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4F28;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs22SetCallBarringPassword8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_22250C7FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_SB_ENK3__0clERKN2vs22SetCallBarringPassword8ResponseE_block_invoke(uint64_t a1, _WORD *a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 40) + 80) + 16))(*(void *)(*(void *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver16fetchCallWaitingEN10subscriber7SimSlotEjE3__0EEOS1_OT__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  uint64_t v4 = *((unsigned int *)v2 + 2);
  uint64_t v5 = a2[1];
  v13[0] = *a2;
  v13[1] = v5;
  uint64_t v6 = a2[2];
  v13[2] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v13);
  uint64_t v7 = *((unsigned int *)v2 + 3);
  if (!HIDWORD(v13[0]))
  {
    uint64_t v18 = 0;
    uint64_t v19 = (uint64_t)&v18;
    uint64_t v20 = 0x3802000000;
    uint64_t v21 = __Block_byref_object_copy__38;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v22 = __Block_byref_object_dispose__39;
    operator new();
  }
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2000000000;
  LOWORD(v17) = 0;
  uint64_t v18 = MEMORY[0x263EF8330];
  uint64_t v19 = 0x40000000;
  uint64_t v20 = (uint64_t)___ZN28QMISuppServicesCommandDriver25handleCallWaitingResponseEN10subscriber7SimSlotERKN2vs14GetCallWaiting8ResponseEj_block_invoke;
  uint64_t v21 = (__n128 (*)(uint64_t, uint64_t))&unk_264611C30;
  LODWORD(v24) = v4;
  uint64_t v22 = (void (*)(uint64_t))&v14;
  uint64_t v23 = v3;
  *(void *)std::string buf = &v18;
  qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v13, 17, (uint64_t)buf);
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 80) + 16))(*(void *)(v3 + 80), v4);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    int v11 = HIDWORD(v13[0]);
    uint64_t v12 = qmi::asString();
    *(_DWORD *)std::string buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = v11;
    v26[0] = 2080;
    *(void *)&v26[1] = v12;
    _os_log_error_impl(&dword_22231A000, v8, OS_LOG_TYPE_ERROR, "GetCallWaiting::Response returned error 0x%x (%s)", buf, 0x12u);
  }
  uint64_t v9 = *(void *)(v3 + 64);
  uint64_t v10 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v15 + 12));
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v9 + 104))(v9, v4, v7, v10, 0);
  _Block_object_dispose(&v14, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v13);
}

void sub_22250CC78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  int v26 = *(std::__shared_weak_count **)(v24 - 72);
  if (v26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v26);
  }
  _Block_object_dispose(&a18, 8);
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a24);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c105_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver16fetchCallWaitingEN10subscriber7SimSlotEjE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c105_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver16fetchCallWaitingEN10subscriber7SimSlotEjE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCallWaiting(subscriber::SimSlot,unsigned int)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCallWaiting(subscriber::SimSlot,unsigned int)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4FA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCallWaiting(subscriber::SimSlot,unsigned int)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCallWaiting(subscriber::SimSlot,unsigned int)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D4FA8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<CallWaitingSettingsModel *,std::shared_ptr<CallWaitingSettingsModel>::__shared_ptr_default_delete<CallWaitingSettingsModel,CallWaitingSettingsModel>,std::allocator<CallWaitingSettingsModel>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::__shared_ptr_pointer<CallWaitingSettingsModel *,std::shared_ptr<CallWaitingSettingsModel>::__shared_ptr_default_delete<CallWaitingSettingsModel,CallWaitingSettingsModel>,std::allocator<CallWaitingSettingsModel>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x223C9A950);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<CallWaitingSettingsModel *,std::shared_ptr<CallWaitingSettingsModel>::__shared_ptr_default_delete<CallWaitingSettingsModel,CallWaitingSettingsModel>,std::allocator<CallWaitingSettingsModel>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedureE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  if (*((_DWORD *)a2 + 1))
  {
    uint64_t v16 = 0;
    uint64_t v17 = &v16;
    uint64_t v18 = 0x2000000000;
    __int16 v19 = 0;
    v14[0] = MEMORY[0x263EF8330];
    v14[1] = 0x40000000;
    v14[2] = ___ZZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke;
    void v14[3] = &unk_264611EF0;
    void v14[5] = v3;
    int v15 = *((_DWORD *)v2 + 2);
    v14[4] = &v16;
    *(void *)std::string buf = v14;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>(a2, 16, (uint64_t)buf);
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 80) + 16))(*(void *)(v3 + 80), *((unsigned int *)v2 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v12 = *((_DWORD *)a2 + 1);
      uint64_t v13 = qmi::asString();
      *(_DWORD *)std::string buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v12;
      __int16 v21 = 2080;
      uint64_t v22 = v13;
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "SetSupsService::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    uint64_t v6 = *(void *)(v3 + 64);
    uint64_t v7 = *((unsigned int *)v2 + 2);
    uint64_t v8 = *((unsigned int *)v2 + 3);
    uint64_t v9 = *((unsigned int *)v2 + 4);
    uint64_t v10 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v17 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v6 + 120))(v6, v7, v8, v9, v10, 0);
    _Block_object_dispose(&v16, 8);
  }
  else
  {
    int v11 = *(void (**)(void))(**(void **)(v3 + 64) + 112);
    v11();
  }
}

void sub_22250D0A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c118_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedureE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c118_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedureE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallWaiting(subscriber::SimSlot,BOOL,unsigned int,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallWaiting(subscriber::SimSlot,BOOL,unsigned int,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D50A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallWaiting(subscriber::SimSlot,BOOL,unsigned int,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallWaiting(subscriber::SimSlot,BOOL,unsigned int,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D50A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke(uint64_t a1, _WORD *a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 40) + 80) + 16))(*(void *)(*(void *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver9fetchCLIREN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  uint64_t v4 = *((unsigned int *)v2 + 2);
  uint64_t v5 = a2[1];
  v19[0] = *a2;
  v19[1] = v5;
  uint64_t v6 = a2[2];
  void v19[2] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v19);
  if (!HIDWORD(v19[0]))
  {
    *(void *)std::string buf = 0;
    *(void *)&long long v27 = buf;
    *((void *)&v27 + 1) = 0x3802000000;
    uint64_t v28 = __Block_byref_object_copy__45_0;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    uint64_t v29 = __Block_byref_object_dispose__46_0;
    operator new();
  }
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 80) + 16))(*(void *)(v3 + 80), v4);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    int v17 = HIDWORD(v19[0]);
    uint64_t v18 = qmi::asString();
    *(_DWORD *)std::string buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = v17;
    LOWORD(v27) = 2080;
    *(void *)((char *)&v27 + 2) = v18;
    _os_log_error_impl(&dword_22231A000, v7, OS_LOG_TYPE_ERROR, "GetCLIR::Response returned error 0x%x (%s)", buf, 0x12u);
  }
  uint64_t v20 = 0;
  __int16 v21 = &v20;
  uint64_t v22 = 0x2000000000;
  LOWORD(v23) = 0;
  *(void *)std::string buf = MEMORY[0x263EF8330];
  *(void *)&long long v27 = 0x40000000;
  *((void *)&v27 + 1) = ___ZN28QMISuppServicesCommandDriver18handleCLIRResponseEN10subscriber7SimSlotERKN2vs7GetCLIR8ResponseE_block_invoke;
  uint64_t v28 = (__n128 (*)(uint64_t, uint64_t))&unk_264611CC0;
  uint64_t v29 = (void (*)(uint64_t))&v20;
  *(void *)uint64_t v24 = buf;
  int v9 = qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v19, 17, (uint64_t)v24);
  uint64_t v10 = *(void *)(v3 + 80);
  int v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10 + 16);
  if (v9)
  {
    int v12 = *(NSObject **)v11(v10, v4, v8);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v24 = 0;
      _os_log_error_impl(&dword_22231A000, v12, OS_LOG_TYPE_ERROR, "Failure cause is present in the response, sending event", v24, 2u);
    }
    uint64_t v13 = *(void *)(v3 + 64);
    *(void *)uint64_t v24 = 0;
    __int16 v25 = 0;
    (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v13 + 136))(v13, v4, v24);
    if (v25) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v25);
    }
  }
  else
  {
    uint64_t v14 = *(NSObject **)v11(v10, v4, v8);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v24 = 0;
      _os_log_error_impl(&dword_22231A000, v14, OS_LOG_TYPE_ERROR, "Failure cause is not present in the response, sending CLIR fetch error", v24, 2u);
    }
    uint64_t v15 = *(void *)(v3 + 64);
    uint64_t v16 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v21 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v15 + 144))(v15, v4, v16, 0);
  }
  _Block_object_dispose(&v20, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v19);
}

void sub_22250D698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

uint64_t __copy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCLIREN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCLIREN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCLIR(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCLIR(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5120;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCLIR(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCLIR(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5120;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<CLIRSettingsModel *,std::shared_ptr<CLIRSettingsModel>::__shared_ptr_default_delete<CLIRSettingsModel,CLIRSettingsModel>,std::allocator<CLIRSettingsModel>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::__shared_ptr_pointer<CLIRSettingsModel *,std::shared_ptr<CLIRSettingsModel>::__shared_ptr_default_delete<CLIRSettingsModel,CLIRSettingsModel>,std::allocator<CLIRSettingsModel>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x223C9A950);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<CLIRSettingsModel *,std::shared_ptr<CLIRSettingsModel>::__shared_ptr_default_delete<CLIRSettingsModel,CLIRSettingsModel>,std::allocator<CLIRSettingsModel>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t qmi::MessageBase::applyTlv<vs::tlv::SuppServiceStatus,void({block_pointer})(vs::tlv::SuppServiceStatus const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    uint64_t v6 = result;
    int v7 = v5;
    uint64_t v10 = result;
    tlv::parseV<vs::tlv::SuppServiceStatus>((unint64_t *)&v10, v5);
    if (v10)
    {
      return (*(uint64_t (**)(void))(*(void *)a2 + 16))();
    }
    else
    {
      uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v9 = *(unsigned __int16 *)a1;
      return v8(v9, 16, v6, v7);
    }
  }
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver9fetchCLIPEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  uint64_t v4 = *((unsigned int *)v2 + 2);
  uint64_t v5 = a2[1];
  v12[0] = *a2;
  v12[1] = v5;
  uint64_t v6 = a2[2];
  void v12[2] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v12);
  if (!HIDWORD(v12[0]))
  {
    uint64_t v17 = 0;
    uint64_t v18 = (uint64_t)&v17;
    uint64_t v19 = 0x3802000000;
    uint64_t v20 = __Block_byref_object_copy__51;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    __int16 v21 = __Block_byref_object_dispose__52;
    operator new();
  }
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2000000000;
  LOWORD(v16) = 0;
  uint64_t v17 = MEMORY[0x263EF8330];
  uint64_t v18 = 0x40000000;
  uint64_t v19 = (uint64_t)___ZN28QMISuppServicesCommandDriver18handleCLIPResponseEN10subscriber7SimSlotERKN2vs7GetCLIP8ResponseE_block_invoke;
  uint64_t v20 = (__n128 (*)(uint64_t, uint64_t))&unk_264611D10;
  LODWORD(v23) = v4;
  __int16 v21 = (void (*)(uint64_t))&v13;
  uint64_t v22 = v3;
  *(void *)std::string buf = &v17;
  qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v12, 17, (uint64_t)buf);
  int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 80) + 16))(*(void *)(v3 + 80), v4);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    int v10 = HIDWORD(v12[0]);
    uint64_t v11 = qmi::asString();
    *(_DWORD *)std::string buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = v10;
    v25[0] = 2080;
    *(void *)&v25[1] = v11;
    _os_log_error_impl(&dword_22231A000, v7, OS_LOG_TYPE_ERROR, "GetCLIP::Response returned error 0x%x (%s)", buf, 0x12u);
  }
  uint64_t v8 = *(void *)(v3 + 64);
  uint64_t v9 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v14 + 12));
  (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v8 + 176))(v8, v4, v9, 0);
  _Block_object_dispose(&v13, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v12);
}

void sub_22250DCB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  uint64_t v26 = *(std::__shared_weak_count **)(v24 - 56);
  if (v26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v26);
  }
  _Block_object_dispose(&a18, 8);
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a24);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCLIPEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCLIPEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCLIP(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCLIP(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5218;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCLIP(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCLIP(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5218;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<CLIPSettingsModel *,std::shared_ptr<CLIPSettingsModel>::__shared_ptr_default_delete<CLIPSettingsModel,CLIPSettingsModel>,std::allocator<CLIPSettingsModel>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::__shared_ptr_pointer<CLIPSettingsModel *,std::shared_ptr<CLIPSettingsModel>::__shared_ptr_default_delete<CLIPSettingsModel,CLIPSettingsModel>,std::allocator<CLIPSettingsModel>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x223C9A950);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<CLIPSettingsModel *,std::shared_ptr<CLIPSettingsModel>::__shared_ptr_default_delete<CLIPSettingsModel,CLIPSettingsModel>,std::allocator<CLIPSettingsModel>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver9fetchCOLREN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  uint64_t v4 = *((unsigned int *)v2 + 2);
  uint64_t v5 = a2[1];
  v19[0] = *a2;
  v19[1] = v5;
  uint64_t v6 = a2[2];
  void v19[2] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v19);
  if (!HIDWORD(v19[0]))
  {
    *(void *)uint64_t v26 = 0;
    *(void *)&long long v27 = v26;
    *((void *)&v27 + 1) = 0x3802000000;
    uint64_t v28 = __Block_byref_object_copy__127;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    uint64_t v29 = __Block_byref_object_dispose__128;
    operator new();
  }
  int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 80) + 16))(*(void *)(v3 + 80), v4);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    int v17 = HIDWORD(v19[0]);
    uint64_t v18 = qmi::asString();
    *(_DWORD *)uint64_t v26 = 67109378;
    *(_DWORD *)&void v26[4] = v17;
    LOWORD(v27) = 2080;
    *(void *)((char *)&v27 + 2) = v18;
    _os_log_error_impl(&dword_22231A000, v7, OS_LOG_TYPE_ERROR, "GetCOLR::Response returned error 0x%x (%s)", v26, 0x12u);
  }
  uint64_t v20 = 0;
  __int16 v21 = &v20;
  uint64_t v22 = 0x2000000000;
  LOWORD(v23) = 0;
  *(void *)uint64_t v26 = MEMORY[0x263EF8330];
  *(void *)&long long v27 = 0x40000000;
  *((void *)&v27 + 1) = ___ZN28QMISuppServicesCommandDriver18handleCOLRResponseIN2vs7GetCOLR8ResponseEEEvN10subscriber7SimSlotERKT__block_invoke;
  uint64_t v28 = (__n128 (*)(uint64_t, uint64_t))&unk_264611F18;
  LODWORD(v31) = v4;
  uint64_t v29 = (void (*)(uint64_t))&v20;
  uint64_t v30 = v3;
  *(void *)std::string buf = v26;
  int v9 = qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer}&)(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v19, (uint64_t)buf);
  uint64_t v10 = *(void *)(v3 + 80);
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10 + 16);
  if (v9)
  {
    int v12 = *(NSObject **)v11(v10, v4, v8);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_22231A000, v12, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response, sending event", buf, 2u);
    }
    uint64_t v13 = *(void *)(v3 + 64);
    *(void *)std::string buf = 0;
    __int16 v25 = 0;
    (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v13 + 200))(v13, v4, buf);
    if (v25) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v25);
    }
  }
  else
  {
    uint64_t v14 = *(NSObject **)v11(v10, v4, v8);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl(&dword_22231A000, v14, OS_LOG_TYPE_ERROR, "Failure cause is not present in the response, sending COLR fetch error", buf, 2u);
    }
    uint64_t v15 = *(void *)(v3 + 64);
    uint64_t v16 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v21 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15 + 208))(v15, v4, v16);
  }
  _Block_object_dispose(&v20, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v19);
}

void sub_22250E354(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

uint64_t __copy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCOLREN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCOLREN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCOLR(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCOLR(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5310;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCOLR(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCOLR(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5310;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZN28QMISuppServicesCommandDriver18handleCOLRResponseIN2vs7GetCOLR8ResponseEEEvN10subscriber7SimSlotERKT__block_invoke(uint64_t a1, _WORD *a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 40) + 80) + 16))(*(void *)(*(void *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
}

__n128 __Block_byref_object_copy__127(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__128(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

uint64_t ___ZN28QMISuppServicesCommandDriver18handleCOLRResponseIN2vs7GetCOLR8ResponseEEEvN10subscriber7SimSlotERKT__block_invoke_129(uint64_t result, unsigned char *a2)
{
  **(unsigned char **)(*(void *)(*(void *)(result + 32) + 8) + 40) = *a2;
  *(unsigned char *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 40) + 1) = a2[1];
  return result;
}

uint64_t qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer}&)(vs::tlv::FailureCause const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    uint64_t v6 = result;
    int v7 = v5;
    uint64_t v10 = result;
    tlv::parseV<vs::tlv::FailureCause>((unint64_t *)&v10, v5);
    if (v10)
    {
      (*(void (**)(void))(*(void *)a2 + 16))();
      return 1;
    }
    else
    {
      uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78];
      uint64_t v9 = *(unsigned __int16 *)a1;
      return v8(v9, 17, v6, v7);
    }
  }
  return result;
}

void std::__shared_ptr_pointer<COLRSettingsModel *,std::shared_ptr<COLRSettingsModel>::__shared_ptr_default_delete<COLRSettingsModel,COLRSettingsModel>,std::allocator<COLRSettingsModel>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::__shared_ptr_pointer<COLRSettingsModel *,std::shared_ptr<COLRSettingsModel>::__shared_ptr_default_delete<COLRSettingsModel,COLRSettingsModel>,std::allocator<COLRSettingsModel>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x223C9A950);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<COLRSettingsModel *,std::shared_ptr<COLRSettingsModel>::__shared_ptr_default_delete<COLRSettingsModel,COLRSettingsModel>,std::allocator<COLRSettingsModel>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver9fetchCNAPEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  uint64_t v4 = *((unsigned int *)v2 + 2);
  uint64_t v5 = a2[1];
  v12[0] = *a2;
  v12[1] = v5;
  uint64_t v6 = a2[2];
  void v12[2] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v12);
  if (!HIDWORD(v12[0]))
  {
    *(void *)std::string buf = 0;
    *(void *)&long long v19 = buf;
    *((void *)&v19 + 1) = 0x3802000000;
    uint64_t v20 = __Block_byref_object_copy__56;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    __int16 v21 = __Block_byref_object_dispose__57;
    operator new();
  }
  int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 80) + 16))(*(void *)(v3 + 80), v4);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    int v10 = HIDWORD(v12[0]);
    uint64_t v11 = qmi::asString();
    *(_DWORD *)std::string buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = v10;
    LOWORD(v19) = 2080;
    *(void *)((char *)&v19 + 2) = v11;
    _os_log_error_impl(&dword_22231A000, v7, OS_LOG_TYPE_ERROR, "GetCNAP::Response returned error 0x%x (%s)", buf, 0x12u);
  }
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2000000000;
  LOWORD(v17) = 0;
  *(void *)std::string buf = MEMORY[0x263EF8330];
  *(void *)&long long v19 = 0x40000000;
  *((void *)&v19 + 1) = ___ZN28QMISuppServicesCommandDriver18handleCNAPResponseEN10subscriber7SimSlotERKN2vs7GetCNAP8ResponseE_block_invoke;
  uint64_t v20 = (__n128 (*)(uint64_t, uint64_t))&unk_264611D60;
  __int16 v21 = (void (*)(uint64_t))&v14;
  uint64_t v13 = buf;
  qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer}&)(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v12, (uint64_t)&v13);
  uint64_t v8 = *(void *)(v3 + 64);
  uint64_t v9 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v15 + 12));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 224))(v8, v4, v9);
  _Block_object_dispose(&v14, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v12);
}

void sub_22250EAA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Block_object_dispose(&a21, 8);
  if (a27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a27);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCNAPEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCNAPEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCNAP(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCNAP(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5408;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCNAP(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCNAP(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5408;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<CNAPSettingsModel *,std::shared_ptr<CNAPSettingsModel>::__shared_ptr_default_delete<CNAPSettingsModel,CNAPSettingsModel>,std::allocator<CNAPSettingsModel>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::__shared_ptr_pointer<CNAPSettingsModel *,std::shared_ptr<CNAPSettingsModel>::__shared_ptr_default_delete<CNAPSettingsModel,CNAPSettingsModel>,std::allocator<CNAPSettingsModel>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x223C9A950);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<CNAPSettingsModel *,std::shared_ptr<CNAPSettingsModel>::__shared_ptr_default_delete<CNAPSettingsModel,CNAPSettingsModel>,std::allocator<CNAPSettingsModel>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t dfs::tlv::writeField(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  *(void *)(a1 + 1) = *(void *)(a2 + 8);
  *(_DWORD *)(a1 + 9) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 13) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 17) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 21) = *(_DWORD *)(a2 + 28);
  *(unsigned char *)(a1 + 25) = *(unsigned char *)(a2 + 32);
  *(unsigned char *)(a1 + 26) = *(unsigned char *)(a2 + 33);
  *(void *)(a1 + 27) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 35) = *(_OWORD *)(a2 + 48);
  *(unsigned char *)(a1 + 51) = *(unsigned char *)(a2 + 64);
  *(_OWORD *)(a1 + 52) = *(_OWORD *)(a2 + 65);
  *(unsigned char *)(a1 + 68) = *(unsigned char *)(a2 + 81);
  *(unsigned char *)(a1 + 69) = *(unsigned char *)(a2 + 82);
  *(unsigned char *)(a1 + 70) = *(unsigned char *)(a2 + 83);
  *(_DWORD *)(a1 + 71) = *(_DWORD *)(a2 + 84);
  return a1 + 75;
}

{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 4) = *(void *)(a2 + 8);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 16);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a2 + 18);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 20);
  *(_WORD *)(a1 + 18) = *(_WORD *)(a2 + 22);
  *(void *)(a1 + 20) = *(void *)(a2 + 24);
  *(_WORD *)(a1 + 28) = *(_WORD *)(a2 + 32);
  *(_WORD *)(a1 + 30) = *(_WORD *)(a2 + 34);
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 36);
  *(_WORD *)(a1 + 34) = *(_WORD *)(a2 + 38);
  *(void *)(a1 + 36) = *(void *)(a2 + 40);
  *(unsigned char *)(a1 + 44) = *(unsigned char *)(a2 + 48);
  *(unsigned char *)(a1 + 45) = *(unsigned char *)(a2 + 49);
  *(void *)(a1 + 46) = *(void *)(a2 + 56);
  *(_DWORD *)(a1 + 54) = *(_DWORD *)(a2 + 64);
  *(void *)(a1 + 58) = *(void *)(a2 + 72);
  *(_DWORD *)(a1 + 66) = *(_DWORD *)(a2 + 80);
  return a1 + 70;
}

_DWORD *dfs::tlv::parseField(_DWORD *a1, const unsigned __int8 *a2, _DWORD *a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 4uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 4uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 4uLL);
  uint64_t result = a1 + 3;
  a3[2] = a1[2];
  return result;
}

_DWORD *dfs::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, void *a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  unsigned int v7 = *a1;
  uint64_t v6 = a1 + 1;
  std::vector<dfs::tlv::LLFilterStatusInfo>::resize(a3, v7);
  uint64_t v8 = (_DWORD *)*a3;
  uint64_t v9 = (_DWORD *)a3[1];
  while (1)
  {
    uint64_t result = v6;
    if (v8 == v9) {
      break;
    }
    uint64_t v6 = dfs::tlv::parseField(v6, a2, v8);
    v8 += 3;
  }
  return result;
}

unsigned __int8 *tlv::parseV<dfs::tlv::LLFilterStatusList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t result = (unsigned __int8 *)dfs::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_22250EEB0(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x22250EEA4);
}

void sub_22250EEC0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t dfs::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  unsigned int v7 = *a1;
  unint64_t v6 = (unint64_t)(a1 + 1);
  std::vector<wds::tlv::Ipv4AddrInfo>::resize((uint64_t)a3, v7);
  uint64_t v9 = *a3;
  uint64_t v8 = a3[1];
  while (v9 != v8)
  {
    tlv::throwIfNotEnoughBytes(v6, a2, 2uLL);
    *(_WORD *)uint64_t v9 = *(_WORD *)v6;
    tlv::throwIfNotEnoughBytes(v6 + 2, a2, 4uLL);
    *(_DWORD *)(v9 + 4) = *(_DWORD *)(v6 + 2);
    v6 += 6;
    v9 += 8;
  }
  return v6;
}

unint64_t tlv::parseV<dfs::tlv::LLFilterHandlesList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  unint64_t result = dfs::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_22250EFAC(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x22250EFA0);
}

void sub_22250EFBC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned char **tlv::writeV<dfs::tlv::IPv4SrcAddrFiltersList>(unsigned char **result, _DWORD *a2)
{
  uint64_t v2 = *result;
  unsigned char *v2 = -85 * ((a2[2] - *a2) >> 2);
  uint64_t v3 = v2 + 1;
  uint64_t v4 = *(void *)a2;
  uint64_t v5 = *((void *)a2 + 1);
  while (v4 != v5)
  {
    *(_WORD *)uint64_t v3 = *(_WORD *)v4;
    *(_DWORD *)(v3 + 2) = *(_DWORD *)(v4 + 4);
    *(_DWORD *)(v3 + 6) = *(_DWORD *)(v4 + 8);
    v3 += 10;
    v4 += 12;
  }
  unsigned __int8 *result = v3;
  return result;
}

unsigned char **tlv::writeV<dfs::tlv::IPv6SrcAddrFiltersList>(unsigned char **result, _DWORD *a2)
{
  uint64_t v2 = *result;
  unsigned char *v2 = -51 * ((a2[2] - *a2) >> 2);
  uint64_t v3 = v2 + 1;
  uint64_t v4 = *(void *)a2;
  uint64_t v5 = *((void *)a2 + 1);
  if (*(void *)a2 == v5)
  {
    unint64_t v6 = v3;
  }
  else
  {
    do
    {
      *(_WORD *)uint64_t v3 = *(_WORD *)v4;
      *(_OWORD *)(v3 + 2) = *(_OWORD *)(v4 + 2);
      unint64_t v6 = v3 + 19;
      v3[18] = *(unsigned char *)(v4 + 18);
      v4 += 20;
      v3 += 19;
    }
    while (v4 != v5);
  }
  unsigned __int8 *result = v6;
  return result;
}

unsigned char **tlv::writeV<dfs::tlv::TosFiltersList>(unsigned char **result, _DWORD *a2)
{
  uint64_t v2 = *result;
  unsigned char *v2 = (a2[2] - *a2) >> 2;
  uint64_t v3 = v2 + 1;
  uint64_t v4 = *(void *)a2;
  uint64_t v5 = *((void *)a2 + 1);
  if (*(void *)a2 == v5)
  {
    unint64_t v6 = v3;
  }
  else
  {
    do
    {
      *(_WORD *)uint64_t v3 = *(_WORD *)v4;
      _OWORD v3[2] = *(unsigned char *)(v4 + 2);
      unint64_t v6 = v3 + 4;
      v3[3] = *(unsigned char *)(v4 + 3);
      v4 += 4;
      v3 += 4;
    }
    while (v4 != v5);
  }
  unsigned __int8 *result = v6;
  return result;
}

unsigned char **tlv::writeV<dfs::tlv::UdpSrcPortFiltersList>(unsigned char **result, _DWORD *a2)
{
  uint64_t v2 = *result;
  unsigned char *v2 = -85 * ((a2[2] - *a2) >> 1);
  uint64_t v3 = v2 + 1;
  uint64_t v4 = *(_WORD **)a2;
  uint64_t v5 = (_WORD *)*((void *)a2 + 1);
  while (v4 != v5)
  {
    _WORD *v3 = *v4;
    v3[1] = v4[1];
    _OWORD v3[2] = v4[2];
    v3 += 3;
    v4 += 3;
  }
  unsigned __int8 *result = v3;
  return result;
}

uint64_t tlv::parseV<dfs::tlv::LLFilterCapability>(unint64_t *a1, int a2)
{
  uint64_t v3 = (unsigned int *)*a1;
  uint64_t v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 4uLL);
  unsigned int v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 4uLL);
  uint64_t v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return (v6 << 32) | v5;
}

void sub_22250F1CC(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x22250F1B4);
}

uint64_t dfs::tlv::writeField(unsigned char *a1, _DWORD *a2)
{
  *a1 = -93 * ((a2[2] - *a2) >> 4);
  uint64_t result = (uint64_t)(a1 + 1);
  uint64_t v3 = *(void *)a2;
  uint64_t v4 = *((void *)a2 + 1);
  while (v3 != v4)
  {
    uint64_t v5 = dfs::tlv::writeField(result, v3);
    uint64_t result = dfs::tlv::writeField(v5, v3 + 88);
    v3 += 176;
  }
  return result;
}

void std::vector<dfs::tlv::LLFilterStatusInfo>::resize(void *a1, unint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[1] - *a1) >> 2);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<dfs::tlv::LLFilterStatusInfo>::__append((uint64_t)a1, v4);
  }
  else if (!v3)
  {
    a1[1] = *a1 + 12 * a2;
  }
}

void std::vector<dfs::tlv::LLFilterStatusInfo>::__append(uint64_t a1, unint64_t a2)
{
  uint64_t v5 = *(_DWORD **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (uint64_t)v5) >> 2) >= a2)
  {
    if (a2)
    {
      size_t v12 = 12 * ((12 * a2 - 12) / 0xC) + 12;
      bzero(*(void **)(a1 + 8), v12);
      uint64_t v5 = (_DWORD *)((char *)v5 + v12);
    }
    *(void *)(a1 + 8) = v5;
  }
  else
  {
    uint64_t v6 = *(_DWORD **)a1;
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v5 - *(void *)a1) >> 2);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x1555555555555555) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v4 - (uint64_t)v6) >> 2);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v10 = 0x1555555555555555;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x1555555555555555) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v11 = (char *)operator new(12 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t v13 = &v11[12 * v7];
    uint64_t v14 = &v11[12 * v10];
    size_t v15 = 12 * ((12 * a2 - 12) / 0xC) + 12;
    bzero(v13, v15);
    uint64_t v16 = &v13[v15];
    if (v5 != v6)
    {
      do
      {
        uint64_t v17 = *(void *)(v5 - 3);
        v5 -= 3;
        int v18 = v5[2];
        *(void *)(v13 - 12) = v17;
        v13 -= 12;
        *((_DWORD *)v13 + 2) = v18;
      }
      while (v5 != v6);
      uint64_t v5 = *(_DWORD **)a1;
    }
    *(void *)a1 = v13;
    *(void *)(a1 + 8) = v16;
    *(void *)(a1 + 16) = v14;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void QMINetworkRegistrationDriver::create()
{
  uint64_t v0 = *MEMORY[0x263EF8340];
  operator new();
}

void sub_22250F7C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va2);
  MEMORY[0x223C9A950](v4, 0x10A1C40FF1576FELL);
  uint64_t v6 = *((void *)v2 + 11);
  *((void *)v2 + 11) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::~__value_func[abi:ne180100]((uint64_t *)va);
  NetworkRegistrationDriver::~NetworkRegistrationDriver(v2);
  if (v3) {
    dispatch_release(v3);
  }
  MEMORY[0x223C9A950](v2, 0xF1C40B0401646);
  _Unwind_Resume(a1);
}

void sub_22250F7F8(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    dispatch_barrier_async_f(v2[3], v2, (dispatch_function_t)std::shared_ptr<QMINetworkRegistrationDriver> ctu::SharedSynchronizable<NetworkRegistrationDriver>::make_shared_ptr<QMINetworkRegistrationDriver>(QMINetworkRegistrationDriver*)::{lambda(QMINetworkRegistrationDriver*)#1}::operator() const(QMINetworkRegistrationDriver*)::{lambda(void *)#1}::__invoke);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_22250F82C()
{
}

void sub_22250F840()
{
  std::unique_ptr<qmi::NotifyHelper>::reset[abi:ne180100](v1, 0);
  uint64_t v2 = *(void *)(v0 + 88);
  *(void *)(v0 + 88) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  JUMPOUT(0x22250F8D0);
}

void sub_22250F908(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x22250F8D8);
}

void sub_22250F91C(void *a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x22250F924);
  }
  __clang_call_terminate(a1);
}

void QMINetworkRegistrationDriver::~QMINetworkRegistrationDriver(QMINetworkRegistrationDriver *this)
{
  *(void *)this = &unk_26D4D54D0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 14);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  std::unique_ptr<qmi::NotifyHelper>::reset[abi:ne180100]((qmi::NotifyHelper **)this + 12, 0);
  uint64_t v3 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }

  NetworkRegistrationDriver::~NetworkRegistrationDriver(this);
}

{
  uint64_t vars8;

  QMINetworkRegistrationDriver::~QMINetworkRegistrationDriver(this);

  JUMPOUT(0x223C9A950);
}

void QMINetworkRegistrationDriver::sendIndRegisterReq_sync(uint64_t a1, uint64_t a2)
{
  int v2 = a2;
  if ((a2 - 1) >= 3) {
    a2 = 0;
  }
  else {
    a2 = a2;
  }
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), a2);
  *(_OWORD *)std::string __p = 0u;
  long long v45 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  *qmi::MutableMessageBase::getTLV<nas::tlv::SystemSelectionPreference>((uint64_t)__p, 16) = 1;
  uint64_t v5 = (const void **)__p[1];
  if (__p[1] != (void *)v45)
  {
    while (*((unsigned char *)*v5 + 8) != 35)
    {
      if (++v5 == (const void **)v45) {
        goto LABEL_11;
      }
    }
  }
  if (v5 == (const void **)v45) {
LABEL_11:
  }
    operator new();
  if (!v6) {
    __cxa_bad_cast();
  }
  v6[9] = 1;
  *qmi::MutableMessageBase::getTLV<nas::tlv::ServingSysEvents>((uint64_t)__p, 19) = 0;
  *qmi::MutableMessageBase::getTLV<nas::tlv::SysInfoEvents>((uint64_t)__p, 24) = 1;
  uint64_t v7 = (const void **)__p[1];
  unint64_t v8 = (const void **)v45;
  uint64_t v9 = (const void **)__p[1];
  if (__p[1] != (void *)v45)
  {
    uint64_t v9 = (const void **)__p[1];
    while (*((unsigned char *)*v9 + 8) != 30)
    {
      if (++v9 == (const void **)v45) {
        goto LABEL_20;
      }
    }
  }
  if (v9 == (const void **)v45) {
LABEL_20:
  }
    operator new();
  if (!v10) {
    __cxa_bad_cast();
  }
  void v10[9] = 1;
  while (1)
  {
    if (v7 == v8) {
      goto LABEL_27;
    }
    if (*((unsigned char *)*v7 + 8) == 23) {
      break;
    }
    ++v7;
  }
  if (v7 == v8) {
LABEL_27:
  }
    operator new();
  if (!v11) {
    __cxa_bad_cast();
  }
  v11[9] = 1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v13 = ServiceMap;
  uint64_t v14 = *(void *)(MEMORY[0x263F03588] + 8);
  if (v14 < 0)
  {
    uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      uint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v14;
  int v18 = std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<void>>>>::find<unsigned long>(&v13[1].__m_.__sig, (unint64_t *)buf);
  if (v18)
  {
    uint64_t v20 = v18[3];
    long long v19 = (std::__shared_weak_count *)v18[4];
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v13);
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v19);
      if (!v20)
      {
        uint64_t v23 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl(&dword_22231A000, v23, OS_LOG_TYPE_DEFAULT, "#N Could not get TimeHandlerInterface to set network time cache period", buf, 2u);
        }
LABEL_43:
        std::__shared_weak_count::__release_shared[abi:ne180100](v19);
        goto LABEL_44;
      }
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_39:
      uint64_t v22 = qmi::MutableMessageBase::getTLV<nas::tlv::NetworkTimeCachePeriod>((uint64_t)__p);
      *(_DWORD *)uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 80))(v20);
      if (!v19) {
        goto LABEL_44;
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v19);
      goto LABEL_43;
    }
    std::mutex::unlock(v13);
    if (v20) {
      goto LABEL_39;
    }
  }
  else
  {
    std::mutex::unlock(v13);
  }
  __int16 v21 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_22231A000, v21, OS_LOG_TYPE_DEFAULT, "#N Could not get TimeHandlerInterface to set network time cache period", buf, 2u);
  }
LABEL_44:
  uint64_t v24 = (const void **)__p[1];
  if (__p[1] != (void *)v45)
  {
    while (*((unsigned char *)*v24 + 8) != 37)
    {
      if (++v24 == (const void **)v45) {
        goto LABEL_51;
      }
    }
  }
  if (v24 != (const void **)v45)
  {
    if (!v25) {
      __cxa_bad_cast();
    }
    *((unsigned char *)v25 + 9) = 1;
    uint64_t v26 = (capabilities::ct *)capabilities::ct::supportsVoLTE(v25);
    if (v26 & 1) != 0 || (capabilities::ct::supportsSMSIMSStack(v26))
    {
      long long v27 = (const void **)__p[1];
      uint64_t v28 = (const void **)v45;
      uint64_t v29 = (const void **)__p[1];
      if (__p[1] != (void *)v45)
      {
        uint64_t v29 = (const void **)__p[1];
        while (*((unsigned char *)*v29 + 8) != 41)
        {
          if (++v29 == (const void **)v45) {
            goto LABEL_62;
          }
        }
      }
      if (v29 == (const void **)v45) {
LABEL_62:
      }
        operator new();
      if (!v30) {
        __cxa_bad_cast();
      }
      v30[9] = 1;
      while (1)
      {
        if (v27 == v28) {
          goto LABEL_70;
        }
        if (*((unsigned char *)*v27 + 8) == 38) {
          break;
        }
        ++v27;
      }
      if (v27 == v28) {
LABEL_70:
      }
        operator new();
      if (!v31) {
        __cxa_bad_cast();
      }
      v31[9] = 1;
      for (uint64_t i = (const void **)__p[1]; ; ++i)
      {
        if (i == v28) {
          goto LABEL_77;
        }
        if (*((unsigned char *)*i + 8) == 43) {
          break;
        }
      }
      if (i == v28) {
LABEL_77:
      }
        operator new();
      if (!v33) {
        __cxa_bad_cast();
      }
      v33[9] = 1;
    }
    else
    {
      uint64_t v28 = (const void **)v45;
    }
    for (j = (const void **)__p[1]; ; ++j)
    {
      if (j == v28) {
        goto LABEL_85;
      }
      if (*((unsigned char *)*j + 8) == 33) {
        break;
      }
    }
    if (j != v28)
    {
      if (!v35) {
        __cxa_bad_cast();
      }
      *(_WORD *)(v35 + 9) = 1;
      uint64_t v36 = (capabilities::ct *)capabilities::ct::supports5G((capabilities::ct *)v35);
      if (v36)
      {
        uint64_t v37 = (const void **)__p[1];
        if (__p[1] != (void *)v45)
        {
          while (*((unsigned char *)*v37 + 8) != 75)
          {
            if (++v37 == (const void **)v45) {
              goto LABEL_94;
            }
          }
        }
        if (v37 == (const void **)v45) {
LABEL_94:
        }
          operator new();
        if (!v36) {
          __cxa_bad_cast();
        }
        *((unsigned char *)v36 + 9) = 1;
      }
      __int16 v38 = (capabilities::ct *)capabilities::ct::supportsPrivateNetwork(v36);
      if (v38)
      {
        char v39 = (const void **)__p[1];
        if (__p[1] != (void *)v45)
        {
          while (*((unsigned __int8 *)*v39 + 8) != 210)
          {
            if (++v39 == (const void **)v45) {
              goto LABEL_103;
            }
          }
        }
        if (v39 == (const void **)v45) {
LABEL_103:
        }
          operator new();
        if (!v38) {
          __cxa_bad_cast();
        }
        *((unsigned char *)v38 + 9) = 1;
      }
      if (capabilities::ct::supportsStewie(v38))
      {
        uint64_t v40 = (const void **)__p[1];
        if (__p[1] != (void *)v45)
        {
          while (*((unsigned char *)*v40 + 8) != 74)
          {
            if (++v40 == (const void **)v45) {
              goto LABEL_112;
            }
          }
        }
        if (v40 == (const void **)v45) {
LABEL_112:
        }
          operator new();
        if (!v41) {
          __cxa_bad_cast();
        }
        v41[9] = 1;
      }
      uint64_t v42 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_22231A000, v42, OS_LOG_TYPE_DEFAULT, "#I Sending register for NAS indications", buf, 2u);
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<nas::IndicationRegister::Request>(&v43, v2);
    }
LABEL_85:
    operator new();
  }
LABEL_51:
  operator new();
}

void sub_222510F04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::getImsPreferenceInfo_sync(uint64_t a1, uint64_t a2)
{
  if ((a2 - 1) >= 3) {
    a2 = 0;
  }
  else {
    a2 = a2;
  }
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), a2);
  memset(v2, 0, sizeof(v2));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v2);
  qmi::ClientRouter::get();
  operator new();
}

void sub_2225111AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::setEmergencyMode(QMINetworkRegistrationDriver *this, char a2)
{
  *(_OWORD *)std::string __p = 0u;
  long long v7 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v3 = (const void **)__p[1];
  if (__p[1] != (void *)v7)
  {
    while (*((unsigned char *)*v3 + 8) != 16)
    {
      if (++v3 == (const void **)v7) {
        goto LABEL_8;
      }
    }
  }
  if (v3 != (const void **)v7)
  {
    if (v4)
    {
      v4[9] = a2;
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>(&v5, 1);
    }
    __cxa_bad_cast();
  }
LABEL_8:
  operator new();
}

void sub_222511538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  uint64_t v23 = a10;
  a10 = 0;
  if (v23) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v23);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::enable2G(capabilities::ct *a1, int a2, char a3)
{
  uint64_t v5 = capabilities::ct::supportsBB2GMitigation(a1);
  if (v5)
  {
    *(_OWORD *)std::string __p = 0u;
    long long v12 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    uint64_t v6 = (const void **)__p[1];
    if (__p[1] != (void *)v12)
    {
      while (*((unsigned __int8 *)*v6 + 8) != 167)
      {
        if (++v6 == (const void **)v12) {
          goto LABEL_9;
        }
      }
    }
    if (v6 != (const void **)v12)
    {
      if (v7)
      {
        v7[9] = a3;
        if ((a2 - 1) >= 3) {
          int v8 = 0;
        }
        else {
          int v8 = a2;
        }
        qmi::ClientRouter::get();
        qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>(&v10, v8);
      }
      __cxa_bad_cast();
    }
LABEL_9:
    operator new();
  }
  return v5;
}

void sub_2225118D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  uint64_t v23 = a10;
  a10 = 0;
  if (v23) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v23);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::enable3G(uint64_t a1, int a2, char a3)
{
  *(_OWORD *)std::string __p = 0u;
  long long v10 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v5 = (const void **)__p[1];
  if (__p[1] != (void *)v10)
  {
    while (*((unsigned char *)*v5 + 8) != 50)
    {
      if (++v5 == (const void **)v10) {
        goto LABEL_8;
      }
    }
  }
  if (v5 != (const void **)v10)
  {
    if (v6)
    {
      v6[9] = a3;
      if ((a2 - 1) >= 3) {
        int v7 = 0;
      }
      else {
        int v7 = a2;
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>(&v8, v7);
    }
    __cxa_bad_cast();
  }
LABEL_8:
  operator new();
}

void sub_222511C60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  uint64_t v23 = a10;
  a10 = 0;
  if (v23) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v23);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::enableLTE(uint64_t a1, int a2, char a3, unsigned int a4)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  int v7 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
  *(_OWORD *)std::string __p = 0u;
  long long v21 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  int v8 = (const void **)__p[1];
  uint64_t v9 = (const void **)v21;
  long long v10 = (const void **)__p[1];
  if (__p[1] != (void *)v21)
  {
    long long v10 = (const void **)__p[1];
    while (*((unsigned char *)*v10 + 8) != 49)
    {
      if (++v10 == (const void **)v21) {
        goto LABEL_9;
      }
    }
  }
  if (v10 != (const void **)v21)
  {
    if (!v11) {
      __cxa_bad_cast();
    }
    v11[9] = a3;
    while (1)
    {
      if (v8 == v9) {
        goto LABEL_16;
      }
      if (*((unsigned __int8 *)*v8 + 8) == 160) {
        break;
      }
      ++v8;
    }
    if (v8 != v9)
    {
      if (v12)
      {
        uint64_t v13 = v12 + 12;
        uint64_t v14 = *v7;
        if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = CSIBOOLAsString();
          uint64_t v17 = asString();
          buf[0] = 136315394;
          *(void *)&buf[1] = v16;
          __int16 v23 = 2080;
          uint64_t v24 = v17;
          _os_log_impl(&dword_22231A000, v14, OS_LOG_TYPE_DEFAULT, "#I Informing baseband the Enable LTE [%s] update reason: %s", (uint8_t *)buf, 0x16u);
        }
        if (a4 <= 3) {
          *uint64_t v13 = dword_22258DCE0[(char)a4];
        }
        if ((a2 - 1) >= 3) {
          int v18 = 0;
        }
        else {
          int v18 = a2;
        }
        qmi::ClientRouter::get();
        qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>(&v19, v18);
      }
      __cxa_bad_cast();
    }
LABEL_16:
    operator new();
  }
LABEL_9:
  operator new();
}

void sub_222512260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  if (a26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a26);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v26);
  uint64_t v28 = a10;
  a10 = 0;
  if (v28) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v28);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::enable5G(uint64_t a1, int a2, int a3, unsigned int a4, char a5)
{
  (*(void (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
  *(_OWORD *)std::string __p = 0u;
  long long v16 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v9 = (const void **)__p[1];
  if (__p[1] != (void *)v16)
  {
    while (*((unsigned __int8 *)*v9 + 8) != 165)
    {
      if (++v9 == (const void **)v16) {
        goto LABEL_8;
      }
    }
  }
  if (v9 != (const void **)v16)
  {
    if (!v10) {
      __cxa_bad_cast();
    }
    void v10[9] = a3 != 0;
    updated = qmi::MutableMessageBase::getTLV<nas::tlv::EnableNrUpdateReason>((uint64_t)__p);
    if (a4 <= 3) {
      *(_DWORD *)updated = dword_22258DCE0[(char)a4];
    }
    long long v12 = (const void **)__p[1];
    if (__p[1] != (void *)v16)
    {
      while (*((unsigned __int8 *)*v12 + 8) != 166)
      {
        if (++v12 == (const void **)v16) {
          goto LABEL_18;
        }
      }
    }
    if (v12 != (const void **)v16)
    {
      if (v13)
      {
        v13[10] = a5;
        if ((a2 - 1) >= 3) {
          a2 = 0;
        }
        qmi::ClientRouter::get();
        qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>(&v14, a2);
      }
      __cxa_bad_cast();
    }
LABEL_18:
    operator new();
  }
LABEL_8:
  operator new();
}

void sub_2225127F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  uint64_t v23 = a10;
  a10 = 0;
  if (v23) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v23);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::enable5GStandalone(uint64_t a1, int a2, int a3, unsigned int a4)
{
  (*(void (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
  memset(v9, 0, sizeof(v9));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v9);
  *(_DWORD *)qmi::MutableMessageBase::getTLV<nas::tlv::NRDisableMode>((uint64_t)v9) = a3 ^ 1;
  updated = qmi::MutableMessageBase::getTLV<nas::tlv::EnableNrUpdateReason>((uint64_t)v9);
  if (a4 <= 3) {
    *(_DWORD *)updated = dword_22258DCE0[(char)a4];
  }
  if ((a2 - 1) >= 3) {
    a2 = 0;
  }
  qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>(&v8, a2);
}

void sub_222512A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  uint64_t v23 = a10;
  a10 = 0;
  if (v23) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v23);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::setCdmaRoamingSwitchSetting(uint64_t a1, int a2, char a3, uint64_t a4)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  int v7 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
  int v8 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = CSIBOOLAsString();
    uint64_t v10 = (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 1;
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = v10;
    _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#I Setting System Selection Preference CDMA roaming switch (%s) with %zu equivalent countries", buf, 0x16u);
  }
  *(_OWORD *)std::string __p = 0u;
  long long v22 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v11 = (const void **)__p[1];
  if (__p[1] != (void *)v22)
  {
    while (*((unsigned __int8 *)*v11 + 8) != 161)
    {
      if (++v11 == (const void **)v22) {
        goto LABEL_10;
      }
    }
  }
  if (v11 != (const void **)v22)
  {
    if (!v12) {
      __cxa_bad_cast();
    }
    v12[9] = a3;
    memset(buf, 0, sizeof(buf));
    std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(buf, *(const void **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 1);
    uint64_t v24 = v7;
    uint64_t v13 = (const void **)__p[1];
    if (__p[1] != (void *)v22)
    {
      while (*((unsigned __int8 *)*v13 + 8) != 162)
      {
        if (++v13 == (const void **)v22) {
          goto LABEL_18;
        }
      }
    }
    if (v13 != (const void **)v22)
    {
      if (v14)
      {
        uint64_t v15 = (void **)(v14 + 16);
        std::vector<unsigned short>::resize((uint64_t)(v14 + 16), (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 1);
        long long v16 = *(void **)buf;
        if (*(void *)&buf[8] == *(void *)buf)
        {
          uint64_t v17 = *(void *)buf;
        }
        else
        {
          memmove(*v15, *(const void **)buf, *(void *)&buf[8] - *(void *)buf);
          long long v16 = *(void **)buf;
          uint64_t v17 = *(void *)&buf[8];
        }
        if ((unint64_t)(v17 - (void)v16) >= 0x15)
        {
          std::vector<unsigned short>::resize((uint64_t)v15, 0xAuLL);
          int v18 = *v24;
          BOOL v19 = os_log_type_enabled(*v24, OS_LOG_TYPE_DEFAULT);
          long long v16 = *(void **)buf;
          if (v19)
          {
            aBlock[0] = 134218240;
            *(void *)&aBlock[1] = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 1;
            __int16 v26 = 2048;
            uint64_t v27 = 10;
            _os_log_impl(&dword_22231A000, v18, OS_LOG_TYPE_DEFAULT, "#I Truncated equivalent country MCC list from %zu entries to %zu", (uint8_t *)aBlock, 0x16u);
            long long v16 = *(void **)buf;
          }
        }
        if (v16)
        {
          *(void *)&uint8_t buf[8] = v16;
          operator delete(v16);
        }
        if ((a2 - 1) >= 3) {
          a2 = 0;
        }
        qmi::ClientRouter::get();
        qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>(&v20, a2);
      }
      __cxa_bad_cast();
    }
LABEL_18:
    operator new();
  }
LABEL_10:
  operator new();
}

void sub_222513118(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  uint64_t v22 = a10;
  a10 = 0;
  if (v22) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v22);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::setSystemSelectionAndRoamingPreference(QMINetworkRegistrationDriver *this, unsigned int a2, __int16 a3)
{
}

void QMINetworkRegistrationDriver::setSystemSelectionPreference(uint64_t a1, int a2, unsigned int a3, uint64_t a4, __int16 a5)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  uint64_t v9 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
  *(_OWORD *)std::string __p = 0u;
  long long v49 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v10 = qmi::MutableMessageBase::getTLV<nas::tlv::ModePreference>((uint64_t)__p, 17);
  uint64_t v11 = (__int16 *)v10;
  __int16 v12 = 0;
  *(_WORD *)uint64_t v10 = 0;
  if (a3)
  {
    uint64_t v13 = *v9;
    uint64_t v10 = (char *)os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
    __int16 v14 = 0;
    if (v10)
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_22231A000, v13, OS_LOG_TYPE_DEFAULT, "#I GSM has been enabled in RAT selection", (uint8_t *)&buf, 2u);
      __int16 v14 = *v11;
    }
    __int16 v12 = v14 | 4;
    *uint64_t v11 = v14 | 4;
    if ((a3 & 2) == 0)
    {
LABEL_3:
      if ((a3 & 0x10) == 0) {
        goto LABEL_4;
      }
      goto LABEL_14;
    }
  }
  else if ((a3 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t v15 = *v9;
  uint64_t v10 = (char *)os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
  if (v10)
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_22231A000, v15, OS_LOG_TYPE_DEFAULT, "#I UMTS has been enabled in RAT selection", (uint8_t *)&buf, 2u);
    __int16 v12 = *v11;
  }
  v12 |= 8u;
  *uint64_t v11 = v12;
  if ((a3 & 0x10) == 0)
  {
LABEL_4:
    if ((a3 & 4) == 0) {
      goto LABEL_5;
    }
    goto LABEL_17;
  }
LABEL_14:
  long long v16 = *v9;
  uint64_t v10 = (char *)os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
  if (v10)
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_22231A000, v16, OS_LOG_TYPE_DEFAULT, "#I LTE has been enabled in RAT selection", (uint8_t *)&buf, 2u);
    __int16 v12 = *v11;
  }
  v12 |= 0x10u;
  *uint64_t v11 = v12;
  if ((a3 & 4) == 0)
  {
LABEL_5:
    if ((a3 & 8) == 0) {
      goto LABEL_6;
    }
    goto LABEL_20;
  }
LABEL_17:
  uint64_t v17 = *v9;
  uint64_t v10 = (char *)os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
  if (v10)
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_22231A000, v17, OS_LOG_TYPE_DEFAULT, "#I CDMA 1x has been enabled in RAT selection", (uint8_t *)&buf, 2u);
    __int16 v12 = *v11;
  }
  v12 |= 1u;
  *uint64_t v11 = v12;
  if ((a3 & 8) == 0)
  {
LABEL_6:
    if ((a3 & 0x20) == 0) {
      goto LABEL_26;
    }
    goto LABEL_23;
  }
LABEL_20:
  int v18 = *v9;
  uint64_t v10 = (char *)os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
  if (v10)
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_22231A000, v18, OS_LOG_TYPE_DEFAULT, "#I EVDO has been enabled in RAT selection", (uint8_t *)&buf, 2u);
    __int16 v12 = *v11;
  }
  v12 |= 2u;
  *uint64_t v11 = v12;
  if ((a3 & 0x20) == 0)
  {
LABEL_26:
    uint64_t v20 = capabilities::ct::supports5G((capabilities::ct *)v10);
    if (v20)
    {
      if (a3 < 0x40) {
        goto LABEL_51;
      }
      long long v21 = *v9;
      uint64_t v20 = os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
      if (v20)
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_22231A000, v21, OS_LOG_TYPE_DEFAULT, "#I NR has been enabled in RAT selection", (uint8_t *)&buf, 2u);
      }
      *v11 |= 0x40u;
    }
    if (a3 == 255)
    {
      uint64_t v22 = *v9;
      if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_22231A000, v22, OS_LOG_TYPE_DEFAULT, "#I Automatic has been enabled in RAT selection", (uint8_t *)&buf, 2u);
        uint64_t v22 = *v9;
      }
      *uint64_t v11 = 0;
      BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
      if (v23)
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_22231A000, v22, OS_LOG_TYPE_DEFAULT, "#I UMTS capable device, adding GSM and UMTS to RAT selection", (uint8_t *)&buf, 2u);
        __int16 v24 = *v11 | 0xC;
      }
      else
      {
        __int16 v24 = 12;
      }
      *uint64_t v11 = v24;
      int v25 = capabilities::ct::supportsCapabilityC2KDevice((capabilities::ct *)v23);
      __int16 v26 = *v9;
      if (v25)
      {
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl(&dword_22231A000, v26, OS_LOG_TYPE_DEFAULT, "#I CDMA capable device, adding 1x and EVDO to RAT selection", (uint8_t *)&buf, 2u);
          __int16 v26 = *v9;
        }
        *v11 |= 3u;
      }
      BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
      if (v27)
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_22231A000, v26, OS_LOG_TYPE_DEFAULT, "#I LTE capable device, adding LTE to RAT selection", (uint8_t *)&buf, 2u);
      }
      *v11 |= 0x10u;
      uint64_t v28 = (capabilities::ct *)capabilities::ct::supportsCapabilityTDSCDMADevice((capabilities::ct *)v27);
      if (v28)
      {
        uint64_t v29 = *v9;
        uint64_t v28 = (capabilities::ct *)os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
        if (v28)
        {
          LOWORD(buf) = 0;
          _os_log_impl(&dword_22231A000, v29, OS_LOG_TYPE_DEFAULT, "#I TDSCDMA capable device, adding TDSCDMA to RAT selection", (uint8_t *)&buf, 2u);
        }
        *v11 |= 0x20u;
      }
      uint64_t v20 = capabilities::ct::supports5G(v28);
      if (v20)
      {
        uint64_t v30 = *v9;
        uint64_t v20 = os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
        if (v20)
        {
          LOWORD(buf) = 0;
          _os_log_impl(&dword_22231A000, v30, OS_LOG_TYPE_DEFAULT, "#I NR capable device, adding NR to RAT selection", (uint8_t *)&buf, 2u);
        }
        *v11 |= 0x40u;
      }
    }
LABEL_51:
    if ((a4 & 0xFF00000000) != 0)
    {
      uint64_t v31 = (const void **)__p[1];
      if (__p[1] != (void *)v49)
      {
        while (*((unsigned char *)*v31 + 8) != 28)
        {
          if (++v31 == (const void **)v49) {
            goto LABEL_59;
          }
        }
      }
      if (v31 == (const void **)v49) {
LABEL_59:
      }
        operator new();
      if (!v32) {
        __cxa_bad_cast();
      }
      char v33 = (int *)(v32 + 12);
      if (a4 == 2)
      {
        uint64_t v36 = *v9;
        uint64_t v20 = os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
        if (v20)
        {
          LOWORD(buf) = 0;
          int v35 = 2;
          _os_log_impl(&dword_22231A000, v36, OS_LOG_TYPE_DEFAULT, "#I Setting acquisition order to UMTS", (uint8_t *)&buf, 2u);
        }
        else
        {
          int v35 = 2;
        }
      }
      else if (a4 == 1)
      {
        long long v34 = *v9;
        uint64_t v20 = os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
        if (v20)
        {
          LOWORD(buf) = 0;
          _os_log_impl(&dword_22231A000, v34, OS_LOG_TYPE_DEFAULT, "#I Setting acquisition order to GSM", (uint8_t *)&buf, 2u);
        }
        int v35 = 1;
      }
      else
      {
        uint64_t v37 = *v9;
        uint64_t v20 = os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
        int v35 = 0;
        if (v20)
        {
          LOWORD(buf) = 0;
          _os_log_impl(&dword_22231A000, v37, OS_LOG_TYPE_DEFAULT, "#I Setting acquisition order to Default", (uint8_t *)&buf, 2u);
          int v35 = 0;
        }
      }
      *char v33 = v35;
    }
    if ((a5 & 0xFF00) != 0)
    {
      __int16 v38 = (const void **)__p[1];
      if (__p[1] != (void *)v49)
      {
        while (*((unsigned char *)*v38 + 8) != 20)
        {
          if (++v38 == (const void **)v49) {
            goto LABEL_79;
          }
        }
      }
      if (v38 == (const void **)v49) {
LABEL_79:
      }
        operator new();
      if (!v39) {
        __cxa_bad_cast();
      }
      uint64_t v40 = (__int16 *)(v39 + 10);
      uint64_t v41 = *v9;
      uint64_t v20 = os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
      if (v20)
      {
        uint64_t v42 = CSIBOOLAsString();
        int buf = 136315138;
        *(void *)buf_4 = v42;
        _os_log_impl(&dword_22231A000, v41, OS_LOG_TYPE_DEFAULT, "#I Setting roaming preference to %s", (uint8_t *)&buf, 0xCu);
      }
      if ((_BYTE)a5) {
        __int16 v43 = 255;
      }
      else {
        __int16 v43 = 1;
      }
      __int16 *v40 = v43;
    }
    if (capabilities::ct::supports5G((capabilities::ct *)v20))
    {
      if ((~a3 & 0xC0) != 0)
      {
        if ((a3 & 0x80) != 0)
        {
          *(_DWORD *)qmi::MutableMessageBase::getTLV<nas::tlv::NRDisableMode>((uint64_t)__p) = 1;
          char v44 = *v9;
          if (!os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_97;
          }
          LOWORD(buf) = 0;
          long long v45 = "#I Disabling StandAlone mode";
        }
        else
        {
          if ((a3 & 0x40) == 0) {
            goto LABEL_97;
          }
          *(_DWORD *)qmi::MutableMessageBase::getTLV<nas::tlv::NRDisableMode>((uint64_t)__p) = 2;
          char v44 = *v9;
          if (!os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_97;
          }
          LOWORD(buf) = 0;
          long long v45 = "#I Disabling Non-StandAlone mode";
        }
      }
      else
      {
        *(_DWORD *)qmi::MutableMessageBase::getTLV<nas::tlv::NRDisableMode>((uint64_t)__p) = 0;
        char v44 = *v9;
        if (!os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_97;
        }
        LOWORD(buf) = 0;
        long long v45 = "#I Enabling both Non-StandAlone and StandAlone mode";
      }
      _os_log_impl(&dword_22231A000, v44, OS_LOG_TYPE_DEFAULT, v45, (uint8_t *)&buf, 2u);
    }
LABEL_97:
    if ((a2 - 1) >= 3) {
      int v46 = 0;
    }
    else {
      int v46 = a2;
    }
    qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>(&v47, v46);
  }
LABEL_23:
  BOOL v19 = *v9;
  uint64_t v10 = (char *)os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
  if (v10)
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_22231A000, v19, OS_LOG_TYPE_DEFAULT, "#I TDSCDMA has been enabled in RAT selection", (uint8_t *)&buf, 2u);
    __int16 v12 = *v11;
  }
  *uint64_t v11 = v12 | 0x20;
  goto LABEL_26;
}

void sub_222513D54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::setSystemSelectionAndOrderPreference(uint64_t a1, int a2, unsigned int a3, unsigned int a4)
{
}

uint64_t QMINetworkRegistrationDriver::getSystemSelectionPreference(void **a1, int a2)
{
  if (a2 != 3)
  {
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void *))(*a1[11] + 16))(a1[11]);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#I Getting system selection preference from baseband", buf, 2u);
    }
    memset(v7, 0, sizeof(v7));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v7);
    qmi::ClientRouter::get();
    operator new();
  }
  uint64_t result = subscriber::makeSimSlotRange();
  uint64_t v4 = *(unsigned int **)buf;
  if (*(unsigned int **)buf != v9)
  {
    while (1)
    {
      uint64_t result = v10(*v4);
      if (result) {
        break;
      }
      if (++v4 == v9)
      {
        uint64_t v4 = v9;
        break;
      }
    }
LABEL_6:
    while (v4 != v9)
    {
      uint64_t v5 = v4 + 1;
      uint64_t result = ((uint64_t (*)(void **, void))(*a1)[14])(a1, *v4);
      uint64_t v4 = v9;
      if (v5 != v9)
      {
        uint64_t v4 = v5;
        while (1)
        {
          uint64_t result = v10(*v4);
          if (result) {
            break;
          }
          if (++v4 == v9)
          {
            uint64_t v4 = v9;
            goto LABEL_6;
          }
        }
      }
    }
  }
  return result;
}

void sub_2225140D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v20, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::handleModePreference_sync(capabilities::ct *a1, uint64_t a2, int a3)
{
  if ((*(void *)&a3 & 0xFF0000) == 0) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  capabilities::ct::supports5G(a1);
  uint64_t v4 = *(uint64_t (**)(void))(**((void **)a1 + 8) + 40);

  return v4();
}

uint64_t QMINetworkRegistrationDriver::getServingSystem(void **a1, int a2)
{
  if (a2 != 3)
  {
    int v7 = *(NSObject **)(*(uint64_t (**)(void *))(*a1[11] + 16))(a1[11]);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#I Getting current serving system from baseband", buf, 2u);
    }
    memset(v10, 0, sizeof(v10));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v10);
    if (a2 == 1) {
      int v8 = 1;
    }
    else {
      int v8 = 2 * (a2 == 2);
    }
    qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::GetSysInfo::Request>(&v9, v8);
  }
  uint64_t result = subscriber::makeSimSlotRange();
  uint64_t v4 = *(unsigned int **)buf;
  if (*(unsigned int **)buf != v12)
  {
    while (1)
    {
      uint64_t result = v13(*v4);
      if (result) {
        break;
      }
      if (++v4 == v12)
      {
        uint64_t v4 = v12;
        break;
      }
    }
LABEL_6:
    while (v4 != v12)
    {
      uint64_t v5 = v4 + 1;
      uint64_t result = ((uint64_t (*)(void **, void))(*a1)[16])(a1, *v4);
      uint64_t v4 = v12;
      if (v5 != v12)
      {
        uint64_t v4 = v5;
        while (1)
        {
          uint64_t result = v13(*v4);
          if (result) {
            break;
          }
          if (++v4 == v12)
          {
            uint64_t v4 = v12;
            goto LABEL_6;
          }
        }
      }
    }
  }
  return result;
}

void sub_222514520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  uint64_t v22 = a10;
  a10 = 0;
  if (v22) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v22);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void ServingSystem::~ServingSystem(ServingSystem *this)
{
  if (*((unsigned char *)this + 152))
  {
    int v2 = (void *)*((void *)this + 16);
    if (v2)
    {
      *((void *)this + 17) = v2;
      operator delete(v2);
    }
  }
  if (*((unsigned char *)this + 120)) {
    std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>>>::destroy(*((void **)this + 13));
  }
  if (*((unsigned char *)this + 32)) {
    std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::System>>>::destroy(*((void **)this + 2));
  }
}

uint64_t QMINetworkRegistrationDriver::getPlmnName(uint64_t a1, uint64_t a2, uint64_t a3, const MCC *a4, int a5)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  *(_OWORD *)std::string __p = 0u;
  long long v28 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  MCC::MCC();
  MCC::MCC((MCC *)v34, a4);
  int v9 = (const void **)__p[1];
  if (__p[1] != (void *)v28)
  {
    while (*((unsigned char *)*v9 + 8) != 1)
    {
      if (++v9 == (const void **)v28) {
        goto LABEL_8;
      }
    }
  }
  if (v9 == (const void **)v28) {
LABEL_8:
  }
    operator new();
  if (!v10) {
    __cxa_bad_cast();
  }
  uint64_t v11 = (char *)(v10 + 5);
  void v10[5] = MCC::getIntValue((MCC *)&buf);
  __int16 IntValue = MCC::getIntValue((MCC *)v34);
  *((_WORD *)v11 + 1) = IntValue;
  if (v35 < 0) {
    operator delete(v34[1]);
  }
  if (v33 < 0) {
    operator delete(*(void **)&buf_4[4]);
  }
  char v13 = 0;
  char v14 = 1;
  switch(a5)
  {
    case -1:
    case 3:
    case 4:
    case 5:
    case 11:
      uint64_t v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), a2);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
      {
        uint64_t v26 = asString();
        int buf = 136315138;
        *(void *)buf_4 = v26;
        _os_log_fault_impl(&dword_22231A000, v15, OS_LOG_TYPE_FAULT, "RAT %s should not have been encountered here", (uint8_t *)&buf, 0xCu);
      }
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
      return 0;
    case 0:
      char v14 = 0;
      char v13 = 4;
      break;
    case 2:
      char v14 = 0;
      char v13 = 5;
      break;
    case 7:
    case 8:
      char v14 = 0;
      char v13 = 8;
      break;
    case 9:
      char v14 = 0;
      char v13 = 9;
      break;
    case 10:
      char v14 = 0;
      char v13 = 12;
      break;
    default:
      break;
  }
  long long v16 = (const void **)__p[1];
  uint64_t v17 = (const void **)v28;
  if (__p[1] != (void *)v28)
  {
    while (*((unsigned char *)*v16 + 8) != 18)
    {
      if (++v16 == (const void **)v28) {
        goto LABEL_29;
      }
    }
  }
  if (v16 != (const void **)v28)
  {
    if (!v18) {
      __cxa_bad_cast();
    }
    v18[9] = 1;
    if ((v14 & 1) == 0)
    {
      for (uint64_t i = (const void **)__p[1]; ; ++i)
      {
        if (i == v17) {
          goto LABEL_38;
        }
        if (*((unsigned char *)*i + 8) == 21) {
          break;
        }
      }
      if (i == v17) {
LABEL_38:
      }
        operator new();
      if (!v20) {
        __cxa_bad_cast();
      }
      v20[9] = v13;
    }
    MCC::MCC((MCC *)&buf, a4);
    long long v21 = (const void **)__p[1];
    if (__p[1] != (void *)v28)
    {
      while (*((unsigned char *)*v21 + 8) != 17)
      {
        if (++v21 == (const void **)v28) {
          goto LABEL_46;
        }
      }
    }
    if (v21 != (const void **)v28)
    {
      if (v22)
      {
        BOOL v23 = (BOOL *)(v22 + 9);
        MCC::getStringValue(aBlock, (MCC *)&buf);
        if (v30 < 0)
        {
          __int16 v24 = (void *)aBlock[0];
          *BOOL v23 = aBlock[1] == 3;
          operator delete(v24);
        }
        else
        {
          *BOOL v23 = v30 == 3;
        }
        if (v33 < 0) {
          operator delete(*(void **)&buf_4[4]);
        }
        qmi::ClientRouter::get();
        operator new();
      }
      __cxa_bad_cast();
    }
LABEL_46:
    operator new();
  }
LABEL_29:
  operator new();
}

void sub_222514FA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29)
{
}

void NetworkTimeUpdate::~NetworkTimeUpdate(void **this)
{
  if (*((unsigned char *)this + 144) && *((char *)this + 143) < 0) {
    operator delete(this[15]);
  }
  if (*((unsigned char *)this + 104))
  {
    if (*((char *)this + 103) < 0) {
      operator delete(this[10]);
    }
  }
}

void QMINetworkRegistrationDriver::sendPSRegistrationRequest(uint64_t a1, int a2, int a3)
{
  *(_OWORD *)std::string __p = 0u;
  long long v10 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v5 = (const void **)__p[1];
  if (__p[1] != (void *)v10)
  {
    while (*((unsigned char *)*v5 + 8) != 24)
    {
      if (++v5 == (const void **)v10) {
        goto LABEL_8;
      }
    }
  }
  if (v5 != (const void **)v10)
  {
    if (v6)
    {
      v6[3] = 2;
      if (a3) {
        *qmi::MutableMessageBase::getTLV<nas::tlv::NetworkSelectionPreference>((uint64_t)__p, 22) = 0;
      }
      if ((a2 - 1) >= 3) {
        int v7 = 0;
      }
      else {
        int v7 = a2;
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>(&v8, v7);
    }
    __cxa_bad_cast();
  }
LABEL_8:
  operator new();
}

void sub_22251543C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::setCampOnlyMode(uint64_t a1, uint64_t a2, int a3)
{
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), 1);
  *(_OWORD *)std::string __p = 0u;
  long long v8 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v4 = (const void **)__p[1];
  if (__p[1] != (void *)v8)
  {
    while (*((unsigned char *)*v4 + 8) != 31)
    {
      if (++v4 == (const void **)v8) {
        goto LABEL_8;
      }
    }
  }
  if (v4 != (const void **)v8)
  {
    if (v5)
    {
      void v5[3] = a3;
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>(&v6, 1);
    }
    __cxa_bad_cast();
  }
LABEL_8:
  operator new();
}

void sub_2225157F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  uint64_t v23 = a10;
  a10 = 0;
  if (v23) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v23);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::setProvisioningMode(QMINetworkRegistrationDriver *this, int a2)
{
  (*(void (**)(void, uint64_t))(**((void **)this + 11) + 16))(*((void *)this + 11), 1);
  if (a2)
  {
    long long v3 = 0uLL;
    long long v4 = 0uLL;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v3);
    qmi::ClientRouter::get();
    operator new();
  }
  long long v3 = 0uLL;
  long long v4 = 0uLL;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v3);
  qmi::ClientRouter::get();
  operator new();
}

void sub_222515B9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::getProvisioningMode(uint64_t a1)
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), 1);
  memset(v1, 0, sizeof(v1));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v1);
  qmi::ClientRouter::get();
  operator new();
}

void sub_222515E58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(v23 - 80));
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::enableServingSystemNotificationInLowPower(QMINetworkRegistrationDriver *this)
{
  uint64_t v1 = (QMINetworkRegistrationDriver *)((char *)this + 104);
  qmi::ClientRouter::setIndShouldWake((QMINetworkRegistrationDriver *)((char *)this + 104));
  qmi::ClientRouter::setIndShouldWake(v1);
  return 1;
}

BOOL QMINetworkRegistrationDriver::invalidateNetworkTimeCache(Registry **this)
{
  subscriber::makeSimSlotRange();
  uint64_t v2 = v21;
  if (v21 != v22)
  {
    while ((v23(*v2) & 1) == 0)
    {
      if (++v2 == v22)
      {
        uint64_t v2 = v22;
        break;
      }
    }
    if (v2 != v22)
    {
      BOOL v19 = (QMINetworkRegistrationDriver *)this;
      while (1)
      {
        if ((*v2 - 1) >= 3) {
          uint64_t v3 = 0;
        }
        else {
          uint64_t v3 = *v2;
        }
        long long v4 = (NSObject **)(*(uint64_t (**)(Registry *, uint64_t))(*(void *)this[11] + 16))(this[11], v3);
        memset(v25, 0, sizeof(v25));
        qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v25);
        ServiceMap = (std::mutex *)Registry::getServiceMap(this[6]);
        int v6 = ServiceMap;
        uint64_t v7 = *(void *)(MEMORY[0x263F03588] + 8);
        if (v7 < 0)
        {
          long long v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v9 = 5381;
          do
          {
            uint64_t v7 = v9;
            unsigned int v10 = *v8++;
            uint64_t v9 = (33 * v9) ^ v10;
          }
          while (v10);
        }
        std::mutex::lock(ServiceMap);
        *(void *)int buf = v7;
        uint64_t v11 = std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<void>>>>::find<unsigned long>(&v6[1].__m_.__sig, (unint64_t *)buf);
        if (v11)
        {
          uint64_t v13 = v11[3];
          __int16 v12 = (std::__shared_weak_count *)v11[4];
          if (v12)
          {
            atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v6);
            atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
            std::__shared_weak_count::__release_shared[abi:ne180100](v12);
            if (v13)
            {
              atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_20:
              uint64_t v15 = qmi::MutableMessageBase::getTLV<nas::tlv::NetworkTimeCachePeriod>((uint64_t)v25);
              *(_DWORD *)uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 80))(v13);
              if (v12)
              {
                std::__shared_weak_count::__release_shared[abi:ne180100](v12);
                std::__shared_weak_count::__release_shared[abi:ne180100](v12);
              }
              qmi::ClientRouter::get();
              qmi::ClientRouter::SendProxy::SendProxy<nas::IndicationRegister::Request>(&v24, v3);
            }
            char v14 = 0;
            this = (Registry **)v19;
            goto LABEL_24;
          }
          std::mutex::unlock(v6);
          if (v13) {
            goto LABEL_20;
          }
        }
        else
        {
          std::mutex::unlock(v6);
        }
        __int16 v12 = 0;
        char v14 = 1;
LABEL_24:
        long long v16 = *v4;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl(&dword_22231A000, v16, OS_LOG_TYPE_DEFAULT, "#N Could not get TimeHandlerInterface to invalidate network time cache", buf, 2u);
        }
        if ((v14 & 1) == 0) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v12);
        }
        int v20 = 0;
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v25);
        uint64_t v17 = v2 + 1;
        uint64_t v2 = v22;
        if (v17 != v22)
        {
          uint64_t v2 = v17;
          while ((v23(*v2) & 1) == 0)
          {
            if (++v2 == v22)
            {
              uint64_t v2 = v22;
              break;
            }
          }
        }
        if (v2 == v22) {
          return v20 != 0;
        }
      }
    }
  }
  int v20 = 1;
  return v20 != 0;
}

void sub_22251632C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30)
{
  if (a30) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a30);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v30);
  if (a20) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](a9, a20);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a21);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::enterE911State(uint64_t a1, int a2, uint64_t a3, char a4, char a5, uint64_t a6)
{
  uint64_t v39 = a1;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>(&v40, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  uint64_t v38 = 0;
  long long v36 = 0u;
  *(_OWORD *)uint64_t v37 = 0u;
  uint64_t v34 = a1;
  memset(v35, 0, sizeof(v35));
  std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>(v35, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  LOBYTE(v36) = a4;
  BYTE1(v36) = a5 & ~a4;
  __int16 v12 = v40;
  *((void *)&v36 + 1) = v39;
  v37[0] = 0;
  v37[1] = 0;
  uint64_t v38 = 0;
  uint64_t v13 = (capabilities::ct *)std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>(v37, v40, v41, (v41 - (uint64_t)v40) >> 2);
  if ((capabilities::ct::supportsEmergencyQMIExtensions(v13) & 1) == 0) {
    QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator()(&v39, 1);
  }
  uint64_t v15 = *(int **)a3;
  char v14 = *(int **)(a3 + 8);
  uint64_t v16 = (uint64_t)v14 - *(void *)a3;
  if (v14 == *(int **)a3)
  {
    if (v16 == 4)
    {
      uint64_t v21 = 4;
      goto LABEL_25;
    }
    goto LABEL_35;
  }
  uint64_t v17 = 0;
  uint64_t v18 = v16 >> 2;
  BOOL v19 = *(int **)a3;
  do
  {
    if (!*v19++) {
      ++v17;
    }
  }
  while (v19 != v14);
  if (v18 - v17 == 1)
  {
    uint64_t v21 = 0;
    while (*(int *)((char *)v15 + v21) != 1)
    {
      v21 += 4;
      if ((int *)((char *)v15 + v21) == v14)
      {
        uint64_t v22 = v16 >> 2;
        uint64_t v21 = (uint64_t)v14 - *(void *)a3;
        goto LABEL_24;
      }
    }
    uint64_t v22 = v21 >> 2;
LABEL_24:
    if (&v15[v22] != v14)
    {
LABEL_25:
      int v26 = subscriber::instanceAsSimSlot((subscriber *)((unint64_t)v21 >> 2));
      QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator()((uint64_t)&v34, v26);
    }
    uint64_t v27 = 0;
    while (*(int *)((char *)v15 + v27) != 2)
    {
      v27 += 4;
      if ((int *)((char *)v15 + v27) == v14)
      {
        uint64_t v27 = (uint64_t)v14 - *(void *)a3;
        goto LABEL_31;
      }
    }
    uint64_t v18 = v27 >> 2;
LABEL_31:
    if (&v15[v18] != v14)
    {
      uint64_t v28 = subscriber::instanceAsSimSlot((subscriber *)((unint64_t)v27 >> 2));
      uint64_t v29 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), v28);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v31) = 0;
        _os_log_impl(&dword_22231A000, v29, OS_LOG_TYPE_DEFAULT, "#I Dial on preferred sub with normal setup as the other sub is not usable. Do not query preferred E911 subscription.", (uint8_t *)&v31, 2u);
      }
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 64) + 144))(*(void *)(a1 + 64), (v28 << 32) | 1);
      goto LABEL_38;
    }
LABEL_35:
    if (a2) {
      QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator()((uint64_t)&v34, a2);
    }
    memset(v33, 0, sizeof(v33));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v33);
    qmi::ClientRouter::get();
    int v32 = 1;
    operator new();
  }
  uint64_t v23 = 0;
  do
  {
    int v24 = *v15++;
    if (v24 == 2) {
      ++v23;
    }
  }
  while (v15 != v14);
  if (v23 != 2) {
    goto LABEL_35;
  }
  int v25 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), a6);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v31) = 0;
    _os_log_impl(&dword_22231A000, v25, OS_LOG_TYPE_DEFAULT, "#I Matched as Normal on both subs. Dial on data preferred sub with normal setup. Do not query preferred E911 subscription.", (uint8_t *)&v31, 2u);
  }
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 64) + 144))(*(void *)(a1 + 64), (a6 << 32) | 1);
LABEL_38:
  if (v37[0]) {
    operator delete(v37[0]);
  }
  if (v35[0]) {
    operator delete(v35[0]);
  }
  if (v12) {
    operator delete(v12);
  }
  return 1;
}

void sub_222516970(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30)
{
  QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::~$_1(&a29);
  if (v30) {
    operator delete(v30);
  }
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator()(void *a1, int a2)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  long long v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(*a1 + 88) + 16))(*(void *)(*a1 + 88));
  uint64_t v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Entering E911 state", buf, 2u);
  }
  *(_OWORD *)std::string __p = 0u;
  long long v22 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  int v6 = (capabilities::ct *)qmi::MutableMessageBase::getTLV<nas::tlv::E911StateAction>((uint64_t)__p);
  *(_DWORD *)int v6 = 0;
  if (capabilities::ct::supportsEmergencyQMIExtensions(v6))
  {
    unsigned int v7 = subscriber::simSlotAsInstance();
    long long v8 = (const void *)a1[1];
    uint64_t v9 = a1[2];
    unint64_t v10 = (v9 - (uint64_t)v8) >> 2;
    if (v10 > v7)
    {
      *(void *)int buf = 0;
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>(buf, v8, v9, v10);
      int v26 = v4;
      uint64_t v11 = (const void **)__p[1];
      if (__p[1] != (void *)v22)
      {
        while (*((unsigned char *)*v11 + 8) != 19)
        {
          if (++v11 == (const void **)v22) {
            goto LABEL_12;
          }
        }
      }
      if (v11 == (const void **)v22) {
LABEL_12:
      }
        operator new();
      if (!v12) {
        __cxa_bad_cast();
      }
      uint64_t v13 = v7;
      char v14 = *(void **)buf;
      int v15 = *(_DWORD *)(*(void *)buf + 4 * v13);
      if (v15 == 3) {
        unsigned int v16 = 1;
      }
      else {
        unsigned int v16 = 2 * (v15 == 4);
      }
      void v12[3] = v16;
      uint64_t v17 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = nas::asString(v16);
        int aBlock = 136315138;
        *(void *)aBlock_4 = v18;
        _os_log_impl(&dword_22231A000, v17, OS_LOG_TYPE_DEFAULT, "#I EmergencyType set to %s", (uint8_t *)&aBlock, 0xCu);
      }
      operator delete(v14);
    }
  }
  if ((a2 - 1) >= 3) {
    int v19 = 0;
  }
  else {
    int v19 = a2;
  }
  qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::SetE911State::Request>(&v20, v19);
}

void sub_222516F34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
}

void QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator()(uint64_t a1, int a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  long long v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(*(void *)a1 + 88) + 16))(*(void *)(*(void *)a1 + 88));
  uint64_t v5 = v4;
  int v6 = *(unsigned __int8 *)(a1 + 32);
  if (!*(unsigned char *)(a1 + 32) && !*(unsigned char *)(a1 + 33))
  {
    QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator()((void *)(a1 + 40), a2);
  }
  unsigned int v7 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#I Sending cell avoidance request", (uint8_t *)&buf, 2u);
    int v6 = *(unsigned __int8 *)(a1 + 32);
    unsigned int v7 = *v5;
  }
  if (v6) {
    uint64_t v8 = 3;
  }
  else {
    uint64_t v8 = 2;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int buf = 134217984;
    *(void *)buf_4 = v8;
    _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#I Emergency RAT mask set to 0x%08llx", (uint8_t *)&buf, 0xCu);
  }
  *(_OWORD *)std::string __p = 0u;
  long long v12 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v9 = (const void **)__p[1];
  if (__p[1] != (void *)v12)
  {
    while (*((unsigned char *)*v9 + 8) != 17)
    {
      if (++v9 == (const void **)v12) {
        goto LABEL_17;
      }
    }
  }
  if (v9 != (const void **)v12)
  {
    if (v10)
    {
      _OWORD v10[2] = v8;
      qmi::ClientRouter::get();
      operator new();
    }
    __cxa_bad_cast();
  }
LABEL_17:
  operator new();
}

void sub_2225174A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32)
{
  if (a32) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a32);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v32);
  if (a16) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v33, a16);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a17);
  _Unwind_Resume(a1);
}

void *QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::~$_1(void *a1)
{
  uint64_t v2 = (void *)a1[6];
  if (v2)
  {
    a1[7] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void *QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_2::~$_2(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2)
  {
    a1[11] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[7];
  if (v3)
  {
    a1[8] = v3;
    operator delete(v3);
  }
  long long v4 = (void *)a1[2];
  if (v4)
  {
    a1[3] = v4;
    operator delete(v4);
  }
  return a1;
}

uint64_t QMINetworkRegistrationDriver::exitE911State(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t isValidSimSlot = subscriber::isValidSimSlot();
  if (isValidSimSlot)
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), a2);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Exiting E911 state", (uint8_t *)&buf, 2u);
    }
    memset(v9, 0, sizeof(v9));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v9);
    *(_DWORD *)qmi::MutableMessageBase::getTLV<nas::tlv::E911StateAction>((uint64_t)v9) = 2;
    if ((a2 - 1) >= 3) {
      LODWORD(a2) = 0;
    }
    qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::SetE911State::Request>(&v8, a2);
  }
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
  {
    int buf = 136315138;
    uint64_t buf_4 = subscriber::asString();
    _os_log_fault_impl(&dword_22231A000, v6, OS_LOG_TYPE_FAULT, "Unhandled SIM slot when existing E911 state: %s", (uint8_t *)&buf, 0xCu);
  }
  return isValidSimSlot;
}

void sub_222517874(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  if (a26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a26);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v26);
  uint64_t v28 = a10;
  a10 = 0;
  if (v28) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v28);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::setImsProceedWithSubscriptionChange(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl(&dword_22231A000, v1, OS_LOG_TYPE_DEFAULT, "#I Indicating to baseband that it is OK to proceed with subscription change", buf, 2u);
  }
  memset(v2, 0, sizeof(v2));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v2);
  qmi::ClientRouter::get();
  operator new();
}

void sub_222517AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v20, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::enableIms(uint64_t a1, int a2, int a3)
{
  *(_OWORD *)std::string __p = 0u;
  long long v11 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v5 = (const void **)__p[1];
  if (__p[1] != (void *)v11)
  {
    while (*((unsigned char *)*v5 + 8) != 51)
    {
      if (++v5 == (const void **)v11) {
        goto LABEL_8;
      }
    }
  }
  if (v5 != (const void **)v11)
  {
    if (v6)
    {
      char v7 = a3 == 1;
      if (a3 == 2) {
        char v7 = 2;
      }
      v6[9] = v7;
      if ((a2 - 1) >= 3) {
        int v8 = 0;
      }
      else {
        int v8 = a2;
      }
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>(&v9, v8);
    }
    __cxa_bad_cast();
  }
LABEL_8:
  operator new();
}

void sub_222517EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  uint64_t v23 = a10;
  a10 = 0;
  if (v23) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v23);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::updateVoNRState(uint64_t a1, uint64_t a2, int a3)
{
  *(_OWORD *)std::string __p = 0u;
  long long v7 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  long long v4 = (const void **)__p[1];
  if (__p[1] != (void *)v7)
  {
    while (*((unsigned char *)*v4 + 8) != 1)
    {
      if (++v4 == (const void **)v7) {
        goto LABEL_8;
      }
    }
  }
  if (v4 != (const void **)v7)
  {
    if (v5)
    {
      void v5[3] = a3 == 1;
      qmi::ClientRouter::get();
      operator new();
    }
    __cxa_bad_cast();
  }
LABEL_8:
  operator new();
}

void sub_222518260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::sendDataRoaming(uint64_t a1, int a2, uint64_t a3)
{
  if (a2 != 3)
  {
    *(_OWORD *)std::string __p = 0u;
    long long v14 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    int v9 = (const void **)__p[1];
    if (__p[1] != (void *)v14)
    {
      while (*((unsigned char *)*v9 + 8) != 52)
      {
        if (++v9 == (const void **)v14) {
          goto LABEL_19;
        }
      }
    }
    if (v9 != (const void **)v14)
    {
      if (v10)
      {
        void v10[9] = a3;
        if ((a2 - 1) >= 3) {
          int v11 = 0;
        }
        else {
          int v11 = a2;
        }
        qmi::ClientRouter::get();
        qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>(&v12, v11);
      }
      __cxa_bad_cast();
    }
LABEL_19:
    operator new();
  }
  uint64_t result = subscriber::makeSimSlotRange();
  int v6 = v15;
  if (v15 != v16)
  {
    while (1)
    {
      uint64_t result = v17(*v6);
      if (result) {
        break;
      }
      if (++v6 == v16)
      {
        int v6 = v16;
        break;
      }
    }
LABEL_6:
    while (v6 != v16)
    {
      long long v7 = v6 + 1;
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 240))(a1, *v6, a3);
      int v6 = v16;
      if (v7 != v16)
      {
        int v6 = v7;
        while (1)
        {
          uint64_t result = v17(*v6);
          if (result) {
            break;
          }
          if (++v6 == v16)
          {
            int v6 = v16;
            goto LABEL_6;
          }
        }
      }
    }
  }
  return result;
}

void sub_2225186B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  uint64_t v23 = a10;
  a10 = 0;
  if (v23) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v23);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

BOOL QMINetworkRegistrationDriver::updateIMSStatus(uint64_t a1, uint64_t a2, int a3, int a4, char a5, int a6)
{
  uint64_t v65 = *MEMORY[0x263EF8340];
  unint64_t v10 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
  *(_OWORD *)std::string __p = 0u;
  long long v61 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  int v11 = qmi::MutableMessageBase::getTLV<nas::tlv::IpDataMode>((uint64_t)__p);
  int v12 = v11;
  switch(a4)
  {
    case 1:
    case 2:
      char v13 = 4;
      goto LABEL_15;
    case 3:
    case 4:
    case 5:
      if (a3 == 9) {
        char v13 = 9;
      }
      else {
        char v13 = 5;
      }
      goto LABEL_15;
    case 13:
      char v13 = 2;
      goto LABEL_15;
    case 14:
      goto LABEL_7;
    case 16:
      if (capabilities::ct::supports5G((capabilities::ct *)v11))
      {
LABEL_7:
        char v13 = 8;
        goto LABEL_15;
      }
      char v56 = *v10;
      if (!os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_16;
      }
      LOWORD(buf[0]) = 0;
      goto LABEL_82;
    case 17:
      if (capabilities::ct::supports5G((capabilities::ct *)v11))
      {
        char v13 = 12;
LABEL_15:
        *int v12 = v13;
      }
      else
      {
        char v56 = *v10;
        if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf[0]) = 0;
LABEL_82:
          _os_log_error_impl(&dword_22231A000, v56, OS_LOG_TYPE_ERROR, "Device doesn't support NR", (uint8_t *)buf, 2u);
        }
      }
LABEL_16:
      unsigned int v16 = qmi::MutableMessageBase::getTLV<nas::tlv::IpDataMode>((uint64_t)__p);
      int v17 = *v16;
      if (*v16)
      {
        uint64_t v18 = (const void **)__p[1];
        if (__p[1] != (void *)v61)
        {
          while (*((unsigned char *)*v18 + 8) != 2)
          {
            if (++v18 == (const void **)v61) {
              goto LABEL_24;
            }
          }
        }
        if (v18 == (const void **)v61) {
LABEL_24:
        }
          operator new();
        if (!v19) {
          __cxa_bad_cast();
        }
        uint64_t v20 = (void **)(v19 + 16);
        unint64_t v21 = *((void *)v19 + 4);
        long long v22 = (void *)*((void *)v19 + 3);
        if ((unint64_t)v22 >= v21)
        {
          uint64_t v24 = ((char *)v22 - (unsigned char *)*v20) >> 3;
          if ((unint64_t)(v24 + 1) >> 61) {
            goto LABEL_96;
          }
          uint64_t v25 = v21 - (void)*v20;
          uint64_t v26 = v25 >> 2;
          if (v25 >> 2 <= (unint64_t)(v24 + 1)) {
            uint64_t v26 = v24 + 1;
          }
          if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v27 = v26;
          }
          if (v27) {
            uint64_t v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(v19 + 32), v27);
          }
          else {
            uint64_t v28 = 0;
          }
          uint64_t v29 = &v28[8 * v24];
          char v30 = &v28[8 * v27];
          *(void *)uint64_t v29 = 0;
          uint64_t v23 = v29 + 8;
          long long v31 = (char *)*v20;
          int v19 = (char *)v20[1];
          if (v19 != *v20)
          {
            do
            {
              int v32 = *((_DWORD *)v19 - 2);
              v19 -= 8;
              char v33 = v19[4];
              *((_DWORD *)v29 - 2) = v32;
              v29 -= 8;
              void v29[4] = v33;
            }
            while (v19 != v31);
            int v19 = (char *)*v20;
          }
          *uint64_t v20 = v29;
          v20[1] = v23;
          _OWORD v20[2] = v30;
          if (v19) {
            operator delete(v19);
          }
        }
        else
        {
          *long long v22 = 0;
          uint64_t v23 = v22 + 1;
        }
        v20[1] = v23;
        *((_DWORD *)v23 - 2) = 0;
        *((unsigned char *)v23 - 4) = a5 & 1;
        unint64_t v34 = (unint64_t)v20[2];
        if ((unint64_t)v23 < v34)
        {
          *uint64_t v23 = 0;
          char v35 = v23 + 1;
          goto LABEL_57;
        }
        uint64_t v36 = ((char *)v23 - (unsigned char *)*v20) >> 3;
        if (!((unint64_t)(v36 + 1) >> 61))
        {
          uint64_t v37 = v34 - (void)*v20;
          uint64_t v38 = v37 >> 2;
          if (v37 >> 2 <= (unint64_t)(v36 + 1)) {
            uint64_t v38 = v36 + 1;
          }
          if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v39 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v39 = v38;
          }
          if (v39) {
            uint64_t v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(v20 + 2), v39);
          }
          else {
            uint64_t v40 = 0;
          }
          uint64_t v41 = &v40[8 * v36];
          uint64_t v42 = &v40[8 * v39];
          *(void *)uint64_t v41 = 0;
          char v35 = v41 + 8;
          __int16 v43 = (char *)*v20;
          int v19 = (char *)v20[1];
          if (v19 != *v20)
          {
            do
            {
              int v44 = *((_DWORD *)v19 - 2);
              v19 -= 8;
              char v45 = v19[4];
              *((_DWORD *)v41 - 2) = v44;
              v41 -= 8;
              v41[4] = v45;
            }
            while (v19 != v43);
            int v19 = (char *)*v20;
          }
          *uint64_t v20 = v41;
          v20[1] = v35;
          _OWORD v20[2] = v42;
          if (v19) {
            operator delete(v19);
          }
LABEL_57:
          v20[1] = v35;
          *((_DWORD *)v35 - 2) = 1;
          *((unsigned char *)v35 - 4) = (a5 & 2) != 0;
          char v46 = capabilities::ct::supports5G((capabilities::ct *)v19);
          if (a6) {
            char v47 = v46;
          }
          else {
            char v47 = 0;
          }
          if (v47)
          {
            if (a6 == -1) {
              int v48 = 2;
            }
            else {
              int v48 = 1;
            }
            if (a5) {
              int v49 = 0;
            }
            else {
              int v49 = v48;
            }
            uint64_t v50 = *v10;
            if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
            {
              __int16 v51 = nas::asString(v49);
              buf[0] = 136315394;
              *(void *)&buf[1] = v51;
              __int16 v63 = 1024;
              LODWORD(v64) = a6;
              _os_log_impl(&dword_22231A000, v50, OS_LOG_TYPE_DEFAULT, "#I Updating baseband with IMS registration end cause %s and retry interval: %u", (uint8_t *)buf, 0x12u);
            }
            uint64_t v52 = (const void **)__p[1];
            uint64_t v53 = (const void **)v61;
            uint64_t v54 = (const void **)__p[1];
            if (__p[1] != (void *)v61)
            {
              uint64_t v54 = (const void **)__p[1];
              while (*((unsigned char *)*v54 + 8) != 16)
              {
                if (++v54 == (const void **)v61) {
                  goto LABEL_77;
                }
              }
            }
            if (v54 == (const void **)v61) {
LABEL_77:
            }
              operator new();
            if (!v55) {
              __cxa_bad_cast();
            }
            v55[3] = v49;
            while (1)
            {
              if (v52 == v53) {
                goto LABEL_89;
              }
              if (*((unsigned char *)*v52 + 8) == 17) {
                break;
              }
              ++v52;
            }
            if (v52 == v53) {
LABEL_89:
            }
              operator new();
            if (!v57) {
              __cxa_bad_cast();
            }
            if (a5) {
              int v58 = 0;
            }
            else {
              int v58 = a6;
            }
            v57[3] = v58;
          }
          qmi::ClientRouter::get();
          operator new();
        }
LABEL_96:
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
      return v17 != 0;
    case 18:
      if (!capabilities::ct::supports5G((capabilities::ct *)v11)) {
        goto LABEL_10;
      }
      char v13 = 6;
      goto LABEL_15;
    default:
LABEL_10:
      long long v14 = *v10;
      if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = asString();
        buf[0] = 136315138;
        *(void *)&buf[1] = v15;
        _os_log_impl(&dword_22231A000, v14, OS_LOG_TYPE_DEFAULT, "#I Cannot update IMS status - Invalid Data Mode: (%s)", (uint8_t *)buf, 0xCu);
      }
      goto LABEL_16;
  }
}

void sub_222519168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::update5GStandaloneInfo(capabilities::ct *a1, uint64_t a2, char a3)
{
  uint64_t v6 = capabilities::ct::supports5G(a1);
  if (v6)
  {
    (*(void (**)(void *, uint64_t))(**((void **)a1 + 11) + 16))(*((void **)a1 + 11), a2);
    *(_OWORD *)std::string __p = 0u;
    long long v11 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    long long v7 = (const void **)__p[1];
    if (__p[1] != (void *)v11)
    {
      while (*((unsigned char *)*v7 + 8) != 16)
      {
        if (++v7 == (const void **)v11) {
          goto LABEL_9;
        }
      }
    }
    if (v7 != (const void **)v11)
    {
      if (v8)
      {
        void v8[9] = a3;
        qmi::ClientRouter::get();
        operator new();
      }
      __cxa_bad_cast();
    }
LABEL_9:
    operator new();
  }
  return v6;
}

void sub_2225195E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::triggerClosedSubscriberGroupSearch(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  int v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
  *(_OWORD *)std::string __p = 0u;
  long long v15 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  int v9 = (const void **)__p[1];
  if (__p[1] != (void *)v15)
  {
    while (*((unsigned char *)*v9 + 8) != 1)
    {
      if (++v9 == (const void **)v15) {
        goto LABEL_8;
      }
    }
  }
  if (v9 != (const void **)v15)
  {
    if (v10)
    {
      unint64_t v10[3] = a4;
      long long v11 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = a4;
        _os_log_impl(&dword_22231A000, v11, OS_LOG_TYPE_DEFAULT, "#I Sending CSG ID %d", buf, 8u);
      }
      char v13 = (std::__shared_weak_count *)operator new(0x50uLL);
      v13->__shared_weak_owners_ = 0;
      v13->__shared_owners_ = 0;
      v13->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7518;
      LOBYTE(v13[1].__vftable) = *(unsigned char *)a6;
      *(_OWORD *)&v13[1].__shared_owners_ = *(_OWORD *)(a6 + 8);
      v13[2].__vftable = *(std::__shared_weak_count_vtbl **)(a6 + 24);
      *(void *)(a6 + 8) = 0;
      *(void *)(a6 + 16) = 0;
      *(void *)(a6 + 24) = 0;
      LODWORD(v13[2].__shared_owners_) = *(_DWORD *)(a6 + 32);
      *(_OWORD *)&v13[2].__shared_weak_owners_ = *(_OWORD *)(a6 + 40);
      *(void *)(a6 + 40) = 0;
      *(void *)(a6 + 48) = 0;
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v13);
      qmi::ClientRouter::get();
      operator new();
    }
    __cxa_bad_cast();
  }
LABEL_8:
  operator new();
}

void sub_222519B74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if (a3) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v4, a3);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::triggerClosedSubscriberGroupSearch(subscriber::SimSlot,std::string,int,std::optional<MCCAndMNC>,ctu::rest::command_responder_t<CSGSearchResponse> &&)::$_1::~$_1(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void QMINetworkRegistrationDriver::sendCommCenterStartsSincePowerCycle(QMINetworkRegistrationDriver *this, int a2)
{
  *(_OWORD *)std::string __p = 0u;
  long long v7 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  uint64_t v3 = (const void **)__p[1];
  if (__p[1] != (void *)v7)
  {
    while (*((unsigned char *)*v3 + 8) != 53)
    {
      if (++v3 == (const void **)v7) {
        goto LABEL_8;
      }
    }
  }
  if (v3 != (const void **)v7)
  {
    if (v4)
    {
      v4[9] = (a2 == 1) & (QMINetworkRegistrationDriver::sendCommCenterStartsSincePowerCycle::sAlreadySentRequest ^ 1);
      QMINetworkRegistrationDriver::sendCommCenterStartsSincePowerCycle::sAlreadySentRequest = 1;
      qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>(&v5, 1);
    }
    __cxa_bad_cast();
  }
LABEL_8:
  operator new();
}

void sub_222519FB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  uint64_t v23 = a10;
  a10 = 0;
  if (v23) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v23);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::setGeoMccs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = subscriber::makeSimSlotRange();
  uint64_t v6 = v38;
  if (v38 != v39)
  {
    while (1)
    {
      uint64_t result = v40(*v6);
      if (result) {
        break;
      }
      if (++v6 == v39)
      {
        uint64_t v6 = v39;
        break;
      }
    }
    if (v6 != v39)
    {
      (*(void (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
      long long v41 = 0u;
      long long v42 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v41);
      std::string __p = 0;
      int v44 = 0;
      uint64_t v45 = 0;
      std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(&__p, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 1);
      long long v7 = (const void **)*((void *)&v41 + 1);
      if (*((void *)&v41 + 1) != (void)v42)
      {
        while (*((unsigned char *)*v7 + 8) != 16)
        {
          if (++v7 == (const void **)v42) {
            goto LABEL_13;
          }
        }
      }
      if (v7 != (const void **)v42)
      {
        if (!v8) {
          __cxa_bad_cast();
        }
        int v9 = v8 + 10;
        unint64_t v10 = (char *)__p;
        *int v9 = *(_WORD *)__p;
        int v44 = v10;
        operator delete(v10);
        std::string __p = 0;
        int v44 = 0;
        uint64_t v45 = 0;
        std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(&__p, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 1);
        long long v11 = (const void **)*((void *)&v41 + 1);
        int v12 = (const void **)v42;
        if (*((void *)&v41 + 1) != (void)v42)
        {
          while (*((unsigned char *)*v11 + 8) != 17)
          {
            if (++v11 == (const void **)v42) {
              goto LABEL_21;
            }
          }
        }
        if (v11 != (const void **)v42)
        {
          if (!v13) {
            __cxa_bad_cast();
          }
          long long v14 = (int *)(v13 + 12);
          long long v15 = (char *)__p;
          if (v44 - (unsigned char *)__p == 2) {
            int v16 = 4;
          }
          else {
            int v16 = 2 * (v44 - (unsigned char *)__p == 4);
          }
          *long long v14 = v16;
          if (v15)
          {
            int v44 = v15;
            operator delete(v15);
            int v12 = (const void **)v42;
          }
          for (uint64_t i = (const void **)*((void *)&v41 + 1); ; ++i)
          {
            if (i == v12) {
              goto LABEL_34;
            }
            if (*((unsigned char *)*i + 8) == 18) {
              break;
            }
          }
          if (i != v12)
          {
            if (!v18) {
              __cxa_bad_cast();
            }
            void v18[3] = 0;
            int v19 = *(const void **)a3;
            uint64_t v20 = *(void *)(a3 + 8);
            uint64_t v21 = v20 - *(void *)a3;
            if ((unint64_t)v21 >= 3)
            {
              std::string __p = 0;
              int v44 = 0;
              uint64_t v45 = 0;
              std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(&__p, v19, v20, v21 >> 1);
              long long v22 = (const void **)*((void *)&v41 + 1);
              if (*((void *)&v41 + 1) != (void)v42)
              {
                while (*((unsigned char *)*v22 + 8) != 19)
                {
                  if (++v22 == (const void **)v42) {
                    goto LABEL_43;
                  }
                }
              }
              if (v22 == (const void **)v42) {
LABEL_43:
              }
                operator new();
              if (!v23) {
                __cxa_bad_cast();
              }
              uint64_t v24 = v23 + 16;
              uint64_t v25 = v44;
              uint64_t v26 = (char *)__p + 2;
              int64_t v27 = v44 - ((unsigned char *)__p + 2);
              unint64_t v28 = v27 >> 1;
              unint64_t v29 = *((void *)v23 + 4);
              char v30 = (char *)*v24;
              if (v27 >> 1 <= (unint64_t)((uint64_t)(v29 - *v24) >> 1))
              {
                char v33 = (void **)(v23 + 24);
                char v35 = (unsigned char *)*((void *)v23 + 3);
                unint64_t v36 = (v35 - v30) >> 1;
                if (v36 >= v28)
                {
                  if (v44 != v26) {
                    memmove(v30, (char *)__p + 2, v44 - ((unsigned char *)__p + 2));
                  }
                }
                else
                {
                  if (v35 != v30)
                  {
                    memmove(v30, (char *)__p + 2, v35 - v30);
                    char v30 = (char *)*v33;
                  }
                  uint64_t v37 = &v26[2 * v36];
                  int64_t v27 = v25 - v37;
                  if (v25 != v37) {
                    memmove(v30, v37, v25 - v37);
                  }
                }
              }
              else
              {
                if (v30)
                {
                  *((void *)v23 + 3) = v30;
                  operator delete(v30);
                  unint64_t v29 = 0;
                  *uint64_t v24 = 0;
                  v24[1] = 0;
                  _OWORD v24[2] = 0;
                }
                if (v27 < 0) {
                  std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                }
                if (v29 <= v28) {
                  uint64_t v31 = v27 >> 1;
                }
                else {
                  uint64_t v31 = v29;
                }
                if (v29 >= 0x7FFFFFFFFFFFFFFELL) {
                  uint64_t v32 = 0x7FFFFFFFFFFFFFFFLL;
                }
                else {
                  uint64_t v32 = v31;
                }
                std::vector<unsigned short>::__vallocate[abi:ne180100](v24, v32);
                unint64_t v34 = (char *)v24[1];
                char v33 = (void **)(v24 + 1);
                char v30 = v34;
                if (v25 != v26) {
                  memmove(v30, v26, v27);
                }
              }
              *char v33 = &v30[v27];
              if (__p)
              {
                int v44 = (char *)__p;
                operator delete(__p);
              }
            }
            qmi::ClientRouter::get();
            operator new();
          }
LABEL_34:
          operator new();
        }
LABEL_21:
        operator new();
      }
LABEL_13:
      operator new();
    }
  }
  return result;
}

void sub_22251AAC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
}

void QMINetworkRegistrationDriver::setSatelliteSystemConfig(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (a2)
  {
    *(_OWORD *)std::string __p = 0u;
    long long v13 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    uint64_t v6 = (const void **)__p[1];
    if (__p[1] != (void *)v13)
    {
      while (*((unsigned char *)*v6 + 8) != 17)
      {
        if (++v6 == (const void **)v13) {
          goto LABEL_11;
        }
      }
    }
    if (v6 != (const void **)v13)
    {
      if (v7)
      {
        v7[9] = *a3 != 0;
        int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), a2);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = asString();
          int buf = 136315138;
          uint64_t buf_4 = v11;
          _os_log_impl(&dword_22231A000, v9, OS_LOG_TYPE_DEFAULT, "#I Sending set satellite system config info: %s", (uint8_t *)&buf, 0xCu);
        }
        qmi::ClientRouter::get();
        operator new();
      }
      __cxa_bad_cast();
    }
LABEL_11:
    operator new();
  }
  int v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    int buf = 136315138;
    uint64_t buf_4 = subscriber::asString();
    _os_log_error_impl(&dword_22231A000, v8, OS_LOG_TYPE_ERROR, "Set satellite system config info does not support slot: %s", (uint8_t *)&buf, 0xCu);
  }
}

void sub_22251AFD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::bootstrap(uint64_t a1, dispatch_object_t *a2, uint64_t a3)
{
  int v5 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v5);
  }
  uint64_t v6 = *(void *)(a3 + 8);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  long long v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMINetworkRegistrationDriver::start(QMINetworkRegistrationDriver *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void QMINetworkRegistrationDriver::shutdown(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void ServingSystem::System::~System(void **this)
{
  if (*((unsigned char *)this + 88) && *((char *)this + 87) < 0) {
    operator delete(this[8]);
  }
  if (*((unsigned char *)this + 48))
  {
    if (*((char *)this + 47) < 0) {
      operator delete(this[3]);
    }
  }
}

void ServingSystem::GSMSystem::~GSMSystem(void **this)
{
  if (*((unsigned char *)this + 72) && *((char *)this + 71) < 0) {
    operator delete(this[6]);
  }
  if (*((unsigned char *)this + 32))
  {
    if (*((char *)this + 31) < 0) {
      operator delete(this[1]);
    }
  }
}

void OperatorNameUpdate::OperatorNameUpdate(std::string *this, const OperatorNameUpdate *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *(_OWORD *)a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(this + 1, *((const std::string::value_type **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(_OWORD *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((void *)a2 + 5);
    *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = v5;
  }
  if (*((char *)a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(this + 2, *((const std::string::value_type **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v6 = *((_OWORD *)a2 + 3);
    this[2].__r_.__value_.__r.__words[2] = *((void *)a2 + 8);
    *(_OWORD *)&this[2].__r_.__value_.__l.__data_ = v6;
  }
  this[3].__r_.__value_.__r.__words[0] = *((void *)a2 + 9);
  std::__optional_copy_base<MCC,false>::__optional_copy_base[abi:ne180100](&this[3].__r_.__value_.__s.__data_[8], (uint64_t)a2 + 80);
  std::__optional_copy_base<MNC,false>::__optional_copy_base[abi:ne180100]((MCC *)&this[5], (const OperatorNameUpdate *)((char *)a2 + 120));
  long long v7 = (std::string *)((char *)this + 160);
  if (*((char *)a2 + 183) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *((const std::string::value_type **)a2 + 20), *((void *)a2 + 21));
  }
  else
  {
    long long v8 = *((_OWORD *)a2 + 10);
    this[7].__r_.__value_.__l.__size_ = *((void *)a2 + 22);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
}

void sub_22251B510(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 152) && *(char *)(v1 + 151) < 0) {
    operator delete(*(void **)(v1 + 128));
  }
  if (*(unsigned char *)(v1 + 112) && *(char *)(v1 + 111) < 0) {
    operator delete(*(void **)(v1 + 88));
  }
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void OperatorNameUpdate::~OperatorNameUpdate(void **this)
{
  if (*((char *)this + 183) < 0) {
    operator delete(this[20]);
  }
  if (*((unsigned char *)this + 152) && *((char *)this + 151) < 0) {
    operator delete(this[16]);
  }
  if (*((unsigned char *)this + 112) && *((char *)this + 111) < 0) {
    operator delete(this[11]);
  }
  if (*((char *)this + 71) < 0) {
    operator delete(this[6]);
  }
  if (*((char *)this + 47) < 0) {
    operator delete(this[3]);
  }
  if (*((char *)this + 23) < 0) {
    operator delete(*this);
  }
}

void *std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v5 = result;
    if (a4 >> 62) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t result = operator new(4 * a4);
    long long v8 = result;
    *long long v5 = result;
    v5[1] = result;
    _DWORD v5[2] = (char *)result + 4 * a4;
    size_t v9 = a3 - (void)a2;
    if (v9) {
      uint64_t result = memcpy(result, a2, v9);
    }
    v5[1] = (char *)v8 + v9;
  }
  return result;
}

void sub_22251B6B8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::E911StateAction>(uint64_t a1)
{
  uint64_t v1 = *(const void ***)(a1 + 8);
  uint64_t v2 = *(const void ***)(a1 + 16);
  if (v1 != v2)
  {
    while (*((unsigned char *)*v1 + 8) != 1)
    {
      if (++v1 == v2) {
        goto LABEL_8;
      }
    }
  }
  if (v1 == v2) {
LABEL_8:
  }
    operator new();
  if (!v3) {
    __cxa_bad_cast();
  }
  return v3 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911StateAction>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911StateAction>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911StateAction>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  long long v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  long long v7 = (char *)(*a2 - v5);
  *(unsigned char *)long long v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911StateAction>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyType>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyType>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyType>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  long long v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  long long v7 = (char *)(*a2 - v5);
  *(unsigned char *)long long v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyType>::clone()
{
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNSt3__16vectorI18EmergencySetupTypeNS6_9allocatorIS8_EEEEbbS5_bENK3__0clES5_EUlRKNS_12ResponseBaseEE_EEOS1_OT__block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    char v3 = *(uint64_t **)(result + 32);
    uint64_t v4 = *v3;
    uint64_t v5 = *(NSObject **)v3[2];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 67109378;
      v6[1] = v2;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#N Enter E911 state failed: Error in response with code %d (%s)", (uint8_t *)v6, 0x12u);
      uint64_t v5 = *(NSObject **)v3[2];
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v6[0]) = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I E911 state enter failed, send ready indication", (uint8_t *)v6, 2u);
    }
    return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(v4 + 64) + 136))(*(void *)(v4 + 64), 1, *((unsigned int *)v3 + 2));
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c198_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNS_6vectorI18EmergencySetupTypeNS_9allocatorIS5_EEEEbbS3_bENK3__0clES3_EUlRKN3qmi12ResponseBaseEE_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c198_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNS_6vectorI18EmergencySetupTypeNS_9allocatorIS5_EEEEbbS3_bENK3__0clES3_EUlRKN3qmi12ResponseBaseEE_EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1},std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5738;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1},std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5738;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::AvoidRat>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::AvoidRat>::getSize()
{
  return tlv::size<wds::tlv::ProfileTypeMask>();
}

void **qmi::MutableMessageBase::TlvWrapper<nas::tlv::AvoidRat>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (void *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::ProfileTypeMask>((void **)a2, (void *)(a1 + 16));
  __int16 v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::AvoidRat>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNSt3__16vectorI18EmergencySetupTypeNS6_9allocatorIS8_EEEEbbS5_bENK3__1clES5_EUlRKNS_12ResponseBaseEE_EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  if (v3)
  {
    uint64_t v4 = **(NSObject ***)(v2 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 67109378;
      v5[1] = v3;
      __int16 v6 = 2080;
      uint64_t v7 = qmi::asString();
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#N Sending cell avoidance request failed: Error in response with code %d (%s)", (uint8_t *)v5, 0x12u);
    }
  }
  QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator()((void *)(v2 + 16), *(_DWORD *)v2);
}

uint64_t __copy_helper_block_e8_32c198_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNS_6vectorI18EmergencySetupTypeNS_9allocatorIS5_EEEEbbS3_bENK3__1clES3_EUlRKN3qmi12ResponseBaseEE_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c198_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNS_6vectorI18EmergencySetupTypeNS_9allocatorIS5_EEEEbbS3_bENK3__1clES3_EUlRKN3qmi12ResponseBaseEE_EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1},std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5808;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1},std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5808;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1},std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1}>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_pointer<QMINetworkRegistrationDriver *,std::shared_ptr<QMINetworkRegistrationDriver> ctu::SharedSynchronizable<NetworkRegistrationDriver>::make_shared_ptr<QMINetworkRegistrationDriver>(QMINetworkRegistrationDriver*)::{lambda(QMINetworkRegistrationDriver *)#1},std::allocator<QMINetworkRegistrationDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<QMINetworkRegistrationDriver *,std::shared_ptr<QMINetworkRegistrationDriver> ctu::SharedSynchronizable<NetworkRegistrationDriver>::make_shared_ptr<QMINetworkRegistrationDriver>(QMINetworkRegistrationDriver*)::{lambda(QMINetworkRegistrationDriver *)#1},std::allocator<QMINetworkRegistrationDriver>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<QMINetworkRegistrationDriver *,std::shared_ptr<QMINetworkRegistrationDriver> ctu::SharedSynchronizable<NetworkRegistrationDriver>::make_shared_ptr<QMINetworkRegistrationDriver>(QMINetworkRegistrationDriver*)::{lambda(QMINetworkRegistrationDriver *)#1},std::allocator<QMINetworkRegistrationDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMINetworkRegistrationDriver> ctu::SharedSynchronizable<NetworkRegistrationDriver>::make_shared_ptr<QMINetworkRegistrationDriver>(QMINetworkRegistrationDriver*)::{lambda(QMINetworkRegistrationDriver*)#1}::operator() const(QMINetworkRegistrationDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkRegistrationDriver>::execute_wrapped<QMINetworkRegistrationDriver::create(std::shared_ptr<Registry const> const&,dispatch::workloop)::$_0>(QMINetworkRegistrationDriver::create(std::shared_ptr<Registry const> const&,dispatch::workloop)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkRegistrationDriver::create(std::shared_ptr<Registry const> const&,dispatch::workloop)::$_0,std::default_delete<QMINetworkRegistrationDriver::create(std::shared_ptr<Registry const> const&,dispatch::workloop)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I Initializing command driver", (uint8_t *)&buf, 2u);
  }
  subscriber::makeSimSlotRange();
  uint64_t v4 = v17;
  if (v17 != v18)
  {
    while ((v19(*v4) & 1) == 0)
    {
      if (++v4 == v18)
      {
        uint64_t v4 = v18;
        break;
      }
    }
    while (v4 != v18)
    {
      if (*v4 == 1)
      {
        uint64_t v5 = "registration.1";
      }
      else if (*v4 == 2)
      {
        uint64_t v5 = "registration.2";
      }
      else
      {
        uint64_t v5 = 0;
      }
      __int16 v6 = *(std::__shared_weak_count **)(v2 + 16);
      if (!v6 || (uint64_t v7 = *(void *)(v2 + 8), (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
        std::__throw_bad_weak_ptr[abi:ne180100]();
      }
      uint64_t v9 = v8;
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
      Registry::getServerConnection((uint64_t *)&v20, *(Registry **)(v2 + 48));
      long long buf = 0u;
      long long v30 = 0u;
      std::string::basic_string[abi:ne180100]<0>(v21, v5);
      unint64_t v10 = *(NSObject **)(v2 + 24);
      dispatch_object_t v28 = v10;
      if (v10) {
        dispatch_retain(v10);
      }
      std::string::basic_string[abi:ne180100]<0>(&__p, "registration");
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      uint64_t v11 = std::__shared_weak_count::lock(v9);
      if (v11)
      {
        int v12 = v11;
        atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        uint64_t v24 = v7;
        uint64_t v25 = v11;
        std::__shared_weak_count::__release_weak(v9);
        std::__shared_weak_count::__release_shared[abi:ne180100](v12);
      }
      else
      {
        uint64_t v24 = 0;
        uint64_t v25 = 0;
        std::__shared_weak_count::__release_weak(v9);
      }
      long long v23 = v20;
      long long v20 = 0uLL;
      qmi::Client::createWithQueueLocal();
      if (*((void *)&v23 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v23 + 1));
      }
      if (v25) {
        std::__shared_weak_count::__release_weak(v25);
      }
      if (v27 < 0) {
        operator delete(__p);
      }
      if (v28) {
        dispatch_release(v28);
      }
      if (SBYTE7(v22) < 0) {
        operator delete(v21[0]);
      }
      v21[0] = 0;
      v21[1] = 0;
      long long v22 = v30;
      long long v30 = 0uLL;
      qmi::ClientRouter::addClient();
      qmi::Client::~Client((qmi::Client *)v21);
      qmi::ClientRouter::get();
      qmi::Client::~Client((qmi::Client *)&buf);
      if (*((void *)&v20 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v20 + 1));
      }
      long long v13 = v4 + 1;
      uint64_t v4 = v18;
      if (v13 != v18)
      {
        uint64_t v4 = v13;
        while ((v19(*v4) & 1) == 0)
        {
          if (++v4 == v18)
          {
            uint64_t v4 = v18;
            break;
          }
        }
      }
    }
  }
  std::unique_ptr<Mav20PreferredNetworksFactoryCommandDriver::create(std::shared_ptr<Registry const>,dispatch::queue)::$_0,std::default_delete<Mav20PreferredNetworksFactoryCommandDriver::create(std::shared_ptr<Registry const>,dispatch::queue)::$_0>>::~unique_ptr[abi:ne180100](&v16);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v15);
}

void sub_22251C250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
}

void SimInstanceLoggable<QMINetworkRegistrationDriver,ctu::OsLogLogger,subscriber::SimSlot>::~SimInstanceLoggable()
{
}

uint64_t SimInstanceLoggable<QMINetworkRegistrationDriver,ctu::OsLogLogger,subscriber::SimSlot>::getLoggerForSlot(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver24bindNASSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)v2;
  unsigned int v4 = *(_DWORD *)(v2 + 8);
  if (v4 - 1 >= 3) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*(_DWORD *)(a2 + 4))
  {
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 88) + 16))(*(void *)(v3 + 88), v5);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = qmi::asString();
      int v9 = *(_DWORD *)(a2 + 4);
      buf[0] = 136315394;
      *(void *)&buf[1] = v8;
      __int16 v11 = 1024;
      LODWORD(v12) = v9;
      _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#N Error binding NAS subscription: %s (0x%x)", (uint8_t *)buf, 0x12u);
    }
  }
  QMINetworkRegistrationDriver::sendIndRegisterReq_sync(v3, *(unsigned int *)(v2 + 8));
}

void sub_22251C5F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  if (a26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a26);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  if (a10) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v26, a10);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver24bindNASSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver24bindNASSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMINetworkRegistrationDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5928;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMINetworkRegistrationDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5928;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_7(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  cast_message_type<nas::BindSubscription::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_22251C76C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnModeBit>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnModeBit>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnModeBit>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnModeBit>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CurrentPlmnNameEvent>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CurrentPlmnNameEvent>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CurrentPlmnNameEvent>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CurrentPlmnNameEvent>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeEvents>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeEvents>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeEvents>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeEvents>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::NetworkTimeCachePeriod>(uint64_t a1)
{
  uint64_t v1 = *(const void ***)(a1 + 8);
  uint64_t v2 = *(const void ***)(a1 + 16);
  if (v1 != v2)
  {
    while (*((unsigned __int8 *)*v1 + 8) != 192)
    {
      if (++v1 == v2) {
        goto LABEL_8;
      }
    }
  }
  if (v1 == v2) {
LABEL_8:
  }
    operator new();
  if (!v3) {
    __cxa_bad_cast();
  }
  return v3 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeCachePeriod>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeCachePeriod>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeCachePeriod>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)unsigned int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeCachePeriod>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpPrefStatus>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpPrefStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpPrefStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpPrefStatus>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::SubscriptionChangeIndications>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::SubscriptionChangeIndications>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::SubscriptionChangeIndications>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::SubscriptionChangeIndications>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ReadyStatus>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ReadyStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ReadyStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ReadyStatus>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::T3402TimerChange>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::T3402TimerChange>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::T3402TimerChange>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::T3402TimerChange>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkRejectIndications>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkRejectIndications>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkRejectIndications>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::ProfileIdentifer>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkRejectIndications>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableStatusIndication>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableStatusIndication>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableStatusIndication>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableStatusIndication>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::GeoPlmnIndication>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::GeoPlmnIndication>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::GeoPlmnIndication>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::GeoPlmnIndication>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ScanFailInd>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ScanFailInd>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ScanFailInd>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ScanFailInd>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver23sendIndRegisterReq_syncENS_16SubscriptionTypeEE4__15EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    char v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N Register for indications failed: Error in response with code %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver23sendIndRegisterReq_syncEN3qmi16SubscriptionTypeEE4__15EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver23sendIndRegisterReq_syncEN3qmi16SubscriptionTypeEE4__15EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendIndRegisterReq_sync(qmi::SubscriptionType)::$_15,std::allocator<QMINetworkRegistrationDriver::sendIndRegisterReq_sync(qmi::SubscriptionType)::$_15>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5D68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendIndRegisterReq_sync(qmi::SubscriptionType)::$_15,std::allocator<QMINetworkRegistrationDriver::sendIndRegisterReq_sync(qmi::SubscriptionType)::$_15>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5D68;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyMode>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyMode>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyMode>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unsigned int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyMode>::clone()
{
}

os_log_t *___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver16setEmergencyModeEbE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  char v3 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v4 = *(void *)v3;
  uint64_t result = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v3 + 88) + 16))(*(void *)(*(void *)v3 + 88), 1);
  int v6 = *(_DWORD *)(a2 + 4);
  if (v6)
  {
    uint64_t v7 = *result;
    if (os_log_type_enabled(*result, OS_LOG_TYPE_DEFAULT))
    {
      v9[0] = 67109378;
      v9[1] = v6;
      __int16 v10 = 2080;
      uint64_t v11 = qmi::asString();
      _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#N Set emergency mode failed: Error in response with code %d (%s)", (uint8_t *)v9, 0x12u);
      int v6 = *(_DWORD *)(a2 + 4);
    }
    if (v6 == 26) {
      unint64_t v8 = ((unint64_t)v3[8] << 8) | 1;
    }
    else {
      unint64_t v8 = 0;
    }
    return (os_log_t *)(*(uint64_t (**)(void, uint64_t, unint64_t))(**(void **)(v4 + 64) + 24))(*(void *)(v4 + 64), 1, v8);
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c83_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver16setEmergencyModeEbE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c83_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver16setEmergencyModeEbE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setEmergencyMode(BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::setEmergencyMode(BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5E38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setEmergencyMode(BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::setEmergencyMode(BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5E38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable2G>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable2G>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable2G>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable2G>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver8enable2GEN10subscriber7SimSlotEb16SetMaxRateSourceE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  char v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 32) + 88) + 16))(*(void *)(**(void **)(a1 + 32) + 88), *(unsigned int *)(*(void *)(a1 + 32) + 8));
  int v4 = *(_DWORD *)(a2 + 4);
  if (v4) {
    BOOL v5 = v4 == 26;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    int v6 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      v8[0] = 67109378;
      v8[1] = v4;
      __int16 v9 = 2080;
      uint64_t v10 = qmi::asString();
      _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#N Set 2G enable failed: Error in response with code %d (%s)", (uint8_t *)v8, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver8enable2GEN10subscriber7SimSlotEb16SetMaxRateSourceE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver8enable2GEN10subscriber7SimSlotEb16SetMaxRateSourceE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable2G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1,std::allocator<QMINetworkRegistrationDriver::enable2G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5F08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable2G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1,std::allocator<QMINetworkRegistrationDriver::enable2G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5F08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable3G>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable3G>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable3G>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable3G>::clone()
{
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver8enable3GEN10subscriber7SimSlotEb16SetMaxRateSourceE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  char v3 = *(uint64_t **)(a1 + 32);
  uint64_t v4 = *v3;
  uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(*v3 + 88) + 16))(*(void *)(*v3 + 88), *((unsigned int *)v3 + 2));
  int v6 = *(_DWORD *)(a2 + 4);
  if (v6) {
    BOOL v7 = v6 == 26;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    unint64_t v8 = *(uint64_t (**)(void))(**(void **)(v4 + 64) + 112);
    return v8();
  }
  else
  {
    uint64_t v10 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      v12[0] = 67109378;
      v12[1] = v6;
      __int16 v13 = 2080;
      uint64_t v14 = qmi::asString();
      _os_log_impl(&dword_22231A000, v10, OS_LOG_TYPE_DEFAULT, "#N Set 3G enable failed: Error in response with code %d (%s)", (uint8_t *)v12, 0x12u);
    }
    return (*(uint64_t (**)(void, void, void, void))(**(void **)(v4 + 64) + 112))(*(void *)(v4 + 64), *((unsigned int *)v3 + 2), 0, *((unsigned __int8 *)v3 + 12));
  }
}

uint64_t __copy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver8enable3GEN10subscriber7SimSlotEb16SetMaxRateSourceE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver8enable3GEN10subscriber7SimSlotEb16SetMaxRateSourceE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable3G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1,std::allocator<QMINetworkRegistrationDriver::enable3G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5FD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable3G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1,std::allocator<QMINetworkRegistrationDriver::enable3G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D5FD8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTE>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTE>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTE>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  BOOL v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTE>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTEUpdateReason>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTEUpdateReason>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTEUpdateReason>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::IPPref>((unsigned char **)a2, (_DWORD *)(a1 + 12));
  BOOL v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTEUpdateReason>::clone()
{
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver9enableLTEEN10subscriber7SimSlotEb16SetMaxRateSourceE3__2EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  int v4 = *(_DWORD *)(a2 + 4);
  if (v4)
  {
    uint64_t v5 = *(NSObject **)v2[2];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v8[0] = 67109378;
      v8[1] = v4;
      __int16 v9 = 2080;
      uint64_t v10 = qmi::asString();
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#N Set LTE enable failed: Error in response with code %d (%s)", (uint8_t *)v8, 0x12u);
    }
    return (*(uint64_t (**)(void, void, void, void))(**(void **)(v3 + 64) + 104))(*(void *)(v3 + 64), *((unsigned int *)v2 + 2), 0, *((unsigned __int8 *)v2 + 12));
  }
  else
  {
    BOOL v7 = *(uint64_t (**)(void))(**(void **)(v3 + 64) + 104);
    return v7();
  }
}

uint64_t __copy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver9enableLTEEN10subscriber7SimSlotEb16SetMaxRateSourceE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver9enableLTEEN10subscriber7SimSlotEb16SetMaxRateSourceE3__2EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enableLTE(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2,std::allocator<QMINetworkRegistrationDriver::enableLTE(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D60F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enableLTE(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2,std::allocator<QMINetworkRegistrationDriver::enableLTE(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D60F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNr>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNr>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNr>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  BOOL v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNr>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::EnableNrUpdateReason>(uint64_t a1)
{
  uint64_t v1 = *(const void ***)(a1 + 8);
  uint64_t v2 = *(const void ***)(a1 + 16);
  if (v1 != v2)
  {
    while (*((unsigned __int8 *)*v1 + 8) != 164)
    {
      if (++v1 == v2) {
        goto LABEL_8;
      }
    }
  }
  if (v1 == v2) {
LABEL_8:
  }
    operator new();
  if (!v3) {
    __cxa_bad_cast();
  }
  return v3 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNrUpdateReason>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNrUpdateReason>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNrUpdateReason>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::IPPref>((unsigned char **)a2, (_DWORD *)(a1 + 12));
  BOOL v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNrUpdateReason>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRoamingConfig>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRoamingConfig>::getSize()
{
  return tlv::size<wms::tlv::MemoryStorageIdentification>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRoamingConfig>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = *a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<nas::tlv::NetworkSelectionPreference>(a2, a1 + 10);
  uint64_t v7 = *a2 - v5;
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRoamingConfig>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver8enable5GEN10subscriber7SimSlotEj16SetMaxRateSourcebE3__3EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = **(NSObject ***)v3;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_DWORD *)(v3 + 8)) {
        uint64_t v5 = "enabled";
      }
      else {
        uint64_t v5 = "disabled";
      }
      int v6 = 136315650;
      uint64_t v7 = v5;
      __int16 v8 = 1024;
      int v9 = v2;
      __int16 v10 = 2080;
      uint64_t v11 = qmi::asString();
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#N Set 5G %s mode failed: Error in response with code %d (%s)", (uint8_t *)&v6, 0x1Cu);
    }
  }
}

uint64_t __copy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver8enable5GEN10subscriber7SimSlotEj16SetMaxRateSourcebE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver8enable5GEN10subscriber7SimSlotEj16SetMaxRateSourcebE3__3EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable5G(subscriber::SimSlot,unsigned int,SetMaxRateSource,BOOL)::$_3,std::allocator<QMINetworkRegistrationDriver::enable5G(subscriber::SimSlot,unsigned int,SetMaxRateSource,BOOL)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6268;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable5G(subscriber::SimSlot,unsigned int,SetMaxRateSource,BOOL)::$_3,std::allocator<QMINetworkRegistrationDriver::enable5G(subscriber::SimSlot,unsigned int,SetMaxRateSource,BOOL)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6268;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::NRDisableMode>(uint64_t a1)
{
  uint64_t v1 = *(const void ***)(a1 + 8);
  uint64_t v2 = *(const void ***)(a1 + 16);
  if (v1 != v2)
  {
    while (*((unsigned char *)*v1 + 8) != 46)
    {
      if (++v1 == v2) {
        goto LABEL_8;
      }
    }
  }
  if (v1 == v2) {
LABEL_8:
  }
    operator new();
  if (!v3) {
    __cxa_bad_cast();
  }
  return v3 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableMode>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableMode>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableMode>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableMode>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver18enable5GStandaloneEN10subscriber7SimSlotEb16SetMaxRateSourceE3__2EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = **(NSObject ***)v3;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(v3 + 8)) {
        uint64_t v5 = "enabled";
      }
      else {
        uint64_t v5 = "disabled";
      }
      int v6 = 136315650;
      uint64_t v7 = v5;
      __int16 v8 = 1024;
      int v9 = v2;
      __int16 v10 = 2080;
      uint64_t v11 = qmi::asString();
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#N Set 5G Standalone %s failed: Error in response with code %d (%s)", (uint8_t *)&v6, 0x1Cu);
    }
  }
}

uint64_t __copy_helper_block_e8_32c125_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver18enable5GStandaloneEN10subscriber7SimSlotEb16SetMaxRateSourceE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c125_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver18enable5GStandaloneEN10subscriber7SimSlotEb16SetMaxRateSourceE3__2EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable5GStandalone(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2,std::allocator<QMINetworkRegistrationDriver::enable5GStandalone(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6338;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable5GStandalone(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2,std::allocator<QMINetworkRegistrationDriver::enable5GStandalone(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6338;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver23getNRDisableStatus_syncEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  v27[2] = *MEMORY[0x263EF8340];
  uint64_t v3 = *(unsigned int **)(a1 + 32);
  uint64_t v4 = *(void *)v3;
  uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v3 + 88) + 16))(*(void *)(*(void *)v3 + 88), v3[2]);
  int v6 = *((_DWORD *)a2 + 1);
  if (v6)
  {
    uint64_t v7 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v26) = 67109378;
      HIDWORD(v26) = v6;
      LOWORD(v27[0]) = 2080;
      *(void *)((char *)v27 + 2) = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v7, OS_LOG_TYPE_ERROR, "Get NR disable status failed: Error in response with code %d (%s)", (uint8_t *)&v26, 0x12u);
    }
  }
  else
  {
    uint64_t v8 = *(void *)(v4 + 64);
    uint64_t v9 = v3[2];
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(a2);
    uint64_t v12 = TlvValue;
    if (TlvValue)
    {
      int v13 = v11;
      uint64_t v26 = TlvValue;
      tlv::parseV<nas::tlv::IsSADisabled>((unint64_t *)&v26, v11);
      if (!v26) {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 16, v12, v13);
      }
    }
    uint64_t v14 = qmi::MessageBase::findTlvValue(a2);
    if (v14)
    {
      uint64_t v16 = v14;
      int v17 = v15;
      uint64_t v26 = v14;
      tlv::parseV<nas::tlv::SADisableReasonMask>((unint64_t *)&v26, v15);
      if (!v26) {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 18, v16, v17);
      }
    }
    uint64_t v18 = qmi::MessageBase::findTlvValue(a2);
    uint64_t v20 = v18;
    if (v18)
    {
      int v21 = v19;
      uint64_t v26 = v18;
      tlv::parseV<nas::tlv::IsNSADisabled>((unint64_t *)&v26, v19);
      if (!v26) {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 17, v20, v21);
      }
    }
    uint64_t v22 = qmi::MessageBase::findTlvValue(a2);
    if (v22)
    {
      uint64_t v24 = v22;
      int v25 = v23;
      uint64_t v26 = v22;
      tlv::parseV<nas::tlv::NSADisableReasonMask>((unint64_t *)&v26, v23);
      if (!v26) {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 19, v24, v25);
      }
    }
    NRDisableStatus::NRDisableStatus((NRDisableStatus *)&v26);
    (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v8 + 216))(v8, v9, v26, v27[0]);
  }
}

uint64_t __copy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver23getNRDisableStatus_syncEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver23getNRDisableStatus_syncEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getNRDisableStatus_sync(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::getNRDisableStatus_sync(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D63B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getNRDisableStatus_sync(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::getNRDisableStatus_sync(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D63B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas18GetNRDisableStatus8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_22251EF38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaSwitch>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaSwitch>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaSwitch>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaSwitch>::clone()
{
}

void *qmi::MutableMessageBase::TlvWrapper<nas::tlv::EquivalentCountryCodeList>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4D6470;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EquivalentCountryCodeList>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4D6470;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x223C9A950);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EquivalentCountryCodeList>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::NextHdrProtList>((void *)(a1 + 16));
}

void *qmi::MutableMessageBase::TlvWrapper<nas::tlv::EquivalentCountryCodeList>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::DestPortList>((unsigned char **)a2, (_DWORD *)(a1 + 16));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EquivalentCountryCodeList>::clone()
{
}

void sub_22251F1F0(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver27setCdmaRoamingSwitchSettingEN10subscriber7SimSlotEbRKNSt3__16vectorItNS6_9allocatorItEEEEE3__2EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    char v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N Set System Selection failed: Error in response with code %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c149_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver27setCdmaRoamingSwitchSettingEN10subscriber7SimSlotEbRKNS_6vectorItNS_9allocatorItEEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c149_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver27setCdmaRoamingSwitchSettingEN10subscriber7SimSlotEbRKNS_6vectorItNS_9allocatorItEEEEE3__2EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setCdmaRoamingSwitchSetting(subscriber::SimSlot,BOOL,std::vector<unsigned short> const&)::$_2,std::allocator<QMINetworkRegistrationDriver::setCdmaRoamingSwitchSetting(subscriber::SimSlot,BOOL,std::vector<unsigned short> const&)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D64D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setCdmaRoamingSwitchSetting(subscriber::SimSlot,BOOL,std::vector<unsigned short> const&)::$_2,std::allocator<QMINetworkRegistrationDriver::setCdmaRoamingSwitchSetting(subscriber::SimSlot,BOOL,std::vector<unsigned short> const&)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D64D8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::GwAcqOrderPref>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::GwAcqOrderPref>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::GwAcqOrderPref>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::GwAcqOrderPref>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::RoamingPreference>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::RoamingPreference>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::RoamingPreference>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::RoamingPreference>::clone()
{
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver28setSystemSelectionPreferenceEN10subscriber7SimSlotEhNSt3__18optionalIjEENS7_IbEEE3__6EEOS1_OT__block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    char v3 = *(uint64_t **)(result + 32);
    uint64_t v4 = *v3;
    uint64_t v5 = *(NSObject **)v3[2];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v2;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Set System Selection failed: Error in response with code %d (%s)", (uint8_t *)v6, 0x12u);
    }
    return (*(uint64_t (**)(void, void, void))(**(void **)(v4 + 64) + 48))(*(void *)(v4 + 64), *((unsigned int *)v3 + 2), *((unsigned __int8 *)v3 + 12));
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c141_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver28setSystemSelectionPreferenceEN10subscriber7SimSlotEhNS_8optionalIjEENS4_IbEEE3__6EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c141_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver28setSystemSelectionPreferenceEN10subscriber7SimSlotEhNS_8optionalIjEENS4_IbEEE3__6EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setSystemSelectionPreference(subscriber::SimSlot,unsigned char,std::optional<unsigned int>,std::optional<BOOL>)::$_6,std::allocator<QMINetworkRegistrationDriver::setSystemSelectionPreference(subscriber::SimSlot,unsigned char,std::optional<unsigned int>,std::optional<BOOL>)::$_6>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D65F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setSystemSelectionPreference(subscriber::SimSlot,unsigned char,std::optional<unsigned int>,std::optional<BOOL>)::$_6,std::allocator<QMINetworkRegistrationDriver::setSystemSelectionPreference(subscriber::SimSlot,unsigned char,std::optional<unsigned int>,std::optional<BOOL>)::$_6>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D65F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver28getSystemSelectionPreferenceEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *((_DWORD *)this + 1);
  if (v3)
  {
    uint64_t v4 = **(NSObject ***)(v2 + 16);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v14) = 67109378;
      HIDWORD(v14) = v3;
      __int16 v15 = 2080;
      uint64_t v16 = qmi::asString();
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#N Get System Selection failed: Error in response with code %d (%s)", (uint8_t *)&v14, 0x12u);
    }
    return;
  }
  uint64_t v6 = *(capabilities::ct **)v2;
  uint64_t TlvValue = qmi::MessageBase::findTlvValue(this);
  if (TlvValue)
  {
    LODWORD(v14) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::ModePreference>(this, (uint64_t)&v14);
    if (!(_BYTE)v14) {
      goto LABEL_25;
    }
    int v8 = WORD1(v14) & 0xFF00;
    int v9 = BYTE2(v14);
    int v10 = 0x10000;
  }
  else
  {
    int v10 = 0;
    int v9 = 0;
    int v8 = 0;
  }
  int v11 = (capabilities::ct *)qmi::MessageBase::findTlvValue(this);
  if (v11)
  {
    uint64_t v14 = 0;
    int v11 = (capabilities::ct *)qmi::MessageBase::tryTlv<nas::tlv::GwAcqOrderPref>(this, (uint64_t)&v14);
    if (!(_BYTE)v14) {
LABEL_25:
    }
      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
  if (capabilities::ct::supports5G(v11) && qmi::MessageBase::findTlvValue(this))
  {
    uint64_t v14 = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NRDisableMode>(this, (uint64_t)&v14);
    if ((_BYTE)v14)
    {
      if (!TlvValue) {
        goto LABEL_14;
      }
      goto LABEL_17;
    }
    goto LABEL_25;
  }
  if (!TlvValue)
  {
LABEL_14:
    uint64_t v12 = **(NSObject ***)(v2 + 16);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v14) = 0;
      _os_log_impl(&dword_22231A000, v12, OS_LOG_TYPE_DEFAULT, "#I No mode preference present", (uint8_t *)&v14, 2u);
    }
    goto LABEL_18;
  }
LABEL_17:
  QMINetworkRegistrationDriver::handleModePreference_sync(v6, *(unsigned int *)(v2 + 8), v9 | v10 | v8);
LABEL_18:
  if (qmi::MessageBase::findTlvValue(this))
  {
    LOWORD(v14) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::EmergencyMode>(this, &v14);
    if (!(_BYTE)v14) {
      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
    }
    if (BYTE1(v14)) {
      uint64_t v13 = 257;
    }
    else {
      uint64_t v13 = 1;
    }
    (*(void (**)(void *, void, uint64_t))(**((void **)v6 + 8) + 24))(*((void **)v6 + 8), *(unsigned int *)(v2 + 8), v13);
  }
}

uint64_t __copy_helper_block_e8_32c116_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver28getSystemSelectionPreferenceEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c116_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver28getSystemSelectionPreferenceEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getSystemSelectionPreference(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::getSystemSelectionPreference(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6678;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getSystemSelectionPreference(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::getSystemSelectionPreference(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6678;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas28GetSystemSelectionPreference8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_22251FB2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::ModePreference>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::ModePreference>(v5, v4);
    if (!*(unsigned char *)a2) {
      *(unsigned char *)a2 = 1;
    }
    *(_WORD *)(a2 + 2) = result;
    if (!v5[0]) {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::GwAcqOrderPref>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::GwAcqOrderPref>(v5, v4);
    if (!*(unsigned char *)a2) {
      *(unsigned char *)a2 = 1;
    }
    *(_DWORD *)(a2 + 4) = result;
    if (!v5[0]) {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::NRDisableMode>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::NRDisableMode>(v5, v4);
    if (!*(unsigned char *)a2) {
      *(unsigned char *)a2 = 1;
    }
    *(_DWORD *)(a2 + 4) = result;
    if (!v5[0]) {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::EmergencyMode>(qmi::MessageBase *a1, unsigned char *a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::EmergencyMode>(v5, v4);
    if (!*a2) {
      *a2 = 1;
    }
    a2[1] = result;
    if (!v5[0]) {
      *a2 = 0;
    }
  }
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver16getServingSystemEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  if (v3)
  {
    unint64_t v4 = **(NSObject ***)(v2 + 16);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 67109378;
      HIDWORD(buf) = v3;
      __int16 v11 = 2080;
      uint64_t v12 = qmi::asString();
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#N Get Sys Info failed: Error in response with code %d (%s)", (uint8_t *)&buf, 0x12u);
    }
    return;
  }
  uint64_t v5 = *(void *)v2;
  uint64_t v6 = *(void *)(a2 + 8);
  v9[0] = *(void *)a2;
  v9[1] = v6;
  uint64_t v7 = *(void *)(a2 + 16);
  _DWORD v9[2] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v9);
  bzero(&buf, 0x218uLL);
  uint64_t v8 = *(void *)(v2 + 16);
  char v64 = 0;
  int v63 = 0;
  *(_DWORD *)((char *)&v68 + 3) = 0;
  LODWORD(v68) = 0;
  memset(v77, 0, 7);
  uint64_t v78 = v8;
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    BYTE2(v79[0]) = 0;
    LOWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::CDMAServiceStatus>((qmi::MessageBase *)v9, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!BYTE2(buf)) {
      BYTE2(buf) = 1;
    }
    LOWORD(buf) = *(_WORD *)((char *)v79 + 1);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    BYTE2(v79[0]) = 0;
    LOWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::HDRServiceStatus>((qmi::MessageBase *)v9, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!BYTE5(buf)) {
      BYTE5(buf) = 1;
    }
    *(_WORD *)((char *)&buf + 3) = *(_WORD *)((char *)v79 + 1);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LODWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::GSMServiceStatus>((qmi::MessageBase *)v9, (unsigned __int8 *)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    HIWORD(buf) = *(_WORD *)((char *)v79 + 1);
    LOBYTE(v11) = BYTE3(v79[0]);
    if (!HIBYTE(v11)) {
      HIBYTE(v11) = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LODWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::WCDMAServiceStatus>((qmi::MessageBase *)v9, (unsigned __int8 *)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    LOWORD(v12) = *(_WORD *)((char *)v79 + 1);
    BYTE2(v12) = BYTE3(v79[0]);
    if (!BYTE3(v12)) {
      BYTE3(v12) = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LODWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LTEServiceStatus>((qmi::MessageBase *)v9, (unsigned __int8 *)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    WORD2(v12) = *(_WORD *)((char *)v79 + 1);
    BYTE6(v12) = BYTE3(v79[0]);
    if (!HIBYTE(v12)) {
      HIBYTE(v12) = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LODWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GServiceStatus>((qmi::MessageBase *)v9, 74, (unsigned __int8 *)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    __int16 v16 = *(_WORD *)((char *)v79 + 1);
    char v17 = BYTE3(v79[0]);
    if (!v18) {
      char v18 = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LODWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::TDSCDMAServiceStatus>((qmi::MessageBase *)v9, 36, (unsigned __int8 *)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    __int16 v13 = *(_WORD *)((char *)v79 + 1);
    char v14 = BYTE3(v79[0]);
    if (!v15) {
      char v15 = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    memset(v79, 0, 52);
    qmi::MessageBase::tryTlv<nas::tlv::CDMASysInfo>((qmi::MessageBase *)v9, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    long long v19 = *(_OWORD *)((char *)v79 + 4);
    v20[0] = *(_OWORD *)((char *)&v79[1] + 4);
    if (v21)
    {
      *(_OWORD *)((char *)v20 + 15) = *(_OWORD *)((char *)&v79[2] + 3);
    }
    else
    {
      v20[1] = *(_OWORD *)((char *)&v79[2] + 4);
      char v21 = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    memset(v79, 0, 32);
    qmi::MessageBase::tryTlv<nas::tlv::HDRSysInfo>((qmi::MessageBase *)v9, (unsigned __int8 *)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    *(_OWORD *)uint64_t v22 = *(_OWORD *)((char *)v79 + 1);
    *(_OWORD *)&v22[15] = v79[1];
    if (!v23) {
      char v23 = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    memset(v79, 0, 40);
    qmi::MessageBase::tryTlv<nas::tlv::GSMSysInfo>((qmi::MessageBase *)v9, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    long long v24 = *(_OWORD *)((char *)v79 + 4);
    long long v25 = *(_OWORD *)((char *)&v79[1] + 4);
    if (v27)
    {
      LOWORD(v26) = WORD2(v79[2]);
    }
    else
    {
      int v26 = DWORD1(v79[2]);
      char v27 = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    memset(v79, 0, 44);
    qmi::MessageBase::tryTlv<nas::tlv::WCDMASysInfo>((qmi::MessageBase *)v9, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    long long v28 = *(_OWORD *)((char *)v79 + 4);
    *(_OWORD *)unint64_t v29 = *(_OWORD *)((char *)&v79[1] + 4);
    if (v30)
    {
      *(void *)&v29[14] = *(void *)((char *)&v79[2] + 2);
    }
    else
    {
      *(void *)&v29[16] = *(void *)((char *)&v79[2] + 4);
      char v30 = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    memset(v79, 0, 40);
    qmi::MessageBase::tryTlv<nas::tlv::LTESysInfo>((qmi::MessageBase *)v9, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    long long v31 = *(_OWORD *)((char *)v79 + 4);
    long long v32 = *(_OWORD *)((char *)&v79[1] + 4);
    if (v34)
    {
      LOWORD(v33) = WORD2(v79[2]);
    }
    else
    {
      int v33 = DWORD1(v79[2]);
      char v34 = 1;
    }
    BYTE2(v77[1]) = 0;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    memset(v79, 0, 40);
    qmi::MessageBase::tryTlv<nas::tlv::NR5GSysInfo>((qmi::MessageBase *)v9, 75, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    long long v39 = *(_OWORD *)((char *)v79 + 4);
    long long v40 = *(_OWORD *)((char *)&v79[1] + 4);
    if (v42)
    {
      LOWORD(v41) = WORD2(v79[2]);
    }
    else
    {
      int v41 = DWORD1(v79[2]);
      char v42 = 1;
    }
    BYTE2(v77[1]) = 0;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    uint64_t v80 = 0;
    memset(v79, 0, sizeof(v79));
    qmi::MessageBase::tryTlv<nas::tlv::TDSCDMASysInfo>((qmi::MessageBase *)v9, 37, (unsigned __int8 *)v79);
    if (!LOBYTE(v79[0])) {
      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
    }
    std::optional<nas::tlv::TDSCDMASysInfo>::operator=[abi:ne180100]<nas::tlv::TDSCDMASysInfo&,void>((uint64_t)&v35, (uint64_t)v79 + 8);
    if (LOBYTE(v79[0]) && *(void *)&v79[3])
    {
      *((void *)&v79[3] + 1) = *(void *)&v79[3];
      operator delete(*(void **)&v79[3]);
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    WORD2(v79[0]) = 0;
    LODWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::CDMASysInfoEx>((qmi::MessageBase *)v9, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!v44) {
      char v44 = 1;
    }
    int v43 = *(_DWORD *)((char *)v79 + 2);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LODWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::HDRSysInfoEx>((qmi::MessageBase *)v9, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!v46) {
      char v46 = 1;
    }
    __int16 v45 = WORD1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    DWORD2(v79[0]) = 0;
    *(void *)&v79[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::GSMSysInfoEx>((qmi::MessageBase *)v9, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!v48) {
      char v48 = 1;
    }
    uint64_t v47 = *(void *)((char *)v79 + 4);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    DWORD2(v79[0]) = 0;
    *(void *)&v79[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::WCDMASysInfoEx>((qmi::MessageBase *)v9, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!v50) {
      char v50 = 1;
    }
    uint64_t v49 = *(void *)((char *)v79 + 4);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LODWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LTESysInfoEx>((qmi::MessageBase *)v9, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!v52) {
      char v52 = 1;
    }
    __int16 v51 = WORD1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LODWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GTAC>((qmi::MessageBase *)v9, 80, (unsigned __int8 *)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    HIWORD(v68) = *(_WORD *)((char *)v79 + 1);
    char v69 = BYTE3(v79[0]);
    if (!v70) {
      char v70 = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    BYTE8(v79[0]) = 0;
    *(void *)&v79[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GCellID>((qmi::MessageBase *)v9, 94, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!v72) {
      char v72 = 1;
    }
    uint64_t v71 = *(void *)((char *)v79 + 1);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LOWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GServiceAreaRestrictionInfo>((qmi::MessageBase *)v9, 81, v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!v74) {
      char v74 = 1;
    }
    char v73 = BYTE1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    DWORD2(v79[0]) = 0;
    *(void *)&v79[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GEmergencyServiceInfo>((qmi::MessageBase *)v9, 90, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!v76) {
      char v76 = 1;
    }
    uint64_t v75 = *(void *)((char *)v79 + 4);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LOWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GVoiceSupportInfo>((qmi::MessageBase *)v9, 88, v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!BYTE1(v77[0])) {
      BYTE1(v77[0]) = 1;
    }
    LOBYTE(v77[0]) = BYTE1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    *(void *)&v79[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LteEmergencyBearerSupport>((qmi::MessageBase *)v9, 57, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!v60) {
      char v60 = 1;
    }
    int v59 = DWORD1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    *(void *)&v79[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LteEmergencyAccessBarred>((qmi::MessageBase *)v9, 62, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!v62) {
      char v62 = 1;
    }
    int v61 = DWORD1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LOWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::HDRSubnetMaskLength>((qmi::MessageBase *)v9, 69, v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!BYTE1(v63)) {
      BYTE1(v63) = 1;
    }
    LOBYTE(v63) = BYTE1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LOWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::GSMCipherDomainSysInfo>((qmi::MessageBase *)v9, v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!HIBYTE(v77[0])) {
      HIBYTE(v77[0]) = 1;
    }
    BYTE2(v77[0]) = BYTE1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LOWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::WCDMACipherDomainSysInfo>((qmi::MessageBase *)v9, v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!BYTE1(v77[1])) {
      BYTE1(v77[1]) = 1;
    }
    LOBYTE(v77[1]) = BYTE1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LOWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LTEVoiceSupportSysInfo>((qmi::MessageBase *)v9, v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!v54) {
      char v54 = 1;
    }
    char v53 = BYTE1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    *(void *)&v79[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::SimRejectInfo>((qmi::MessageBase *)v9, 39, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!v56) {
      char v56 = 1;
    }
    int v55 = DWORD1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LODWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::CDMADerivedMCC>((qmi::MessageBase *)v9, 46, (uint64_t)v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!v58) {
      char v58 = 1;
    }
    __int16 v57 = WORD1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LOWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::AgentVoiceSupportStatus>((qmi::MessageBase *)v9, 41, v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!HIBYTE(v63)) {
      HIBYTE(v63) = 1;
    }
    BYTE2(v63) = BYTE1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LOWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::ScanCompletionStatus>((qmi::MessageBase *)v9, v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!BYTE1(v68)) {
      BYTE1(v68) = 1;
    }
    LOBYTE(v68) = BYTE1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LOWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::CSVoiceSupportStatus>((qmi::MessageBase *)v9, v79);
    if (!LOBYTE(v79[0])) {
      goto LABEL_189;
    }
    if (!BYTE3(v68)) {
      BYTE3(v68) = 1;
    }
    BYTE2(v68) = BYTE1(v79[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v9))
  {
    LOWORD(v79[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::IsSatelliteSystem>((qmi::MessageBase *)v9, v79);
    if (LOBYTE(v79[0]))
    {
      if (!BYTE5(v68)) {
        BYTE5(v68) = 1;
      }
      BYTE4(v68) = BYTE1(v79[0]);
      goto LABEL_181;
    }
LABEL_189:
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
LABEL_181:
  QMINetworkRegistrationDriver::processSystemInfo_sync(v5, *(_DWORD *)(v2 + 8), (unsigned __int8 *)&buf);
  if (v67 && __p)
  {
    char v66 = __p;
    operator delete(__p);
  }
  if (v38 && v36)
  {
    uint64_t v37 = v36;
    operator delete(v36);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v9);
}

void sub_222520984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (*(unsigned char *)(v71 - 128))
  {
    char v73 = *(void **)(v71 - 80);
    if (v73) {
      operator delete(v73);
    }
  }
  if (a71 && __p)
  {
    a69 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a51)
  {
    if (a48)
    {
      a49 = (uint64_t)a48;
      operator delete(a48);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver16getServingSystemEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver16getServingSystemEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getServingSystem(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::getServingSystem(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D66F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getServingSystem(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::getServingSystem(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D66F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::optional<nas::tlv::TDSCDMASysInfo>::operator=[abi:ne180100]<nas::tlv::TDSCDMASysInfo&,void>(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 64);
  __int16 v4 = *(_WORD *)(a2 + 32);
  long long v5 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v5;
  *(_WORD *)(a1 + 32) = v4;
  if (v3)
  {
    if (a1 != a2) {
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((void *)(a1 + 40), *(char **)(a2 + 40), *(char **)(a2 + 48), *(void *)(a2 + 48) - *(void *)(a2 + 40));
    }
  }
  else
  {
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((void *)(a1 + 40), *(const void **)(a2 + 40), *(void *)(a2 + 48), *(void *)(a2 + 48) - *(void *)(a2 + 40));
    *(unsigned char *)(a1 + 64) = 1;
  }
  return a1;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::CDMAServiceStatus>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::CDMAServiceStatus>(v5, v4);
    if (!*(unsigned char *)a2) {
      *(unsigned char *)a2 = 1;
    }
    *(_WORD *)(a2 + 1) = result;
    if (!v5[0]) {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::HDRServiceStatus>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::HDRServiceStatus>(v5, v4);
    if (!*(unsigned char *)a2) {
      *(unsigned char *)a2 = 1;
    }
    *(_WORD *)(a2 + 1) = result;
    if (!v5[0]) {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

unsigned char *qmi::MessageBase::tryTlv<nas::tlv::TDSCDMAServiceStatus>(qmi::MessageBase *a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t result = (unsigned char *)qmi::MessageBase::findTlvValue(a1);
  v7[0] = result;
  v7[1] = v5;
  if (result)
  {
    uint64_t result = (unsigned char *)tlv::parseV<nas::tlv::TDSCDMAServiceStatus>(v7, (int)v5);
    int v6 = *a3;
    *(_WORD *)(a3 + 1) = (_WORD)result;
    a3[3] = BYTE2(result);
    if (!v6) {
      *a3 = 1;
    }
    if (!v7[0]) {
      *a3 = 0;
    }
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::CDMASysInfo>(qmi::MessageBase *a1, uint64_t a2)
{
  unint64_t result = qmi::MessageBase::findTlvValue(a1);
  v9[0] = result;
  v9[1] = v4;
  if (result)
  {
    unint64_t result = tlv::parseV<nas::tlv::CDMASysInfo>(v9, v4, &v7);
    long long v5 = (_OWORD *)(a2 + 4);
    long long v6 = *(_OWORD *)v8;
    if (*(unsigned char *)a2)
    {
      *long long v5 = v7;
      *(_OWORD *)(a2 + 20) = v6;
      *(_OWORD *)(a2 + 35) = *(_OWORD *)&v8[15];
    }
    else
    {
      *long long v5 = v7;
      *(_OWORD *)(a2 + 20) = v6;
      *(_OWORD *)(a2 + 36) = *(_OWORD *)&v8[16];
      *(unsigned char *)a2 = 1;
    }
    if (!v9[0]) {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::HDRSysInfo>(qmi::MessageBase *a1, unsigned __int8 *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  unint64_t result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v4;
  if (result)
  {
    unint64_t result = tlv::parseV<nas::tlv::HDRSysInfo>(v6, v4, v7);
    int v5 = *a2;
    *(_OWORD *)(a2 + 1) = *(_OWORD *)v7;
    *((_OWORD *)a2 + 1) = *(_OWORD *)&v7[15];
    if (!v5) {
      *a2 = 1;
    }
    if (!v6[0]) {
      *a2 = 0;
    }
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::GSMSysInfo>(qmi::MessageBase *a1, uint64_t a2)
{
  unint64_t result = qmi::MessageBase::findTlvValue(a1);
  v9[0] = result;
  v9[1] = v4;
  if (result)
  {
    unint64_t result = tlv::parseV<nas::tlv::GSMSysInfo>(v9, v4, (uint64_t)v7);
    int v5 = (_OWORD *)(a2 + 4);
    long long v6 = v7[1];
    if (*(unsigned char *)a2)
    {
      *int v5 = v7[0];
      *(_OWORD *)(a2 + 20) = v6;
      *(_WORD *)(a2 + 36) = v8;
    }
    else
    {
      *int v5 = v7[0];
      *(_OWORD *)(a2 + 20) = v6;
      *(_DWORD *)(a2 + 36) = v8;
      *(unsigned char *)a2 = 1;
    }
    if (!v9[0]) {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::WCDMASysInfo>(qmi::MessageBase *a1, uint64_t a2)
{
  unint64_t result = qmi::MessageBase::findTlvValue(a1);
  v9[0] = result;
  v9[1] = v4;
  if (result)
  {
    unint64_t result = tlv::parseV<nas::tlv::WCDMASysInfo>(v9, v4, (uint64_t)&v7);
    int v5 = (_OWORD *)(a2 + 4);
    long long v6 = *(_OWORD *)v8;
    if (*(unsigned char *)a2)
    {
      *int v5 = v7;
      *(_OWORD *)(a2 + 20) = v6;
      *(void *)(a2 + 34) = *(void *)&v8[14];
    }
    else
    {
      *int v5 = v7;
      *(_OWORD *)(a2 + 20) = v6;
      *(void *)(a2 + 36) = *(void *)&v8[16];
      *(unsigned char *)a2 = 1;
    }
    if (!v9[0]) {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::NR5GSysInfo>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = qmi::MessageBase::findTlvValue(a1);
  v10[0] = result;
  v10[1] = v5;
  if (result)
  {
    unint64_t result = tlv::parseV<nas::tlv::NR5GSysInfo>(v10, v5, (uint64_t)v8);
    long long v6 = (_OWORD *)(a3 + 4);
    long long v7 = v8[1];
    if (*(unsigned char *)a3)
    {
      _OWORD *v6 = v8[0];
      *(_OWORD *)(a3 + 20) = v7;
      *(_WORD *)(a3 + 36) = v9;
    }
    else
    {
      _OWORD *v6 = v8[0];
      *(_OWORD *)(a3 + 20) = v7;
      *(_DWORD *)(a3 + 36) = v9;
      *(unsigned char *)a3 = 1;
    }
    if (!v10[0]) {
      *(unsigned char *)a3 = 0;
    }
  }
  return result;
}

void qmi::MessageBase::tryTlv<nas::tlv::TDSCDMASysInfo>(qmi::MessageBase *a1, uint64_t a2, unsigned __int8 *a3)
{
  v14[0] = qmi::MessageBase::findTlvValue(a1);
  v14[1] = v4;
  if (v14[0])
  {
    tlv::parseV<nas::tlv::TDSCDMASysInfo>(v14, v4, v10);
    int v5 = *a3;
    long long v6 = v10[1];
    *(_OWORD *)(a3 + 8) = v10[0];
    *(_OWORD *)(a3 + 24) = v6;
    *((_WORD *)a3 + 20) = v11;
    if (v5)
    {
      long long v7 = (void *)*((void *)a3 + 6);
      if (v7)
      {
        *((void *)a3 + 7) = v7;
        operator delete(v7);
        int v8 = *a3;
      }
      else
      {
        int v8 = 1;
      }
      int v9 = (void *)v12;
      *((_OWORD *)a3 + 3) = v12;
      *((void *)a3 + 8) = v13;
    }
    else
    {
      int v9 = (void *)v12;
      *((_OWORD *)a3 + 3) = v12;
      *((void *)a3 + 8) = v13;
      int v8 = 1;
      *a3 = 1;
    }
    if (!v14[0] && v8)
    {
      if (v9)
      {
        *((void *)a3 + 7) = v9;
        operator delete(v9);
      }
      *a3 = 0;
    }
  }
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::CDMASysInfoEx>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::CDMASysInfoEx>(v5, v4);
    if (!*(unsigned char *)a2) {
      *(unsigned char *)a2 = 1;
    }
    *(_DWORD *)(a2 + 2) = result;
    if (!v5[0]) {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::HDRSysInfoEx>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::HDRSysInfoEx>(v5, v4);
    if (!*(unsigned char *)a2) {
      *(unsigned char *)a2 = 1;
    }
    *(_WORD *)(a2 + 2) = result;
    if (!v5[0]) {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::GSMSysInfoEx>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::GSMSysInfoEx>(v5, v4);
    if (!*(unsigned char *)a2) {
      *(unsigned char *)a2 = 1;
    }
    *(void *)(a2 + 4) = result;
    if (!v5[0]) {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::WCDMASysInfoEx>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::WCDMASysInfoEx>(v5, v4);
    if (!*(unsigned char *)a2) {
      *(unsigned char *)a2 = 1;
    }
    *(void *)(a2 + 4) = result;
    if (!v5[0]) {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::NR5GTAC>(qmi::MessageBase *a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v7[0] = result;
  v7[1] = v5;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::NR5GTAC>(v7, v5);
    int v6 = *a3;
    *(_WORD *)(a3 + 1) = result;
    a3[3] = BYTE2(result);
    if (!v6) {
      *a3 = 1;
    }
    if (!v7[0]) {
      *a3 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::NR5GCellID>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::NR5GCellID>(v6, v5);
    if (!*(unsigned char *)a3) {
      *(unsigned char *)a3 = 1;
    }
    *(void *)(a3 + 1) = result;
    if (!v6[0]) {
      *(unsigned char *)a3 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::NR5GServiceAreaRestrictionInfo>(qmi::MessageBase *a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::NR5GServiceAreaRestrictionInfo>(v6, v5);
    if (!*a3) {
      *a3 = 1;
    }
    a3[1] = result;
    if (!v6[0]) {
      *a3 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::NR5GEmergencyServiceInfo>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::NR5GEmergencyServiceInfo>(v6, v5);
    if (!*(unsigned char *)a3) {
      *(unsigned char *)a3 = 1;
    }
    *(void *)(a3 + 4) = result;
    if (!v6[0]) {
      *(unsigned char *)a3 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::NR5GVoiceSupportInfo>(qmi::MessageBase *a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::NR5GVoiceSupportInfo>(v6, v5);
    if (!*a3) {
      *a3 = 1;
    }
    a3[1] = result;
    if (!v6[0]) {
      *a3 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::HDRSubnetMaskLength>(qmi::MessageBase *a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::HDRSubnetMaskLength>(v6, v5);
    if (!*a3) {
      *a3 = 1;
    }
    a3[1] = result;
    if (!v6[0]) {
      *a3 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::GSMCipherDomainSysInfo>(qmi::MessageBase *a1, unsigned char *a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::GSMCipherDomainSysInfo>(v5, v4);
    if (!*a2) {
      *a2 = 1;
    }
    a2[1] = result;
    if (!v5[0]) {
      *a2 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::WCDMACipherDomainSysInfo>(qmi::MessageBase *a1, unsigned char *a2)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::WCDMACipherDomainSysInfo>(v5, v4);
    if (!*a2) {
      *a2 = 1;
    }
    a2[1] = result;
    if (!v5[0]) {
      *a2 = 0;
    }
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::LTEVoiceSupportSysInfo>(qmi::MessageBase *a1, unsigned char *a2)
{
  unint64_t result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    unint64_t result = tlv::parseV<nas::tlv::LTEVoiceSupportSysInfo>(v5, v4);
    if (!*a2) {
      *a2 = 1;
    }
    a2[1] = result;
    if (!v5[0]) {
      *a2 = 0;
    }
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::CDMADerivedMCC>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    uint64_t result = tlv::parseV<nas::tlv::CDMADerivedMCC>(v6, v5);
    if (!*(unsigned char *)a3) {
      *(unsigned char *)a3 = 1;
    }
    *(_WORD *)(a3 + 2) = result;
    if (!v6[0]) {
      *(unsigned char *)a3 = 0;
    }
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::AgentVoiceSupportStatus>(qmi::MessageBase *a1, uint64_t a2, unsigned char *a3)
{
  unint64_t result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    unint64_t result = tlv::parseV<nas::tlv::AgentVoiceSupportStatus>(v6, v5);
    if (!*a3) {
      *a3 = 1;
    }
    a3[1] = result;
    if (!v6[0]) {
      *a3 = 0;
    }
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::ScanCompletionStatus>(qmi::MessageBase *a1, unsigned char *a2)
{
  unint64_t result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    unint64_t result = tlv::parseV<nas::tlv::ScanCompletionStatus>(v5, v4);
    if (!*a2) {
      *a2 = 1;
    }
    a2[1] = result;
    if (!v5[0]) {
      *a2 = 0;
    }
  }
  return result;
}

void std::__function::__func<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::~__func()
{
}

void *std::__function::__func<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::__clone(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D6748;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D6748;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::target_type()
{
}

void std::__function::__func<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System const&)>::~__func()
{
}

void *std::__function::__func<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System const&)>::__clone(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D67D8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D67D8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System const&)>::target_type()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnInfo>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnInfo>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unint64_t v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  unint64_t result = tlv::writeV<wds::tlv::TdFragmentInfo>((_WORD **)a2, (_WORD *)(a1 + 10));
  long long v7 = (char *)(*a2 - v5);
  *(unsigned char *)unint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnInfo>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::AlwaysSendPLMNName>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::AlwaysSendPLMNName>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::AlwaysSendPLMNName>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  unint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  long long v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::AlwaysSendPLMNName>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::RATForPLMN>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::RATForPLMN>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::RATForPLMN>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  unint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  long long v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::RATForPLMN>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::MncPcsDigitInfo>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::MncPcsDigitInfo>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::MncPcsDigitInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  unint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  unint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  long long v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::MncPcsDigitInfo>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver11getPlmnNameEN10subscriber7SimSlotE3MCC3MNC21RadioAccessTechnologyE3__4EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  char v3 = *(unsigned int **)(a1 + 32);
  uint64_t v4 = *(void *)v3;
  uint64_t v5 = v3[2];
  int v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v3 + 88) + 16))(*(void *)(*(void *)v3 + 88), v5);
  int v7 = *((_DWORD *)a2 + 1);
  if (v7)
  {
    int v8 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v7;
      *(_WORD *)&uint8_t buf[8] = 2080;
      *(void *)&buf[10] = qmi::asString();
      _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#N Get PLMN Name failed: Error in response with code %d (%s)", buf, 0x12u);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v49 = 0u;
    long long v50 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    *(_OWORD *)char v46 = 0u;
    *(_OWORD *)char v44 = 0u;
    memset(buf, 0, sizeof(buf));
    HIDWORD(v45) = 11;
    uint64_t v52 = 0;
    long long v51 = 0uLL;
    uint64_t TlvValue = (nas::tlv *)qmi::MessageBase::findTlvValue(a2);
    long long v12 = TlvValue;
    if (TlvValue)
    {
      int v13 = v10;
      long long v40 = TlvValue;
      *(_OWORD *)long long v31 = 0u;
      *(_OWORD *)long long v32 = 0u;
      *(_OWORD *)unint64_t v29 = 0u;
      *(_OWORD *)char v30 = 0u;
      *(_OWORD *)char v27 = 0u;
      *(_OWORD *)long long v28 = 0u;
      tlv::parseV<nas::tlv::PlmnNameInfo>(&v40, v10, v11, (uint64_t)v27);
      char v14 = v40;
      if (v40)
      {
        decodeOperatorName();
        if ((char)buf[47] < 0) {
          operator delete(*(void **)&buf[24]);
        }
        *(_OWORD *)&uint8_t buf[24] = v41;
        *(void *)&uint8_t buf[40] = v42;
        decodeOperatorName();
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        *(_OWORD *)uint64_t buf = v41;
        *(void *)&uint8_t buf[16] = v42;
        decodeOperatorName();
        if (SBYTE7(v45) < 0) {
          operator delete(v44[0]);
        }
        *(_OWORD *)char v44 = v41;
        *(void *)&long long v45 = v42;
      }
      if (v31[1])
      {
        v32[0] = v31[1];
        operator delete(v31[1]);
      }
      if (v29[1])
      {
        v30[0] = v29[1];
        operator delete(v29[1]);
      }
      if (v27[1])
      {
        v28[0] = v27[1];
        operator delete(v27[1]);
      }
      if (!v14) {
        ((void (*)(void, uint64_t, nas::tlv *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 16, v12, v13);
      }
    }
    char v15 = (void *)qmi::MessageBase::findTlvValue(a2);
    char v17 = v15;
    if (v15)
    {
      int v18 = v16;
      v27[0] = v15;
      uint64_t v19 = tlv::parseV<nas::tlv::NetworkNameSource>((unint64_t *)v27, v16);
      if (v27[0]) {
        DWORD2(v45) = nas::convert(v19);
      }
      else {
        ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 21, v17, v18);
      }
    }
    uint64_t v20 = (nas::tlv *)qmi::MessageBase::findTlvValue(a2);
    char v23 = v20;
    if (v20)
    {
      int v24 = v21;
      long long v40 = v20;
      v30[0] = 0;
      *(_OWORD *)long long v28 = 0u;
      *(_OWORD *)unint64_t v29 = 0u;
      *(_OWORD *)char v27 = 0u;
      tlv::parseV<nas::tlv::EvoNitzInfo>(&v40, v21, v22, (uint64_t)v27);
      long long v25 = v40;
      if (v40)
      {
        decodeOperatorName();
        if (SHIBYTE(v52) < 0) {
          operator delete((void *)v51);
        }
        long long v51 = v41;
        uint64_t v52 = v42;
      }
      if (v29[0])
      {
        v29[1] = v29[0];
        operator delete(v29[0]);
      }
      if (v27[1])
      {
        v28[0] = v27[1];
        operator delete(v27[1]);
      }
      if (!v25) {
        ((void (*)(void, uint64_t, nas::tlv *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 160, v23, v24);
      }
    }
    uint64_t v26 = *(void *)(v4 + 64);
    OperatorNameUpdate::OperatorNameUpdate((std::string *)v27, (const OperatorNameUpdate *)buf);
    (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v26 + 80))(v26, v5, v27);
    if (v39 < 0) {
      operator delete(v38);
    }
    if (v37 && v36 < 0) {
      operator delete(v35);
    }
    if (v34 && v33 < 0) {
      operator delete(v32[1]);
    }
    if (SHIBYTE(v31[0]) < 0) {
      operator delete(v30[0]);
    }
    if (SHIBYTE(v29[1]) < 0) {
      operator delete(v28[1]);
    }
    if (SHIBYTE(v28[0]) < 0) {
      operator delete(v27[0]);
    }
    if (SHIBYTE(v52) < 0) {
      operator delete((void *)v51);
    }
    if (BYTE8(v50) && SBYTE7(v50) < 0) {
      operator delete(v49[0]);
    }
    if ((_BYTE)v48 && SHIBYTE(v47) < 0) {
      operator delete(v46[1]);
    }
    if (SBYTE7(v45) < 0) {
      operator delete(v44[0]);
    }
    if ((char)buf[47] < 0) {
      operator delete(*(void **)&buf[24]);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
}

void sub_222521FF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *__p, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,int a59,__int16 a60,char a61,char a62,char a63)
{
  if (__p) {
    operator delete(__p);
  }
  if (a10) {
    operator delete(a10);
  }
  if (a73 < 0) {
    operator delete(a72);
  }
  if (a71 && a70 < 0) {
    operator delete(a65);
  }
  if (a63 && a62 < 0) {
    operator delete(a57);
  }
  if (a54 < 0) {
    operator delete(a49);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c130_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver11getPlmnNameEN10subscriber7SimSlotE3MCC3MNC21RadioAccessTechnologyE3__4EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c130_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver11getPlmnNameEN10subscriber7SimSlotE3MCC3MNC21RadioAccessTechnologyE3__4EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getPlmnName(subscriber::SimSlot,MCC,MNC,RadioAccessTechnology)::$_4,std::allocator<QMINetworkRegistrationDriver::getPlmnName(subscriber::SimSlot,MCC,MNC,RadioAccessTechnology)::$_4>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D69D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getPlmnName(subscriber::SimSlot,MCC,MNC,RadioAccessTechnology)::$_4,std::allocator<QMINetworkRegistrationDriver::getPlmnName(subscriber::SimSlot,MCC,MNC,RadioAccessTechnology)::$_4>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D69D8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas11GetPlmnName8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2225222AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ServiceDomainPreference>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ServiceDomainPreference>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::ServiceDomainPreference>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  unint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ServiceDomainPreference>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver25sendPSRegistrationRequestEN10subscriber7SimSlotEbE3__2EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  char v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 32) + 88) + 16))(*(void *)(**(void **)(a1 + 32) + 88), *(unsigned int *)(*(void *)(a1 + 32) + 8));
  int v4 = *(_DWORD *)(a2 + 4);
  if (v4)
  {
    uint64_t v5 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 67109378;
      v6[1] = v4;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#E CS-PS Attach preference failed: Error in response with code %d (%s)", (uint8_t *)v6, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver25sendPSRegistrationRequestEN10subscriber7SimSlotEbE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver25sendPSRegistrationRequestEN10subscriber7SimSlotEbE3__2EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendPSRegistrationRequest(subscriber::SimSlot,BOOL)::$_2,std::allocator<QMINetworkRegistrationDriver::sendPSRegistrationRequest(subscriber::SimSlot,BOOL)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6AA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendPSRegistrationRequest(subscriber::SimSlot,BOOL)::$_2,std::allocator<QMINetworkRegistrationDriver::sendPSRegistrationRequest(subscriber::SimSlot,BOOL)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6AA8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionRegistrationRestrictionPreference>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionRegistrationRestrictionPreference>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionRegistrationRestrictionPreference>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  unint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  __int16 v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionRegistrationRestrictionPreference>::clone()
{
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver15setCampOnlyModeEN10subscriber7SimSlotEbE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  int v4 = *(_DWORD *)(a2 + 4);
  if (v4)
  {
    int v6 = *(NSObject **)v2[2];
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    BOOL v8 = 0;
    if (v7)
    {
      v10[0] = 67109378;
      v10[1] = v4;
      __int16 v11 = 2080;
      uint64_t v12 = qmi::asString();
      _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#E Set CMAS Mode failed: Error in response with code %d (%s)", (uint8_t *)v10, 0x12u);
      BOOL v8 = *(_DWORD *)(a2 + 4) == 0;
    }
  }
  else
  {
    BOOL v8 = 1;
  }
  return (*(uint64_t (**)(void, void, BOOL, void))(**(void **)(v3 + 64) + 208))(*(void *)(v3 + 64), *((unsigned int *)v2 + 2), v8, 2 * *((unsigned __int8 *)v2 + 12));
}

uint64_t __copy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15setCampOnlyModeEN10subscriber7SimSlotEbE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15setCampOnlyModeEN10subscriber7SimSlotEbE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setCampOnlyMode(subscriber::SimSlot,BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::setCampOnlyMode(subscriber::SimSlot,BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6B78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setCampOnlyMode(subscriber::SimSlot,BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::setCampOnlyMode(subscriber::SimSlot,BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6B78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver19setProvisioningModeEbE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void ***)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  if (v3)
  {
    int v4 = *v2[2];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#E Enabling provisioning mode failed: Error in response with code %d (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else
  {
    uint64_t v5 = *(void (**)(void))(*(void *)(*v2)[8] + 96);
    v5();
  }
}

uint64_t __copy_helper_block_e8_32c86_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver19setProvisioningModeEbE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c86_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver19setProvisioningModeEbE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_0,std::allocator<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6BF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_0,std::allocator<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6BF8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver19setProvisioningModeEbE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void ***)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 4);
  if (v3)
  {
    int v4 = *v2[2];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 67109378;
      v6[1] = v3;
      __int16 v7 = 2080;
      uint64_t v8 = qmi::asString();
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#E Disabling provisioning mode failed: Error in response with code %d (%s)", (uint8_t *)v6, 0x12u);
    }
  }
  else
  {
    uint64_t v5 = *(void (**)(void))(*(void *)(*v2)[8] + 96);
    v5();
  }
}

uint64_t __copy_helper_block_e8_32c86_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver19setProvisioningModeEbE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c86_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver19setProvisioningModeEbE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6C78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6C78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver19getProvisioningModeENSt3__18functionIFvbEEEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *((_DWORD *)a2 + 1);
  if (v4)
  {
    uint64_t v5 = **(NSObject ***)(v3 + 32);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 67109378;
      HIDWORD(buf) = v4;
      __int16 v13 = 2080;
      uint64_t v14 = qmi::asString();
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#E Querying provisioning mode failed: Error in response with code %d (%s)", (uint8_t *)&buf, 0x12u);
    }
  }
  else
  {
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&buf, v3);
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(a2);
    uint64_t v8 = TlvValue;
    if (TlvValue)
    {
      int v9 = v7;
      uint64_t v11 = TlvValue;
      char v10 = tlv::parseV<nas::tlv::CambioMode>((unint64_t *)&v11, v7);
      if (v11) {
        std::function<void ()(BOOL)>::operator()((uint64_t)&buf, v10 != 0);
      }
      else {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 1, v8, v9);
      }
    }
    std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](&buf);
  }
}

void sub_222522CD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t __copy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver19getProvisioningModeENS_8functionIFvbEEEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver19getProvisioningModeENS_8functionIFvbEEEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getProvisioningMode(std::function<void ()(BOOL)>)::$_0,std::allocator<QMINetworkRegistrationDriver::getProvisioningMode(std::function<void ()(BOOL)>)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6CF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getProvisioningMode(std::function<void ()(BOOL)>)::$_0,std::allocator<QMINetworkRegistrationDriver::getProvisioningMode(std::function<void ()(BOOL)>)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6CF8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void *std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getProvisioningMode(std::function<void ()(BOOL)>)::$_0,std::allocator<QMINetworkRegistrationDriver::getProvisioningMode(std::function<void ()(BOOL)>)::$_0>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 24));
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas19GetProvisioningMode8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222522E60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN28QMINetworkRegistrationDriver26invalidateNetworkTimeCacheEvENK3__0clINS_16SubscriptionTypeEEEDaT_EUlRKNS_12ResponseBaseEE_EEOS1_OS8__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    uint64_t v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N Invalidate cache request failed: Error in response with code %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c155_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver26invalidateNetworkTimeCacheEvENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKNS4_12ResponseBaseEE_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c155_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver26invalidateNetworkTimeCacheEvENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKNS4_12ResponseBaseEE_EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void _ZNSt3__120__shared_ptr_emplaceIZZN28QMINetworkRegistrationDriver26invalidateNetworkTimeCacheEvENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKNS4_12ResponseBaseEE_NS_9allocatorISB_EEED1Ev(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6D78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void _ZNSt3__120__shared_ptr_emplaceIZZN28QMINetworkRegistrationDriver26invalidateNetworkTimeCacheEvENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKNS4_12ResponseBaseEE_NS_9allocatorISB_EEED0Ev(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6D78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::ClientRouter::SendProxy::SendProxy<nas::SetE911State::Request>(_DWORD *a1, int a2)
{
  *a1 = a2;
  operator new();
}

void sub_222523078(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x10F0C401BA14CC5);
  _Unwind_Resume(a1);
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNSt3__16vectorI18EmergencySetupTypeNS6_9allocatorIS8_EEEEbbS5_bE3__2EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  int v4 = *((_DWORD *)this + 1);
  if (v4)
  {
    __int16 v5 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 67109634;
      *(_DWORD *)char v27 = v4;
      *(_WORD *)&void v27[4] = 2080;
      *(void *)&v27[6] = qmi::asString();
      __int16 v28 = 2080;
      uint64_t v29 = subscriber::asString();
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#E Querying preferred E911 subscription failed: Error in response with code %d (%s). Default to %s", buf, 0x1Cu);
    }
    goto LABEL_18;
  }
  uint64_t TlvValue = qmi::MessageBase::findTlvValue(this);
  if (!TlvValue) {
    goto LABEL_13;
  }
  uint64_t v9 = TlvValue;
  int v10 = v8;
  uint64_t v25 = TlvValue;
  unsigned __int8 v11 = tlv::parseV<nas::tlv::E911Sub>((unint64_t *)&v25, v8);
  if (!v25)
  {
    ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)this, 16, v9, v10);
LABEL_13:
    int v13 = 1;
    goto LABEL_14;
  }
  unsigned __int8 v12 = v11;
  if (v11) {
    int v13 = 2 * (v11 == 1);
  }
  else {
    int v13 = 1;
  }
  if ((subscriber::isValidSimSlot() & 1) == 0)
  {
    uint64_t v14 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v15 = nas::asString(v12);
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)char v27 = v15;
      _os_log_error_impl(&dword_22231A000, v14, OS_LOG_TYPE_ERROR, "Got invalid preferred E911 subscription %s", buf, 0xCu);
    }
  }
LABEL_14:
  int v16 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = subscriber::asString();
    *(_DWORD *)uint64_t buf = 136315138;
    *(void *)char v27 = v17;
    _os_log_impl(&dword_22231A000, v16, OS_LOG_TYPE_DEFAULT, "#I Using %s as preferred E911 subscription", buf, 0xCu);
  }
  if (v13 != 2)
  {
    if (v13 != 1)
    {
      uint64_t v19 = 0;
LABEL_23:
      BOOL v20 = 0;
      goto LABEL_24;
    }
LABEL_18:
    int v18 = (_DWORD *)v2[10];
    uint64_t v19 = 1;
    if ((_DWORD *)v2[11] != v18)
    {
LABEL_19:
      BOOL v20 = *v18 == 2;
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  uint64_t v21 = v2[10];
  if ((unint64_t)(v2[11] - v21) >= 5)
  {
    int v18 = (_DWORD *)(v21 + 4);
    uint64_t v19 = 2;
    goto LABEL_19;
  }
  BOOL v20 = 0;
  uint64_t v19 = 2;
LABEL_24:
  uint64_t v22 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = CSIBOOLAsString();
    *(_DWORD *)uint64_t buf = 136315138;
    *(void *)char v27 = v23;
    _os_log_impl(&dword_22231A000, v22, OS_LOG_TYPE_DEFAULT, "#I Is emergency call going to be set up as normal: %s", buf, 0xCu);
  }
  uint64_t result = (*(uint64_t (**)(void, unint64_t))(**(void **)(v3 + 64) + 144))(*(void *)(v3 + 64), v20 | (unint64_t)(v19 << 32));
  if (!v20) {
    QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator()((uint64_t)(v2 + 1), v19);
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c162_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNS_6vectorI18EmergencySetupTypeNS_9allocatorIS5_EEEEbbS3_bE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c162_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNS_6vectorI18EmergencySetupTypeNS_9allocatorIS5_EEEEbbS3_bE3__2EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_2,std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6DF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_2,std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6DF8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_2,std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_2>>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (void *)a1[13];
  if (v2)
  {
    a1[14] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[10];
  if (v3)
  {
    a1[11] = v3;
    operator delete(v3);
  }
  int v4 = (void *)a1[5];
  if (v4)
  {
    a1[6] = v4;
    operator delete(v4);
  }
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas10GetE911Sub8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222523564(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver13exitE911StateEN10subscriber7SimSlotEE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(uint64_t **)(a1 + 32);
  int v4 = *(_DWORD *)(a2 + 4);
  uint64_t v5 = *v3;
  uint64_t v6 = *(NSObject **)v3[1];
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (!v4)
  {
    if (v7)
    {
      LOWORD(v13) = 0;
      int v10 = "#I Exit E911 state successful";
      unsigned __int8 v11 = v6;
      uint32_t v12 = 2;
      goto LABEL_9;
    }
LABEL_10:
    (*(void (**)(void))(**(void **)(v5 + 64) + 160))(*(void *)(v5 + 64));
    return;
  }
  if (v7)
  {
    int v13 = 67109378;
    int v14 = v4;
    __int16 v15 = 2080;
    uint64_t v16 = qmi::asString();
    _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#N Exit E911 state failed: Error in response with code %d (%s)", (uint8_t *)&v13, 0x12u);
    int v4 = *(_DWORD *)(a2 + 4);
  }
  if (v4 == 26)
  {
    int v8 = *(NSObject **)v3[1];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = qmi::asString();
      int v13 = 67109378;
      int v14 = 26;
      __int16 v15 = 2080;
      uint64_t v16 = v9;
      int v10 = "#I E911 state exit failed with code %d (%s), send Completed indication anyway";
      unsigned __int8 v11 = v8;
      uint32_t v12 = 18;
LABEL_9:
      _os_log_impl(&dword_22231A000, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v13, v12);
      goto LABEL_10;
    }
    goto LABEL_10;
  }
}

uint64_t __copy_helper_block_e8_32c101_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver13exitE911StateEN10subscriber7SimSlotEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c101_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver13exitE911StateEN10subscriber7SimSlotEE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::exitE911State(subscriber::SimSlot)::$_1,std::allocator<QMINetworkRegistrationDriver::exitE911State(subscriber::SimSlot)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6E78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::exitE911State(subscriber::SimSlot)::$_1,std::allocator<QMINetworkRegistrationDriver::exitE911State(subscriber::SimSlot)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6E78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver35setImsProceedWithSubscriptionChangeEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    uint64_t v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N ProceedWithSubscriptionChange request failed: Error in response with code %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c123_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver35setImsProceedWithSubscriptionChangeEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c123_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver35setImsProceedWithSubscriptionChangeEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setImsProceedWithSubscriptionChange(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::setImsProceedWithSubscriptionChange(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6EF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setImsProceedWithSubscriptionChange(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::setImsProceedWithSubscriptionChange(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6EF8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver25getImsPreferenceInfo_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  int v3 = *((_DWORD *)this + 1);
  if (v3)
  {
    int v4 = *(NSObject **)v2[2];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v3;
      LOWORD(v30) = 2080;
      *(void *)((char *)&v30 + 2) = qmi::asString();
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#N Get IMS preference failed: Error in response with code %d (%s)", buf, 0x12u);
    }
  }
  else
  {
    uint64_t v6 = *v2;
    unsigned int v7 = *((_DWORD *)v2 + 2);
    int v8 = (capabilities::ct *)v2[2];
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(this);
    if (TlvValue)
    {
      uint64_t v11 = TlvValue;
      int v12 = v10;
      uint64_t v21 = TlvValue;
      unsigned __int8 v13 = tlv::parseV<nas::tlv::IpPrefInfo>((unint64_t *)&v21, v10);
      if (v21)
      {
        __int16 v15 = v14;
        *(void *)uint64_t buf = 0;
        long long v30 = 0uLL;
        dataModesFromSysMode(v8, v13, (uint64_t)buf);
        uint64_t v16 = *(NSObject **)v8;
        if (*(void *)buf == (void)v30)
        {
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            LODWORD(__p) = 67109120;
            HIDWORD(__p) = v15;
            _os_log_error_impl(&dword_22231A000, v16, OS_LOG_TYPE_ERROR, "Get IMS preference retrieved with IMS supported = %d and no data modes", (uint8_t *)&__p, 8u);
          }
        }
        else
        {
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            asString();
            uint64_t v17 = v24 >= 0 ? &__p : (void **)__p;
            *(_DWORD *)uint64_t v25 = 67109378;
            int v26 = (int)v15;
            __int16 v27 = 2082;
            __int16 v28 = v17;
            _os_log_impl(&dword_22231A000, v16, OS_LOG_TYPE_DEFAULT, "#I IMS preference retrieved: IMS supported = %d, data modes = %{public}s", v25, 0x12u);
            if (SHIBYTE(v24) < 0) {
              operator delete(__p);
            }
          }
          uint64_t v18 = *(void *)(v6 + 64);
          if (v7 - 1 >= 3) {
            uint64_t v19 = 0;
          }
          else {
            uint64_t v19 = v7;
          }
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          std::string __p = 0;
          std::vector<DataMode>::__init_with_size[abi:ne180100]<DataMode*,DataMode*>(&__p, *(const void **)buf, v30, (uint64_t)(v30 - *(void *)buf) >> 2);
          unsigned int v20 = sd::imsServiceMaskFromUint(v15);
          (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)v18 + 128))(v18, v19, &__p, v20);
          if (__p)
          {
            uint64_t v23 = __p;
            operator delete(__p);
          }
        }
        if (*(void *)buf)
        {
          *(void *)&long long v30 = *(void *)buf;
          operator delete(*(void **)buf);
        }
      }
      else
      {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)this, 16, v11, v12);
      }
    }
  }
}

void sub_222523BF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver25getImsPreferenceInfo_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver25getImsPreferenceInfo_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getImsPreferenceInfo_sync(qmi::SubscriptionType)::$_0,std::allocator<QMINetworkRegistrationDriver::getImsPreferenceInfo_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6F78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getImsPreferenceInfo_sync(qmi::SubscriptionType)::$_0,std::allocator<QMINetworkRegistrationDriver::getImsPreferenceInfo_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D6F78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas20GetImsPreferenceInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222523DA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void *std::vector<DataMode>::__init_with_size[abi:ne180100]<DataMode*,DataMode*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<unsigned int>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_222523E44(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::BasebandIpState>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::BasebandIpState>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::BasebandIpState>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::BasebandIpState>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver9enableImsEN10subscriber7SimSlotE19ImsStateForBasebandE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 4))
  {
    char v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 32) + 88) + 16))(*(void *)(**(void **)(a1 + 32) + 88), *(unsigned int *)(*(void *)(a1 + 32) + 8));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(a2 + 4);
      v5[0] = 67109378;
      v5[1] = v4;
      __int16 v6 = 2080;
      uint64_t v7 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N IMS setting failed to be sent to baseband: Error in response with code %d (%s)", (uint8_t *)v5, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c117_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver9enableImsEN10subscriber7SimSlotE19ImsStateForBasebandE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c117_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver9enableImsEN10subscriber7SimSlotE19ImsStateForBasebandE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enableIms(subscriber::SimSlot,ImsStateForBaseband)::$_1,std::allocator<QMINetworkRegistrationDriver::enableIms(subscriber::SimSlot,ImsStateForBaseband)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7048;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enableIms(subscriber::SimSlot,ImsStateForBaseband)::$_1,std::allocator<QMINetworkRegistrationDriver::enableIms(subscriber::SimSlot,ImsStateForBaseband)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7048;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NR5GVoiceSupportSetting>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NR5GVoiceSupportSetting>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NR5GVoiceSupportSetting>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NR5GVoiceSupportSetting>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver15updateVoNRStateEN10subscriber7SimSlotE20VoNRStateForBasebandE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 4))
  {
    char v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 32) + 88) + 16))(*(void *)(**(void **)(a1 + 32) + 88), *(unsigned int *)(*(void *)(a1 + 32) + 8));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(a2 + 4);
      v5[0] = 67109378;
      v5[1] = v4;
      __int16 v6 = 2080;
      uint64_t v7 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N VoNR setting failed to be sent to baseband: Error in response with code %d (%s)", (uint8_t *)v5, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c125_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15updateVoNRStateEN10subscriber7SimSlotE20VoNRStateForBasebandE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c125_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15updateVoNRStateEN10subscriber7SimSlotE20VoNRStateForBasebandE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::updateVoNRState(subscriber::SimSlot,VoNRStateForBaseband)::$_1,std::allocator<QMINetworkRegistrationDriver::updateVoNRState(subscriber::SimSlot,VoNRStateForBaseband)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7118;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::updateVoNRState(subscriber::SimSlot,VoNRStateForBaseband)::$_1,std::allocator<QMINetworkRegistrationDriver::updateVoNRState(subscriber::SimSlot,VoNRStateForBaseband)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7118;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::DataRoamingSwitch>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::DataRoamingSwitch>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::DataRoamingSwitch>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::DataRoamingSwitch>::clone()
{
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver15sendDataRoamingEN10subscriber7SimSlotEbE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *v2;
  if (*(_DWORD *)(a2 + 4))
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 88) + 16))(*(void *)(v3 + 88), *((unsigned int *)v2 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v8 = *(_DWORD *)(a2 + 4);
      v9[0] = 67109378;
      v9[1] = v8;
      __int16 v10 = 2080;
      uint64_t v11 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Send Data Roaming switch failed: %d (%s)", (uint8_t *)v9, 0x12u);
    }
    return (*(uint64_t (**)(void, void, void))(**(void **)(v3 + 64) + 120))(*(void *)(v3 + 64), *((unsigned int *)v2 + 2), 0);
  }
  else
  {
    uint64_t v7 = *(uint64_t (**)(void))(**(void **)(v3 + 64) + 120);
    return v7();
  }
}

uint64_t __copy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15sendDataRoamingEN10subscriber7SimSlotEbE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15sendDataRoamingEN10subscriber7SimSlotEbE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendDataRoaming(subscriber::SimSlot,BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::sendDataRoaming(subscriber::SimSlot,BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D71E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendDataRoaming(subscriber::SimSlot,BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::sendDataRoaming(subscriber::SimSlot,BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D71E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::IpDataMode>(uint64_t a1)
{
  uint64_t v1 = *(const void ***)(a1 + 8);
  uint64_t v2 = *(const void ***)(a1 + 16);
  if (v1 != v2)
  {
    while (*((unsigned char *)*v1 + 8) != 1)
    {
      if (++v1 == v2) {
        goto LABEL_8;
      }
    }
  }
  if (v1 == v2) {
LABEL_8:
  }
    operator new();
  if (!v3) {
    __cxa_bad_cast();
  }
  return v3 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpDataMode>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpDataMode>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpDataMode>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpDataMode>::clone()
{
}

void *qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationStates>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4D72A0;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationStates>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4D72A0;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x223C9A950);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationStates>::getSize(uint64_t a1)
{
  return tlv::size<nas::tlv::IpRegistrationStates>((void *)(a1 + 16));
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationStates>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<nas::tlv::IpRegistrationStates>((unsigned char **)a2, (_DWORD *)(a1 + 16));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationStates>::clone()
{
}

void sub_222524AD0(_Unwind_Exception *a1)
{
  int v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 24) = v4;
    operator delete(v4);
  }
  MEMORY[0x223C9A950](v1, 0x10A1C403082B835);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationEndCause>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationEndCause>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationEndCause>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationEndCause>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationRetryTimer>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationRetryTimer>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationRetryTimer>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationRetryTimer>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver15updateIMSStatusEN10subscriber7SimSlotE21RadioAccessTechnology8DataModeN5caulk10option_setIN2sd14ImsServiceTypeEjEEjE3__4EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    char v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N Update IMS Status failed: Error in response with code %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c180_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15updateIMSStatusEN10subscriber7SimSlotE21RadioAccessTechnology8DataModeN5caulk10option_setIN2sd14ImsServiceTypeEjEEjE3__4EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c180_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15updateIMSStatusEN10subscriber7SimSlotE21RadioAccessTechnology8DataModeN5caulk10option_setIN2sd14ImsServiceTypeEjEEjE3__4EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::updateIMSStatus(subscriber::SimSlot,RadioAccessTechnology,DataMode,caulk::option_set<sd::ImsServiceType,unsigned int>,unsigned int)::$_4,std::allocator<QMINetworkRegistrationDriver::updateIMSStatus(subscriber::SimSlot,RadioAccessTechnology,DataMode,caulk::option_set<sd::ImsServiceType,unsigned int>,unsigned int)::$_4>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D73A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::updateIMSStatus(subscriber::SimSlot,RadioAccessTechnology,DataMode,caulk::option_set<sd::ImsServiceType,unsigned int>,unsigned int)::$_4,std::allocator<QMINetworkRegistrationDriver::updateIMSStatus(subscriber::SimSlot,RadioAccessTechnology,DataMode,caulk::option_set<sd::ImsServiceType,unsigned int>,unsigned int)::$_4>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D73A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::SADisableStatus>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::SADisableStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::SADisableStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::SADisableStatus>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver22update5GStandaloneInfoEN10subscriber7SimSlotEbE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    char v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N Update SA Info failed: Error in response with code %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver22update5GStandaloneInfoEN10subscriber7SimSlotEbE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver22update5GStandaloneInfoEN10subscriber7SimSlotEbE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::update5GStandaloneInfo(subscriber::SimSlot,BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::update5GStandaloneInfo(subscriber::SimSlot,BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7478;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::update5GStandaloneInfo(subscriber::SimSlot,BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::update5GStandaloneInfo(subscriber::SimSlot,BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7478;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ClosedSubscriberGroupID>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ClosedSubscriberGroupID>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::ClosedSubscriberGroupID>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ClosedSubscriberGroupID>::clone()
{
}

void std::__shared_ptr_emplace<ctu::rest::command_responder_t<CSGSearchResponse>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7518;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ctu::rest::command_responder_t<CSGSearchResponse>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7518;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_emplace<ctu::rest::command_responder_t<CSGSearchResponse>>::__on_zero_shared(uint64_t a1)
{
  if (*(void *)(a1 + 64))
  {
    write_rest_value();
    uint64_t v2 = *(void ***)(a1 + 64);
    char v3 = *v2;
    void *v2 = v5;
    xpc_release(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver34triggerClosedSubscriberGroupSearchEN10subscriber7SimSlotENSt3__112basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEiNS6_8optionalI9MCCAndMNCEEON3ctu4rest19command_responder_tI17CSGSearchResponseEEE3__1EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(long long **)(a1 + 32);
  int v3 = *((_DWORD *)this + 1);
  if (v3)
  {
    int v4 = **((void **)v2 + 6);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109378;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v3;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = qmi::asString();
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#N Trigger closed subscriber group request failed: %d (%s)", (uint8_t *)&buf, 0x12u);
    }
  }
  else
  {
    if (*((char *)v2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&buf, *(const std::string::value_type **)v2, *((void *)v2 + 1));
    }
    else
    {
      long long v6 = *v2;
      buf.__r_.__value_.__r.__words[2] = *((void *)v2 + 2);
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v6;
    }
    int v19 = *((_DWORD *)v2 + 6);
    unsigned int v20 = (os_log_t *)*((void *)v2 + 6);
    uint64_t v21 = *((void *)v2 + 4);
    uint64_t v7 = (std::__shared_weak_count *)*((void *)v2 + 5);
    uint64_t v22 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(this);
    uint64_t v10 = TlvValue;
    if (TlvValue)
    {
      int v11 = v9;
      uint64_t v17 = TlvValue;
      unsigned int v12 = tlv::parseV<nas::tlv::CnfReason>((unint64_t *)&v17, v9);
      if (v17)
      {
        unsigned int v13 = v12;
        int v14 = *v20;
        if (os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t v23 = 67109120;
          unsigned int v24 = v13;
          _os_log_impl(&dword_22231A000, v14, OS_LOG_TYPE_DEFAULT, "#I Trigger closed subscriber group request succeeded (reason %d)", v23, 8u);
        }
        if (v13 >= 4) {
          char v15 = 0;
        }
        else {
          char v15 = v13;
        }
        uint64_t v16 = v21;
        *(unsigned char *)uint64_t v21 = v15;
        std::string::operator=((std::string *)(v16 + 8), &buf);
        *(_DWORD *)(v21 + 32) = v19;
      }
      else
      {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)this, 161, v10, v11);
      }
    }
    if (v22) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v22);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
  }
}

void sub_22252543C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
}

uint64_t __copy_helper_block_e8_32c260_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver34triggerClosedSubscriberGroupSearchEN10subscriber7SimSlotENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiNS_8optionalI9MCCAndMNCEEON3ctu4rest19command_responder_tI17CSGSearchResponseEEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c260_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver34triggerClosedSubscriberGroupSearchEN10subscriber7SimSlotENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiNS_8optionalI9MCCAndMNCEEON3ctu4rest19command_responder_tI17CSGSearchResponseEEE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::triggerClosedSubscriberGroupSearch(subscriber::SimSlot,std::string,int,std::optional<MCCAndMNC>,ctu::rest::command_responder_t<CSGSearchResponse> &&)::$_1,std::allocator<ctu::rest::command_responder_t<CSGSearchResponse> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7598;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::triggerClosedSubscriberGroupSearch(subscriber::SimSlot,std::string,int,std::optional<MCCAndMNC>,ctu::rest::command_responder_t<CSGSearchResponse> &&)::$_1,std::allocator<ctu::rest::command_responder_t<CSGSearchResponse> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7598;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::triggerClosedSubscriberGroupSearch(subscriber::SimSlot,std::string,int,std::optional<MCCAndMNC>,ctu::rest::command_responder_t<CSGSearchResponse> &&)::$_1,std::allocator<ctu::rest::command_responder_t<CSGSearchResponse> &&>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  if (*(char *)(a1 + 47) < 0)
  {
    int v3 = *(void **)(a1 + 24);
    operator delete(v3);
  }
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas28TriggerClosedSubscriberGroup8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    long long v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      long long v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222525628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::UserReboot>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::UserReboot>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::UserReboot>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::UserReboot>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver35sendCommCenterStartsSincePowerCycleEjE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    char v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N Sending system selection preference user reboot information failed: %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver35sendCommCenterStartsSincePowerCycleEjE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver35sendCommCenterStartsSincePowerCycleEjE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendCommCenterStartsSincePowerCycle(unsigned int)::$_1,std::allocator<QMINetworkRegistrationDriver::sendCommCenterStartsSincePowerCycle(unsigned int)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7668;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendCommCenterStartsSincePowerCycle(unsigned int)::$_1,std::allocator<QMINetworkRegistrationDriver::sendCommCenterStartsSincePowerCycle(unsigned int)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7668;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas28SetSystemSelectionPreference8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  cast_message_type<nas::SetSystemSelectionPreference::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2225258F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::Mcc>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::Mcc>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::Mcc>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::Mcc>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::Confidence>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::Confidence>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::Confidence>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::Confidence>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::DetectionStatus>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::DetectionStatus>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::DetectionStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::DetectionStatus>::clone()
{
}

void *qmi::MutableMessageBase::TlvWrapper<nas::tlv::BorderMcc>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4D77C0;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::BorderMcc>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4D77C0;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x223C9A950);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::BorderMcc>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::NextHdrProtList>((void *)(a1 + 16));
}

void *qmi::MutableMessageBase::TlvWrapper<nas::tlv::BorderMcc>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::DestPortList>((unsigned char **)a2, (_DWORD *)(a1 + 16));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::BorderMcc>::clone()
{
}

void sub_222525D48(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN28QMINetworkRegistrationDriver10setGeoMccsEN10subscriber7SimSlotERKNSt3__16vectorItNS6_9allocatorItEEEEENK3__0clINS_16SubscriptionTypeEEEDaT_EUlRKN3nas6SetMcc8ResponseEE_EEOS1_OSH__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    char v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#N Sending set mcc failed: %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c196_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver10setGeoMccsEN10subscriber7SimSlotERKNS_6vectorItNS_9allocatorItEEEEENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKN3nas6SetMcc8ResponseEE_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c196_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver10setGeoMccsEN10subscriber7SimSlotERKNS_6vectorItNS_9allocatorItEEEEENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKN3nas6SetMcc8ResponseEE_EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void _ZNSt3__120__shared_ptr_emplaceIZZN28QMINetworkRegistrationDriver10setGeoMccsEN10subscriber7SimSlotERKNS_6vectorItNS_9allocatorItEEEEENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKN3nas6SetMcc8ResponseEE_NS5_ISL_EEED1Ev(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7828;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void _ZNSt3__120__shared_ptr_emplaceIZZN28QMINetworkRegistrationDriver10setGeoMccsEN10subscriber7SimSlotERKNS_6vectorItNS_9allocatorItEEEEENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKN3nas6SetMcc8ResponseEE_NS5_ISL_EEED0Ev(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D7828;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas6SetMcc8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222525F94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegistrationOverSatPlmnsStatus>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegistrationOverSatPlmnsStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegistrationOverSatPlmnsStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegistrationOverSatPlmnsStatus>::clone()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver24setSatelliteSystemConfigEN10subscriber7SimSlotERK21SatelliteSystemConfigE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  char v3 = ***(NSObject ****)(a1 + 32);
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "Set satellite system config failed: %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I Set satellite system config successful", (uint8_t *)v4, 2u);
  }
}

uint64_t __copy_helper_block_e8_32c137_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver24setSatelliteSystemConfigEN10subscriber7SimSlotERK21SatelliteSystemConfigE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c137_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver24setSatelliteSystemConfigEN10subscriber7SimSlotERK21SatelliteSystemConfigE3__1EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setSatelliteSystemConfig(subscriber::SimSlot,SatelliteSystemConfig const&)::$_1,std::allocator<QMINetworkRegistrationDriver::setSatelliteSystemConfig(subscriber::SimSlot,SatelliteSystemConfig const&)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D78F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setSatelliteSystemConfig(subscriber::SimSlot,SatelliteSystemConfig const&)::$_1,std::allocator<QMINetworkRegistrationDriver::setSatelliteSystemConfig(subscriber::SimSlot,SatelliteSystemConfig const&)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D78F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas24SetSatelliteSystemConfig8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_22252630C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkRegistrationDriver>::execute_wrapped<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0>(QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0,std::default_delete<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0>>)::{lambda(void *)#1}::__invoke(void **a1)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v1 = *a1;
  int v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = (void *)*v1;
  uint64_t v4 = v1[2];
  uint64_t v3 = v1[3];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  __int16 v5 = (std::__shared_weak_count *)v2[9];
  v2[8] = v4;
  v2[9] = v3;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  unsigned int v13 = &unk_26D4D7948;
  int v14 = v2;
  char v15 = &v13;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v13);
  unsigned int v13 = &unk_26D4D79C8;
  int v14 = v2;
  char v15 = &v13;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v13);
  unsigned int v13 = &unk_26D4D7A48;
  int v14 = v2;
  char v15 = &v13;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v13);
  unsigned int v13 = &unk_26D4D7AC8;
  int v14 = v2;
  char v15 = &v13;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v13);
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 13));
  unsigned int v13 = &unk_26D4D7B48;
  int v14 = v2;
  char v15 = &v13;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v13);
  unsigned int v13 = &unk_26D4D7BC8;
  int v14 = v2;
  char v15 = &v13;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v13);
  unsigned int v13 = &unk_26D4D7C48;
  int v14 = v2;
  char v15 = &v13;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v13);
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 13));
  unsigned int v13 = &unk_26D4D7CC8;
  int v14 = v2;
  char v15 = &v13;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v13);
  unsigned int v13 = &unk_26D4D7D48;
  int v14 = v2;
  char v15 = &v13;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v13);
  unsigned int v13 = &unk_26D4D7DC8;
  int v14 = v2;
  char v15 = &v13;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v13);
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 13));
  unsigned int v13 = &unk_26D4D7E48;
  int v14 = v2;
  char v15 = &v13;
  qmi::ClientRouter::setIndHandlerInternal();
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v13);
  unsigned int v13 = &unk_26D4D7EC8;
  int v14 = v2;
  char v15 = &v13;
  qmi::ClientRouter::setIndHandlerInternal();
  uint64_t v6 = (capabilities::ct *)std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v13);
  if (capabilities::ct::supportsPrivateNetwork(v6))
  {
    unsigned int v13 = &unk_26D4D7F48;
    int v14 = v2;
    char v15 = &v13;
    qmi::ClientRouter::setIndHandlerInternal();
    std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v13);
  }
  v12[0] = &unk_26D4D7FC8;
  v12[1] = v2;
  void v12[3] = v12;
  qmi::ClientRouter::setHandler();
  std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](v12);
  v11[0] = &unk_26D4D8048;
  v11[1] = v2;
  v11[3] = v11;
  qmi::ClientRouter::setHandler();
  uint64_t v7 = (capabilities::ct *)std::__function::__value_func<void ()(qmi::SubscriptionType)>::~__value_func[abi:ne180100](v11);
  if (capabilities::ct::supportsPrivateNetwork(v7))
  {
    unsigned int v13 = &unk_26D4D80C8;
    int v14 = v2;
    char v15 = &v13;
    qmi::ClientRouter::setIndHandlerInternal();
    std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100](&v13);
  }
  std::unique_ptr<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)&v10);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v9);
}

void sub_2225267C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  std::__function::__value_func<void ()(qmi::SubscriptionType,QMIServiceMsg const&)>::~__value_func[abi:ne180100]((void *)(v2 - 72));
  std::unique_ptr<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D7948;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D7948;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    __int16 v28 = 0;
    uint64_t v29 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v26, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v26);
    if (__p)
    {
      __int16 v28 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v26);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v26);
  int v9 = TlvValue;
  if (TlvValue)
  {
    int v10 = v8;
    std::string __p = TlvValue;
    unsigned __int8 v11 = tlv::parseV<nas::tlv::RejCause>((unint64_t *)&__p, v8);
    if (__p) {
      goto LABEL_12;
    }
    ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v26[0], 3, v9, v10);
  }
  unsigned __int8 v11 = 0;
LABEL_12:
  unsigned int v12 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v26);
  int v14 = v12;
  if (v12)
  {
    int v15 = v13;
    std::string __p = v12;
    char v16 = tlv::parseV<nas::tlv::RadioIf>((unint64_t *)&__p, v13);
    if (__p)
    {
      char v17 = v16 - 4;
      if (v16 - 4) <= 5u && ((0x33u >> v17))
      {
        uint64_t v18 = dword_22258DD24[v17];
        goto LABEL_19;
      }
    }
    else
    {
      ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v26[0], 1, v14, v15);
    }
  }
  uint64_t v18 = 11;
LABEL_19:
  int v19 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v26);
  uint64_t v21 = v19;
  if (v19)
  {
    int v22 = v20;
    std::string __p = v19;
    unsigned __int8 v23 = tlv::parseV<nas::tlv::ServiceDomain>((unint64_t *)&__p, v20);
    if (__p)
    {
      uint64_t v24 = v23;
      goto LABEL_24;
    }
    ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v26[0], 2, v21, v22);
  }
  uint64_t v24 = 0;
LABEL_24:
  if (v4 - 1 >= 3) {
    uint64_t v25 = 0;
  }
  else {
    uint64_t v25 = v4;
  }
  (*(void (**)(void, uint64_t, uint64_t, void, uint64_t))(**(void **)(v6 + 64) + 32))(*(void *)(v6 + 64), v25, v24, v11, v18);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v26);
}

void sub_222526AF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D79C8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D79C8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D7A48;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D7A48;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  uint64_t v82 = *MEMORY[0x263EF8340];
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p[0] = 0;
    __p[1] = 0;
    v59[0] = 0;
    QMIServiceMsg::serialize((uint64_t *)__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v57, __p[0]);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v57);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v57);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  unsigned int v7 = v4 - 1;
  if (v4 - 1 >= 3) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = v4;
  }
  int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl(&dword_22231A000, v9, OS_LOG_TYPE_DEFAULT, "#I Received current PLMN indication from baseband", (uint8_t *)__p, 2u);
  }
  if (v7 >= 3) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = v4;
  }
  unsigned __int8 v11 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v10);
  long long v65 = 0u;
  long long v66 = 0u;
  long long v64 = 0u;
  *(_OWORD *)char v62 = 0u;
  long long v63 = 0u;
  *(_OWORD *)char v60 = 0u;
  long long v61 = 0u;
  memset(v59, 0, sizeof(v59));
  *(_OWORD *)std::string __p = 0u;
  HIDWORD(v61) = 11;
  uint64_t v68 = 0;
  long long v67 = 0uLL;
  uint64_t TlvValue = (nas::tlv *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v57);
  int v14 = TlvValue;
  if (TlvValue)
  {
    int v15 = v13;
    char v69 = TlvValue;
    memset(buf, 0, 32);
    tlv::parseV<nas::tlv::PlmnShortName>((unint64_t *)&v69, v13, buf);
    char v16 = v69;
    if (v69)
    {
      decodeOperatorName();
      if (SHIBYTE(v59[3]) < 0) {
        operator delete(v59[1]);
      }
      *(_OWORD *)&v59[1] = v70;
      v59[3] = v71;
    }
    if (*(void *)&buf[8])
    {
      *(void *)&uint8_t buf[16] = *(void *)&buf[8];
      operator delete(*(void **)&buf[8]);
    }
    if (!v16) {
      ((void (*)(void, uint64_t, nas::tlv *, void))*MEMORY[0x263F8BD78])(v57[0], 18, v14, v15);
    }
  }
  char v17 = (nas::tlv *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v57);
  int v19 = v17;
  if (v17)
  {
    int v20 = v18;
    char v69 = v17;
    memset(buf, 0, 32);
    tlv::parseV<nas::tlv::PlmnLongName>((unint64_t *)&v69, v18, buf);
    uint64_t v21 = v69;
    if (v69)
    {
      decodeOperatorName();
      if (SHIBYTE(v59[0]) < 0) {
        operator delete(__p[0]);
      }
      *(_OWORD *)std::string __p = v70;
      v59[0] = v71;
    }
    if (*(void *)&buf[8])
    {
      *(void *)&uint8_t buf[16] = *(void *)&buf[8];
      operator delete(*(void **)&buf[8]);
    }
    if (!v21) {
      ((void (*)(void, uint64_t, nas::tlv *, void))*MEMORY[0x263F8BD78])(v57[0], 19, v19, v20);
    }
  }
  int v22 = (nas::tlv *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v57);
  uint64_t v24 = v22;
  if (v22)
  {
    int v25 = v23;
    char v69 = v22;
    memset(buf, 0, 32);
    tlv::parseV<nas::tlv::SrvProviderName>((unint64_t *)&v69, v23, buf);
    int v26 = v69;
    if (v69)
    {
      decodeOperatorName();
      if (SBYTE7(v61) < 0) {
        operator delete(v60[0]);
      }
      *(_OWORD *)char v60 = v70;
      *(void *)&long long v61 = v71;
    }
    if (*(void *)&buf[8])
    {
      *(void *)&uint8_t buf[16] = *(void *)&buf[8];
      operator delete(*(void **)&buf[8]);
    }
    if (!v26) {
      ((void (*)(void, uint64_t, nas::tlv *, void))*MEMORY[0x263F8BD78])(v57[0], 17, v24, v25);
    }
  }
  uint64_t v27 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v57);
  uint64_t v29 = v27;
  if (v27)
  {
    int v30 = v28;
    *(void *)std::string buf = v27;
    uint64_t v31 = tlv::parseV<nas::tlv::NetworkNameSource>((unint64_t *)buf, v28);
    if (*(void *)buf) {
      DWORD2(v61) = nas::convert(v31);
    }
    else {
      ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v57[0], 26, v29, v30);
    }
  }
  long long v32 = (nas::tlv *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v57);
  uint64_t v35 = v32;
  if (v32)
  {
    int v36 = v33;
    char v69 = v32;
    memset(buf, 0, sizeof(buf));
    tlv::parseV<nas::tlv::EvoNitzInfo>(&v69, v33, v34, (uint64_t)buf);
    char v37 = v69;
    if (v69)
    {
      decodeOperatorName();
      if (SHIBYTE(v68) < 0) {
        operator delete((void *)v67);
      }
      long long v67 = v70;
      uint64_t v68 = v71;
    }
    if (*(void *)&buf[32])
    {
      *(void *)&uint8_t buf[40] = *(void *)&buf[32];
      operator delete(*(void **)&buf[32]);
    }
    if (*(void *)&buf[8])
    {
      *(void *)&uint8_t buf[16] = *(void *)&buf[8];
      operator delete(*(void **)&buf[8]);
    }
    if (!v37) {
      ((void (*)(void, uint64_t, nas::tlv *, void))*MEMORY[0x263F8BD78])(v57[0], 160, v35, v36);
    }
  }
  char v38 = *v11;
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v54 = v6;
    unsigned int v55 = v4 - 1;
    unsigned int v56 = v4;
    int v39 = SHIBYTE(v59[0]);
    long long v40 = (void **)__p[0];
    int v41 = SHIBYTE(v59[3]);
    uint64_t v42 = (void **)v59[1];
    int v43 = SBYTE7(v61);
    char v44 = (void **)v60[0];
    int v45 = SHIBYTE(v68);
    char v46 = (long long *)v67;
    uint64_t v47 = asString();
    long long v48 = __p;
    uint64_t v49 = &v59[1];
    long long v50 = v60;
    if (v45 >= 0) {
      long long v51 = &v67;
    }
    else {
      long long v51 = v46;
    }
    *(_DWORD *)std::string buf = 136447234;
    if (v43 < 0) {
      long long v50 = v44;
    }
    if (v41 < 0) {
      uint64_t v49 = v42;
    }
    if (v39 < 0) {
      long long v48 = v40;
    }
    *(void *)&uint8_t buf[4] = v48;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v49;
    *(_WORD *)&buf[22] = 2082;
    *(void *)&uint8_t buf[24] = v50;
    *(_WORD *)&unsigned char buf[32] = 2082;
    *(void *)&buf[34] = v51;
    *(_WORD *)&buf[42] = 2080;
    *(void *)&buf[44] = v47;
    _os_log_impl(&dword_22231A000, v38, OS_LOG_TYPE_DEFAULT, "#I Received long name (%{public}s) short name (%{public}s) service provider name (%{public}s) TOE (%{public}s) and name source (%s)", buf, 0x34u);
    unsigned int v7 = v55;
    unsigned int v4 = v56;
    uint64_t v6 = v54;
  }
  uint64_t v52 = *(void *)(v6 + 64);
  OperatorNameUpdate::OperatorNameUpdate((std::string *)buf, (const OperatorNameUpdate *)__p);
  if (v7 >= 3) {
    uint64_t v53 = 0;
  }
  else {
    uint64_t v53 = v4;
  }
  (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v52 + 80))(v52, v53, buf);
  if (v81 < 0) {
    operator delete(v80);
  }
  if (v79 && v78 < 0) {
    operator delete(v77);
  }
  if (v76 && v75 < 0) {
    operator delete(v74);
  }
  if (v73 < 0) {
    operator delete(*(void **)&buf[48]);
  }
  if ((buf[47] & 0x80000000) != 0) {
    operator delete(*(void **)&buf[24]);
  }
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  if (SHIBYTE(v68) < 0) {
    operator delete((void *)v67);
  }
  if (BYTE8(v66) && SBYTE7(v66) < 0) {
    operator delete((void *)v65);
  }
  if ((_BYTE)v64 && SHIBYTE(v63) < 0) {
    operator delete(v62[1]);
  }
  if (SBYTE7(v61) < 0) {
    operator delete(v60[0]);
  }
  if (SHIBYTE(v59[3]) < 0) {
    operator delete(v59[1]);
  }
  if (SHIBYTE(v59[0]) < 0) {
    operator delete(__p[0]);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v57);
}

void sub_222527418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,void *a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48)
{
  if (__p)
  {
    a48 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a44)
  {
    a45 = (uint64_t)a44;
    operator delete(a44);
  }
  OperatorNameUpdate::~OperatorNameUpdate(&a15);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a12);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D7AC8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D7AC8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  uint64_t v77 = *MEMORY[0x263EF8340];
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&long long v48 = 0;
    QMIServiceMsg::serialize((uint64_t *)__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v46, __p[0]);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v46);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v46);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  unsigned int v7 = v4 - 1;
  if (v4 - 1 >= 3) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = v4;
  }
  int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl(&dword_22231A000, v9, OS_LOG_TYPE_DEFAULT, "#I Received network time indication from baseband", (uint8_t *)__p, 2u);
  }
  if (v7 >= 3) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = v4;
  }
  unsigned __int8 v11 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v10);
  uint64_t v56 = 0;
  long long v54 = 0u;
  long long v55 = 0u;
  *(_OWORD *)uint64_t v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  *(_OWORD *)std::string __p = 0u;
  DWORD2(v50) = -1;
  LOBYTE(v51) = 1;
  DWORD1(v51) = 11;
  uint64_t TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v46);
  uint64_t v14 = TlvValue;
  if (TlvValue)
  {
    int v15 = v13;
    *(void *)&long long buf = TlvValue;
    unsigned __int8 v16 = tlv::parseV<nas::tlv::TimeFromRadioInterface>((unint64_t *)&buf, v13);
    if ((void)buf)
    {
      if (v16 <= 0xCu && ((0x133Fu >> v16) & 1) != 0) {
        DWORD1(v51) = dword_22258DD3C[(char)v16];
      }
    }
    else
    {
      ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v46[0], 18, v14, v15);
    }
  }
  uint64_t v17 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v46);
  uint64_t v19 = v17;
  if (v17)
  {
    int v20 = v18;
    *(void *)&long long v58 = v17;
    unsigned __int8 v21 = tlv::parseV<nas::tlv::DatelightSavings>((unint64_t *)&v58, v18);
    if ((void)v58)
    {
      int v22 = v21;
      DWORD2(v50) = v21;
      if (v21 <= 1u) {
        BYTE4(v49) = v21 == 1;
      }
      int v23 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 67109120;
        DWORD1(buf) = v22;
        _os_log_impl(&dword_22231A000, v23, OS_LOG_TYPE_DEFAULT, "#I DST is present with value %d", (uint8_t *)&buf, 8u);
      }
      LODWORD(v19) = 1;
    }
    else
    {
      LODWORD(v19) = ((uint64_t (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v46[0], 17, v19, v20);
    }
  }
  uint64_t v24 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v46);
  uint64_t v26 = v24;
  if (v24)
  {
    int v27 = v25;
    *(void *)&long long buf = v24;
    unint64_t v28 = tlv::parseV<nas::tlv::UniversalTime>((unint64_t *)&buf, v25);
    if ((void)buf)
    {
      DWORD2(v48) = BYTE2(v28);
      HIDWORD(v48) = (unsigned __int16)v28;
      __p[1] = (void *)vand_s8((int8x8_t)vmovn_s64((int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v28), (uint64x2_t)xmmword_222588ED0)), (int8x8_t)0xFF000000FFLL);
      LODWORD(v48) = BYTE6(v28);
      DWORD1(v48) = BYTE3(v28);
      uint64_t v29 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v58) = 0;
        _os_log_impl(&dword_22231A000, v29, OS_LOG_TYPE_DEFAULT, "#I Time values are present", (uint8_t *)&v58, 2u);
      }
      LODWORD(v26) = 1;
    }
    else
    {
      LODWORD(v26) = ((uint64_t (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v46[0], 1, v26, v27);
    }
  }
  uint64_t v30 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v46);
  uint64_t v32 = v30;
  if (v30)
  {
    int v33 = v31;
    *(void *)&long long v58 = v30;
    char v34 = tlv::parseV<nas::tlv::TimeZone>((unint64_t *)&v58, v31);
    if ((void)v58)
    {
      int v35 = *MEMORY[0x263F03800] * v34;
      LODWORD(v49) = v35;
      int v36 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 67109120;
        DWORD1(buf) = v35;
        _os_log_impl(&dword_22231A000, v36, OS_LOG_TYPE_DEFAULT, "#I Timezone offset is present with value %d", (uint8_t *)&buf, 8u);
      }
      int v37 = 1;
    }
    else
    {
      int v37 = ((uint64_t (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v46[0], 16, v32, v33);
    }
  }
  else
  {
    int v37 = 0;
  }
  if ((((v26 | v37) ^ 1 | v19) & 1) == 0)
  {
    char v38 = *v11;
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_22231A000, v38, OS_LOG_TYPE_DEFAULT, "#I DST TLV is absent. Assuming it to be 0", (uint8_t *)&buf, 2u);
    }
    DWORD2(v50) = 0;
    BYTE4(v49) = 0;
  }
  uint64_t v39 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v46);
  uint64_t v41 = v39;
  if (v39)
  {
    int v42 = v40;
    uint64_t v57 = v39;
    unint64_t v43 = tlv::parseV<nas::tlv::TimeFromPLMN>((unint64_t *)&v57, v40);
    if (v57)
    {
      __int16 v62 = v43;
      char v63 = BYTE2(v43);
      char v61 = BYTE5(v43);
      __int16 v60 = v43 >> 24;
      long long buf = 0u;
      long long v65 = 0u;
      MCC::MCC((MCC *)&buf);
      long long v58 = 0u;
      long long v59 = 0u;
      MNC::MNC((MNC *)&v58);
      convertMccAndMnc((unsigned __int8 *)&v62, (unsigned __int8 *)&v60, (const MCC *)&buf, (const MNC *)&v58);
      std::optional<MCC>::operator=[abi:ne180100]<MCC&,void>((uint64_t)&v51 + 8);
      std::optional<MNC>::operator=[abi:ne180100]<MNC&,void>((MCC *)&v54, (const MCC *)&v58);
      if (SHIBYTE(v59) < 0) {
        operator delete(*((void **)&v58 + 1));
      }
      if (SHIBYTE(v65) < 0) {
        operator delete(*((void **)&buf + 1));
      }
    }
    else
    {
      ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v46[0], 193, v41, v42);
    }
  }
  uint64_t v44 = *(void *)(v6 + 64);
  if (v7 >= 3) {
    uint64_t v45 = 0;
  }
  else {
    uint64_t v45 = v4;
  }
  long long v66 = v49;
  long long v67 = v50;
  long long buf = *(_OWORD *)__p;
  long long v65 = v48;
  uint64_t v68 = v51;
  std::__optional_copy_base<MCC,false>::__optional_copy_base[abi:ne180100](v69, (uint64_t)&v51 + 8);
  std::__optional_copy_base<MNC,false>::__optional_copy_base[abi:ne180100]((MCC *)&v73, (const MCC *)&v54);
  (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)v44 + 88))(v44, v45, &buf);
  if (v76 && v75 < 0) {
    operator delete(v74);
  }
  if (v72 && v71 < 0) {
    operator delete(v70);
  }
  if ((_BYTE)v56 && SHIBYTE(v55) < 0) {
    operator delete(*((void **)&v54 + 1));
  }
  if (BYTE8(v53) && SBYTE7(v53) < 0) {
    operator delete(v52[0]);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v46);
}

void sub_222527C4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,char a42,void *__p,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,int a57,__int16 a58,char a59,char a60,char a61)
{
  if (a48 < 0) {
    operator delete(__p);
  }
  NetworkTimeUpdate::~NetworkTimeUpdate(&a13);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D7B48;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D7B48;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v4 = *a2;
  cast_message_type<nas::SystemSelectionPreference::Indication const&>::cast(a3, (qmi::MessageBase *)v14);
  __int16 v5 = *(capabilities::ct **)(a1 + 8);
  if (v4 - 1 >= 3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v4;
  }
  unsigned int v7 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(**((void **)v5 + 11) + 16))(*((void **)v5 + 11), v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#I Received system selection preference update from baseband", buf, 2u);
  }
  uint64_t TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v14);
  if (TlvValue)
  {
    *(_DWORD *)long long buf = 0;
    qmi::MessageBase::tryTlv<nas::tlv::ModePreference>((qmi::MessageBase *)v14, (uint64_t)buf);
    if (!buf[0]) {
      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
    }
    int v9 = *(_WORD *)&buf[2] & 0xFF00;
    int v10 = buf[2];
    int v11 = 0x10000;
  }
  else
  {
    int v11 = 0;
    int v10 = 0;
    int v9 = 0;
  }
  unsigned int v12 = (capabilities::ct *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v14);
  if (v12)
  {
    *(void *)long long buf = 0;
    unsigned int v12 = (capabilities::ct *)qmi::MessageBase::tryTlv<nas::tlv::GwAcqOrderPref>((qmi::MessageBase *)v14, (uint64_t)buf);
    if (!buf[0]) {
      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
    }
  }
  if (!capabilities::ct::supports5G(v12) || !qmi::MessageBase::findTlvValue((qmi::MessageBase *)v14))
  {
    if (!TlvValue) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  *(void *)long long buf = 0;
  qmi::MessageBase::tryTlv<nas::tlv::NRDisableMode>((qmi::MessageBase *)v14, (uint64_t)buf);
  if (!buf[0]) {
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
  if (TlvValue) {
LABEL_18:
  }
    QMINetworkRegistrationDriver::handleModePreference_sync(v5, v6, v10 | v11 | v9);
LABEL_19:
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v14))
  {
    *(_WORD *)long long buf = 0;
    qmi::MessageBase::tryTlv<nas::tlv::EmergencyMode>((qmi::MessageBase *)v14, buf);
    if (!buf[0]) {
      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
    }
    if (buf[1]) {
      uint64_t v13 = 257;
    }
    else {
      uint64_t v13 = 1;
    }
    (*(void (**)(void *, uint64_t, uint64_t))(**((void **)v5 + 8) + 24))(*((void **)v5 + 8), v6, v13);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v14);
}

void sub_2225280C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D7BC8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D7BC8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v26, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v26);
    if (__p)
    {
      uint64_t v32 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v26);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  unsigned int v7 = v4 - 1;
  if (v4 - 1 >= 3) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = v4;
  }
  int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_22231A000, v9, OS_LOG_TYPE_DEFAULT, "#I Received IMS preference update from baseband", (uint8_t *)&__p, 2u);
  }
  uint64_t TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v26);
  uint64_t v12 = TlvValue;
  if (TlvValue)
  {
    int v13 = v11;
    uint64_t v27 = TlvValue;
    unsigned __int8 v14 = tlv::parseV<nas::tlv::IpPrefInfo>((unint64_t *)&v27, v11);
    if (v27)
    {
      unsigned __int8 v16 = v14;
      uint64_t v17 = v15;
      if (v7 >= 3) {
        uint64_t v18 = 0;
      }
      else {
        uint64_t v18 = v4;
      }
      uint64_t v19 = (capabilities::ct *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v18);
      std::string __p = 0;
      uint64_t v32 = 0;
      uint64_t v33 = 0;
      dataModesFromSysMode(v19, v16, (uint64_t)&__p);
      int v20 = __p;
      if (__p != v32)
      {
        unsigned __int8 v21 = *(NSObject **)v19;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          asString();
          int v22 = v30 >= 0 ? &v28 : (void **)v28;
          *(_DWORD *)long long buf = 67109378;
          int v35 = (int)v17;
          __int16 v36 = 2082;
          int v37 = v22;
          _os_log_impl(&dword_22231A000, v21, OS_LOG_TYPE_DEFAULT, "#I IMS preference changed: IMS supported = %d, data modes = %{public}s", buf, 0x12u);
          if (SHIBYTE(v30) < 0) {
            operator delete(v28);
          }
        }
        uint64_t v23 = *(void *)(v6 + 64);
        if (v7 >= 3) {
          uint64_t v24 = 0;
        }
        else {
          uint64_t v24 = v4;
        }
        uint64_t v29 = 0;
        uint64_t v30 = 0;
        unint64_t v28 = 0;
        std::vector<DataMode>::__init_with_size[abi:ne180100]<DataMode*,DataMode*>(&v28, __p, (uint64_t)v32, (v32 - (unsigned char *)__p) >> 2);
        unsigned int v25 = sd::imsServiceMaskFromUint(v17);
        (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)v23 + 128))(v23, v24, &v28, v25);
        if (v28)
        {
          uint64_t v29 = v28;
          operator delete(v28);
        }
        int v20 = __p;
      }
      if (v20)
      {
        uint64_t v32 = v20;
        operator delete(v20);
      }
    }
    else
    {
      ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v26[0], 1, v12, v13);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v26);
}

void sub_2225284E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D7C48;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D7C48;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v10, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v10);
    if (__p)
    {
      uint64_t v12 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v10);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v4 - 1 >= 3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v4;
  }
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#I Received Subscription change indication from baseband", (uint8_t *)&__p, 2u);
  }
  if (v4 - 1 >= 3) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = v4;
  }
  (*(void (**)(void, uint64_t))(**(void **)(v6 + 64) + 184))(*(void *)(v6 + 64), v9);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v10);
}

void sub_222528798(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D7CC8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D7CC8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    int v11 = 0;
    uint64_t v12 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v9, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v9);
    if (__p)
    {
      int v11 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v9);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v4 - 1 >= 3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v4;
  }
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#I E911 state ready", (uint8_t *)&__p, 2u);
  }
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 64) + 136))(*(void *)(v6 + 64), 1, v7);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v9);
}

void sub_222528A14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D7D48;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D7D48;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  __p[3] = *(void **)MEMORY[0x263EF8340];
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    memset(__p, 0, 24);
    QMIServiceMsg::serialize((uint64_t *)__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v16, __p[0]);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v16);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v16);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v4 - 1 >= 3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v4;
  }
  uint64_t TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v16);
  uint64_t v10 = TlvValue;
  if (TlvValue)
  {
    int v11 = v9;
    uint64_t v17 = TlvValue;
    BOOL v12 = tlv::parseV<nas::tlv::SmsReady>((unint64_t *)&v17, v9);
    if (v17)
    {
      BOOL v13 = v12;
      unsigned __int8 v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v7);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        int v15 = (void *)asStringBool();
        LODWORD(__p[0]) = 136315138;
        *(void **)((char *)__p + 4) = v15;
        _os_log_impl(&dword_22231A000, v14, OS_LOG_TYPE_DEFAULT, "#I T911 state ready: %s", (uint8_t *)__p, 0xCu);
      }
      (*(void (**)(void, BOOL, uint64_t))(**(void **)(v6 + 64) + 136))(*(void *)(v6 + 64), v13, v7);
    }
    else
    {
      ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(v16[0], 16, v10, v11);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v16);
}

void sub_222528D34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D7DC8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D7DC8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    int v11 = 0;
    uint64_t v12 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v9, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v9);
    if (__p)
    {
      int v11 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v9);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v4 - 1 >= 3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v4;
  }
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#I E911 scan completed (failed)", (uint8_t *)&__p, 2u);
  }
  (*(void (**)(void, uint64_t))(**(void **)(v6 + 64) + 152))(*(void *)(v6 + 64), v7);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v9);
}

void sub_222528FB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D7E48;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D7E48;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    unsigned __int8 v16 = 0;
    uint64_t v17 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v14, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v14);
    if (__p)
    {
      unsigned __int8 v16 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v14);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v4 - 1 >= 3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v4;
  }
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#I T3402 timer changed", (uint8_t *)&__p, 2u);
  }
  uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v14);
  int v11 = TlvValue;
  if (!TlvValue) {
    goto LABEL_16;
  }
  int v12 = v10;
  std::string __p = TlvValue;
  uint64_t v13 = tlv::parseV<nas::tlv::T3402Timer>((unint64_t *)&__p, v10);
  if (!__p)
  {
    ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v14[0], 16, v11, v12);
LABEL_16:
    uint64_t v13 = 0;
  }
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 64) + 176))(*(void *)(v6 + 64), v7, v13);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v14);
}

void sub_222529280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D7EC8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D7EC8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    int v31 = 0;
    uint64_t v32 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v29, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v29);
    if (__p)
    {
      int v31 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v29);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v4 - 1 >= 3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v4;
  }
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v7);
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#I NR disable status changed", (uint8_t *)&__p, 2u);
  }
  if (capabilities::ct::supports5G((capabilities::ct *)v9))
  {
    if (v4 - 1 >= 3) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = v4;
    }
    uint64_t v11 = *(void *)(v6 + 64);
    uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v29);
    unsigned __int8 v14 = TlvValue;
    if (TlvValue)
    {
      int v15 = v13;
      std::string __p = TlvValue;
      tlv::parseV<nas::tlv::IsSADisabled>((unint64_t *)&__p, v13);
      if (!__p) {
        ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v29[0], 1, v14, v15);
      }
    }
    unsigned __int8 v16 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v29);
    uint64_t v18 = v16;
    if (v16)
    {
      int v19 = v17;
      std::string __p = v16;
      tlv::parseV<nas::tlv::SADisableReasonMask>((unint64_t *)&__p, v17);
      if (!__p) {
        ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v29[0], 16, v18, v19);
      }
    }
    int v20 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v29);
    int v22 = v20;
    if (v20)
    {
      int v23 = v21;
      std::string __p = v20;
      tlv::parseV<nas::tlv::IsNSADisabled>((unint64_t *)&__p, v21);
      if (!__p) {
        ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v29[0], 2, v22, v23);
      }
    }
    uint64_t v24 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v29);
    uint64_t v26 = v24;
    if (v24)
    {
      int v27 = v25;
      std::string __p = v24;
      uint64_t v28 = tlv::parseV<nas::tlv::NSADisableReasonMask>((unint64_t *)&__p, v25);
      if (!__p) {
        ((void (*)(void, uint64_t, void *, void, uint64_t))*MEMORY[0x263F8BD78])(v29[0], 17, v26, v27, v28);
      }
    }
    NRDisableStatus::NRDisableStatus((NRDisableStatus *)&__p);
    (*(void (**)(uint64_t, uint64_t, void *, void *))(*(void *)v11 + 216))(v11, v10, __p, v31);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v29);
}

void sub_222529698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D7F48;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D7F48;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    char v34 = 0;
    uint64_t v35 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v24, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v24);
    if (__p)
    {
      char v34 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v24);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v4 - 1 >= 3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v4;
  }
  uint64_t v8 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v7);
  char v32 = -1;
  __int16 v31 = -1;
  uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v24);
  uint64_t v11 = TlvValue;
  if (TlvValue)
  {
    int v12 = v10;
    std::string __p = TlvValue;
    int v13 = tlv::parseV<nas::tlv::GeoMcc>((unint64_t *)&__p, v10);
    if (__p)
    {
      __int16 v31 = v13;
      char v32 = BYTE2(v13);
    }
    else
    {
      ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v24[0], 16, v11, v12);
    }
  }
  char v30 = -1;
  __int16 v29 = -1;
  unsigned __int8 v14 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v24);
  unsigned __int8 v16 = v14;
  if (v14)
  {
    int v17 = v15;
    std::string __p = v14;
    int v18 = tlv::parseV<nas::tlv::GeoMnc>((unint64_t *)&__p, v15);
    if (__p)
    {
      __int16 v29 = v18;
      char v30 = BYTE2(v18);
    }
    else
    {
      ((void (*)(void, uint64_t, void *, void))*MEMORY[0x263F8BD78])(v24[0], 17, v16, v17);
    }
  }
  *(_OWORD *)int v27 = 0u;
  long long v28 = 0u;
  MCC::MCC((MCC *)v27);
  *(_OWORD *)int v25 = 0u;
  long long v26 = 0u;
  MNC::MNC((MNC *)v25);
  convertMccAndMnc((unsigned __int8 *)&v31, (unsigned __int8 *)&v29, (const MCC *)v27, (const MNC *)v25);
  int v19 = *v8;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    int IntValue = MCC::getIntValue((MCC *)v27);
    int IntegerWidth = MNC::getIntegerWidth((MNC *)v25);
    int v22 = MCC::getIntValue((MCC *)v25);
    LODWORD(__p) = 67109632;
    HIDWORD(__p) = IntValue;
    LOWORD(v34) = 1024;
    *(_DWORD *)((char *)&v34 + 2) = IntegerWidth;
    HIWORD(v34) = 1024;
    LODWORD(v35) = v22;
    _os_log_impl(&dword_22231A000, v19, OS_LOG_TYPE_DEFAULT, "#I Geo Plmn %03d-%0.*d", (uint8_t *)&__p, 0x14u);
  }
  uint64_t v23 = *(void *)(v6 + 64);
  MEMORY[0x223C99FA0](&__p, v27, v25);
  (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v23 + 224))(v23, v7, &__p);
  if (v38 < 0) {
    operator delete(v37);
  }
  if (v36 < 0) {
    operator delete(v34);
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(v25[1]);
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(v27[1]);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v24);
}

void sub_222529AE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30)
{
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1}>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1}>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D7FC8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1}>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D7FC8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1}>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  if ((v2 - 1) >= 3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = v2;
  }
  __int16 v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 88) + 16))(*(void *)(v3 + 88), v4);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I NAS Client has started", buf, 2u);
  }
  if (capabilities::ct::supportsGemini((capabilities::ct *)v6))
  {
    memset(v9, 0, sizeof(v9));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v9);
    *qmi::MutableMessageBase::getTLV<nas::tlv::SubType>((uint64_t)v9, 1) = v2 == 2;
    qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::BindSubscription::Request>(&v8, v2);
  }
  uint64_t v7 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#I NAS client binding not required", buf, 2u);
  }
  QMINetworkRegistrationDriver::sendIndRegisterReq_sync(v3, v2);
}

void sub_222529EF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  uint64_t v22 = a10;
  a10 = 0;
  if (v22) {
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v22);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1}>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1}>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2}>,void ()(qmi::SubscriptionType)>::~__func()
{
}

void *std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2}>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D8048;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2}>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D8048;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2}>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if ((*a2 - 1) >= 3) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = *a2;
  }
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 88) + 16))(*(void *)(v2 + 88), v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)BOOL v6 = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I NAS Client has stopped", v6, 2u);
  }
  uint64_t result = qmi::NotifyHelper::shouldNotifyStop(*(unint64_t ***)(v2 + 96));
  if (result) {
    return (*(uint64_t (**)(void, void))(**(void **)(v2 + 64) + 16))(*(void *)(v2 + 64), 0);
  }
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2}>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2}>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D80C8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D80C8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    int v10 = 0;
    uint64_t v11 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v8, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v8);
    if (__p)
    {
      int v10 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v8);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v4 - 1 >= 3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v4;
  }
  (*(void (**)(void, uint64_t))(**(void **)(v6 + 88) + 16))(*(void *)(v6 + 88), v7);
  (*(void (**)(void, uint64_t))(**(void **)(v6 + 64) + 232))(*(void *)(v6 + 64), v7);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v8);
}

void sub_22252A2F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkRegistrationDriver>::execute_wrapped<QMINetworkRegistrationDriver::start(void)::$_0>(QMINetworkRegistrationDriver::start(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkRegistrationDriver::start(void)::$_0,dispatch_queue_s *::default_delete<QMINetworkRegistrationDriver::start(void)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = *(void *)a1;
  uint64_t v2 = *(NSObject **)(**(void **)a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  qmi::ClientRouter::start();
  MEMORY[0x223C9A950](v1, 0x20C4093837F09);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v4);
}

void sub_22252A424(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MEMORY[0x223C9A950](v2, 0x20C4093837F09);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkRegistrationDriver>::execute_wrapped<QMINetworkRegistrationDriver::shutdown(dispatch::group_session)::$_0>(QMINetworkRegistrationDriver::shutdown(dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkRegistrationDriver::shutdown(dispatch::group_session)::$_0,dispatch_queue_s *::default_delete<QMINetworkRegistrationDriver::shutdown(dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  qmi::ClientRouter::stop();
  std::unique_ptr<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0,std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](&v4);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v3);
}

void sub_22252A49C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t QMIQOSClientIP::QMIQOSClientIP(uint64_t a1, void *a2, uint64_t a3, void *a4, int a5, NSObject **a6)
{
  *(void *)a1 = &unk_26D4D8148;
  int v12 = (void *)(a1 + 8);
  int v13 = (*(uint64_t (**)(uint64_t))(*(void *)(a3 + *(void *)(*(void *)a3 - 56)) + 24))(a3 + *(void *)(*(void *)a3 - 56));
  unsigned int v14 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 64))(a3);
  int v15 = QMIQOSClientIP::nameForFamily(a1, v13, v14, a5);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v22, (const char *)*MEMORY[0x263F03770], v15);
  *int v12 = 0;
  v12[1] = 0;
  unsigned __int8 v16 = *a6;
  *(void *)(a1 + 24) = *a6;
  if (v16) {
    dispatch_retain(v16);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x223C99A30](v23);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v22);
  *(void *)a1 = &unk_26D4D8148;
  *(void *)(a1 + 48) = *a2;
  uint64_t v17 = a2[1];
  *(void *)(a1 + 56) = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 64) = a3;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = a5;
  *(_WORD *)(a1 + 108) = 0;
  int v18 = (*(uint64_t (**)(uint64_t))(*(void *)(a3 + *(void *)(*(void *)a3 - 56)) + 24))(a3 + *(void *)(*(void *)a3 - 56));
  unsigned int v19 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 64))(a3);
  *(void *)(a1 + 112) = QMIQOSClientIP::nameForFamily(a1, v18, v19, a5);
  *(void *)(a1 + 120) = *a4;
  uint64_t v20 = a4[1];
  *(void *)(a1 + 128) = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 136) = xpc_null_create();
  return a1;
}

const char *QMIQOSClientIP::nameForFamily(uint64_t a1, int a2, unsigned int a3, int a4)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a2 == 2)
  {
    if (a4 == 2)
    {
      if (a3 < 0xA)
      {
        uint64_t v4 = &off_264612748;
        return v4[a3];
      }
      return "DATA.QMIContext.2:N:QOSIPv6";
    }
    else if (a4 == 1)
    {
      if (a3 < 0xA)
      {
        uint64_t v4 = &off_2646126F8;
        return v4[a3];
      }
      return "DATA.QMIContext.2:N:QOSIPv4";
    }
    else
    {
      if (a3 < 0xA)
      {
        uint64_t v4 = &off_264612798;
        return v4[a3];
      }
      return "DATA.QMIContext.2:N:QOSIPvX";
    }
  }
  else if (a2 == 1)
  {
    if (a4 == 2)
    {
      if (a3 < 0xA)
      {
        uint64_t v4 = &off_264612658;
        return v4[a3];
      }
      return "DATA.QMIContext.1:N:QOSIPv6";
    }
    else if (a4 == 1)
    {
      if (a3 < 0xA)
      {
        uint64_t v4 = &off_264612608;
        return v4[a3];
      }
      return "DATA.QMIContext.1:N:QOSIPv4";
    }
    else
    {
      if (a3 < 0xA)
      {
        uint64_t v4 = &off_2646126A8;
        return v4[a3];
      }
      return "DATA.QMIContext.1:N:QOSIPvX";
    }
  }
  else
  {
    __int16 v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v7 = 136315138;
      uint64_t v8 = subscriber::asString();
      _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Wrong SIM: %s", (uint8_t *)&v7, 0xCu);
    }
    return "DATA.QMIContext.X:X:QOSIPvX";
  }
}

void QMIQOSClientIP::createQoSClientOnDemand(QMIQOSClientIP *this)
{
  if (!*((void *)this + 11))
  {
    uint64_t v2 = *((void *)this + 5);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I creating fQOSClient", buf, 2u);
    }
    *((unsigned char *)this + 109) = 0;
    v21[0] = 0;
    v21[1] = 0;
    uint64_t v22 = 0;
    std::string::basic_string[abi:ne180100]<0>(v21, "qos_1");
    std::string::basic_string[abi:ne180100]<0>(&v19, *((char **)this + 14));
    uint64_t v3 = *((void *)this + 3);
    dispatch_object_t v18 = v3;
    if (v3) {
      dispatch_retain(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
    if (!v4 || (uint64_t v5 = *((void *)this + 1), (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
      std::__throw_bad_weak_ptr[abi:ne180100]();
    }
    int v7 = v6;
    uint64_t v16 = v5;
    uint64_t v17 = v6;
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    Registry::getServerConnection(&v14, *((Registry **)this + 6));
    qmi::Client::createWithQueueLocal();
    long long v8 = v25;
    long long v25 = 0uLL;
    uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 12);
    *(_OWORD *)((char *)this + 88) = v8;
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    }
    qmi::Client::~Client((qmi::Client *)buf);
    if (v15) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v15);
    }
    if (v17) {
      std::__shared_weak_count::__release_weak(v17);
    }
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    if (v18) {
      dispatch_release(v18);
    }
    if (v20 < 0) {
      operator delete(v19);
    }
    v13[15] = MEMORY[0x263EF8330];
    uint8_t v13[16] = 0x40000000;
    v13[17] = ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke;
    v13[18] = &__block_descriptor_tmp_29;
    v13[19] = this;
    qmi::Client::setHandler();
    v13[10] = MEMORY[0x263EF8330];
    v13[11] = 0x40000000;
    v13[12] = ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_2;
    v13[13] = &__block_descriptor_tmp_70_3;
    v13[14] = this;
    int v10 = (capabilities::ct *)qmi::Client::setHandler();
    if (capabilities::ct::supportsDataQMIExtensions(v10))
    {
      void v13[5] = MEMORY[0x263EF8330];
      void v13[6] = 0x40000000;
      v13[7] = ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_3;
      v13[8] = &__block_descriptor_tmp_71_1;
      v13[9] = this;
      qmi::Client::setHandler();
    }
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 0x40000000;
    v13[2] = ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_4;
    void v13[3] = &__block_descriptor_tmp_73_4;
    void v13[4] = this;
    *(void *)long long buf = MEMORY[0x263EF8330];
    uint64_t v24 = 0x40000000;
    *(void *)&long long v25 = ___ZNK3qmi6Client13setIndHandlerIRKN3qos9QosStatus10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    *((void *)&v25 + 1) = &unk_264612480;
    long long v26 = v13;
    qmi::Client::setIndHandler();
    v12[0] = MEMORY[0x263EF8330];
    v12[1] = 0x40000000;
    _DWORD v12[2] = ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_5;
    void v12[3] = &__block_descriptor_tmp_74_5;
    void v12[4] = this;
    *(void *)long long buf = MEMORY[0x263EF8330];
    uint64_t v24 = 0x40000000;
    *(void *)&long long v25 = ___ZNK3qmi6Client13setIndHandlerIRKN3qos14EventReportInd10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    *((void *)&v25 + 1) = &unk_2646124A8;
    long long v26 = v12;
    qmi::Client::setIndHandler();
    v11[0] = MEMORY[0x263EF8330];
    v11[1] = 0x40000000;
    _DWORD v11[2] = ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_6;
    v11[3] = &__block_descriptor_tmp_75_2;
    void v11[4] = this;
    *(void *)long long buf = MEMORY[0x263EF8330];
    uint64_t v24 = 0x40000000;
    *(void *)&long long v25 = ___ZNK3qmi6Client13setIndHandlerIRKN3qos16GlobalQosFlowInd10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    *((void *)&v25 + 1) = &unk_2646124D0;
    long long v26 = v11;
    qmi::Client::setIndHandler();
    qmi::Client::start((QMIQOSClientIP *)((char *)this + 72));
    if (SHIBYTE(v22) < 0) {
      operator delete(v21[0]);
    }
  }
}

void sub_22252AD4C(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v2 - 192);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 - 176);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  uint64_t v6 = *(NSObject **)(v2 - 168);
  if (v6) {
    dispatch_release(v6);
  }
  if (*(char *)(v2 - 137) < 0) {
    operator delete(*(void **)(v2 - 160));
  }
  if (*(char *)(v2 - 113) < 0) {
    operator delete(*(void **)(v2 - 136));
  }
  _Unwind_Resume(a1);
}

void ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_2(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 108))
  {
    if (*(void *)(v1 + 88))
    {
      v31[1] = *(void *)(a1 + 32);
      void v31[2] = 0;
      v31[0] = &unk_26D4D8378;
      char v32 = v31;
      *(unsigned char *)(v1 + 109) = 0;
      if ((*(unsigned int (**)(void))(**(void **)(v1 + 120) + 184))(*(void *)(v1 + 120)))
      {
        *(_OWORD *)std::string __p = 0u;
        long long v19 = 0u;
        qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
        uint64_t v13 = MEMORY[0x263EF8330];
        uint64_t v14 = 0x40000000;
        int v15 = ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke;
        uint64_t v16 = &__block_descriptor_tmp_78_5;
        uint64_t v17 = v1;
        uint64_t v2 = (const void **)__p[1];
        if (__p[1] != (void *)v19)
        {
          while (*((unsigned char *)*v2 + 8) != 18)
          {
            if (++v2 == (const void **)v19) {
              goto LABEL_18;
            }
          }
        }
        if (v2 == (const void **)v19) {
LABEL_18:
        }
          operator new();
        if (!v5) {
          __cxa_bad_cast();
        }
        ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke((uint64_t)&v13, v5 + 5);
        uint64_t v9 = QMIServiceMsg::create();
        *(void *)long long buf = MEMORY[0x263EF8330];
        uint64_t v26 = 1174405120;
        int v27 = ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke_2;
        long long v28 = &__block_descriptor_tmp_81_7;
        uint64_t v29 = v1;
        std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v30, (uint64_t)v31);
        uint64_t aBlock = MEMORY[0x263EF8330];
        uint64_t v21 = 0x40000000;
        uint64_t v22 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos12BindDataPort8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
        uint64_t v23 = &unk_264612520;
        uint64_t v24 = buf;
        long long v8 = _Block_copy(&aBlock);
        uint64_t v11 = v8;
        if (v9)
        {
          qmi::Client::send();
          long long v8 = v11;
        }
        if (!v8) {
          goto LABEL_35;
        }
      }
      else
      {
        if (!(*(unsigned int (**)(void))(**(void **)(v1 + 120) + 192))(*(void *)(v1 + 120)))
        {
          uint64_t v6 = *(NSObject **)(v1 + 40);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl(&dword_22231A000, v6, OS_LOG_TYPE_ERROR, "Unknown baseband type", buf, 2u);
          }
          if (!v32) {
            std::__throw_bad_function_call[abi:ne180100]();
          }
          (*(void (**)(void *))(*v32 + 48))(v32);
          goto LABEL_36;
        }
        *(_OWORD *)std::string __p = 0u;
        long long v19 = 0u;
        qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
        uint64_t v13 = MEMORY[0x263EF8330];
        uint64_t v14 = 0x40000000;
        int v15 = ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke_82;
        uint64_t v16 = &__block_descriptor_tmp_84_5;
        uint64_t v17 = v1;
        uint64_t v4 = (const void **)__p[1];
        if (__p[1] != (void *)v19)
        {
          while (*((unsigned char *)*v4 + 8) != 17)
          {
            if (++v4 == (const void **)v19) {
              goto LABEL_26;
            }
          }
        }
        if (v4 == (const void **)v19) {
LABEL_26:
        }
          operator new();
        if (!v7) {
          __cxa_bad_cast();
        }
        ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke_82((uint64_t)&v13, v7 + 9);
        uint64_t v10 = QMIServiceMsg::create();
        *(void *)long long buf = MEMORY[0x263EF8330];
        uint64_t v26 = 1174405120;
        int v27 = ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke_2_85;
        long long v28 = &__block_descriptor_tmp_88_6;
        uint64_t v29 = v1;
        std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v30, (uint64_t)v31);
        uint64_t aBlock = MEMORY[0x263EF8330];
        uint64_t v21 = 0x40000000;
        uint64_t v22 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos12BindDataPort8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
        uint64_t v23 = &unk_264612520;
        uint64_t v24 = buf;
        long long v8 = _Block_copy(&aBlock);
        int v12 = v8;
        if (v10)
        {
          qmi::Client::send();
          long long v8 = v12;
        }
        if (!v8)
        {
LABEL_35:
          std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v30);
          qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
LABEL_36:
          std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v31);
          return;
        }
      }
      _Block_release(v8);
      goto LABEL_35;
    }
    uint64_t v3 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "bindDataPort after client is deleted", buf, 2u);
    }
  }
}

void sub_22252B554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *aBlock, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v19);
  if (a10) {
    qmi::Client::send();
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a19);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100]((void *)(v20 - 120));
  _Unwind_Resume(a1);
}

void *___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_3(void *result)
{
  void v15[4] = *MEMORY[0x263EF8340];
  uint64_t v1 = result[4];
  if (!*(unsigned char *)(v1 + 108))
  {
    uint64_t result = (void *)(*(uint64_t (**)(void))(**(void **)(v1 + 64) + 72))(*(void *)(v1 + 64));
    if (result)
    {
      v10[0] = &unk_26D4D86F8;
      v10[1] = v1;
      uint64_t v11 = v10;
      if (*(void *)(v1 + 88) && *(unsigned char *)(v1 + 109))
      {
        memset(v8, 0, sizeof(v8));
        qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v8);
        uint64_t v6 = QMIServiceMsg::create();
        *(void *)long long buf = MEMORY[0x263EF8330];
        *(void *)&uint8_t buf[8] = 1174405120;
        *(void *)&uint8_t buf[16] = ___ZN14QMIQOSClientIP25queryCurrentQosFlows_syncENSt3__18functionIFvRKNS0_6vectorIjNS0_9allocatorIjEEEEbEEE_block_invoke;
        uint64_t v13 = &__block_descriptor_tmp_141_1;
        uint64_t v14 = v1;
        std::__function::__value_func<void ()(std::vector<unsigned int> const&,BOOL)>::__value_func[abi:ne180100]((uint64_t)v15, (uint64_t)v10);
        aBlock[0] = MEMORY[0x263EF8330];
        aBlock[1] = 0x40000000;
        uint64_t aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos9GetQosIds8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
        _DWORD aBlock[3] = &unk_264612598;
        aBlock[4] = buf;
        uint64_t v2 = _Block_copy(aBlock);
        int v7 = v2;
        if (v6)
        {
          qmi::Client::send();
          uint64_t v2 = v7;
        }
        if (v2) {
          _Block_release(v2);
        }
        std::__function::__value_func<void ()(std::vector<unsigned int> const&,BOOL)>::~__value_func[abi:ne180100](v15);
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v8);
      }
      else
      {
        uint64_t v3 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v4 = asStringBool();
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = "queryCurrentQosFlows_sync";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v4;
          _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I %s: QOS Client not ready yet: ready=%s", buf, 0x16u);
          uint64_t v5 = v11;
        }
        else
        {
          uint64_t v5 = v10;
        }
        memset(buf, 0, sizeof(buf));
        std::function<void ()(std::vector<unsigned int> const&,BOOL)>::operator()((uint64_t)v5, (uint64_t)buf, 0);
        if (*(void *)buf)
        {
          *(void *)&uint8_t buf[8] = *(void *)buf;
          operator delete(*(void **)buf);
        }
      }
      return std::__function::__value_func<void ()(std::vector<unsigned int> const&,BOOL)>::~__value_func[abi:ne180100](v10);
    }
  }
  return result;
}

void sub_22252B890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  uint64_t v26 = v25;
  std::__function::__value_func<void ()(std::vector<unsigned int> const&,BOOL)>::~__value_func[abi:ne180100](v26);
  if (a11) {
    qmi::Client::send();
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  std::__function::__value_func<void ()(std::vector<unsigned int> const&,BOOL)>::~__value_func[abi:ne180100](&a25);
  _Unwind_Resume(a1);
}

void ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_4(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 108))
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "handleQOSStatusInd_sync";
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&buf, 0xCu);
    }
    v11[0] = 0;
    v11[1] = v11;
    _DWORD v11[2] = 0x2000000000;
    int v12 = 0;
    v9[0] = 0;
    v9[1] = v9;
    _OWORD v9[2] = 0x2000000000;
    char v10 = 0;
    *(void *)&long long buf = MEMORY[0x263EF8330];
    *((void *)&buf + 1) = 0x40000000;
    uint64_t v16 = ___ZN14QMIQOSClientIP23handleQOSStatusInd_syncERKN3qos9QosStatus10IndicationE_block_invoke;
    uint64_t v17 = &unk_2646122A8;
    dispatch_object_t v18 = v11;
    long long v19 = v9;
    uint64_t TlvValue = qmi::MessageBase::findTlvValue(a2);
    uint64_t v7 = TlvValue;
    if (TlvValue)
    {
      int v8 = v6;
      uint64_t v14 = TlvValue;
      uint64_t v13 = tlv::parseV<qos::tlv::QosStatusInfo>((unint64_t *)&v14, v6);
      if (v14) {
        v16((uint64_t)&buf, (uint64_t)&v13);
      }
      else {
        ((void (*)(void, uint64_t, uint64_t, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 1, v7, v8);
      }
    }
    _Block_object_dispose(v9, 8);
    _Block_object_dispose(v11, 8);
  }
}

void sub_22252BAC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

void ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_5(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v2 + 108)) {
    return;
  }
  uint64_t v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "handleQOSEventReportInd_sync";
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
  }
  long long v5 = 0uLL;
  memset(v34, 0, sizeof(v34));
  memset(v40, 0, sizeof(v40));
  uint64_t v38 = 0;
  int v6 = (void *)*((void *)a2 + 1);
  if (v6)
  {
    uint64_t v7 = *v6;
    unint64_t v8 = v6[1];
    char v36 = (void **)(*v6 + 4);
    unint64_t v37 = v8;
    uint64_t v9 = (char *)(v7 + 7);
    if (v7 + 7 <= v8)
    {
      char v11 = *(unsigned char *)(v7 + 4);
      __int16 v12 = *(_WORD *)(v7 + 5);
      uint64_t v39 = v9;
      LOBYTE(v3_Block_object_dispose(&a9, 8) = v11;
      for (WORD1(v3_Block_object_dispose(&a9, 8) = v12; ; WORD1(v3_Block_object_dispose(&a9, 8) = v32)
      {
        NextTlv = (qos::tlv *)qmi::MessageBase::findNextTlv();
        uint64_t v16 = NextTlv;
        if (!NextTlv)
        {
LABEL_125:
          uint64_t v10 = *(void *)v40;
          long long v5 = *(_OWORD *)&v40[8];
          goto LABEL_126;
        }
        int v17 = v14;
        uint64_t v35 = NextTlv;
        long long v62 = 0u;
        long long v63 = 0u;
        long long v60 = 0u;
        long long v61 = 0u;
        *(_OWORD *)std::string __p = 0u;
        long long v59 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        *(_OWORD *)long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        *(_OWORD *)long long buf = 0u;
        long long v43 = 0u;
        tlv::parseV<qos::tlv::FlowInfo>(&v35, v14, v15, (uint64_t)buf);
        if (v35) {
          break;
        }
        if ((((uint64_t (*)(void, uint64_t, qos::tlv *, void))*MEMORY[0x263F8BD78])(*a2, 16, v16, v17) & 1) == 0)
        {
          int v20 = 0;
          memset(v34, 0, sizeof(v34));
          goto LABEL_32;
        }
LABEL_31:
        int v20 = 1;
LABEL_32:
        if (BYTE12(v63)) {
          BYTE12(v63) = 0;
        }
        if (BYTE10(v63)) {
          BYTE10(v63) = 0;
        }
        if (BYTE8(v63)) {
          BYTE8(v63) = 0;
        }
        if ((_BYTE)v55)
        {
          if ((_BYTE)v63) {
            LOBYTE(v63) = 0;
          }
          if (BYTE14(v62)) {
            BYTE14(v62) = 0;
          }
          if (BYTE12(v62)) {
            BYTE12(v62) = 0;
          }
          if (BYTE10(v62)) {
            BYTE10(v62) = 0;
          }
          if (BYTE8(v62)) {
            BYTE8(v62) = 0;
          }
          if (BYTE4(v62)) {
            BYTE4(v62) = 0;
          }
          if (BYTE2(v62)) {
            BYTE2(v62) = 0;
          }
          if ((_BYTE)v62) {
            LOBYTE(v62) = 0;
          }
          if (BYTE8(v61)) {
            BYTE8(v61) = 0;
          }
          if ((_BYTE)v61) {
            LOBYTE(v61) = 0;
          }
          if (BYTE8(v60)) {
            BYTE8(v60) = 0;
          }
          if ((_BYTE)v60) {
            LOBYTE(v60) = 0;
          }
          if (BYTE8(v59)) {
            BYTE8(v59) = 0;
          }
          if (BYTE8(v57))
          {
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
            BYTE8(v57) = 0;
          }
          if (BYTE12(v56)) {
            BYTE12(v56) = 0;
          }
          if (BYTE12(v55)) {
            BYTE12(v55) = 0;
          }
          if (BYTE8(v55)) {
            BYTE8(v55) = 0;
          }
          LOBYTE(v55) = 0;
        }
        if (BYTE8(v46))
        {
          if (BYTE8(v54)) {
            BYTE8(v54) = 0;
          }
          if (BYTE6(v54)) {
            BYTE6(v54) = 0;
          }
          if (BYTE4(v54)) {
            BYTE4(v54) = 0;
          }
          if (BYTE2(v54)) {
            BYTE2(v54) = 0;
          }
          if ((_BYTE)v54) {
            LOBYTE(v54) = 0;
          }
          if (BYTE12(v53)) {
            BYTE12(v53) = 0;
          }
          if (BYTE10(v53)) {
            BYTE10(v53) = 0;
          }
          if (BYTE8(v53)) {
            BYTE8(v53) = 0;
          }
          if ((_BYTE)v53) {
            LOBYTE(v53) = 0;
          }
          if (BYTE8(v52)) {
            BYTE8(v52) = 0;
          }
          if ((_BYTE)v52) {
            LOBYTE(v52) = 0;
          }
          if (BYTE8(v51)) {
            BYTE8(v51) = 0;
          }
          if ((_BYTE)v51) {
            LOBYTE(v51) = 0;
          }
          if (LOBYTE(v49[0]))
          {
            if (v49[1])
            {
              *(void **)&long long v50 = v49[1];
              operator delete(v49[1]);
            }
            LOBYTE(v49[0]) = 0;
          }
          if (BYTE4(v48)) {
            BYTE4(v4_Block_object_dispose(&a9, 8) = 0;
          }
          if (BYTE4(v47)) {
            BYTE4(v47) = 0;
          }
          if ((_BYTE)v47) {
            LOBYTE(v47) = 0;
          }
          BYTE8(v46) = 0;
        }
        if (BYTE8(v44))
        {
          uint64_t v41 = (void **)&v45;
          std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](&v41);
          BYTE8(v44) = 0;
        }
        if (buf[8])
        {
          uint64_t v41 = (void **)&v43;
          std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](&v41);
        }
        if (!v20)
        {
          uint64_t v33 = *(void *)&v34[8];
          uint64_t v10 = *(void *)v34;
          goto LABEL_127;
        }
        uint64_t v29 = (void **)&v39[WORD1(v38)];
        char v36 = v29;
        if (!v39 || (unint64_t)v29 + 3 > v37) {
          goto LABEL_125;
        }
        uint64_t v39 = (char *)v29 + 1;
        char v30 = *(unsigned char *)v29;
        uint64_t v39 = (char *)v29 + 2;
        __int16 v31 = *((unsigned __int8 *)v29 + 1);
        uint64_t v39 = (char *)v29 + 3;
        __int16 v32 = v31 | (*((unsigned __int8 *)v29 + 2) << 8);
        LOBYTE(v3_Block_object_dispose(&a9, 8) = v30;
      }
      dispatch_object_t v18 = *(char **)&v40[8];
      if (*(void *)&v40[8] < *(void *)&v40[16])
      {
        qos::tlv::FlowInfo::FlowInfo(*(uint64_t *)&v40[8], (uint64_t)buf);
        long long v19 = v18 + 352;
LABEL_30:
        *(void *)&uint8_t v40[8] = v19;
        goto LABEL_31;
      }
      uint64_t v21 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)&v40[8] - *(void *)v40) >> 5);
      unint64_t v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) > 0xBA2E8BA2E8BA2ELL) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      if (0x5D1745D1745D1746 * ((uint64_t)(*(void *)&v40[16] - *(void *)v40) >> 5) > v22) {
        unint64_t v22 = 0x5D1745D1745D1746 * ((uint64_t)(*(void *)&v40[16] - *(void *)v40) >> 5);
      }
      if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)&v40[16] - *(void *)v40) >> 5)) >= 0x5D1745D1745D17) {
        unint64_t v23 = 0xBA2E8BA2E8BA2ELL;
      }
      else {
        unint64_t v23 = v22;
      }
      if (v23)
      {
        if (v23 > 0xBA2E8BA2E8BA2ELL) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v24 = (char *)operator new(352 * v23);
      }
      else
      {
        uint64_t v24 = 0;
      }
      long long v25 = &v24[352 * v23];
      uint64_t v26 = qos::tlv::FlowInfo::FlowInfo((uint64_t)&v24[352 * v21], (uint64_t)buf);
      long long v19 = (char *)(v26 + 352);
      int v27 = *(char **)v40;
      if (v18 == *(char **)v40)
      {
        *(void *)int v40 = v26;
        *(void *)&uint8_t v40[8] = v26 + 352;
        *(void *)&v40[16] = v25;
      }
      else
      {
        do
        {
          v18 -= 352;
          uint64_t v26 = qos::tlv::FlowInfo::FlowInfo(v26 - 352, (uint64_t)v18);
        }
        while (v18 != v27);
        uint64_t v28 = *(void *)&v40[8];
        dispatch_object_t v18 = *(char **)v40;
        *(void *)int v40 = v26;
        *(void *)&uint8_t v40[8] = v19;
        *(void *)&v40[16] = v25;
        if ((char *)v28 != v18)
        {
          do
          {
            v28 -= 352;
            std::__destroy_at[abi:ne180100]<qos::tlv::FlowInfo,0>(v28);
          }
          while ((char *)v28 != v18);
          if (!v18) {
            goto LABEL_30;
          }
LABEL_29:
          operator delete(v18);
          goto LABEL_30;
        }
      }
      if (!v18) {
        goto LABEL_30;
      }
      goto LABEL_29;
    }
  }
  uint64_t v10 = 0;
LABEL_126:
  *(void *)char v34 = v10;
  *(_OWORD *)&void v34[8] = v5;
  uint64_t v33 = v5;
  memset(v40, 0, sizeof(v40));
LABEL_127:
  *(void *)long long buf = v40;
  std::vector<qos::tlv::FlowInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  *(void *)long long buf = MEMORY[0x263EF8330];
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&long long v43 = ___ZNK14QMIQOSClientIP28handleQOSEventReportInd_syncERKN3qos14EventReportInd10IndicationE_block_invoke;
  *((void *)&v43 + 1) = &__block_descriptor_tmp_132_2;
  *(void *)&long long v44 = v2;
  while (v10 != v33)
  {
    ((void (*)(uint8_t *, uint64_t))v43)(buf, v10);
    v10 += 352;
  }
  char v36 = (void **)v34;
  std::vector<qos::tlv::FlowInfo>::__destroy_vector::operator()[abi:ne180100](&v36);
}

void sub_22252C134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,int a31,__int16 a32,__int16 a33,__int16 a34,uint64_t a35,int a36,char a37,uint64_t a38,char a39,void *a40,uint64_t a41,uint64_t a42,char a43,int a44,__int16 a45,int a46,__int16 a47,int a48,__int16 a49,int a50,__int16 a51,int a52,__int16 a53,char a54,char a55,char a56,__int16 a57,__int16 a58,char a59,char a60,char a61,char a62,char a63)
{
  if (a91) {
    char a91 = 0;
  }
  if (a90) {
    char a90 = 0;
  }
  if ((_BYTE)a89) {
    LOBYTE(a89) = 0;
  }
  if ((_BYTE)a67)
  {
    if (a88) {
      a88 = 0;
    }
    if (a87) {
      a87 = 0;
    }
    if (a86) {
      a86 = 0;
    }
    if (a85) {
      a85 = 0;
    }
    if ((_BYTE)a84) {
      LOBYTE(a84) = 0;
    }
    if (a83) {
      a83 = 0;
    }
    if (a82) {
      a82 = 0;
    }
    if ((_BYTE)a81) {
      LOBYTE(a81) = 0;
    }
    if ((_BYTE)a80) {
      LOBYTE(a80) = 0;
    }
    if ((_BYTE)a79) {
      LOBYTE(a79) = 0;
    }
    if ((_BYTE)a78) {
      LOBYTE(a7_Block_object_dispose(&a9, 8) = 0;
    }
    if ((_BYTE)a77) {
      LOBYTE(a77) = 0;
    }
    if (a76) {
      a76 = 0;
    }
    if (a73)
    {
      if (__p)
      {
        a75 = (uint64_t)__p;
        operator delete(__p);
      }
      a73 = 0;
    }
    if (a72) {
      a72 = 0;
    }
    if ((_BYTE)a71) {
      LOBYTE(a71) = 0;
    }
    if ((_BYTE)a69) {
      LOBYTE(a69) = 0;
    }
    LOBYTE(a67) = 0;
  }
  if (a30)
  {
    if (a65) {
      a65 = 0;
    }
    if (a63) {
      a63 = 0;
    }
    if (a61) {
      a61 = 0;
    }
    if (a59) {
      a59 = 0;
    }
    if ((_BYTE)a58) {
      LOBYTE(a5_Block_object_dispose(&a9, 8) = 0;
    }
    if (a56) {
      a56 = 0;
    }
    if (a54) {
      a54 = 0;
    }
    if ((_BYTE)a53) {
      LOBYTE(a53) = 0;
    }
    if ((_BYTE)a51) {
      LOBYTE(a51) = 0;
    }
    if ((_BYTE)a49) {
      LOBYTE(a49) = 0;
    }
    if ((_BYTE)a47) {
      LOBYTE(a47) = 0;
    }
    if ((_BYTE)a45) {
      LOBYTE(a45) = 0;
    }
    if (a43) {
      a43 = 0;
    }
    if (a39)
    {
      if (a40)
      {
        a41 = (uint64_t)a40;
        operator delete(a40);
      }
      a39 = 0;
    }
    if (a37) {
      a37 = 0;
    }
    if ((_BYTE)a34) {
      LOBYTE(a34) = 0;
    }
    if ((_BYTE)a32) {
      LOBYTE(a32) = 0;
    }
    a30 = 0;
  }
  if (a26)
  {
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a20);
    a26 = 0;
  }
  if (a22) {
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a20);
  }
  a21 = (uint64_t)&a17;
  std::vector<qos::tlv::FlowInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  _Unwind_Resume(a1);
}

void ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_6(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 108))
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "handleGlobalQosFlowInd_sync";
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
    }
    *(void *)long long buf = qmi::MessageBase::findTlvValue(a2);
    *(void *)&uint8_t buf[8] = v5;
    if (*(void *)buf)
    {
      uint64_t v6 = tlv::parseV<qos::tlv::QosFlowState>((unint64_t *)buf, v5);
      if (*(void *)buf)
      {
        uint64_t v8 = v6;
        unsigned int v9 = v7;
        uint64_t v10 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          char v11 = qos::asString(v9);
          __int16 v12 = "New ";
          *(_DWORD *)long long buf = 136315906;
          *(void *)&uint8_t buf[4] = "handleGlobalQosFlowInd_sync";
          if ((v8 & 0xFF00000000) == 0) {
            __int16 v12 = (const char *)&unk_222543CCE;
          }
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v12;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v47) = v8;
          WORD2(v47) = 2080;
          *(void *)((char *)&v47 + 6) = v11;
          _os_log_impl(&dword_22231A000, v10, OS_LOG_TYPE_DEFAULT, "#I %s: %sQOS ID: %u, State change=%s", buf, 0x26u);
        }
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&uint8_t buf[16] = 0xC002000000;
        *(void *)&long long v47 = __Block_byref_object_copy__11;
        *((void *)&v47 + 1) = __Block_byref_object_dispose__11;
        uint64_t v55 = 256;
        long long v48 = 0u;
        long long v49 = 0u;
        memset(v50, 0, sizeof(v50));
        long long v51 = 0u;
        long long v52 = 0u;
        memset(v53, 0, sizeof(v53));
        long long v54 = 0u;
        LODWORD(v4_Block_object_dispose(&a9, 8) = v8;
        uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
        uint64_t v34 = v13;
        if (TlvValue)
        {
          tlv::parseV<qos::tlv::TxQosGrantedFlow>((unint64_t *)&TlvValue, v13, (uint64_t)__p);
          if (TlvValue)
          {
            __int16 v14 = (__int16)__p[0];
            long long v15 = v40;
            uint64_t v42 = 0;
            long long v40 = 0u;
            long long v41 = 0u;
            *(_OWORD *)std::string __p = 0u;
            if ((v14 & 2) != 0)
            {
              BYTE4(__p[1]) = 1;
              LODWORD(__p[1]) = v15;
              BYTE4(v40) = 1;
              LODWORD(v40) = DWORD2(v15);
            }
            if ((v14 & 0x4000) != 0)
            {
              LODWORD(__p[0]) = v43;
              BYTE4(__p[0]) = 1;
            }
            if (v14 < 0)
            {
              uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
              uint64_t v34 = v16;
              if (TlvValue)
              {
                int v17 = tlv::parseV<qos::tlv::Tx5gQci>((unint64_t *)&TlvValue, v16);
                if (TlvValue)
                {
                  LODWORD(__p[0]) = v17;
                  BYTE4(__p[0]) = 1;
                  *(_WORD *)(*(void *)&buf[8] + 184) = 257;
                }
              }
            }
            std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS&,void>(*(void *)&buf[8] + 56, (uint64_t)__p);
            if ((_BYTE)v42)
            {
              uint64_t TlvValue = (char *)&v40 + 8;
              std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100]((void ***)&TlvValue);
            }
          }
        }
        uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
        uint64_t v34 = v18;
        if (TlvValue)
        {
          tlv::parseV<qos::tlv::RxQosGrantedFlow>((unint64_t *)&TlvValue, v18, (uint64_t)__p);
          if (TlvValue)
          {
            __int16 v19 = (__int16)__p[0];
            long long v20 = v40;
            uint64_t v42 = 0;
            long long v40 = 0u;
            long long v41 = 0u;
            *(_OWORD *)std::string __p = 0u;
            if ((v19 & 2) != 0)
            {
              BYTE4(__p[1]) = 1;
              LODWORD(__p[1]) = v20;
              BYTE4(v40) = 1;
              LODWORD(v40) = DWORD2(v20);
            }
            if ((v19 & 0x4000) != 0)
            {
              LODWORD(__p[0]) = v43;
              BYTE4(__p[0]) = 1;
            }
            if (v19 < 0)
            {
              uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
              uint64_t v34 = v21;
              if (TlvValue)
              {
                int v22 = tlv::parseV<qos::tlv::Rx5gQci>((unint64_t *)&TlvValue, v21);
                if (TlvValue)
                {
                  LODWORD(__p[0]) = v22;
                  BYTE4(__p[0]) = 1;
                  *(_WORD *)(*(void *)&buf[8] + 184) = 257;
                }
              }
            }
            std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS&,void>(*(void *)&buf[8] + 120, (uint64_t)__p);
            if ((_BYTE)v42)
            {
              uint64_t TlvValue = (char *)&v40 + 8;
              std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100]((void ***)&TlvValue);
            }
          }
        }
        uint64_t TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
        uint64_t v34 = v23;
        if (TlvValue)
        {
          tlv::parseV<qos::tlv::TxQosFilterSpecList>((unsigned __int8 **)&TlvValue, v23, (uint64_t *)__p);
          uint64_t v24 = (char *)__p[0];
          if (TlvValue)
          {
            long long v25 = (char *)__p[1];
            __p[0] = (void *)MEMORY[0x263EF8330];
            __p[1] = (void *)0x40000000;
            *(void *)&long long v40 = ___ZNK14QMIQOSClientIP27handleGlobalQosFlowInd_syncERKN3qos16GlobalQosFlowInd10IndicationE_block_invoke;
            *((void *)&v40 + 1) = &unk_264612340;
            *(void *)&long long v41 = buf;
            *((void *)&v41 + 1) = v2;
            if (v24 != v25)
            {
              uint64_t v26 = v24;
              do
              {
                ((void (*)(void **, char *))v40)(__p, v26);
                v26 += 176;
              }
              while (v26 != v25);
            }
          }
          if (v24) {
            operator delete(v24);
          }
        }
        long long v44 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
        uint64_t v45 = v27;
        if (v44)
        {
          tlv::parseV<qos::tlv::RxQosFilterSpecList>(&v44, v27, (uint64_t *)&TlvValue);
          uint64_t v28 = (unsigned __int8 *)TlvValue;
          if (v44)
          {
            uint64_t v29 = (unsigned __int8 *)v34;
            uint64_t TlvValue = (void *)MEMORY[0x263EF8330];
            uint64_t v34 = 0x40000000;
            uint64_t v35 = ___ZNK14QMIQOSClientIP27handleGlobalQosFlowInd_syncERKN3qos16GlobalQosFlowInd10IndicationE_block_invoke_2;
            char v36 = &unk_264612368;
            unint64_t v37 = buf;
            uint64_t v38 = v2;
            if (v28 != v29)
            {
              char v30 = v28;
              do
              {
                v35((uint64_t)&TlvValue, v30);
                v30 += 176;
              }
              while (v30 != v29);
            }
          }
          if (v28) {
            operator delete(v28);
          }
        }
        long long v44 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
        uint64_t v45 = v31;
        if (v44)
        {
          unsigned __int8 v32 = tlv::parseV<qos::tlv::BearerId>((unint64_t *)&v44, v31);
          if (v44) {
            *(_DWORD *)(*(void *)&buf[8] + 44) = v32;
          }
        }
        if (v9 >= 2)
        {
          if (v9 == 2) {
            (*(void (**)(void, void))(**(void **)(v2 + 64) + 88))(*(void *)(v2 + 64), *(unsigned int *)(*(void *)&buf[8] + 40));
          }
        }
        else
        {
          (*(void (**)(void, uint64_t))(**(void **)(v2 + 64) + 80))(*(void *)(v2 + 64), *(void *)&buf[8] + 40);
        }
        _Block_object_dispose(buf, 8);
        if (BYTE8(v54) && (_BYTE)v54)
        {
          long long v44 = &v53[8];
          std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100]((void ***)&v44);
        }
        if (BYTE8(v51))
        {
          if ((_BYTE)v51)
          {
            long long v44 = &v50[8];
            std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100]((void ***)&v44);
          }
        }
      }
    }
  }
}

void sub_22252C99C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void **a26,uint64_t a27,void **a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,int a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,int a52,char a53)
{
  if (a21) {
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&a26);
  }
  _Block_object_dispose(&a29, 8);
  if (a53) {
    BOOL v54 = a51 == 0;
  }
  else {
    BOOL v54 = 1;
  }
  if (!v54)
  {
    a28 = (void **)&a48;
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&a28);
  }
  if (a44)
  {
    if (a42)
    {
      a28 = (void **)&a39;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&a28);
    }
  }
  _Unwind_Resume(a1);
}

void QMIQOSClientIP::releaseQoSClient(QMIQOSClientIP *this)
{
  *((unsigned char *)this + 109) = 0;
  if (!*((void *)this + 11))
  {
    uint64_t v3 = *((void *)this + 5);
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v5[0]) = 0;
    uint64_t v4 = "#I Null fQOSClient";
    goto LABEL_8;
  }
  qmi::Client::stop((QMIQOSClientIP *)((char *)this + 72));
  memset(v5, 0, sizeof(v5));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 12);
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  qmi::Client::~Client((qmi::Client *)v5);
  uint64_t v3 = *((void *)this + 5);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5[0]) = 0;
    uint64_t v4 = "#I fQOSClient deleted";
LABEL_8:
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)v5, 2u);
  }
}

void QMIQOSClientIP::~QMIQOSClientIP(QMIQOSClientIP *this)
{
  *(void *)this = &unk_26D4D8148;
  *((unsigned char *)this + 109) = 0;
  uint64_t v2 = (QMIQOSClientIP *)((char *)this + 72);
  if (*((void *)this + 11)) {
    qmi::Client::stop((QMIQOSClientIP *)((char *)this + 72));
  }
  xpc_release(*((xpc_object_t *)this + 17));
  *((void *)this + 17) = 0;
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  qmi::Client::~Client(v2);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  MEMORY[0x223C99A30]((char *)this + 40);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable((void *)this + 1);
}

{
  uint64_t vars8;

  QMIQOSClientIP::~QMIQOSClientIP(this);

  JUMPOUT(0x223C9A950);
}

uint64_t ___ZN14QMIQOSClientIP21bindSubscription_syncENSt3__18functionIFvvEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (*(_DWORD *)(a2 + 4))
  {
    if (os_log_type_enabled(*(os_log_t *)(v3 + 40), OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = qmi::asString();
      int v7 = *(_DWORD *)(a2 + 4);
      int v10 = 136315394;
      uint64_t v11 = v6;
      __int16 v12 = 1024;
      int v13 = v7;
      _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Binding subscription: %s (0x%x)", (uint8_t *)&v10, 0x12u);
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(v3 + 40), OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 136315138;
    uint64_t v11 = subscriber::asString();
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I QoS bound: subscription: %s", (uint8_t *)&v10, 0xCu);
  }
  uint64_t v8 = *(void *)(a1 + 64);
  if (!v8) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v8 + 48))(v8);
}

uint64_t ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke(uint64_t a1, _WORD *a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 64) + 64))(*(void *)(*(void *)(a1 + 32) + 64));
  *a2 = result;
  return result;
}

uint64_t ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke_2(uint64_t result, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(result + 32);
  if (!*(unsigned char *)(v2 + 108))
  {
    uint64_t v3 = result;
    int v4 = *(_DWORD *)(a2 + 4);
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (v4)
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v7[0] = 67109378;
        v7[1] = v4;
        __int16 v8 = 2080;
        uint64_t v9 = qmi::asString();
        _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Error in response to BindDataPort with code = 0x%x (%s)", (uint8_t *)v7, 0x12u);
      }
    }
    else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Response to BindDataPort received", (uint8_t *)v7, 2u);
    }
    uint64_t v6 = *(void *)(v3 + 64);
    if (!v6) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 48))(v6);
  }
  return result;
}

uint64_t ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke_82(uint64_t a1, unsigned char *a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 64) + 64))(*(void *)(*(void *)(a1 + 32) + 64));
  *a2 = result + 1;
  return result;
}

uint64_t ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke_2_85(uint64_t result, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(result + 32);
  if (!*(unsigned char *)(v2 + 108))
  {
    uint64_t v3 = result;
    int v4 = *(_DWORD *)(a2 + 4);
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (v4)
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v7[0] = 67109378;
        v7[1] = v4;
        __int16 v8 = 2080;
        uint64_t v9 = qmi::asString();
        _os_log_error_impl(&dword_22231A000, v5, OS_LOG_TYPE_ERROR, "Error in response to BindDataPort with code = 0x%x (%s)", (uint8_t *)v7, 0x12u);
      }
    }
    else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I Response to BindDataPort received", (uint8_t *)v7, 2u);
    }
    uint64_t v6 = *(void *)(v3 + 64);
    if (!v6) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 48))(v6);
  }
  return result;
}

void ___ZN14QMIQOSClientIP14setupQMIClientEv_block_invoke_97(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "Error in response to SetIpClientFamily with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I Response to SetIpClientFamily received", (uint8_t *)v4, 2u);
  }
}

void ___ZN14QMIQOSClientIP14setupQMIClientEv_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "Error in response to SetEventReport with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I Response to SetEventReport received", (uint8_t *)v4, 2u);
  }
}

void ___ZN14QMIQOSClientIP14setupQMIClientEv_block_invoke_4(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a2 + 4);
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      __int16 v5 = 2080;
      uint64_t v6 = qmi::asString();
      _os_log_error_impl(&dword_22231A000, v3, OS_LOG_TYPE_ERROR, "Error in response to IndicationRegister with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl(&dword_22231A000, v3, OS_LOG_TYPE_DEFAULT, "#I Response to IndicationRegister received", (uint8_t *)v4, 2u);
  }
}

uint64_t QMIQOSClientIP::shutDownQMIQOSClientIP(uint64_t this)
{
  *(unsigned char *)(this + 10_Block_object_dispose(&a9, 8) = 1;
  return this;
}

void QMIQOSClientIP::dumpState(QMIQOSClientIP *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v2 = 0;
    _os_log_impl(&dword_22231A000, v1, OS_LOG_TYPE_DEFAULT, "#I DATA:: start", v2, 2u);
  }
}

uint64_t ___ZN14QMIQOSClientIP23handleQOSStatusInd_syncERKN3qos9QosStatus10IndicationE_block_invoke(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_DWORD *)a2;
  *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = *(unsigned char *)(a2 + 4);
  return result;
}

void QMIQOSClientIP::FilterSpecToDict(QMIQOSClientIP *this, const qos::tlv::QoSFilter *a2, DataIPFilter *a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 116))
  {
    *((_DWORD *)a2 + 7) = 4;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v24);
    CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&v24);
    if (!*((unsigned char *)a2 + 80))
    {
      __p.n128_u8[0] = 0;
      char v18 = 0;
      __int16 v19 = 0;
      char v20 = 0;
      char v21 = 0;
      char v22 = 0;
      char v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 32, &__p);
      if (v18)
      {
        if (v17 < 0) {
          operator delete((void *)__p.n128_u64[0]);
        }
      }
    }
    CSIPacketAddress::operator std::string();
    if (!*((unsigned char *)a2 + 80)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    std::optional<std::string>::operator=[abi:ne180100]<std::string,void>((uint64_t)a2 + 32, (long long *)&__p);
    if (v17 < 0) {
      operator delete((void *)__p.n128_u64[0]);
    }
    CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&v24);
    __int16 v5 = CSIPacketAddress::maskToPrefix((CSIPacketAddress *)&v24);
    if (!*((unsigned char *)a2 + 80)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    *((_WORD *)a2 + 32) = v5 | 0x100;
  }
  if (*((unsigned char *)this + 104))
  {
    *((_DWORD *)a2 + 7) = 4;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v24);
    CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&v24);
    if (!*((unsigned char *)a2 + 136))
    {
      __p.n128_u8[0] = 0;
      char v18 = 0;
      __int16 v19 = 0;
      char v20 = 0;
      char v21 = 0;
      char v22 = 0;
      char v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 88, &__p);
      if (v18)
      {
        if (v17 < 0) {
          operator delete((void *)__p.n128_u64[0]);
        }
      }
    }
    CSIPacketAddress::operator std::string();
    if (!*((unsigned char *)a2 + 136)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    std::optional<std::string>::operator=[abi:ne180100]<std::string,void>((uint64_t)a2 + 88, (long long *)&__p);
    if (v17 < 0) {
      operator delete((void *)__p.n128_u64[0]);
    }
    CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&v24);
    __int16 v6 = CSIPacketAddress::maskToPrefix((CSIPacketAddress *)&v24);
    if (!*((unsigned char *)a2 + 136)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    *((_WORD *)a2 + 60) = v6 | 0x100;
  }
  if (*((unsigned char *)this + 63))
  {
    unsigned int v7 = *((unsigned __int16 *)this + 32);
    *((_DWORD *)a2 + 7) = 4;
    *((_WORD *)a2 + 72) = v7 | 0x100;
    *((_WORD *)a2 + 73) = (v7 >> 8) | 0x100;
  }
  if (*((unsigned char *)this + 86))
  {
    *(_OWORD *)uint64_t v27 = *(_OWORD *)((char *)this + 87);
    __int16 v8 = *((unsigned __int8 *)this + 103);
    *((_DWORD *)a2 + 7) = 41;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v24);
    CSIPacketAddress::setIPv6Address((CSIPacketAddress *)&v24, v27);
    if (!*((unsigned char *)a2 + 80))
    {
      __p.n128_u8[0] = 0;
      char v18 = 0;
      __int16 v19 = 0;
      char v20 = 0;
      char v21 = 0;
      char v22 = 0;
      char v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 32, &__p);
      if (v18)
      {
        if (v17 < 0) {
          operator delete((void *)__p.n128_u64[0]);
        }
      }
    }
    CSIPacketAddress::operator std::string();
    if (!*((unsigned char *)a2 + 80)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    std::optional<std::string>::operator=[abi:ne180100]<std::string,void>((uint64_t)a2 + 32, (long long *)&__p);
    if (v17 < 0) {
      operator delete((void *)__p.n128_u64[0]);
    }
    if (!*((unsigned char *)a2 + 80)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    *((_WORD *)a2 + 32) = v8 | 0x100;
  }
  if (*((unsigned char *)this + 68))
  {
    *(_OWORD *)uint64_t v27 = *(_OWORD *)((char *)this + 69);
    __int16 v9 = *((unsigned __int8 *)this + 85);
    *((_DWORD *)a2 + 7) = 41;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v24);
    CSIPacketAddress::setIPv6Address((CSIPacketAddress *)&v24, v27);
    if (!*((unsigned char *)a2 + 136))
    {
      __p.n128_u8[0] = 0;
      char v18 = 0;
      __int16 v19 = 0;
      char v20 = 0;
      char v21 = 0;
      char v22 = 0;
      char v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 88, &__p);
      if (v18)
      {
        if (v17 < 0) {
          operator delete((void *)__p.n128_u64[0]);
        }
      }
    }
    CSIPacketAddress::operator std::string();
    if (!*((unsigned char *)a2 + 136)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    std::optional<std::string>::operator=[abi:ne180100]<std::string,void>((uint64_t)a2 + 88, (long long *)&__p);
    if (v17 < 0) {
      operator delete((void *)__p.n128_u64[0]);
    }
    if (!*((unsigned char *)a2 + 136)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    *((_WORD *)a2 + 60) = v9 | 0x100;
  }
  if (*((unsigned char *)this + 60))
  {
    unsigned int v10 = *(unsigned __int16 *)((char *)this + 61);
    *((_DWORD *)a2 + 7) = 41;
    *((_WORD *)a2 + 72) = v10 | 0x100;
    *((_WORD *)a2 + 73) = (v10 >> 8) | 0x100;
  }
  if (*((unsigned char *)this + 52))
  {
    int v11 = *((_DWORD *)this + 14);
    *((_DWORD *)a2 + 7) = 41;
    *((_DWORD *)a2 + 37) = v11;
    *((unsigned char *)a2 + 152) = 1;
  }
  if (*((unsigned char *)this + 46))
  {
    int v12 = *((_DWORD *)this + 12);
    *((_DWORD *)a2 + 6) = 6;
    if (!*((unsigned char *)a2 + 80))
    {
      __p.n128_u8[0] = 0;
      char v18 = 0;
      __int16 v19 = 0;
      char v20 = 0;
      char v21 = 0;
      char v22 = 0;
      char v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 32, &__p);
      if (v18 && v17 < 0) {
        operator delete((void *)__p.n128_u64[0]);
      }
      if (!*((unsigned char *)a2 + 80)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
    }
    *((_WORD *)a2 + 33) = v12;
    *((unsigned char *)a2 + 6_Block_object_dispose(&a9, 8) = 1;
    *((_WORD *)a2 + 35) = HIWORD(v12);
    *((unsigned char *)a2 + 72) = 1;
  }
  if (*((unsigned char *)this + 40))
  {
    int v13 = *(_DWORD *)((char *)this + 42);
    *((_DWORD *)a2 + 6) = 6;
    if (!*((unsigned char *)a2 + 136))
    {
      __p.n128_u8[0] = 0;
      char v18 = 0;
      __int16 v19 = 0;
      char v20 = 0;
      char v21 = 0;
      char v22 = 0;
      char v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 88, &__p);
      if (v18 && v17 < 0) {
        operator delete((void *)__p.n128_u64[0]);
      }
      if (!*((unsigned char *)a2 + 136)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
    }
    *((_WORD *)a2 + 61) = v13;
    *((unsigned char *)a2 + 124) = 1;
    *((_WORD *)a2 + 63) = HIWORD(v13);
    *((unsigned char *)a2 + 12_Block_object_dispose(&a9, 8) = 1;
  }
  if (*((unsigned char *)this + 34))
  {
    int v14 = *((_DWORD *)this + 9);
    *((_DWORD *)a2 + 6) = 17;
    if (!*((unsigned char *)a2 + 80))
    {
      __p.n128_u8[0] = 0;
      char v18 = 0;
      __int16 v19 = 0;
      char v20 = 0;
      char v21 = 0;
      char v22 = 0;
      char v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 32, &__p);
      if (v18 && v17 < 0) {
        operator delete((void *)__p.n128_u64[0]);
      }
      if (!*((unsigned char *)a2 + 80)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
    }
    *((_WORD *)a2 + 33) = v14;
    *((unsigned char *)a2 + 6_Block_object_dispose(&a9, 8) = 1;
    *((_WORD *)a2 + 35) = HIWORD(v14);
    *((unsigned char *)a2 + 72) = 1;
  }
  if (*((unsigned char *)this + 28))
  {
    int v15 = *(_DWORD *)((char *)this + 30);
    *((_DWORD *)a2 + 6) = 17;
    if (!*((unsigned char *)a2 + 136))
    {
      __p.n128_u8[0] = 0;
      char v18 = 0;
      __int16 v19 = 0;
      char v20 = 0;
      char v21 = 0;
      char v22 = 0;
      char v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 88, &__p);
      if (v18 && v17 < 0) {
        operator delete((void *)__p.n128_u64[0]);
      }
      if (!*((unsigned char *)a2 + 136)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
    }
    *((_WORD *)a2 + 61) = v15;
    *((unsigned char *)a2 + 124) = 1;
    *((_WORD *)a2 + 63) = HIWORD(v15);
    *((unsigned char *)a2 + 12_Block_object_dispose(&a9, 8) = 1;
  }
  if (*((unsigned char *)this + 4)) {
    *((_DWORD *)a2 + 5) = *((unsigned __int16 *)this + 3);
  }
  if (*(unsigned char *)this) {
    *(_DWORD *)a2 = *((unsigned __int16 *)this + 1);
  }
}

void sub_22252DA2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(uint64_t a1, __n128 *a2)
{
  if (*(unsigned char *)(a1 + 48))
  {
    std::__optional_storage_base<std::string,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::string,false>>(a1, a2);
    unint64_t v4 = a2[2].n128_u64[0];
    *(unsigned char *)(a1 + 40) = a2[2].n128_u8[8];
    *(void *)(a1 + 32) = v4;
  }
  else
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 24) = 0;
    if (a2[1].n128_u8[8])
    {
      __n128 v5 = *a2;
      *(void *)(a1 + 16) = a2[1].n128_u64[0];
      *(__n128 *)a1 = v5;
      a2->n128_u64[1] = 0;
      a2[1].n128_u64[0] = 0;
      a2->n128_u64[0] = 0;
      *(unsigned char *)(a1 + 24) = 1;
    }
    unint64_t v6 = a2[2].n128_u64[0];
    *(unsigned char *)(a1 + 40) = a2[2].n128_u8[8];
    *(void *)(a1 + 32) = v6;
    *(unsigned char *)(a1 + 4_Block_object_dispose(&a9, 8) = 1;
  }
  return a1;
}

void QMIQOSClientIP::mav20FilterSpecToDict(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  int v4 = *a1;
  if (v4 == 6)
  {
    *(_DWORD *)(a2 + 2_Block_object_dispose(&a9, 8) = 41;
    uint64_t v8 = *((void *)a1 + 5);
    if (v8)
    {
      if (!*(unsigned char *)(a2 + 80))
      {
        __p.n128_u8[0] = 0;
        char v16 = 0;
        __int16 v17 = 0;
        char v18 = 0;
        char v19 = 0;
        char v20 = 0;
        char v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 32, &__p);
        if (v16)
        {
          if (SHIBYTE(v15) < 0) {
            operator delete((void *)__p.n128_u64[0]);
          }
        }
      }
      *(_OWORD *)char v22 = *((_OWORD *)a1 + 3);
      __n128 __p = 0uLL;
      uint64_t v15 = 0;
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&__p);
      CSIPacketAddress::setIPv6Address((CSIPacketAddress *)&__p, v22);
      CSIPacketAddress::operator std::string();
      if (!*(unsigned char *)(a2 + 80)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      std::optional<std::string>::operator=[abi:ne180100]<std::string,void>(a2 + 32, (long long *)v12);
      if (v13 < 0) {
        operator delete(v12[0]);
      }
      if (!*(unsigned char *)(a2 + 80)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      *(_WORD *)(a2 + 64) = a1[81] | 0x100;
      uint64_t v8 = *((void *)a1 + 5);
    }
    if ((v8 & 2) != 0)
    {
      if (!*(unsigned char *)(a2 + 136))
      {
        __p.n128_u8[0] = 0;
        char v16 = 0;
        __int16 v17 = 0;
        char v18 = 0;
        char v19 = 0;
        char v20 = 0;
        char v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 88, &__p);
        if (v16)
        {
          if (SHIBYTE(v15) < 0) {
            operator delete((void *)__p.n128_u64[0]);
          }
        }
      }
      *(_OWORD *)char v22 = *(_OWORD *)(a1 + 65);
      __n128 __p = 0uLL;
      uint64_t v15 = 0;
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&__p);
      CSIPacketAddress::setIPv6Address((CSIPacketAddress *)&__p, v22);
      CSIPacketAddress::operator std::string();
      if (!*(unsigned char *)(a2 + 136)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      std::optional<std::string>::operator=[abi:ne180100]<std::string,void>(a2 + 88, (long long *)v12);
      if (v13 < 0) {
        operator delete(v12[0]);
      }
      if (!*(unsigned char *)(a2 + 136)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      *(_WORD *)(a2 + 120) = a1[81] | 0x100;
      uint64_t v8 = *((void *)a1 + 5);
    }
    if ((v8 & 4) != 0)
    {
      *(_WORD *)(a2 + 144) = a1[82] | 0x100;
      *(_WORD *)(a2 + 146) = a1[83] | 0x100;
      uint64_t v8 = *((void *)a1 + 5);
    }
    if ((v8 & 8) != 0)
    {
      *(_DWORD *)(a2 + 14_Block_object_dispose(&a9, 8) = *((_DWORD *)a1 + 21);
      *(unsigned char *)(a2 + 152) = 1;
    }
  }
  else if (v4 == 4)
  {
    *(_DWORD *)(a2 + 2_Block_object_dispose(&a9, 8) = 4;
    uint64_t v5 = *((void *)a1 + 1);
    if (v5)
    {
      if (!*(unsigned char *)(a2 + 80))
      {
        __p.n128_u8[0] = 0;
        char v16 = 0;
        __int16 v17 = 0;
        char v18 = 0;
        char v19 = 0;
        char v20 = 0;
        char v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 32, &__p);
        if (v16)
        {
          if (SHIBYTE(v15) < 0) {
            operator delete((void *)__p.n128_u64[0]);
          }
        }
      }
      __n128 __p = 0uLL;
      uint64_t v15 = 0;
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&__p);
      CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&__p);
      CSIPacketAddress::operator std::string();
      if (!*(unsigned char *)(a2 + 80)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      std::optional<std::string>::operator=[abi:ne180100]<std::string,void>(a2 + 32, (long long *)v12);
      if (v13 < 0) {
        operator delete(v12[0]);
      }
      CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&__p);
      __int16 v6 = CSIPacketAddress::maskToPrefix((CSIPacketAddress *)&__p);
      if (!*(unsigned char *)(a2 + 80)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      *(_WORD *)(a2 + 64) = v6 | 0x100;
      uint64_t v5 = *((void *)a1 + 1);
    }
    if ((v5 & 2) != 0)
    {
      if (!*(unsigned char *)(a2 + 136))
      {
        __p.n128_u8[0] = 0;
        char v16 = 0;
        __int16 v17 = 0;
        char v18 = 0;
        char v19 = 0;
        char v20 = 0;
        char v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 88, &__p);
        if (v16)
        {
          if (SHIBYTE(v15) < 0) {
            operator delete((void *)__p.n128_u64[0]);
          }
        }
      }
      __n128 __p = 0uLL;
      uint64_t v15 = 0;
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&__p);
      CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&__p);
      CSIPacketAddress::operator std::string();
      if (!*(unsigned char *)(a2 + 136)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      std::optional<std::string>::operator=[abi:ne180100]<std::string,void>(a2 + 88, (long long *)v12);
      if (v13 < 0) {
        operator delete(v12[0]);
      }
      CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&__p);
      __int16 v7 = CSIPacketAddress::maskToPrefix((CSIPacketAddress *)&__p);
      if (!*(unsigned char *)(a2 + 136)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      *(_WORD *)(a2 + 120) = v7 | 0x100;
      uint64_t v5 = *((void *)a1 + 1);
    }
    if ((v5 & 4) != 0)
    {
      *(_WORD *)(a2 + 144) = a1[32] | 0x100;
      *(_WORD *)(a2 + 146) = a1[33] | 0x100;
    }
  }
  int v9 = *((_DWORD *)a1 + 22);
  if (v9 == 6)
  {
    *(_DWORD *)(a2 + 24) = 6;
    uint64_t v10 = *((void *)a1 + 12);
    if (v10)
    {
      if (!*(unsigned char *)(a2 + 80))
      {
        __p.n128_u8[0] = 0;
        char v16 = 0;
        __int16 v17 = 0;
        char v18 = 0;
        char v19 = 0;
        char v20 = 0;
        char v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 32, &__p);
        if (v16 && SHIBYTE(v15) < 0) {
          operator delete((void *)__p.n128_u64[0]);
        }
        if (!*(unsigned char *)(a2 + 80)) {
          std::__throw_bad_optional_access[abi:ne180100]();
        }
      }
      *(_WORD *)(a2 + 66) = *((_WORD *)a1 + 52);
      *(unsigned char *)(a2 + 6_Block_object_dispose(&a9, 8) = 1;
      *(_WORD *)(a2 + 70) = *((_WORD *)a1 + 53);
      *(unsigned char *)(a2 + 72) = 1;
      uint64_t v10 = *((void *)a1 + 12);
    }
    if ((v10 & 2) != 0)
    {
      if (!*(unsigned char *)(a2 + 136))
      {
        __p.n128_u8[0] = 0;
        char v16 = 0;
        __int16 v17 = 0;
        char v18 = 0;
        char v19 = 0;
        char v20 = 0;
        char v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 88, &__p);
        if (v16 && SHIBYTE(v15) < 0) {
          operator delete((void *)__p.n128_u64[0]);
        }
        if (!*(unsigned char *)(a2 + 136)) {
          std::__throw_bad_optional_access[abi:ne180100]();
        }
      }
      *(_WORD *)(a2 + 122) = *((_WORD *)a1 + 54);
      *(unsigned char *)(a2 + 124) = 1;
      *(_WORD *)(a2 + 126) = *((_WORD *)a1 + 55);
      *(unsigned char *)(a2 + 12_Block_object_dispose(&a9, 8) = 1;
    }
    int v9 = *((_DWORD *)a1 + 22);
  }
  if (v9 == 17)
  {
    *(_DWORD *)(a2 + 24) = 17;
    uint64_t v11 = *((void *)a1 + 14);
    if (v11)
    {
      if (!*(unsigned char *)(a2 + 80))
      {
        __p.n128_u8[0] = 0;
        char v16 = 0;
        __int16 v17 = 0;
        char v18 = 0;
        char v19 = 0;
        char v20 = 0;
        char v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 32, &__p);
        if (v16 && SHIBYTE(v15) < 0) {
          operator delete((void *)__p.n128_u64[0]);
        }
        if (!*(unsigned char *)(a2 + 80)) {
          std::__throw_bad_optional_access[abi:ne180100]();
        }
      }
      *(_WORD *)(a2 + 66) = *((_WORD *)a1 + 60);
      *(unsigned char *)(a2 + 6_Block_object_dispose(&a9, 8) = 1;
      *(_WORD *)(a2 + 70) = *((_WORD *)a1 + 61);
      *(unsigned char *)(a2 + 72) = 1;
      uint64_t v11 = *((void *)a1 + 14);
    }
    if ((v11 & 2) != 0)
    {
      if (!*(unsigned char *)(a2 + 136))
      {
        __p.n128_u8[0] = 0;
        char v16 = 0;
        __int16 v17 = 0;
        char v18 = 0;
        char v19 = 0;
        char v20 = 0;
        char v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 88, &__p);
        if (v16 && SHIBYTE(v15) < 0) {
          operator delete((void *)__p.n128_u64[0]);
        }
        if (!*(unsigned char *)(a2 + 136)) {
          std::__throw_bad_optional_access[abi:ne180100]();
        }
      }
      *(_WORD *)(a2 + 122) = *((_WORD *)a1 + 62);
      *(unsigned char *)(a2 + 124) = 1;
      *(_WORD *)(a2 + 126) = *((_WORD *)a1 + 63);
      *(unsigned char *)(a2 + 12_Block_object_dispose(&a9, 8) = 1;
    }
  }
  *(_DWORD *)a2 = *((unsigned __int16 *)a1 + 86);
  *(_DWORD *)(a2 + 20) = *((unsigned __int16 *)a1 + 87);
}

void sub_22252E16C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZNK14QMIQOSClientIP28handleQOSEventReportInd_syncERKN3qos14EventReportInd10IndicationE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v24 = 0;
  uint64_t v25 = &v24;
  uint64_t v26 = 0xC002000000;
  uint64_t v27 = __Block_byref_object_copy__11;
  uint64_t v28 = __Block_byref_object_dispose__11;
  uint64_t v36 = 256;
  long long v4 = 0uLL;
  long long v29 = 0u;
  long long v30 = 0u;
  memset(v31, 0, sizeof(v31));
  long long v32 = 0u;
  long long v33 = 0u;
  memset(v34, 0, sizeof(v34));
  long long v35 = 0u;
  LODWORD(v29) = *(_DWORD *)a2;
  uint64_t v46 = 0;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  if (*(unsigned char *)(a2 + 208))
  {
    qos::tlv::FlowSpec::FlowSpec((qos::tlv::FlowSpec *)((char *)&v38 + 8), (const qos::tlv::FlowSpec *)(a2 + 216));
    LOBYTE(v3_Block_object_dispose(&a9, 8) = 1;
    uint64_t v23 = 0;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v20 = 0u;
    if (BYTE12(v39))
    {
      DWORD2(v20) = v40;
      BYTE12(v20) = 1;
      LODWORD(v21) = DWORD1(v40);
      BYTE4(v21) = 1;
    }
    if (BYTE14(v45))
    {
      BYTE4(v20) = 1;
      LODWORD(v20) = HIBYTE(v45);
    }
    std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS&,void>((uint64_t)(v25 + 7), (uint64_t)&v20);
    if ((_BYTE)v23)
    {
      unint64_t v37 = (void **)&v21 + 1;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v37);
    }
    long long v4 = 0uLL;
    if ((_BYTE)v38)
    {
      if ((_BYTE)v46) {
        LOBYTE(v46) = 0;
      }
      if (BYTE14(v45)) {
        BYTE14(v45) = 0;
      }
      if (BYTE12(v45)) {
        BYTE12(v45) = 0;
      }
      if (BYTE10(v45)) {
        BYTE10(v45) = 0;
      }
      if (BYTE8(v45)) {
        BYTE8(v45) = 0;
      }
      if (BYTE4(v45)) {
        BYTE4(v45) = 0;
      }
      if (BYTE2(v45)) {
        BYTE2(v45) = 0;
      }
      if ((_BYTE)v45) {
        LOBYTE(v45) = 0;
      }
      if (BYTE8(v44)) {
        BYTE8(v44) = 0;
      }
      if ((_BYTE)v44) {
        LOBYTE(v44) = 0;
      }
      if (BYTE8(v43)) {
        BYTE8(v43) = 0;
      }
      if ((_BYTE)v43) {
        LOBYTE(v43) = 0;
      }
      if (BYTE8(v42)) {
        BYTE8(v42) = 0;
      }
      if (BYTE8(v40) && (void)v41)
      {
        *((void *)&v41 + 1) = v41;
        operator delete((void *)v41);
        long long v4 = 0uLL;
      }
    }
  }
  uint64_t v46 = 0;
  long long v44 = v4;
  long long v45 = v4;
  long long v42 = v4;
  long long v43 = v4;
  long long v40 = v4;
  long long v41 = v4;
  long long v38 = v4;
  long long v39 = v4;
  if (*(unsigned char *)(a2 + 72))
  {
    qos::tlv::FlowSpec::FlowSpec((qos::tlv::FlowSpec *)((char *)&v38 + 8), (const qos::tlv::FlowSpec *)(a2 + 80));
    LOBYTE(v3_Block_object_dispose(&a9, 8) = 1;
    uint64_t v23 = 0;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v20 = 0u;
    if (BYTE12(v39))
    {
      DWORD2(v20) = v40;
      BYTE12(v20) = 1;
      LODWORD(v21) = DWORD1(v40);
      BYTE4(v21) = 1;
    }
    if (BYTE14(v45))
    {
      BYTE4(v20) = 1;
      LODWORD(v20) = HIBYTE(v45);
    }
    std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS&,void>((uint64_t)(v25 + 15), (uint64_t)&v20);
    if ((_BYTE)v23)
    {
      unint64_t v37 = (void **)&v21 + 1;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v37);
    }
    if ((_BYTE)v38)
    {
      if ((_BYTE)v46) {
        LOBYTE(v46) = 0;
      }
      if (BYTE14(v45)) {
        BYTE14(v45) = 0;
      }
      if (BYTE12(v45)) {
        BYTE12(v45) = 0;
      }
      if (BYTE10(v45)) {
        BYTE10(v45) = 0;
      }
      if (BYTE8(v45)) {
        BYTE8(v45) = 0;
      }
      if (BYTE4(v45)) {
        BYTE4(v45) = 0;
      }
      if (BYTE2(v45)) {
        BYTE2(v45) = 0;
      }
      if ((_BYTE)v45) {
        LOBYTE(v45) = 0;
      }
      if (BYTE8(v44)) {
        BYTE8(v44) = 0;
      }
      if ((_BYTE)v44) {
        LOBYTE(v44) = 0;
      }
      if (BYTE8(v43)) {
        BYTE8(v43) = 0;
      }
      if ((_BYTE)v43) {
        LOBYTE(v43) = 0;
      }
      if (BYTE8(v42)) {
        BYTE8(v42) = 0;
      }
      if (BYTE8(v40) && (void)v41)
      {
        *((void *)&v41 + 1) = v41;
        operator delete((void *)v41);
      }
    }
  }
  *(void *)&long long v38 = 0;
  if (*(unsigned char *)(a2 + 40))
  {
    *((void *)&v38 + 1) = 0;
    long long v39 = 0uLL;
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__init_with_size[abi:ne180100]<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*,tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*>((void *)&v38 + 1, *(void *)(a2 + 48), *(void *)(a2 + 56), 0xF83E0F83E0F83E1 * ((uint64_t)(*(void *)(a2 + 56) - *(void *)(a2 + 48)) >> 2));
    LOBYTE(v3_Block_object_dispose(&a9, 8) = 1;
    uint64_t v5 = *((void *)&v38 + 1);
    uint64_t v6 = v39;
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 0x40000000;
    char v16 = ___ZNK14QMIQOSClientIP28handleQOSEventReportInd_syncERKN3qos14EventReportInd10IndicationE_block_invoke_128;
    __int16 v17 = &unk_2646122D0;
    char v18 = &v24;
    uint64_t v19 = v3;
    if (*((void *)&v38 + 1) == (void)v39) {
      goto LABEL_79;
    }
    do
    {
      ((void (*)(void *, uint64_t))v16)(v15, v5);
      v5 += 132;
    }
    while (v5 != v6);
    if ((_BYTE)v38)
    {
LABEL_79:
      *(void *)&long long v20 = (char *)&v38 + 8;
      std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v20);
    }
  }
  *(void *)&long long v38 = 0;
  if (*(unsigned char *)(a2 + 8))
  {
    *((void *)&v38 + 1) = 0;
    long long v39 = 0uLL;
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__init_with_size[abi:ne180100]<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*,tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*>((void *)&v38 + 1, *(void *)(a2 + 16), *(void *)(a2 + 24), 0xF83E0F83E0F83E1 * ((uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 2));
    LOBYTE(v3_Block_object_dispose(&a9, 8) = 1;
    uint64_t v7 = *((void *)&v38 + 1);
    uint64_t v8 = v39;
    v10[0] = MEMORY[0x263EF8330];
    v10[1] = 0x40000000;
    uint64_t v11 = ___ZNK14QMIQOSClientIP28handleQOSEventReportInd_syncERKN3qos14EventReportInd10IndicationE_block_invoke_2;
    int v12 = &unk_2646122F8;
    char v13 = &v24;
    uint64_t v14 = v3;
    if (*((void *)&v38 + 1) == (void)v39) {
      goto LABEL_84;
    }
    do
    {
      ((void (*)(void *, uint64_t))v11)(v10, v7);
      v7 += 132;
    }
    while (v7 != v8);
    if ((_BYTE)v38)
    {
LABEL_84:
      *(void *)&long long v20 = (char *)&v38 + 8;
      std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v20);
    }
  }
  if (*(unsigned char *)(a2 + 346)) {
    *((_DWORD *)v25 + 11) = *(unsigned __int8 *)(a2 + 347);
  }
  int v9 = *(unsigned __int8 *)(a2 + 5);
  if ((v9 - 1) >= 2)
  {
    if (v9 == 3) {
      (*(void (**)(void, void))(**(void **)(v3 + 64) + 88))(*(void *)(v3 + 64), *((unsigned int *)v25 + 10));
    }
  }
  else
  {
    (*(void (**)(void, uint64_t *))(**(void **)(v3 + 64) + 80))(*(void *)(v3 + 64), v25 + 5);
  }
  _Block_object_dispose(&v24, 8);
  if (BYTE8(v35) && (_BYTE)v35)
  {
    *(void *)&long long v38 = &v34[8];
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100]((void ***)&v38);
  }
  if (BYTE8(v32))
  {
    if ((_BYTE)v32)
    {
      *(void *)&long long v38 = &v31[8];
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100]((void ***)&v38);
    }
  }
}

void sub_22252E7EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  _Block_object_dispose(&a28, 8);
  DataCellularQoSFlow::~DataCellularQoSFlow((DataCellularQoSFlow *)(v28 + 40));
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__11(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  std::__optional_move_base<DataQoS,false>::__optional_move_base[abi:ne180100](a1 + 56, (long long *)(a2 + 56));
  uint64_t result = std::__optional_move_base<DataQoS,false>::__optional_move_base[abi:ne180100](a1 + 120, (long long *)(a2 + 120));
  *(_WORD *)(a1 + 184) = *(_WORD *)(a2 + 184);
  return result;
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 176) && *(unsigned char *)(a1 + 168))
  {
    int v2 = (void **)(a1 + 144);
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v2);
  }
  if (*(unsigned char *)(a1 + 112))
  {
    if (*(unsigned char *)(a1 + 104))
    {
      int v2 = (void **)(a1 + 80);
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v2);
    }
  }
}

void DataCellularQoSFlow::~DataCellularQoSFlow(DataCellularQoSFlow *this)
{
  if (*((unsigned char *)this + 136) && *((unsigned char *)this + 128))
  {
    int v2 = (void **)((char *)this + 104);
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v2);
  }
  if (*((unsigned char *)this + 72))
  {
    if (*((unsigned char *)this + 64))
    {
      int v2 = (void **)((char *)this + 40);
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v2);
    }
  }
}

uint64_t std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS&,void>(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 56);
  uint64_t v4 = *(void *)(a2 + 13);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 13) = v4;
  uint64_t v5 = (void *)(a1 + 24);
  if (v3)
  {
    if (*(unsigned __int8 *)(a1 + 48) == *(unsigned __int8 *)(a2 + 48))
    {
      if (a1 != a2 && *(unsigned char *)(a1 + 48))
      {
        uint64_t v7 = *(void *)(a2 + 24);
        uint64_t v6 = *(void *)(a2 + 32);
        unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 5);
        uint64_t v9 = *(void *)(a1 + 24);
        if (0xCCCCCCCCCCCCCCCDLL * ((*(void *)(a1 + 40) - v9) >> 5) >= v8)
        {
          if (0xCCCCCCCCCCCCCCCDLL * ((*(void *)(a1 + 32) - v9) >> 5) >= v8)
          {
            std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<DataIPFilter *,DataIPFilter *,DataIPFilter *>((uint64_t)&v16, *(void *)(a2 + 24), v6, v9);
            std::vector<DataIPFilter>::__base_destruct_at_end[abi:ne180100]((uint64_t)v5, v14);
            return a1;
          }
          uint64_t v13 = v7 + 32 * ((*(void *)(a1 + 32) - v9) >> 5);
          std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<DataIPFilter *,DataIPFilter *,DataIPFilter *>((uint64_t)&v16, *(void *)(a2 + 24), v13, v9);
          uint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<DataIPFilter>,DataIPFilter*,DataIPFilter*,DataIPFilter*>(a1 + 40, v13, v6, *(void *)(a1 + 32));
        }
        else
        {
          std::vector<DataIPFilter>::__vdeallocate((uint64_t *)(a1 + 24));
          if (v8 > 0x199999999999999) {
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v10 = 0x999999999999999ALL * ((uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 24)) >> 5);
          if (v10 <= v8) {
            unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 5);
          }
          if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 24)) >> 5) >= 0xCCCCCCCCCCCCCCLL) {
            unint64_t v11 = 0x199999999999999;
          }
          else {
            unint64_t v11 = v10;
          }
          std::vector<DataIPFilter>::__vallocate[abi:ne180100](v5, v11);
          uint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<DataIPFilter>,DataIPFilter*,DataIPFilter*,DataIPFilter*>(a1 + 40, v7, v6, *(void *)(a1 + 32));
        }
        *(void *)(a1 + 32) = v12;
      }
    }
    else if (*(unsigned char *)(a1 + 48))
    {
      char v16 = (void **)(a1 + 24);
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v16);
      *(unsigned char *)(a1 + 4_Block_object_dispose(&a9, 8) = 0;
    }
    else
    {
      *uint64_t v5 = 0;
      *(void *)(a1 + 32) = 0;
      *(void *)(a1 + 40) = 0;
      std::vector<DataIPFilter>::__init_with_size[abi:ne180100]<DataIPFilter*,DataIPFilter*>((void *)(a1 + 24), *(void *)(a2 + 24), *(void *)(a2 + 32), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 5));
      *(unsigned char *)(a1 + 4_Block_object_dispose(&a9, 8) = 1;
    }
  }
  else
  {
    *(unsigned char *)(a1 + 24) = 0;
    *(unsigned char *)(a1 + 4_Block_object_dispose(&a9, 8) = 0;
    if (*(unsigned char *)(a2 + 48))
    {
      *uint64_t v5 = 0;
      *(void *)(a1 + 32) = 0;
      *(void *)(a1 + 40) = 0;
      std::vector<DataIPFilter>::__init_with_size[abi:ne180100]<DataIPFilter*,DataIPFilter*>((void *)(a1 + 24), *(void *)(a2 + 24), *(void *)(a2 + 32), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 5));
      *(unsigned char *)(a1 + 4_Block_object_dispose(&a9, 8) = 1;
    }
    *(unsigned char *)(a1 + 56) = 1;
  }
  return a1;
}

void sub_22252EBC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  *(void *)(v10 + 32) = v11;
  _Unwind_Resume(exception_object);
}

void ___ZNK14QMIQOSClientIP28handleQOSEventReportInd_syncERKN3qos14EventReportInd10IndicationE_block_invoke_128(uint64_t a1, QMIQOSClientIP *this, DataIPFilter *a3)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v5 + 112))
  {
    LOBYTE(v9) = 0;
    BYTE4(v9) = 0;
    BYTE8(v9) = 0;
    BYTE12(v9) = 0;
    LOBYTE(v10) = 0;
    BYTE4(v10) = 0;
    BYTE8(v10) = 0;
    LOBYTE(v12) = 0;
    std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS,void>(v5 + 56, (uint64_t)&v9);
    if ((_BYTE)v12)
    {
      uint64_t v19 = (void **)&v10 + 1;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v19);
    }
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
    if (!*(unsigned char *)(v5 + 112)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
  }
  if (!*(unsigned char *)(v5 + 104))
  {
    long long v9 = 0uLL;
    *(void *)&long long v10 = 0;
    std::optional<std::vector<DataIPFilter>>::operator=[abi:ne180100]<std::vector<DataIPFilter>,void>(v5 + 80, (uint64_t)&v9);
    uint64_t v19 = (void **)&v9;
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v19);
  }
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  *(_OWORD *)__n128 __p = 0u;
  *(_OWORD *)uint64_t v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  QMIQOSClientIP::FilterSpecToDict(this, (const qos::tlv::QoSFilter *)&v9, a3);
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v6 + 112) || !*(unsigned char *)(v6 + 104)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  unint64_t v7 = *(void *)(v6 + 88);
  if (v7 >= *(void *)(v6 + 96))
  {
    uint64_t v8 = std::vector<DataIPFilter>::__emplace_back_slow_path<DataIPFilter&>((uint64_t *)(v6 + 80), (uint64_t)&v9);
  }
  else
  {
    std::construct_at[abi:ne180100]<DataIPFilter,DataIPFilter&,DataIPFilter*>(*(void *)(v6 + 88), (uint64_t)&v9);
    uint64_t v8 = v7 + 160;
    *(void *)(v6 + 8_Block_object_dispose(&a9, 8) = v7 + 160;
  }
  *(void *)(v6 + 8_Block_object_dispose(&a9, 8) = v8;
  if (BYTE8(v17) && (_BYTE)v16 && SHIBYTE(v15) < 0) {
    operator delete(__p[1]);
  }
  if (LOBYTE(__p[0]) && BYTE8(v12) && SBYTE7(v12) < 0) {
    operator delete(v11[0]);
  }
}

void sub_22252ED7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,char a32)
{
  uint64_t v34 = v32;
  *(void *)(v34 + 8_Block_object_dispose(&a9, 8) = v33;
  if (a32 && a29 && a28 < 0) {
    operator delete(__p);
  }
  if (a22 && a19 && a18 < 0) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS,void>(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 56);
  uint64_t v5 = *(void *)(a2 + 13);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 13) = v5;
  uint64_t v6 = (uint64_t *)(a1 + 24);
  if (v4)
  {
    unint64_t v7 = (void *)(a2 + 24);
    if (*(unsigned __int8 *)(a1 + 48) == *(unsigned __int8 *)(a2 + 48))
    {
      if (*(unsigned char *)(a1 + 48))
      {
        std::vector<DataIPFilter>::__vdeallocate(v6);
        *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *unint64_t v7 = 0;
        *(void *)(a2 + 32) = 0;
        *(void *)(a2 + 40) = 0;
      }
    }
    else if (*(unsigned char *)(a1 + 48))
    {
      long long v9 = (void **)v6;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v9);
      *(unsigned char *)(a1 + 4_Block_object_dispose(&a9, 8) = 0;
    }
    else
    {
      uint64_t *v6 = 0;
      v6[1] = 0;
      _DWORD v6[2] = 0;
      *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
      *(void *)(a1 + 40) = *(void *)(a2 + 40);
      *unint64_t v7 = 0;
      *(void *)(a2 + 32) = 0;
      *(void *)(a2 + 40) = 0;
      *(unsigned char *)(a1 + 4_Block_object_dispose(&a9, 8) = 1;
    }
  }
  else
  {
    *(unsigned char *)(a1 + 24) = 0;
    *(unsigned char *)(a1 + 4_Block_object_dispose(&a9, 8) = 0;
    if (*(unsigned char *)(a2 + 48))
    {
      uint64_t *v6 = 0;
      v6[1] = 0;
      _DWORD v6[2] = 0;
      *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
      *(void *)(a1 + 40) = *(void *)(a2 + 40);
      *(void *)(a2 + 24) = 0;
      *(void *)(a2 + 32) = 0;
      *(void *)(a2 + 40) = 0;
      *(unsigned char *)(a1 + 4_Block_object_dispose(&a9, 8) = 1;
    }
    *(unsigned char *)(a1 + 56) = 1;
  }
  return a1;
}

uint64_t std::optional<std::vector<DataIPFilter>>::operator=[abi:ne180100]<std::vector<DataIPFilter>,void>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    std::vector<DataIPFilter>::__vdeallocate((uint64_t *)a1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + _Block_object_dispose(&a9, 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + _Block_object_dispose(&a9, 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void ___ZNK14QMIQOSClientIP28handleQOSEventReportInd_syncERKN3qos14EventReportInd10IndicationE_block_invoke_2(uint64_t a1, QMIQOSClientIP *this, DataIPFilter *a3)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v5 + 176))
  {
    LOBYTE(v9) = 0;
    BYTE4(v9) = 0;
    BYTE8(v9) = 0;
    BYTE12(v9) = 0;
    LOBYTE(v10) = 0;
    BYTE4(v10) = 0;
    BYTE8(v10) = 0;
    LOBYTE(v12) = 0;
    std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS,void>(v5 + 120, (uint64_t)&v9);
    if ((_BYTE)v12)
    {
      uint64_t v19 = (void **)&v10 + 1;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v19);
    }
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
    if (!*(unsigned char *)(v5 + 176)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
  }
  if (!*(unsigned char *)(v5 + 168))
  {
    long long v9 = 0uLL;
    *(void *)&long long v10 = 0;
    std::optional<std::vector<DataIPFilter>>::operator=[abi:ne180100]<std::vector<DataIPFilter>,void>(v5 + 144, (uint64_t)&v9);
    uint64_t v19 = (void **)&v9;
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v19);
  }
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  *(_OWORD *)__n128 __p = 0u;
  *(_OWORD *)uint64_t v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  QMIQOSClientIP::FilterSpecToDict(this, (const qos::tlv::QoSFilter *)&v9, a3);
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v6 + 176) || !*(unsigned char *)(v6 + 168)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  unint64_t v7 = *(void *)(v6 + 152);
  if (v7 >= *(void *)(v6 + 160))
  {
    uint64_t v8 = std::vector<DataIPFilter>::__emplace_back_slow_path<DataIPFilter&>((uint64_t *)(v6 + 144), (uint64_t)&v9);
  }
  else
  {
    std::construct_at[abi:ne180100]<DataIPFilter,DataIPFilter&,DataIPFilter*>(*(void *)(v6 + 152), (uint64_t)&v9);
    uint64_t v8 = v7 + 160;
    *(void *)(v6 + 152) = v7 + 160;
  }
  *(void *)(v6 + 152) = v8;
  if (BYTE8(v17) && (_BYTE)v16 && SHIBYTE(v15) < 0) {
    operator delete(__p[1]);
  }
  if (LOBYTE(__p[0]) && BYTE8(v12) && SBYTE7(v12) < 0) {
    operator delete(v11[0]);
  }
}

void sub_22252F0E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,char a32)
{
  uint64_t v34 = v32;
  *(void *)(v34 + 152) = v33;
  if (a32 && a29 && a28 < 0) {
    operator delete(__p);
  }
  if (a22 && a19 && a18 < 0) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void ___ZNK14QMIQOSClientIP27handleGlobalQosFlowInd_syncERKN3qos16GlobalQosFlowInd10IndicationE_block_invoke(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v4 + 112))
  {
    LOBYTE(v_Block_object_dispose(&a9, 8) = 0;
    BYTE4(v_Block_object_dispose(&a9, 8) = 0;
    BYTE8(v_Block_object_dispose(&a9, 8) = 0;
    BYTE12(v_Block_object_dispose(&a9, 8) = 0;
    LOBYTE(v9) = 0;
    BYTE4(v9) = 0;
    BYTE8(v9) = 0;
    LOBYTE(v11) = 0;
    std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS,void>(v4 + 56, (uint64_t)&v8);
    if ((_BYTE)v11)
    {
      long long v18 = (void **)&v9 + 1;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v18);
    }
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
    if (!*(unsigned char *)(v4 + 112)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
  }
  if (!*(unsigned char *)(v4 + 104))
  {
    long long v8 = 0uLL;
    *(void *)&long long v9 = 0;
    std::optional<std::vector<DataIPFilter>>::operator=[abi:ne180100]<std::vector<DataIPFilter>,void>(v4 + 80, (uint64_t)&v8);
    long long v18 = (void **)&v8;
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v18);
  }
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  *(_OWORD *)__n128 __p = 0u;
  *(_OWORD *)long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  QMIQOSClientIP::mav20FilterSpecToDict(a2, (uint64_t)&v8);
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v5 + 112) || !*(unsigned char *)(v5 + 104)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  unint64_t v6 = *(void *)(v5 + 88);
  if (v6 >= *(void *)(v5 + 96))
  {
    uint64_t v7 = std::vector<DataIPFilter>::__emplace_back_slow_path<DataIPFilter&>((uint64_t *)(v5 + 80), (uint64_t)&v8);
  }
  else
  {
    std::construct_at[abi:ne180100]<DataIPFilter,DataIPFilter&,DataIPFilter*>(*(void *)(v5 + 88), (uint64_t)&v8);
    uint64_t v7 = v6 + 160;
    *(void *)(v5 + 8_Block_object_dispose(&a9, 8) = v6 + 160;
  }
  *(void *)(v5 + 8_Block_object_dispose(&a9, 8) = v7;
  if (BYTE8(v16) && (_BYTE)v15 && SHIBYTE(v14) < 0) {
    operator delete(__p[1]);
  }
  if (LOBYTE(__p[0]) && BYTE8(v11) && SBYTE7(v11) < 0) {
    operator delete(v10[0]);
  }
}

void sub_22252F2C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,char a32)
{
  uint64_t v34 = v32;
  *(void *)(v34 + 8_Block_object_dispose(&a9, 8) = v33;
  if (a32 && a29 && a28 < 0) {
    operator delete(__p);
  }
  if (a22 && a19 && a18 < 0) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void ___ZNK14QMIQOSClientIP27handleGlobalQosFlowInd_syncERKN3qos16GlobalQosFlowInd10IndicationE_block_invoke_2(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v4 + 176))
  {
    LOBYTE(v_Block_object_dispose(&a9, 8) = 0;
    BYTE4(v_Block_object_dispose(&a9, 8) = 0;
    BYTE8(v_Block_object_dispose(&a9, 8) = 0;
    BYTE12(v_Block_object_dispose(&a9, 8) = 0;
    LOBYTE(v9) = 0;
    BYTE4(v9) = 0;
    BYTE8(v9) = 0;
    LOBYTE(v11) = 0;
    std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS,void>(v4 + 120, (uint64_t)&v8);
    if ((_BYTE)v11)
    {
      long long v18 = (void **)&v9 + 1;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v18);
    }
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
    if (!*(unsigned char *)(v4 + 176)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
  }
  if (!*(unsigned char *)(v4 + 168))
  {
    long long v8 = 0uLL;
    *(void *)&long long v9 = 0;
    std::optional<std::vector<DataIPFilter>>::operator=[abi:ne180100]<std::vector<DataIPFilter>,void>(v4 + 144, (uint64_t)&v8);
    long long v18 = (void **)&v8;
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v18);
  }
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  *(_OWORD *)__n128 __p = 0u;
  *(_OWORD *)long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  QMIQOSClientIP::mav20FilterSpecToDict(a2, (uint64_t)&v8);
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v5 + 176) || !*(unsigned char *)(v5 + 168)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  unint64_t v6 = *(void *)(v5 + 152);
  if (v6 >= *(void *)(v5 + 160))
  {
    uint64_t v7 = std::vector<DataIPFilter>::__emplace_back_slow_path<DataIPFilter&>((uint64_t *)(v5 + 144), (uint64_t)&v8);
  }
  else
  {
    std::construct_at[abi:ne180100]<DataIPFilter,DataIPFilter&,DataIPFilter*>(*(void *)(v5 + 152), (uint64_t)&v8);
    uint64_t v7 = v6 + 160;
    *(void *)(v5 + 152) = v6 + 160;
  }
  *(void *)(v5 + 152) = v7;
  if (BYTE8(v16) && (_BYTE)v15 && SHIBYTE(v14) < 0) {
    operator delete(__p[1]);
  }
  if (LOBYTE(__p[0]) && BYTE8(v11) && SBYTE7(v11) < 0) {
    operator delete(v10[0]);
  }
}

void sub_22252F4A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,char a32)
{
  uint64_t v34 = v32;
  *(void *)(v34 + 152) = v33;
  if (a32 && a29 && a28 < 0) {
    operator delete(__p);
  }
  if (a22 && a19 && a18 < 0) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::function<void ()(std::vector<unsigned int> const&,BOOL)>::operator()(uint64_t a1, uint64_t a2, char a3)
{
  char v4 = a3;
  if (!a1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)a1 + 48))(a1, a2, &v4);
}

void ___ZN14QMIQOSClientIP25queryCurrentQosFlows_syncENSt3__18functionIFvRKNS0_6vectorIjNS0_9allocatorIjEEEEbEEE_block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v3 + 108))
  {
    memset(__p, 0, 24);
    std::function<void ()(std::vector<unsigned int> const&,BOOL)>::operator()(*(void *)(a1 + 64), (uint64_t)__p, 0);
    char v4 = __p[0];
    if (__p[0])
    {
      __p[1] = __p[0];
LABEL_4:
      operator delete(v4);
    }
  }
  else if (*((_DWORD *)this + 1))
  {
    memset(__p, 0, 24);
    std::function<void ()(std::vector<unsigned int> const&,BOOL)>::operator()(*(void *)(a1 + 64), (uint64_t)__p, 0);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    unint64_t v6 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v14 = *((_DWORD *)this + 1);
      long long v15 = (void *)qmi::asString();
      LODWORD(__p[0]) = 136315650;
      *(void **)((char *)__p + 4) = "queryCurrentQosFlows_sync_block_invoke";
      WORD2(__p[1]) = 1024;
      *(_DWORD *)((char *)&__p[1] + 6) = v14;
      WORD1(__p[2]) = 2080;
      *(void **)((char *)&__p[2] + 4) = v15;
      _os_log_error_impl(&dword_22231A000, v6, OS_LOG_TYPE_ERROR, "%s: GetQosIds: Error in response with code = 0x%x (%s)", (uint8_t *)__p, 0x1Cu);
    }
  }
  else
  {
    __p[0] = 0;
    __p[1] = __p;
    __p[2] = (void *)0x4002000000;
    __p[3] = __Block_byref_object_copy__137;
    __p[4] = __Block_byref_object_dispose__138;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    v16[0] = MEMORY[0x263EF8330];
    v16[1] = 0x40000000;
    long long v17 = ___ZN14QMIQOSClientIP25queryCurrentQosFlows_syncENSt3__18functionIFvRKNS0_6vectorIjNS0_9allocatorIjEEEEbEEE_block_invoke_139;
    long long v18 = &unk_264612390;
    uint64_t v19 = __p;
    uint64_t v20 = v3;
    uint64_t TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue(this);
    long long v9 = TlvValue;
    if (TlvValue)
    {
      int v10 = v8;
      long long v21 = TlvValue;
      memset(&buf, 0, sizeof(buf));
      tlv::parseV<qos::tlv::QoSIdsList>(&v21, v8, &buf);
      long long v11 = v21;
      if (v21) {
        v17((uint64_t)v16, (uint64_t)&buf);
      }
      if (buf.__begin_)
      {
        buf.__end_ = buf.__begin_;
        operator delete(buf.__begin_);
      }
      if (!v11) {
        ((void (*)(void, uint64_t, unsigned __int8 *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)this, 16, v9, v10);
      }
    }
    long long v12 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = (uint64_t)(*((void *)__p[1] + 6) - *((void *)__p[1] + 5)) >> 2;
      LODWORD(buf.__begin_) = 136315394;
      *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = (std::vector<unsigned int>::pointer)"queryCurrentQosFlows_sync_block_invoke";
      WORD2(buf.__end_) = 2048;
      *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)v13;
      _os_log_impl(&dword_22231A000, v12, OS_LOG_TYPE_DEFAULT, "#I %s: GetQosIds: std::string::size_type size = %lu", (uint8_t *)&buf, 0x16u);
    }
    std::function<void ()(std::vector<unsigned int> const&,BOOL)>::operator()(*(void *)(a1 + 64), (uint64_t)__p[1] + 40, 1);
    _Block_object_dispose(__p, 8);
    char v4 = v23;
    if (v23)
    {
      uint64_t v24 = v23;
      goto LABEL_4;
    }
  }
}

void sub_22252F844(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  uint64_t v25 = *(void **)(v23 - 96);
  if (v25)
  {
    *(void *)(v23 - 8_Block_object_dispose(&a9, 8) = v25;
    operator delete(v25);
  }
  _Block_object_dispose(&a17, 8);
  if (__p)
  {
    a23 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__137(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 4_Block_object_dispose(&a9, 8) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__138(uint64_t a1)
{
  int v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = v2;
    operator delete(v2);
  }
}

void ___ZN14QMIQOSClientIP25queryCurrentQosFlows_syncENSt3__18functionIFvRKNS0_6vectorIjNS0_9allocatorIjEEEEbEEE_block_invoke_139(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD **)a2;
  uint64_t v3 = *(_DWORD **)(a2 + 8);
  if (*(_DWORD **)a2 != v3)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    do
    {
      unint64_t v6 = *(void **)(*(void *)(a1 + 32) + 8);
      uint64_t v7 = (char *)v6[6];
      unint64_t v8 = v6[7];
      if ((unint64_t)v7 >= v8)
      {
        int v10 = (char *)v6[5];
        uint64_t v11 = (v7 - v10) >> 2;
        if ((unint64_t)(v11 + 1) >> 62) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v12 = v8 - (void)v10;
        unint64_t v13 = (uint64_t)(v8 - (void)v10) >> 1;
        if (v13 <= v11 + 1) {
          unint64_t v13 = v11 + 1;
        }
        if (v12 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v13;
        }
        if (v14)
        {
          long long v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,4ul>>>((uint64_t)(v6 + 7), v14);
          int v10 = (char *)v6[5];
          uint64_t v7 = (char *)v6[6];
        }
        else
        {
          long long v15 = 0;
        }
        long long v16 = &v15[4 * v11];
        *(_DWORD *)long long v16 = *v2;
        long long v9 = v16 + 4;
        while (v7 != v10)
        {
          int v17 = *((_DWORD *)v7 - 1);
          v7 -= 4;
          *((_DWORD *)v16 - 1) = v17;
          v16 -= 4;
        }
        void v6[5] = v16;
        v6[6] = v9;
        v6[7] = &v15[4 * v14];
        if (v10) {
          operator delete(v10);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v7 = *v2;
        long long v9 = v7 + 4;
      }
      v6[6] = v9;
      long long v18 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = *v2;
        *(_DWORD *)std::vector<unsigned int> buf = 136315394;
        long long v21 = "queryCurrentQosFlows_sync_block_invoke";
        __int16 v22 = 2048;
        uint64_t v23 = v19;
        _os_log_impl(&dword_22231A000, v18, OS_LOG_TYPE_DEFAULT, "#I %s: GetQosIds: id = %lu", buf, 0x16u);
      }
      ++v2;
    }
    while (v2 != v3);
  }
}

uint64_t __copy_helper_block_e8_40c60_ZTSNSt3__18functionIFvRKNS_6vectorIjNS_9allocatorIjEEEEbEEE(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(std::vector<unsigned int> const&,BOOL)>::__value_func[abi:ne180100](a1 + 40, a2 + 40);
}

void *__destroy_helper_block_e8_40c60_ZTSNSt3__18functionIFvRKNS_6vectorIjNS_9allocatorIjEEEEbEEE(uint64_t a1)
{
  return std::__function::__value_func<void ()(std::vector<unsigned int> const&,BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 40));
}

uint64_t QMIQOSClientIP::requestQos(uint64_t a1, int a2, const __CFDictionary **a3)
{
  uint64_t v97 = *MEMORY[0x263EF8340];
  if (!*(void *)(a1 + 88) || !*(unsigned char *)(a1 + 109))
  {
    unint64_t v8 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      return 0;
    }
    LODWORD(aBlock) = 136315138;
    *(void *)((char *)&aBlock + 4) = "requestQos";
    long long v9 = "#I %s: QOS Client not ready yet";
LABEL_9:
    _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&aBlock, 0xCu);
    return 0;
  }
  CFDictionaryRef v4 = *a3;
  if (!*a3)
  {
    unint64_t v8 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      return 0;
    }
    LODWORD(aBlock) = 136315138;
    *(void *)((char *)&aBlock + 4) = "requestQos";
    long long v9 = "#I %s: Flow Dictionary not present";
    goto LABEL_9;
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v62 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  if (a2)
  {
    unint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = asString();
      *(_DWORD *)std::vector<unsigned int> buf = 136315394;
      *(void *)&uint8_t buf[4] = "getFlowProfile";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v7;
      _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Not supported QOS flow type %s", buf, 0x16u);
    }
  }
  else
  {
    *(void *)&long long v95 = 0;
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 120) + 88))(buf);
    ctu::cf::CFSharedRef<__CFDictionary const>::CFSharedRef<void const,void>(&v95, (CFTypeRef *)buf);
    ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef((const void **)buf);
    if ((void)v95) {
      int v10 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
    }
    else {
      int v10 = 0;
    }
    if (v10)
    {
      Value = (unsigned __int16 *)CFDictionaryGetValue((CFDictionaryRef)v95, @"ProfileID");
      unint64_t v12 = Value;
      *(_WORD *)std::vector<unsigned int> buf = 0;
      if (Value && (CFTypeID v13 = CFGetTypeID(Value), v13 == CFNumberGetTypeID()))
      {
        ctu::cf::assign((ctu::cf *)buf, v12, v14);
        int v15 = *(unsigned __int16 *)buf;
      }
      else
      {
        int v15 = 0;
      }
      long long v16 = (unsigned __int8 *)CFDictionaryGetValue((CFDictionaryRef)v95, @"FlowPriority");
      int v17 = v16;
      buf[0] = 0;
      if (v16 && (CFTypeID v18 = CFGetTypeID(v16), v18 == CFNumberGetTypeID()))
      {
        ctu::cf::assign((ctu::cf *)buf, v17, v19);
        int v20 = buf[0];
      }
      else
      {
        int v20 = 0;
      }
      long long v21 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::vector<unsigned int> buf = 136315650;
        *(void *)&uint8_t buf[4] = "getFlowProfile";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v15;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v20;
        _os_log_impl(&dword_22231A000, v21, OS_LOG_TYPE_DEFAULT, "#I %s: Audio QOS parameters found in CB: Profile ID = %d, Flow Priority = %d", buf, 0x18u);
      }
      ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)&v95);
      int v22 = *(_DWORD *)(a1 + 104);
      if (v22 == 2)
      {
        *(void *)std::vector<unsigned int> buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        long long v95 = 0uLL;
        CFDataRef v40 = (const __CFData *)CFDictionaryGetValue(v4, (const void *)*MEMORY[0x263F03720]);
        CFDataRef v41 = v40;
        if (v40)
        {
          CFTypeID v42 = CFGetTypeID(v40);
          if (v42 != CFDataGetTypeID()) {
            CFDataRef v41 = 0;
          }
        }
        CFDataRef v43 = (const __CFData *)CFDictionaryGetValue(v4, (const void *)*MEMORY[0x263F036E0]);
        CFDataRef v44 = v43;
        if (v43)
        {
          CFTypeID v45 = CFGetTypeID(v43);
          if (v45 != CFDataGetTypeID()) {
            CFDataRef v44 = 0;
          }
        }
        uint64_t v46 = (unsigned __int16 *)CFDictionaryGetValue(v4, (const void *)*MEMORY[0x263F03728]);
        uint64_t v47 = v46;
        if (v46)
        {
          CFTypeID v48 = CFGetTypeID(v46);
          if (v48 != CFNumberGetTypeID()) {
            uint64_t v47 = 0;
          }
        }
        long long v49 = (unsigned __int16 *)CFDictionaryGetValue(v4, (const void *)*MEMORY[0x263F036E8]);
        long long v51 = v49;
        if (v49)
        {
          CFTypeID v52 = CFGetTypeID(v49);
          if (v52 != CFNumberGetTypeID()) {
            long long v51 = 0;
          }
        }
        if (v41 && CFDataGetLength(v41) == 16)
        {
          *(_OWORD *)std::vector<unsigned int> buf = *(_OWORD *)CFDataGetBytePtr(v41);
          char v53 = 0x80;
        }
        else
        {
          char v53 = 0;
        }
        if (v44)
        {
          if (CFDataGetLength(v44) == 16)
          {
            long long v95 = *(_OWORD *)CFDataGetBytePtr(v44);
            LOBYTE(v44) = 0x80;
          }
          else
          {
            LOBYTE(v44) = 0;
          }
        }
        if (v47)
        {
          __int16 v78 = 0;
          ctu::cf::assign((ctu::cf *)&v78, v47, v50);
          LOWORD(v47) = v78;
        }
        if (v51)
        {
          __int16 v78 = 0;
          ctu::cf::assign((ctu::cf *)&v78, v51, v50);
          __int16 v58 = v78;
        }
        else
        {
          __int16 v58 = 0;
        }
        *(void *)&long long aBlock = MEMORY[0x263EF8330];
        *((void *)&aBlock + 1) = 0x40000000;
        uint64_t v80 = ___ZN14QMIQOSClientIP12QosDictToMsgE15DataQosFlowTypeRN3qos10RequestQos7RequestEPK14__CFDictionary_block_invoke_2;
        char v81 = &__block_descriptor_tmp_155_0;
        __int16 v82 = 0;
        __int16 v83 = v15;
        char v84 = v20;
        __int16 v85 = 1536;
        char v86 = 0;
        __int16 v87 = (__int16)v47;
        __int16 v88 = 0;
        __int16 v89 = v58;
        __int16 v90 = 0;
        long long v91 = *(_OWORD *)buf;
        char v92 = v53;
        long long v93 = v95;
        char v94 = (char)v44;
        operator new();
      }
      if (v22 == 1)
      {
        CFDataRef v23 = (const __CFData *)CFDictionaryGetValue(v4, (const void *)*MEMORY[0x263F03720]);
        CFDataRef v24 = v23;
        if (v23)
        {
          CFTypeID v25 = CFGetTypeID(v23);
          if (v25 != CFDataGetTypeID()) {
            CFDataRef v24 = 0;
          }
        }
        CFDataRef v26 = (const __CFData *)CFDictionaryGetValue(v4, (const void *)*MEMORY[0x263F036E0]);
        CFDataRef v27 = v26;
        if (v26)
        {
          CFTypeID v28 = CFGetTypeID(v26);
          if (v28 != CFDataGetTypeID()) {
            CFDataRef v27 = 0;
          }
        }
        long long v29 = (unsigned __int16 *)CFDictionaryGetValue(v4, (const void *)*MEMORY[0x263F03728]);
        long long v30 = v29;
        if (v29)
        {
          CFTypeID v31 = CFGetTypeID(v29);
          if (v31 != CFNumberGetTypeID()) {
            long long v30 = 0;
          }
        }
        uint64_t v32 = (unsigned __int16 *)CFDictionaryGetValue(v4, (const void *)*MEMORY[0x263F036E8]);
        uint64_t v34 = v32;
        if (v32)
        {
          CFTypeID v35 = CFGetTypeID(v32);
          if (v35 != CFNumberGetTypeID()) {
            uint64_t v34 = 0;
          }
        }
        if (v24 && CFDataGetLength(v24) == 4)
        {
          BytePtr = CFDataGetBytePtr(v24);
          HIDWORD(v37) = -1;
          LODWORD(v37) = *(_DWORD *)BytePtr;
        }
        else
        {
          uint64_t v37 = 0;
        }
        uint64_t v60 = v37;
        if (v27 && CFDataGetLength(v27) == 4)
        {
          BOOL v54 = CFDataGetBytePtr(v27);
          HIDWORD(v55) = -1;
          LODWORD(v55) = *(_DWORD *)v54;
        }
        else
        {
          uint64_t v55 = 0;
        }
        uint64_t v59 = v55;
        if (v30)
        {
          *(_WORD *)std::vector<unsigned int> buf = 0;
          ctu::cf::assign((ctu::cf *)buf, v30, v33);
          __int16 v56 = *(_WORD *)buf;
        }
        else
        {
          __int16 v56 = 0;
        }
        if (v34)
        {
          *(_WORD *)std::vector<unsigned int> buf = 0;
          ctu::cf::assign((ctu::cf *)buf, v34, v33);
          __int16 v57 = *(_WORD *)buf;
        }
        else
        {
          __int16 v57 = 0;
        }
        uint64_t v63 = MEMORY[0x263EF8330];
        uint64_t v64 = 0x40000000;
        long long v65 = ___ZN14QMIQOSClientIP12QosDictToMsgE15DataQosFlowTypeRN3qos10RequestQos7RequestEPK14__CFDictionary_block_invoke;
        long long v66 = &__block_descriptor_tmp_154_2;
        __int16 v67 = 0;
        __int16 v68 = v15;
        char v69 = v20;
        __int16 v70 = 1024;
        char v71 = 0;
        __int16 v72 = v56;
        __int16 v73 = 0;
        __int16 v74 = v57;
        __int16 v75 = 0;
        uint64_t v76 = v60;
        uint64_t v77 = v59;
        operator new();
      }
    }
    else
    {
      long long v38 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::vector<unsigned int> buf = 136315138;
        *(void *)&uint8_t buf[4] = "getFlowProfile";
        _os_log_impl(&dword_22231A000, v38, OS_LOG_TYPE_DEFAULT, "#I %s: Audio QOS parameters not found in CB", buf, 0xCu);
      }
      ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)&v95);
    }
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  return 0;
}

void sub_222530524(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN14QMIQOSClientIP10requestQosE15DataQosFlowTypeN3ctu2cf11CFSharedRefIK14__CFDictionaryEEj_block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 108))
  {
    int v5 = *((_DWORD *)a2 + 1);
    unint64_t v6 = *(NSObject **)(v2 + 40);
    if (v5)
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::vector<unsigned int> buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v5;
        *(_WORD *)&uint8_t buf[8] = 2080;
        *(void *)&buf[10] = qmi::asString();
        _os_log_error_impl(&dword_22231A000, v6, OS_LOG_TYPE_ERROR, "Error in response to RequestQos with code = 0x%x (%s)", buf, 0x12u);
      }
      (*(void (**)(void, void))(**(void **)(v2 + 64) + 48))(*(void *)(v2 + 64), *(unsigned int *)(a1 + 40));
    }
    else
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::vector<unsigned int> buf = 136315138;
        *(void *)&uint8_t buf[4] = "requestQos_block_invoke";
        _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Response to RequestQos received", buf, 0xCu);
      }
      *(void *)std::vector<unsigned int> buf = 0;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&uint8_t buf[16] = 0x2000000000;
      int v25 = 0;
      uint64_t v18 = 0;
      CFNumberRef v19 = &v18;
      uint64_t v20 = 0x2000000000;
      char v21 = 0;
      v13[0] = MEMORY[0x263EF8330];
      v13[1] = 0x40000000;
      uint64_t v14 = ___ZN14QMIQOSClientIP10requestQosE15DataQosFlowTypeN3ctu2cf11CFSharedRefIK14__CFDictionaryEEj_block_invoke_142;
      uint64_t v15 = &unk_2646123B8;
      uint64_t v16 = buf;
      uint64_t v17 = &v18;
      uint64_t TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
      long long v9 = TlvValue;
      if (TlvValue)
      {
        int v10 = v8;
        CFDataRef v23 = TlvValue;
        memset(&__p, 0, sizeof(__p));
        tlv::parseV<qos::tlv::IdentifierList>(&v23, v8, &__p);
        uint64_t v11 = v23;
        if (v23) {
          v14((uint64_t)v13, (uint64_t)&__p);
        }
        if (__p.__begin_)
        {
          __p.__end_ = __p.__begin_;
          operator delete(__p.__begin_);
        }
        if (!v11) {
          ((void (*)(void, uint64_t, unsigned __int8 *, void))*MEMORY[0x263F8BD78])(*(unsigned __int16 *)a2, 1, v9, v10);
        }
      }
      if (*((unsigned char *)v19 + 24))
      {
        (*(void (**)(void, void, void))(**(void **)(v2 + 64) + 40))(*(void *)(v2 + 64), *(unsigned int *)(a1 + 40), *(unsigned int *)(*(void *)&buf[8] + 24));
      }
      else
      {
        uint64_t v12 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p.__begin_) = 0;
          _os_log_error_impl(&dword_22231A000, v12, OS_LOG_TYPE_ERROR, "Error: Mandatory TLV fIdentifiers not present/valid", (uint8_t *)&__p, 2u);
        }
        (*(void (**)(void, void))(**(void **)(v2 + 64) + 48))(*(void *)(v2 + 64), *(unsigned int *)(a1 + 40));
      }
      _Block_object_dispose(&v18, 8);
      _Block_object_dispose(buf, 8);
    }
  }
}

void sub_222530890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (__p)
  {
    a20 = (uint64_t)__p;
    operator delete(__p);
  }
  _Block_object_dispose(&a15, 8);
  _Block_object_dispose(&a23, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14QMIQOSClientIP10requestQosE15DataQosFlowTypeN3ctu2cf11CFSharedRefIK14__CFDictionaryEEj_block_invoke_142(uint64_t result, uint64_t a2)
{
  if (*(void *)(a2 + 8) != *(void *)a2)
  {
    *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = **(_DWORD **)a2;
    *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = 1;
  }
  return result;
}

void QMIQOSClientIP::releaseQos(QMIQOSClientIP *this, int a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (*((void *)this + 11) && *((unsigned char *)this + 109))
  {
    long long v16 = 0u;
    *(_OWORD *)std::vector<unsigned int> __p = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 0x40000000;
    void v13[2] = ___ZN14QMIQOSClientIP10releaseQosEj_block_invoke;
    void v13[3] = &__block_descriptor_tmp_145_2;
    int v14 = a2;
    CFDictionaryRef v4 = (const void **)__p[1];
    if (__p[1] != (void *)v16)
    {
      while (*((unsigned char *)*v4 + 8) != 1)
      {
        if (++v4 == (const void **)v16) {
          goto LABEL_12;
        }
      }
    }
    if (v4 == (const void **)v16) {
LABEL_12:
    }
      operator new();
    if (!v6) {
      __cxa_bad_cast();
    }
    ___ZN14QMIQOSClientIP10releaseQosEj_block_invoke((uint64_t)v13, (uint64_t)v6 + 16);
    void v8[5] = (char *)this + 72;
    uint64_t v9 = QMIServiceMsg::create();
    int v10 = 25000;
    uint64_t v11 = 0;
    long long aBlock = 0;
    v8[0] = MEMORY[0x263EF8330];
    v8[1] = 0x40000000;
    _OWORD v8[2] = ___ZN14QMIQOSClientIP10releaseQosEj_block_invoke_2;
    v8[3] = &__block_descriptor_tmp_146_0;
    void v8[4] = this;
    *(void *)&long long buf = MEMORY[0x263EF8330];
    *((void *)&buf + 1) = 0x40000000;
    uint64_t v18 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos10ReleaseQos8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    CFNumberRef v19 = &unk_2646125E8;
    uint64_t v20 = v8;
    uint64_t v7 = _Block_copy(&buf);
    long long aBlock = v7;
    if (v9)
    {
      qmi::Client::send();
      uint64_t v7 = aBlock;
    }
    if (v7) {
      _Block_release(v7);
    }
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
  else
  {
    int v5 = *((void *)this + 5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "releaseQos";
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I %s: QOS Client not ready yet", (uint8_t *)&buf, 0xCu);
    }
  }
}

void sub_222530CBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZN14QMIQOSClientIP10releaseQosEj_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2 + 16;
  unint64_t v5 = *(void *)(a2 + 16);
  unint64_t v6 = *(_DWORD **)(a2 + 8);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = *(_DWORD **)a2;
    uint64_t v9 = ((uint64_t)v6 - *(void *)a2) >> 2;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,4ul>>>(v4, v12);
      uint64_t v8 = *(_DWORD **)a2;
      unint64_t v6 = *(_DWORD **)(a2 + 8);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[4 * v9];
    uint64_t v15 = &v13[4 * v12];
    *(_DWORD *)uint64_t v14 = *(_DWORD *)(a1 + 32);
    uint64_t v7 = v14 + 4;
    while (v6 != v8)
    {
      int v16 = *--v6;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(void *)a2 = v14;
    *(void *)(a2 + _Block_object_dispose(&a9, 8) = v7;
    *(void *)(a2 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    _DWORD *v6 = *(_DWORD *)(a1 + 32);
    uint64_t v7 = v6 + 1;
  }
  *(void *)(a2 + _Block_object_dispose(&a9, 8) = v7;
}

void ___ZN14QMIQOSClientIP10releaseQosEj_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 108))
  {
    int v3 = *(_DWORD *)(a2 + 4);
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (v3)
    {
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        v5[0] = 67109378;
        v5[1] = v3;
        __int16 v6 = 2080;
        uint64_t v7 = qmi::asString();
        _os_log_error_impl(&dword_22231A000, v4, OS_LOG_TYPE_ERROR, "Error in response to ReleaseQos with code = 0x%x (%s)", (uint8_t *)v5, 0x12u);
      }
    }
    else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v5[0]) = 0;
      _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Response to ReleaseQos received", (uint8_t *)v5, 2u);
    }
  }
}

__n128 ___ZN14QMIQOSClientIP12QosDictToMsgE15DataQosFlowTypeRN3qos10RequestQos7RequestEPK14__CFDictionary_block_invoke(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a1 + 32);
  long long v3 = *(_OWORD *)(a1 + 48);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  return result;
}

__n128 ___ZN14QMIQOSClientIP12QosDictToMsgE15DataQosFlowTypeRN3qos10RequestQos7RequestEPK14__CFDictionary_block_invoke_2(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a1 + 32);
  long long v3 = *(_OWORD *)(a1 + 48);
  long long v4 = *(_OWORD *)(a1 + 64);
  *(_WORD *)(a2 + 4_Block_object_dispose(&a9, 8) = *(_WORD *)(a1 + 80);
  *(_OWORD *)(a2 + 16) = v3;
  *(_OWORD *)(a2 + 32) = v4;
  *(__n128 *)a2 = result;
  return result;
}

uint64_t std::__optional_move_base<DataQoS,false>::__optional_move_base[abi:ne180100](uint64_t result, long long *a2)
{
  *(unsigned char *)__n128 result = 0;
  *(unsigned char *)(result + 56) = 0;
  if (*((unsigned char *)a2 + 56))
  {
    long long v2 = *a2;
    *(void *)(result + 13) = *(void *)((char *)a2 + 13);
    *(_OWORD *)__n128 result = v2;
    *(unsigned char *)(result + 24) = 0;
    *(unsigned char *)(result + 4_Block_object_dispose(&a9, 8) = 0;
    if (*((unsigned char *)a2 + 48))
    {
      *(void *)(result + 24) = 0;
      *(void *)(result + 32) = 0;
      *(void *)(result + 40) = 0;
      *(_OWORD *)(result + 24) = *(long long *)((char *)a2 + 24);
      *(void *)(result + 40) = *((void *)a2 + 5);
      *((void *)a2 + 3) = 0;
      *((void *)a2 + 4) = 0;
      *((void *)a2 + 5) = 0;
      *(unsigned char *)(result + 4_Block_object_dispose(&a9, 8) = 1;
    }
    *(unsigned char *)(result + 56) = 1;
  }
  return result;
}

void std::vector<DataIPFilter>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<DataIPFilter>::__base_destruct_at_end[abi:ne180100]((uint64_t)a1, *a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *std::vector<DataIPFilter>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x19999999999999ALL) {
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<DataIPFilter>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[160 * v4];
  return result;
}

void *std::vector<DataIPFilter>::__init_with_size[abi:ne180100]<DataIPFilter*,DataIPFilter*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    __int16 v6 = result;
    std::vector<DataIPFilter>::__vallocate[abi:ne180100](result, a4);
    __n128 result = (void *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<DataIPFilter>,DataIPFilter*,DataIPFilter*,DataIPFilter*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_222531064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + _Block_object_dispose(&a9, 8) = v10;
  std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::vector<DataIPFilter>::__emplace_back_slow_path<DataIPFilter&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 5);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x199999999999999) {
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0xCCCCCCCCCCCCCCLL) {
    unint64_t v9 = 0x199999999999999;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<DataIPFilter>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  uint64_t v14 = &v10[160 * v4];
  int v16 = &v10[160 * v9];
  std::construct_at[abi:ne180100]<DataIPFilter,DataIPFilter&,DataIPFilter*>((uint64_t)v14, a2);
  uint64_t v15 = v14 + 160;
  std::vector<DataIPFilter>::__swap_out_circular_buffer(a1, &v13);
  uint64_t v11 = a1[1];
  std::__split_buffer<DataIPFilter>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_222531178(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<DataIPFilter>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<qos::tlv::FlowInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  long long v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 352;
        std::__destroy_at[abi:ne180100]<qos::tlv::FlowInfo,0>(v4);
      }
      while ((void *)v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<qos::tlv::FlowInfo,0>(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 348)) {
    *(unsigned char *)(a1 + 34_Block_object_dispose(&a9, 8) = 0;
  }
  if (*(unsigned char *)(a1 + 346)) {
    *(unsigned char *)(a1 + 346) = 0;
  }
  if (*(unsigned char *)(a1 + 344)) {
    *(unsigned char *)(a1 + 344) = 0;
  }
  if (*(unsigned char *)(a1 + 208))
  {
    qos::tlv::FlowSpec::~FlowSpec((qos::tlv::FlowSpec *)(a1 + 216));
    *(unsigned char *)(a1 + 20_Block_object_dispose(&a9, 8) = 0;
  }
  if (*(unsigned char *)(a1 + 72))
  {
    qos::tlv::FlowSpec::~FlowSpec((qos::tlv::FlowSpec *)(a1 + 80));
    *(unsigned char *)(a1 + 72) = 0;
  }
  if (*(unsigned char *)(a1 + 40))
  {
    long long v2 = (void **)(a1 + 48);
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](&v2);
    *(unsigned char *)(a1 + 40) = 0;
  }
  if (*(unsigned char *)(a1 + 8))
  {
    long long v2 = (void **)(a1 + 16);
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](&v2);
    *(unsigned char *)(a1 + _Block_object_dispose(&a9, 8) = 0;
  }
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3qos9QosStatus10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::vector<unsigned int> __p = 0;
    __int16 v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      __int16 v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222531380(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3qos14EventReportInd10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::vector<unsigned int> __p = 0;
    __int16 v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      __int16 v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222531484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3qos16GlobalQosFlowInd10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::vector<unsigned int> __p = 0;
    __int16 v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      __int16 v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222531588(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::SubscriptionType>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::SubscriptionType>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<qos::tlv::SubscriptionType>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::SubscriptionType>::clone()
{
}

void std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0,std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0>,void ()(void)>::~__func()
{
}

void *std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0,std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D8378;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0,std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D8378;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0,std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0>,void ()(void)>::operator()(capabilities::ct *a1)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v1 = (void *)*((void *)a1 + 1);
  v17[1] = v1;
  _OWORD v17[2] = 0;
  v17[0] = &unk_26D4D83E8;
  uint64_t v18 = v17;
  if (capabilities::ct::supportsGemini(a1))
  {
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v15, (uint64_t)v17);
    if (v1[11])
    {
      uint64_t v2 = v1[8] + *(void *)(*(void *)v1[8] - 56);
      int v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24))(v2);
      subscriber::simSlotAsInstance();
      qmi::Client::set((qmi::Client *)(v1 + 9), (const char *)*MEMORY[0x263F8AFE0]);
      *(_OWORD *)std::vector<unsigned int> __p = 0u;
      long long v13 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
      if (v3 == 2) {
        int v4 = 2;
      }
      else {
        int v4 = 1;
      }
      uint64_t v5 = (const void **)__p[1];
      if (__p[1] != (void *)v13)
      {
        while (*((unsigned char *)*v5 + 8) != 1)
        {
          if (++v5 == (const void **)v13) {
            goto LABEL_19;
          }
        }
      }
      if (v5 == (const void **)v13) {
LABEL_19:
      }
        operator new();
      if (!v6) {
        __cxa_bad_cast();
      }
      v6[3] = v4;
      uint64_t v10 = QMIServiceMsg::create();
      *(void *)long long buf = MEMORY[0x263EF8330];
      uint64_t v20 = 1174405120;
      uint64_t v21 = ___ZN14QMIQOSClientIP21bindSubscription_syncENSt3__18functionIFvvEEE_block_invoke;
      int v22 = &__block_descriptor_tmp_76_9;
      CFDataRef v23 = v1;
      int v25 = v3;
      std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v24, (uint64_t)v15);
      aBlock[0] = MEMORY[0x263EF8330];
      aBlock[1] = 0x40000000;
      uint64_t aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_32;
      _DWORD aBlock[3] = &unk_2646124F8;
      aBlock[4] = buf;
      unint64_t v8 = _Block_copy(aBlock);
      uint64_t v11 = v8;
      if (v10)
      {
        qmi::Client::send();
        unint64_t v8 = v11;
      }
      if (v8) {
        _Block_release(v8);
      }
      std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v24);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
    }
    else
    {
      uint64_t v7 = v1[5];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl(&dword_22231A000, v7, OS_LOG_TYPE_ERROR, "bindSubscription after client is deleted", buf, 2u);
      }
      if (!v16) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      (*(void (**)(uint64_t))(*(void *)v16 + 48))(v16);
    }
    std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v15);
  }
  else
  {
    if (!v18) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(void *))(*v18 + 48))(v18);
  }
  return std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v17);
}

void sub_222531BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v29);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a10);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](&a25);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](&a29);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0,std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0,std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0>,void ()(void)>::target_type()
{
}

void std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::~__func()
{
}

void *std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D83E8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D83E8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(void *)(v1 + 88))
  {
    memset(v35, 0, sizeof(v35));
    uint64_t v2 = qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v35);
    int v3 = *(_DWORD *)(v1 + 104);
    if (v3 == 2)
    {
      int v4 = qmi::MutableMessageBase::getTLV<qos::tlv::IpFamilyPref>(v2);
      char v5 = 6;
    }
    else
    {
      if (v3 != 1)
      {
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136315650;
          *(void *)&uint8_t buf[4] = "wrong ip family";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CommCenter/CommCenterCommandDrivers/"
                                "Data/QMI/Context/QMIQOSClientIP.cpp";
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v37) = 324;
          _os_log_error_impl(&dword_22231A000, &_os_log_internal, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT fIpFamilyType == kDataProtocolFamilyIPv4 || fIpFamilyType == kDataProtocolFamilyIPv6\n %s\n at %s:%d\n**********", buf, 0x1Cu);
          int v3 = *(_DWORD *)(v1 + 104);
        }
        if ((v3 - 1) >= 2) {
          __TUAssertTrigger();
        }
LABEL_68:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v35);
        return;
      }
      int v4 = qmi::MutableMessageBase::getTLV<qos::tlv::IpFamilyPref>(v2);
      char v5 = 4;
    }
    char *v4 = v5;
    uint64_t v30 = v1 + 72;
    uint64_t v31 = QMIServiceMsg::create();
    int v32 = 25000;
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    v29[0] = MEMORY[0x263EF8330];
    v29[1] = 0x40000000;
    std::string v29[2] = ___ZN14QMIQOSClientIP14setupQMIClientEv_block_invoke_97;
    v29[3] = &__block_descriptor_tmp_98_4;
    void v29[4] = v1;
    *(void *)long long buf = MEMORY[0x263EF8330];
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_32;
    uint64_t v37 = &unk_2646124F8;
    long long v38 = v29;
    uint64_t v7 = _Block_copy(buf);
    uint64_t v34 = v7;
    if (v31)
    {
      qmi::Client::send();
      uint64_t v7 = v34;
    }
    if (v7) {
      _Block_release(v7);
    }
    long long v28 = 0u;
    *(_OWORD *)std::vector<unsigned int> __p = 0u;
    unint64_t v8 = (capabilities::ct *)qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    if (capabilities::ct::supportsDataQMIExtensions(v8))
    {
      unint64_t v9 = (const void **)v28;
    }
    else
    {
      uint64_t v10 = (const void **)__p[1];
      unint64_t v9 = (const void **)v28;
      if (__p[1] != (void *)v28)
      {
        while (*((unsigned char *)*v10 + 8) != 16)
        {
          if (++v10 == (const void **)v28) {
            goto LABEL_25;
          }
        }
      }
      if (v10 == (const void **)v28) {
LABEL_25:
      }
        operator new();
      if (!v11) {
        goto LABEL_70;
      }
      v11[9] = 1;
    }
    for (uint64_t i = (const void **)__p[1]; ; ++i)
    {
      if (i == v9) {
        goto LABEL_33;
      }
      if (*((unsigned char *)*i + 8) == 17) {
        break;
      }
    }
    if (i == v9) {
LABEL_33:
    }
      operator new();
    if (v13)
    {
      v13[10] = 1;
      *((_WORD *)v13 + 6) = -32764;
      uint64_t v30 = v1 + 72;
      uint64_t v31 = QMIServiceMsg::create();
      int v32 = 25000;
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      v26[0] = MEMORY[0x263EF8330];
      v26[1] = 0x40000000;
      v26[2] = ___ZN14QMIQOSClientIP14setupQMIClientEv_block_invoke_3;
      v26[3] = &__block_descriptor_tmp_109_0;
      void v26[4] = v1;
      *(void *)long long buf = MEMORY[0x263EF8330];
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos14SetEventReport8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
      uint64_t v37 = &unk_264612548;
      long long v38 = v26;
      uint64_t v14 = _Block_copy(buf);
      uint64_t v34 = v14;
      if (v31)
      {
        qmi::Client::send();
        uint64_t v14 = v34;
      }
      if (v14) {
        _Block_release(v14);
      }
      if (capabilities::ct::supportsDataQMIExtensions((capabilities::ct *)v14))
      {
        *(_OWORD *)CFDataRef v24 = 0u;
        long long v25 = 0u;
        qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v24);
        uint64_t v15 = (const void **)v24[1];
        uint64_t v16 = (const void **)v25;
        uint64_t v17 = (const void **)v24[1];
        if (v24[1] != (void *)v25)
        {
          uint64_t v17 = (const void **)v24[1];
          while (*((unsigned char *)*v17 + 8) != 16)
          {
            if (++v17 == (const void **)v25) {
              goto LABEL_47;
            }
          }
        }
        if (v17 == (const void **)v25) {
LABEL_47:
        }
          operator new();
        if (!v18) {
          goto LABEL_71;
        }
        v18[9] = 1;
        while (1)
        {
          if (v15 == v16) {
            goto LABEL_54;
          }
          if (*((unsigned char *)*v15 + 8) == 17) {
            break;
          }
          ++v15;
        }
        if (v15 == v16) {
LABEL_54:
        }
          operator new();
        if (!v19) {
          goto LABEL_71;
        }
        v19[9] = 1;
        for (j = (const void **)v24[1]; ; ++j)
        {
          if (j == v16) {
            goto LABEL_61;
          }
          if (*((unsigned char *)*j + 8) == 18) {
            break;
          }
        }
        if (j == v16) {
LABEL_61:
        }
          operator new();
        if (!v21) {
LABEL_71:
        }
          __cxa_bad_cast();
        v21[9] = 1;
        uint64_t v30 = v1 + 72;
        uint64_t v31 = QMIServiceMsg::create();
        int v32 = 25000;
        uint64_t v33 = 0;
        uint64_t v34 = 0;
        v23[0] = MEMORY[0x263EF8330];
        v23[1] = 0x40000000;
        void v23[2] = ___ZN14QMIQOSClientIP14setupQMIClientEv_block_invoke_4;
        v23[3] = &__block_descriptor_tmp_125_0;
        uint8_t v23[4] = v1;
        *(void *)long long buf = MEMORY[0x263EF8330];
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos18IndicationRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
        uint64_t v37 = &unk_264612570;
        long long v38 = v23;
        int v22 = _Block_copy(buf);
        uint64_t v34 = v22;
        if (v31)
        {
          qmi::Client::send();
          int v22 = v34;
        }
        if (v22) {
          _Block_release(v22);
        }
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v24);
      }
      *(unsigned char *)(v1 + 109) = 1;
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
      goto LABEL_68;
    }
LABEL_70:
    __cxa_bad_cast();
  }
  __int16 v6 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl(&dword_22231A000, v6, OS_LOG_TYPE_ERROR, "setupQMIClient after client is deleted", buf, 2u);
  }
}

void sub_2225328D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  uint64_t v20 = va_arg(va1, void);
  if (*(void *)(v7 - 176)) {
    qmi::Client::send();
  }
  unint64_t v9 = *(const void **)(v7 - 152);
  if (v9) {
    _Block_release(v9);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v7 - 144));
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::target_type()
{
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::DataPort>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::DataPort>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<qos::tlv::DataPort>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::DataPort>::clone()
{
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos12BindDataPort8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::vector<unsigned int> __p = 0;
    __int16 v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      __int16 v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222532BB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::MuxId>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::MuxId>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<qos::tlv::MuxId>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::MuxId>::clone()
{
}

char *qmi::MutableMessageBase::getTLV<qos::tlv::IpFamilyPref>(uint64_t a1)
{
  uint64_t v1 = *(const void ***)(a1 + 8);
  uint64_t v2 = *(const void ***)(a1 + 16);
  if (v1 != v2)
  {
    while (*((unsigned char *)*v1 + 8) != 1)
    {
      if (++v1 == v2) {
        goto LABEL_8;
      }
    }
  }
  if (v1 == v2) {
LABEL_8:
  }
    operator new();
  if (!v3) {
    __cxa_bad_cast();
  }
  return v3 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::IpFamilyPref>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::IpFamilyPref>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<qos::tlv::IpFamilyPref>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::IpFamilyPref>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::GlobalFlowReporting>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::GlobalFlowReporting>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<qos::tlv::GlobalFlowReporting>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::GlobalFlowReporting>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::NetworkProfileChange>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::NetworkProfileChange>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMnc>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<qos::tlv::NetworkProfileChange>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = *a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<qos::tlv::NetworkProfileChange>(a2, a1 + 10);
  uint64_t v7 = *a2 - v5;
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::NetworkProfileChange>::clone()
{
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos14SetEventReport8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::vector<unsigned int> __p = 0;
    __int16 v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      __int16 v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2225331C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::ReportGlobalQosFlows>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::ReportGlobalQosFlows>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<qos::tlv::ReportGlobalQosFlows>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::ReportGlobalQosFlows>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressFlowControlReport>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressFlowControlReport>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressFlowControlReport>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressFlowControlReport>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressNetworkStatusInd>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressNetworkStatusInd>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressNetworkStatusInd>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<wds::tlv::LocalAbort>((unsigned char **)a2, (unsigned char *)(a1 + 9));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressNetworkStatusInd>::clone()
{
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos18IndicationRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::vector<unsigned int> __p = 0;
    __int16 v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      __int16 v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222533550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t qos::tlv::FlowInfo::FlowInfo(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + _Block_object_dispose(&a9, 8) = 0;
  if (*(unsigned char *)(a2 + 8))
  {
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(unsigned char *)(a1 + _Block_object_dispose(&a9, 8) = 1;
  }
  *(unsigned char *)(a1 + 40) = 0;
  if (*(unsigned char *)(a2 + 40))
  {
    *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = 0;
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
    *(_OWORD *)(a1 + 4_Block_object_dispose(&a9, 8) = *(_OWORD *)(a2 + 48);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
    *(void *)(a2 + 4_Block_object_dispose(&a9, 8) = 0;
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 64) = 0;
    *(unsigned char *)(a1 + 40) = 1;
  }
  *(unsigned char *)(a1 + 72) = 0;
  if (*(unsigned char *)(a2 + 72))
  {
    qos::tlv::FlowSpec::FlowSpec(a1 + 80, a2 + 80);
    *(unsigned char *)(a1 + 72) = 1;
  }
  *(unsigned char *)(a1 + 20_Block_object_dispose(&a9, 8) = 0;
  if (*(unsigned char *)(a2 + 208))
  {
    qos::tlv::FlowSpec::FlowSpec(a1 + 216, a2 + 216);
    *(unsigned char *)(a1 + 20_Block_object_dispose(&a9, 8) = 1;
  }
  *(unsigned char *)(a1 + 344) = 0;
  if (*(unsigned char *)(a2 + 344))
  {
    *(unsigned char *)(a1 + 345) = *(unsigned char *)(a2 + 345);
    *(unsigned char *)(a1 + 344) = 1;
  }
  *(unsigned char *)(a1 + 346) = 0;
  if (*(unsigned char *)(a2 + 346))
  {
    *(unsigned char *)(a1 + 347) = *(unsigned char *)(a2 + 347);
    *(unsigned char *)(a1 + 346) = 1;
  }
  *(unsigned char *)(a1 + 34_Block_object_dispose(&a9, 8) = 0;
  if (*(unsigned char *)(a2 + 348))
  {
    *(_WORD *)(a1 + 350) = *(_WORD *)(a2 + 350);
    *(unsigned char *)(a1 + 34_Block_object_dispose(&a9, 8) = 1;
  }
  return a1;
}

uint64_t qos::tlv::FlowSpec::FlowSpec(uint64_t result, uint64_t a2)
{
  *(unsigned char *)__n128 result = 0;
  if (*(unsigned char *)a2)
  {
    *(unsigned char *)(result + 1) = *(unsigned char *)(a2 + 1);
    *(unsigned char *)__n128 result = 1;
  }
  *(unsigned char *)(result + 4) = 0;
  if (*(unsigned char *)(a2 + 4))
  {
    uint64_t v2 = *(void *)(a2 + 8);
    *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
    *(void *)(result + _Block_object_dispose(&a9, 8) = v2;
    *(unsigned char *)(result + 4) = 1;
  }
  *(unsigned char *)(result + 20) = 0;
  if (*(unsigned char *)(a2 + 20))
  {
    *(void *)(result + 24) = *(void *)(a2 + 24);
    *(unsigned char *)(result + 20) = 1;
  }
  *(unsigned char *)(result + 32) = 0;
  if (*(unsigned char *)(a2 + 32))
  {
    *(void *)(result + 40) = 0;
    *(void *)(result + 4_Block_object_dispose(&a9, 8) = 0;
    *(void *)(result + 56) = 0;
    *(_OWORD *)(result + 40) = *(_OWORD *)(a2 + 40);
    *(void *)(result + 56) = *(void *)(a2 + 56);
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 4_Block_object_dispose(&a9, 8) = 0;
    *(void *)(a2 + 56) = 0;
    *(unsigned char *)(result + 32) = 1;
  }
  *(unsigned char *)(result + 64) = 0;
  if (*(unsigned char *)(a2 + 64))
  {
    *(_DWORD *)(result + 6_Block_object_dispose(&a9, 8) = *(_DWORD *)(a2 + 68);
    *(unsigned char *)(result + 64) = 1;
  }
  *(unsigned char *)(result + 72) = 0;
  if (*(unsigned char *)(a2 + 72))
  {
    *(_DWORD *)(result + 76) = *(_DWORD *)(a2 + 76);
    *(unsigned char *)(result + 72) = 1;
  }
  *(unsigned char *)(result + 80) = 0;
  if (*(unsigned char *)(a2 + 80))
  {
    *(_DWORD *)(result + 82) = *(_DWORD *)(a2 + 82);
    *(unsigned char *)(result + 80) = 1;
  }
  *(unsigned char *)(result + 8_Block_object_dispose(&a9, 8) = 0;
  if (*(unsigned char *)(a2 + 88))
  {
    *(_DWORD *)(result + 92) = *(_DWORD *)(a2 + 92);
    *(unsigned char *)(result + 8_Block_object_dispose(&a9, 8) = 1;
  }
  *(unsigned char *)(result + 96) = 0;
  if (*(unsigned char *)(a2 + 96))
  {
    *(_DWORD *)(result + 100) = *(_DWORD *)(a2 + 100);
    *(unsigned char *)(result + 96) = 1;
  }
  *(unsigned char *)(result + 104) = 0;
  if (*(unsigned char *)(a2 + 104))
  {
    *(unsigned char *)(result + 105) = *(unsigned char *)(a2 + 105);
    *(unsigned char *)(result + 104) = 1;
  }
  *(unsigned char *)(result + 106) = 0;
  if (*(unsigned char *)(a2 + 106))
  {
    *(unsigned char *)(result + 107) = *(unsigned char *)(a2 + 107);
    *(unsigned char *)(result + 106) = 1;
  }
  *(unsigned char *)(result + 10_Block_object_dispose(&a9, 8) = 0;
  if (*(unsigned char *)(a2 + 108))
  {
    *(_WORD *)(result + 110) = *(_WORD *)(a2 + 110);
    *(unsigned char *)(result + 10_Block_object_dispose(&a9, 8) = 1;
  }
  *(unsigned char *)(result + 112) = 0;
  if (*(unsigned char *)(a2 + 112))
  {
    *(unsigned char *)(result + 113) = *(unsigned char *)(a2 + 113);
    *(unsigned char *)(result + 112) = 1;
  }
  *(unsigned char *)(result + 114) = 0;
  if (*(unsigned char *)(a2 + 114))
  {
    *(unsigned char *)(result + 115) = *(unsigned char *)(a2 + 115);
    *(unsigned char *)(result + 114) = 1;
  }
  *(unsigned char *)(result + 116) = 0;
  if (*(unsigned char *)(a2 + 116))
  {
    *(unsigned char *)(result + 117) = *(unsigned char *)(a2 + 117);
    *(unsigned char *)(result + 116) = 1;
  }
  *(unsigned char *)(result + 11_Block_object_dispose(&a9, 8) = 0;
  if (*(unsigned char *)(a2 + 118))
  {
    *(unsigned char *)(result + 119) = *(unsigned char *)(a2 + 119);
    *(unsigned char *)(result + 11_Block_object_dispose(&a9, 8) = 1;
  }
  *(unsigned char *)(result + 120) = 0;
  if (*(unsigned char *)(a2 + 120))
  {
    *(unsigned char *)(result + 121) = *(unsigned char *)(a2 + 121);
    *(unsigned char *)(result + 120) = 1;
  }
  return result;
}

void *std::__function::__value_func<void ()(std::vector<unsigned int> const&,BOOL)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<void ()(std::vector<unsigned int> const&,BOOL)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos9GetQosIds8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::vector<unsigned int> __p = 0;
    __int16 v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      __int16 v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222533A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void std::__function::__func<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0,std::allocator<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0>,void ()(std::vector<unsigned int> const&,BOOL)>::~__func()
{
}

void *std::__function::__func<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0,std::allocator<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0>,void ()(std::vector<unsigned int> const&,BOOL)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26D4D86F8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0,std::allocator<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0>,void ()(std::vector<unsigned int> const&,BOOL)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4D86F8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0,std::allocator<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0>,void ()(std::vector<unsigned int> const&,BOOL)>::operator()(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 8);
  if (*a3)
  {
    uint64_t v4 = *(void (**)(void))(**(void **)(v3 + 64) + 96);
    v4();
  }
  else
  {
    uint64_t v5 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136315138;
      uint64_t v7 = "operator()";
      _os_log_impl(&dword_22231A000, v5, OS_LOG_TYPE_DEFAULT, "#I %s: GetQosIds: cannot update current QoSFlows", (uint8_t *)&v6, 0xCu);
    }
  }
}

uint64_t std::__function::__func<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0,std::allocator<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0>,void ()(std::vector<unsigned int> const&,BOOL)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0,std::allocator<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0>,void ()(std::vector<unsigned int> const&,BOOL)>::target_type()
{
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos10RequestQos8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::vector<unsigned int> __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222533D8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void *qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosIdentifierList>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4D87A0;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosIdentifierList>::~TlvWrapper(void *a1)
{
  *a1 = &unk_26D4D87A0;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x223C9A950);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosIdentifierList>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::DestPortRangeList>((void *)(a1 + 16));
}

unsigned char **qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosIdentifierList>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  __n128 result = tlv::writeV<qos::tlv::QosIdentifierList>((unsigned char **)a2, (_DWORD *)(a1 + 16));
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosIdentifierList>::clone()
{
}

void sub_222533F6C(_Unwind_Exception *a1)
{
  MEMORY[0x223C9A950](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos10ReleaseQos8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::vector<unsigned int> __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_222534054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV4>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV4>::getSize()
{
  return tlv::size<qos::tlv::QosSpecV4>();
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV4>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = *a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<qos::tlv::QosSpecV4>(a2, a1 + 12);
  uint64_t v7 = *a2 - v5;
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV4>::clone()
{
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV6>::~TlvWrapper()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV6>::getSize()
{
  return tlv::size<qos::tlv::QosSpecV6>();
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV6>::write(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = *a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = tlv::writeV<qos::tlv::QosSpecV6>(a2, a1 + 10);
  uint64_t v7 = *a2 - v5;
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV6>::clone()
{
}

void MCommandDriversFactory::create(void *a1@<X8>)
{
  char v3 = (char *)operator new(0x40uLL);
  *((void *)v3 + 1) = 0;
  *((void *)v3 + 2) = 0;
  *(void *)char v3 = &unk_26D4D89D0;
  *(_OWORD *)(v3 + 24) = 0u;
  uint64_t v4 = v3 + 24;
  *(_OWORD *)(v3 + 40) = 0u;
  *((void *)v3 + 7) = 0;
  CommandDriversFactory::CommandDriversFactory((CommandDriversFactory *)(v3 + 24));
  *((void *)v3 + 3) = &unk_26D4D8878;
  uint64_t v5 = (std::__shared_weak_count *)*((void *)v3 + 5);
  if (!v5)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v3 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v3 + 2, 1uLL, memory_order_relaxed);
    *((void *)v3 + 4) = v4;
    *((void *)v3 + 5) = v3;
    goto LABEL_5;
  }
  if (v5->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v3 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v3 + 2, 1uLL, memory_order_relaxed);
    *((void *)v3 + 4) = v4;
    *((void *)v3 + 5) = v3;
    std::__shared_weak_count::__release_weak(v5);
LABEL_5:
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v3);
  }
  *a1 = v4;
  a1[1] = v3;
}

void sub_222534358(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

uint64_t MCommandDriversFactory::init(uint64_t a1, void *a2)
{
  CommandDriversFactory::init();
  if (*a2)
  {
    v6[0] = 0;
    v6[1] = 0;
    uint64_t v4 = a2[1];
    if (v4) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    }
    QMIClientPool::create(v6);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 296))(a1);
}

void sub_222534A58(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,void *>>>::operator()[abi:ne180100](1, v12);
  __clang_call_terminate(a1);
}

void sub_222534A8C()
{
  if (v0) {
    JUMPOUT(0x222534AA8);
  }
  JUMPOUT(0x222534AACLL);
}

void MCommandDriversFactory::~MCommandDriversFactory(MCommandDriversFactory *this)
{
  CommandDriversFactory::~CommandDriversFactory(this);

  JUMPOUT(0x223C9A950);
}

uint64_t MCommandDriversFactory::setupQmiExceptionHandlers(MCommandDriversFactory *this, BOOL (*a2)(unsigned __int16, unsigned __int16, const unsigned __int8 *, unint64_t))
{
}

uint64_t anonymous namespace'::ChangeQMIParserErrorToCSIAssert(_anonymous_namespace_ *this, int a2, unsigned __int16 a3, const unsigned __int8 *a4)
{
  int v4 = (int)a4;
  int v6 = (int)this;
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    v8[0] = 67109632;
    v8[1] = v6;
    __int16 v9 = 1024;
    int v10 = a2;
    __int16 v11 = 1024;
    int v12 = v4;
    _os_log_error_impl(&dword_22231A000, &_os_log_internal, OS_LOG_TYPE_ERROR, "CSI ASSERT: QMI parsing error in message with msgId=0x%04x during tlvId=0x%02x (tlv_len=%u)", (uint8_t *)v8, 0x14u);
  }
  __TUAssertTrigger();
  return 0;
}

uint64_t anonymous namespace'::ChangeQMIWriteErrorToCSIAssert(int a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    int v7 = a2[2] - *a2;
    v8[0] = 67109632;
    v8[1] = a1;
    __int16 v9 = 2048;
    uint64_t v10 = a3;
    __int16 v11 = 1024;
    int v12 = v7;
    _os_log_error_impl(&dword_22231A000, &_os_log_internal, OS_LOG_TYPE_ERROR, "CSI ASSERT: QMI serialization error in message with msgId=0x%04x (%td bytes written to buf of size %u bytes)", (uint8_t *)v8, 0x18u);
  }
  return __TUAssertTrigger();
}

void MCommandDriversFactory::createSimCommandDriver(uint64_t a1, dispatch_object_t *a2)
{
  char v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3) {
    std::__shared_weak_count::lock(v3);
  }
  if (*a2) {
    dispatch_retain(*a2);
  }
  subscriber::EURSimCommandDriver::create();
}

void sub_222534D84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createEosCommandDriver(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v8 = 0;
  __int16 v9 = 0;
  int v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6)
  {
    __int16 v9 = std::__shared_weak_count::lock(v6);
    if (v9) {
      uint64_t v8 = *(void *)(a1 + 24);
    }
  }
  xpc_object_t object = *a2;
  if (*a2) {
    dispatch_retain(*a2);
  }
  QmiEosCommandDriver::create((capabilities::euicc *)&v8, a3);
  if (object) {
    dispatch_release(object);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
}

void sub_222534E38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createSignalStrengthCommandDriver(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5 || (int v7 = std::__shared_weak_count::lock(v5), (v14 = v7) == 0) || (v13 = *(void *)(a1 + 24)) == 0)
  {
LABEL_11:
    int v9 = 1;
    goto LABEL_12;
  }
  int SignalStrengthPersonality = capabilities::ct::getSignalStrengthPersonality((capabilities::ct *)v7);
  if (SignalStrengthPersonality != 1)
  {
    if (SignalStrengthPersonality == 2)
    {
      if (*a2) {
        dispatch_retain(*a2);
      }
      Mav20SignalStrengthCommandDriver::create(&v12);
    }
    goto LABEL_11;
  }
  uint64_t v10 = *a2;
  __int16 v11 = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  Mav7SignalStrengthCommandDriver::create(&v13, &v11, (std::__shared_weak_count **)&v12);
  *(_OWORD *)a3 = v12;
  if (v11) {
    dispatch_release(v11);
  }
  int v9 = 0;
LABEL_12:
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  if (v9)
  {
    *(void *)a3 = 0;
    *(void *)(a3 + _Block_object_dispose(&a9, 8) = 0;
  }
}

void sub_222534F58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (object) {
    dispatch_release(object);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createDMSCommandDriver(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, void *a3@<X8>)
{
  int v7 = 0;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    int v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        if (*a2) {
          dispatch_retain(*a2);
        }
        QMIDMSCommandDriver::create();
      }
    }
  }
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_22253503C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createPhonebookCommandDriver(uint64_t a1, dispatch_object_t *a2)
{
  char v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3) {
    std::__shared_weak_count::lock(v3);
  }
  if (*a2) {
    dispatch_retain(*a2);
  }
  QMIPhonebookCommandDriver::create();
}

void sub_2225350FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createAwdCommandDriver(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  int v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    uint64_t v8 = v5;
    if (v5)
    {
      uint64_t v7 = *(void *)(a1 + 24);
      if (v7)
      {
        if (capabilities::radio::supportsMultiClientAWD((capabilities::radio *)v5)) {
          awd::QMIMav20AwdCommandDriver::create();
        }
        awd::QMIAwdCommandDriver::create(&v6);
      }
    }
  }
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_2225351D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createActivationCommandDriver(uint64_t a1, NSObject **a2)
{
  char v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3) {
    std::__shared_weak_count::lock(v3);
  }
  int v4 = *a2;
  if (v4) {
    dispatch_retain(v4);
  }
  QMIActivationCommandDriver::create();
}

void sub_22253528C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (v12) {
    dispatch_release(v12);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createDesenseCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, void *a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    uint64_t v7 = (capabilities::ct *)std::__shared_weak_count::lock(v5);
    uint64_t v10 = (std::__shared_weak_count *)v7;
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        if (capabilities::ct::supports5G(v7))
        {
          uint64_t v8 = *a2;
          if (v8) {
            dispatch_retain(v8);
          }
          Mav20QMIDesenseCommandDriver::create();
        }
        int v9 = *a2;
        if (v9) {
          dispatch_retain(v9);
        }
        QMIDesenseCommandDriver::create();
      }
    }
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_222535398(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v14) {
    dispatch_release(v14);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createAQMCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        uint64_t v8 = *a2;
        if (v8) {
          dispatch_retain(v8);
        }
        QMIAQMCommandDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_222535474(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v14) {
    dispatch_release(v14);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createDormancyCommandDriver(uint64_t a1, NSObject **a2)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4) {
    std::__shared_weak_count::lock(v4);
  }
  uint64_t v5 = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  long long v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      dormancy::QMIDormancyCommandDriver::create(&v7);
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void sub_222535578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  if (v14) {
    dispatch_release(v14);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createAttachApnCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v8 = *a2;
        if (v8) {
          dispatch_retain(v8);
        }
        QMIAttachApnCommandDriverFactory::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_22253566C(_Unwind_Exception *a1)
{
  if (v2) {
    dispatch_release(v2);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createP2PCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v8 = *a2;
        if (v8) {
          dispatch_retain(v8);
        }
        QMIP2PCommandDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_222535754(_Unwind_Exception *a1)
{
  if (v2) {
    dispatch_release(v2);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createDataFactoryCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v8 = *a2;
        if (v8) {
          dispatch_retain(v8);
        }
        QMIDataFactoryCommandDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_22253583C(_Unwind_Exception *a1)
{
  if (v2) {
    dispatch_release(v2);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createCellMonitorCommandDriver(uint64_t a1, NSObject **a2)
{
  char v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3) {
    std::__shared_weak_count::lock(v3);
  }
  int v4 = *a2;
  if (v4) {
    dispatch_retain(v4);
  }
  QMICellMonitorCommandDriver::create();
}

void sub_2225358F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (v12) {
    dispatch_release(v12);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createEnhancedLQMCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        uint64_t v8 = *a2;
        if (v8) {
          dispatch_retain(v8);
        }
        QMIEnhancedLQMCommandDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_2225359C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v14) {
    dispatch_release(v14);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createAudioRoutingCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        uint64_t v8 = *a2;
        if (v8) {
          dispatch_retain(v8);
        }
        QMIAudioRoutingCommandDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_222535A98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v14) {
    dispatch_release(v14);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createAudioCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v8 = *a2;
        if (v8) {
          dispatch_retain(v8);
        }
        QMIAudioCommandDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_222535B7C(_Unwind_Exception *a1)
{
  if (v2) {
    dispatch_release(v2);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createCallAudioCommandDriver(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, void *a3@<X2>, void *a4@<X3>, void *a5@<X8>)
{
  long long v7 = *(std::__shared_weak_count **)(a1 + 32);
  if (v7)
  {
    __int16 v11 = std::__shared_weak_count::lock(v7);
    if (v11)
    {
      if (*(void *)(a1 + 24))
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        if (*a2) {
          dispatch_retain(*a2);
        }
        *a3 = 0;
        a3[1] = 0;
        *a4 = 0;
        a4[1] = 0;
        QMICallAudioDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v11);
    }
  }
  *a5 = 0;
  a5[1] = 0;
}

void sub_222535CA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, dispatch_object_t object, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createSuppServicesCommandDriver(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        *a2 = 0;
        QMISuppServicesCommandDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_222535D90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (object) {
    dispatch_release(object);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createStkCommandDriver(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  long long v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6)
  {
    int v9 = std::__shared_weak_count::lock(v6);
    if (v9)
    {
      if (*(void *)(a1 + 24))
      {
        *a2 = 0;
        *a3 = 0;
        a3[1] = 0;
        QMI_STK_CommandDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    }
  }
  *a4 = 0;
  a4[1] = 0;
}

void sub_222535E78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, dispatch_object_t object, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createCallCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  long long v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6)
  {
    int v9 = std::__shared_weak_count::lock(v6);
    v17[1] = v9;
    if (v9)
    {
      v17[0] = *(void *)(a1 + 24);
      if (v17[0])
      {
        uint64_t v10 = *a2;
        dispatch_object_t object = v10;
        if (v10) {
          dispatch_retain(v10);
        }
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        std::allocate_shared[abi:ne180100]<EurOTASPService,std::allocator<EurOTASPService>,std::shared_ptr<Registry const> const&,dispatch::queue &,std::shared_ptr<ServiceProvisioningInterface> const&,char const* const&,void>((uint64_t)v17, &object, &v15);
        if (object) {
          dispatch_release(object);
        }
        *a2 = 0;
        uint64_t v12 = *a3;
        __int16 v11 = (std::__shared_weak_count *)a3[1];
        *a3 = 0;
        a3[1] = 0;
        if (v16) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v13 = operator new(0x30uLL);
        v13[1] = 0;
        void v13[2] = 0;
        *uint64_t v13 = &unk_26D4D8A20;
        void v13[3] = &unk_26D4D8A70;
        void v13[4] = v12;
        void v13[5] = v11;
        if (v11)
        {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
          std::__shared_weak_count::__release_shared[abi:ne180100](v11);
        }
        operator new();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    }
  }
  *a4 = 0;
  a4[1] = 0;
}

void sub_222536138(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, dispatch_object_t object)
{
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a15);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  std::__shared_weak_count::__release_shared[abi:ne180100](v19);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  if (a13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a13);
  }
  _Unwind_Resume(a1);
}

void sub_222536238(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x222536208);
}

void MCommandDriversFactory::createSmsCommandDriver(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = std::__shared_weak_count::lock(v5);
    uint64_t v10 = v7;
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        *a2 = 0;
        QMISMSCommandDriver::create(&v8);
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_2225362F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v14) {
    dispatch_release(v14);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createWiFiSettingsCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        long long v8 = *a2;
        if (v8) {
          dispatch_retain(v8);
        }
        QMIWiFiSettingsCommandDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_2225363C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v14) {
    dispatch_release(v14);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createNetworkListCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = (CCPreferences *)std::__shared_weak_count::lock(v5);
    uint64_t v15 = v7;
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        long long v8 = *a2;
        uint64_t v13 = v8;
        if (v8) {
          dispatch_retain(v8);
        }
        CCPreferences::create(&v9, v7);
        uint64_t v11 = v9;
        uint64_t v12 = v10;
        uint64_t v9 = 0;
        uint64_t v10 = 0;
        QMINetworkListCommandDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_2225364C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  if (v11) {
    dispatch_release(v11);
  }
  uint64_t v15 = *(std::__shared_weak_count **)(v13 - 40);
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createNetworkRegistrationCommandDriver(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, void *a3@<X8>)
{
  long long v7 = 0;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        if (*a2) {
          dispatch_retain(*a2);
        }
        QMINetworkRegistrationDriver::create();
      }
    }
  }
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_2225365AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createBasebandSettingsCommandDriver(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        if (*a2) {
          dispatch_retain(*a2);
        }
        QMIBasebandSettingsDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_22253668C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createVinylCommandDriver(MCommandDriversFactory *this@<X0>, void *a2@<X8>)
{
  int v4 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    v7[1] = v5;
    if (v5)
    {
      v7[0] = *((void *)this + 3);
      if (v7[0]) {
        VinylQMICommandDriver::create((capabilities::ct *)v7, &v6);
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    }
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_222536754(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createATCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        long long v8 = *a2;
        if (v8) {
          dispatch_retain(v8);
        }
        QMIATCommandDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_222536828(_Unwind_Exception *a1)
{
  if (v2) {
    dispatch_release(v2);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createPreferredNetworksCommandDriver(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = (capabilities::ct *)std::__shared_weak_count::lock(v5);
    if (v7)
    {
      long long v8 = v7;
      if (*(void *)(a1 + 24))
      {
        if (capabilities::ct::supports5G(v7))
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
          if (*a2) {
            dispatch_retain(*a2);
          }
          Mav20PreferredNetworksFactoryCommandDriver::create(&v10);
        }
        atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
        uint64_t v9 = *a2;
        if (v9) {
          dispatch_retain(v9);
        }
        xpc_null_create();
        QMIPreferredNetworksCommandDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_222536990(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, dispatch_object_t object, uint64_t a15, uint64_t a16)
{
  xpc_release(v18);
  if (v17) {
    dispatch_release(v17);
  }
  if (a13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a13);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createCDMASettingsCommandDriver(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    long long v7 = (capabilities::ct *)std::__shared_weak_count::lock(v5);
    long long v10 = v7;
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        if (capabilities::ct::supports5G(v7))
        {
          if (*a2) {
            dispatch_retain(*a2);
          }
          Mav20QMICDMASettingsCommandDriver::create(&v8);
        }
        if (*a2) {
          dispatch_retain(*a2);
        }
        QMICDMASettingsCommandDriver::create(&v8);
      }
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_222536AE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (object) {
    dispatch_release(object);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createDataSubscriptionCommandDriver(uint64_t a1@<X0>, void *a2@<X8>)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v4) {
    goto LABEL_7;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v4);
  long long v8 = v5;
  if (!v5) {
    goto LABEL_7;
  }
  uint64_t v7 = *(void *)(a1 + 24);
  if (!v7)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
LABEL_7:
    *a2 = 0;
    a2[1] = 0;
    return;
  }
  QMIDataSubscriptionCommandDriver::create((capabilities::ct *)&v7, &v6);
  *(_OWORD *)a2 = v6;
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
}

void sub_222536BB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createDownLinkFilterCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, uint64_t a3@<X5>, void *a4@<X8>)
{
  long long v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v6);
    if (v9)
    {
      if (*(void *)(a1 + 24))
      {
        long long v10 = *a2;
        if (v10) {
          dispatch_retain(v10);
        }
        uint64_t v11 = *(void *)(a3 + 8);
        if (v11) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 16), 1uLL, memory_order_relaxed);
        }
        QMIDownLinkFilterCommandDriver::create();
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    }
  }
  *a4 = 0;
  a4[1] = 0;
}

void sub_222536CCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  if (v16) {
    dispatch_release(v16);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createEmbmsCommandDriver(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    long long v10 = v7;
    if (v7)
    {
      if (*(void *)(a1 + 24))
      {
        if (*a2) {
          dispatch_retain(*a2);
        }
        QMIEmbmsCommandDriver::create(&v8);
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_222536DA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (object) {
    dispatch_release(object);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void MCommandDriversFactory::createStewieCommandDriver(uint64_t a1@<X0>, void *a2@<X8>)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v4) {
    goto LABEL_7;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v4);
  if (!v5) {
    goto LABEL_7;
  }
  long long v6 = v5;
  if (!*(void *)(a1 + 24))
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
LABEL_7:
    *a2 = 0;
    a2[1] = 0;
    return;
  }
  if (capabilities::ct::supportsStewie((capabilities::ct *)v5)) {
    QMIStewieCommandDriver::create();
  }
  *a2 = 0;
  a2[1] = 0;
  std::__shared_weak_count::__release_shared[abi:ne180100](v6);
}

void sub_222536E64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<MCommandDriversFactory>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D89D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<MCommandDriversFactory>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D89D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::__shared_ptr_emplace<MCommandDriversFactory>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,void *>>>::operator()[abi:ne180100](char a1, void *__p)
{
  if (a1)
  {
    char v3 = (std::__shared_weak_count *)__p[4];
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D8A20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D8A20;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::__shared_ptr_emplace<EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::~CommandDriverDelegate(void *a1)
{
  *a1 = &unk_26D4D8A70;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  return a1;
}

void EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::~CommandDriverDelegate(void *a1)
{
  *a1 = &unk_26D4D8A70;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }

  JUMPOUT(0x223C9A950);
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleVoiceDialCallResp(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallDialedInd(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallDialedAndMediaInitializedInd(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallAlertingInd(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallActiveInd(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 64))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallActiveWithFWIM(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 72))();
  }
  return result;
}

void EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallEndInd(uint64_t a1, const CallInfo *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    CallInfo::CallInfo((CallInfo *)v5, a2);
    (*(void (**)(uint64_t, void **, uint64_t, uint64_t))(*(void *)v3 + 80))(v3, v5, a3, 1);
    CallInfo::~CallInfo(v5);
  }
}

void sub_222537264(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  CallInfo::~CallInfo((void **)va);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallIncomingInd(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 96))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleBrandedCall(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 104))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallWaitingInd(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 112))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleNewWaitingCallWithTimer(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 136))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallHeldInd(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 144))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleMergedCalls(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 152))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleMergeCallsFailed(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 160))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleBBEmergencyModeExit(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 184))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handlePrivateConversation(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 192))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleUSSDInd(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 200))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleSendUSSDResponse(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 208))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleVoiceHandoverEvent(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 216))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleSRVCCCallInfo(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 224))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::areVoiceCallsAllowedRightNow(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 296))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::isIncomingCallAllowedOnSIM(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 568))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::notifyCallCapabilities(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 304))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::setCallerIdForCall(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 312))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::cancelUSSDSession(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 480))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::triggerSilentRedialOverIMS(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 464))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getTrafficChannelId(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 320))();
  }
  else {
    return *MEMORY[0x263F03540];
  }
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallHoldFailure(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 168))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallAnswerFailure(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 176))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getNumberOfCurrentCalls(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 328))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::setCallCapability(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 336))();
  }
  return result;
}

{
  uint64_t result;

  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 344))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleVoicePrivacySet(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 352))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::setExpectDisconnectionOnAllCalls(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 448))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getAudioDriver@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 488))();
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getCallInfoForUUID(uint64_t a1, const void **a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return 0;
  }
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v7, a2);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, const void **, uint64_t))(*(void *)v3 + 432))(v3, &v7, a3);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v7);
  return v5;
}

void sub_2225378B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getActiveCalls@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 400))();
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getHeldCalls@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 424))();
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getCurrentCalls@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 384))();
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

{
  uint64_t result;

  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 392))();
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::updateCallIds(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 504))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::reportCallDisconnect(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 512))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getTTYEnabledForSim(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 520))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getTTYEnabledForCall(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 528))();
  }
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::ratSelectedCallReadyToDial(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 608))();
  }
  return result;
}

void std::__shared_ptr_pointer<EurekaCallCommandDriver *,std::shared_ptr<EurekaCallCommandDriver> ctu::SharedSynchronizable<CallCommandDriver>::make_shared_ptr<EurekaCallCommandDriver>(EurekaCallCommandDriver*)::{lambda(EurekaCallCommandDriver *)#1},std::allocator<EurekaCallCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<EurekaCallCommandDriver *,std::shared_ptr<EurekaCallCommandDriver> ctu::SharedSynchronizable<CallCommandDriver>::make_shared_ptr<EurekaCallCommandDriver>(EurekaCallCommandDriver*)::{lambda(EurekaCallCommandDriver *)#1},std::allocator<EurekaCallCommandDriver>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<EurekaCallCommandDriver *,std::shared_ptr<EurekaCallCommandDriver> ctu::SharedSynchronizable<CallCommandDriver>::make_shared_ptr<EurekaCallCommandDriver>(EurekaCallCommandDriver*)::{lambda(EurekaCallCommandDriver *)#1},std::allocator<EurekaCallCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

atomic_uint **std::shared_ptr<EurekaCallCommandDriver> ctu::SharedSynchronizable<CallCommandDriver>::make_shared_ptr<EurekaCallCommandDriver>(EurekaCallCommandDriver*)::{lambda(EurekaCallCommandDriver*)#1}::operator() const(EurekaCallCommandDriver*)::{lambda(void *)#1}::__invoke(atomic_uint **result)
{
  if (result)
  {
    EurekaCallCommandDriver::~EurekaCallCommandDriver(result);
    JUMPOUT(0x223C9A950);
  }
  return result;
}

void QMIDataCommandDriverInterface::create(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  v4[0] = 0;
  v4[1] = 0;
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  if (*a3) {
    dispatch_retain(*a3);
  }
  QMIDataCommandDriver::create(v4);
}

void sub_222537C58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void QMIDataCommandDriver::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_222537D54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12)
{
  uint64_t v14 = *(std::__shared_weak_count **)(v12 + 8);
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  _Unwind_Resume(exception_object);
}

void std::shared_ptr<QMIDataCommandDriver>::shared_ptr[abi:ne180100]<QMIDataCommandDriver,std::shared_ptr<QMIDataCommandDriver> ctu::SharedSynchronizable<QMIDataCommandDriver>::make_shared_ptr<QMIDataCommandDriver>(QMIDataCommandDriver*)::{lambda(QMIDataCommandDriver*)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_222537E8C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[10], v1, (dispatch_function_t)std::shared_ptr<QMIDataCommandDriver> ctu::SharedSynchronizable<QMIDataCommandDriver>::make_shared_ptr<QMIDataCommandDriver>(QMIDataCommandDriver*)::{lambda(QMIDataCommandDriver*)#1}::operator() const(QMIDataCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_222537EB4(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<QMIDataCommandDriver *,std::shared_ptr<QMIDataCommandDriver> ctu::SharedSynchronizable<QMIDataCommandDriver>::make_shared_ptr<QMIDataCommandDriver>(QMIDataCommandDriver*)::{lambda(QMIDataCommandDriver *)#1},std::allocator<QMIDataCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<QMIDataCommandDriver *,std::shared_ptr<QMIDataCommandDriver> ctu::SharedSynchronizable<QMIDataCommandDriver>::make_shared_ptr<QMIDataCommandDriver>(QMIDataCommandDriver*)::{lambda(QMIDataCommandDriver *)#1},std::allocator<QMIDataCommandDriver>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<QMIDataCommandDriver *,std::shared_ptr<QMIDataCommandDriver> ctu::SharedSynchronizable<QMIDataCommandDriver>::make_shared_ptr<QMIDataCommandDriver>(QMIDataCommandDriver*)::{lambda(QMIDataCommandDriver *)#1},std::allocator<QMIDataCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIDataCommandDriver> ctu::SharedSynchronizable<QMIDataCommandDriver>::make_shared_ptr<QMIDataCommandDriver>(QMIDataCommandDriver*)::{lambda(QMIDataCommandDriver*)#1}::operator() const(QMIDataCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void QMIDataContextDriver::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_2225384C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, BBDataContextDriverInterface *a13, uint64_t a14, uint64_t a15, uint64_t a16, dispatch_object_t object, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v29);
  _Unwind_Resume(a1);
}

void QMIDataContextDriver::~QMIDataContextDriver(QMIDataContextDriver *this)
{
  *(void *)this = &unk_26D4D8D30;
  uint64_t v2 = (QMIDataContextDriver *)((char *)this + 24);
  *((void *)this + 3) = &unk_26D4D90C8;
  *((void *)this + 6) = &unk_26D4D9290;
  MEMORY[0x223C98F70]((char *)this + 216);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 24);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 22);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  long long v6 = (std::__shared_weak_count *)*((void *)this + 20);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  long long v8 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  if (*((char *)this + 119) < 0) {
    operator delete(*((void **)this + 12));
  }
  MEMORY[0x223C99A30]((char *)this + 88);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable((void *)this + 7);
  BBDataContextDriverInterface::~BBDataContextDriverInterface(v2);

  PersonalitySpecificImpl::~PersonalitySpecificImpl(this);
}

{
  PersonalitySpecific *v1;
  uint64_t vars8;

  QMIDataContextDriver::~QMIDataContextDriver(this);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

{
  PersonalitySpecific *v1;
  uint64_t vars8;

  QMIDataContextDriver::~QMIDataContextDriver(this);
  PersonalitySpecific::~PersonalitySpecific(v1);

  JUMPOUT(0x223C9A950);
}

void non-virtual thunk to'QMIDataContextDriver::~QMIDataContextDriver(QMIDataContextDriver *this)
{
  QMIDataContextDriver::~QMIDataContextDriver((QMIDataContextDriver *)((char *)this - 24));

  PersonalitySpecific::~PersonalitySpecific(v1);
}

{
  PersonalitySpecific *v1;
  uint64_t vars8;

  QMIDataContextDriver::~QMIDataContextDriver((QMIDataContextDriver *)((char *)this - 48));

  PersonalitySpecific::~PersonalitySpecific(v1);
}

{
  QMIDataContextDriver::~QMIDataContextDriver((QMIDataContextDriver *)((char *)this - 24));
}

{
  QMIDataContextDriver::~QMIDataContextDriver((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::initialize(QMIDataContextDriver *this)
{
  uint64_t v2 = *((void *)this + 16);
  void v12[3] = *((void *)this + 15);
  void v12[4] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *((void *)this + 9);
  _DWORD v12[2] = v3;
  if (v3) {
    dispatch_retain(v3);
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v4)
  {
    uint64_t v5 = *((void *)this + 7);
    long long v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      uint64_t v7 = v5 + 48;
      if (!v5) {
        uint64_t v7 = 0;
      }
      v12[0] = v7;
      v12[1] = v6;
      long long v10 = 0;
      uint64_t v11 = 0;
      long long v8 = (std::__shared_weak_count *)*((void *)this + 26);
      if (v8)
      {
        uint64_t v11 = std::__shared_weak_count::lock(v8);
        if (v11) {
          long long v10 = (char *)*((void *)this + 25);
        }
      }
      BBDataContextDriverInterface::getObserver(&v13, (QMIDataContextDriver *)((char *)this + 24));
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v13 + 480))(&v9);
      QMIDataContextIPAggregatorInterface::create((uint64_t)v12, &v10, &v14);
    }
  }
  std::__throw_bad_weak_ptr[abi:ne180100]();
}

void sub_222538B74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, dispatch_object_t a19, uint64_t a20,uint64_t a21,dispatch_object_t object,uint64_t a23,std::__shared_weak_count *a24)
{
  if (object) {
    dispatch_release(object);
  }
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a24);
  }
  uint64_t v30 = *(std::__shared_weak_count **)(v28 - 88);
  if (v30) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v30);
  }
  uint64_t v31 = *(std::__shared_weak_count **)(v28 - 72);
  if (v31) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v31);
  }
  std::__shared_weak_count::~__shared_weak_count(v27);
  operator delete(v32);
  if (v26) {
    dispatch_release(v26);
  }
  if (v25) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v25);
  }
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  if (v24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v24);
  }
  _Unwind_Resume(a1);
}

void non-virtual thunk to'QMIDataContextDriver::initialize(QMIDataContextDriver *this)
{
}

void QMIDataContextDriver::resetBaseband(uint64_t a1, uint64_t a2)
{
  BBDataContextDriverInterface::getObserver(&v3, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 584))(v3, a2);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void sub_222538CF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::resetBaseband(uint64_t a1, uint64_t a2)
{
}

void QMIDataContextDriver::updateResetBasebandTimer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BBDataContextDriverInterface::getObserver(&v7, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v7 + 592))(v7, a2, a3, a4);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
}

void sub_222538D9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::updateResetBasebandTimer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

uint64_t QMIDataContextDriver::bootstrapBBCtxCmdDriver(QMIDataContextDriver *this)
{
  uint64_t result = *((void *)this + 19);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

uint64_t non-virtual thunk to'QMIDataContextDriver::bootstrapBBCtxCmdDriver(QMIDataContextDriver *this)
{
  uint64_t result = *((void *)this + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

uint64_t QMIDataContextDriver::startBBCtxCmdDriver(QMIDataContextDriver *this)
{
  uint64_t result = *((void *)this + 19);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t non-virtual thunk to'QMIDataContextDriver::startBBCtxCmdDriver(QMIDataContextDriver *this)
{
  uint64_t result = *((void *)this + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t QMIDataContextDriver::stopBBCtxCmdDriver(QMIDataContextDriver *this)
{
  uint64_t result = *((void *)this + 19);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t non-virtual thunk to'QMIDataContextDriver::stopBBCtxCmdDriver(QMIDataContextDriver *this)
{
  uint64_t result = *((void *)this + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t QMIDataContextDriver::getName(QMIDataContextDriver *this)
{
  uint64_t result = (uint64_t)this + 96;
  if (*((char *)this + 119) < 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getName(QMIDataContextDriver *this)
{
  uint64_t result = (uint64_t)this + 48;
  if (*((char *)this + 71) < 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t QMIDataContextDriver::getIPAddress(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 48))();
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getIPAddress(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 48))();
}

uint64_t QMIDataContextDriver::getOriginalIPv6Address(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 19) + 56))();
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getOriginalIPv6Address(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 16) + 56))();
}

uint64_t QMIDataContextDriver::getLinkLocalIPAddress(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 19) + 64))();
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getLinkLocalIPAddress(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 16) + 64))();
}

uint64_t QMIDataContextDriver::getDNSAddresses(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 72))();
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getDNSAddresses(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 72))();
}

uint64_t QMIDataContextDriver::transitionalStateMask(QMIDataContextDriver *this)
{
  unsigned int v2 = (*(uint64_t (**)(void))(**((void **)this + 19) + 88))(*((void *)this + 19));
  uint64_t v3 = (QMIDataContextDriver *)((char *)this + 24);
  BBDataContextDriverInterface::getObserver(&v8, (QMIDataContextDriver *)((char *)this + 24));
  int v4 = (*(uint64_t (**)(void))(*(void *)v8 + 496))();
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  BBDataContextDriverInterface::getObserver(&v8, v3);
  int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 504))(v8);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  unsigned int v6 = v2 | 2;
  if (!v4) {
    unsigned int v6 = v2;
  }
  if (v5) {
    return v6 | 4;
  }
  else {
    return v6;
  }
}

void sub_222539170(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::transitionalStateMask(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::transitionalStateMask((QMIDataContextDriver *)((char *)this - 24));
}

uint64_t QMIDataContextDriver::getPDPMetricInfo(QMIDataContextDriver *this)
{
  return (uint64_t)this + 216;
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getPDPMetricInfo(QMIDataContextDriver *this)
{
  return (uint64_t)this + 192;
}

uint64_t QMIDataContextDriver::getPDPMetricInfo(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 80))();
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getPDPMetricInfo(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 80))();
}

uint64_t QMIDataContextDriver::getDataContextState(uint64_t a1, int a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 96))(*(void *)(a1 + 152));
  if ((int)v4 <= 3)
  {
    int v5 = (BBDataContextDriverInterface *)(a1 + 24);
    BBDataContextDriverInterface::getObserver(&v11, v5);
    if ((*(uint64_t (**)(uint64_t))(*(void *)v11 + 336))(v11))
    {
      BOOL v6 = a2 == 3;
    }
    else
    {
      BBDataContextDriverInterface::getObserver(&v9, v5);
      int v7 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 360))(v9);
      if (a2 == 3) {
        BOOL v6 = v7;
      }
      else {
        BOOL v6 = 0;
      }
      if (v10) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v10);
      }
    }
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    }
    if (v6) {
      return 4;
    }
    else {
      return v4;
    }
  }
  return v4;
}

void sub_222539318(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getDataContextState(uint64_t a1, int a2)
{
  return QMIDataContextDriver::getDataContextState(a1 - 24, a2);
}

uint64_t QMIDataContextDriver::getDataContextStateRaw(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void, uint64_t))(**((void **)this + 19) + 96))(*((void *)this + 19), 3);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getDataContextStateRaw(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void, uint64_t))(**((void **)this + 16) + 96))(*((void *)this + 16), 3);
}

uint64_t QMIDataContextDriver::reportHandoverWwanPduSessionId(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 19) + 224))();
}

uint64_t non-virtual thunk to'QMIDataContextDriver::reportHandoverWwanPduSessionId(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 16) + 224))();
}

uint64_t QMIDataContextDriver::updateAnbrFilters(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 152);
  std::__optional_copy_base<DataIPFilter,false>::__optional_copy_base[abi:ne180100](v7, a2);
  std::__optional_copy_base<DataIPFilter,false>::__optional_copy_base[abi:ne180100](v6, a3);
  (*(void (**)(uint64_t, unsigned char *, unsigned char *))(*(void *)v4 + 232))(v4, v7, v6);
  std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v6);
  return std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v7);
}

void sub_222539480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

uint64_t non-virtual thunk to'QMIDataContextDriver::updateAnbrFilters(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return QMIDataContextDriver::updateAnbrFilters(a1 - 24, a2, a3);
}

uint64_t QMIDataContextDriver::getAnbr(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 19) + 240))();
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getAnbr(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 16) + 240))();
}

void *QMIDataContextDriver::getAnbrActivationState(uint64_t a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 152);
  std::__function::__value_func<void ()(BOOL,BOOL)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  (*(void (**)(uint64_t, void *))(*(void *)v2 + 248))(v2, v4);
  return std::__function::__value_func<void ()(BOOL,BOOL)>::~__value_func[abi:ne180100](v4);
}

void sub_22253958C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(BOOL,BOOL)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *non-virtual thunk to'QMIDataContextDriver::getAnbrActivationState(uint64_t a1, uint64_t a2)
{
  return QMIDataContextDriver::getAnbrActivationState(a1 - 24, a2);
}

void *QMIDataContextDriver::queryAnbrBitrate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v8[4] = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a1 + 152);
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v8, a4);
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v6 + 256))(v6, a2, a3, v8);
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v8);
}

void sub_222539664(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *non-virtual thunk to'QMIDataContextDriver::queryAnbrBitrate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return QMIDataContextDriver::queryAnbrBitrate(a1 - 24, a2, a3, a4);
}

uint64_t QMIDataContextDriver::setCoalescing(uint64_t a1, unsigned __int16 a2)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 152) + 264))(*(void *)(a1 + 152), a2);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::setCoalescing(uint64_t a1, unsigned __int16 a2)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 128) + 264))(*(void *)(a1 + 128), a2);
}

uint64_t QMIDataContextDriver::isActivating(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 19) + 104))();
}

uint64_t non-virtual thunk to'QMIDataContextDriver::isActivating(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 16) + 104))();
}

uint64_t QMIDataContextDriver::releaseDataContextClient(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 19) + 288))();
}

uint64_t non-virtual thunk to'QMIDataContextDriver::releaseDataContextClient(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 16) + 288))();
}

unint64_t QMIDataContextDriver::activateDataContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v101 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 392))
  {
    unsigned int v3 = -8;
LABEL_3:
    unsigned int v4 = -1;
    return v4 | ((unint64_t)v3 << 32);
  }
  uint64_t v9 = *(char **)(a2 + 8);
  long long v10 = *(char **)(a2 + 16);
  int v53 = *(unsigned __int8 *)(a2 + 24);
  int v11 = *(unsigned __int8 *)(a2 + 72);
  uint64_t v12 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136316162;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"activateDataContext";
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v9;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
    char v84 = v10;
    __int16 v85 = 2080;
    char v86 = (const char *)asStringBool();
    __int16 v87 = 2080;
    uint64_t v88 = asStringBool();
    _os_log_impl(&dword_22231A000, v12, OS_LOG_TYPE_DEFAULT, "#I %s: reason=%s, processName=%s, handover=%s, networkDisconnect = %s", (uint8_t *)&buf, 0x34u);
  }
  uint64_t v13 = (BBDataContextDriverInterface *)(a1 + 24);
  BBDataContextDriverInterface::getObserver((uint64_t *)&v79, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(std::string *__return_ptr))(*(void *)v79 + 392))(&buf);
  std::string::size_type v14 = buf.__r_.__value_.__r.__words[0];
  if (buf.__r_.__value_.__l.__size_) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
  }
  if (*((void *)&v79 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v79 + 1));
  }
  if (!v14)
  {
    uint64_t v30 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"activateDataContext";
      _os_log_impl(&dword_22231A000, v30, OS_LOG_TYPE_DEFAULT, "#I %s: DataContext should be grabbed first", (uint8_t *)&buf, 0xCu);
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"DataContext should be grabbed first";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CommCenter/CommCenterCommandDrivers/Data/QMI/Context/QMIDataContextDriver.cpp";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
      LODWORD(v84) = 218;
      _os_log_error_impl(&dword_22231A000, &_os_log_internal, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT false\n %s\n at %s:%d\n**********", (uint8_t *)&buf, 0x1Cu);
    }
    __TUAssertTrigger();
    unsigned int v3 = -9;
    goto LABEL_3;
  }
  __int16 v82 = 0;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v79 = 0u;
  BBDataContextDriverInterface::getObserver((uint64_t *)&buf, (BBDataContextDriverInterface *)(a1 + 24));
  std::string::size_type v15 = buf.__r_.__value_.__r.__words[0];
  BBDataContextDriverInterface::getObserver(&v75, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v75 + 392))(&v77);
  std::vector<unsigned int> __p = 0;
  __int16 v73 = 0;
  uint64_t v74 = 0;
  std::vector<DataConnectionTraits>::__init_with_size[abi:ne180100]<DataConnectionTraits*,DataConnectionTraits*>(&__p, *(const void **)a3, *(void *)(a3 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2));
  (*(void (**)(long long *__return_ptr, std::string::size_type, uint64_t *, void **))(*(void *)v15 + 376))(&v79, v15, &v77, &__p);
  if (__p)
  {
    __int16 v73 = __p;
    operator delete(__p);
  }
  if (v78) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v78);
  }
  if (v76) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v76);
  }
  if (buf.__r_.__value_.__l.__size_) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
  }
  if (!v79)
  {
    LODWORD(v75) = 0;
    BBDataContextDriverInterface::getObserver((uint64_t *)&buf, (BBDataContextDriverInterface *)(a1 + 24));
    std::string::size_type v31 = buf.__r_.__value_.__r.__words[0];
    __int16 v68 = 0;
    uint64_t v69 = 0;
    __int16 v67 = 0;
    std::vector<DataConnectionTraits>::__init_with_size[abi:ne180100]<DataConnectionTraits*,DataConnectionTraits*>(&v67, *(const void **)a3, *(void *)(a3 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2));
    char v32 = (*(uint64_t (**)(std::string::size_type, void **, uint64_t *))(*(void *)v31 + 96))(v31, &v67, &v75);
    if (v67)
    {
      __int16 v68 = v67;
      operator delete(v67);
    }
    if (buf.__r_.__value_.__l.__size_) {
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
    }
    uint64_t v33 = *(NSObject **)(a1 + 88);
    BOOL v34 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
    if ((v32 & 1) == 0)
    {
      if (v34)
      {
        uint64_t v43 = CSIEventString();
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"activateDataContext";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v43;
        _os_log_impl(&dword_22231A000, v33, OS_LOG_TYPE_DEFAULT, "#I %s: DataContext activation is not possible: radio is not ready: event=%s", (uint8_t *)&buf, 0x16u);
      }
      BBDataContextDriverInterface::getObserver((uint64_t *)&buf, (BBDataContextDriverInterface *)(a1 + 24));
      (*(void (**)(std::string::size_type, void))(*(void *)buf.__r_.__value_.__l.__data_ + 88))(buf.__r_.__value_.__r.__words[0], 0);
      if (buf.__r_.__value_.__l.__size_) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
      }
      BBDataContextDriverInterface::getObserver((uint64_t *)&buf, (BBDataContextDriverInterface *)(a1 + 24));
      int v59 = 0;
      uint64_t v60 = "Radio is not ready";
      long long v61 = &unk_222543CCE;
      int v62 = 0;
      char v63 = 0;
      uint64_t v65 = 0;
      long long v66 = 0;
      uint64_t v64 = 0;
      (*(void (**)(std::string::size_type, int *, void))(*(void *)buf.__r_.__value_.__l.__data_ + 112))(buf.__r_.__value_.__r.__words[0], &v59, v75);
      if (v66) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v66);
      }
      if (buf.__r_.__value_.__l.__size_) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
      }
      unsigned int v3 = 24;
      goto LABEL_91;
    }
    if (v34)
    {
      uint64_t v35 = asStringBool();
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"activateDataContext";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v35;
      _os_log_impl(&dword_22231A000, v33, OS_LOG_TYPE_DEFAULT, "#I %s: trying handover=%s", (uint8_t *)&buf, 0x16u);
    }
    if (!v11)
    {
      BBDataContextDriverInterface::getObserver((uint64_t *)&buf, (BBDataContextDriverInterface *)(a1 + 24));
      char v36 = (*(uint64_t (**)(std::string::size_type))(*(void *)buf.__r_.__value_.__l.__data_ + 72))(buf.__r_.__value_.__r.__words[0]);
      if (buf.__r_.__value_.__l.__size_) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
      }
      if (v36) {
        goto LABEL_45;
      }
    }
    BBDataContextDriverInterface::getObserver((uint64_t *)&buf, (BBDataContextDriverInterface *)(a1 + 24));
    char v37 = (*(uint64_t (**)(std::string::size_type, char *))(*(void *)buf.__r_.__value_.__l.__data_ + 80))(buf.__r_.__value_.__r.__words[0], v9);
    if (buf.__r_.__value_.__l.__size_) {
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
    }
    if (v37)
    {
LABEL_45:
      unsigned int v3 = 0;
      unsigned int v4 = 2;
      goto LABEL_92;
    }
    BBDataContextDriverInterface::getObserver((uint64_t *)&buf, (BBDataContextDriverInterface *)(a1 + 24));
    (*(void (**)(std::string::size_type, uint64_t))(*(void *)buf.__r_.__value_.__l.__data_ + 88))(buf.__r_.__value_.__r.__words[0], 1);
    if (buf.__r_.__value_.__l.__size_) {
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
    }
    unsigned int v58 = 3;
    BBDataContextDriverInterface::getObserver((uint64_t *)&buf, (BBDataContextDriverInterface *)(a1 + 24));
    char v44 = (*(uint64_t (**)(std::string::size_type, unsigned int *, BOOL))(*(void *)buf.__r_.__value_.__l.__data_
                                                                                  + 568))(buf.__r_.__value_.__r.__words[0], &v58, v53 != 0);
    if (buf.__r_.__value_.__l.__size_) {
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
    }
    if ((v44 & 1) == 0)
    {
      long long v49 = *(NSObject **)(a1 + 88);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"activateDataContext";
        _os_log_impl(&dword_22231A000, v49, OS_LOG_TYPE_DEFAULT, "#I %s: DataSettings does not want us to proceed, bailing", (uint8_t *)&buf, 0xCu);
      }
      unsigned int v3 = -3;
      goto LABEL_91;
    }
    if (!v53)
    {
      BBDataContextDriverInterface::getObserver((uint64_t *)&buf, (BBDataContextDriverInterface *)(a1 + 24));
      std::string::size_type v45 = buf.__r_.__value_.__r.__words[0];
      std::string::basic_string[abi:ne180100]<0>(v56, v9);
      std::string::basic_string[abi:ne180100]<0>(v54, v10);
      (*(void (**)(std::string::size_type, uint64_t, void **, void **))(*(void *)v45 + 312))(v45, 3, v56, v54);
      if (v55 < 0) {
        operator delete(v54[0]);
      }
      if (v57 < 0) {
        operator delete(v56[0]);
      }
      if (buf.__r_.__value_.__l.__size_) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
      }
    }
    unsigned int v46 = QMIDataContextDriver::getDataContextState(a1, 3) - 1;
    if (v46 < 6)
    {
      unsigned int v4 = dword_22258EA00[2 * v46];
      unsigned int v3 = dword_22258EA30[v46];
      goto LABEL_92;
    }
    PDPMetricInfo::clear((PDPMetricInfo *)(a1 + 216));
    CFNumberRef v50 = (const std::string::value_type **)(a2 + 48);
    if (*(char *)(a2 + 71) < 0)
    {
      std::string::size_type v51 = *(void *)(a2 + 56);
      if (v51)
      {
        std::string::__init_copy_ctor_external(&buf, *v50, v51);
        goto LABEL_103;
      }
    }
    else if (*(unsigned char *)(a2 + 71))
    {
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = *(_OWORD *)v50;
      buf.__r_.__value_.__r.__words[2] = *(void *)(a2 + 64);
LABEL_103:
      CFTypeID v52 = (void **)(a1 + 224);
      if (*(char *)(a1 + 247) < 0) {
        operator delete(*v52);
      }
      *(_OWORD *)CFTypeID v52 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
      *(void *)(a1 + 240) = *((void *)&buf.__r_.__value_.__l + 2);
      *(void *)(a1 + 376) = (*(uint64_t (**)(void))(**(void **)(a1 + 136) + 80))(*(void *)(a1 + 136));
      unsigned int v4 = QMIDataContextDriver::startDataCall(a1, v58, v53 != 0, a1 + 224) - 1;
      unsigned int v3 = -9;
      goto LABEL_92;
    }
    std::string::basic_string[abi:ne180100]<0>(&buf, v9);
    goto LABEL_103;
  }
  int v16 = BYTE12(v80);
  uint64_t v17 = *(NSObject **)(a1 + 88);
  BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  if (v16)
  {
    if (!v18) {
      goto LABEL_79;
    }
    uint64_t v19 = (void *)(a1 + 96);
    if (*(char *)(a1 + 119) < 0) {
      uint64_t v19 = (void *)*v19;
    }
    uint64_t v20 = CSIErrorString();
    int v22 = (const char *)*((void *)&v79 + 1);
    uint64_t v21 = v80;
    uint64_t v23 = asStringBool();
    uint64_t v24 = asStringBool();
    uint64_t v25 = asStringBool();
    uint64_t v26 = asStringBool();
    LODWORD(buf.__r_.__value_.__l.__data_) = 136317698;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v19;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"activateDataContext";
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
    char v84 = "DataContext activation is not possible";
    __int16 v85 = 2080;
    char v86 = "f";
    __int16 v87 = 2080;
    uint64_t v88 = v20;
    __int16 v89 = 2080;
    __int16 v90 = v22;
    __int16 v91 = 2080;
    uint64_t v92 = v21;
    __int16 v93 = 2080;
    uint64_t v94 = v23;
    __int16 v95 = 2080;
    uint64_t v96 = v24;
    __int16 v97 = 2080;
    uint64_t v98 = v25;
    __int16 v99 = 2080;
    uint64_t v100 = v26;
    CFDataRef v27 = "#I DATA.%s: %s: %s: %s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})";
    uint64_t v28 = v17;
    uint32_t v29 = 112;
    goto LABEL_78;
  }
  if (!v18) {
    goto LABEL_79;
  }
  long long v38 = (void *)(a1 + 96);
  if (*(char *)(a1 + 119) < 0) {
    long long v38 = (void *)*v38;
  }
  uint64_t v39 = CSIErrorString();
  if (!*((void *)&v79 + 1))
  {
    uint64_t v40 = v80;
    goto LABEL_76;
  }
  uint64_t v40 = v80;
  if (!**((unsigned char **)&v79 + 1))
  {
LABEL_76:
    CFTypeID v42 = (const char *)&unk_222543CCE;
    CFDataRef v41 = (const char *)&unk_222543CCE;
    goto LABEL_77;
  }
  CFDataRef v41 = "}";
  CFTypeID v42 = "{";
LABEL_77:
  LODWORD(buf.__r_.__value_.__l.__data_) = 136317186;
  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
  WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
  *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"activateDataContext";
  HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
  char v84 = "DataContext activation is not possible";
  __int16 v85 = 2080;
  char v86 = "f";
  __int16 v87 = 2080;
  uint64_t v88 = v39;
  __int16 v89 = 2080;
  __int16 v90 = v42;
  __int16 v91 = 2080;
  uint64_t v92 = *((void *)&v79 + 1);
  __int16 v93 = 2080;
  uint64_t v94 = v40;
  __int16 v95 = 2080;
  uint64_t v96 = (uint64_t)v41;
  CFDataRef v27 = "#I DATA.%s: %s: %s: %s(%s%s%s %s%s)";
  uint64_t v28 = v17;
  uint32_t v29 = 92;
LABEL_78:
  _os_log_impl(&dword_22231A000, v28, OS_LOG_TYPE_DEFAULT, v27, (uint8_t *)&buf, v29);
LABEL_79:
  if (v79 == -5)
  {
    LODWORD(v79) = 24;
    *((void *)&v79 + 1) = "activateDataContext replacement";
    *(void *)&long long v80 = &unk_222543CCE;
    DWORD2(v80) = 0;
    BYTE12(v80) = 0;
    uint64_t v47 = v82;
    __int16 v82 = 0;
    long long v81 = 0uLL;
    if (v47) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v47);
    }
  }
  BBDataContextDriverInterface::getObserver((uint64_t *)&buf, v13);
  (*(void (**)(std::string::size_type, void))(*(void *)buf.__r_.__value_.__l.__data_ + 88))(buf.__r_.__value_.__r.__words[0], 0);
  if (buf.__r_.__value_.__l.__size_) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
  }
  BBDataContextDriverInterface::getObserver((uint64_t *)&buf, v13);
  std::string::size_type v48 = buf.__r_.__value_.__r.__words[0];
  v70[0] = v79;
  v70[1] = v80;
  v70[2] = v81;
  char v71 = v82;
  if (v82) {
    atomic_fetch_add_explicit(&v82->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(std::string::size_type, _OWORD *, void))(*(void *)v48 + 112))(v48, v70, 0);
  if (v71) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v71);
  }
  if (buf.__r_.__value_.__l.__size_) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
  }
  unsigned int v3 = v79;
LABEL_91:
  unsigned int v4 = -1;
LABEL_92:
  if (v82) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v82);
  }
  return v4 | ((unint64_t)v3 << 32);
}

void sub_22253A398(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,std::__shared_weak_count *a53)
{
  if (a53) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a53);
  }
  _Unwind_Resume(exception_object);
}

uint64_t QMIDataContextDriver::startDataCall(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  if ((*(uint64_t (**)(void))(**(void **)(a1 + 136) + 48))(*(void *)(a1 + 136))) {
    goto LABEL_9;
  }
  BBDataContextDriverInterface::getObserver((uint64_t *)buf, (BBDataContextDriverInterface *)(a1 + 24));
  uint64_t v8 = (*(uint64_t (**)(void, uint64_t))(**(void **)buf + 120))(*(void *)buf, a3);
  if (*(void *)&buf[8]) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
  }
  if (!v8 || (a2 ? (int v9 = a2) : (int v9 = 3), v8 == 3))
  {
LABEL_9:
    uint64_t v8 = 3;
    uint64_t v10 = 3;
  }
  else
  {
    uint64_t v10 = v8 & v9;
  }
  int v11 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    p_p = &__p;
    QMIDataContextDriver::getAPNObserver((QMIDataContextDriver *)a1);
    if (v18 < 0) {
      p_p = __p;
    }
    BBDataContextDriverInterface::getObserver(&v15, (BBDataContextDriverInterface *)(a1 + 24));
    unsigned int v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v15 + 120))(v15, a3);
    *(_DWORD *)std::string buf = 136447490;
    *(void *)&uint8_t buf[4] = p_p;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = a2;
    __int16 v20 = 2048;
    uint64_t v21 = v13;
    __int16 v22 = 2048;
    uint64_t v23 = v8;
    __int16 v24 = 2048;
    uint64_t v25 = v10;
    __int16 v26 = 2048;
    uint64_t v27 = 3;
    _os_log_impl(&dword_22231A000, v11, OS_LOG_TYPE_DEFAULT, "#I startDataCall: apn=%{public}s: ipFamily is allowed: family=0x%lx, allowed=0x%lx, localAllowed=0x%lx, activation=0x%lx, requested=0x%lx", buf, 0x3Eu);
    if (v16) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v16);
    }
    if (v18 < 0) {
      operator delete(__p);
    }
  }
  *(_DWORD *)(a1 + 384) = v10;
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 152) + 40))(*(void *)(a1 + 152), v10, v8, 3, a3, a4);
}

void sub_22253A740(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t non-virtual thunk to'QMIDataContextDriver::activateDataContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return QMIDataContextDriver::activateDataContext(a1 - 24, a2, a3);
}

void QMIDataContextDriver::getAPNObserver(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 456))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253A820(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t QMIDataContextDriver::getDataFamilyActive(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v7, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v7 + 328))(&v9);
  int v2 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 360))(v9);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  if (!v2 || QMIDataContextDriver::getDataContextState((uint64_t)this, 3) - 3 >= 4) {
    return 0;
  }
  unsigned int v3 = (CSIPacketAddress *)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 19) + 48))(*((void *)this + 19), 1);
  unsigned int v4 = CSIPacketAddress::isZeroIP(v3) ^ 1;
  int v5 = (CSIPacketAddress *)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 19) + 48))(*((void *)this + 19), 2);
  if (CSIPacketAddress::isZeroIP(v5)) {
    return v4;
  }
  else {
    return v4 | 2;
  }
}

void sub_22253A980(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getDataFamilyActive(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::getDataFamilyActive((QMIDataContextDriver *)((char *)this - 24));
}

void QMIDataContextDriver::handleDataContextIPActivated(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 448))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253AA20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleDataContextIPActivated(QMIDataContextDriver *this)
{
}

void QMIDataContextDriver::handleDataContextIPSuspended(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 208))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253AAA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleDataContextIPSuspended(QMIDataContextDriver *this)
{
}

void QMIDataContextDriver::handleDataContextIPOffline(uint64_t a1, uint64_t a2)
{
  BBDataContextDriverInterface::getObserver(&v3, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 432))(v3, a2);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void sub_22253AB38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleDataContextIPOffline(uint64_t a1, uint64_t a2)
{
}

void QMIDataContextDriver::handleDataContextIPActivateFailure(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  std::string::size_type v14 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "handleDataContextIPActivateFailure";
    _os_log_impl(&dword_22231A000, v14, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v15 = (BBDataContextDriverInterface *)(a1 + 24);
  BBDataContextDriverInterface::getObserver((uint64_t *)&buf, v15);
  uint64_t v16 = buf;
  int v19 = a3;
  __int16 v20 = "we are done with this context";
  uint64_t v21 = &unk_222543CCE;
  int v22 = 0;
  char v23 = 0;
  uint64_t v25 = 0;
  __int16 v26 = 0;
  uint64_t v24 = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, "qmi activate fail");
  (*(void (**)(uint64_t, uint64_t, int *, void **, void, uint64_t, uint64_t, uint64_t, char))(*(void *)v16 + 440))(v16, a2, &v19, __p, 0, a6, a4, a5, a7);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if (v26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v26);
  }
  if (*((void *)&buf + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&buf + 1));
  }
  BBDataContextDriverInterface::getObserver((uint64_t *)&buf, v15);
  (*(void (**)(void))(*(void *)buf + 544))(buf);
  if (*((void *)&buf + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&buf + 1));
  }
}

void sub_22253AD38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25)
{
  if (a25) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a25);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleDataContextIPActivateFailure(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
}

void QMIDataContextDriver::handleDataContextIPOfflineIfActivated(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  unsigned int v4 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v9 = 136315138;
    *(void *)&void v9[4] = "handleDataContextIPOfflineIfActivated";
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", v9, 0xCu);
  }
  int v5 = (BBDataContextDriverInterface *)(a1 + 24);
  BBDataContextDriverInterface::getObserver((uint64_t *)v9, (BBDataContextDriverInterface *)(a1 + 24));
  int v6 = (*(uint64_t (**)(void, uint64_t))(**(void **)v9 + 424))(*(void *)v9, a2);
  if (*(void *)&v9[8]) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v9[8]);
  }
  if (v6)
  {
    uint64_t v7 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = asString();
      *(_DWORD *)uint64_t v9 = 136315394;
      *(void *)&void v9[4] = "handleDataContextIPOfflineIfActivated";
      *(_WORD *)&v9[12] = 2080;
      *(void *)&v9[14] = v8;
      _os_log_impl(&dword_22231A000, v7, OS_LOG_TYPE_DEFAULT, "#I %s: %s network is already online, take it offline (2)", v9, 0x16u);
    }
    BBDataContextDriverInterface::getObserver((uint64_t *)v9, v5);
    (*(void (**)(void, uint64_t))(**(void **)v9 + 432))(*(void *)v9, a2);
    if (*(void *)&v9[8]) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v9[8]);
    }
  }
}

void sub_22253AF44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleDataContextIPOfflineIfActivated(uint64_t a1, uint64_t a2)
{
}

uint64_t QMIDataContextDriver::handleNetworkStackFailure(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  int v6 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "handleNetworkStackFailure";
    _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&buf, 0xCu);
  }
  if (a3 == 99) {
    uint64_t v7 = 38;
  }
  else {
    uint64_t v7 = 18;
  }
  QMIDataContextDriver::deactivateDataContext(a1, v7, "CommCenter");
  if ((int)QMIDataContextDriver::getDataContextState(a1, 3) <= 3)
  {
    uint64_t v8 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "handleNetworkStackFailure";
      _os_log_impl(&dword_22231A000, v8, OS_LOG_TYPE_DEFAULT, "#I %s: done with context", (uint8_t *)&buf, 0xCu);
    }
    BBDataContextDriverInterface::getObserver((uint64_t *)&buf, (BBDataContextDriverInterface *)(a1 + 24));
    uint64_t v9 = buf;
    int v13 = a3;
    std::string::size_type v14 = "handleNetworkStackFailure";
    uint64_t v15 = &unk_222543CCE;
    int v16 = 0;
    char v17 = 0;
    uint64_t v19 = 0;
    __int16 v20 = 0;
    uint64_t v18 = 0;
    std::string::basic_string[abi:ne180100]<0>(__p, "QMI network fail");
    (*(void (**)(uint64_t, uint64_t, int *, void **, uint64_t, void, void, void, _BYTE))(*(void *)v9 + 440))(v9, a2, &v13, __p, 1, 0, 0, 0, 0);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    if (v20) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v20);
    }
    if (*((void *)&buf + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&buf + 1));
    }
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 152) + 120))(*(void *)(a1 + 152), a2);
}

void sub_22253B194(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a23) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a23);
  }
  uint64_t v25 = *(std::__shared_weak_count **)(v23 - 72);
  if (v25) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v25);
  }
  _Unwind_Resume(exception_object);
}

uint64_t QMIDataContextDriver::deactivateDataContext(uint64_t a1, uint64_t a2, const std::string::value_type *a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  int v6 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "deactivateDataContext";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: reason %s", buf, 0x16u);
  }
  uint64_t v7 = (BBDataContextDriverInterface *)(a1 + 24);
  BBDataContextDriverInterface::getObserver(&v20, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(unsigned char *__return_ptr))(*(void *)v20 + 392))(buf);
  if (*(void *)buf)
  {
    BBDataContextDriverInterface::getObserver(&v16, (BBDataContextDriverInterface *)(a1 + 24));
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v16 + 392))(&v18);
    int v8 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v18 + 96))(v18, 0, a2);
    if (v19) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v19);
    }
    int v9 = v8 ^ 1;
    if (v17) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v17);
    }
  }
  else
  {
    int v9 = 0;
  }
  if (*(void *)&buf[8]) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
  }
  if (v21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  }
  if (v9)
  {
    uint64_t v10 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "deactivateDataContext";
      _os_log_impl(&dword_22231A000, v10, OS_LOG_TYPE_DEFAULT, "#I %s: DataSettings prevented deactivation", buf, 0xCu);
    }
    BBDataContextDriverInterface::getObserver(&v20, v7);
    (*(void (**)(unsigned char *__return_ptr))(*(void *)v20 + 328))(buf);
    (*(void (**)(void))(**(void **)buf + 648))(*(void *)buf);
    if (*(void *)&buf[8]) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
    }
    if (v21) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v21);
    }
    return 0;
  }
  else
  {
    BOOL v13 = a2 != 38 && a2 != 21;
    BOOL v14 = (a2 - 23) >= 2 && v13;
    uint64_t v15 = (const std::string::value_type *)asString();
    std::string::__assign_external((std::string *)(a1 + 248), v15);
    std::string::__assign_external((std::string *)(a1 + 272), a3);
    return (*(uint64_t (**)(void, BOOL, BOOL))(**(void **)(a1 + 152) + 136))(*(void *)(a1 + 152), v14, a2 == 23);
  }
}

void sub_22253B4F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::handleNetworkStackFailure(uint64_t a1, uint64_t a2, int a3)
{
  return QMIDataContextDriver::handleNetworkStackFailure(a1 - 24, a2, a3);
}

void QMIDataContextDriver::handleDataContextIpDeactivatedContextDisappeared(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 248))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253B5C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleDataContextIpDeactivatedContextDisappeared(QMIDataContextDriver *this)
{
}

void QMIDataContextDriver::updateBbThrottlingTimer(QMIDataContextDriver *this, uint64_t a2)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 656))(v3, a2);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void sub_22253B65C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::updateBbThrottlingTimer(QMIDataContextDriver *this, uint64_t a2)
{
}

void QMIDataContextDriver::handleDataContextIpDeactivatedNetworkDisconnect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BBDataContextDriverInterface::getObserver(&v7, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v7 + 240))(v7, a2, a3, a4);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
}

void sub_22253B700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleDataContextIpDeactivatedNetworkDisconnect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void QMIDataContextDriver::handleDataContextIPFailedCleaningDone(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 184))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253B784(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleDataContextIPFailedCleaningDone(QMIDataContextDriver *this)
{
}

void QMIDataContextDriver::sendAnbrActivationState(QMIDataContextDriver *this, uint64_t a2)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 192))(v3, a2);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void sub_22253B810(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::sendAnbrActivationState(QMIDataContextDriver *this, uint64_t a2)
{
}

void QMIDataContextDriver::sendAnbrBitrateRecommendation(QMIDataContextDriver *this, uint64_t a2, uint64_t a3)
{
  BBDataContextDriverInterface::getObserver(&v5, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 200))(v5, a2, a3);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

void sub_22253B8A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::sendAnbrBitrateRecommendation(QMIDataContextDriver *this, uint64_t a2, uint64_t a3)
{
}

void QMIDataContextDriver::handleDataContextIPAborted(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 256))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253B930(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleDataContextIPAborted(QMIDataContextDriver *this)
{
}

void QMIDataContextDriver::handleDataContextIPIdle(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 176))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253B9B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleDataContextIPIdle(QMIDataContextDriver *this)
{
}

uint64_t QMIDataContextDriver::handleDataContextIPResume(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BBDataContextDriverInterface::getObserver(&v7, (BBDataContextDriverInterface *)(a1 + 24));
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 224))(v7, a2, a3);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  return v5;
}

void sub_22253BA50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::handleDataContextIPResume(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return QMIDataContextDriver::handleDataContextIPResume(a1 - 48, a2, a3);
}

void QMIDataContextDriver::handleDataContextIPResumed(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 232))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253BAD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleDataContextIPResumed(QMIDataContextDriver *this)
{
}

void QMIDataContextDriver::handleDataContextIPDidGetPcoInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BBDataContextDriverInterface::getObserver(&v5, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 264))(v5, a2, a3);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

void sub_22253BB70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleDataContextIPDidGetPcoInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void QMIDataContextDriver::handleDataContextIPDidGetMTU(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BBDataContextDriverInterface::getObserver(&v5, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 280))(v5, a2, a3);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

void sub_22253BC0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleDataContextIPDidGetMTU(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t QMIDataContextDriver::handleDataContextIPOnline(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BBDataContextDriverInterface::getObserver(&v9, (BBDataContextDriverInterface *)(a1 + 24));
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v9 + 104))(v9, a2, a3, a4);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  return v7;
}

void sub_22253BCB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::handleDataContextIPOnline(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return QMIDataContextDriver::handleDataContextIPOnline(a1 - 48, a2, a3, a4);
}

uint64_t QMIDataContextDriver::ipFamilyMustBeConfigured(uint64_t a1, uint64_t a2)
{
  BBDataContextDriverInterface::getObserver(&v5, (BBDataContextDriverInterface *)(a1 + 24));
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 288))(v5, a2);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  return v3;
}

void sub_22253BD54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::ipFamilyMustBeConfigured(uint64_t a1, uint64_t a2)
{
  return QMIDataContextDriver::ipFamilyMustBeConfigured(a1 - 48, a2);
}

void QMIDataContextDriver::proxyUpdate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BBDataContextDriverInterface::getObserver(&v5, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 128))(v5, a2, a3);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

void sub_22253BDE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::proxyUpdate(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void QMIDataContextDriver::applicationIDUpdate(QMIDataContextDriver *this, uint64_t a2)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 136))(v3, a2);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void sub_22253BE74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::applicationIDUpdate(QMIDataContextDriver *this, uint64_t a2)
{
}

void QMIDataContextDriver::getInterfaceAddress(uint64_t a1, uint64_t a2)
{
  BBDataContextDriverInterface::getObserver(&v3, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 296))(v3, a2);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void sub_22253BF10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::getInterfaceAddress(uint64_t a1, uint64_t a2)
{
}

uint64_t QMIDataContextDriver::isInEnteringLowPowerForNoWowIP(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  uint64_t v1 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 304))(v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1;
}

void sub_22253BFA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::isInEnteringLowPowerForNoWowIP(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::isInEnteringLowPowerForNoWowIP((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::submitIpv4AddressChangeMetric(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 320))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253C030(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::submitIpv4AddressChangeMetric(QMIDataContextDriver *this)
{
}

void QMIDataContextDriver::getDataSettingsInfo(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 392))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253C0C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::getDataSettingsInfo(QMIDataContextDriver *this)
{
}

uint64_t QMIDataContextDriver::getConnectionMask(QMIDataContextDriver *this, uint64_t a2)
{
  BBDataContextDriverInterface::getObserver(&v5, (QMIDataContextDriver *)((char *)this + 24));
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 416))(v5, a2);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  return v3;
}

void sub_22253C160(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getConnectionMask(QMIDataContextDriver *this, uint64_t a2)
{
  return QMIDataContextDriver::getConnectionMask((QMIDataContextDriver *)((char *)this - 48), a2);
}

void QMIDataContextDriver::reInitThrottleTimer(QMIDataContextDriver *this, uint64_t a2)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 552))(v3, a2);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void sub_22253C1F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::reInitThrottleTimer(QMIDataContextDriver *this, uint64_t a2)
{
}

uint64_t QMIDataContextDriver::getCellularDataTechnology(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  uint64_t v1 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 384))(v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1;
}

void sub_22253C288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getCellularDataTechnology(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::getCellularDataTechnology((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::setOutgoingTrafficEnabled(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BBDataContextDriverInterface::getObserver(&v7, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v7 + 400))(v7, a2, a3, a4);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
}

void sub_22253C334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::setOutgoingTrafficEnabled(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

uint64_t QMIDataContextDriver::getHandoverPduSessionId(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  uint64_t v1 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 144))(v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1;
}

void sub_22253C3C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getHandoverPduSessionId(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::getHandoverPduSessionId((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::freePduSessionId(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 152))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253C444(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::freePduSessionId(QMIDataContextDriver *this)
{
}

uint64_t QMIDataContextDriver::getIwlanSnssai(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  uint64_t v1 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 160))(v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1;
}

void sub_22253C4D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getIwlanSnssai(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::getIwlanSnssai((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::updateHandoverPduSessionId(QMIDataContextDriver *this, uint64_t a2)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 168))(v3, a2);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void sub_22253C55C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::updateHandoverPduSessionId(QMIDataContextDriver *this, uint64_t a2)
{
}

void QMIDataContextDriver::reportContextConnectionError(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BBDataContextDriverInterface::getObserver(&v5, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 488))(v5, a2, a3);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

void sub_22253C5F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::reportContextConnectionError(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t QMIDataContextDriver::isOnProbation(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  uint64_t v1 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 496))(v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1;
}

void sub_22253C68C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::isOnProbation(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::isOnProbation((QMIDataContextDriver *)((char *)this - 48));
}

uint64_t QMIDataContextDriver::isOnDNSProbation(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  uint64_t v1 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 504))(v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1;
}

void sub_22253C720(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::isOnDNSProbation(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::isOnDNSProbation((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::setProbation(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 512))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253C7AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::setProbation(QMIDataContextDriver *this)
{
}

void QMIDataContextDriver::handleActivatedIfReady(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 520))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253C838(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleActivatedIfReady(QMIDataContextDriver *this)
{
}

void QMIDataContextDriver::setDeactivating(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 528))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253C8C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::setDeactivating(QMIDataContextDriver *this)
{
}

void non-virtual thunk to'QMIDataContextDriver::getAPNObserver(QMIDataContextDriver *this)
{
}

void QMIDataContextDriver::copyValueFromCarrierBundleForKeyWithDefault(QMIDataContextDriver *this, const __CFString *a2, const void *a3, uint64_t a4)
{
  BBDataContextDriverInterface::getObserver(&v7, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v7 + 472))(&v9);
  (*(void (**)(uint64_t, const __CFString *, const void *, uint64_t))(*(void *)v9 + 88))(v9, a2, a3, a4);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
}

void sub_22253C9B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::copyValueFromCarrierBundleForKeyWithDefault(QMIDataContextDriver *this, const __CFString *a2, const void *a3, uint64_t a4)
{
}

uint64_t QMIDataContextDriver::supportsPDNAuthentication(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v3 + 472))(&v5);
  uint64_t v1 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 56))(v5);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1;
}

void sub_22253CA98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::supportsPDNAuthentication(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::supportsPDNAuthentication((QMIDataContextDriver *)((char *)this - 48));
}

uint64_t QMIDataContextDriver::alwaysUseIpv4v6(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v3 + 472))(&v5);
  uint64_t v1 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 48))(v5);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1;
}

void sub_22253CB78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::alwaysUseIpv4v6(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::alwaysUseIpv4v6((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::submitPDPContextStateChangeMetrics(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v1, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t))(*(void *)v1 + 576))(v1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_22253CC18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::submitPDPContextStateChangeMetrics(QMIDataContextDriver *this)
{
}

void QMIDataContextDriver::submitCommCenterIPSetupFailure(QMIDataContextDriver *this, uint64_t a2, uint64_t a3)
{
  BBDataContextDriverInterface::getObserver(&v5, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 600))(v5, a2, a3);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

void sub_22253CCB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::submitCommCenterIPSetupFailure(QMIDataContextDriver *this, uint64_t a2, uint64_t a3)
{
}

void QMIDataContextDriver::handleDataContextIPDeactivatedDriver(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  unsigned int v4 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v7) = 136315138;
    *(void *)((char *)&v7 + 4) = "handleDataContextIPDeactivatedDriver";
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v7, 0xCu);
  }
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 152) + 120))(*(void *)(a1 + 152), a2);
  uint64_t v5 = (BBDataContextDriverInterface *)(a1 + 24);
  BBDataContextDriverInterface::getObserver((uint64_t *)&v7, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(void, uint64_t))(*(void *)v7 + 432))(v7, a2);
  if (*((void *)&v7 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v7 + 1));
  }
  if (!QMIDataContextDriver::getDataContextState(a1, 3))
  {
    int v6 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v7) = 136315138;
      *(void *)((char *)&v7 + 4) = "handleDataContextIPDeactivatedDriver";
      _os_log_impl(&dword_22231A000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Done with this context", (uint8_t *)&v7, 0xCu);
    }
    BBDataContextDriverInterface::getObserver((uint64_t *)&v7, v5);
    (*(void (**)(void))(*(void *)v7 + 560))(v7);
    if (*((void *)&v7 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v7 + 1));
    }
    BBDataContextDriverInterface::getObserver((uint64_t *)&v7, v5);
    (*(void (**)(void))(*(void *)v7 + 344))(v7);
    if (*((void *)&v7 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v7 + 1));
    }
    BBDataContextDriverInterface::getObserver((uint64_t *)&v7, v5);
    (*(void (**)(void))(*(void *)v7 + 544))(v7);
    if (*((void *)&v7 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v7 + 1));
    }
  }
}

void sub_22253CF38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::handleDataContextIPDeactivatedDriver(uint64_t a1, uint64_t a2)
{
}

{
  QMIDataContextDriver::handleDataContextIPDeactivatedDriver(a1 - 48, a2);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::deactivateDataContext(uint64_t a1, uint64_t a2, const std::string::value_type *a3)
{
  return QMIDataContextDriver::deactivateDataContext(a1 - 24, a2, a3);
}

uint64_t QMIDataContextDriver::suspendDataContext(QMIDataContextDriver *this)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v2 = *((void *)this + 11);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = "suspendDataContext";
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v4, 0xCu);
  }
  return (*(uint64_t (**)(void))(**((void **)this + 19) + 144))(*((void *)this + 19));
}

uint64_t non-virtual thunk to'QMIDataContextDriver::suspendDataContext(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::suspendDataContext((QMIDataContextDriver *)((char *)this - 24));
}

uint64_t QMIDataContextDriver::resumeDataContext(QMIDataContextDriver *this)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v2 = *((void *)this + 11);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = "resumeDataContext";
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v4, 0xCu);
  }
  return (*(uint64_t (**)(void))(**((void **)this + 19) + 152))(*((void *)this + 19));
}

uint64_t non-virtual thunk to'QMIDataContextDriver::resumeDataContext(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::resumeDataContext((QMIDataContextDriver *)((char *)this - 24));
}

uint64_t QMIDataContextDriver::resetDataContext(QMIDataContextDriver *this)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v2 = *((void *)this + 11);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = "resetDataContext";
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v4, 0xCu);
  }
  return (*(uint64_t (**)(void))(**((void **)this + 19) + 160))(*((void *)this + 19));
}

uint64_t non-virtual thunk to'QMIDataContextDriver::resetDataContext(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::resetDataContext((QMIDataContextDriver *)((char *)this - 24));
}

void *QMIDataContextDriver::createQoSClientOnDemand(uint64_t a1, int a2)
{
  return QMIDataQOSHelper::createQoSClientOnDemand(*(void **)(a1 + 168), a2);
}

void *non-virtual thunk to'QMIDataContextDriver::createQoSClientOnDemand(uint64_t a1, int a2)
{
  return QMIDataQOSHelper::createQoSClientOnDemand(*(void **)(a1 + 120), a2);
}

void *QMIDataContextDriver::releaseQoSClient(uint64_t a1, int a2)
{
  return QMIDataQOSHelper::releaseQoSClient(*(void **)(a1 + 168), a2);
}

void *non-virtual thunk to'QMIDataContextDriver::releaseQoSClient(uint64_t a1, int a2)
{
  return QMIDataQOSHelper::releaseQoSClient(*(void **)(a1 + 120), a2);
}

uint64_t QMIDataContextDriver::requestQos(uint64_t a1, uint64_t a2, uint64_t a3, const void **a4, uint64_t a5)
{
  uint64_t v8 = *(void **)(a1 + 168);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(&v11, a4);
  uint64_t v9 = QMIDataQOSHelper::requestQos(v8, a2, a3, &v11, a5);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&v11);
  return v9;
}

void sub_22253D288(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::requestQos(uint64_t a1, uint64_t a2, uint64_t a3, const void **a4, uint64_t a5)
{
  return QMIDataContextDriver::requestQos(a1 - 24, a2, a3, a4, a5);
}

void QMIDataContextDriver::releaseQos(uint64_t a1, int a2, uint64_t a3)
{
}

void non-virtual thunk to'QMIDataContextDriver::releaseQos(uint64_t a1, int a2, uint64_t a3)
{
}

const void **QMIDataContextDriver::setPacketNotificationFilter(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v4 = *(void *)(a1 + 152);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(&v6, a3);
  (*(void (**)(uint64_t, uint64_t, const void **))(*(void *)v4 + 208))(v4, a2, &v6);
  return ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&v6);
}

void sub_22253D324(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **non-virtual thunk to'QMIDataContextDriver::setPacketNotificationFilter(uint64_t a1, uint64_t a2, const void **a3)
{
  return QMIDataContextDriver::setPacketNotificationFilter(a1 - 24, a2, a3);
}

const void **QMIDataContextDriver::dropIPPackets(uint64_t a1, const void **a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 152);
  ctu::SharedRef<__CFArray const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFArray const>::SharedRef(&v6, a2);
  (*(void (**)(uint64_t, const void **, uint64_t))(*(void *)v4 + 192))(v4, &v6, a3);
  return ctu::SharedRef<__CFArray const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFArray const>::~SharedRef(&v6);
}

void sub_22253D3AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::SharedRef<__CFArray const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFArray const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **non-virtual thunk to'QMIDataContextDriver::dropIPPackets(uint64_t a1, const void **a2, uint64_t a3)
{
  return QMIDataContextDriver::dropIPPackets(a1 - 24, a2, a3);
}

uint64_t QMIDataContextDriver::dropIMSPackets(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 19) + 200))();
}

uint64_t non-virtual thunk to'QMIDataContextDriver::dropIMSPackets(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 16) + 200))();
}

uint64_t QMIDataContextDriver::setQuality(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 184))();
}

uint64_t non-virtual thunk to'QMIDataContextDriver::setQuality(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 184))();
}

uint64_t QMIDataContextDriver::shutDownContextDriver(QMIDataContextDriver *this)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v2 = *((void *)this + 11);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = "shutDownContextDriver";
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v4, 0xCu);
  }
  *((unsigned char *)this + 392) = 1;
  (*(void (**)(void))(**((void **)this + 19) + 216))(*((void *)this + 19));
  return QMIDataQOSHelper::shutDownQOS(*((QMIDataQOSHelper **)this + 21));
}

uint64_t non-virtual thunk to'QMIDataContextDriver::shutDownContextDriver(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::shutDownContextDriver((QMIDataContextDriver *)((char *)this - 24));
}

uint64_t QMIDataContextDriver::ipv6ServiceUp(QMIDataContextDriver *this, const CSIPacketAddress *a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  int v4 = *((void *)this + 11);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CSIPacketAddress::operator std::string();
    if (v8 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v10 = "ipv6ServiceUp";
    __int16 v11 = 2080;
    char v12 = p_p;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I %s:  %s ", buf, 0x16u);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  return (*(uint64_t (**)(void, const CSIPacketAddress *))(**((void **)this + 19) + 176))(*((void *)this + 19), a2);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::ipv6ServiceUp(QMIDataContextDriver *this, const CSIPacketAddress *a2)
{
  return QMIDataContextDriver::ipv6ServiceUp((QMIDataContextDriver *)((char *)this - 24), a2);
}

uint64_t QMIDataContextDriver::ipv4ServiceUp(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 168))();
}

uint64_t non-virtual thunk to'QMIDataContextDriver::ipv4ServiceUp(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 168))();
}

uint64_t QMIDataContextDriver::getPdpId(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  uint64_t v1 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 64))(v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1;
}

void sub_22253D72C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getPdpId(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::getPdpId((QMIDataContextDriver *)((char *)this - 24));
}

{
  return QMIDataContextDriver::getPdpId((QMIDataContextDriver *)((char *)this - 48));
}

uint64_t QMIDataContextDriver::getAllowedIpFamily(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  uint64_t v1 = (*(uint64_t (**)(uint64_t, void))(*(void *)v3 + 120))(v3, 0);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1;
}

void sub_22253D7C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::getAllowedIpFamily(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::getAllowedIpFamily((QMIDataContextDriver *)((char *)this - 48));
}

uint64_t QMIDataContextDriver::isImsSupported(QMIDataContextDriver *this)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v3 + 392))(&v5);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  if (v5) {
    uint64_t v1 = (*(uint64_t (**)(uint64_t, void))(*(void *)v5 + 56))(v5, 0);
  }
  else {
    uint64_t v1 = 0;
  }
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  return v1;
}

void sub_22253D8B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::isImsSupported(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::isImsSupported((QMIDataContextDriver *)((char *)this - 24));
}

QMIDataQOSHelper *QMIDataContextDriver::dumpStateDriver(QMIDataContextDriver *this)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  int v2 = *((void *)this + 11);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = (void *)((char *)this + 96);
    if (*((char *)this + 119) < 0) {
      uint64_t v3 = (void *)*v3;
    }
    int v6 = 136315138;
    long long v7 = v3;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: ------- %s (driver) -------", (uint8_t *)&v6, 0xCu);
  }
  uint64_t v4 = *((void *)this + 19);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 272))(v4);
  }
  uint64_t result = (QMIDataQOSHelper *)*((void *)this + 21);
  if (result) {
    return (QMIDataQOSHelper *)QMIDataQOSHelper::dumpState(result);
  }
  return result;
}

QMIDataQOSHelper *non-virtual thunk to'QMIDataContextDriver::dumpStateDriver(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::dumpStateDriver((QMIDataContextDriver *)((char *)this - 24));
}

uint64_t QMIDataContextDriver::isInLoopBackMode(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface::getObserver(&v3, (QMIDataContextDriver *)((char *)this + 24));
  uint64_t v1 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 616))(v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1;
}

void sub_22253DA48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::isInLoopBackMode(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::isInLoopBackMode((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::updateLastActiveProfileConnectionMask(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BBDataContextDriverInterface::getObserver(&v5, (BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 624))(v5, a2, a3);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

void sub_22253DAE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'QMIDataContextDriver::updateLastActiveProfileConnectionMask(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t QMIDataContextDriver::handleBasebandRefreshComplete(QMIDataContextDriver *this)
{
  int v2 = *((void *)this + 11);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl(&dword_22231A000, v2, OS_LOG_TYPE_DEFAULT, "#I recevied rest baseband_refresh_complete event", v4, 2u);
  }
  uint64_t result = *((void *)this + 19);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 280))(result);
  }
  return result;
}

uint64_t non-virtual thunk to'QMIDataContextDriver::handleBasebandRefreshComplete(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::handleBasebandRefreshComplete((QMIDataContextDriver *)((char *)this - 24));
}

void QMIDataContextDriver::sendServiceDisconnectionStatus_sync(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 192);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      int v6 = v5;
      long long v7 = *(char **)(a1 + 184);
      if (v7) {
        (*(void (**)(char *, uint64_t))(*(void *)&v7[*(void *)(*(void *)v7 - 320)] + 288))(&v7[*(void *)(*(void *)v7 - 320)], a2);
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    }
  }
}

void sub_22253DC5C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'QMIDataContextDriver::sendServiceDisconnectionStatus_sync(uint64_t a1, uint64_t a2)
{
}

uint64_t QMIDataContextDriver::updateVoLTEDataCallType(QMIDataContextDriver *this, uint64_t a2)
{
  uint64_t v4 = *((void *)this + 11);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v6 = 0;
    _os_log_impl(&dword_22231A000, v4, OS_LOG_TYPE_DEFAULT, "#I Updating VolTE call data type", v6, 2u);
  }
  uint64_t result = *((void *)this + 19);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 112))(result, a2);
  }
  return result;
}

uint64_t non-virtual thunk to'QMIDataContextDriver::updateVoLTEDataCallType(QMIDataContextDriver *this, uint64_t a2)
{
  return QMIDataContextDriver::updateVoLTEDataCallType((QMIDataContextDriver *)((char *)this - 24), a2);
}

uint64_t QMIDataContextDriver::deactivateDataContextOtherActive()
{
  return 1;
}

void QMIDataContextDriver::getLastSnssai(unsigned char *a1@<X8>)
{
  *a1 = 0;
  a1[24] = 0;
}

uint64_t QMIDataContextDriver::addLLFilters_sync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return std::function<void ()(BOOL)>::operator()(a4, 0);
}

uint64_t QMIDataContextDriver::delLLFilters_sync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return std::function<void ()(BOOL)>::operator()(a4, 0);
}

void QMIDataContextDriver::getLLFilters_sync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  memset(v4, 0, sizeof(v4));
  uint64_t v3 = *(void *)(a3 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, void *))(*(void *)v3 + 48))(v3, v4);
  uint64_t v5 = (void **)v4;
  std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v5);
}

void sub_22253DDC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'QMIDataContextDriver::getLastSnssai(unsigned char *a1@<X8>)
{
  *a1 = 0;
  a1[24] = 0;
}

uint64_t non-virtual thunk to'QMIDataContextDriver::deactivateDataContextOtherActive()
{
  return 1;
}

uint64_t non-virtual thunk to'QMIDataContextDriver::addLLFilters_sync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return std::function<void ()(BOOL)>::operator()(a4, 0);
}

uint64_t non-virtual thunk to'QMIDataContextDriver::delLLFilters_sync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return std::function<void ()(BOOL)>::operator()(a4, 0);
}

void std::__shared_ptr_emplace<QMIDataQOSHelper>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D9A60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIDataQOSHelper>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4D9A60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

uint64_t std::__shared_ptr_emplace<QMIDataQOSHelper>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *std::vector<DataConnectionTraits>::__init_with_size[abi:ne180100]<DataConnectionTraits*,DataConnectionTraits*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v5 = result;
    if (a4 >= 0x1555555555555556) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t result = operator new(12 * a4);
    uint64_t v8 = result;
    *uint64_t v5 = result;
    v5[1] = result;
    _DWORD v5[2] = (char *)result + 12 * a4;
    size_t v9 = a3 - (void)a2;
    if (v9) {
      uint64_t result = memcpy(result, a2, v9);
    }
    v5[1] = (char *)v8 + v9;
  }
  return result;
}

void sub_22253DF44(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&a9, 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<QMIDataContextDriver *,std::shared_ptr<QMIDataContextDriver> ctu::SharedSynchronizable<QMIDataContextDriver>::make_shared_ptr<QMIDataContextDriver>(QMIDataContextDriver*)::{lambda(QMIDataContextDriver *)#1},std::allocator<QMIDataContextDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C9A950);
}

void std::__shared_ptr_pointer<QMIDataContextDriver *,std::shared_ptr<QMIDataContextDriver> ctu::SharedSynchronizable<QMIDataContextDriver>::make_shared_ptr<QMIDataContextDriver>(QMIDataContextDriver*)::{lambda(QMIDataContextDriver *)#1},std::allocator<QMIDataContextDriver>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<QMIDataContextDriver *,std::shared_ptr<QMIDataContextDriver> ctu::SharedSynchronizable<QMIDataContextDriver>::make_shared_ptr<QMIDataContextDriver>(QMIDataContextDriver*)::{lambda(QMIDataContextDriver *)#1},std::allocator<QMIDataContextDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIDataContextDriver> ctu::SharedSynchronizable<QMIDataContextDriver>::make_shared_ptr<QMIDataContextDriver>(QMIDataContextDriver*)::{lambda(QMIDataContextDriver*)#1}::operator() const(QMIDataContextDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x270EE4320](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x270EE4348]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x270EE4360](theArray, idx);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x270EE4528]();
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x270EE4808](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x270EE4820](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x270EE4838]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EE4920](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x270EE4948]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x270EE4958](theDict, key);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x270EE4A30](cf);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x270EE4C58]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x270EE4C70](number, theType, valuePtr);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x270EE4E10](cf);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x270EE50D0](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x270EE5178](theString, buffer, bufferSize, *(void *)&encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x270EE5218]();
}

CFUUIDRef CFUUIDCreateWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)MEMORY[0x270EE5490](alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  uint64_t v1 = MEMORY[0x270EE54A8](uuid);
  result.uint64_t byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.uint64_t byte7 = HIBYTE(v1);
  return result;
}

uint64_t CSIErrorString()
{
  return MEMORY[0x270EE8900]();
}

uint64_t CSIEventString()
{
  return MEMORY[0x270EE8908]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x270ED7CD8](aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t createPLMN()
{
  return MEMORY[0x270EE8910]();
}

uint64_t getCSIError()
{
  return MEMORY[0x270EE8918]();
}

uint64_t getDSReason()
{
  return MEMORY[0x270EE8920]();
}

uint64_t asStringBool()
{
  return MEMORY[0x270EE8930]();
}

{
  return MEMORY[0x270EE8938]();
}

uint64_t decodeString()
{
  return MEMORY[0x270EE8948]();
}

{
  return MEMORY[0x270EE8950]();
}

uint64_t sGetEmptyAddrs(void)
{
  return MEMORY[0x270EE8960]();
}

uint64_t shouldRetrySMS()
{
  return MEMORY[0x270EE8968]();
}

uint64_t CSIBOOLAsString()
{
  return MEMORY[0x270EE8970]();
}

uint64_t read_rest_value()
{
  return MEMORY[0x270EE8978]();
}

uint64_t CSIDateToSeconds()
{
  return MEMORY[0x270EE8998]();
}

uint64_t VinylSlotIdToInt()
{
  return MEMORY[0x270EE89A8]();
}

uint64_t appendDataSoMask()
{
  return MEMORY[0x270EE89B0]();
}

uint64_t write_rest_value()
{
  return MEMORY[0x270EE93A8]();
}

{
  return MEMORY[0x270EE89C0]();
}

uint64_t ratSelectionAsStr()
{
  return MEMORY[0x270EE89C8]();
}

uint64_t VinylSlotIdFromInt()
{
  return MEMORY[0x270EE89D0]();
}

uint64_t asStringDataSoMask()
{
  return MEMORY[0x270EE89D8]();
}

uint64_t dataUiModifierMask()
{
  return MEMORY[0x270EE89E0]();
}

uint64_t decodeOperatorName()
{
  return MEMORY[0x270EE93B0]();
}

uint64_t is5GDataTechnology()
{
  return MEMORY[0x270EE89E8]();
}

uint64_t attachApnClientName()
{
  return MEMORY[0x270EE8A00]();
}

uint64_t asWirelessTechnology()
{
  return MEMORY[0x270EE8A20]();
}

uint64_t callTechnologyToString()
{
  return MEMORY[0x270EE8A40]();
}

uint64_t numberContainsAlphabet()
{
  return MEMORY[0x270EE8A48]();
}

uint64_t sGetEmptyPDPMetricInfo(void)
{
  return MEMORY[0x270EE8A50]();
}

uint64_t PersonalityIdFromSlotId()
{
  return MEMORY[0x270EE8A58]();
}

uint64_t sVinylProfileIdAsString()
{
  return MEMORY[0x270EE8A60]();
}

uint64_t convertMaskToBandsForRat()
{
  return MEMORY[0x270EE93C0]();
}

uint64_t decodeBCDExtendedAddress()
{
  return MEMORY[0x270EE8A68]();
}

uint64_t DevicePersistentCopyValue(const __CFString *a1, const void *a2)
{
  return MEMORY[0x270EE8A70](a1, a2);
}

uint64_t WirelessTechnologyAsString()
{
  return MEMORY[0x270EE8A90]();
}

uint64_t convertOtaspStatusToString()
{
  return MEMORY[0x270EE8A98]();
}

uint64_t convertWirelessTechnologyToCallTechnology()
{
  return MEMORY[0x270EE8AB0]();
}

uint64_t asString()
{
  return MEMORY[0x270EE8AC8]();
}

{
  return MEMORY[0x270EE8AD8]();
}

{
  return MEMORY[0x270EE8AE0]();
}

{
  return MEMORY[0x270EE93C8]();
}

{
  return MEMORY[0x270EE8AF8]();
}

{
  return MEMORY[0x270EE8B10]();
}

{
  return MEMORY[0x270EE8B18]();
}

{
  return MEMORY[0x270EE8B38]();
}

{
  return MEMORY[0x270EE8B40]();
}

{
  return MEMORY[0x270EE8B48]();
}

{
  return MEMORY[0x270EE8B58]();
}

{
  return MEMORY[0x270EE8B60]();
}

{
  return MEMORY[0x270EE8B68]();
}

{
  return MEMORY[0x270EE8B70]();
}

{
  return MEMORY[0x270EE8B78]();
}

{
  return MEMORY[0x270EE8B80]();
}

{
  return MEMORY[0x270EE8B88]();
}

{
  return MEMORY[0x270EE8B90]();
}

{
  return MEMORY[0x270EE8BB0]();
}

{
  return MEMORY[0x270EE8BB8]();
}

{
  return MEMORY[0x270EE8BC0]();
}

{
  return MEMORY[0x270EE8BC8]();
}

{
  return MEMORY[0x270EE8BD8]();
}

{
  return MEMORY[0x270EE8BE8]();
}

{
  return MEMORY[0x270EE8BF8]();
}

{
  return MEMORY[0x270EE8C00]();
}

{
  return MEMORY[0x270EE8C10]();
}

{
  return MEMORY[0x270EE8C18]();
}

{
  return MEMORY[0x270EE8C20]();
}

{
  return MEMORY[0x270EE8C30]();
}

{
  return MEMORY[0x270EE8C38]();
}

{
  return MEMORY[0x270EE8C48]();
}

uint64_t isCdmaRat()
{
  return MEMORY[0x270EE8C50]();
}

uint64_t printUuid()
{
  return MEMORY[0x270EE8C60]();
}

void SelectItem::~SelectItem(SelectItem *this)
{
}

uint64_t subscriber::encodeIccid()
{
  return MEMORY[0x270EE8C78]();
}

uint64_t subscriber::isSimSettled()
{
  return MEMORY[0x270EE8C90]();
}

uint64_t subscriber::sDecodeIccid(subscriber *this, const unsigned __int8 *a2)
{
  return MEMORY[0x270EE8C98](this, a2);
}

uint64_t subscriber::isEsimCapable()
{
  return MEMORY[0x270EE8CA8]();
}

uint64_t subscriber::getSimFilePath()
{
  return MEMORY[0x270EE93F0]();
}

uint64_t subscriber::isValidSimSlot()
{
  return MEMORY[0x270EE8CB8]();
}

uint64_t subscriber::markNotPresent()
{
  return MEMORY[0x270EE93F8]();
}

uint64_t subscriber::isFileIdInvalid()
{
  return MEMORY[0x270EE9400]();
}

uint64_t subscriber::SimCommandDriver::parseEapAka()
{
  return MEMORY[0x270EE9408]();
}

uint64_t subscriber::SimCommandDriver::parseEapSim()
{
  return MEMORY[0x270EE9410]();
}

uint64_t subscriber::SimCommandDriver::parseImsAka()
{
  return MEMORY[0x270EE9418]();
}

uint64_t subscriber::SimCommandDriver::parseImsGbaBs()
{
  return MEMORY[0x270EE9420]();
}

uint64_t subscriber::SimCommandDriver::parseImsGbaNaf()
{
  return MEMORY[0x270EE9428]();
}

uint64_t subscriber::SimCommandDriver::SimCommandDriver()
{
  return MEMORY[0x270EE9430]();
}

uint64_t subscriber::expectedSimCount()
{
  return MEMORY[0x270EE8CC8]();
}

uint64_t subscriber::makeSimSlotRange()
{
  return MEMORY[0x270EE8CD8]();
}

uint64_t subscriber::instanceAsSimSlot(subscriber *this)
{
  return MEMORY[0x270EE8CE0](this);
}

uint64_t subscriber::simSlotAsInstance()
{
  return MEMORY[0x270EE8CE8]();
}

uint64_t subscriber::isCardResultSW1Good(subscriber *this)
{
  return MEMORY[0x270EE9440](this);
}

uint64_t subscriber::maybeMarkNotPresent()
{
  return MEMORY[0x270EE9448]();
}

uint64_t subscriber::isSet()
{
  return MEMORY[0x270EE9450]();
}

uint64_t subscriber::asString()
{
  return MEMORY[0x270EE8D00]();
}

{
  return MEMORY[0x270EE8D08]();
}

{
  return MEMORY[0x270EE8D10]();
}

{
  return MEMORY[0x270EE8D20]();
}

{
  return MEMORY[0x270EE8D28]();
}

{
  return MEMORY[0x270EE8D30]();
}

{
  return MEMORY[0x270EE8D38]();
}

{
  return MEMORY[0x270EE8D40]();
}

uint64_t subscriber::clearFlag()
{
  return MEMORY[0x270EE9460]();
}

uint64_t subscriber::getFileId()
{
  return MEMORY[0x270EE9468]();
}

uint64_t subscriber::setFlagIf()
{
  return MEMORY[0x270EE9470]();
}

uint64_t subscriber::operator<<()
{
  return MEMORY[0x270EE8D58]();
}

void DisplayText::~DisplayText(DisplayText *this)
{
}

void OpenChannel::~OpenChannel(OpenChannel *this)
{
}

void ReceiveData::~ReceiveData(ReceiveData *this)
{
}

void CloseChannel::~CloseChannel(CloseChannel *this)
{
}

uint64_t DataIPFilter::adjust(DataIPFilter *this)
{
  return MEMORY[0x270EE8D60](this);
}

uint64_t OTASPService::OTASPService()
{
  return MEMORY[0x270EE8D68]();
}

void OTASPService::~OTASPService(OTASPService *this)
{
}

void RefreshAlpha::~RefreshAlpha(RefreshAlpha *this)
{
}

uint64_t capabilities::ct::supports5G(capabilities::ct *this)
{
  return MEMORY[0x270F968B0](this);
}

uint64_t capabilities::ct::supportsVoNR(capabilities::ct *this)
{
  return MEMORY[0x270F968B8](this);
}

uint64_t capabilities::ct::supportsHydra(capabilities::ct *this)
{
  return MEMORY[0x270F968C0](this);
}

uint64_t capabilities::ct::supportsVoLTE(capabilities::ct *this)
{
  return MEMORY[0x270F968C8](this);
}

uint64_t capabilities::ct::supportsGemini(capabilities::ct *this)
{
  return MEMORY[0x270F968D0](this);
}

uint64_t capabilities::ct::supportsStewie(capabilities::ct *this)
{
  return MEMORY[0x270F968D8](this);
}

uint64_t capabilities::ct::shouldAWDWakeAP(capabilities::ct *this)
{
  return MEMORY[0x270F968E0](this);
}

uint64_t capabilities::ct::supports5GSlicing(capabilities::ct *this)
{
  return MEMORY[0x270F968E8](this);
}

uint64_t capabilities::ct::supportsLLFilters(capabilities::ct *this)
{
  return MEMORY[0x270F968F8](this);
}

uint64_t capabilities::ct::supportsVoiceCall(capabilities::ct *this)
{
  return MEMORY[0x270F96900](this);
}

uint64_t capabilities::ct::defaultVinylSlotID(capabilities::ct *this)
{
  return MEMORY[0x270F96908](this);
}

uint64_t capabilities::ct::supportsDynamicSID(capabilities::ct *this)
{
  return MEMORY[0x270F96918](this);
}

uint64_t capabilities::ct::supportsEcoDataMode(capabilities::ct *this)
{
  return MEMORY[0x270F96920](this);
}

uint64_t capabilities::ct::supportsHandoverPDN(capabilities::ct *this)
{
  return MEMORY[0x270F96928](this);
}

uint64_t capabilities::ct::supportsSMSIMSStack(capabilities::ct *this)
{
  return MEMORY[0x270F96930](this);
}

uint64_t capabilities::ct::getCDMASettingsSupport(capabilities::ct *this)
{
  return MEMORY[0x270F96950](this);
}

uint64_t capabilities::ct::requireVinylManagerInd(capabilities::ct *this)
{
  return MEMORY[0x270F96958](this);
}

uint64_t capabilities::ct::supportsBB2GMitigation(capabilities::ct *this)
{
  return MEMORY[0x270F96960](this);
}

uint64_t capabilities::ct::supportsPrivateNetwork(capabilities::ct *this)
{
  return MEMORY[0x270F96968](this);
}

uint64_t capabilities::ct::dataOnlySingleSIMDevice(capabilities::ct *this)
{
  return MEMORY[0x270F96980](this);
}

uint64_t capabilities::ct::supportedVinylSlotCount(capabilities::ct *this)
{
  return MEMORY[0x270F96998](this);
}

uint64_t capabilities::ct::supportsDualPhysicalSIM(capabilities::ct *this)
{
  return MEMORY[0x270F969A0](this);
}

uint64_t capabilities::ct::supportsQMIWakeUpForDFC(capabilities::ct *this)
{
  return MEMORY[0x270F969A8](this);
}

uint64_t capabilities::ct::shouldSendWiFiCallStatus(capabilities::ct *this)
{
  return MEMORY[0x270F969B0](this);
}

uint64_t capabilities::ct::supportedPDPContextCount(capabilities::ct *this)
{
  return MEMORY[0x270F969B8](this);
}

uint64_t capabilities::ct::supportsCSFBFastSAReturn(capabilities::ct *this)
{
  return MEMORY[0x270F969C0](this);
}

uint64_t capabilities::ct::supportsNASCallEndReason(capabilities::ct *this)
{
  return MEMORY[0x270F969D0](this);
}

uint64_t capabilities::ct::supportsDataQMIExtensions(capabilities::ct *this)
{
  return MEMORY[0x270F969D8](this);
}

uint64_t capabilities::ct::supportsQualityIndication(capabilities::ct *this)
{
  return MEMORY[0x270F969E8](this);
}

uint64_t capabilities::ct::defaultVinylCardTypeToGSMA(capabilities::ct *this)
{
  return MEMORY[0x270F969F0](this);
}

uint64_t capabilities::ct::supportsUplinkHealthUpdate(capabilities::ct *this)
{
  return MEMORY[0x270F96A08](this);
}

uint64_t capabilities::ct::supportsCapabilityC2KDevice(capabilities::ct *this)
{
  return MEMORY[0x270F96A10](this);
}

uint64_t capabilities::ct::supportsDisableICCIDCommand(capabilities::ct *this)
{
  return MEMORY[0x270F96A18](this);
}

uint64_t capabilities::ct::getSignalStrengthPersonality(capabilities::ct *this)
{
  return MEMORY[0x270F96A20](this);
}

uint64_t capabilities::ct::supports2StepDataCallBringUp(capabilities::ct *this)
{
  return MEMORY[0x270F96A28](this);
}

uint64_t capabilities::ct::supportsPacketFilterCallType(capabilities::ct *this)
{
  return MEMORY[0x270F96A40](this);
}

uint64_t capabilities::ct::getProvisioningProfileSupport(capabilities::ct *this)
{
  return MEMORY[0x270F96A48](this);
}

uint64_t capabilities::ct::supportsCapabilityeHRPDDevice(capabilities::ct *this)
{
  return MEMORY[0x270F96A58](this);
}

uint64_t capabilities::ct::supportsSIMDetectionInterrupt(capabilities::ct *this)
{
  return MEMORY[0x270F96A68](this);
}

uint64_t capabilities::ct::supportsSIMMomentaryPowerDown(capabilities::ct *this)
{
  return MEMORY[0x270F96A70](this);
}

uint64_t capabilities::ct::supportsThroughputEngineering(capabilities::ct *this)
{
  return MEMORY[0x270F96A78](this);
}

uint64_t capabilities::ct::supportsEmergencyQMIExtensions(capabilities::ct *this)
{
  return MEMORY[0x270F96A80](this);
}

uint64_t capabilities::ct::supportsCapabilityTDSCDMADevice(capabilities::ct *this)
{
  return MEMORY[0x270F96A88](this);
}

uint64_t capabilities::ct::supportsDataSystemDetermination(capabilities::ct *this)
{
  return MEMORY[0x270F96A90](this);
}

uint64_t capabilities::ct::supportsEnhanced5GCellularHarvesting(capabilities::ct *this)
{
  return MEMORY[0x270F96AC8](this);
}

uint64_t capabilities::ct::supportsDynamicRRCReleaseVersionUpdate(capabilities::ct *this)
{
  return MEMORY[0x270F96AD8](this);
}

uint64_t capabilities::ct::supportsCompleteCleanupOnFilePushFailure(capabilities::ct *this)
{
  return MEMORY[0x270F96AF0](this);
}

uint64_t capabilities::ct::supportsForceUserConfirmationForSTKCalls(capabilities::ct *this)
{
  return MEMORY[0x270F96AF8](this);
}

uint64_t capabilities::ct::supportsNVRAMUpdateWithoutBasebandReboot(capabilities::ct *this)
{
  return MEMORY[0x270F96B00](this);
}

uint64_t capabilities::ct::supportsReportingTetheringStateToBaseband(capabilities::ct *this)
{
  return MEMORY[0x270F96B08](this);
}

uint64_t capabilities::ct::asString()
{
  return MEMORY[0x270F96B28]();
}

uint64_t capabilities::ipc::supportsCoalescing(capabilities::ipc *this)
{
  return MEMORY[0x270F96C40](this);
}

uint64_t capabilities::euicc::supportsEOS(capabilities::euicc *this)
{
  return MEMORY[0x270F96CA8](this);
}

uint64_t capabilities::radio::supportsMultiClientAWD(capabilities::radio *this)
{
  return MEMORY[0x270F96CF0](this);
}

uint64_t CCPreferences::create(CCPreferences *this)
{
  return MEMORY[0x270EE94A0](this);
}

uint64_t PDPMetricInfo::clear(PDPMetricInfo *this)
{
  return MEMORY[0x270EE8D78](this);
}

void PDPMetricInfo::~PDPMetricInfo(PDPMetricInfo *this)
{
}

uint64_t QMIServiceMsg::create()
{
  return MEMORY[0x270F903F0]();
}

void SelectionItem::~SelectionItem(SelectionItem *this)
{
}

void SetupIdleText::~SetupIdleText(SetupIdleText *this)
{
}

void ActivationInfo::ActivationInfo(ActivationInfo *this)
{
}

uint64_t CSIPhoneNumber::setBaseNumber()
{
  return MEMORY[0x270EE8DB8]();
}

uint64_t CSIPhoneNumber::setTypeOfAddress(CSIPhoneNumber *this)
{
  return MEMORY[0x270EE8DC0](this);
}

void CSIPhoneNumber::CSIPhoneNumber(CSIPhoneNumber *this, const char *a2)
{
}

uint64_t CSIPhoneNumber::CSIPhoneNumber()
{
  return MEMORY[0x270EE8DD0]();
}

{
  return MEMORY[0x270EE8DD8]();
}

void CSIPhoneNumber::CSIPhoneNumber(CSIPhoneNumber *this)
{
}

uint64_t PBCapabilities::SecondName::SecondName(PBCapabilities::SecondName *this)
{
  return MEMORY[0x270EE8DE8](this);
}

uint64_t PBCapabilities::HiddenRecords::HiddenRecords(PBCapabilities::HiddenRecords *this)
{
  return MEMORY[0x270EE8DF0](this);
}

uint64_t PBCapabilities::PrimaryNumber::PrimaryNumber(PBCapabilities::PrimaryNumber *this)
{
  return MEMORY[0x270EE8DF8](this);
}

uint64_t PBCapabilities::AdditionaNumber::AdditionaNumber(PBCapabilities::AdditionaNumber *this)
{
  return MEMORY[0x270EE8E00](this);
}

uint64_t PBCapabilities::Email::Email(PBCapabilities::Email *this)
{
  return MEMORY[0x270EE8E08](this);
}

uint64_t PBCapabilities::Groups::Groups(PBCapabilities::Groups *this)
{
  return MEMORY[0x270EE8E10](this);
}

uint64_t ATCommandDriver::handleCommand_sync()
{
  return MEMORY[0x270EE94B8]();
}

uint64_t ATCommandDriver::getSupportedCommands(ATCommandDriver *this)
{
  return MEMORY[0x270EE94C0](this);
}

uint64_t ATCommandDriver::ATCommandDriver()
{
  return MEMORY[0x270EE94C8]();
}

uint64_t CallAudioDriver::stopLocalDtmf(CallAudioDriver *this)
{
  return MEMORY[0x270EE94D8](this);
}

uint64_t CallAudioDriver::playLocalDtmfDigits()
{
  return MEMORY[0x270EE94E0]();
}

uint64_t CallAudioDriver::CallAudioDriver()
{
  return MEMORY[0x270EE94E8]();
}

void CallAudioDriver::~CallAudioDriver(CallAudioDriver *this)
{
}

void ChipInformation::ChipInformation(ChipInformation *this)
{
}

void NRDisableStatus::NRDisableStatus(NRDisableStatus *this)
{
}

uint64_t AQMCommandDriver::AQMCommandDriver()
{
  return MEMORY[0x270EE94F8]();
}

uint64_t CSIPacketAddress::setPrefixLen(CSIPacketAddress *this)
{
  return MEMORY[0x270EE8E40](this);
}

uint64_t CSIPacketAddress::setIPv6Address(CSIPacketAddress *this, const unsigned __int8 *a2)
{
  return MEMORY[0x270EE8E50](this, a2);
}

uint64_t CSIPacketAddress::applyMaskPrefix(CSIPacketAddress *this)
{
  return MEMORY[0x270EE8E58](this);
}

uint64_t CSIPacketAddress::setIPv4AddressLE(CSIPacketAddress *this)
{
  return MEMORY[0x270EE8E60](this);
}

uint64_t CSIPacketAddress::CSIPacketAddress()
{
  return MEMORY[0x270EE8E68]();
}

void CSIPacketAddress::CSIPacketAddress(CSIPacketAddress *this, const CSIPacketAddress *a2)
{
}

void CSIPacketAddress::CSIPacketAddress(CSIPacketAddress *this)
{
}

uint64_t CSIPacketAddress::operator=()
{
  return MEMORY[0x270EE8E80]();
}

uint64_t DMSCommandDriver::setImeiSvn()
{
  return MEMORY[0x270EE9508]();
}

uint64_t DMSCommandDriver::clearPrlVersion()
{
  return MEMORY[0x270EE9518]();
}

uint64_t DMSCommandDriver::start(DMSCommandDriver *this)
{
  return MEMORY[0x270EE9538](this);
}

uint64_t DMSCommandDriver::setMin()
{
  return MEMORY[0x270EE9540]();
}

uint64_t DMSCommandDriver::setImei()
{
  return MEMORY[0x270EE9548]();
}

uint64_t DMSCommandDriver::setMeid()
{
  return MEMORY[0x270EE9550]();
}

uint64_t DMSCommandDriver::clearMin()
{
  return MEMORY[0x270EE9558]();
}

uint64_t DMSCommandDriver::DMSCommandDriver()
{
  return MEMORY[0x270EE9560]();
}

void DMSCommandDriver::~DMSCommandDriver(DMSCommandDriver *this)
{
}

uint64_t EosCommandDriver::EosCommandDriver()
{
  return MEMORY[0x270EE9570]();
}

void EosCommandDriver::~EosCommandDriver(EosCommandDriver *this)
{
}

uint64_t P2PCommandDriver::P2PCommandDriver()
{
  return MEMORY[0x270EE9580]();
}

void SendShortMessage::~SendShortMessage(SendShortMessage *this)
{
}

uint64_t CallCommandDriver::shouldMTCallContinue(CallCommandDriver *this, uint64_t a2, const CallInfo *a3)
{
  return MEMORY[0x270EE9598](this, a2, a3);
}

uint64_t CallCommandDriver::computeClirValue_sync(CallCommandDriver *this, const CallInfo *a2)
{
  return MEMORY[0x270EE95A0](this, a2);
}

uint64_t CallCommandDriver::shutdown()
{
  return MEMORY[0x270EE95A8]();
}

uint64_t CallCommandDriver::bootstrap()
{
  return MEMORY[0x270EE95B0]();
}

uint64_t CallCommandDriver::CallCommandDriver()
{
  return MEMORY[0x270EE95B8]();
}

void CallCommandDriver::~CallCommandDriver(CallCommandDriver *this)
{
}

void STK_CommandDriver::~STK_CommandDriver(STK_CommandDriver *this)
{
}

uint64_t TrafficDescriptor::TrafficDescriptor()
{
  return MEMORY[0x270EE8E90]();
}

{
  return MEMORY[0x270EE8E98]();
}

void TrafficDescriptor::TrafficDescriptor(TrafficDescriptor *this)
{
}

void TrafficDescriptor::~TrafficDescriptor(TrafficDescriptor *this)
{
}

uint64_t TrafficDescriptor::operator=()
{
  return MEMORY[0x270EE8EB0]();
}

uint64_t AudioCommandDriver::bootstrap()
{
  return MEMORY[0x270EE95D0]();
}

uint64_t AudioCommandDriver::AudioCommandDriver()
{
  return MEMORY[0x270EE95D8]();
}

void EmbmsCommandDriver::~EmbmsCommandDriver(EmbmsCommandDriver *this)
{
}

void VinylCommandDriver::VinylCommandDriver(VinylCommandDriver *this, const char *a2)
{
}

void VinylCommandDriver::~VinylCommandDriver(VinylCommandDriver *this)
{
}

uint64_t CSISMSCommandDriver::CSISMSCommandDriver()
{
  return MEMORY[0x270EE9618]();
}

void CSISMSCommandDriver::~CSISMSCommandDriver(CSISMSCommandDriver *this)
{
}

uint64_t FilePushTransaction::create()
{
  return MEMORY[0x270EE9628]();
}

void FilePushTransaction::~FilePushTransaction(FilePushTransaction *this)
{
}

uint64_t NetworkListOperator::NetworkListOperator()
{
  return MEMORY[0x270EE8EC8]();
}

void PersonalitySpecific::~PersonalitySpecific(PersonalitySpecific *this)
{
}

void StewieCommandDriver::~StewieCommandDriver(StewieCommandDriver *this)
{
}

uint64_t DesenseCommandDriver::addSingleFrequencyToMap()
{
  return MEMORY[0x270EE9640]();
}

uint64_t DesenseCommandDriver::bootstrap()
{
  return MEMORY[0x270EE9648]();
}

uint64_t DesenseCommandDriver::DesenseCommandDriver()
{
  return MEMORY[0x270EE9650]();
}

void DesenseCommandDriver::~DesenseCommandDriver(DesenseCommandDriver *this)
{
}

void LanguageNotification::~LanguageNotification(LanguageNotification *this)
{
}

uint64_t CommandDriversFactory::init()
{
  return MEMORY[0x270EE9668]();
}

void CommandDriversFactory::CommandDriversFactory(CommandDriversFactory *this)
{
}

void CommandDriversFactory::~CommandDriversFactory(CommandDriversFactory *this)
{
}

uint64_t DormancyCommandDriver::DormancyCommandDriver()
{
  return MEMORY[0x270EE9680]();
}

void DormancyCommandDriver::~DormancyCommandDriver(DormancyCommandDriver *this)
{
}

uint64_t NetworkListScanResult::addOperator()
{
  return MEMORY[0x270EE9690]();
}

uint64_t NetworkListScanResult::setState()
{
  return MEMORY[0x270EE9698]();
}

void SetupCallAlphaDisplay::~SetupCallAlphaDisplay(SetupCallAlphaDisplay *this)
{
}

uint64_t AttachApnCommandDriver::start_sync(AttachApnCommandDriver *this)
{
  return MEMORY[0x270EE96A8](this);
}

uint64_t AttachApnCommandDriver::shutdown_sync(AttachApnCommandDriver *this)
{
  return MEMORY[0x270EE96B0](this);
}

uint64_t AttachApnCommandDriver::bootstrap_sync(AttachApnCommandDriver *this)
{
  return MEMORY[0x270EE96B8](this);
}

uint64_t AttachApnCommandDriver::getApnListForType_sync()
{
  return MEMORY[0x270EE96C0]();
}

uint64_t AttachApnCommandDriver::AttachApnCommandDriver()
{
  return MEMORY[0x270EE96C8]();
}

void AttachApnCommandDriver::~AttachApnCommandDriver(AttachApnCommandDriver *this)
{
}

uint64_t BasebandSettingsDriver::readSegment()
{
  return MEMORY[0x270EE96D8]();
}

uint64_t BasebandSettingsDriver::reportFileTransferStatus_sync()
{
  return MEMORY[0x270EE96E0]();
}

uint64_t BasebandSettingsDriver::BasebandSettingsDriver()
{
  return MEMORY[0x270EE96E8]();
}

void BasebandSettingsDriver::~BasebandSettingsDriver(BasebandSettingsDriver *this)
{
}

uint64_t PhonebookCommandDriver::decodeName()
{
  return MEMORY[0x270EE96F8]();
}

uint64_t PhonebookCommandDriver::convertToString()
{
  return MEMORY[0x270EE9700]();
}

uint64_t PhonebookCommandDriver::getVectorForString()
{
  return MEMORY[0x270EE9708]();
}

uint64_t PhonebookCommandDriver::PhonebookCommandDriver()
{
  return MEMORY[0x270EE9710]();
}

void PhonebookCommandDriver::~PhonebookCommandDriver(PhonebookCommandDriver *this)
{
}

void SetupEventUserActivity::~SetupEventUserActivity(SetupEventUserActivity *this)
{
}

uint64_t ActivationCommandDriver::parseImei(ActivationCommandDriver *this, unsigned __int8 *a2)
{
  return MEMORY[0x270EE9730](this, a2);
}

uint64_t ActivationCommandDriver::ActivationCommandDriver()
{
  return MEMORY[0x270EE9738]();
}

void ActivationCommandDriver::~ActivationCommandDriver(ActivationCommandDriver *this)
{
}

uint64_t PersonalitySpecificImpl::PersonalitySpecificImpl()
{
  return MEMORY[0x270EE8EF8]();
}

void PersonalitySpecificImpl::~PersonalitySpecificImpl(PersonalitySpecificImpl *this)
{
}

uint64_t RequestDumpStatePayload::RequestDumpStatePayload()
{
  return MEMORY[0x270EE8F08]();
}

uint64_t CellMonitorCommandDriver::CellMonitorCommandDriver()
{
  return MEMORY[0x270EE9748]();
}

void CellMonitorCommandDriver::~CellMonitorCommandDriver(CellMonitorCommandDriver *this)
{
}

uint64_t EnhancedLQMCommandDriver::EnhancedLQMCommandDriver()
{
  return MEMORY[0x270EE9758]();
}

void EnhancedLQMCommandDriver::~EnhancedLQMCommandDriver(EnhancedLQMCommandDriver *this)
{
}

uint64_t NetworkListCommandDriver::NetworkListCommandDriver()
{
  return MEMORY[0x270EE9768]();
}

void NetworkListCommandDriver::~NetworkListCommandDriver(NetworkListCommandDriver *this)
{
}

void ProvideLocalInfoLanguage::~ProvideLocalInfoLanguage(ProvideLocalInfoLanguage *this)
{
}

uint64_t AudioRoutingCommandDriver::AudioRoutingCommandDriver()
{
  return MEMORY[0x270EE9780]();
}

void CDMASettingsCommandDriver::~CDMASettingsCommandDriver(CDMASettingsCommandDriver *this)
{
}

uint64_t FilePushTransactionResult::FilePushTransactionResult()
{
  return MEMORY[0x270EE9798]();
}

uint64_t NetworkRegistrationDriver::NetworkRegistrationDriver()
{
  return MEMORY[0x270EE97B0]();
}

void NetworkRegistrationDriver::~NetworkRegistrationDriver(NetworkRegistrationDriver *this)
{
}

void SetupCallUserConfirmation::~SetupCallUserConfirmation(SetupCallUserConfirmation *this)
{
}

uint64_t SuppServicesCommandDriver::SuppServicesCommandDriver()
{
  return MEMORY[0x270EE97C8]();
}

void SuppServicesCommandDriver::~SuppServicesCommandDriver(SuppServicesCommandDriver *this)
{
}

uint64_t WiFiSettingsCommandDriver::parseBssid()
{
  return MEMORY[0x270EE97D8]();
}

uint64_t WiFiSettingsCommandDriver::WiFiSettingsCommandDriver()
{
  return MEMORY[0x270EE97E0]();
}

void WiFiSettingsCommandDriver::~WiFiSettingsCommandDriver(WiFiSettingsCommandDriver *this)
{
}

void BBDataFactoryCommandDriver::~BBDataFactoryCommandDriver(BBDataFactoryCommandDriver *this)
{
}

uint64_t NetworkListSelectionResult::NetworkListSelectionResult()
{
  return MEMORY[0x270EE97F8]();
}

void SetupEventIdleScreenNotify::~SetupEventIdleScreenNotify(SetupEventIdleScreenNotify *this)
{
}

void SignalStrengthCommandDriver::~SignalStrengthCommandDriver(SignalStrengthCommandDriver *this)
{
}

void BBDataCommandDriverInterface::~BBDataCommandDriverInterface(BBDataCommandDriverInterface *this)
{
}

uint64_t BBDataContextDriverInterface::getObserver(BBDataContextDriverInterface *this)
{
  return MEMORY[0x270EE9818](this);
}

{
  return MEMORY[0x270EE9970](this);
}

uint64_t BBDataContextDriverInterface::BBDataContextDriverInterface()
{
  return MEMORY[0x270EE9820]();
}

void BBDataContextDriverInterface::~BBDataContextDriverInterface(BBDataContextDriverInterface *this)
{
}

void AttachApnCommandDriverFactory::~AttachApnCommandDriverFactory(AttachApnCommandDriverFactory *this)
{
}

void SubscriptionSlotConfiguration::SubscriptionSlotConfiguration(SubscriptionSlotConfiguration *this)
{
}

uint64_t at::asString()
{
  return MEMORY[0x270EE9838]();
}

uint64_t sd::imsServiceMaskFromUint(sd *this)
{
  return MEMORY[0x270EE8F28](this);
}

uint64_t PreferredNetworksCommandDriver::PreferredNetworksCommandDriver()
{
  return MEMORY[0x270EE8FE8]();
}

void PreferredNetworksCommandDriver::~PreferredNetworksCommandDriver(PreferredNetworksCommandDriver *this)
{
}

void SetupEventLanguageSelectNotify::~SetupEventLanguageSelectNotify(SetupEventLanguageSelectNotify *this)
{
}

void BBDataCommandDriverEventHandler::~BBDataCommandDriverEventHandler(BBDataCommandDriverEventHandler *this)
{
}

uint64_t ES10TapeLoadBoundProfilePackage::getNextPayload()
{
  return MEMORY[0x270EE8FF8]();
}

uint64_t ES10TapeLoadBoundProfilePackage::ES10TapeLoadBoundProfilePackage()
{
  return MEMORY[0x270EE9000]();
}

uint64_t DataSubscriptionBaseCommandDriver::operationCompleted_sync()
{
  return MEMORY[0x270EE9850]();
}

uint64_t DataSubscriptionBaseCommandDriver::DataSubscriptionBaseCommandDriver()
{
  return MEMORY[0x270EE9858]();
}

uint64_t NetworkListCommandDriverResponseError::NetworkListCommandDriverResponseError()
{
  return MEMORY[0x270EE9868]();
}

uint64_t MCC::MCC()
{
  return MEMORY[0x270EE9018]();
}

{
  return MEMORY[0x270EE9028]();
}

void MCC::MCC(MCC *this)
{
}

{
  MEMORY[0x270EE9030](this);
}

void MCC::MCC(MCC *this, const MCC *a2)
{
}

uint64_t MCC::operator=()
{
  return MEMORY[0x270EE9040]();
}

void MNC::MNC(MNC *this, uint64_t a2, const MCC *a3)
{
}

uint64_t MNC::MNC()
{
  return MEMORY[0x270EE9058]();
}

void MNC::MNC(MNC *this)
{
}

uint64_t awd::AwdCommandDriver::AwdCommandDriver()
{
  return MEMORY[0x270EE9870]();
}

void awd::AwdCommandDriver::~AwdCommandDriver(awd::AwdCommandDriver *this)
{
}

uint64_t ctu::MallocZone::MallocZone(ctu::MallocZone *this, const char *a2)
{
  return MEMORY[0x270F97270](this, a2);
}

uint64_t ctu::RestModule::RestModule()
{
  return MEMORY[0x270F97278]();
}

uint64_t ctu::UnfairLock::lock(ctu::UnfairLock *this)
{
  return MEMORY[0x270F97288](this);
}

uint64_t ctu::UnfairLock::unlock(ctu::UnfairLock *this)
{
  return MEMORY[0x270F97290](this);
}

uint64_t ctu::OsLogLogger::OsLogLogger()
{
  return MEMORY[0x270F972B0]();
}

{
  return MEMORY[0x270F972B8]();
}

void ctu::OsLogLogger::~OsLogLogger(ctu::OsLogLogger *this)
{
}

uint64_t ctu::OsLogContext::OsLogContext(ctu::OsLogContext *this, const char *a2, const char *a3)
{
  return MEMORY[0x270F972D8](this, a2, a3);
}

void ctu::OsLogContext::~OsLogContext(ctu::OsLogContext *this)
{
}

uint64_t ctu::TextConverter::pushConversion()
{
  return MEMORY[0x270F97338]();
}

uint64_t ctu::TextConverter::readChars(ctu::TextConverter *this)
{
  return MEMORY[0x270F97378](this);
}

uint64_t ctu::TextConverter::setSource(ctu::TextConverter *this, const char *a2)
{
  return MEMORY[0x270F97380](this, a2);
}

uint64_t ctu::TextConverter::TextConverter(ctu::TextConverter *this)
{
  return MEMORY[0x270F97388](this);
}

void ctu::TextConverter::~TextConverter(ctu::TextConverter *this)
{
}

uint64_t ctu::ResultIsEmptyError::ResultIsEmptyError(ctu::ResultIsEmptyError *this)
{
  return MEMORY[0x270F97458](this);
}

uint64_t ctu::appendLeftoverBits()
{
  return MEMORY[0x270F97470]();
}

uint64_t ctu::appendLabelIfBitSet()
{
  return MEMORY[0x270F97490]();
}

uint64_t ctu::cf::MakeCFString::MakeCFString(ctu::cf::MakeCFString *this, const char *a2)
{
  return MEMORY[0x270F974F0](this, a2);
}

void ctu::cf::MakeCFString::~MakeCFString(ctu::cf::MakeCFString *this)
{
}

uint64_t ctu::cf::convert_copy()
{
  return MEMORY[0x270F97510]();
}

uint64_t ctu::cf::dict_adapter::dict_adapter(ctu::cf::dict_adapter *this, const __CFDictionary *a2)
{
  return MEMORY[0x270F97518](this, a2);
}

uint64_t ctu::cf::dict_adapter::dict_adapter(ctu::cf::dict_adapter *this, const ctu::cf::dict_adapter *a2)
{
  return MEMORY[0x270F97520](this, a2);
}

void ctu::cf::dict_adapter::~dict_adapter(ctu::cf::dict_adapter *this)
{
}

uint64_t ctu::cf::assign()
{
  return MEMORY[0x270F97550]();
}

{
  return MEMORY[0x270F97560]();
}

uint64_t ctu::cf::assign(ctu::cf *this, BOOL *a2, const __CFBoolean *a3)
{
  return MEMORY[0x270F97570](this, a2, a3);
}

uint64_t ctu::cf::assign(ctu::cf *this, unsigned __int8 *a2, const __CFNumber *a3)
{
  return MEMORY[0x270F97578](this, a2, a3);
}

uint64_t ctu::cf::assign(ctu::cf *this, int *a2, const __CFNumber *a3)
{
  return MEMORY[0x270F97580](this, a2, a3);
}

uint64_t ctu::cf::assign(ctu::cf *this, unsigned __int16 *a2, const __CFNumber *a3)
{
  return MEMORY[0x270F97590](this, a2, a3);
}

uint64_t ctu::hex(ctu *this, const void *a2)
{
  return MEMORY[0x270F97628](this, a2);
}

uint64_t ctu::hex()
{
  return MEMORY[0x270F97630]();
}

uint64_t ctu::rest::detail::read_enum_string_value()
{
  return MEMORY[0x270F97698]();
}

uint64_t ctu::rest::detail::write_enum_string_value(ctu::rest::detail *this, uint64_t a2, const char *a3)
{
  return MEMORY[0x270F976A8](this, a2, a3);
}

uint64_t ctu::cf_to_xpc(ctu *this, const void *a2)
{
  return MEMORY[0x270F97778](this, a2);
}

uint64_t ctu::operator<<()
{
  return MEMORY[0x270F977A8]();
}

{
  return MEMORY[0x270F977B8]();
}

{
  return MEMORY[0x270F977C8]();
}

{
  return MEMORY[0x270F977D0]();
}

uint64_t qmi::MessageBase::validateMsgId(qmi::MessageBase *this)
{
  return MEMORY[0x270F96678](this);
}

uint64_t qmi::MessageBase::setParsingErrorHandler(qmi::MessageBase *this, BOOL (*a2)(unsigned __int16, unsigned __int16, const unsigned __int8 *, unint64_t))
{
  return MEMORY[0x270F96680](this, a2);
}

uint64_t qmi::MessageBase::MessageBase(qmi::MessageBase *this, const void *a2)
{
  return MEMORY[0x270F96688](this, a2);
}

{
  return MEMORY[0x270F96698](this, a2);
}

uint64_t qmi::MessageBase::MessageBase()
{
  return MEMORY[0x270F96690]();
}

{
  return MEMORY[0x270F966A0]();
}

void qmi::MessageBase::~MessageBase(qmi::MessageBase *this)
{
}

{
  MEMORY[0x270F966B0](this);
}

uint64_t qmi::ClientRouter::addClient()
{
  return MEMORY[0x270F903F8]();
}

uint64_t qmi::ClientRouter::ClientRouter(qmi::ClientRouter *this, os_log_s *a2)
{
  return MEMORY[0x270F90400](this, a2);
}

uint64_t qmi::ResponseBase::ResponseBase(qmi::ResponseBase *this, const void *a2)
{
  return MEMORY[0x270F966B8](this, a2);
}

{
  return MEMORY[0x270F966C0](this, a2);
}

uint64_t qmi::asShortString()
{
  return MEMORY[0x270F966C8]();
}

uint64_t qmi::isInternalError()
{
  return MEMORY[0x270F966D0]();
}

uint64_t qmi::MutableMessageBase::MutableMessageBase()
{
  return MEMORY[0x270F966E0]();
}

{
  return MEMORY[0x270F966E8]();
}

uint64_t qmi::MutableMessageBase::MutableMessageBase(qmi::MutableMessageBase *this)
{
  return MEMORY[0x270F966F0](this);
}

void qmi::MutableMessageBase::~MutableMessageBase(qmi::MutableMessageBase *this)
{
}

uint64_t qmi::Client::createWithQueue()
{
  return MEMORY[0x270F90408]();
}

uint64_t qmi::Client::createWithQueueLocal()
{
  return MEMORY[0x270F90410]();
}

uint64_t qmi::Client::set(qmi::Client *this, const char *a2)
{
  return MEMORY[0x270F90418](this, a2);
}

{
  return MEMORY[0x270F90420](this, a2);
}

uint64_t qmi::Client::release(qmi::Client *this)
{
  return MEMORY[0x270F90428](this);
}

uint64_t qmi::Client::Client()
{
  return MEMORY[0x270F90430]();
}

void qmi::Client::~Client(qmi::Client *this)
{
}

uint64_t qmi::asString()
{
  return MEMORY[0x270F90440]();
}

{
  return MEMORY[0x270F96700]();
}

uint64_t sms::MTSmsDetails::MTSmsDetails()
{
  return MEMORY[0x270EE9068]();
}

void sms::MTSmsDetails::~MTSmsDetails(sms::MTSmsDetails *this)
{
}

uint64_t sms::Model::setMessageID(sms::Model *this)
{
  return MEMORY[0x270EE9078](this);
}

uint64_t sms::asString()
{
  return MEMORY[0x270EE9090]();
}

uint64_t sms::isRPError(sms *this)
{
  return MEMORY[0x270EE90A0](this);
}

uint64_t stk::truncateLanguageIfNeeded()
{
  return MEMORY[0x270EE9880]();
}

uint64_t xpc::dyn_cast_or_default()
{
  return MEMORY[0x270F977F0]();
}

{
  return MEMORY[0x270F97820]();
}

void PreferredNetworksCommandDriverEventHandler::~PreferredNetworksCommandDriverEventHandler(PreferredNetworksCommandDriverEventHandler *this)
{
}

uint64_t rest::ResetPayload::ResetPayload()
{
  return MEMORY[0x270EE90B0]();
}

uint64_t rest::BandwidthInfo::BandwidthInfo()
{
  return MEMORY[0x270EE90B8]();
}

uint64_t rest::write_rest_value()
{
  return MEMORY[0x270EE90C8]();
}

void SendSS::~SendSS(SendSS *this)
{
}

uint64_t detail::createOsLogLoggers()
{
  return MEMORY[0x270EE90D0]();
}

{
  return MEMORY[0x270EE90D8]();
}

uint64_t detail::createUnknownOsLogLogger()
{
  return MEMORY[0x270EE90E0]();
}

{
  return MEMORY[0x270EE90E8]();
}

void GetInkey::~GetInkey(GetInkey *this)
{
}

void GetInput::~GetInput(GetInput *this)
{
}

void PlayTone::~PlayTone(PlayTone *this)
{
}

uint64_t Registry::getServiceMap(Registry *this)
{
  return MEMORY[0x270EE90F0](this);
}

{
  return MEMORY[0x270EE9340](this);
}

void SendDTMF::~SendDTMF(SendDTMF *this)
{
}

void SendData::~SendData(SendData *this)
{
}

void SendUSSD::~SendUSSD(SendUSSD *this)
{
}

uint64_t printers::asString(printers *this, const BOOL *a2)
{
  return MEMORY[0x270EE9100](this, a2);
}

uint64_t DataUtils::lteishDataMode()
{
  return MEMORY[0x270EE9108]();
}

uint64_t DataUtils::getDataContextName()
{
  return MEMORY[0x270EE9110]();
}

void MCCAndMNC::MCCAndMNC(MCCAndMNC *this, const MCC *a2, const MNC *a3)
{
}

uint64_t MCCAndMNC::MCCAndMNC()
{
  return MEMORY[0x270EE9120]();
}

void MCCAndMNC::MCCAndMNC(MCCAndMNC *this)
{
}

void ModelBase::~ModelBase(ModelBase *this)
{
}

void SetupMenu::~SetupMenu(SetupMenu *this)
{
}

uint64_t subscriber::SimCommandDriver::allowSimRefresh(subscriber::SimCommandDriver *this)
{
  return MEMORY[0x270EE98D0](this);
}

uint64_t subscriber::SimCommandDriver::sendSimDriverInfo()
{
  return MEMORY[0x270EE98D8]();
}

uint64_t subscriber::SimCommandDriver::indexToHardwareSimSlot(subscriber::SimCommandDriver *this)
{
  return MEMORY[0x270EE98E0](this);
}

uint64_t subscriber::SimCommandDriver::checkSimHwIdConfig_sync()
{
  return MEMORY[0x270EE98E8]();
}

uint64_t subscriber::SimCommandDriver::getVinylCapabilitiesFromATR()
{
  return MEMORY[0x270EE98F0]();
}

uint64_t subscriber::SimCommandDriver::appendMissingDriverInfo_sync()
{
  return MEMORY[0x270EE98F8]();
}

uint64_t subscriber::SimCommandDriver::markAllowedToReadCDMAAuxInfo()
{
  return MEMORY[0x270EE9908]();
}

uint64_t QMIServiceMsg::getNewError(QMIServiceMsg *this)
{
  return MEMORY[0x270F90448](this);
}

uint64_t QMIServiceMsg::serialize(QMIServiceMsg *this)
{
  return MEMORY[0x270F90450](this);
}

uint64_t CSIPhoneNumber::getBaseNumber(CSIPhoneNumber *this)
{
  return MEMORY[0x270EE9170](this);
}

uint64_t CSIPhoneNumber::getFullNumber(CSIPhoneNumber *this)
{
  return MEMORY[0x270EE9178](this);
}

uint64_t CSIPhoneNumber::getTypeOfAddress(CSIPhoneNumber *this)
{
  return MEMORY[0x270EE9180](this);
}

uint64_t CSIPacketAddress::isLinkLocal(CSIPacketAddress *this)
{
  return MEMORY[0x270EE9190](this);
}

uint64_t CSIPacketAddress::getPrefixLen(CSIPacketAddress *this)
{
  return MEMORY[0x270EE9198](this);
}

uint64_t CSIPacketAddress::maskToPrefix(CSIPacketAddress *this)
{
  return MEMORY[0x270EE91A0](this);
}

uint64_t CSIPacketAddress::ipv4PrefixLenToMaskAddr(CSIPacketAddress *this)
{
  return MEMORY[0x270EE91B0](this);
}

uint64_t CSIPacketAddress::isIPv4(CSIPacketAddress *this)
{
  return MEMORY[0x270EE91B8](this);
}

uint64_t CSIPacketAddress::isIPv6(CSIPacketAddress *this)
{
  return MEMORY[0x270EE91C0](this);
}

uint64_t CSIPacketAddress::toIPv6(CSIPacketAddress *this, unsigned __int8 *a2)
{
  return MEMORY[0x270EE91D0](this, a2);
}

uint64_t CSIPacketAddress::isZeroIP(CSIPacketAddress *this)
{
  return MEMORY[0x270EE91D8](this);
}

uint64_t CSIPacketAddress::toIPv4LE(CSIPacketAddress *this)
{
  return MEMORY[0x270EE91E0](this);
}

uint64_t CSIPacketAddress::operator std::string()
{
  return MEMORY[0x270EE91E8]();
}

uint64_t CSIPacketAddress::operator==()
{
  return MEMORY[0x270EE91F0]();
}

uint64_t EosCommandDriver::publishEosStatus()
{
  return MEMORY[0x270EE9918]();
}

uint64_t EosCommandDriver::getName(EosCommandDriver *this)
{
  return MEMORY[0x270EE9920](this);
}

uint64_t CallCommandDriver::carrierSupportsCallingTimewithFWIM()
{
  return MEMORY[0x270EE9928]();
}

uint64_t CallCommandDriver::dumpState(CallCommandDriver *this)
{
  return MEMORY[0x270EE9938](this);
}

uint64_t TrafficDescriptor::hasDnnInfo(TrafficDescriptor *this)
{
  return MEMORY[0x270EE91F8](this);
}

uint64_t TrafficDescriptor::hasBundleInfo(TrafficDescriptor *this)
{
  return MEMORY[0x270EE9200](this);
}

uint64_t TrafficDescriptor::empty(TrafficDescriptor *this)
{
  return MEMORY[0x270EE9208](this);
}

uint64_t TrafficDescriptor::toString(TrafficDescriptor *this)
{
  return MEMORY[0x270EE9210](this);
}

uint64_t VinylCommandDriver::sendReadyCallback_sync()
{
  return MEMORY[0x270EE9940]();
}

uint64_t CSISMSCommandDriver::handleSmsSendTimeout()
{
  return MEMORY[0x270EE9948]();
}

uint64_t NetworkListOperator::getMCC(NetworkListOperator *this)
{
  return MEMORY[0x270EE9238](this);
}

uint64_t NetworkListOperator::getMNC(NetworkListOperator *this)
{
  return MEMORY[0x270EE9240](this);
}

uint64_t NetworkListOperator::getRAT(NetworkListOperator *this)
{
  return MEMORY[0x270EE9248](this);
}

uint64_t PersonalitySpecificImpl::simSlot(PersonalitySpecificImpl *this)
{
  return MEMORY[0x270EE9278](this);
}

uint64_t SuppServicesCommandDriver::supportsCallWaitingServiceClass()
{
  return MEMORY[0x270EE9968]();
}

uint64_t SubscriptionSlotConfiguration::isValid()
{
  return MEMORY[0x270EE9288]();
}

uint64_t DataSubscriptionBaseCommandDriver::isValidSlot_sync()
{
  return MEMORY[0x270EE9978]();
}

uint64_t MCC::getIntValue(MCC *this)
{
  return MEMORY[0x270EE92E8](this);
}

uint64_t MCC::getStringValue(MCC *this)
{
  return MEMORY[0x270EE92F0](this);
}

uint64_t MCC::valid(MCC *this)
{
  return MEMORY[0x270EE92F8](this);
}

uint64_t MNC::isThreeDigit(MNC *this)
{
  return MEMORY[0x270EE9308](this);
}

uint64_t MNC::getIntegerWidth(MNC *this)
{
  return MEMORY[0x270EE9310](this);
}

uint64_t awd::AppContext::submitTrigger()
{
  return MEMORY[0x270EE9988]();
}

uint64_t awd::AppContext::getAppSettings(awd::AppContext *this)
{
  return MEMORY[0x270EE9990](this);
}

uint64_t awd::AppContext::postResultToHandler()
{
  return MEMORY[0x270EE9998]();
}

uint64_t awd::AppContext::submitMetricPayload()
{
  return MEMORY[0x270EE99A0]();
}

uint64_t awd::AppContext::updateAppSettingsUsed()
{
  return MEMORY[0x270EE99A8]();
}

uint64_t awd::AppContext::sendConfigurationResult(awd::AppContext *this)
{
  return MEMORY[0x270EE99B0](this);
}

uint64_t awd::AppContext::markMetricSubmissionComplete()
{
  return MEMORY[0x270EE99B8]();
}

uint64_t awd::AppContext::getAppID(awd::AppContext *this)
{
  return MEMORY[0x270EE99C0](this);
}

uint64_t awd::AwdCommandDriver::getName(awd::AwdCommandDriver *this)
{
  return MEMORY[0x270EE99D0](this);
}

uint64_t ctu::MallocZone::free(ctu::MallocZone *this, void *a2)
{
  return MEMORY[0x270F97840](this, a2);
}

uint64_t ctu::MallocZone::malloc(ctu::MallocZone *this)
{
  return MEMORY[0x270F97848](this);
}

uint64_t ctu::MallocZone::operator==()
{
  return MEMORY[0x270F97850]();
}

uint64_t ctu::RestModule::disconnect(ctu::RestModule *this)
{
  return MEMORY[0x270F97858](this);
}

uint64_t ctu::RestModule::setProperty()
{
  return MEMORY[0x270F97868]();
}

uint64_t ctu::RestModule::observeEvent()
{
  return MEMORY[0x270F97870]();
}

uint64_t ctu::RestModule::observeProperty()
{
  return MEMORY[0x270F97880]();
}

uint64_t ctu::RestModule::connect()
{
  return MEMORY[0x270F97888]();
}

uint64_t ctu::RestModule::sendEvent()
{
  return MEMORY[0x270F97898]();
}

uint64_t ctu::cf::map_adapter::getInt(ctu::cf::map_adapter *this, const __CFString *a2)
{
  return MEMORY[0x270F97908](this, a2);
}

uint64_t ctu::cf::map_adapter::getBool(ctu::cf::map_adapter *this, const __CFString *a2)
{
  return MEMORY[0x270F97910](this, a2);
}

uint64_t ctu::cf::map_adapter::getString()
{
  return MEMORY[0x270F97920]();
}

uint64_t qmi::MessageBase::findNextTlv()
{
  return MEMORY[0x270F96708]();
}

uint64_t qmi::MessageBase::findTlvValue(qmi::MessageBase *this)
{
  return MEMORY[0x270F96710](this);
}

uint64_t qmi::ClientRouter::setHandler()
{
  return MEMORY[0x270F90458]();
}

uint64_t qmi::ClientRouter::setIndShouldWake(qmi::ClientRouter *this)
{
  return MEMORY[0x270F90460](this);
}

uint64_t qmi::ClientRouter::setIndHandlerInternal()
{
  return MEMORY[0x270F90468]();
}

uint64_t qmi::ClientRouter::get()
{
  return MEMORY[0x270F90470]();
}

uint64_t qmi::ClientRouter::has()
{
  return MEMORY[0x270F90478]();
}

uint64_t qmi::ClientRouter::stop()
{
  return MEMORY[0x270F90480]();
}

uint64_t qmi::ClientRouter::start()
{
  return MEMORY[0x270F90488]();
}

uint64_t qmi::Client::getSvcType(qmi::Client *this)
{
  return MEMORY[0x270F90490](this);
}

uint64_t qmi::Client::setHandler()
{
  return MEMORY[0x270F90498]();
}

{
  return MEMORY[0x270F904A0]();
}

uint64_t qmi::Client::setIndHandler()
{
  return MEMORY[0x270F904A8]();
}

uint64_t qmi::Client::setIndShouldWake(qmi::Client *this)
{
  return MEMORY[0x270F904B0](this);
}

uint64_t qmi::Client::send()
{
  return MEMORY[0x270F904B8]();
}

uint64_t qmi::Client::stop(qmi::Client *this)
{
  return MEMORY[0x270F904C0](this);
}

uint64_t qmi::Client::start(qmi::Client *this)
{
  return MEMORY[0x270F904C8](this);
}

uint64_t qmi::Client::getName(qmi::Client *this)
{
  return MEMORY[0x270F904D0](this);
}

uint64_t qmi::Client::operator std::weak_ptr<qmi::Client::State>()
{
  return MEMORY[0x270F904D8]();
}

uint64_t sms::Model::getMessageID(sms::Model *this)
{
  return MEMORY[0x270EE9318](this);
}

uint64_t sms::Model::getTransportType(sms::Model *this)
{
  return MEMORY[0x270EE9320](this);
}

uint64_t xpc::object::to_string(xpc::object *this)
{
  return MEMORY[0x270F97948](this);
}

uint64_t CallInfo::getCCDisconnectErrorCode(CallInfo *this)
{
  return MEMORY[0x270EE9328](this);
}

uint64_t CallInfo::toString(CallInfo *this)
{
  return MEMORY[0x270EE9330](this);
}

uint64_t CallInfo::operator BOOL()
{
  return MEMORY[0x270EE9338]();
}

uint64_t Registry::getTimerService(Registry *this)
{
  return MEMORY[0x270EE9348](this);
}

uint64_t Registry::getServerConnection(Registry *this)
{
  return MEMORY[0x270EE9358](this);
}

uint64_t Registry::createRestModuleOneTimeUseConnection(Registry *this)
{
  return MEMORY[0x270EE9370](this);
}

uint64_t MCCAndMNC::getMcc(MCCAndMNC *this)
{
  return MEMORY[0x270EE9378](this);
}

uint64_t MCCAndMNC::getMnc(MCCAndMNC *this)
{
  return MEMORY[0x270EE9380](this);
}

int std::string::compare(const std::string *this, const std::string::value_type *__s)
{
  return MEMORY[0x270F98248](this, __s);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x270F982E8](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x270F982F8](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x270F98330](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const std::string *a2)
{
  return (std::logic_error *)MEMORY[0x270F98338](this, a2);
}

void std::out_of_range::~out_of_range(std::out_of_range *this)
{
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x270F983B0](this, a2);
}

{
  return (std::runtime_error *)MEMORY[0x270F983C8](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::runtime_error *a2)
{
  return (std::runtime_error *)MEMORY[0x270F983D8](this, a2);
}

void std::runtime_error::~runtime_error(std::runtime_error *this)
{
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x270F98428](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x270F98458](__n);
}

void std::string::__grow_by_and_replace(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add, const std::string::value_type *__p_new_stuff)
{
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x270F984A0](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x270F984E8](this, __pos, __s, __n);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
}

void std::string::reserve(std::string *this, std::string::size_type __requested_capacity)
{
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x270F98560](this, __str);
}

uint64_t std::istream::read()
{
  return MEMORY[0x270F98678]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x270F98740]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x270F98748]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x270F98758]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x270F98760]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x270F98770]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x270F98788]();
}

{
  return MEMORY[0x270F987A8]();
}

{
  return MEMORY[0x270F987B0]();
}

{
  return MEMORY[0x270F987C8]();
}

{
  return MEMORY[0x270F987D0]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x270F98870]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x270F988A8]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x270F988B0]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x270F989E8](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

void std::mutex::~mutex(std::mutex *this)
{
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x270F98DE8]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x270F98E08](retstr, *(void *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x270F98E10](retstr, *(void *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return (std::string *)MEMORY[0x270F98E20](retstr, __val);
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

uint64_t operator<<()
{
  return MEMORY[0x270EE9398]();
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

uint64_t __TUAssertTrigger()
{
  return MEMORY[0x270F97950]();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x270F98EC0](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x270ED7DA0](lpfunc, obj, lpdso_handle);
}

void __cxa_bad_cast(void)
{
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x270F98ED8](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x270F98F10](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d)
{
  return (void *)MEMORY[0x270F98F30](lpsrc, lpstype, lpdtype, s2d);
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x270ED8070]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void bzero(void *a1, size_t a2)
{
}

uint64_t ctConvertLteBandToMask()
{
  return MEMORY[0x270EE99D8]();
}

uint64_t ctConvertNrBandToMask()
{
  return MEMORY[0x270EE99E0]();
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

void dispatch_barrier_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x270ED9318](identifier, flags);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x270ED9340]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_group_notify_f(dispatch_group_t group, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x270ED9458](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x270ED9460](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x270ED95A8](when, delta);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x270ED9D98](a1, a2);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

void os_release(void *object)
{
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF60](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF70](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x270EDAFA0](a1, a2);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x270EDB510](__str, __size, __format);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDB5B0](__s1, __s2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

time_t time(time_t *a1)
{
  return MEMORY[0x270EDB930](a1);
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return MEMORY[0x270EDBD38](xarray);
}

xpc_object_t xpc_array_get_value(xpc_object_t xarray, size_t index)
{
  return (xpc_object_t)MEMORY[0x270EDBD88](xarray, index);
}

xpc_object_t xpc_BOOL_create(BOOL value)
{
  return (xpc_object_t)MEMORY[0x270EDBDD8](value);
}

xpc_connection_t xpc_connection_create_from_endpoint(xpc_endpoint_t endpoint)
{
  return (xpc_connection_t)MEMORY[0x270EDBE48](endpoint);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x270EDC008](keys, values, count);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x270EDC0C0](xdict, key);
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x270EDC200](object);
}

xpc_object_t xpc_null_create(void)
{
  return (xpc_object_t)MEMORY[0x270EDC290]();
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x270EDC2B8](object);
}