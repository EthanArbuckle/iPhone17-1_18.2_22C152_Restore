void sub_100345920(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100345958(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019BA740)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100345998()
{
  return &off_1019BA740;
}

uint64_t sub_1003459A4(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v3;
  uint64_t v4 = *((void *)a2 + 4);
  *(void *)(a1 + 24) = *((void *)a2 + 3);
  *(void *)(a1 + 32) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 40) = 0;
  uint64_t v5 = a1 + 40;
  if (*((unsigned char *)a2 + 40)) {
    sub_1000C5A48(v5, (uint64_t)(a2 + 3));
  }
  return a1;
}

void sub_100345A08(_Unwind_Exception *exception_object)
{
  long long v3 = *(std::__shared_weak_count **)(v1 + 32);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100345A20(uint64_t a1)
{
  sub_1000C5D34((unsigned char *)(a1 + 40));
  v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void sub_100345A70()
{
}

void *sub_100345A84()
{
  result = operator new(0x10uLL);
  void *result = off_1019BA760;
  return result;
}

void sub_100345ABC(uint64_t a1, void *a2)
{
  *a2 = off_1019BA760;
}

uint64_t sub_100345AE8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019BA7C0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100345B28()
{
  return &off_1019BA7C0;
}

uint64_t sub_100345B34(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100345BCC(void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100345C50(void *a1)
{
  *a1 = off_1019BA7E0;
  sub_100345BCC(a1 + 2);
  return a1;
}

void sub_100345C94(void *a1)
{
  *a1 = off_1019BA7E0;
  sub_100345BCC(a1 + 2);

  operator delete();
}

void *sub_100345CF8(uint64_t a1)
{
  v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_1019BA7E0;
  v2[1] = v3;
  sub_100345B34((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100345D50(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100345D64(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_1019BA7E0;
  a2[1] = v2;
  return sub_100345B34((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100345D94(uint64_t a1)
{
  return sub_100345BCC((void *)(a1 + 16));
}

void sub_100345D9C(void *a1)
{
  sub_100345BCC(a1 + 2);

  operator delete(a1);
}

void sub_100345DD8(uint64_t a1, const std::string *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v4 + 1496))
  {
    v7 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = (void *)(v4 + 744);
      if (*(char *)(v4 + 767) < 0) {
        v8 = (void *)*v8;
      }
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v9 = a2;
      }
      else {
        v9 = (const std::string *)a2->__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 136315394;
      *(void *)&buf[4] = v8;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Provisioning Websheet URL %s [%s]", buf, 0x16u);
    }
    std::string::size_type size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
    if ((size & 0x80u) != 0) {
      std::string::size_type size = a2->__r_.__value_.__l.__size_;
    }
    if (!size) {
      goto LABEL_22;
    }
    uint64_t v11 = *(unsigned __int8 *)(a3 + 23);
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *(void *)(a3 + 8);
    }
    if (v11)
    {
      if (!*(unsigned char *)(v4 + 1104))
      {
        uint64_t v19 = 0;
        long long v21 = 0u;
        *(_OWORD *)__p = 0u;
        memset(v18, 0, sizeof(v18));
        memset(buf, 0, sizeof(buf));
        v20 = &v21;
        char v22 = 1;
        sub_10034620C(v4 + 768, (uint64_t)buf);
        sub_1003107E0((uint64_t)buf);
      }
      sub_100058DB0(buf, "handoffToken");
      v15 = buf;
      v12 = sub_100327F4C((uint64_t **)(v4 + 1080), (void **)buf, (uint64_t)&unk_10144E20E, (_OWORD **)&v15);
      std::string::operator=((std::string *)((char *)v12 + 56), a2);
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      sub_100058DB0(buf, "podIdentifier");
      v15 = buf;
      v13 = sub_100327F4C((uint64_t **)(v4 + 1080), (void **)buf, (uint64_t)&unk_10144E20E, (_OWORD **)&v15);
      std::string::operator=((std::string *)((char *)v13 + 56), (const std::string *)a3);
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      char v14 = 1;
    }
    else
    {
LABEL_22:
      char v14 = 0;
    }
    sub_100305208(a1 + 16, v14);
    sub_1003052D4(v4 + 712);
  }
  else
  {
    char v23 = 0;
    char v24 = 0;
    char v25 = 0;
    char v26 = 0;
    char v27 = 0;
    BYTE8(v18[0]) = 0;
    sub_100305208(a1 + 16, 0);
    sub_1003107E0((uint64_t)v18 + 8);
  }
}

void sub_1003460C0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100346140(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100346180()
{
}

uint64_t sub_10034618C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void sub_10034620C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 336) == *(unsigned __int8 *)(a2 + 336))
  {
    if (*(unsigned char *)(a1 + 336))
    {
      if (*(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
      long long v4 = *(_OWORD *)a2;
      *(void *)(a1 + 16) = *(void *)(a2 + 16);
      *(_OWORD *)a1 = v4;
      *(unsigned char *)(a2 + 23) = 0;
      *(unsigned char *)a2 = 0;
      sub_1003463A0(a1 + 24, (long long *)(a2 + 24));
      uint64_t v5 = (void **)(a1 + 256);
      if (*(char *)(a1 + 279) < 0) {
        operator delete(*v5);
      }
      long long v6 = *(_OWORD *)(a2 + 256);
      *(void *)(a1 + 272) = *(void *)(a2 + 272);
      *(_OWORD *)uint64_t v5 = v6;
      *(unsigned char *)(a2 + 279) = 0;
      *(unsigned char *)(a2 + 256) = 0;
      sub_1003464A0(a1 + 280, a2 + 280);
      sub_10034654C(a1 + 312, (void *)(a2 + 312));
    }
  }
  else if (*(unsigned char *)(a1 + 336))
  {
    sub_100346324(a1);
  }
  else
  {
    sub_1003465B8(a1, (long long *)a2);
    *(unsigned char *)(a1 + 336) = 1;
  }
}

void sub_100346324(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 336))
  {
    sub_10010C0E0(a1 + 312, *(void **)(a1 + 320));
    if (*(unsigned char *)(a1 + 280))
    {
      if (*(char *)(a1 + 311) < 0) {
        operator delete(*(void **)(a1 + 288));
      }
      *(unsigned char *)(a1 + 280) = 0;
    }
    if (*(char *)(a1 + 279) < 0) {
      operator delete(*(void **)(a1 + 256));
    }
    sub_10031085C(a1 + 24);
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(unsigned char *)(a1 + 336) = 0;
  }
}

uint64_t sub_1003463A0(uint64_t a1, long long *a2)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  uint64_t v5 = (void **)(a1 + 24);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*v5);
  }
  long long v6 = *(long long *)((char *)a2 + 24);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *(_OWORD *)uint64_t v5 = v6;
  *((unsigned char *)a2 + 47) = 0;
  *((unsigned char *)a2 + 24) = 0;
  sub_10005CBB4((uint64_t *)(a1 + 48));
  *(_OWORD *)(a1 + 48) = a2[3];
  *(void *)(a1 + 64) = *((void *)a2 + 8);
  *((void *)a2 + 6) = 0;
  *((void *)a2 + 7) = 0;
  *((void *)a2 + 8) = 0;
  sub_1003464A0(a1 + 72, (uint64_t)a2 + 72);
  sub_1003464A0(a1 + 104, (uint64_t)a2 + 104);
  sub_1003464A0(a1 + 136, (uint64_t)a2 + 136);
  *(void *)(a1 + 168) = *((void *)a2 + 21);
  sub_1003464A0(a1 + 176, (uint64_t)(a2 + 11));
  long long v7 = a2[13];
  *(_WORD *)(a1 + 224) = *((_WORD *)a2 + 112);
  *(_OWORD *)(a1 + 208) = v7;
  return a1;
}

void sub_1003464A0(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a1)
  {
    if (*(unsigned char *)a2)
    {
      long long v4 = (long long *)(a2 + 8);
      uint64_t v5 = (void **)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        operator delete(*v5);
      }
      long long v6 = *v4;
      *(void *)(a1 + 24) = *(void *)(a2 + 24);
      *(_OWORD *)uint64_t v5 = v6;
      *(unsigned char *)(a2 + 31) = 0;
      *(unsigned char *)(a2 + 8) = 0;
    }
    else
    {
      if (*(char *)(a1 + 31) < 0) {
        operator delete(*(void **)(a1 + 8));
      }
      *(unsigned char *)a1 = 0;
    }
  }
  else if (*(unsigned char *)a2)
  {
    long long v7 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v7;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 8) = 0;
    *(unsigned char *)a1 = 1;
  }
}

void sub_10034654C(uint64_t a1, void *a2)
{
  long long v4 = (void *)(a1 + 8);
  sub_10010C0E0(a1, *(void **)(a1 + 8));
  *(void *)a1 = *a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = a2[1];
  *long long v4 = v6;
  uint64_t v7 = a2[2];
  *(void *)(a1 + 16) = v7;
  if (v7)
  {
    *(void *)(v6 + 16) = v4;
    *a2 = v5;
    *uint64_t v5 = 0;
    a2[2] = 0;
  }
  else
  {
    *(void *)a1 = v4;
  }
}

uint64_t sub_1003465B8(uint64_t result, long long *a2)
{
  long long v2 = *a2;
  *(void *)(result + 16) = *((void *)a2 + 2);
  *(_OWORD *)result = v2;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  long long v3 = *(long long *)((char *)a2 + 24);
  *(void *)(result + 40) = *((void *)a2 + 5);
  *(_OWORD *)(result + 24) = v3;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 3) = 0;
  long long v4 = a2[3];
  *(void *)(result + 64) = *((void *)a2 + 8);
  *(_OWORD *)(result + 48) = v4;
  *((void *)a2 + 7) = 0;
  *((void *)a2 + 8) = 0;
  *((void *)a2 + 6) = 0;
  *(void *)(result + 72) = 0;
  *(void *)(result + 80) = 0;
  *(void *)(result + 88) = 0;
  *(_OWORD *)(result + 72) = *(long long *)((char *)a2 + 72);
  *(void *)(result + 88) = *((void *)a2 + 11);
  *((void *)a2 + 9) = 0;
  *((void *)a2 + 10) = 0;
  *((void *)a2 + 11) = 0;
  *(unsigned char *)(result + 96) = 0;
  if (*((unsigned char *)a2 + 96))
  {
    long long v5 = *(long long *)((char *)a2 + 104);
    *(void *)(result + 120) = *((void *)a2 + 15);
    *(_OWORD *)(result + 104) = v5;
    *((void *)a2 + 14) = 0;
    *((void *)a2 + 15) = 0;
    *((void *)a2 + 13) = 0;
    *(unsigned char *)(result + 96) = 1;
  }
  *(unsigned char *)(result + 128) = 0;
  if (*((unsigned char *)a2 + 128))
  {
    long long v6 = *(long long *)((char *)a2 + 136);
    *(void *)(result + 152) = *((void *)a2 + 19);
    *(_OWORD *)(result + 136) = v6;
    *((void *)a2 + 18) = 0;
    *((void *)a2 + 19) = 0;
    *((void *)a2 + 17) = 0;
    *(unsigned char *)(result + 128) = 1;
  }
  *(unsigned char *)(result + 160) = 0;
  if (*((unsigned char *)a2 + 160))
  {
    long long v7 = *(long long *)((char *)a2 + 168);
    *(void *)(result + 184) = *((void *)a2 + 23);
    *(_OWORD *)(result + 168) = v7;
    *((void *)a2 + 22) = 0;
    *((void *)a2 + 23) = 0;
    *((void *)a2 + 21) = 0;
    *(unsigned char *)(result + 160) = 1;
  }
  *(void *)(result + 192) = *((void *)a2 + 24);
  *(unsigned char *)(result + 200) = 0;
  if (*((unsigned char *)a2 + 200))
  {
    long long v8 = a2[13];
    *(void *)(result + 224) = *((void *)a2 + 28);
    *(_OWORD *)(result + 208) = v8;
    *((void *)a2 + 27) = 0;
    *((void *)a2 + 28) = 0;
    *((void *)a2 + 26) = 0;
    *(unsigned char *)(result + 200) = 1;
  }
  long long v9 = *(long long *)((char *)a2 + 232);
  *(_WORD *)(result + 248) = *((_WORD *)a2 + 124);
  *(_OWORD *)(result + 232) = v9;
  long long v10 = a2[16];
  *(void *)(result + 272) = *((void *)a2 + 34);
  *(_OWORD *)(result + 256) = v10;
  *((void *)a2 + 33) = 0;
  *((void *)a2 + 34) = 0;
  *((void *)a2 + 32) = 0;
  *(unsigned char *)(result + 280) = 0;
  if (*((unsigned char *)a2 + 280))
  {
    long long v11 = a2[18];
    *(void *)(result + 304) = *((void *)a2 + 38);
    *(_OWORD *)(result + 288) = v11;
    *((void *)a2 + 37) = 0;
    *((void *)a2 + 38) = 0;
    *((void *)a2 + 36) = 0;
    *(unsigned char *)(result + 280) = 1;
  }
  *(void *)(result + 312) = *((void *)a2 + 39);
  uint64_t v12 = result + 320;
  uint64_t v13 = *((void *)a2 + 40);
  *(void *)(result + 320) = v13;
  uint64_t v14 = *((void *)a2 + 41);
  *(void *)(result + 328) = v14;
  if (v14)
  {
    *(void *)(v13 + 16) = v12;
    *((void *)a2 + 39) = a2 + 20;
    *((void *)a2 + 40) = 0;
    *((void *)a2 + 41) = 0;
  }
  else
  {
    *(void *)(result + 312) = v12;
  }
  return result;
}

uint64_t sub_100346768(unsigned char *a1, uint64_t a2)
{
  sub_1003467F0(a1 + 8, a2);
  sub_100346CC8(a1 + 352, a2 + 344);
  uint64_t result = sub_1000593FC((uint64_t)(a1 + 704), (long long *)(a2 + 696));
  *a1 = 1;
  return result;
}

void sub_1003467C4(_Unwind_Exception *a1)
{
  if (*(unsigned char *)(v2 + 696)) {
    sub_100310520(v3);
  }
  sub_1003107E0(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_1003467F0(unsigned char *__dst, uint64_t a2)
{
  *__dst = 0;
  __dst[336] = 0;
  if (*(unsigned char *)(a2 + 336))
  {
    sub_100346848(__dst, (long long *)a2);
    __dst[336] = 1;
  }
  return __dst;
}

void sub_100346834(_Unwind_Exception *a1)
{
  sub_1003107E0(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_100346848(unsigned char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__dst = v4;
  }
  sub_10034696C(__dst + 24, (long long *)((char *)a2 + 24));
  if (*((char *)a2 + 279) < 0)
  {
    sub_10004FC84(__dst + 256, *((void **)a2 + 32), *((void *)a2 + 33));
  }
  else
  {
    long long v5 = a2[16];
    *((void *)__dst + 34) = *((void *)a2 + 34);
    *((_OWORD *)__dst + 16) = v5;
  }
  sub_100311E70((uint64_t)(__dst + 280), (uint64_t)a2 + 280);
  sub_100346B40((uint64_t)(__dst + 312), (uint64_t)a2 + 312);
  return __dst;
}

void sub_100346904(_Unwind_Exception *a1)
{
  sub_10031085C(v2);
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(a1);
}

char *sub_10034696C(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  *((void *)__dst + 6) = 0;
  *((void *)__dst + 7) = 0;
  *((void *)__dst + 8) = 0;
  sub_1000302C0(__dst + 48, *((long long **)a2 + 6), *((long long **)a2 + 7), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a2 + 7) - *((void *)a2 + 6)) >> 3));
  sub_100311E70((uint64_t)(__dst + 72), (uint64_t)a2 + 72);
  sub_100311E70((uint64_t)(__dst + 104), (uint64_t)a2 + 104);
  sub_100311E70((uint64_t)(__dst + 136), (uint64_t)a2 + 136);
  *((void *)__dst + 21) = *((void *)a2 + 21);
  sub_100311E70((uint64_t)(__dst + 176), (uint64_t)(a2 + 11));
  long long v6 = a2[13];
  *((_WORD *)__dst + 112) = *((_WORD *)a2 + 112);
  *((_OWORD *)__dst + 13) = v6;
  return __dst;
}

void sub_100346A8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (*(char *)(v10 + 23) < 0) {
    operator delete(*(void **)v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100346B40(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  sub_100346B98((char *)a1, *(void ***)a2, (void **)(a2 + 8));
  return a1;
}

void sub_100346B80(_Unwind_Exception *a1)
{
  sub_10010C0E0(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *sub_100346B98(char *result, void **a2, void **a3)
{
  if (a2 != a3)
  {
    long long v4 = a2;
    long long v5 = (uint64_t **)result;
    uint64_t v6 = (uint64_t)(result + 8);
    do
    {
      uint64_t result = sub_100346C24(v5, v6, v4 + 4, (long long *)v4 + 2);
      long long v7 = (void **)v4[1];
      if (v7)
      {
        do
        {
          long long v8 = v7;
          long long v7 = (void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          long long v8 = (void **)v4[2];
          BOOL v9 = *v8 == v4;
          long long v4 = v8;
        }
        while (!v9);
      }
      long long v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

char *sub_100346C24(uint64_t **a1, uint64_t a2, void **a3, long long *a4)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v6 = sub_1000C6D50(a1, a2, &v12, &v11, a3);
  long long v7 = (char *)*v6;
  if (!*v6)
  {
    long long v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_100328CCC((uint64_t)a1, a4, v10);
    sub_100046C38(a1, (uint64_t)v12, v8, (uint64_t *)v10[0]);
    long long v7 = v10[0];
    v10[0] = 0;
    sub_10010E764((uint64_t)v10, 0);
  }
  return v7;
}

unsigned char *sub_100346CC8(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[344] = 0;
  if (*(unsigned char *)(a2 + 344))
  {
    sub_100346D28((uint64_t)a1, a2);
    a1[344] = 1;
  }
  return a1;
}

void sub_100346D0C(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 344)) {
    sub_100310520(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100346D28(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100311E70(a1, a2);
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(v4 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(v4 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(v4 + 32) = v5;
  }
  sub_100346DF8((char *)(a1 + 56), (long long *)(a2 + 56));
  sub_100346DF8((char *)(a1 + 200), (long long *)(a2 + 200));
  return a1;
}

void sub_100346DA8(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)v1)
  {
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    *(unsigned char *)uint64_t v1 = 0;
  }
  _Unwind_Resume(exception_object);
}

char *sub_100346DF8(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__dst = v4;
  }
  *((void *)__dst + 3) = 0;
  *((void *)__dst + 4) = 0;
  *((void *)__dst + 5) = 0;
  sub_100346F54((void *)__dst + 3, *((void *)a2 + 3), *((void *)a2 + 4), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((void *)a2 + 4) - *((void *)a2 + 3)) >> 3));
  __dst[48] = *((unsigned char *)a2 + 48);
  if (*((char *)a2 + 79) < 0)
  {
    sub_10004FC84(__dst + 56, *((void **)a2 + 7), *((void *)a2 + 8));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 56);
    *((void *)__dst + 9) = *((void *)a2 + 9);
    *(_OWORD *)(__dst + 56) = v5;
  }
  sub_100311E70((uint64_t)(__dst + 80), (uint64_t)(a2 + 5));
  sub_100311E70((uint64_t)(__dst + 112), (uint64_t)(a2 + 7));
  return __dst;
}

void sub_100346EE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1003106DC((void ***)va);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  _Unwind_Resume(a1);
}

void *sub_100346F54(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_100311F60(result, a4);
    uint64_t result = (void *)sub_100346FDC((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100346FBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1003106DC(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100346FDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_100347060((void *)(a4 + v7), (long long *)(a2 + v7));
      v7 += 88;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_10034703C(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 88;
    do
    {
      sub_100310760(v4 + v2);
      v2 -= 88;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100347060(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)__dst = v4;
  }
  sub_100311E70((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  sub_100311E70((uint64_t)(__dst + 7), (uint64_t)a2 + 56);
  return __dst;
}

void sub_1003470D4(_Unwind_Exception *exception_object)
{
  if (*v2)
  {
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    unsigned char *v2 = 0;
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100347114(unsigned char *a1)
{
  if (*a1) {
    sub_10034714C((uint64_t)a1);
  }
  return a1;
}

uint64_t sub_10034714C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 728) && *(char *)(a1 + 727) < 0) {
    operator delete(*(void **)(a1 + 704));
  }
  if (*(unsigned char *)(a1 + 696)) {
    sub_100310520(a1 + 352);
  }
  uint64_t result = sub_1003107E0(a1 + 8);
  *(unsigned char *)a1 = 0;
  return result;
}

void sub_1003471A4()
{
}

void *sub_1003471B8()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019BA860;
  return result;
}

void sub_1003471F0(uint64_t a1, void *a2)
{
  *a2 = off_1019BA860;
}

uint64_t sub_10034721C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10034725C()
{
}

void sub_100347268(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_100347268(a1, *(void *)a2);
    sub_100347268(a1, *((void *)a2 + 1));
    long long v4 = (void **)(a2 + 48);
    sub_100047F64(&v4);
    operator delete(a2);
  }
}

void sub_1003472CC()
{
}

void *sub_1003472E0()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019BA8E0;
  return result;
}

void sub_100347318(uint64_t a1, void *a2)
{
  *a2 = off_1019BA8E0;
}

void sub_100347340(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    long long v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)long long v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "CellularPlanProvisioningOngoing", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_1003473B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003473F8()
{
}

void *sub_100347404(void *a1)
{
  *a1 = off_1019BA960;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100347450(void *a1)
{
  *a1 = off_1019BA960;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1003474BC(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019BA960;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100347520(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019BA960;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100347560(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100347570(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1003475B0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[2])
      {
        long long v5 = *(std::__shared_weak_count **)(v3 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_1003476C0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100347700()
{
}

void sub_10034770C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Disabling bootstrap now", buf, 2u);
  }
  uint64_t v3 = *(void *)(v1 + 5568);
  *(void *)(v1 + 5568) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  (*(void (**)(void, void))(**(void **)(v1 + 304) + 280))(*(void *)(v1 + 304), 0);
  operator delete();
}

void sub_100347804()
{
}

void *sub_100347830(void *a1)
{
  *a1 = off_1019BA9E0;
  sub_10030AEBC((uint64_t)(a1 + 2));
  return a1;
}

void sub_100347874(void *a1)
{
  *a1 = off_1019BA9E0;
  sub_10030AEBC((uint64_t)(a1 + 2));

  operator delete();
}

void *sub_1003478D8(uint64_t a1)
{
  uint64_t v2 = operator new(0xD0uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_1019BA9E0;
  v2[1] = v3;
  sub_10030BBA0((unsigned char *)v2 + 16, a1 + 16);
  *((unsigned char *)v2 + 200) = *(unsigned char *)(a1 + 200);
  return v2;
}

void sub_100347938(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_10034794C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)a2 = off_1019BA9E0;
  *(void *)(a2 + 8) = v4;
  uint64_t result = sub_10030BBA0((unsigned char *)(a2 + 16), a1 + 16);
  *(unsigned char *)(a2 + 200) = *(unsigned char *)(a1 + 200);
  return result;
}

uint64_t sub_1003479A4(uint64_t a1)
{
  return sub_10030AEBC(a1 + 16);
}

void sub_1003479AC(void *a1)
{
  sub_10030AEBC((uint64_t)a1 + 16);

  operator delete(a1);
}

void sub_1003479E8(uint64_t a1, uint64_t *a2)
{
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  sub_10030C19C(&v25, *a2, a2[1], 0x6F96F96F96F96F97 * ((a2[1] - *a2) >> 3));
  uint64_t v3 = *(void *)(a1 + 8);
  if (v25 == v26)
  {
    uint64_t v4 = *(void *)(v3 + 192);
    if (v4)
    {
      LOBYTE(v44[0]) = 0;
      char v45 = 0;
      (*(void (**)(uint64_t, void ***))(*(void *)v4 + 24))(v4, v44);
      sub_1000C612C((uint64_t)v44);
    }
  }
  else
  {
    sub_10030BBA0(v44, a1 + 16);
    sub_1002FE1EC(v3, 1, &v25, (uint64_t)v44, 0);
    sub_10030AEBC((uint64_t)v44);
  }
  if (!*(unsigned char *)(a1 + 200) || !sub_1002DDBDC(v3)) {
    goto LABEL_80;
  }
  (***(void (****)(long long *__return_ptr))(v3 + 320))(&__p);
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p);
  uint64_t v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    long long v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      std::string::size_type v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  v37.__r_.__value_.__r.__words[0] = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v37);
  if (!v11)
  {
    uint64_t v13 = 0;
    goto LABEL_14;
  }
  uint64_t v13 = v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (!v12)
  {
LABEL_14:
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_15;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
LABEL_15:
  if (*((void *)&__p + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&__p + 1));
  }
  if (v13)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 24))(v13, 3);
    if (!*(void *)(v3 + 680))
    {
      std::string::size_type v42 = 0;
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(v3 + 160) + 64))(&v40);
      if (!v40)
      {
        v15 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "No data alert helper", (uint8_t *)&__p, 2u);
        }
      }
      long long __p = 0uLL;
      unint64_t v39 = 0;
      sub_100058DB0(&__p, "");
      memset(&v37, 0, sizeof(v37));
      sub_100058DB0(&v37, "");
      memset(&v36, 0, sizeof(v36));
      sub_100058DB0(&v36, "");
      v33 = 0;
      v34 = 0;
      uint64_t v35 = 0;
      sub_1002DCA80(&v33, *(void *)(v3 + 416));
      v16 = v33;
      v17 = v34;
      if (v33 == v34)
      {
        unsigned __int8 v18 = 0;
      }
      else
      {
        unsigned __int8 v18 = 0;
        while (!v16->__r_.__value_.__s.__data_[16])
        {
          if (v16->__r_.__value_.__s.__data_[17])
          {
            if (*(unsigned char *)(v3 + 2289) == 1 && *(unsigned char *)(v3 + 2592) == 1) {
              unsigned __int8 v18 = 2;
            }
            else {
              unsigned __int8 v18 = 3;
            }
            (*(void (**)(uint8_t *__return_ptr))(**(void **)(v3 + 320) + 800))(buf);
            if (SHIBYTE(v39) < 0) {
              operator delete((void *)__p);
            }
            unint64_t v39 = v32;
            long long __p = *(_OWORD *)buf;
            unint64_t v19 = HIBYTE(v32);
            if ((v32 & 0x8000000000000000) != 0) {
              unint64_t v19 = *((void *)&__p + 1);
            }
            if (v19)
            {
              v30 = 0;
              (*(void (**)(std::string *__return_ptr, uint64_t, const std::string *, long long *, const void **))(*(void *)v13 + 80))(&__dst, v13, v16 + 10, &__p, &v30);
              *(void *)buf = v42;
              std::string::size_type v42 = __dst.__r_.__value_.__r.__words[0];
              __dst.__r_.__value_.__r.__words[0] = 0;
              sub_100057D78((const void **)buf);
              sub_100057D78((const void **)&__dst.__r_.__value_.__l.__data_);
              sub_100057D78(&v30);
            }
            std::string::operator=(&v37, v16 + 11);
            std::string::operator=(&v36, v16 + 10);
          }
          v16 += 52;
          if (v16 == v17) {
            goto LABEL_43;
          }
        }
        unsigned __int8 v18 = 1;
      }
LABEL_43:
      if (v42) {
        long long v21 = sub_100080778;
      }
      else {
        long long v21 = 0;
      }
      if (v21 || (*(unsigned int (**)(void))(**(void **)(v3 + 320) + 112))(*(void *)(v3 + 320)))
      {
        char v22 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Show alert to install an user eSIM", buf, 2u);
        }
        uint64_t v23 = v40;
        if (v40)
        {
          if (SHIBYTE(v39) < 0)
          {
            sub_10004FC84(buf, (void *)__p, *((unint64_t *)&__p + 1));
          }
          else
          {
            *(_OWORD *)buf = __p;
            unint64_t v32 = v39;
          }
          if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__dst, v37.__r_.__value_.__l.__data_, v37.__r_.__value_.__l.__size_);
          }
          else {
            std::string __dst = v37;
          }
          if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&v28, v36.__r_.__value_.__l.__data_, v36.__r_.__value_.__l.__size_);
          }
          else {
            std::string v28 = v36;
          }
          (*(void (**)(uint64_t, void, uint8_t *, std::string *, std::string *))(*(void *)v23 + 120))(v23, v18, buf, &__dst, &v28);
          if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v28.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v32) < 0) {
            operator delete(*(void **)buf);
          }
        }
        char v24 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v43 = 0;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Maybe show followup to install a user eSIM", v43, 2u);
        }
        (*(void (**)(uint64_t, uint64_t, std::string::size_type, void))(*(void *)v13 + 16))(v13, 7, v42, 0);
      }
      *(void *)v43 = &v33;
      sub_10030AFC8((void ***)v43);
      if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v36.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v37.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v39) < 0) {
        operator delete((void *)__p);
      }
      if (v41) {
        sub_10004D2C8(v41);
      }
      sub_100057D78((const void **)&v42);
    }
  }
  else
  {
    v20 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "No followupController", (uint8_t *)&__p, 2u);
    }
  }
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
LABEL_80:
  v44[0] = (void **)&v25;
  sub_1000C63B8(v44);
}

void sub_1003480F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,char *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53,uint64_t a54,std::__shared_weak_count *a55,const void *a56,char *a57,uint64_t a58,char a59)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  a57 = &a33;
  sub_10030AFC8((void ***)&a57);
  if (a41 < 0) {
    operator delete(a36);
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  if (a53 < 0) {
    operator delete(a48);
  }
  if (a55) {
    sub_10004D2C8(a55);
  }
  sub_100057D78(&a56);
  if ((v60 & 1) == 0) {
    sub_10004D2C8(v59);
  }
  a42 = &a10;
  sub_1000C63B8((void ***)&a42);
  _Unwind_Resume(a1);
}

uint64_t sub_100348258(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100348298()
{
}

void sub_1003482A8()
{
}

void *sub_1003482BC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019BAA60;
  result[1] = v3;
  return result;
}

uint64_t sub_100348304(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019BAA60;
  a2[1] = v2;
  return result;
}

uint64_t sub_100348330(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(v1 + 304);
  v8[0] = 0;
  v8[240] = 0;
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v2 + 256))(v2, v8);
  sub_10030D044((uint64_t)v8);
  uint64_t v3 = *(void *)(v1 + 288);
  sub_100058DB0(__p, "");
  (*(void (**)(uint64_t, void **))(*(void *)v3 + 72))(v3, __p);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  if (*(char *)(v1 + 615) < 0)
  {
    uint64_t v4 = *(unsigned char **)(v1 + 592);
    *(void *)(v1 + 600) = 0;
  }
  else
  {
    uint64_t v4 = (unsigned char *)(v1 + 592);
    *(unsigned char *)(v1 + 615) = 0;
  }
  *uint64_t v4 = 0;
  *(unsigned char *)(v1 + 1512) = 0;
  *(_DWORD *)(v1 + 576) = 0;
  sub_1002DA714(v1, 0, 1);
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(v1 + 320) + 40))(*(void *)(v1 + 320));
  if (result)
  {
    (*(void (**)(void))(**(void **)(v1 + 336) + 136))(*(void *)(v1 + 336));
    return (*(uint64_t (**)(void))(**(void **)(v1 + 336) + 184))(*(void *)(v1 + 336));
  }
  return result;
}

void sub_1003484D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10034850C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10034854C()
{
}

uint64_t sub_100348558(uint64_t a1)
{
  *(void *)a1 = off_1019BAAE0;
  sub_100060644((void *)(a1 + 1320));
  if (*(unsigned char *)(a1 + 1312)) {
    sub_10030D10C(a1 + 64);
  }
  uint64_t v3 = (void **)(a1 + 40);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1003485D8(uint64_t a1)
{
  *(void *)a1 = off_1019BAAE0;
  sub_100060644((void *)(a1 + 1320));
  if (*(unsigned char *)(a1 + 1312)) {
    sub_10030D10C(a1 + 64);
  }
  uint64_t v2 = (void **)(a1 + 40);
  sub_100047F64(&v2);
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  operator delete();
}

void *sub_10034866C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x548uLL);
  void *v2 = off_1019BAAE0;
  sub_100348A00((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1003486C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1003486D4(uint64_t a1, void *a2)
{
  *a2 = off_1019BAAE0;
  return sub_100348A00((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100348700(uint64_t a1)
{
}

void sub_100348708(void *a1)
{
  sub_100348B08((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100348744(uint64_t a1, unsigned char *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (*a2)
  {
    uint64_t v5 = *(void *)(v4 + 464);
    if (v5) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 184))(v5, a1 + 16);
    }
    uint64_t v6 = *(void *)(v4 + 416);
    if (v6) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 248))(v6, a1 + 40);
    }
  }
  else
  {
    char v7 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Server install notification error", buf, 2u);
    }
    sub_1000607A8(a1 + 1320, 0);
  }
  if (*(unsigned char *)(a1 + 1312) && *(unsigned char *)(a1 + 64) == 7)
  {
    *(void *)buf = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    if (*(unsigned char *)(a1 + 977)) {
      long long v8 = (char *)asString();
    }
    else {
      long long v8 = "";
    }
    sub_100058DB0(buf, v8);
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v12 = 0;
    if (v3) {
      uint64_t v9 = "";
    }
    else {
      uint64_t v9 = (char *)asString();
    }
    sub_100058DB0(__p, v9);
    (*(void (**)(void, uint8_t *, BOOL, void **))(**(void **)(v4 + 432) + 248))(*(void *)(v4 + 432), buf, v3 != 0, __p);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v15) < 0) {
      operator delete(*(void **)buf);
    }
  }
  return sub_1000607A8(a1 + 1320, 1);
}

void sub_100348920(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100348954(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100348994()
{
}

unsigned char *sub_1003489A0(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1248] = 0;
  if (*(unsigned char *)(a2 + 1248))
  {
    sub_1003115D8((uint64_t)a1, (long long *)a2);
    a1[1248] = 1;
  }
  return a1;
}

void sub_1003489E4(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 1248)) {
    sub_10030D10C(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100348A00(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  sub_1000302C0((char *)(a1 + 32), *(long long **)(a2 + 32), *(long long **)(a2 + 40), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3));
  sub_100311A9C((unsigned char *)(a1 + 56), a2 + 56);
  sub_1000DFC90(a1 + 1312, a2 + 1312);
  return a1;
}

void sub_100348AC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(unsigned char *)(v3 + 1304)) {
    sub_10030D10C(v4);
  }
  sub_100047F64((void ***)va);
  if (*(char *)(v3 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(a1);
}

void sub_100348B08(uint64_t a1)
{
  sub_100060644((void *)(a1 + 1312));
  if (*(unsigned char *)(a1 + 1304)) {
    sub_10030D10C(a1 + 56);
  }
  uint64_t v2 = (void **)(a1 + 32);
  sub_100047F64(&v2);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
}

void *sub_100348B68(void *a1)
{
  *a1 = off_1019BAB60;
  sub_100060644(a1 + 2);
  return a1;
}

void sub_100348BAC(void *a1)
{
  *a1 = off_1019BAB60;
  sub_100060644(a1 + 2);

  operator delete();
}

void *sub_100348C10(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_1019BAB60;
  v2[1] = v3;
  sub_1000DFC90((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100348C68(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100348C7C(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_1019BAB60;
  a2[1] = v2;
  return sub_1000DFC90((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100348CAC(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 16));
}

void sub_100348CB4(void *a1)
{
  sub_100060644(a1 + 2);

  operator delete(a1);
}

uint64_t sub_100348CF0(uint64_t a1, unsigned char *a2)
{
  if (*a2)
  {
    uint64_t v3 = a1 + 16;
    return sub_1000607A8(v3, 1);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Server install replace notification error", v6, 2u);
    }
    return sub_1000607A8(a1 + 16, 0);
  }
}

uint64_t sub_100348D98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100348DD8()
{
}

uint64_t sub_100348DE4(uint64_t a1)
{
  *(void *)a1 = off_1019BABE0;
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_100348E84(uint64_t a1)
{
  *(void *)a1 = off_1019BABE0;
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

void *sub_100348F44(uint64_t a1)
{
  uint64_t v2 = operator new(0xC0uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_1019BABE0;
  v2[1] = v3;
  sub_100311AFC((uint64_t)(v2 + 2), (int *)(a1 + 16));
  return v2;
}

void sub_100348F9C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100348FB0(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_1019BABE0;
  a2[1] = v2;
  return sub_100311AFC((uint64_t)(a2 + 2), (int *)(a1 + 16));
}

void sub_100348FE0(uint64_t a1)
{
}

void sub_100348FE8(void *a1)
{
  sub_1003490EC((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100349024(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(unsigned int *)(v3 + 580);
  sub_100311AFC((uint64_t)v6, (int *)(a1 + 16));
  v6[176] = 1;
  sub_1002DAEB8(v3, v4, (uint64_t)v6, v2);
  return sub_10030AEBC((uint64_t)v6);
}

void sub_10034908C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10030AEBC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1003490A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003490E0()
{
}

void sub_1003490EC(uint64_t a1)
{
  if (*(char *)(a1 + 175) < 0) {
    operator delete(*(void **)(a1 + 152));
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 39) < 0)
  {
    int v2 = *(void **)(a1 + 16);
    operator delete(v2);
  }
}

uint64_t sub_100349184(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void *sub_100349204(void *a1)
{
  *a1 = off_1019BAC60;
  sub_100313790(a1 + 2);
  return a1;
}

void sub_100349248(void *a1)
{
  *a1 = off_1019BAC60;
  sub_100313790(a1 + 2);

  operator delete();
}

void *sub_1003492AC(uint64_t a1)
{
  int v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_1019BAC60;
  v2[1] = v3;
  sub_10031F4D0((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100349304(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100349318(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_1019BAC60;
  a2[1] = v2;
  return sub_10031F4D0((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100349348(uint64_t a1)
{
  return sub_100313790((void *)(a1 + 16));
}

void sub_100349350(void *a1)
{
  sub_100313790(a1 + 2);

  operator delete(a1);
}

const void **sub_10034938C(uint64_t a1, char *a2, uint64_t *a3, uint64_t *a4, uint64_t a5, NSObject **a6)
{
  char v7 = *a2;
  if (*a2)
  {
    CFTypeRef cf = 0;
    sub_10031F910(a1 + 16, (uint64_t)&cf, v7);
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 8);
    CFTypeRef cf = 0;
    sub_100307B64((void **)&cf, v9, a3, a4, a5, a6);
    if (*(void *)a5)
    {
      if (**(void **)a5 != *(void *)(*(void *)a5 + 8))
      {
        uint64_t v10 = *(void *)(v9 + 512);
        if (v10) {
          (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
        }
      }
    }
    uint64_t v11 = *(void *)(v9 + 288);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    (*(void (**)(uint64_t, CFAbsoluteTime))(*(void *)v11 + 296))(v11, Current + 1296000.0);
    CFTypeRef v14 = cf;
    if (cf) {
      CFRetain(cf);
    }
    sub_10031F910(a1 + 16, (uint64_t)&v14, 0);
    sub_100044D00(&v14);
  }
  return sub_100044D00(&cf);
}

void sub_1003494AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_1003494D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100349514()
{
}

void sub_100349520(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019BACE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100349540(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019BACE0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100349594(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 24);
  sub_1000C5238(&v1);
}

void sub_1003495C4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019BAD30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1003495E4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019BAD30;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100349638(uint64_t a1)
{
}

void sub_10034964C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10034964C(a1, *a2);
    sub_10034964C(a1, a2[1]);
    sub_1003496A8((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_1003496A8(uint64_t a1)
{
  sub_10030CBA4(a1 + 24);
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void *sub_1003496F8(void *a1)
{
  *a1 = off_1019BAD80;
  uint64_t v2 = a1[9];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[9];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[8];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)a1[4];
  if (v6) {
    sub_10004D2C8(v6);
  }
  return a1;
}

void sub_100349774(void *a1)
{
  *a1 = off_1019BAD80;
  uint64_t v2 = a1[9];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[9];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[8];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)a1[4];
  if (v6) {
    sub_10004D2C8(v6);
  }

  operator delete();
}

void *sub_100349810(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x50uLL);
  void *v2 = off_1019BAD80;
  sub_10034A29C((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_100349864(uint64_t a1, void *a2)
{
  *a2 = off_1019BAD80;
  return sub_10034A29C((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void sub_100349890(uint64_t a1)
{
}

void sub_100349898(void *a1)
{
  sub_10034A334(a1 + 1);

  operator delete(a1);
}

void sub_1003498D4(uint64_t a1, uint64_t *a2, char *a3)
{
  long long v60 = 0uLL;
  uint64_t v61 = 0;
  sub_1003420CC(&v60, *a2, a2[1], 0x8F5C28F5C28F5C29 * ((a2[1] - *a2) >> 4));
  char v5 = *a3;
  uint64_t v6 = *(void *)(a1 + 8);
  if (*a3)
  {
    char v7 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Get remote device from cloud failed", buf, 2u);
    }
    **(unsigned char **)(a1 + 24) = v5;
    long long v8 = *(NSObject **)(a1 + 72);
    *(void *)(a1 + 72) = 0;
    if (v8)
    {
      dispatch_group_leave(v8);
      dispatch_release(v8);
    }
    goto LABEL_95;
  }
  uint64_t v9 = *(void *)(a1 + 40);
  sub_10034A3A8((void **)v9);
  *(_OWORD *)uint64_t v9 = v60;
  *(void *)(v9 + 16) = v61;
  long long v60 = 0uLL;
  uint64_t v61 = 0;
  uint64_t v10 = *(NSObject **)(v6 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v11 = 0x8F5C28F5C28F5C29 * ((uint64_t)(*(void *)(*(void *)(a1 + 40) + 8) - **(void **)(a1 + 40)) >> 4);
    *(_DWORD *)buf = 134217984;
    *(void *)&buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Remote devices %lu", buf, 0xCu);
  }
  uint64_t v12 = *(uint64_t ***)(a1 + 40);
  uint64_t v13 = *v12;
  CFTypeRef v14 = v12[1];
  if (*v12 != v14)
  {
    do
    {
      uint64_t v15 = *(NSObject **)(v6 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        sub_10098FAB8(v13, (uint64_t)buf);
        *(_DWORD *)v85 = 134217984;
        *(void *)&v85[4] = v75;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Remote device plans %lu", v85, 0xCu);
        sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
      }
      v13 += 50;
    }
    while (v13 != v14);
  }
  if (*(unsigned char *)(a1 + 18))
  {
    uint64_t v55 = v6;
    uint64_t v62 = 0;
    v63 = 0;
    unint64_t v64 = 0;
    v16 = *(uint64_t **)(a1 + 40);
    v17 = *(std::__shared_weak_count **)(a1 + 48);
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v18 = *v16;
    v56 = v17;
    uint64_t v57 = v16[1];
    if (*v16 != v57)
    {
      do
      {
        if (!*(unsigned char *)(v18 + 240)) {
          goto LABEL_87;
        }
        uint64_t v19 = *(void *)(v18 + 200);
        uint64_t v59 = *(void *)(v18 + 208);
        if (v19 == v59) {
          goto LABEL_87;
        }
        uint64_t v58 = v18;
        do
        {
          if (!*(unsigned char *)(v19 + 80)) {
            goto LABEL_86;
          }
          long long v21 = *(_DWORD **)(v18 + 368);
          v20 = *(_DWORD **)(v18 + 376);
          sub_1000C5DA8((uint64_t)v85, v19);
          if (v21 != v20)
          {
            do
            {
              if (*(_DWORD *)&v85[4] == *v21) {
                goto LABEL_24;
              }
              v21 += 20;
            }
            while (v21 != v20);
            long long v21 = v20;
          }
LABEL_24:
          if (v88[24])
          {
            *(void *)buf = v88;
            sub_1000C57C8((void ***)buf);
          }
          if (v87 < 0) {
            operator delete(v86);
          }
          uint64_t v70 = 0;
          long long v72 = 0u;
          long long v68 = 0u;
          *(_OWORD *)v69 = 0u;
          *(_OWORD *)v67 = 0u;
          v71 = &v72;
          if (v21 != *(_DWORD **)(v18 + 376)) {
            sub_1003083C8((uint64_t)v67, (uint64_t)v21);
          }
          v65[0] = 0;
          v65[1] = 0;
          uint64_t v66 = 0;
          ctu::hex((uint64_t *)v65, (ctu *)(v19 + 16), (const void *)0x10, v22);
          if (!*(unsigned char *)(v19 + 80)) {
            sub_10016C840();
          }
          uint64_t v23 = *(void *)(v19 + 56);
          uint64_t v24 = *(void *)(v19 + 64);
          while (v23 != v24)
          {
            if (*(char *)(v23 + 39) < 0)
            {
              if (!*(void *)(v23 + 24)) {
                goto LABEL_79;
              }
            }
            else if (!*(unsigned char *)(v23 + 39))
            {
              goto LABEL_79;
            }
            if (&v72 != (long long *)sub_100046F68((uint64_t)&v71, (void **)(v23 + 16)))
            {
              if (*(char *)(v23 + 39) < 0)
              {
                sub_10004FC84(buf, *(void **)(v23 + 16), *(void *)(v23 + 24));
              }
              else
              {
                long long v25 = *(_OWORD *)(v23 + 16);
                uint64_t v75 = *(void *)(v23 + 32);
                *(_OWORD *)buf = v25;
              }
              LOBYTE(v76) = 1;
              if (*(char *)(v23 + 119) < 0)
              {
                sub_10004FC84(&v77, *(void **)(v23 + 96), *(void *)(v23 + 104));
              }
              else
              {
                long long v26 = *(_OWORD *)(v23 + 96);
                uint64_t v78 = *(void *)(v23 + 112);
                long long v77 = v26;
              }
              if (*(char *)(v23 + 143) < 0)
              {
                sub_10004FC84(&v79, *(void **)(v23 + 120), *(void *)(v23 + 128));
              }
              else
              {
                long long v27 = *(_OWORD *)(v23 + 120);
                uint64_t v80 = *(void *)(v23 + 136);
                long long v79 = v27;
              }
              if (*(char *)(v23 + 167) < 0)
              {
                sub_10004FC84(&v81, *(void **)(v23 + 144), *(void *)(v23 + 152));
              }
              else
              {
                long long v28 = *(_OWORD *)(v23 + 144);
                uint64_t v82 = *(void *)(v23 + 160);
                long long v81 = v28;
              }
              if (*(char *)(v23 + 191) < 0)
              {
                sub_10004FC84(&__p, *(void **)(v23 + 168), *(void *)(v23 + 176));
              }
              else
              {
                long long v29 = *(_OWORD *)(v23 + 168);
                uint64_t v84 = *(void *)(v23 + 184);
                long long __p = v29;
              }
              v30 = v63;
              if ((unint64_t)v63 >= v64)
              {
                uint64_t v36 = (uint64_t)&v63[-v62] >> 7;
                unint64_t v37 = v36 + 1;
                if ((unint64_t)(v36 + 1) >> 57) {
                  sub_10006A748();
                }
                uint64_t v38 = v64 - v62;
                if ((uint64_t)(v64 - v62) >> 6 > v37) {
                  unint64_t v37 = v38 >> 6;
                }
                if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFF80) {
                  unint64_t v39 = 0x1FFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v39 = v37;
                }
                v73[4] = &v64;
                if (v39) {
                  uint64_t v40 = (char *)sub_100043864((uint64_t)&v64, v39);
                }
                else {
                  uint64_t v40 = 0;
                }
                v41 = &v40[128 * v36];
                v73[0] = v40;
                v73[1] = v41;
                v73[3] = &v40[128 * v39];
                char *v41 = 0;
                v41[24] = 0;
                if ((_BYTE)v76)
                {
                  long long v42 = *(_OWORD *)buf;
                  *((void *)v41 + 2) = v75;
                  *(_OWORD *)v41 = v42;
                  uint64_t v75 = 0;
                  memset(buf, 0, sizeof(buf));
                  v41[24] = 1;
                }
                long long v43 = v77;
                *((void *)v41 + 6) = v78;
                *((_OWORD *)v41 + 2) = v43;
                uint64_t v78 = 0;
                long long v77 = 0uLL;
                long long v44 = v79;
                *((void *)v41 + 9) = v80;
                *(_OWORD *)(v41 + 56) = v44;
                uint64_t v80 = 0;
                long long v79 = 0uLL;
                long long v45 = v81;
                *((void *)v41 + 12) = v82;
                *((_OWORD *)v41 + 5) = v45;
                uint64_t v82 = 0;
                long long v81 = 0uLL;
                long long v46 = __p;
                *((void *)v41 + 15) = v84;
                *(_OWORD *)(v41 + 104) = v46;
                long long __p = 0uLL;
                uint64_t v84 = 0;
                v73[2] = v41 + 128;
                sub_100313094(&v62, v73);
                v47 = v63;
                sub_1003131D8((uint64_t)v73);
                v63 = v47;
                if (SHIBYTE(v84) < 0) {
                  operator delete((void *)__p);
                }
              }
              else
              {
                unsigned char *v63 = 0;
                v30[24] = 0;
                if ((_BYTE)v76)
                {
                  long long v31 = *(_OWORD *)buf;
                  *((void *)v30 + 2) = v75;
                  *(_OWORD *)v30 = v31;
                  uint64_t v75 = 0;
                  memset(buf, 0, sizeof(buf));
                  v30[24] = 1;
                }
                long long v32 = v77;
                *((void *)v30 + 6) = v78;
                *((_OWORD *)v30 + 2) = v32;
                uint64_t v78 = 0;
                long long v77 = 0uLL;
                uint64_t v33 = v80;
                *(_OWORD *)(v30 + 56) = v79;
                *((void *)v30 + 9) = v33;
                uint64_t v80 = 0;
                long long v79 = 0uLL;
                long long v34 = v81;
                *((void *)v30 + 12) = v82;
                *((_OWORD *)v30 + 5) = v34;
                uint64_t v82 = 0;
                long long v81 = 0uLL;
                long long v35 = __p;
                *((void *)v30 + 15) = v84;
                *(_OWORD *)(v30 + 104) = v35;
                long long __p = 0uLL;
                uint64_t v84 = 0;
                v63 = v30 + 128;
              }
              if (SHIBYTE(v82) < 0) {
                operator delete((void *)v81);
              }
              if (SHIBYTE(v80) < 0) {
                operator delete((void *)v79);
              }
              if (SHIBYTE(v78) < 0) {
                operator delete((void *)v77);
              }
              if ((_BYTE)v76 && SHIBYTE(v75) < 0) {
                operator delete(*(void **)buf);
              }
            }
LABEL_79:
            v23 += 216;
          }
          if (SHIBYTE(v66) < 0) {
            operator delete(v65[0]);
          }
          sub_1000C5440((uint64_t)&v71, (void *)v72);
          uint64_t v18 = v58;
          if (SHIBYTE(v70) < 0) {
            operator delete(v69[0]);
          }
          if (SHIBYTE(v68) < 0) {
            operator delete(v67[1]);
          }
LABEL_86:
          v19 += 88;
        }
        while (v19 != v59);
LABEL_87:
        v18 += 400;
      }
      while (v18 != v57);
    }
    if (v56) {
      sub_10004D2C8(v56);
    }
    uint64_t v48 = *(void *)(v55 + 336);
    uint64_t v49 = *(void *)(a1 + 24);
    uint64_t v50 = *(void *)(a1 + 32);
    if (v50) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v50 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v52 = *(void *)(a1 + 56);
    uint64_t v51 = *(void *)(a1 + 64);
    if (v51) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v51 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v53 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = 0;
    v76 = 0;
    v54 = operator new(0x38uLL);
    void *v54 = off_1019BAE00;
    v54[1] = v55;
    v54[2] = v49;
    v54[3] = v50;
    v54[4] = v52;
    v54[5] = v51;
    v54[6] = v53;
    v76 = v54;
    (*(void (**)(uint64_t, void, uint64_t *, uint8_t *))(*(void *)v48 + 56))(v48, 0, &v62, buf);
    sub_10034AB3C(buf);
    *(void *)v85 = &v62;
    sub_10030B640((void ***)v85);
  }
LABEL_95:
  *(void *)buf = &v60;
  sub_1000C5238((void ***)buf);
}

void sub_10034A0E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void **a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45)
{
  a29 = (void **)&a23;
  sub_10030B640(&a29);
  a29 = (void **)&a19;
  sub_1000C5238(&a29);
  _Unwind_Resume(a1);
}

void sub_10034A154()
{
}

void sub_10034A15C()
{
}

void sub_10034A164(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,char a29)
{
  if (!a12) {
    JUMPOUT(0x10034A108);
  }
  JUMPOUT(0x10034A100);
}

uint64_t sub_10034A250(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10034A290()
{
}

uint64_t sub_10034A29C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
  *(void *)a1 = v3;
  uint64_t v4 = a2[3];
  *(void *)(a1 + 16) = a2[2];
  *(void *)(a1 + 24) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a2[5];
  *(void *)(a1 + 32) = a2[4];
  *(void *)(a1 + 40) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = a2[7];
  *(void *)(a1 + 48) = a2[6];
  *(void *)(a1 + 56) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  char v7 = a2[8];
  *(void *)(a1 + 64) = v7;
  if (v7)
  {
    dispatch_retain(v7);
    long long v8 = *(NSObject **)(a1 + 64);
    if (v8) {
      dispatch_group_enter(v8);
    }
  }
  return a1;
}

void sub_10034A334(void *a1)
{
  uint64_t v2 = a1[8];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[8];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[5];
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)a1[3];
  if (v6)
  {
    sub_10004D2C8(v6);
  }
}

void sub_10034A3A8(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = v1;
    if ((void *)v3 != v1)
    {
      do
        uint64_t v3 = sub_1000C52BC(v3 - 400);
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void *sub_10034A408(void *a1)
{
  *a1 = off_1019BAE00;
  uint64_t v2 = a1[6];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[6];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[5];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[3];
  if (v5) {
    sub_10004D2C8(v5);
  }
  return a1;
}

void sub_10034A478(void *a1)
{
  *a1 = off_1019BAE00;
  uint64_t v2 = a1[6];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[6];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[5];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[3];
  if (v5) {
    sub_10004D2C8(v5);
  }

  operator delete();
}

void *sub_10034A508(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  void *v2 = off_1019BAE00;
  sub_10034A9AC((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_10034A55C(uint64_t a1, void *a2)
{
  *a2 = off_1019BAE00;
  return sub_10034A9AC((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10034A588(uint64_t a1)
{
}

void sub_10034A590(void *a1)
{
  sub_10034AA24(a1 + 1);

  operator delete(a1);
}

void sub_10034A5CC(uint64_t a1, void *a2, char *a3)
{
  char v4 = *a3;
  if (*a3)
  {
    uint64_t v5 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Get add on options failed", buf, 2u);
    }
    uint64_t v6 = *(NSObject **)(a1 + 48);
    *(void *)(a1 + 48) = 0;
    if (v6)
    {
      dispatch_group_leave(v6);
      dispatch_release(v6);
    }
    **(unsigned char **)(a1 + 16) = v4;
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 32);
    if ((void *)v7 != a2)
    {
      long long v8 = a2 + 1;
      uint64_t v9 = (void *)*a2;
      if (*(void *)(v7 + 16))
      {
        *(void *)buf = *(void *)(a1 + 32);
        uint64_t v10 = *(uint64_t **)v7;
        uint64_t v11 = *(void *)(v7 + 8);
        *(void *)uint64_t v7 = v7 + 8;
        *(void *)(v11 + 16) = 0;
        *(void *)(v7 + 16) = 0;
        *(void *)(v7 + 8) = 0;
        if (v10[1]) {
          uint64_t v12 = (uint64_t *)v10[1];
        }
        else {
          uint64_t v12 = v10;
        }
        long long v27 = v12;
        long long v28 = v12;
        if (!v12 || (long long v27 = sub_1000EA590((uint64_t)v12), v9 == v8))
        {
          v16 = v9;
        }
        else
        {
          do
          {
            std::string::operator=((std::string *)(v12 + 4), (const std::string *)(v9 + 4));
            std::string::operator=((std::string *)(v12 + 7), (const std::string *)(v9 + 7));
            std::string::operator=((std::string *)(v12 + 10), (const std::string *)(v9 + 10));
            std::string::operator=((std::string *)(v12 + 13), (const std::string *)(v9 + 13));
            std::string::operator=((std::string *)(v12 + 16), (const std::string *)(v9 + 16));
            std::string::operator=((std::string *)(v12 + 19), (const std::string *)(v9 + 19));
            std::string::operator=((std::string *)(v12 + 22), (const std::string *)(v9 + 22));
            std::string::operator=((std::string *)(v12 + 25), (const std::string *)(v9 + 25));
            std::string::operator=((std::string *)(v12 + 28), (const std::string *)(v9 + 28));
            std::string::operator=((std::string *)(v12 + 31), (const std::string *)(v9 + 31));
            *((unsigned char *)v12 + 272) = *((unsigned char *)v9 + 272);
            sub_100179AF8((std::string *)(v12 + 35), (const std::string *)(v9 + 35));
            sub_100179AF8((std::string *)v12 + 13, (const std::string *)v9 + 13);
            uint64_t v13 = v28;
            uint64_t v25 = 0;
            CFTypeRef v14 = (uint64_t **)sub_1000EA518(v7, &v25, v28 + 4);
            sub_100046C38((uint64_t **)v7, v25, v14, v13);
            uint64_t v12 = v27;
            long long v28 = v27;
            if (v27) {
              long long v27 = sub_1000EA590((uint64_t)v27);
            }
            uint64_t v15 = (void *)v9[1];
            if (v15)
            {
              do
              {
                v16 = v15;
                uint64_t v15 = (void *)*v15;
              }
              while (v15);
            }
            else
            {
              do
              {
                v16 = (void *)v9[2];
                BOOL v17 = *v16 == (void)v9;
                uint64_t v9 = v16;
              }
              while (!v17);
            }
            if (!v12) {
              break;
            }
            uint64_t v9 = v16;
          }
          while (v16 != v8);
        }
        sub_10034AA8C((uint64_t)buf);
        uint64_t v9 = v16;
      }
      if (v9 != v8)
      {
        do
        {
          long long v28 = 0;
          uint64_t v18 = operator new(0x158uLL);
          uint64_t v19 = v18;
          *(void *)buf = v18;
          long long v27 = (uint64_t *)(v7 + 8);
          if (*((char *)v9 + 55) < 0)
          {
            sub_10004FC84(v18 + 32, (void *)v9[4], v9[5]);
          }
          else
          {
            long long v20 = *((_OWORD *)v9 + 2);
            *((void *)v18 + 6) = v9[6];
            *((_OWORD *)v18 + 2) = v20;
          }
          sub_10030C884(v19 + 56, (long long *)(v9 + 7));
          LOBYTE(v28) = 1;
          uint64_t v25 = 0;
          long long v21 = (uint64_t **)sub_1000EA518(v7, &v25, (void *)(*(void *)buf + 32));
          sub_100046C38((uint64_t **)v7, v25, v21, *(uint64_t **)buf);
          *(void *)buf = 0;
          sub_10034AAE4((uint64_t)buf, 0);
          unint64_t v22 = (void *)v9[1];
          if (v22)
          {
            do
            {
              uint64_t v23 = v22;
              unint64_t v22 = (void *)*v22;
            }
            while (v22);
          }
          else
          {
            do
            {
              uint64_t v23 = (void *)v9[2];
              BOOL v17 = *v23 == (void)v9;
              uint64_t v9 = v23;
            }
            while (!v17);
          }
          uint64_t v9 = v23;
        }
        while (v23 != v8);
      }
    }
    uint64_t v24 = *(NSObject **)(a1 + 48);
    *(void *)(a1 + 48) = 0;
    if (v24)
    {
      dispatch_group_leave(v24);
      dispatch_release(v24);
    }
  }
}

void sub_10034A920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10034AAE4((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_10034A960(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10034A9A0()
{
}

uint64_t sub_10034A9AC(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(NSObject **)(a2 + 40);
  *(void *)(a1 + 40) = v5;
  if (v5)
  {
    dispatch_retain(v5);
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (v6) {
      dispatch_group_enter(v6);
    }
  }
  return a1;
}

void sub_10034AA24(void *a1)
{
  uint64_t v2 = a1[5];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[5];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[4];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (v5)
  {
    sub_10004D2C8(v5);
  }
}

uint64_t sub_10034AA8C(uint64_t a1)
{
  sub_10034964C(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_10034964C(*(void *)a1, v2);
  }
  return a1;
}

void sub_10034AAE4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1003496A8((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void *sub_10034AB3C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10034ABC0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10034AC44(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019BAEA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10034AC64(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019BAEA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10034ACB8(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 24);
  sub_10010DF1C(&v1);
}

void *sub_10034ACE8(void *a1)
{
  *a1 = off_1019BAEF0;
  uint64_t v2 = a1[4];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[4];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

void sub_10034AD4C(void *a1)
{
  *a1 = off_1019BAEF0;
  uint64_t v2 = a1[4];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[4];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4) {
    sub_10004D2C8(v4);
  }

  operator delete();
}

void *sub_10034ADD0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_1019BAEF0;
  sub_10034B048((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_10034AE24(uint64_t a1, void *a2)
{
  *a2 = off_1019BAEF0;
  return sub_10034B048((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10034AE50(uint64_t a1)
{
}

void sub_10034AE58(void *a1)
{
  sub_10034B0A8((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10034AE94(void *a1, uint64_t a2)
{
  uint64_t v3 = *(std::string **)(a2 + 8);
  long long v8 = v3;
  long long v7 = *(_OWORD *)(a2 + 16);
  long long v9 = v7;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  uint64_t v4 = *(NSObject **)(a1[1] + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    *(void *)&buf[4] = 0x8F5C28F5C28F5C29 * ((uint64_t)(v7 - (void)v3) >> 3);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Retrieved blacklist plans %ld", buf, 0xCu);
  }
  uint64_t v5 = (std::string **)a1[2];
  if (v5 != &v8) {
    sub_10034B104((uint64_t)v5, v3, (std::string *)v7, 0x8F5C28F5C28F5C29 * ((uint64_t)(v7 - (void)v3) >> 3));
  }
  uint64_t v6 = a1[4];
  a1[4] = 0;
  if (v6)
  {
    dispatch_group_leave(v6);
    dispatch_release(v6);
  }
  *(void *)buf = &v8;
  sub_10010DF1C((void ***)buf);
}

void sub_10034AFE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_10010DF1C((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10034AFFC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10034B03C()
{
}

uint64_t sub_10034B048(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(NSObject **)(a2 + 24);
  *(void *)(a1 + 24) = v4;
  if (v4)
  {
    dispatch_retain(v4);
    uint64_t v5 = *(NSObject **)(a1 + 24);
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  return a1;
}

void sub_10034B0A8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 24);
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    sub_10004D2C8(v4);
  }
}

uint64_t sub_10034B104(uint64_t a1, std::string *__str, std::string *a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  long long v9 = *(std::string **)a1;
  if (0x8F5C28F5C28F5C29 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a4)
  {
    sub_10034B2A0((void **)a1);
    if (a4 > 0x147AE147AE147AELL) {
      sub_10006A748();
    }
    unint64_t v10 = 0x1EB851EB851EB852 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0x8F5C28F5C28F5C29 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= 0xA3D70A3D70A3D7) {
      unint64_t v11 = 0x147AE147AE147AELL;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_10030F9EC((void *)a1, v11);
    uint64_t result = sub_100322920(v8, (uint64_t)__str, (uint64_t)a3, *(void *)(a1 + 8));
    goto LABEL_11;
  }
  if (0x8F5C28F5C28F5C29 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3) < a4)
  {
    uint64_t v13 = (std::string *)((char *)__str + 8 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3));
    sub_10034B300((int)&v16, __str, v13, v9);
    uint64_t result = sub_100322920(v8, (uint64_t)v13, (uint64_t)a3, *(void *)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = result;
    return result;
  }
  sub_10034B300((int)&v17, __str, a3, v9);
  uint64_t v15 = v14;
  uint64_t result = *(void *)(a1 + 8);
  if (result != v14)
  {
    do
      uint64_t result = sub_10010DDFC(result - 200);
    while (result != v15);
  }
  *(void *)(a1 + 8) = v15;
  return result;
}

void sub_10034B290(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_10034B298(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_10034B2A0(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = v1;
    if ((void *)v3 != v1)
    {
      do
        uint64_t v3 = sub_10010DDFC(v3 - 200);
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

std::string *sub_10034B300(int a1, std::string *__str, std::string *a3, std::string *this)
{
  uint64_t v5 = __str;
  if (__str == a3) {
    return __str;
  }
  uint64_t v6 = a3;
  do
  {
    std::string::operator=(this, v5);
    std::string::operator=(this + 1, v5 + 1);
    std::string::operator=(this + 2, v5 + 2);
    std::string::operator=(this + 3, v5 + 3);
    std::string::operator=(this + 4, v5 + 4);
    std::string::operator=(this + 5, v5 + 5);
    sub_10034B3AC((uint64_t)&this[6], (uint64_t)&v5[6]);
    this = (std::string *)((char *)this + 200);
    uint64_t v5 = (std::string *)((char *)v5 + 200);
  }
  while (v5 != v6);
  return v6;
}

void sub_10034B3AC(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 48) == *(unsigned __int8 *)(a2 + 48))
  {
    if (*(unsigned char *)(a1 + 48))
    {
      *(_OWORD *)a1 = *(_OWORD *)a2;
      std::string::operator=((std::string *)(a1 + 16), (const std::string *)(a2 + 16));
      *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
    }
  }
  else if (*(unsigned char *)(a1 + 48))
  {
    if (*(char *)(a1 + 39) < 0) {
      operator delete(*(void **)(a1 + 16));
    }
    *(unsigned char *)(a1 + 48) = 0;
  }
  else
  {
    sub_10010DD9C(a1, a2);
    *(unsigned char *)(a1 + 48) = 1;
  }
}

void sub_10034B434(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019BB170;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10034B454(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019BB170;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10034B4A8(uint64_t a1)
{
}

void *sub_10034B4BC(void *a1)
{
  *a1 = off_1019BAF70;
  uint64_t v2 = a1[3];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[3];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

void sub_10034B520(void *a1)
{
  *a1 = off_1019BAF70;
  uint64_t v2 = a1[3];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[3];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    sub_10004D2C8(v4);
  }

  operator delete();
}

void *sub_10034B5A4(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = off_1019BAF70;
  sub_10034B788(v2 + 1, v1);
  return v2;
}

void *sub_10034B5F8(uint64_t a1, void *a2)
{
  *a2 = off_1019BAF70;
  return sub_10034B788(a2 + 1, (void *)(a1 + 8));
}

void sub_10034B624(uint64_t a1)
{
}

void sub_10034B62C(void *a1)
{
  sub_10034B7E0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10034B668(uint64_t a1, void *a2)
{
  uint64_t v3 = a2 + 1;
  uint64_t v4 = (void *)a2[1];
  unint64_t v10 = (void **)*a2;
  unint64_t v11 = v4;
  uint64_t v12 = a2[2];
  if (v12)
  {
    v4[2] = &v11;
    *a2 = v3;
    *uint64_t v3 = 0;
    a2[2] = 0;
  }
  else
  {
    unint64_t v10 = &v11;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = v5 + 8;
  sub_100313460(v5, *(void **)(v5 + 8));
  *(void *)uint64_t v5 = v10;
  long long v7 = v11;
  *(void *)(v5 + 8) = v11;
  uint64_t v8 = v12;
  *(void *)(v5 + 16) = v12;
  if (v8)
  {
    v7[2] = v6;
    unint64_t v10 = &v11;
    unint64_t v11 = 0;
    uint64_t v12 = 0;
  }
  else
  {
    *(void *)uint64_t v5 = v6;
  }
  long long v9 = *(NSObject **)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v9)
  {
    dispatch_group_leave(v9);
    dispatch_release(v9);
  }
  sub_100313460((uint64_t)&v10, v11);
}

uint64_t sub_10034B73C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10034B77C()
{
}

void *sub_10034B788(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[2];
  a1[2] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    uint64_t v5 = a1[2];
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  return a1;
}

void sub_10034B7E0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 16);
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    sub_10004D2C8(v4);
  }
}

void *sub_10034B83C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10034B8C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void *sub_10034B940(void *result)
{
  uint64_t v1 = (void *)*result;
  void *result = 0;
  if (v1)
  {
    sub_10034398C(v1 + 11);
    uint64_t v2 = (std::__shared_weak_count *)v1[10];
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[8];
    if (v3) {
      sub_10004D2C8(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)v1[6];
    if (v4) {
      sub_10004D2C8(v4);
    }
    uint64_t v5 = (std::__shared_weak_count *)v1[4];
    if (v5) {
      sub_10004D2C8(v5);
    }
    uint64_t v6 = (std::__shared_weak_count *)v1[2];
    if (v6) {
      sub_10004D2C8(v6);
    }
    operator delete();
  }
  return result;
}

void *sub_10034B9CC(uint64_t *a1)
{
  uint64_t v6 = a1;
  uint64_t v2 = *a1;
  *(unsigned char *)(*a1 + 1707) = 0;
  char v3 = *(unsigned char *)a1[1];
  if (v3)
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Failed to preparing remote add on plans", buf, 2u);
      char v3 = *(unsigned char *)a1[1];
    }
    *(void *)buf = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    long long v9 = 0;
    memset(v8, 0, sizeof(v8));
    long long v7 = (uint8_t *)v8;
    sub_1003080C8(a1[14], v3);
    sub_100313460((uint64_t)&v7, v8[0]);
    if (v9) {
      sub_10004D2C8(v9);
    }
    long long v7 = buf;
    sub_1000C5238((void ***)&v7);
  }
  else
  {
    sub_1003080C8(a1[14], 0);
  }
  return sub_10034B940(&v6);
}

void sub_10034BAE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_10034BB24(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v18 = a1;
  uint64_t v19 = v1;
  uint64_t v2 = *v1;
  if (v1[4])
  {
    uint64_t v3 = (uint64_t)(v1 + 1);
    if ((*(unsigned int (**)(void))(**(void **)(v2 + 304) + 296))(*(void *)(v2 + 304))
      && *(unsigned char *)(v2 + 2592) != 1)
    {
      long long v9 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Add on not supported over bootstrap", buf, 2u);
      }
      *(void *)buf = 0;
      sub_10031F910(v3, (uint64_t)buf, 41);
      goto LABEL_22;
    }
    if (!*(unsigned char *)(v2 + 1784))
    {
      uint64_t v8 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Add on not supported without cloud signed in", buf, 2u);
      }
      *(void *)buf = 0;
      sub_10031F910(v3, (uint64_t)buf, 38);
      goto LABEL_22;
    }
    if (*(unsigned char *)(v2 + 4601) && *(unsigned char *)(v2 + 4600))
    {
      uint64_t v4 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E Add on plans blocked : regulatory restriction active", buf, 2u);
      }
      *(void *)buf = 0;
      char v5 = (*(uint64_t (**)(void))(**(void **)(v2 + 320) + 848))(*(void *)(v2 + 320));
      sub_10031F910(v3, (uint64_t)buf, v5);
LABEL_22:
      p_CFTypeRef cf = (const void **)buf;
LABEL_23:
      sub_100044D00(p_cf);
      goto LABEL_24;
    }
    if (*(unsigned char *)(v2 + 1707))
    {
      long long v7 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Fetch inprogress, cache get remote device plans callback", buf, 2u);
      }
      sub_10031F89C((void *)(v2 + 5232), v3);
    }
    else
    {
      double v12 = (*(double (**)(void))(**(void **)(v2 + 288) + 304))(*(void *)(v2 + 288));
      if (v12 >= CFAbsoluteTimeGetCurrent())
      {
        CFTypeRef cf = 0;
        (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(v2 + 288) + 272))(&cf);
        CFTypeRef v31 = cf;
        if (cf) {
          CFRetain(cf);
        }
        char v14 = sub_100CD8D54((os_log_t *)(v2 + 40), (void **)&v31);
        sub_100044D00(&v31);
        uint64_t v15 = *(NSObject **)(v2 + 40);
        BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
        if (v14)
        {
          if (v16)
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Sent cached add on remote plans", buf, 2u);
          }
          long long v34 = 0u;
          long long v35 = 0u;
          *(_OWORD *)buf = 0u;
          uint64_t v17 = *(void *)(v2 + 328);
          v30[0] = *(NSObject ***)(v2 + 320);
          v30[1] = (NSObject **)v17;
          if (v17) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
          }
          long long v28 = 0;
          uint64_t v29 = 0;
          long long v27 = &v28;
          sub_101199D7C((NSObject ***)buf, (NSObject **)(v2 + 40), v30, &v27, (NSObject **)(*(void *)(v2 + 5368) + 96));
          sub_100313460((uint64_t)&v27, v28);
          if (v17) {
            sub_10004D2C8((std::__shared_weak_count *)v17);
          }
          long long v27 = 0;
          long long v28 = 0;
          uint64_t v29 = 0;
          (*(void (**)(NSObject **__return_ptr))(**(void **)(v2 + 304) + 456))(&v27);
          CFTypeRef v25 = cf;
          CFTypeRef v26 = 0;
          if (cf) {
            CFRetain(cf);
          }
          sub_10119B0D4((NSObject ***)buf, (void **)&v25, &v27, (void **)&v26);
          sub_100044D00(&v25);
          uint64_t v22 = 0;
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          CFTypeRef v21 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_100CD9464((void **)&v21, (uint64_t)&v22);
          sub_100044D00(&v21);
          if (v24) {
            sub_10034C1EC(v2 + 1976, &v22);
          }
          CFTypeRef v20 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10031F910(v3, (uint64_t)&v20, 0);
          sub_100044D00(&v20);
          sub_10010C0E0((uint64_t)&v22, v23);
          sub_100044D00(&v26);
          sub_10010E37C((uint64_t)&v27, v28);
          if ((void)v34) {
            sub_10004D2C8((std::__shared_weak_count *)v34);
          }
        }
        else
        {
          if (v16)
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Add on plan cache is invalid", buf, 2u);
          }
          sub_10031F4D0((uint64_t)buf, v3);
          sub_100307A6C(v2, (uint64_t)buf);
          sub_100313790(buf);
        }
        p_CFTypeRef cf = &cf;
        goto LABEL_23;
      }
      uint64_t v13 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Add on plan cache time expired", buf, 2u);
      }
      sub_10031F4D0((uint64_t)buf, v3);
      sub_100307A6C(v2, (uint64_t)buf);
      sub_100313790(buf);
    }
  }
  else
  {
    uint64_t v6 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "invalid callback", buf, 2u);
    }
  }
LABEL_24:
  sub_100321A2C((uint64_t *)&v19);
  return sub_100046B58((uint64_t *)&v18);
}

void sub_10034C0DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,char a25,int a26,__int16 a27,char a28,char a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,int a39,__int16 a40,char a41,char a42,int a43,__int16 a44,char a45,char a46,uint64_t a47,uint64_t a48)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10034C1EC(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_10034C2C4(a2, &v5);
  sub_100058DB0(&__p, "/cc/events/iccid_to_ids_device_id_updated");
  xpc_object_t object = v5;
  xpc_object_t v5 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_10034C280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_10034C2C4(void *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  uint64_t v8 = (void *)*a1;
  uint64_t v6 = a1 + 1;
  long long v7 = v8;
  if (v8 != v6)
  {
    do
    {
      sub_10034C430((uint64_t)(v7 + 4), &value);
      xpc_array_append_value(v5, value);
      xpc_release(value);
      long long v9 = (void *)v7[1];
      if (v9)
      {
        do
        {
          unint64_t v10 = v9;
          long long v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          unint64_t v10 = (void *)v7[2];
          BOOL v11 = *v10 == (void)v7;
          long long v7 = v10;
        }
        while (!v11);
      }
      long long v7 = v10;
    }
    while (v10 != v6);
  }
  *a2 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v5);
}

void sub_10034C404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

void sub_10034C430(uint64_t a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v19 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v19 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v19 = v6;
LABEL_9:
  xpc_release(v5);
  if (*(char *)(a1 + 23) >= 0) {
    long long v7 = (const char *)a1;
  }
  else {
    long long v7 = *(const char **)a1;
  }
  xpc_object_t v17 = xpc_string_create(v7);
  if (!v17) {
    xpc_object_t v17 = xpc_null_create();
  }
  uint64_t v15 = &v19;
  uint64_t v16 = "first";
  sub_100035E70((uint64_t)&v15, &v17, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v17);
  xpc_object_t v17 = 0;
  unint64_t v10 = *(const char **)(a1 + 24);
  uint64_t v9 = a1 + 24;
  uint64_t v8 = v10;
  if (*(char *)(v9 + 23) >= 0) {
    BOOL v11 = (const char *)v9;
  }
  else {
    BOOL v11 = v8;
  }
  xpc_object_t v13 = xpc_string_create(v11);
  if (!v13) {
    xpc_object_t v13 = xpc_null_create();
  }
  uint64_t v15 = &v19;
  uint64_t v16 = "second";
  sub_100035E70((uint64_t)&v15, &v13, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_object_t v12 = v19;
  *a2 = v19;
  if (v12) {
    xpc_retain(v12);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v19);
}

void *sub_10034C5E8(void *a1)
{
  *a1 = off_1019BAFF0;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10034C634(void *a1)
{
  *a1 = off_1019BAFF0;
  uint64_t v1 = (std::__shared_weak_count *)a1[5];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10034C6A0(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x30uLL);
  *(void *)uint64_t result = off_1019BAFF0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  uint64_t v4 = *(void *)(a1 + 40);
  *((void *)result + 5) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10034C70C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019BAFF0;
  long long v2 = *(_OWORD *)(result + 8);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(_OWORD *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 40) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10034C754(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10034C764(void *__p)
{
  long long v2 = (std::__shared_weak_count *)__p[5];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

uint64_t sub_10034C7A4(void *a1, uint64_t a2)
{
  sub_10032B034((uint64_t)v13, a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v4 = (void *)a1[1];
    xpc_object_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      xpc_object_t v6 = v5;
      if (!a1[4])
      {
LABEL_25:
        sub_10004D2C8(v6);
        return sub_1000C636C((uint64_t)v13);
      }
      long long v7 = (std::__shared_weak_count *)v4[51];
      v4[50] = 0;
      v4[51] = 0;
      if (v7) {
        sub_10004D2C8(v7);
      }
      uint64_t v8 = v4[32];
      if (!v8)
      {
        BOOL v11 = v4[5];
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf[0]) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "invalid command receiver", (uint8_t *)buf, 2u);
        }
        goto LABEL_25;
      }
      memset(&v22, 0, sizeof(v22));
      memset(buf, 0, sizeof(buf));
      if (v16)
      {
        LOBYTE(buf[0]) = v13[0];
        std::string::operator=((std::string *)&buf[1], &v14);
        std::string::operator=(&v22, &v15);
        uint64_t v8 = v4[32];
        uint64_t v9 = a1[2];
        uint64_t v10 = a1[3];
        v17[0] = buf[0];
        if (SHIBYTE(buf[3]) < 0)
        {
          sub_10004FC84(&v18, (void *)buf[1], buf[2]);
LABEL_14:
          if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__p, v22.__r_.__value_.__l.__data_, v22.__r_.__value_.__l.__size_);
          }
          else {
            std::string __p = v22;
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *))(*(void *)v8 + 56))(v8, v9, v10, v17);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v19) < 0) {
            operator delete((void *)v18);
          }
          if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v22.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(buf[3]) < 0) {
            operator delete((void *)buf[1]);
          }
          goto LABEL_25;
        }
      }
      else
      {
        uint64_t v9 = a1[2];
        uint64_t v10 = a1[3];
        v17[0] = 0;
      }
      long long v18 = *(_OWORD *)&buf[1];
      uint64_t v19 = buf[3];
      goto LABEL_14;
    }
  }
  return sub_1000C636C((uint64_t)v13);
}

void sub_10034C9A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v31 - 57) < 0) {
    operator delete(*(void **)(v31 - 80));
  }
  if (*(char *)(v31 - 81) < 0) {
    operator delete(*(void **)(v31 - 104));
  }
  sub_10004D2C8(v30);
  sub_1000C636C((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_10034CA14(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10034CA54()
{
}

void *sub_10034CA60(void *a1)
{
  long long v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10034CAE4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void *sub_10034CB64(void *a1)
{
  *a1 = off_1019BB080;
  sub_10034B83C(a1 + 4);
  long long v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10034CBB4(void *a1)
{
  *a1 = off_1019BB080;
  sub_10034B83C(a1 + 4);
  long long v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_10034CC24(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  long long v2 = operator new(0x40uLL);
  void *v2 = off_1019BB080;
  sub_10034D0D4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10034CC78(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10034CC8C(uint64_t a1, void *a2)
{
  *a2 = off_1019BB080;
  return sub_10034D0D4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10034CCB8(uint64_t a1)
{
}

void sub_10034CCC0(void *a1)
{
  sub_10034D1D4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10034CCFC(void *a1, unsigned __int8 *a2, void *a3)
{
  unsigned int v4 = *a2;
  xpc_object_t v5 = a3 + 1;
  xpc_object_t v6 = (void *)a3[1];
  CFTypeRef v20 = (void **)*a3;
  CFTypeRef v21 = v6;
  if (a3[2])
  {
    v6[2] = &v21;
    *a3 = v5;
    *xpc_object_t v5 = 0;
    a3[2] = 0;
  }
  else
  {
    CFTypeRef v20 = &v21;
  }
  long long v7 = (std::__shared_weak_count *)a1[3];
  if (!v7)
  {
    uint64_t v9 = 0;
LABEL_12:
    *((void *)&buf + 1) = 0;
    uint64_t v24 = 0;
    *(void *)&long long buf = (char *)&buf + 8;
    uint64_t v12 = a1[7];
    if (!v12) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, long long *))(*(void *)v12 + 48))(v12, &buf);
    goto LABEL_14;
  }
  uint64_t v8 = a1[1];
  uint64_t v9 = std::__shared_weak_count::lock(v7);
  if (!v9 || !a1[2]) {
    goto LABEL_12;
  }
  if (v4)
  {
    uint64_t v10 = *(NSObject **)(v8 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      if (v4 > 6) {
        uint64_t v19 = "kSuccess";
      }
      else {
        uint64_t v19 = off_1019BB290[(char)(v4 - 1)];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "fetch AKRemoteDevice failure : %s", (uint8_t *)&buf, 0xCu);
    }
    *((void *)&buf + 1) = 0;
    uint64_t v24 = 0;
    *(void *)&long long buf = (char *)&buf + 8;
    uint64_t v11 = a1[7];
    if (!v11) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, long long *))(*(void *)v11 + 48))(v11, &buf);
    sub_100313460((uint64_t)&buf, *((void **)&buf + 1));
    goto LABEL_15;
  }
  xpc_object_t v13 = *(void ***)(v8 + 2320);
  if (v13 == (void **)(v8 + 2328))
  {
LABEL_25:
    xpc_object_t v17 = *(NSObject **)(v8 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "invalid AKRemoteDevice lists - cannot find self device", (uint8_t *)&buf, 2u);
    }
    *((void *)&buf + 1) = 0;
    uint64_t v24 = 0;
    *(void *)&long long buf = (char *)&buf + 8;
    uint64_t v18 = a1[7];
    if (!v18) {
      sub_10007B600();
    }
  }
  else
  {
    while (!sub_10010E128((uint64_t)&v20, v13 + 5))
    {
      std::string v14 = (void **)v13[1];
      if (v14)
      {
        do
        {
          std::string v15 = v14;
          std::string v14 = (void **)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          std::string v15 = (void **)v13[2];
          BOOL v16 = *v15 == v13;
          xpc_object_t v13 = v15;
        }
        while (!v16);
      }
      xpc_object_t v13 = v15;
      if (v15 == (void **)(v8 + 2328)) {
        goto LABEL_25;
      }
    }
    sub_10034D220((uint64_t *)&buf, (uint64_t)&v20);
    uint64_t v18 = a1[7];
    if (!v18) {
      sub_10007B600();
    }
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v18 + 48))(v18, &buf);
LABEL_14:
  sub_100313460((uint64_t)&buf, *((void **)&buf + 1));
  if (v9) {
LABEL_15:
  }
    sub_10004D2C8(v9);
  sub_100313460((uint64_t)&v20, v21);
}

void sub_10034D034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_100313460((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

uint64_t sub_10034D088(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10034D0C8()
{
}

uint64_t sub_10034D0D4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  sub_10034D13C(a1 + 24, a2 + 24);
  return a1;
}

void sub_10034D124(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10034D13C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_10034D1D4(uint64_t a1)
{
  sub_10034B83C((void *)(a1 + 24));
  long long v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t *sub_10034D220(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10034D278(a1, *(void ***)a2, (void **)(a2 + 8));
  return a1;
}

void sub_10034D260(_Unwind_Exception *a1)
{
  sub_100313460(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_10034D278(uint64_t *result, void **a2, void **a3)
{
  if (a2 != a3)
  {
    unsigned int v4 = a2;
    xpc_object_t v5 = (uint64_t **)result;
    uint64_t v6 = (uint64_t)(result + 1);
    do
    {
      uint64_t result = sub_10034D304(v5, v6, v4 + 4, (long long *)v4 + 2);
      long long v7 = (void **)v4[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          long long v7 = (void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void **)v4[2];
          BOOL v9 = *v8 == v4;
          unsigned int v4 = v8;
        }
        while (!v9);
      }
      unsigned int v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_10034D304(uint64_t **a1, uint64_t a2, void **a3, long long *a4)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v6 = sub_1000C6D50(a1, a2, &v12, &v11, a3);
  long long v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_10034D3A8((uint64_t)a1, a4, v10);
    sub_100046C38(a1, (uint64_t)v12, v8, v10[0]);
    long long v7 = v10[0];
    v10[0] = 0;
    sub_10031699C((uint64_t)v10, 0);
  }
  return v7;
}

void *sub_10034D3A8@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v6 = operator new(0x90uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = sub_10034D41C(v6 + 4, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_10034D404(_Unwind_Exception *a1)
{
  sub_10031699C(v1, 0);
  _Unwind_Resume(a1);
}

void *sub_10034D41C(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  sub_10034D494((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_10034D478(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10034D494(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }
  uint64_t v6 = (unsigned char *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)uint64_t v6 = v7;
  }
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  return a1;
}

void sub_10034D560(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10034D594(void *a1)
{
  long long v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10034D618(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10034DA68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16)
{
  if (a10) {
    (*((void (**)(dispatch_object_t))a10->isa + 1))(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void sub_10034DBD0(uint64_t a1)
{
  *(void *)a1 = off_1019BB2D0;
  if (*(char *)(a1 + 239) < 0) {
    operator delete(*(void **)(a1 + 216));
  }
  if (*(char *)(a1 + 215) < 0) {
    operator delete(*(void **)(a1 + 192));
  }
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  sub_100160A84((atomic_uint **)(a1 + 96));
  long long v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  CountryDeterminationInterface::~CountryDeterminationInterface((CountryDeterminationInterface *)a1);
}

void sub_10034DCA4(uint64_t a1)
{
  sub_10034DBD0(a1);

  operator delete();
}

void sub_10034DCDC(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10034DDDC(uint64_t a1, xpc_object_t object)
{
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_null_create();
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10034DEFC(uint64_t a1, double a2, double a3)
{
  (*(void (**)(void))(**(void **)(a1 + 80) + 64))(*(void *)(a1 + 80));
  if (*(unsigned char *)(a1 + 120))
  {
    *(double *)(a1 + 128) = a2;
    *(double *)(a1 + 136) = a3;
    *(unsigned char *)(a1 + 120) = 0;
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134283777;
      *(double *)&void buf[4] = a2;
      *(_WORD *)&buf[12] = 2049;
      *(double *)&buf[14] = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I location acquired: lat=%{private}f, long=%{private}f", buf, 0x16u);
    }
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_10034E124;
    v13[3] = &unk_1019A1BF8;
    v13[4] = a1;
    long long v7 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v7 || (uint64_t v8 = *(void *)(a1 + 8), (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v10 = v9;
    uint64_t v11 = *(NSObject **)(a1 + 24);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3321888768;
    *(void *)&uint8_t buf[16] = sub_100354110;
    std::string v15 = &unk_1019BB930;
    uint64_t v17 = v8;
    uint64_t v18 = v10;
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v16 = v13;
    dispatch_async(v11, buf);
    if (v18) {
      sub_10004D2C8(v18);
    }
    sub_10004D2C8(v10);
  }
  else
  {
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I ignoring unsolicited update", buf, 2u);
    }
  }
}

void sub_10034E118(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10034E124(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  double v2 = *(double *)(v1 + 128);
  double v3 = *(double *)(v1 + 136);
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  v17[0] = "CTLocationBasedCountryDetermination";
  sub_1002BFAE4(v17, (dispatch_object_t *)(v1 + 24), &v11);
  Registry::createRestModuleOneTimeUseMobileHelperConnection(&v9, *(Registry **)(v1 + 48));
  ctu::RestModule::connect();
  if (v10) {
    sub_10004D2C8(v10);
  }
  rest::LocationCoordinate::LocationCoordinate((rest::LocationCoordinate *)v8, v2, v3);
  uint64_t v6 = v11;
  long long v5 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_object_t v16 = 0;
  rest::write_rest_value((rest *)v8, v4);
  sub_100058DB0(&__p, "/helper/requests/civic_info_from_location");
  xpc_object_t object = v16;
  xpc_object_t v16 = xpc_null_create();
  long long v7 = (char *)operator new(0x20uLL);
  *(void *)long long v7 = off_1019BB970;
  *((void *)v7 + 1) = v1;
  *((void *)v7 + 2) = v6;
  *((void *)v7 + 3) = v5;
  v17[3] = v7;
  ctu::RestModule::sendRequest();
  sub_10003F600(v17);
  xpc_release(object);
  xpc_object_t object = 0;
  if (v15 < 0) {
    operator delete(__p);
  }
  xpc_release(v16);
  if (v12) {
    sub_10004D2C8(v12);
  }
}

void sub_10034E2B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,xpc_object_t a22,char a23)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10034E370(void *a1, long long *a2, long long *a3, long long *a4, long long *a5)
{
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3321888768;
  v14[2] = sub_10034E5D8;
  v14[3] = &unk_1019BB348;
  v14[4] = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v15, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v15 = *a2;
    uint64_t v16 = *((void *)a2 + 2);
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&v17, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v17 = *a3;
    uint64_t v18 = *((void *)a3 + 2);
  }
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(&v19, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v19 = *a4;
    uint64_t v20 = *((void *)a4 + 2);
  }
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long __p = *a5;
    uint64_t v22 = *((void *)a5 + 2);
  }
  uint64_t v9 = (std::__shared_weak_count *)a1[2];
  if (!v9 || (v10 = a1[1], (uint64_t v11 = std::__shared_weak_count::lock(v9)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v12 = v11;
  xpc_object_t v13 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_100354110;
  block[3] = &unk_1019BB930;
  block[5] = v10;
  uint64_t v24 = v12;
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v14;
  dispatch_async(v13, block);
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_10004D2C8(v12);
  if (SHIBYTE(v22) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete((void *)v19);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)v17);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)v15);
  }
}

void sub_10034E588(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_10034E5D8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(a1 + 63) < 0) {
    sub_10004FC84(&__dst, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else {
    std::string __dst = *(std::string *)(a1 + 40);
  }
  if (*(char *)(a1 + 87) < 0) {
    sub_10004FC84(&v5, *(void **)(a1 + 64), *(void *)(a1 + 72));
  }
  else {
    std::string v5 = *(std::string *)(a1 + 64);
  }
  if (*(char *)(a1 + 111) < 0) {
    sub_10004FC84(&v4, *(void **)(a1 + 88), *(void *)(a1 + 96));
  }
  else {
    std::string v4 = *(std::string *)(a1 + 88);
  }
  if (*(char *)(a1 + 135) < 0) {
    sub_10004FC84(&__p, *(void **)(a1 + 112), *(void *)(a1 + 120));
  }
  else {
    std::string __p = *(std::string *)(a1 + 112);
  }
  sub_10034E770(v2, &__dst, &v5, &v4, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v4.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v5.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

void sub_10034E70C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (*(char *)(v28 - 25) < 0) {
    operator delete(*(void **)(v28 - 48));
  }
  _Unwind_Resume(exception_object);
}

void sub_10034E770(uint64_t a1, const std::string *a2, const std::string *a3, const std::string *a4, const std::string *a5)
{
  uint64_t v9 = (void *)(a1 + 144);
  std::string::operator=((std::string *)(a1 + 144), a2);
  uint64_t v10 = (void *)(a1 + 168);
  std::string::operator=((std::string *)(a1 + 168), a3);
  uint64_t v11 = (void *)(a1 + 192);
  std::string::operator=((std::string *)(a1 + 192), a4);
  uint64_t v12 = (void *)(a1 + 216);
  std::string::operator=((std::string *)(a1 + 216), a5);
  xpc_object_t v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 167) < 0) {
      uint64_t v9 = (void *)*v9;
    }
    if (*(char *)(a1 + 191) < 0) {
      uint64_t v10 = (void *)*v10;
    }
    if (*(char *)(a1 + 215) < 0) {
      uint64_t v11 = (void *)*v11;
    }
    if (*(char *)(a1 + 239) < 0) {
      uint64_t v12 = (void *)*v12;
    }
    int v16 = 136315906;
    long long v17 = v9;
    __int16 v18 = 2080;
    long long v19 = v10;
    __int16 v20 = 2080;
    CFTypeRef v21 = v11;
    __int16 v22 = 2080;
    uint64_t v23 = v12;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Civic received: country='%s', state='%s', city='%s', postalCode='%s'", (uint8_t *)&v16, 0x2Au);
  }
  if ((*(char *)(a1 + 167) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(a1 + 167)) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  if (*(void *)(a1 + 152))
  {
LABEL_13:
    std::string v14 = (uint64_t *)sub_100161CDC(&event::location::CountryOfOriginationAvailable[1]);
    sub_10035414C(v14);
  }
LABEL_14:
  if (*(char *)(a1 + 191) < 0)
  {
    if (!*(void *)(a1 + 176)) {
      return;
    }
  }
  else if (!*(unsigned char *)(a1 + 191))
  {
    return;
  }
  long long v15 = (uint64_t *)sub_100161CDC(&event::location::CivicInfoAvailable[1]);
  sub_10035414C(v15);
}

unsigned char *sub_10034E910(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }
  if (*(char *)(a2 + 87) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 64), *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = v5;
  }
  if (*(char *)(a2 + 111) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 88), *(void **)(a2 + 88), *(void *)(a2 + 96));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 88);
    *(void *)(a1 + 104) = *(void *)(a2 + 104);
    *(_OWORD *)(a1 + 88) = v6;
  }
  uint64_t result = (unsigned char *)(a1 + 112);
  if (*(char *)(a2 + 135) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 112), *(void *)(a2 + 120));
  }
  long long v8 = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(_OWORD *)uint64_t result = v8;
  return result;
}

void sub_10034EA00(_Unwind_Exception *exception_object)
{
  if (v2[111] < 0) {
    operator delete(*v4);
  }
  if (v2[87] < 0) {
    operator delete(*v3);
  }
  if (v2[63] < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10034EA4C(uint64_t a1)
{
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    operator delete(v2);
  }
}

uint64_t sub_10034EAC4(uint64_t a1, int a2)
{
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  uint64_t v4 = (*(unsigned int (**)(uint64_t))(*(void *)a1 + 48))(a1) | a2;
  if (v4 == 1)
  {
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_10034ECF8;
    v17[3] = &unk_1019BB378;
    v17[4] = a1;
    char v18 = a2;
    long long v5 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v5 || (uint64_t v6 = *(void *)(a1 + 8), (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
      sub_100088B9C();
    }
    long long v8 = v7;
    uint64_t v9 = *(NSObject **)(a1 + 24);
    *(void *)&long long block = _NSConcreteStackBlock;
    *((void *)&block + 1) = 3321888768;
    __int16 v20 = sub_100354110;
    CFTypeRef v21 = &unk_1019BB930;
    uint64_t v23 = v6;
    uint64_t v24 = v8;
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    __int16 v22 = v17;
    dispatch_async(v9, &block);
    if (v24) {
      sub_10004D2C8(v24);
    }
    sub_10004D2C8(v8);
    *(unsigned char *)(a1 + 120) = 1;
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = "false";
      if (a2) {
        uint64_t v11 = "true";
      }
      LODWORD(block) = 136315138;
      *(void *)((char *)&block + 4) = v11;
      uint64_t v12 = "#I start location lookup. Force location lookup: %s";
      xpc_object_t v13 = v10;
      uint32_t v14 = 12;
      goto LABEL_12;
    }
  }
  else
  {
    long long v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(block) = 0;
      uint64_t v12 = "#I location service not authorized";
      xpc_object_t v13 = v15;
      uint32_t v14 = 2;
LABEL_12:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&block, v14);
    }
  }
  return v4;
}

void sub_10034ECEC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_10034ECF8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  (*(void (**)(void))(**(void **)(v1 + 80) + 64))(*(void *)(v1 + 80));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(v1 + 80) + 56);

  return v2();
}

void sub_10034ED7C(uint64_t a1, uint64_t a2, double a3, double a4)
{
  uint64_t v6 = a1;
  double v7 = a3;
  double v8 = a4;
  sub_10012CB18((uint64_t)&v9, a2);
  long long v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10034EEC0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10034EED0(uint64_t a1, uint64_t *a2, uint64_t a3, double a4, double a5)
{
  uint64_t v8 = a1;
  double v9 = a4;
  double v10 = a5;
  uint64_t v6 = a2[1];
  uint64_t v11 = *a2;
  uint64_t v12 = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100355968((uint64_t)&v13, a3);
  double v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10034F04C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10034F05C(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  uint64_t v8 = 0;
  double v9 = 0;
  sub_1006D6404("CTLocationBasedCountryDetermination", &v8);
  if (v8)
  {
    uint64_t v6 = v8;
    double v7 = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1006D8DC0((uint64_t)&v6, a2);
    if (v7) {
      sub_10004D2C8(v7);
    }
  }
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v5 = a2;
    }
    else {
      long long v5 = (std::string *)a2->__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I country code from GEOCountryConfiguration: %s", buf, 0xCu);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_10034F16C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (*(char *)(v12 + 23) < 0) {
    operator delete(*(void **)v12);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10034F1A8(Registry **a1, uint64_t a2)
{
  uint64_t v4 = "loc.???";
  if (a2 == 2) {
    uint64_t v4 = "loc.2";
  }
  if (a2 == 1) {
    long long v5 = "loc.1";
  }
  else {
    long long v5 = v4;
  }
  uint64_t v55 = 0;
  v56 = 0;
  sub_1006D6404("CTLocationBasedCountryDetermination", &v55);
  if (v55)
  {
    memset(&v54, 0, sizeof(v54));
    uint64_t v52 = v55;
    uint64_t v53 = v56;
    if (v56) {
      atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v6 = (unint64_t)sub_1006D8DC0((uint64_t)&v52, &v54) >> 32;
    if (v53) {
      sub_10004D2C8(v53);
    }
    if (v6)
    {
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, v5);
      double v7 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      BOOL v8 = 1;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v6;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "Got error getting country code %d", buf, 8u);
      }
      goto LABEL_67;
    }
    double v10 = (const char *)kCtLoggingSystemName;
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, v5);
    uint64_t v11 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      uint64_t v12 = &v54;
      if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v12 = (std::string *)v54.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Got current country code = %s", buf, 0xCu);
    }
    std::string::size_type size = HIBYTE(v54.__r_.__value_.__r.__words[2]);
    if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v54.__r_.__value_.__l.__size_;
    }
    if (!size)
    {
      BOOL v8 = 1;
LABEL_67:
      if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v54.__r_.__value_.__l.__data_);
      }
      goto LABEL_69;
    }
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v51 = 0;
    v47 = 0;
    uint64_t v48 = 0;
    uint64_t v49 = 0;
    PersonalityIdFromSlotIdEx();
    ServiceMap = (std::mutex *)Registry::getServiceMap(0, *a1);
    long long v15 = ServiceMap;
    if (v16 < 0)
    {
      long long v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v18 = 5381;
      do
      {
        uint64_t v16 = v18;
        unsigned int v19 = *v17++;
        uint64_t v18 = (33 * v18) ^ v19;
      }
      while (v19);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v16;
    __int16 v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
    if (v20)
    {
      uint64_t v22 = v20[3];
      CFTypeRef v21 = (std::__shared_weak_count *)v20[4];
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v15);
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
        char v23 = 0;
        if (!v22) {
          goto LABEL_37;
        }
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    std::mutex::unlock(v15);
    CFTypeRef v21 = 0;
    char v23 = 1;
    if (!v22) {
      goto LABEL_37;
    }
LABEL_34:
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v22 + 16))(buf, v22, a2);
    if (SHIBYTE(v51) < 0) {
      operator delete(__p[0]);
    }
    *(_OWORD *)std::string __p = *(_OWORD *)buf;
    uint64_t v51 = v59;
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v10, "loc-cd");
    uint64_t v24 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
    {
      long long v44 = __p;
      if (v51 < 0) {
        long long v44 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v44;
      _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "check with subscriber MCC %s", buf, 0xCu);
      if (v23)
      {
LABEL_39:
        CFTypeRef v25 = (void *)HIBYTE(v51);
        if (v51 < 0) {
          CFTypeRef v25 = __p[1];
        }
        if (!v25)
        {
          ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v10, v5);
          v41 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          BOOL v8 = 1;
          if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_INFO, "invalid homeMcc", buf, 2u);
          }
          goto LABEL_63;
        }
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v10, v5);
        CFTypeRef v26 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
        {
          long long v27 = __p;
          if (v51 < 0) {
            long long v27 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v27;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_INFO, "got Home MCC %s", buf, 0xCu);
        }
        std::locale::locale((std::locale *)&v45);
        std::string::size_type v28 = HIBYTE(v54.__r_.__value_.__r.__words[2]);
        uint64_t v29 = &v54;
        if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          std::string::size_type v28 = v54.__r_.__value_.__l.__size_;
          uint64_t v29 = (std::string *)v54.__r_.__value_.__r.__words[0];
        }
        *(void *)long long buf = v29;
        *(void *)&uint8_t buf[8] = (char *)v29 + v28;
        sub_1003563F0((char **)buf, (std::locale *)&v45);
        std::locale::~locale((std::locale *)&v45);
        memset(buf, 0, sizeof(buf));
        *(void *)&long long v59 = 0;
        uint64_t v31 = (std::mutex *)Registry::getServiceMap(v30, *a1);
        long long v32 = v31;
        if (v33 < 0)
        {
          long long v34 = (unsigned __int8 *)(v33 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v35 = 5381;
          do
          {
            uint64_t v33 = v35;
            unsigned int v36 = *v34++;
            uint64_t v35 = (33 * v35) ^ v36;
          }
          while (v36);
        }
        std::mutex::lock(v31);
        *(void *)&long long v45 = v33;
        unint64_t v37 = sub_10004D37C(&v32[1].__m_.__sig, (unint64_t *)&v45);
        if (v37)
        {
          uint64_t v39 = v37[3];
          uint64_t v38 = (std::__shared_weak_count *)v37[4];
          if (v38)
          {
            atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v32);
            atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v38);
            char v40 = 0;
            if (!v39) {
              goto LABEL_60;
            }
            goto LABEL_59;
          }
        }
        else
        {
          uint64_t v39 = 0;
        }
        std::mutex::unlock(v32);
        uint64_t v38 = 0;
        char v40 = 1;
        if (!v39)
        {
LABEL_60:
          if ((v40 & 1) == 0) {
            sub_10004D2C8(v38);
          }
          LOBYTE(v45) = 0;
          uint64_t v42 = sub_1000D8740(*(uint64_t *)buf, *(uint64_t *)&buf[8], (unsigned __int8 **)__p);
          BOOL v8 = v42 != *(void *)&buf[8];
          *(void *)&long long v45 = buf;
          sub_100047F64((void ***)&v45);
LABEL_63:
          if (SHIBYTE(v49) < 0) {
            operator delete(v47);
          }
          if (SHIBYTE(v51) < 0) {
            operator delete(__p[0]);
          }
          goto LABEL_67;
        }
LABEL_59:
        (*(void (**)(long long *__return_ptr, uint64_t, std::string *))(*(void *)v39 + 64))(&v45, v39, &v54);
        sub_10005CBB4((uint64_t *)buf);
        *(_OWORD *)long long buf = v45;
        *(void *)&long long v59 = v46;
        uint64_t v46 = 0;
        long long v45 = 0uLL;
        *(void *)uint64_t v57 = &v45;
        sub_100047F64((void ***)v57);
        goto LABEL_60;
      }
LABEL_38:
      sub_10004D2C8(v21);
      goto LABEL_39;
    }
LABEL_37:
    if (v23) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "loc-cd");
  double v9 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  BOOL v8 = 1;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "failed to create Mobile Helper client", buf, 2u);
  }
LABEL_69:
  if (v56) {
    sub_10004D2C8(v56);
  }
  return v8;
}

void sub_10034FB60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,std::__shared_weak_count *a33,uint64_t a34,uint64_t a35,char a36)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_100350940((uint64_t)&a36);
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a33) {
    sub_10004D2C8(a33);
  }
  _Unwind_Resume(a1);
}

void sub_10034FCA4(Registry *a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, a1);
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    unint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v5;
  double v9 = sub_10004D37C(&v4[1].__m_.__sig, &v12);
  if (v9)
  {
    uint64_t v11 = v9[3];
    double v10 = (std::__shared_weak_count *)v9[4];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v11 = 0;
    double v10 = 0;
  }
  std::mutex::unlock(v4);
  *a2 = v11;
  a2[1] = (uint64_t)v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
}

void sub_10034FD6C(uint64_t a1@<X0>, void *a2@<X8>)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10034FED0;
  v4[3] = &unk_1019BB398;
  v4[4] = a1;
  unint64_t v5 = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_100356478;
  v6[3] = &unk_1019ADCC0;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  uint64_t v7 = v6;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    double v10 = sub_10035648C;
    uint64_t v11 = &unk_10199E470;
    unint64_t v12 = a2;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    double v10 = sub_100003D98;
    uint64_t v11 = &unk_10199E470;
    unint64_t v12 = a2;
    uint64_t v13 = &v7;
    dispatch_sync(v2, &block);
  }
}

void *sub_10034FED0@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = result[4];
  if (*(char *)(v2 + 167) < 0) {
    return sub_10004FC84((unsigned char *)a2, *(void **)(v2 + 144), *(void *)(v2 + 152));
  }
  long long v3 = *(_OWORD *)(v2 + 144);
  *(void *)(a2 + 16) = *(void *)(v2 + 160);
  *(_OWORD *)a2 = v3;
  return result;
}

std::string *sub_10034FEFC(const std::string *a1, std::string::size_type *a2, void *a3, std::string *this, std::string *a5, std::string *a6, std::string *a7)
{
  *a2 = a1[5].__r_.__value_.__l.__size_;
  *a3 = *((void *)&a1[5].__r_.__value_.__l + 2);
  std::string::operator=(this, a1 + 6);
  std::string::operator=(a5, a1 + 7);
  std::string::operator=(a6, a1 + 8);

  return std::string::operator=(a7, a1 + 9);
}

void sub_10034FF7C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10035005C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 80);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 72))();
  }
  return result;
}

uint64_t sub_10035008C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 80);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 80))();
  }
  return result;
}

uint64_t sub_1003500BC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 80);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 88))();
  }
  return result;
}

uint64_t sub_1003500EC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 80);
  if (result)
  {
    if (*(unsigned char *)(a1 + 240) && !*(unsigned char *)(a1 + 243))
    {
      *(unsigned char *)(a1 + 243) = 1;
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
    }
    if (*(unsigned char *)(a1 + 242))
    {
      uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(a1 + 80) + 48))(*(void *)(a1 + 80), *(unsigned __int8 *)(a1 + 241));
      if (*(unsigned char *)(a1 + 242)) {
        *(unsigned char *)(a1 + 242) = 0;
      }
    }
  }
  return result;
}

void sub_100350190(void *a1, char a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1003502AC;
  v8[3] = &unk_1019BB378;
  v8[4] = a1;
  char v9 = a2;
  long long v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  unint64_t v6 = v5;
  uint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_100354110;
  block[3] = &unk_1019BB930;
  block[5] = v4;
  uint64_t v11 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v6);
}

uint64_t sub_1003502AC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  int v2 = *(unsigned __int8 *)(v1 + 240);
  int v3 = *(unsigned __int8 *)(result + 40);
  if (v2 != v3)
  {
    uint64_t v4 = result;
    unint64_t v5 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v6 = "true";
      if (v2) {
        uint64_t v7 = "true";
      }
      else {
        uint64_t v7 = "false";
      }
      if (!v3) {
        unint64_t v6 = "false";
      }
      int v8 = 136315394;
      char v9 = v7;
      __int16 v10 = 2080;
      uint64_t v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I setVoWiFiFeatureEnabled: %s -> %s", (uint8_t *)&v8, 0x16u);
      LOBYTE(v3) = *(unsigned char *)(v4 + 40);
    }
    *(unsigned char *)(v1 + 240) = v3;
    return sub_1003500EC(v1);
  }
  return result;
}

void sub_1003503A8(void *a1, char a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1003504C4;
  v8[3] = &unk_1019BB378;
  v8[4] = a1;
  char v9 = a2;
  int v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  unint64_t v6 = v5;
  uint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_100354110;
  block[3] = &unk_1019BB930;
  block[5] = v4;
  uint64_t v11 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v6);
}

void sub_1003504C4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 40)) {
      uint64_t v4 = "true";
    }
    else {
      uint64_t v4 = "false";
    }
    int v8 = 136315138;
    char v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I enableVoWiFiLocationStatus: %s", (uint8_t *)&v8, 0xCu);
  }
  sub_1003500EC(v2);
  uint64_t v5 = *(void *)(v2 + 80);
  if (v5)
  {
    (*(void (**)(uint64_t, void))(*(void *)v5 + 48))(v5, *(unsigned __int8 *)(a1 + 40));
  }
  else
  {
    *(_WORD *)(v2 + 241) = *(unsigned __int8 *)(a1 + 40) | 0x100;
    unint64_t v6 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 40)) {
        uint64_t v7 = "true";
      }
      else {
        uint64_t v7 = "false";
      }
      int v8 = 136315138;
      char v9 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I enableVoWiFiLocationStatus: WifiCalling location is not ready. Queueing pending LocationStatus enabled: %s", (uint8_t *)&v8, 0xCu);
    }
  }
}

uint64_t sub_100350634(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v14) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I ------ LocationBasedCountryDetermination state ------", (uint8_t *)&v14, 2u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 240)) {
      int v3 = "true";
    }
    else {
      int v3 = "false";
    }
    int v14 = 136315138;
    long long v15 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I VoWiFiFeatureEnabled: %s", (uint8_t *)&v14, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 242))
    {
      if (*(unsigned char *)(a1 + 241)) {
        uint64_t v4 = "true";
      }
      else {
        uint64_t v4 = "false";
      }
    }
    else
    {
      uint64_t v4 = "none";
    }
    int v14 = 136315138;
    long long v15 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fPendingLocationStatusEnabled: %s", (uint8_t *)&v14, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 80)) {
      uint64_t v5 = "valid";
    }
    else {
      uint64_t v5 = "missing";
    }
    if (*(unsigned char *)(a1 + 120)) {
      unint64_t v6 = "true";
    }
    else {
      unint64_t v6 = "false";
    }
    int v14 = 136315394;
    long long v15 = v5;
    __int16 v16 = 2080;
    long long v17 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I WifiLocation: %s, RequestedLocation: %s", (uint8_t *)&v14, 0x16u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(const char **)(a1 + 128);
    uint64_t v7 = *(const char **)(a1 + 136);
    int v14 = 134283777;
    long long v15 = v7;
    __int16 v16 = 2049;
    long long v17 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Longitude: %{private}f, Latitude: %{private}f", (uint8_t *)&v14, 0x16u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    char v9 = (const char *)(a1 + 144);
    if (*(char *)(a1 + 167) < 0) {
      char v9 = *(const char **)v9;
    }
    __int16 v10 = (const char *)(a1 + 168);
    if (*(char *)(a1 + 191) < 0) {
      __int16 v10 = *(const char **)v10;
    }
    uint64_t v11 = (void *)(a1 + 192);
    if (*(char *)(a1 + 215) < 0) {
      uint64_t v11 = (void *)*v11;
    }
    unint64_t v12 = (void *)(a1 + 216);
    if (*(char *)(a1 + 239) < 0) {
      unint64_t v12 = (void *)*v12;
    }
    int v14 = 136315906;
    long long v15 = v9;
    __int16 v16 = 2080;
    long long v17 = v10;
    __int16 v18 = 2080;
    unsigned int v19 = v11;
    __int16 v20 = 2080;
    CFTypeRef v21 = v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I LastKnownCountryCode: '%s', LastKnownState: '%s', LastKnownCity: '%s', LastKnownPostalCode: '%s'", (uint8_t *)&v14, 0x2Au);
  }
  uint64_t result = *(void *)(a1 + 80);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 96))(result);
  }
  return result;
}

uint64_t sub_100350940(uint64_t a1)
{
  if (*(char *)(a1 + 255) < 0) {
    operator delete(*(void **)(a1 + 232));
  }
  if (*(char *)(a1 + 231) < 0) {
    operator delete(*(void **)(a1 + 208));
  }
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  if (*(char *)(a1 + 175) < 0) {
    operator delete(*(void **)(a1 + 152));
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  int v3 = (void **)(a1 + 48);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100350A10(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100350A48(uint64_t a1)
{
}

uint64_t sub_100350A64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100350AA8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100350AD4(ServiceManager::Service *this)
{
  *(void *)this = off_1019BB568;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100350B30(ServiceManager::Service *this)
{
  *(void *)this = off_1019BB568;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100350BA0@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "CTLocationBasedCountryDetermination");
}

unsigned char *sub_100350BB0@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100350BF0(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_10034DCDC(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_10034DCDC(v4, 0);
}

uint64_t sub_100350C74()
{
  return 1;
}

uint64_t sub_100350C7C()
{
  return 1;
}

uint64_t sub_100350C84()
{
  return 2;
}

void sub_100350C8C(uint64_t a1, xpc_object_t *a2, NSObject **a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  xpc_object_t v5 = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  unint64_t v6 = *a3;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(v6);
    sub_10034DDDC(v4, v5);
  }
  sub_10034DDDC(v4, v5);
}

void sub_100350D28(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100350E08(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100350F1C(ServiceManager::Service *this)
{
  *(void *)this = off_1019BB568;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100350F78(ServiceManager::Service *this)
{
  *(void *)this = off_1019BB568;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_100350FE8()
{
  return 0;
}

uint64_t sub_100350FF0()
{
  return 0;
}

void sub_100350FFC(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  int v8 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *v1 + 8;
  aBlock[6] = 0;
  __int16 v10 = 0;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 3221225472;
  aBlock[2] = sub_100351438;
  aBlock[3] = &unk_1019BB5C0;
  aBlock[4] = v3;
  aBlock[5] = sub_10034DEFC;
  __int16 v10 = _Block_copy(aBlock);
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 16);
  if (v4)
  {
    xpc_object_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      unint64_t v6 = v5;
      sub_100352B38(v11, &v10, *(dispatch_object_t *)(v2 + 24));
      sub_100352B80(&v12, v11);
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10035131C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28)
{
  if (a2)
  {
    sub_100163BC8(v29 - 80);
    if (a26) {
      (*(void (**)(uint64_t))(*(void *)a26 + 8))(a26);
    }
    std::__shared_weak_count::__release_weak(v28);
    sub_100351484((uint64_t)&a27);
    sub_100353AFC((uint64_t)&a24);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100351438(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100351484(uint64_t a1)
{
  sub_100353778((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

uint64_t sub_1003514C4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100351508(uint64_t *a1)
{
  memset(v3, 0, sizeof(v3));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v3, v2);
  sub_100351600(a1, v3);
}

void sub_1003515D0(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100351600(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_1003516F8(a1, a2);
}

void sub_1003516E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10000A740((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_1003516F8(uint64_t *a1, void *a2)
{
}

void sub_10035176C()
{
}

uint64_t sub_100351790(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_1003517D4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_100351818(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  if (!v2 || atomic_load_explicit((atomic_uint *volatile)(v2 + 8), memory_order_acquire) != 1) {
    operator new();
  }

  return sub_100351B34(a1, a2, 1, 2);
}

void sub_100351914()
{
}

void sub_100351938(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_100351BE8(&v2, a2);
}

uint64_t sub_1003519B4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t *sub_1003519F8(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  uint64_t v22 = *a4;
  __int16 v10 = (uint64_t *)sub_100351790(a1);
  uint64_t result = (uint64_t *)sub_100352AF4(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_1003517D4(result + 2);
        sub_10035221C(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_1003517D4(result + 2) + 24))
      {
        long long v15 = (atomic_uint *)v22[1];
      }
      else
      {
        __int16 v16 = (uint64_t *)sub_100351790(a1);
        uint64_t v17 = sub_100352AF4(v16);
        uint64_t v18 = sub_1003517D4(v22 + 2);
        long long v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      uint64_t v22 = (uint64_t *)v15;
      unsigned int v19 = (uint64_t *)sub_100351790(a1);
      __int16 v20 = (uint64_t *)sub_100352AF4(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t *sub_100351B34(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  char v9 = (uint64_t *)sub_100351790(a1);
  uint64_t v10 = sub_100352AF4(v9);
  uint64_t v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    unsigned int v12 = (uint64_t *)sub_100351790(a1);
    uint64_t v11 = *(uint64_t **)(sub_100352AF4(v12) + 8);
  }
  uint64_t v14 = v11;
  return sub_1003519F8(a1, a2, a3, &v14, a4);
}

void sub_100351BE8(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100351C54(&v2);
}

void sub_100351C40(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100351C54(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100351CC4(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_100351CD8(_Unwind_Exception *a1)
{
}

void sub_100351CF0()
{
}

uint64_t sub_100351D04(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100351D68()
{
  return 0;
}

uint64_t sub_100351D70()
{
  return 0;
}

uint64_t sub_100351D78()
{
  return 0;
}

void sub_100351D80()
{
}

void sub_100351DFC()
{
}

uint64_t sub_100351E20(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100351FAC((uint64_t *)a1, a2);
  sub_100352018((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  unint64_t v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    uint64_t v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      uint64_t v10 = (void *)v5[1];
      uint64_t v11 = v10;
      unsigned int v12 = v5;
      if (v10)
      {
        do
        {
          unsigned int v13 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          unsigned int v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          __int16 v16 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          __int16 v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      uint64_t v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          uint64_t v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      uint64_t v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_100351F84(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100351FAC(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_100352004(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100352018(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_100352068(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_100352080(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1003520EC(&v2);
}

void sub_1003520D8(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1003520EC(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10035215C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_100352170(_Unwind_Exception *a1)
{
}

void sub_100352188()
{
}

uint64_t sub_10035219C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_100352204()
{
  return 0;
}

uint64_t sub_10035220C()
{
  return 0;
}

uint64_t sub_100352214()
{
  return 0;
}

uint64_t *sub_10035221C(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    unint64_t v6 = (uint64_t *)sub_100352284(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_100352284(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_1003522C8(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)a1 = off_1019BB6B0;
  operator new();
}

void sub_1003523DC(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100163C60((void ***)va);
  operator delete();
}

void sub_100352444(uint64_t a1)
{
  sub_1003527F8(a1);

  operator delete();
}

BOOL sub_10035247C(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v4, v2);
  sub_100352868((atomic_uint **)v1, v4);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v5 + 1));
  sub_10000A5F8(v4);
  return v1 != 0;
}

void sub_10035252C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10035255C(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_100352588(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_1003525B4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

void sub_100352610(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10035267C(&v2);
}

void sub_100352668(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10035267C(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1003526EC(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100352714(v1);
  __cxa_rethrow();
}

void sub_100352700(_Unwind_Exception *a1)
{
}

uint64_t sub_100352714(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100353778((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_100352774()
{
}

uint64_t sub_100352788(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100353778((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_1003527E0()
{
  return 0;
}

uint64_t sub_1003527E8()
{
  return 0;
}

uint64_t sub_1003527F0()
{
  return 0;
}

uint64_t sub_1003527F8(uint64_t a1)
{
  *(void *)a1 = off_1019BB6B0;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

atomic_uint **sub_100352868(atomic_uint **result, void *a2)
{
  uint64_t v2 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v4 = result;
    for (uint64_t i = *(atomic_uint **)sub_100352284((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_100352284(v2);
      if (i == result[1]) {
        break;
      }
      memset(v6, 0, sizeof(v6));
      sub_100060B10(i, (uint64_t)v6);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v4 + 24))
        {
          *((unsigned char *)v4 + 24) = 0;
          sub_100163448(v4, a2);
        }
        return sub_1000624B4((uint64_t)v6);
      }
      sub_1000624B4((uint64_t)v6);
    }
  }
  return result;
}

void sub_10035294C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10035296C(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1003529D8(&v2);
}

void sub_1003529C4(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1003529D8(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100352A48(void *a1)
{
  __cxa_begin_catch(a1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  __cxa_rethrow();
}

void sub_100352A80(_Unwind_Exception *a1)
{
}

void sub_100352A98()
{
}

uint64_t sub_100352AAC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100352ADC()
{
  return 0;
}

uint64_t sub_100352AE4()
{
  return 0;
}

uint64_t sub_100352AEC()
{
  return 0;
}

uint64_t sub_100352AF4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

dispatch_object_t *sub_100352B38(dispatch_object_t *a1, void **a2, dispatch_object_t object)
{
  *a1 = object;
  uint64_t v4 = *a2;
  if (*a2)
  {
    uint64_t v4 = _Block_copy(v4);
    xpc_object_t object = *a1;
  }
  a1[1] = v4;
  dispatch_retain(object);
  return a1;
}

_OWORD *sub_100352B80(_OWORD *a1, NSObject **a2)
{
  *a1 = 0u;
  a1[1] = 0u;
  sub_100352BD8((uint64_t)a1, a2);
  return a1;
}

void sub_100352BB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  sub_100353778((uint64_t *)(v10 + 24));
  a10 = (void **)v10;
  sub_100163C60(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100352BD8(uint64_t a1, NSObject **a2)
{
  sub_100352CB4(v4, a2);
  sub_100352C30((uint64_t *)(a1 + 24), v4);
  return sub_100353AFC((uint64_t)v4);
}

void sub_100352C1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_100352C30(uint64_t *a1, NSObject **a2)
{
  sub_100352CB4(v4, a2);
  sub_100352D7C(v5, v4);
  sub_100352D00(v5, a1);
  sub_100353778(v5);
  sub_100353AFC((uint64_t)v4);
  return a1;
}

void sub_100352C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

NSObject **sub_100352CB4(NSObject **a1, NSObject **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  *a1 = *a2;
  if (v4)
  {
    uint64_t v4 = _Block_copy(v4);
    uint64_t v3 = *a1;
  }
  a1[1] = v4;
  dispatch_retain(v3);
  return a1;
}

uint64_t *sub_100352D00(uint64_t *result, uint64_t *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = (uint64_t)result;
    memset(v4, 0, sizeof(v4));
    sub_1003536B8((uint64_t)v4, result);
    sub_1003536B8(v3, a2);
    sub_1003536B8((uint64_t)a2, (uint64_t *)v4);
    return sub_100353778((uint64_t *)v4);
  }
  return result;
}

void sub_100352D68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100352D7C(void *a1, NSObject **a2)
{
  sub_100352CB4(v4, a2);
  sub_100352DDC(a1, v4);
  sub_100353AFC((uint64_t)v4);
  return a1;
}

void sub_100352DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100352DDC(void *a1, NSObject **a2)
{
  *a1 = 0;
  sub_100352CB4(v4, a2);
  sub_100352E3C((uint64_t)a1, v4);
  sub_100353AFC((uint64_t)v4);
  return a1;
}

void sub_100352E28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100352E3C(uint64_t a1, NSObject **a2)
{
  sub_100352CB4(v6, a2);
  int v3 = sub_100352F94((uint64_t)off_1019BB7B8, v6, (NSObject **)(a1 + 8));
  uint64_t result = sub_100353AFC((uint64_t)v6);
  if (v3) {
    long long v5 = off_1019BB7B8;
  }
  else {
    long long v5 = 0;
  }
  *(void *)a1 = v5;
  return result;
}

void sub_100352EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100352EB8(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)sub_100352CB4((NSObject **)a2, (NSObject **)result);
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_100353AFC(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvddEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvddEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

uint64_t sub_100352F94(uint64_t a1, NSObject **a2, NSObject **a3)
{
  sub_100352CB4(v7, a2);
  uint64_t v5 = sub_100353670(a1, v7, a3);
  sub_100353AFC((uint64_t)v7);
  return v5;
}

void sub_100352FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100352FFC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  if (v1) {
    uint64_t v1 = _Block_copy(v1);
  }
  aBlock = v1;
  sub_1003532F8(&v3, &aBlock);
  operator new();
}

void sub_100353164(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, char a10)
{
}

uint64_t sub_1003531B8(uint64_t a1)
{
  sub_100353260(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100353778(v2);
    operator delete();
  }
  if (*(void *)(a1 + 40)) {
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 48);
  if (result)
  {
    operator delete();
  }
  return result;
}

uint64_t sub_100353260(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  uint64_t v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_1003532E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void *sub_1003532F8(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlock = v3;
  sub_100353374(a1, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return a1;
}

void sub_100353358(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100353374(void *a1, void **a2)
{
  *a1 = 0;
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlock = v3;
  sub_1003533F0((uint64_t)a1, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return a1;
}

void sub_1003533D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003533F0(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlock = v3;
  int v4 = sub_1003534B8((uint64_t)off_1019BB7F8, &aBlock, (void **)(a1 + 8));
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (v4) {
    uint64_t v5 = off_1019BB7F8;
  }
  else {
    uint64_t v5 = 0;
  }
  *(void *)a1 = v5;
}

void sub_10035346C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_100353488(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4)
  {
    a2[4] = 0;
  }
  else
  {
    sub_10035353C(a1, a2, a3);
  }
}

uint64_t sub_1003534A8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t sub_1003534B8(uint64_t a1, void **a2, void **a3)
{
  uint64_t v5 = *a2;
  if (*a2) {
    uint64_t v5 = _Block_copy(v5);
  }
  aBlock = v5;
  uint64_t v6 = sub_100353610(a1, (const void **)&aBlock, a3);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return v6;
}

void sub_100353520(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_10035353C(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvddEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvddEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else if (a3 == 2)
    {
      long long v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_6:
      }
        _Block_release(v7);
    }
    else
    {
      a2[4] = 0;
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      long long v7 = *a1;
      if (*a1) {
        goto LABEL_6;
      }
    }
  }
}

uint64_t sub_100353610(uint64_t a1, const void **a2, void **a3)
{
  if (*a2 && (int v4 = _Block_copy(*a2), (v5 = v4) != 0))
  {
    *a3 = _Block_copy(v4);
    _Block_release(v5);
  }
  else
  {
    *a3 = 0;
  }
  return 1;
}

uint64_t sub_100353670(uint64_t a1, NSObject **a2, NSObject **a3)
{
  sub_100352CB4(v5, a2);
  sub_100352CB4(a3, v5);
  sub_100353AFC((uint64_t)v5);
  return 1;
}

uint64_t sub_1003536B8(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    uint64_t *v2 = 0;
  }
  return result;
}

void sub_100353754(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_rethrow();
}

void sub_100353764(_Unwind_Exception *a1)
{
}

uint64_t *sub_100353778(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

void *sub_1003537CC(void *a1)
{
  *a1 = off_1019BB828;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100353818(void *a1)
{
  *a1 = off_1019BB828;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100353884(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100353934(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10035394C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_10035396C()
{
}

void *sub_1003539D8(void *a1)
{
  *a1 = off_1019BB878;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100353A24(void *a1)
{
  *a1 = off_1019BB878;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100353A90()
{
}

uint64_t sub_100353AFC(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100353B3C()
{
}

__n128 sub_100353B50(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019BB8B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100353BA4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019BB8B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100353BDC(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100353C24(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100353C64()
{
}

void sub_100353C70(uint64_t **a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = **a1;
  (*(void (**)(void))(**(void **)(v1 + 80) + 16))(*(void *)(v1 + 80));
  sub_1003500EC(v1);
  operator delete();
}

void sub_100353CF0()
{
}

void sub_100353D1C(void *a1)
{
  uint64_t v1 = (uint64_t *)*a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100353E80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_100088C88((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100353EA8(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void))(**(void **)(**(void **)a1 + 80) + 64))(*(void *)(**(void **)a1 + 80));
  operator delete();
}

void sub_100353F20()
{
}

uint64_t *sub_100353F4C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v10 = a1;
  uint64_t v11 = v1;
  uint64_t v3 = *v1++;
  uint64_t v2 = v3;
  *(void *)long long buf = v1;
  unsigned int v13 = "kIsUpgrade";
  sub_100048BAC((uint64_t)buf, &object);
  int v5 = xpc::dyn_cast_or_default((xpc *)&object, 0, v4);
  xpc_release(object);
  *(void *)long long buf = v1;
  unsigned int v13 = "kIsRestore";
  sub_100048BAC((uint64_t)buf, &object);
  LODWORD(v1) = xpc::dyn_cast_or_default((xpc *)&object, 0, v6);
  xpc_release(object);
  if ((v5 | v1) == 1)
  {
    uint64_t v7 = *(void *)(v2 + 80);
    if (v7)
    {
      (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
    }
    else
    {
      uint64_t v8 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I WifiCalling location is not ready", buf, 2u);
      }
    }
  }
  sub_1003540B8((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100354070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object)
{
}

uint64_t *sub_1003540B8(uint64_t *result)
{
  uint64_t v1 = *result;
  uint64_t *result = 0;
  if (v1)
  {
    xpc_release(*(xpc_object_t *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

uint64_t sub_100354110(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100354120(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10035413C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

atomic_uint **sub_10035414C(uint64_t *a1)
{
  long long v22 = 0uLL;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(&v25, v2);
  uint64_t v3 = a1[1];
  if (v3)
  {
    if (atomic_load_explicit((atomic_uint *volatile)(v3 + 8), memory_order_acquire) == 1) {
      sub_1001624C4(a1, &v25, 0, 1);
    }
    uint64_t v4 = *a1;
    uint64_t v5 = a1[1];
    if (v5) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v5 + 8), 1u, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v4 = *a1;
  }
  long long v6 = v22;
  *(void *)&long long v22 = v4;
  *((void *)&v22 + 1) = v5;
  v24[0] = v6;
  sub_10000A740((atomic_uint **)v24 + 1);
  sub_10000A6C8(*((pthread_mutex_t **)&v36 + 1));
  sub_10000A5F8(&v25);
  long long v42 = 0u;
  long long v43 = 0u;
  long long v39 = 0u;
  uint64_t v40 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  uint64_t v41 = 10;
  *(void *)&long long v42 = (char *)&v25 + 8;
  DWORD2(v43) = 0;
  uint64_t v44 = 0;
  uint64_t v7 = (uint64_t *)sub_100161FE4((uint64_t *)&v22);
  v21[0] = &v25;
  v21[1] = a1;
  v21[2] = sub_10016428C(v7);
  uint64_t v8 = sub_100161FE4((uint64_t *)&v22);
  uint64_t v9 = sub_100060EA8((uint64_t *)(v8 + 16));
  uint64_t v10 = (uint64_t *)sub_100161FE4((uint64_t *)&v22);
  uint64_t v11 = *(void *)(sub_10016428C(v10) + 8);
  unsigned int v12 = (uint64_t *)sub_100161FE4((uint64_t *)&v22);
  *(void *)&long long v19 = v11;
  *((void *)&v19 + 1) = sub_10016428C(v12);
  *(void *)&long long v20 = &v25;
  *((void *)&v20 + 1) = *((void *)&v19 + 1);
  sub_100354504((uint64_t *)&v19);
  unsigned int v13 = (uint64_t *)sub_100161FE4((uint64_t *)&v22);
  uint64_t v14 = sub_10016428C(v13);
  uint64_t v15 = (uint64_t *)sub_100161FE4((uint64_t *)&v22);
  *(void *)&long long v17 = v14;
  *((void *)&v17 + 1) = sub_10016428C(v15);
  *(void *)&long long v18 = &v25;
  *((void *)&v18 + 1) = *((void *)&v17 + 1);
  sub_100354504((uint64_t *)&v17);
  v24[0] = v19;
  v24[1] = v20;
  v23[0] = v17;
  v23[1] = v18;
  sub_1003543BC(v9, (uint64_t *)v24, v23);
  sub_1003548C4((uint64_t)v21);
  sub_100354AA8((uint64_t)&v25);
  return sub_10000A740((atomic_uint **)&v22 + 1);
}

void sub_100354368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,atomic_uint *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1003543BC(uint64_t a1, uint64_t *a2, void *a3)
{
  while (*a2 != *a3)
  {
    sub_10035443C(a2);
    *a2 = *(void *)(*a2 + 8);
    sub_100354504(a2);
    uint64_t v5 = (unsigned char *)a2[2];
    if (*v5) {
      *uint64_t v5 = 0;
    }
  }
}

unsigned char *sub_10035443C(void *a1)
{
  uint64_t v2 = (unsigned char *)a1[2];
  if (!*v2)
  {
    uint64_t v3 = sub_100162164((uint64_t *)(*a1 + 16));
    uint64_t v4 = sub_1001633B4((uint64_t *)(v3 + 32));
    sub_100164B7C((void *)(v4 + 24));
    if (!*v2) {
      unsigned char *v2 = 1;
    }
  }
  uint64_t v5 = (unsigned char *)a1[2];
  if (!*v5) {
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
  return v5 + 1;
}

void sub_100354504(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_15;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      uint64_t v3 = (uint64_t *)(*a1 + 16);
      long long v15 = 0u;
      long long v16 = 0u;
      uint64_t v4 = sub_100354760(v3);
      sub_10000A4EC(&v15, v4);
      uint64_t v5 = (atomic_uint **)sub_100162164((uint64_t *)(*a1 + 16));
      sub_1003547A4(v5, &v15, (void *)(a1[2] + 8));
      uint64_t v6 = sub_100162164((uint64_t *)(*a1 + 16));
      uint64_t v7 = a1[2];
      if (*(unsigned char *)(v6 + 24)) {
        ++*(_DWORD *)(v7 + 276);
      }
      else {
        ++*(_DWORD *)(v7 + 280);
      }
      uint64_t v8 = sub_100162164((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v8 + 24)
        || (uint64_t v9 = *(void *)(v8 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v9 + 8), memory_order_acquire))
      {
        int v10 = 1;
      }
      else
      {
        sub_1001AB328(a1, &v15, *a1);
        int v10 = 0;
      }
      (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
      sub_10000A5F8(&v15);
      uint64_t v1 = *a1;
      uint64_t v11 = a1[1];
      if (!v10) {
        break;
      }
      uint64_t v12 = *(void *)(v1 + 8);
      *a1 = v12;
      if (v12 == v11)
      {
        uint64_t v1 = v11;
        goto LABEL_15;
      }
    }
    if (v1 == v11)
    {
LABEL_15:
      uint64_t v13 = a1[3];
      if (v13 != v1)
      {
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v15 = 0u;
        long long v16 = 0u;
        uint64_t v14 = sub_100354760((uint64_t *)(v13 + 16));
        sub_10000A4EC(&v15, v14);
        sub_1001AB328(a1, &v15, a1[1]);
        (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
        sub_10000A5F8(&v15);
      }
    }
  }
}

void sub_100354724(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100354760(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_1003547A4(atomic_uint **result, void *a2, void *a3)
{
  uint64_t v3 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v6 = result;
    for (uint64_t i = *(atomic_uint **)sub_1001633B4((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_1001633B4(v3);
      if (i == result[1]) {
        break;
      }
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v6 + 24))
        {
          *((unsigned char *)v6 + 24) = 0;
          sub_100060D70(v6, a2);
        }
        return sub_1000624B4((uint64_t)v8);
      }
      sub_100062188(a3, (uint64_t)v8);
      sub_1000624B4((uint64_t)v8);
    }
  }
  return result;
}

void sub_1003548A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1003548C4(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)a1 + 280) > *(_DWORD *)(*(void *)a1 + 276)) {
    sub_100354908(*(uint64_t **)(a1 + 8), *(void *)(a1 + 16));
  }
  return a1;
}

void sub_100354908(uint64_t *a1, uint64_t a2)
{
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  uint64_t v4 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v9, v4);
  uint64_t v5 = (uint64_t *)sub_100161FE4(a1);
  if (sub_10016428C(v5) == a2)
  {
    uint64_t v6 = a1[1];
    if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
      operator new();
    }
    uint64_t v7 = (uint64_t *)sub_100161FE4(a1);
    uint64_t v8 = *(uint64_t **)(sub_10016428C(v7) + 8);
    sub_100162388(a1, v9, 0, &v8, 0);
  }
  sub_10000A6C8(*((pthread_mutex_t **)&v10 + 1));
  sub_10000A5F8(v9);
}

void sub_100354A54()
{
}

uint64_t sub_100354AA8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 288);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 288), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_100354B7C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void *sub_100354B9C(void *a1)
{
  *a1 = off_1019BB970;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100354BE8(void *a1)
{
  *a1 = off_1019BB970;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_100354C54(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019BB970;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100354CB8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019BB970;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100354CF8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100354D08(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_100354D48(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  rest::read_rest_value();
  memset(&v9, 0, sizeof(v9));
  v12[1] = 0;
  v13[0] = 0;
  memset(v10, 0, sizeof(v10));
  v13[1] = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  long long v16 = 0;
  v12[0] = 0;
  memset(&v11, 0, sizeof(v11));
  long long v19 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v5 = &v9;
    }
    else {
      long long v5 = (std::string *)v9.__r_.__value_.__r.__words[0];
    }
    if ((v10[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v6 = v10;
    }
    else {
      uint64_t v6 = (std::string *)v10[0].__r_.__value_.__r.__words[0];
    }
    if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v7 = &v11;
    }
    else {
      uint64_t v7 = (std::string *)v11.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v5;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v6;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
    long long v26 = v6;
    __int16 v27 = 2080;
    long long v28 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I CTLocationBasedCountryDetermination: Receiving civic info (%s, %s, %s, %s)", (uint8_t *)&buf, 0x2Au);
  }
  std::string buf = v9;
  memset(&v9, 0, sizeof(v9));
  std::string v24 = v10[0];
  memset(v10, 0, sizeof(v10));
  std::string v23 = v10[1];
  std::string __p = v11;
  memset(&v11, 0, sizeof(v11));
  sub_10034E770(v3, &buf, &v24, &v23, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v10[1].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10[1].__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v10[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10[0].__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v21) < 0) {
    operator delete(v19);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(v16);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(v13[1]);
  }
  if (SHIBYTE(v13[0]) < 0) {
    operator delete(v12[0]);
  }
  xpc_release(object);
}

void sub_100355038(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_100355130(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100355170()
{
}

uint64_t *sub_10035517C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  *(void *)&long long v21 = "CTLocationBasedCountryDetermination";
  sub_1002BFAE4((char **)&v21, (dispatch_object_t *)(v2 + 24), &v11);
  Registry::createRestModuleOneTimeUseMobileHelperConnection(&v9, *(Registry **)(v2 + 48));
  ctu::RestModule::connect();
  if (v10) {
    sub_10004D2C8(v10);
  }
  rest::LocationCoordinate::LocationCoordinate((rest::LocationCoordinate *)v8, *(double *)(v1 + 8), *(double *)(v1 + 16));
  *(void *)&long long v17 = v2;
  *((void *)&v17 + 1) = v11;
  uint64_t v18 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10012CA20((uint64_t)v19, v1 + 24);
  long long v20 = *(_OWORD *)(v1 + 8);
  xpc_object_t v16 = 0;
  rest::write_rest_value((rest *)v8, v3);
  sub_100058DB0(&__p, "/helper/requests/get_iso_for_location");
  xpc_object_t object = v16;
  xpc_object_t v16 = xpc_null_create();
  long long v21 = v17;
  long long v22 = v18;
  *((void *)&v17 + 1) = 0;
  uint64_t v18 = 0;
  sub_10012CB18((uint64_t)v23, (uint64_t)v19);
  long long v24 = v20;
  long long v26 = 0;
  uint64_t v4 = (char *)operator new(0x50uLL);
  *(void *)uint64_t v4 = off_1019BB9F0;
  *(_OWORD *)(v4 + 8) = v21;
  *((void *)v4 + 3) = v22;
  *((void *)&v21 + 1) = 0;
  long long v22 = 0;
  sub_10012CB18((uint64_t)(v4 + 32), (uint64_t)v23);
  *((_OWORD *)v4 + 4) = v24;
  long long v26 = v4;
  ctu::RestModule::sendRequest();
  sub_10003F600(v25);
  sub_10012C330(v23);
  if (v22) {
    sub_10004D2C8(v22);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  if (v15 < 0) {
    operator delete(__p);
  }
  xpc_release(v16);
  sub_10012C330(v19);
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_1003554B0(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_1003553D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,xpc_object_t object,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,xpc_object_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1003554B0(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_10012C330((void *)(v1 + 24));
    operator delete();
  }
  return result;
}

void *sub_100355500(void *a1)
{
  *a1 = off_1019BB9F0;
  sub_10012C330(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100355550(void *a1)
{
  *a1 = off_1019BB9F0;
  sub_10012C330(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_1003555C0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x50uLL);
  void *v2 = off_1019BB9F0;
  sub_1003558A8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100355614(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100355628(uint64_t a1, void *a2)
{
  *a2 = off_1019BB9F0;
  return sub_1003558A8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100355654(uint64_t a1)
{
}

void sub_10035565C(void *a1)
{
  sub_10035591C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100355698(void *a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  memset(__p, 0, 24);
  xpc::dyn_cast_or_default();
  uint64_t v9 = v12;
  *(void *)long long v10 = *(void *)v13;
  *(void *)&v10[7] = *(void *)&v13[7];
  char v11 = v14;
  uint64_t v3 = *(NSObject **)(a1[1] + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = &v9;
    if (v14 < 0) {
      uint64_t v4 = (void **)v12;
    }
    long long v5 = (void *)a1[8];
    uint64_t v6 = (void *)a1[9];
    LODWORD(__p[0]) = 136315651;
    *(void **)((char *)__p + 4) = v4;
    WORD2(__p[1]) = 2049;
    *(void **)((char *)&__p[1] + 6) = v5;
    HIWORD(__p[2]) = 2049;
    __p[3] = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I CTLocationBasedCountryDetermination: Receiving ISO '%s' for %{private}f.%{private}f", (uint8_t *)__p, 0x20u);
  }
  uint64_t v7 = a1[7];
  if (!v7) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v7 + 48))(v7, &v9);
  if (v11 < 0) {
    operator delete(v9);
  }
  xpc_release(object);
}

void sub_100355808(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10035585C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10035589C()
{
}

uint64_t sub_1003558A8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10012CA20(a1 + 24, a2 + 24);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  return a1;
}

void sub_100355904(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10035591C(uint64_t a1)
{
  sub_10012C330((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

uint64_t sub_100355968(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_1003559E8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v22 = a1;
  uint64_t v23 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v29 = 0;
  long long v30 = 0;
  *(void *)&long long v39 = "CTLocationBasedCountryDetermination";
  sub_1002BFAE4((char **)&v39, (dispatch_object_t *)(v2 + 24), &v29);
  Registry::createRestModuleOneTimeUseMobileHelperConnection(&v27, *(Registry **)(v2 + 48));
  ctu::RestModule::connect();
  if (v28) {
    sub_10004D2C8(v28);
  }
  long long v26 = 0;
  long long v24 = 0u;
  *(_OWORD *)long long v25 = 0u;
  double v3 = nan("");
  rest::LocationCoordinate::LocationCoordinate((rest::LocationCoordinate *)&v24, v3, v3);
  v25[0] = 0;
  v25[1] = 0;
  long long v26 = 0;
  rest::LocationCoordinate::LocationCoordinate((rest::LocationCoordinate *)&v39, *(double *)(v1 + 8), *(double *)(v1 + 16));
  uint64_t v20 = v2;
  uint64_t v21 = v1;
  long long v24 = v39;
  uint64_t v4 = *(double ***)(v1 + 24);
  long long v5 = *v4;
  uint64_t v6 = v4[1];
  if (*v4 != v6)
  {
    do
    {
      rest::RegionDescription::RegionDescription((rest::RegionDescription *)&v39, *v5, v5[1], v5[2]);
      uint64_t v7 = v25[1];
      if (v25[1] >= v26)
      {
        long long v10 = v25[0];
        unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (((char *)v25[1] - (char *)v25[0]) >> 3);
        unint64_t v12 = v11 + 1;
        if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_10006A748();
        }
        if (0x5555555555555556 * ((v26 - (char *)v25[0]) >> 3) > v12) {
          unint64_t v12 = 0x5555555555555556 * ((v26 - (char *)v25[0]) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v26 - (char *)v25[0]) >> 3) >= 0x555555555555555) {
          unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v13 = v12;
        }
        if (v13)
        {
          if (v13 > 0xAAAAAAAAAAAAAAALL) {
            sub_10006A7CC();
          }
          char v14 = (char *)operator new(24 * v13);
        }
        else
        {
          char v14 = 0;
        }
        char v15 = &v14[24 * v11];
        *(_OWORD *)char v15 = v39;
        *((void *)v15 + 2) = v40;
        xpc_object_t v16 = v15;
        if (v7 != v10)
        {
          do
          {
            long long v17 = *(_OWORD *)((char *)v7 - 24);
            *((void *)v16 - 1) = *((void *)v7 - 1);
            *(_OWORD *)(v16 - 24) = v17;
            v16 -= 24;
            uint64_t v7 = (_OWORD *)((char *)v7 - 24);
          }
          while (v7 != v10);
          uint64_t v7 = v25[0];
        }
        uint64_t v9 = v15 + 24;
        v25[0] = v16;
        v25[1] = v15 + 24;
        long long v26 = &v14[24 * v13];
        if (v7) {
          operator delete(v7);
        }
      }
      else
      {
        long long v8 = v39;
        *((void *)v25[1] + 2) = v40;
        _OWORD *v7 = v8;
        uint64_t v9 = (char *)v7 + 24;
      }
      v25[1] = v9;
      v5 += 3;
    }
    while (v5 != v6);
  }
  *(void *)&long long v35 = v20;
  *((void *)&v35 + 1) = v29;
  long long v36 = v30;
  if (v30) {
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100356358((uint64_t)v37, v21 + 40);
  long long v38 = *(_OWORD *)(v21 + 8);
  xpc_object_t v34 = 0;
  rest::write_rest_value();
  sub_100058DB0(&__p, "/helper/requests/choose_region_for_location");
  xpc_object_t object = v34;
  xpc_object_t v34 = xpc_null_create();
  long long v39 = v35;
  uint64_t v40 = v36;
  *((void *)&v35 + 1) = 0;
  long long v36 = 0;
  sub_100355968((uint64_t)v41, (uint64_t)v37);
  long long v42 = v38;
  uint64_t v44 = 0;
  uint64_t v18 = (char *)operator new(0x50uLL);
  *(void *)uint64_t v18 = off_1019BBA70;
  *(_OWORD *)(v18 + 8) = v39;
  *((void *)v18 + 3) = v40;
  *((void *)&v39 + 1) = 0;
  uint64_t v40 = 0;
  sub_100355968((uint64_t)(v18 + 32), (uint64_t)v41);
  *((_OWORD *)v18 + 4) = v42;
  uint64_t v44 = v18;
  ctu::RestModule::sendRequest();
  sub_10003F600(v43);
  sub_1000F8E94(v41);
  if (v40) {
    sub_10004D2C8(v40);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  if (v33 < 0) {
    operator delete(__p);
  }
  xpc_release(v34);
  sub_1000F8E94(v37);
  if (v36) {
    sub_10004D2C8(v36);
  }
  if (v25[0])
  {
    v25[1] = v25[0];
    operator delete(v25[0]);
  }
  if (v30) {
    sub_10004D2C8(v30);
  }
  sub_100355EDC(&v23);
  return sub_100046B58((uint64_t *)&v22);
}

void sub_100355DD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,xpc_object_t object,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,xpc_object_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100355EDC(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_1000F8E94((void *)(v1 + 40));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 32);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void *sub_100355F38(void *a1)
{
  *a1 = off_1019BBA70;
  sub_1000F8E94(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100355F88(void *a1)
{
  *a1 = off_1019BBA70;
  sub_1000F8E94(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100355FF8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x50uLL);
  void *v2 = off_1019BBA70;
  sub_100356244((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10035604C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100356060(uint64_t a1, void *a2)
{
  *a2 = off_1019BBA70;
  return sub_100356244((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10035608C(uint64_t a1)
{
}

void sub_100356094(void *a1)
{
  sub_1003562B8((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1003560D0(void *a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  long long v5 = *(NSObject **)(a1[1] + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = a1[8];
    uint64_t v7 = a1[9];
    *(_DWORD *)std::string buf = 67109633;
    int v10 = v4;
    __int16 v11 = 2049;
    uint64_t v12 = v6;
    __int16 v13 = 2049;
    uint64_t v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I CTLocationBasedCountryDetermination: Choose regions '%d' for %{private}f.%{private}f", buf, 0x1Cu);
  }
  sub_100356304((uint64_t)(a1 + 4), v4);
  xpc_release(object);
}

void sub_1003561C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1003561F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100356238()
{
}

uint64_t sub_100356244(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100356358(a1 + 24, a2 + 24);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  return a1;
}

void sub_1003562A0(_Unwind_Exception *exception_object)
{
  int v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003562B8(uint64_t a1)
{
  sub_1000F8E94((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

uint64_t sub_100356304(uint64_t a1, int a2)
{
  int v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t sub_100356358(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

char **sub_1003563F0(char **result, std::locale *this)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  if (*result != v3)
  {
    do
    {
      uint64_t v5 = *v2;
      uint64_t v6 = std::locale::use_facet(this, &std::ctype<char>::id);
      uint64_t result = (char **)((uint64_t (*)(const std::locale::facet *, uint64_t))v6->__vftable[1].__on_zero_shared)(v6, v5);
      *v2++ = (char)result;
    }
    while (v2 != v3);
  }
  return result;
}

uint64_t sub_100356478(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
}

__n128 sub_10035648C(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

void sub_1003564F0(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(void *)(v1 + 80);
  uint64_t v3 = *(NSObject **)(v1 + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I disableVoWiFiLocationStatusOnFirstLaunch", buf, 2u);
      uint64_t v2 = *(void *)(v1 + 80);
    }
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  else if (v4)
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#E disableVoWiFiLocationStatusOnFirstLaunch: no fWifiLocation. Skipping...", v5, 2u);
  }
  operator delete();
}

void sub_1003565E8()
{
}

uint64_t sub_100356614(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v13, kCtLoggingSystemName, "wea");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v11, (const OsLogContext *)&v13);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 56), (const ctu::OsLogLogger *)&v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v13);
  long long v8 = operator new(0x18uLL);
  v14[1] = v8 + 3;
  v14[2] = v8 + 3;
  void *v8 = a2;
  v8[1] = a3;
  v8[2] = a4;
  v14[0] = v8;
  sub_10010549C((void *)a1, (uint64_t)v14);
  operator delete(v8);
  *(void *)a1 = off_1019BBAF0;
  *(double *)(a1 + 64) = (double)(unint64_t)(180 * a2) * 0.000000238418579 + -90.0;
  *(double *)(a1 + 72) = (double)(unint64_t)(360 * a3) * 0.000000238418579 + -180.0;
  *(double *)(a1 + 80) = (double)a4 * 0.015625;
  long long v11 = *(_OWORD *)(a1 + 64);
  double v12 = (double)a4 * 0.015625;
  sub_1012305BC(&v13);
  uint64_t v9 = (void **)(a1 + 32);
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*v9);
  }
  *(_OWORD *)uint64_t v9 = *(_OWORD *)&v13.__r_.__value_.__l.__data_;
  *(void *)(a1 + 48) = *((void *)&v13.__r_.__value_.__l + 2);
  return a1;
}

void sub_100356788(_Unwind_Exception *a1)
{
  sub_100105504(v1);
  ctu::OsLogLogger::~OsLogLogger(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1003567CC(uint64_t a1)
{
  uint64_t v2 = sub_100105504(a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v2 + 56));
  return a1;
}

void sub_1003567FC(uint64_t a1)
{
  uint64_t v1 = sub_100105504(a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 56));

  operator delete();
}

uint64_t sub_10035684C@<X0>(uint64_t a1@<X0>, char **a2@<X8>)
{
  uint64_t v27 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v16 = 0u;
  memset(v14, 0, sizeof(v14));
  long long v13 = 0u;
  sub_10004BD84((uint64_t)&v13);
  (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)a1 + 16))(&v30, a1);
  if ((v31 & 0x80u) == 0) {
    BOOL v4 = &v30;
  }
  else {
    BOOL v4 = (long long *)v30;
  }
  if ((v31 & 0x80u) == 0) {
    uint64_t v5 = v31;
  }
  else {
    uint64_t v5 = *((void *)&v30 + 1);
  }
  uint64_t v6 = sub_10004B96C(v14, (uint64_t)v4, v5);
  *(void *)((char *)v6 + *(void *)(*v6 - 24) + 16) = 16;
  sub_10004B96C(v6, (uint64_t)" [", 2);
  uint64_t v7 = (void *)std::ostream::operator<<();
  sub_10004B96C(v7, (uint64_t)", ", 2);
  long long v8 = (void *)std::ostream::operator<<();
  sub_10004B96C(v8, (uint64_t)", ", 2);
  uint64_t v9 = (void *)std::ostream::operator<<();
  sub_10004B96C(v9, (uint64_t)"]", 1);
  if ((char)v31 < 0) {
    operator delete((void *)v30);
  }
  sub_10004BC98((uint64_t)v14 + 8, &v30);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  long long v28 = a2;
  uint64_t v29 = 0;
  int v10 = (char *)operator new(0x18uLL);
  *a2 = v10;
  a2[1] = v10;
  a2[2] = v10 + 24;
  a2[1] = sub_1000D8A18((uint64_t)(a2 + 2), &v30, &v32, v10);
  if ((char)v31 < 0) {
    operator delete((void *)v30);
  }
  *(void *)((char *)&v14[-1]
  *(void *)&v14[0] = v11;
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100356B38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100047F64((void ***)(v11 - 96));
  if (*(char *)(v11 - 57) < 0) {
    operator delete(*(void **)(v11 - 80));
  }
  sub_10008248C((uint64_t)&a9);
  _Unwind_Resume(a1);
}

char *sub_100356B90@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[55] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 4), *((void *)result + 5));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 2);
  *(void *)(a2 + 16) = *((void *)result + 6);
  return result;
}

uint64_t sub_100356BC4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

uint64_t *sub_100356BF4(uint64_t *result)
{
  unint64_t v1 = *((unsigned __int8 *)result + 23);
  if ((v1 & 0x80u) != 0) {
    unint64_t v1 = result[1];
  }
  if (v1)
  {
    uint64_t v2 = 0;
    do
    {
      if (*((char *)result + 23) >= 0) {
        uint64_t v3 = result;
      }
      else {
        uint64_t v3 = (uint64_t *)*result;
      }
      int v4 = *((unsigned __int8 *)v3 + v2);
      if ((v4 - 33) >= 0x5E) {
        LOBYTE(v4) = 46;
      }
      *((unsigned char *)v3 + v2++) = v4;
    }
    while (v1 > v2);
  }
  return result;
}

void sub_100356C48(id a1)
{
}

void sub_100356D38(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  std::mutex::unlock(&stru_101B09F68);
  operator delete();
}

void sub_100356D8C(unsigned char *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  std::mutex::lock(&stru_101B09F68);
  bzero(v41, 0x230uLL);
  sub_10035726C((std::string *)&__p);
  *(void *)&v41[(void)*(v40 - 3) - 8] = v11;
  double v12 = (std::ios_base *)&v41[(void)*(v40 - 3) - 8];
  std::ios_base::init(v12, v41);
  v12[1].__vftable = 0;
  v12[1].__fmtflags_ = -1;
  std::filebuf::basic_filebuf();
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)&v41[(void)*(v40 - 3) - 8], *(_DWORD *)&v41[(void)*(v40 - 3) + 24] | 4);
  }
  if (SHIBYTE(__p.tm_year) < 0) {
    operator delete(*(void **)&__p.tm_sec);
  }
  if (*a1)
  {
    memset(&__p, 0, sizeof(__p));
    time_t v36 = time(0);
    localtime_r(&v36, &__p);
    sub_1003572FC((uint64_t)a1, &__p);
    *(void *)long long v38 = 0;
    uint64_t v39 = 0;
    int v13 = SLODWORD(__p.tm_gmtoff) / 3600;
    if (SLODWORD(__p.tm_gmtoff) / 3600 < 0) {
      int v13 = SLODWORD(__p.tm_gmtoff) / -3600;
    }
    int v14 = 100 * v13;
    if (__p.tm_isdst <= 0) {
      char v15 = "ST";
    }
    else {
      char v15 = "DST";
    }
    uint64_t v16 = 43;
    if (__p.tm_gmtoff < -3599) {
      uint64_t v16 = 45;
    }
    sprintf(v38, "%c%04d %s", v16, v14, v15);
    char tm_hour = __p.tm_hour;
    sGetLogGroupName();
    unsigned int v23 = sub_100BAC4D0(byte_101B0CB10, 0xFEuLL, "%d:%2.2d:%2.2d %s [%s] ", v18, v19, v20, v21, v22, tm_hour);
    unsigned int v29 = 253;
    if (v23 <= 0xFD)
    {
      unsigned int v31 = v23;
      size_t v32 = 254 - v23;
      unsigned int v33 = vsnprintf(&byte_101B0CB10[v23], v32, a3, &a9);
      unsigned int v34 = 253 - v31;
      BOOL v30 = v33 >= v32;
      if (v33 < v32) {
        unsigned int v34 = v33;
      }
      unsigned int v29 = v34 + v31;
    }
    else
    {
      BOOL v30 = 1;
    }
    sub_100BAC4D0(&byte_101B0CB10[v29], 2uLL, "\n", v24, v25, v26, v27, v28, v35);
    std::ostream::write();
    if (v30) {
      std::ostream::write();
    }
    if (!std::filebuf::close()) {
      std::ios_base::clear((std::ios_base *)&v41[(void)*(v40 - 3) - 8], *(_DWORD *)&v41[(void)*(v40 - 3) + 24] | 4);
    }
  }
  std::filebuf::~filebuf();
  std::ostream::~ostream();
  std::ios::~ios();
  std::mutex::unlock(&stru_101B09F68);
}

void sub_1003571FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  std::mutex::unlock(&stru_101B09F68);
  _Unwind_Resume(a1);
}

void sub_10035726C(std::string *a1)
{
  WirelessUserDirectory = (char *)_GetWirelessUserDirectory();
  sub_100058DB0(&v4, WirelessUserDirectory);
  uint64_t v3 = std::string::append(&v4, "/Library/Logs/log-bb-live-stats.txt", 0x23uLL);
  *a1 = *v3;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v4.__r_.__value_.__l.__data_);
  }
}

void sub_1003572E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003572FC(uint64_t a1, _DWORD *a2)
{
  if (*(unsigned char *)(a1 + 1)) {
    goto LABEL_42;
  }
  bzero(buf, 0x248uLL);
  sub_10035726C(&__p);
  sub_100358650((uint64_t)buf);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (*(_DWORD *)((char *)v48 + *(void *)(*(void *)buf - 24)))
  {
    BOOL v4 = 0;
    goto LABEL_41;
  }
  memset(&__p, 0, sizeof(__p));
  std::ios_base::getloc((const std::ios_base *)&buf[*(void *)(*(void *)buf - 24)]);
  uint64_t v5 = std::locale::use_facet((const std::locale *)&v45, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale((std::locale *)&v45);
  sub_10013EA34((uint64_t)buf);
  std::ios_base::getloc((const std::ios_base *)&buf[*(void *)(*(void *)buf - 24)]);
  uint64_t v6 = std::locale::use_facet((const std::locale *)&v45, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10);
  std::locale::~locale((std::locale *)&v45);
  sub_10013EA34((uint64_t)buf);
  std::ios_base::getloc((const std::ios_base *)&buf[*(void *)(*(void *)buf - 24)]);
  uint64_t v7 = std::locale::use_facet((const std::locale *)&v45, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 10);
  std::locale::~locale((std::locale *)&v45);
  sub_10013EA34((uint64_t)buf);
  if (!std::filebuf::close()) {
    std::ios_base::clear((std::ios_base *)&buf[*(void *)(*(void *)buf - 24)], *(_DWORD *)((char *)v48 + *(void *)(*(void *)buf - 24)) | 4);
  }
  std::string::basic_string(&v45, &__p, 0, 5uLL, (std::allocator<char> *)&v40);
  std::string::size_type size = HIBYTE(v45.__r_.__value_.__r.__words[2]);
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v45.__r_.__value_.__l.__size_;
  }
  if (size == 5)
  {
    uint64_t v9 = (std::string *)v45.__r_.__value_.__r.__words[0];
    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v9 = &v45;
    }
    int data = (int)v9->__r_.__value_.__l.__data_;
    int v11 = v9->__r_.__value_.__s.__data_[4];
    BOOL v4 = data == 1702125892 && v11 == 61;
    if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  BOOL v4 = 0;
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
LABEL_22:
  }
    operator delete(v45.__r_.__value_.__l.__data_);
LABEL_23:
  if (v4)
  {
    memset(&v45, 0, sizeof(v45));
    std::string::basic_string(&v45, &__p, 5uLL, 4uLL, (std::allocator<char> *)&v40);
    memset(&v40, 0, sizeof(v40));
    std::string::basic_string(&v40, &__p, 0xAuLL, 2uLL, (std::allocator<char> *)&v39);
    memset(&v39, 0, sizeof(v39));
    std::string::basic_string(&v39, &__p, 0xDuLL, 2uLL, (std::allocator<char> *)&v41);
    int v13 = SHIBYTE(v39.__r_.__value_.__r.__words[2]);
    int v14 = (void *)v39.__r_.__value_.__r.__words[0];
    if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      char v15 = &v39;
    }
    else {
      char v15 = (std::string *)v39.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)(a1 + 12) = atoi((const char *)v15);
    char v16 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
    if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v17 = &v40;
    }
    else {
      long long v17 = (std::string *)v40.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)(a1 + 8) = atoi((const char *)v17);
    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v18 = &v45;
    }
    else {
      uint64_t v18 = (std::string *)v45.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)(a1 + 4) = atoi((const char *)v18);
    if (v13 < 0)
    {
      operator delete(v14);
      char v16 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
    }
    if (v16 < 0) {
      operator delete(v40.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v45.__r_.__value_.__l.__data_);
    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_41:
  *(void *)std::string buf = off_1019BBD08;
  uint64_t v49 = off_1019BBD58;
  *(void *)&long long v47 = off_1019BBD30;
  std::filebuf::~filebuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  *(unsigned char *)(a1 + 1) = v4;
  if (!v4)
  {
    sub_10035726C((std::string *)buf);
    if (SBYTE7(v47) < 0)
    {
      long long v38 = *(void **)buf;
      unlink(*(const char **)buf);
      operator delete(v38);
    }
    else
    {
      unlink((const char *)buf);
    }
    sub_100357C9C(a1);
    return;
  }
LABEL_42:
  CSILogger::CSILogger();
  uint64_t v19 = *(NSObject **)&v48[0];
  CSILogger::~CSILogger((CSILogger *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    int v20 = *(_DWORD *)(a1 + 4);
    int v21 = *(_DWORD *)(a1 + 8);
    int v22 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)std::string buf = 67109632;
    *(_DWORD *)&uint8_t buf[4] = v20;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v21;
    *(_WORD *)&buf[14] = 1024;
    LODWORD(v47) = v22;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I current stats file open for %d-%2.2d-%2.2d", buf, 0x14u);
  }
  if (a2[3] != *(_DWORD *)(a1 + 12) || a2[4] + 1 != *(_DWORD *)(a1 + 8) || a2[5] + 1900 != *(_DWORD *)(a1 + 4))
  {
    memset(v48, 0, 224);
    *(_OWORD *)std::string buf = 0u;
    long long v47 = 0u;
    WirelessUserDirectory = (const char *)_GetWirelessUserDirectory();
    snprintf((char *)buf, 0x100uLL, "%s/Library/Logs/Baseband/log-bb-%d-%2.2d-%2.2d-stats.txt", WirelessUserDirectory, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
    sub_10035726C(&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      BOOL v30 = (void *)__p.__r_.__value_.__r.__words[0];
      rename((const std::__fs::filesystem::path *)__p.__r_.__value_.__l.__data_, (const std::__fs::filesystem::path *)buf, v24);
      int v32 = v31;
      operator delete(v30);
      if (v32) {
        goto LABEL_49;
      }
    }
    else
    {
      rename((const std::__fs::filesystem::path *)&__p, (const std::__fs::filesystem::path *)buf, v24);
      if (v25)
      {
LABEL_49:
        CSILogger::CSILogger();
        uint64_t v26 = v44;
        CSILogger::~CSILogger((CSILogger *)&__p);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v27 = &v45;
          sub_10035726C(&v45);
          if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            uint64_t v27 = (std::string *)v45.__r_.__value_.__r.__words[0];
          }
          uint64_t v28 = __error();
          unsigned int v29 = strerror(*v28);
          LODWORD(__p.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v27;
          WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)buf;
          HIWORD(__p.__r_.__value_.__r.__words[2]) = 2080;
          long long v43 = v29;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I failed to rename %s to %s (%s)", (uint8_t *)&__p, 0x20u);
          if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v45.__r_.__value_.__l.__data_);
          }
        }
        sub_10035726C(&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          unlink((const char *)&__p);
LABEL_67:
          CSILogger::CSILogger();
          long long v37 = v44;
          CSILogger::~CSILogger((CSILogger *)&__p);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p.__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I just rotated the stats file; let's make a new one",
              (uint8_t *)&__p,
              2u);
          }
          *(unsigned char *)(a1 + 1) = 0;
          sub_100357C9C(a1);
          return;
        }
        std::string::size_type v36 = __p.__r_.__value_.__r.__words[0];
        unlink(__p.__r_.__value_.__l.__data_);
        char v35 = (void *)v36;
LABEL_66:
        operator delete(v35);
        goto LABEL_67;
      }
    }
    CSILogger::CSILogger();
    unsigned int v33 = v44;
    CSILogger::~CSILogger((CSILogger *)&__p);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_67;
    }
    sub_10035726C(&__p);
    unsigned int v34 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    LODWORD(v45.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)v45.__r_.__value_.__r.__words + 4) = (std::string::size_type)v34;
    WORD2(v45.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v45.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)buf;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I renamed %s -> %s", (uint8_t *)&v45, 0x16u);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_67;
    }
    char v35 = (void *)__p.__r_.__value_.__r.__words[0];
    goto LABEL_66;
  }
}

void sub_100357B28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,std::locale a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a40 < 0) {
    operator delete(a35.__locale_);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  sub_1003587C8(&a42);
  _Unwind_Resume(a1);
}

void *sub_100357BD0(void *a1)
{
  std::filebuf::~filebuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return a1;
}

uint64_t sub_100357C9C(uint64_t a1)
{
  bzero(v81, 0x248uLL);
  sub_10035726C((std::string *)__p);
  sub_100358650((uint64_t)v81);
  if (SBYTE7(v74) < 0) {
    operator delete(__p[0]);
  }
  CSILogger::CSILogger();
  uint64_t v2 = v75;
  CSILogger::~CSILogger((CSILogger *)__p);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_DWORD *)((char *)&v82[2] + *(void *)(v81[0] - 24))) {
      uint64_t v3 = "bad";
    }
    else {
      uint64_t v3 = "good";
    }
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = (void *)v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I created stats file, and it's %s", (uint8_t *)__p, 0xCu);
  }
  if (!*(_DWORD *)((char *)&v82[2] + *(void *)(v81[0] - 24)))
  {
    unint64_t v64 = 0;
    uint64_t v65 = 0;
    uint64_t v66 = 0;
    sub_100068A94(__p);
    (*(void (**)(void **__return_ptr))(*(void *)__p[0] + 104))(&v64);
    if (__p[1]) {
      sub_10004D2C8((std::__shared_weak_count *)__p[1]);
    }
    uint64_t v61 = 0;
    uint64_t v62 = 0;
    uint64_t v63 = 0;
    sub_100068A94(__p);
    (*(void (**)(void **__return_ptr))(*(void *)__p[0] + 72))(&v61);
    if (__p[1]) {
      sub_10004D2C8((std::__shared_weak_count *)__p[1]);
    }
    long long v79 = 0u;
    long long v80 = 0u;
    long long v77 = 0u;
    long long v78 = 0u;
    long long v75 = 0u;
    long long v76 = 0u;
    *(_OWORD *)std::string __p = 0u;
    long long v74 = 0u;
    CFIndex usedBufLen = 0;
    CFUUIDRef v4 = CFUUIDCreate(kCFAllocatorDefault);
    if (v4)
    {
      CFStringRef v5 = CFUUIDCreateString(kCFAllocatorDefault, v4);
      CFStringRef v6 = v5;
      if (v5)
      {
        v83.length = CFStringGetLength(v5);
        v83.location = 0;
        CFStringGetBytes(v6, v83, 0xBFFu, 0, 0, (UInt8 *)__p, 127, &usedBufLen);
        CFRelease(v6);
      }
      CFRelease(v4);
    }
    *((unsigned char *)__p + usedBufLen) = 0;
    memset(&v59, 0, sizeof(v59));
    time_t v58 = time(0);
    localtime_r(&v58, &v59);
    *(_OWORD *)__str = 0u;
    long long v72 = 0u;
    int tm_mday = v59.tm_mday;
    int v8 = v59.tm_mon + 1;
    int v9 = v59.tm_year + 1900;
    *(_DWORD *)(a1 + 8) = v59.tm_mon + 1;
    *(_DWORD *)(a1 + 12) = tm_mday;
    *(_DWORD *)(a1 + 4) = v9;
    *(unsigned char *)(a1 + 1) = 1;
    snprintf(__str, 0x20uLL, "%d-%2.2d-%2.2d", v9, v8, tm_mday);
    sub_10004B96C(v82, (uint64_t)"Version=", 8);
    uint64_t v10 = (void *)std::ostream::operator<<();
    std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(void *)(*v10 - 24)));
    int v11 = std::locale::use_facet((const std::locale *)&v68, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
    std::locale::~locale((std::locale *)&v68);
    std::ostream::put();
    std::ostream::flush();
    double v12 = sub_10004B96C(v82, (uint64_t)"IncidentIdentifier=", 19);
    size_t v13 = strlen((const char *)__p);
    int v14 = sub_10004B96C(v12, (uint64_t)__p, v13);
    std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24)));
    char v15 = std::locale::use_facet((const std::locale *)&v68, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
    std::locale::~locale((std::locale *)&v68);
    std::ostream::put();
    std::ostream::flush();
    uint64_t v55 = 0;
    uint64_t v56 = 0;
    uint64_t v57 = 0;
    sub_100BAC598((uint64_t)&v55);
    if (*(unsigned char *)(a1 + 2))
    {
      char v16 = sub_10004B96C(v82, (uint64_t)"Date=", 5);
      size_t v17 = strlen(__str);
      uint64_t v18 = sub_10004B96C(v16, (uint64_t)__str, v17);
      uint64_t v19 = sub_10004B96C(v18, (uint64_t)";AP=", 4);
      if (v66 >= 0) {
        int v20 = &v64;
      }
      else {
        int v20 = v64;
      }
      if (v66 >= 0) {
        uint64_t v21 = HIBYTE(v66);
      }
      else {
        uint64_t v21 = v65;
      }
      int v22 = sub_10004B96C(v19, (uint64_t)v20, v21);
      unsigned int v23 = sub_10004B96C(v22, (uint64_t)";BB=", 4);
      if (v63 >= 0) {
        uint64_t v24 = &v61;
      }
      else {
        uint64_t v24 = v61;
      }
      if (v63 >= 0) {
        uint64_t v25 = HIBYTE(v63);
      }
      else {
        uint64_t v25 = v62;
      }
      uint64_t v26 = sub_10004B96C(v23, (uint64_t)v24, v25);
      uint64_t v27 = sub_10004B96C(v26, (uint64_t)";Model=", 7);
      sub_100BAC4FC((uint64_t)&v68);
      if ((v69 & 0x80u) == 0) {
        uint64_t v28 = &v68;
      }
      else {
        uint64_t v28 = (long long *)v68;
      }
      if ((v69 & 0x80u) == 0) {
        uint64_t v29 = v69;
      }
      else {
        uint64_t v29 = *((void *)&v68 + 1);
      }
      BOOL v30 = sub_10004B96C(v27, (uint64_t)v28, v29);
      int v31 = sub_10004B96C(v30, (uint64_t)";Machine=", 9);
      if (v57 >= 0) {
        int v32 = &v55;
      }
      else {
        int v32 = v55;
      }
      if (v57 >= 0) {
        uint64_t v33 = HIBYTE(v57);
      }
      else {
        uint64_t v33 = v56;
      }
      unsigned int v34 = sub_10004B96C(v31, (uint64_t)v32, v33);
      std::ios_base::getloc((const std::ios_base *)((char *)v34 + *(void *)(*v34 - 24)));
      char v35 = std::locale::use_facet(&v67, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v35->__vftable[2].~facet_0)(v35, 10);
      std::locale::~locale(&v67);
      std::ostream::put();
      std::ostream::flush();
      if ((char)v69 < 0) {
        operator delete((void *)v68);
      }
    }
    else
    {
      std::string::size_type v36 = sub_10004B96C(v82, (uint64_t)"Date=", 5);
      size_t v37 = strlen(__str);
      long long v38 = sub_10004B96C(v36, (uint64_t)__str, v37);
      std::string v39 = sub_10004B96C(v38, (uint64_t)";AP=", 4);
      if (v66 >= 0) {
        std::string v40 = &v64;
      }
      else {
        std::string v40 = v64;
      }
      if (v66 >= 0) {
        uint64_t v41 = HIBYTE(v66);
      }
      else {
        uint64_t v41 = v65;
      }
      long long v42 = sub_10004B96C(v39, (uint64_t)v40, v41);
      long long v43 = sub_10004B96C(v42, (uint64_t)";BB=", 4);
      if (v63 >= 0) {
        uint64_t v44 = &v61;
      }
      else {
        uint64_t v44 = v61;
      }
      if (v63 >= 0) {
        uint64_t v45 = HIBYTE(v63);
      }
      else {
        uint64_t v45 = v62;
      }
      uint64_t v46 = sub_10004B96C(v43, (uint64_t)v44, v45);
      long long v47 = sub_10004B96C(v46, (uint64_t)";Machine=", 9);
      if (v57 >= 0) {
        uint64_t v48 = &v55;
      }
      else {
        uint64_t v48 = v55;
      }
      if (v57 >= 0) {
        uint64_t v49 = HIBYTE(v57);
      }
      else {
        uint64_t v49 = v56;
      }
      uint64_t v50 = sub_10004B96C(v47, (uint64_t)v48, v49);
      std::ios_base::getloc((const std::ios_base *)((char *)v50 + *(void *)(*v50 - 24)));
      uint64_t v51 = std::locale::use_facet((const std::locale *)&v68, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v51->__vftable[2].~facet_0)(v51, 10);
      std::locale::~locale((std::locale *)&v68);
      std::ostream::put();
      std::ostream::flush();
    }
    CSILogger::CSILogger();
    uint64_t v52 = v70;
    CSILogger::~CSILogger((CSILogger *)&v68);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_DWORD *)((char *)&v82[2] + *(void *)(v81[0] - 24))) {
        uint64_t v53 = "bad";
      }
      else {
        uint64_t v53 = "good";
      }
      LODWORD(v68) = 136315138;
      *(void *)((char *)&v68 + 4) = v53;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I wrote stats file header, and it's %s", (uint8_t *)&v68, 0xCu);
    }
    if (!std::filebuf::close()) {
      std::ios_base::clear((std::ios_base *)((char *)v81 + *(void *)(v81[0] - 24)), *(_DWORD *)((char *)&v82[2] + *(void *)(v81[0] - 24)) | 4);
    }
    if (SHIBYTE(v57) < 0) {
      operator delete(v55);
    }
    if (SHIBYTE(v63) < 0) {
      operator delete(v61);
    }
    if (SHIBYTE(v66) < 0) {
      operator delete(v64);
    }
  }
  v81[0] = off_1019BBD08;
  v82[52] = off_1019BBD58;
  v82[0] = off_1019BBD30;
  std::filebuf::~filebuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100358544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,std::locale a41,std::locale a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  sub_1003587C8(&a70);
  _Unwind_Resume(a1);
}

uint64_t sub_100358650(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = off_1019BBD30;
  *(void *)a1 = &off_1019BBE48;
  *(void *)(a1 + 432) = &off_1019BBE70;
  std::ios_base::init((std::ios_base *)(a1 + 432), (void *)(a1 + 24));
  *(void *)(a1 + 568) = 0;
  *(_DWORD *)(a1 + 576) = -1;
  *(void *)a1 = off_1019BBD08;
  *(void *)(a1 + 432) = off_1019BBD58;
  *(void *)(a1 + 16) = off_1019BBD30;
  std::filebuf::basic_filebuf();
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24)), *(_DWORD *)(a1 + *(void *)(*(void *)a1 - 24) + 32) | 4);
  }
  return a1;
}

void sub_100358788(_Unwind_Exception *a1)
{
}

void *sub_1003587C8(void *a1)
{
  *a1 = off_1019BBD08;
  a1[54] = off_1019BBD58;
  a1[2] = off_1019BBD30;
  std::filebuf::~filebuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  return a1;
}

uint64_t sub_10035886C(void *a1)
{
  *(a1 - 2) = off_1019BBD08;
  a1[52] = off_1019BBD58;
  *a1 = off_1019BBD30;
  std::filebuf::~filebuf();
  std::iostream::~basic_iostream();

  return std::ios::~ios();
}

uint64_t sub_100358910(void *a1)
{
  unint64_t v1 = (void *)((char *)a1 + *(void *)(*a1 - 24));
  *unint64_t v1 = off_1019BBD08;
  v1[54] = off_1019BBD58;
  v1[2] = off_1019BBD30;
  std::filebuf::~filebuf();
  std::iostream::~basic_iostream();

  return std::ios::~ios();
}

void sub_1003589D0(void *a1)
{
  *a1 = off_1019BBD08;
  a1[54] = off_1019BBD58;
  a1[2] = off_1019BBD30;
  std::filebuf::~filebuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();

  operator delete();
}

void sub_100358A94(void *a1)
{
  *(a1 - 2) = off_1019BBD08;
  a1[52] = off_1019BBD58;
  *a1 = off_1019BBD30;
  std::filebuf::~filebuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();

  operator delete();
}

void sub_100358B50(void *a1)
{
  unint64_t v1 = (void *)((char *)a1 + *(void *)(*a1 - 24));
  *unint64_t v1 = off_1019BBD08;
  v1[54] = off_1019BBD58;
  v1[2] = off_1019BBD30;
  std::filebuf::~filebuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();

  operator delete();
}

atomic_uint **sub_100358C28(uint64_t a1, char a2)
{
  sub_100358C70((uint64_t *)(a1 + 24));
  CFUUIDRef v4 = (uint64_t *)sub_100358E0C((uint64_t *)(a1 + 8));

  return sub_100358E50(v4, a2);
}

uint64_t sub_100358C70(uint64_t *a1)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v9 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  *(_OWORD *)CFStringRef v6 = 0u;
  memset(v5, 0, sizeof(v5));
  sub_10004DE24((uint64_t)v5);
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)v5 + 8, __p);
  sub_1001AA668(a1, (uint64_t *)__p);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100358DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000C937C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100358E0C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_100358E50(uint64_t *a1, char a2)
{
  char v24 = a2;
  long long v23 = 0uLL;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v3 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(&v27, v3);
  uint64_t v4 = a1[1];
  if (v4)
  {
    if (atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) == 1) {
      sub_1003590CC(a1, &v27, 0, 1);
    }
    uint64_t v5 = *a1;
    uint64_t v6 = a1[1];
    if (v6) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v6 + 8), 1u, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v5 = *a1;
  }
  long long v7 = v23;
  *(void *)&long long v23 = v5;
  *((void *)&v23 + 1) = v6;
  v26[0] = v7;
  sub_10000A740((atomic_uint **)v26 + 1);
  sub_10000A6C8(*((pthread_mutex_t **)&v38 + 1));
  sub_10000A5F8(&v27);
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v27 = 0u;
  uint64_t v42 = 0;
  uint64_t v43 = 10;
  uint64_t v44 = (char *)&v27 + 8;
  uint64_t v45 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  uint64_t v46 = &v24;
  long long v8 = (uint64_t *)sub_100359180((uint64_t *)&v23);
  v22[0] = &v27;
  v22[1] = a1;
  v22[2] = sub_1003593F0(v8);
  uint64_t v9 = sub_100359180((uint64_t *)&v23);
  uint64_t v10 = sub_100060EA8((uint64_t *)(v9 + 16));
  long long v11 = (uint64_t *)sub_100359180((uint64_t *)&v23);
  uint64_t v12 = *(void *)(sub_1003593F0(v11) + 8);
  long long v13 = (uint64_t *)sub_100359180((uint64_t *)&v23);
  *(void *)&long long v20 = v12;
  *((void *)&v20 + 1) = sub_1003593F0(v13);
  *(void *)&long long v21 = &v27;
  *((void *)&v21 + 1) = *((void *)&v20 + 1);
  sub_100359654((uint64_t *)&v20);
  long long v14 = (uint64_t *)sub_100359180((uint64_t *)&v23);
  uint64_t v15 = sub_1003593F0(v14);
  long long v16 = (uint64_t *)sub_100359180((uint64_t *)&v23);
  *(void *)&long long v18 = v15;
  *((void *)&v18 + 1) = sub_1003593F0(v16);
  *(void *)&long long v19 = &v27;
  *((void *)&v19 + 1) = *((void *)&v18 + 1);
  sub_100359654((uint64_t *)&v18);
  v26[0] = v20;
  v26[1] = v21;
  v25[0] = v18;
  v25[1] = v19;
  sub_100359434(v10, (uint64_t *)v26, v25);
  sub_100359A14((uint64_t)v22);
  sub_10035A2EC((uint64_t)&v27);
  return sub_10000A740((atomic_uint **)&v23 + 1);
}

void sub_100359078(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,atomic_uint *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

uint64_t *sub_1003590CC(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  uint64_t v9 = (uint64_t *)sub_100359180(a1);
  uint64_t v10 = sub_1003593F0(v9);
  long long v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    uint64_t v12 = (uint64_t *)sub_100359180(a1);
    long long v11 = *(uint64_t **)(sub_1003593F0(v12) + 8);
  }
  long long v14 = v11;
  return sub_1003591C4(a1, a2, a3, &v14, a4);
}

uint64_t sub_100359180(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_1003591C4(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  int v22 = *a4;
  uint64_t v10 = (uint64_t *)sub_100359180(a1);
  uint64_t result = (uint64_t *)sub_1003593F0(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_100359300(result + 2);
        sub_100359344(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_100359300(result + 2) + 24))
      {
        uint64_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        long long v16 = (uint64_t *)sub_100359180(a1);
        uint64_t v17 = sub_1003593F0(v16);
        uint64_t v18 = sub_100359300(v22 + 2);
        uint64_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      int v22 = (uint64_t *)v15;
      long long v19 = (uint64_t *)sub_100359180(a1);
      long long v20 = (uint64_t *)sub_1003593F0(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t sub_100359300(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_100359344(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    uint64_t v6 = (uint64_t *)sub_1003593AC(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_1003593AC(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_1003593F0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100359434(uint64_t a1, uint64_t *a2, void *a3)
{
  while (*a2 != *a3)
  {
    sub_1003594B4(a2);
    *a2 = *(void *)(*a2 + 8);
    sub_100359654(a2);
    uint64_t v5 = (unsigned char *)a2[2];
    if (*v5) {
      *uint64_t v5 = 0;
    }
  }
}

unsigned char *sub_1003594B4(void *a1)
{
  uint64_t v2 = (unsigned char *)a1[2];
  if (!*v2)
  {
    sub_100359570((uint64_t)(v2 + 272), (uint64_t *)(*a1 + 16));
    if (!*v2) {
      unsigned char *v2 = 1;
    }
  }
  uint64_t v3 = (unsigned char *)a1[2];
  if (!*v3) {
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
  return v3 + 1;
}

uint64_t sub_100359570(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = sub_100359300(a2);
  uint64_t v3 = (void *)(sub_1003593AC((uint64_t *)(v2 + 32)) + 24);

  return sub_1003595BC(v3);
}

uint64_t sub_1003595BC(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  unint64_t v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_100359640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void sub_100359654(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_15;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      uint64_t v3 = (uint64_t *)(*a1 + 16);
      long long v15 = 0u;
      long long v16 = 0u;
      uint64_t v4 = sub_1003598B0(v3);
      sub_10000A4EC(&v15, v4);
      uint64_t v5 = (atomic_uint **)sub_100359300((uint64_t *)(*a1 + 16));
      sub_1003598F4(v5, &v15, (void *)(a1[2] + 8));
      uint64_t v6 = sub_100359300((uint64_t *)(*a1 + 16));
      uint64_t v7 = a1[2];
      if (*(unsigned char *)(v6 + 24)) {
        ++*(_DWORD *)(v7 + 280);
      }
      else {
        ++*(_DWORD *)(v7 + 284);
      }
      uint64_t v8 = sub_100359300((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v8 + 24)
        || (uint64_t v9 = *(void *)(v8 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v9 + 8), memory_order_acquire))
      {
        int v10 = 1;
      }
      else
      {
        sub_1001AB328(a1, &v15, *a1);
        int v10 = 0;
      }
      (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
      sub_10000A5F8(&v15);
      uint64_t v1 = *a1;
      uint64_t v11 = a1[1];
      if (!v10) {
        break;
      }
      uint64_t v12 = *(void *)(v1 + 8);
      *a1 = v12;
      if (v12 == v11)
      {
        uint64_t v1 = v11;
        goto LABEL_15;
      }
    }
    if (v1 == v11)
    {
LABEL_15:
      uint64_t v13 = a1[3];
      if (v13 != v1)
      {
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v15 = 0u;
        long long v16 = 0u;
        uint64_t v14 = sub_1003598B0((uint64_t *)(v13 + 16));
        sub_10000A4EC(&v15, v14);
        sub_1001AB328(a1, &v15, a1[1]);
        (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
        sub_10000A5F8(&v15);
      }
    }
  }
}

void sub_100359874(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003598B0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_1003598F4(atomic_uint **result, void *a2, void *a3)
{
  uint64_t v3 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v6 = result;
    for (uint64_t i = *(atomic_uint **)sub_1003593AC((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_1003593AC(v3);
      if (i == result[1]) {
        break;
      }
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v6 + 24))
        {
          *((unsigned char *)v6 + 24) = 0;
          sub_100060D70(v6, a2);
        }
        return sub_1000624B4((uint64_t)v8);
      }
      sub_100062188(a3, (uint64_t)v8);
      sub_1000624B4((uint64_t)v8);
    }
  }
  return result;
}

void sub_1003599F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100359A14(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)a1 + 284) > *(_DWORD *)(*(void *)a1 + 280)) {
    sub_100359A58(*(uint64_t **)(a1 + 8), *(void *)(a1 + 16));
  }
  return a1;
}

void sub_100359A58(uint64_t *a1, uint64_t a2)
{
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  uint64_t v4 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v9, v4);
  uint64_t v5 = (uint64_t *)sub_100359180(a1);
  if (sub_1003593F0(v5) == a2)
  {
    uint64_t v6 = a1[1];
    if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
      operator new();
    }
    uint64_t v7 = (uint64_t *)sub_100359180(a1);
    uint64_t v8 = *(uint64_t **)(sub_1003593F0(v7) + 8);
    sub_1003591C4(a1, v9, 0, &v8, 0);
  }
  sub_10000A6C8(*((pthread_mutex_t **)&v10 + 1));
  sub_10000A5F8(v9);
}

void sub_100359BA4()
{
}

void sub_100359BF8(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_100359CB8(&v2, a2);
}

uint64_t sub_100359C74(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100359CB8(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100359D24(&v2);
}

void sub_100359D10(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100359D24(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100359D94(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_100359DA8(_Unwind_Exception *a1)
{
}

void sub_100359DC0()
{
}

uint64_t sub_100359DD4(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100359E38()
{
  return 0;
}

uint64_t sub_100359E40()
{
  return 0;
}

uint64_t sub_100359E48()
{
  return 0;
}

void sub_100359E50()
{
}

void sub_100359ECC()
{
}

uint64_t sub_100359EF0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10035A07C((uint64_t *)a1, a2);
  sub_10035A0E8((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    uint64_t v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      long long v10 = (void *)v5[1];
      uint64_t v11 = v10;
      uint64_t v12 = v5;
      if (v10)
      {
        do
        {
          uint64_t v13 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          uint64_t v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          long long v16 = v10;
          long long v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          long long v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      long long v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          long long v18 = v17;
          long long v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          long long v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          uint64_t v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      uint64_t v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_10035A054(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_10035A07C(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_10035A0D4(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10035A0E8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_10035A138(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_10035A150(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10035A1BC(&v2);
}

void sub_10035A1A8(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10035A1BC(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10035A22C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_10035A240(_Unwind_Exception *a1)
{
}

void sub_10035A258()
{
}

uint64_t sub_10035A26C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_10035A2D4()
{
  return 0;
}

uint64_t sub_10035A2DC()
{
  return 0;
}

uint64_t sub_10035A2E4()
{
  return 0;
}

uint64_t sub_10035A2EC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 288);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 288), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_10035A3C0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10035A3E0()
{
  __cxa_atexit((void (*)(void *))sub_100356BC4, &unk_101B0CC18, (void *)&_mh_execute_header);

  return __cxa_atexit((void (*)(void *))&std::mutex::~mutex, &stru_101B09F68, (void *)&_mh_execute_header);
}

void sub_10035A450()
{
}

void sub_10035A500(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10035A518(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        long long v10 = (std::__shared_weak_count *)a3[1];
        uint64_t v11 = *a3;
        uint64_t v12 = v10;
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v9 + 56))(v9, a2, &v11);
        if (v12) {
          sub_10004D2C8(v12);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10035A5C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_10035A5E4(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    long long v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        uint64_t v8 = (std::__shared_weak_count *)a2[1];
        uint64_t v9 = *a2;
        long long v10 = v8;
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v7 + 120))(v7, &v9);
        if (v10) {
          sub_10004D2C8(v10);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10035A688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_10035A6A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  long long v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      long long v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 80))(v11, a2, a3, a4);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_10035A758(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10035A76C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v6);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)(a1 + 8);
      if (v13)
      {
        BOOL v14 = (std::__shared_weak_count *)a3[1];
        uint64_t v18 = *a3;
        long long v19 = v14;
        if (v14) {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v15 = (std::__shared_weak_count *)a5[1];
        uint64_t v16 = *a5;
        long long v17 = v15;
        if (v15) {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t *))(*(void *)v13 + 104))(v13, a2, &v18, a4, &v16);
        if (v17) {
          sub_10004D2C8(v17);
        }
        if (v19) {
          sub_10004D2C8(v19);
        }
      }
      sub_10004D2C8(v12);
    }
  }
}

void sub_10035A854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

void sub_10035A880(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v6);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)(a1 + 8);
      if (v13)
      {
        BOOL v14 = (std::__shared_weak_count *)a3[1];
        uint64_t v17 = *a3;
        uint64_t v18 = v14;
        if (v14) {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (*(char *)(a5 + 23) < 0)
        {
          sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)a5;
          uint64_t v16 = *(void *)(a5 + 16);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, void **))(*(void *)v13 + 112))(v13, a2, &v17, a4, __p);
        if (SHIBYTE(v16) < 0) {
          operator delete(__p[0]);
        }
        if (v18) {
          sub_10004D2C8(v18);
        }
      }
      sub_10004D2C8(v12);
    }
  }
}

void sub_10035A980(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void *sub_10035A9B8(void *a1)
{
  *a1 = off_1019BBFB8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10035AA04(void *a1)
{
  *a1 = off_1019BBFB8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_10035AA70(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10035AAD8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10035AB14(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10035AB4C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10035AB7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t emergency::BBSearchDriver::BBSearchDriver(uint64_t a1, void *a2, NSObject **a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v18, kCtLoggingSystemName, "em.driver");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v6 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v6) {
    dispatch_retain(v6);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v16, &v18);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v16);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v16);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
  v17[0] = off_101999E18;
  v17[1] = sub_10035B038;
  v17[3] = v17;
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v7) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  sub_10008863C(v17);
  *(void *)a1 = off_1019BC0B0;
  *(_DWORD *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 60) = 0;
  *(void *)(a1 + 64) = *a2;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 72) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 104) = 0;
  sub_100058DB0(&__p, "EmergencyBBSearchDriver");
  uint64_t v9 = *(NSObject **)(a1 + 24);
  uint64_t v13 = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  long long v10 = *(NSObject **)(a1 + 32);
  xpc_object_t object = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v13) {
    dispatch_release(v13);
  }
  if (v15 < 0) {
    operator delete(__p);
  }
  sub_100136414((uint64_t *)(a1 + 128), (uint64_t)&rest::kDefaultRadioAccessTechnologies);
  sub_10005DF14((uint64_t *)(a1 + 152), (uint64_t)&rest::kDefaultCsAttachedStates);
  sub_10035D650((uint64_t *)(a1 + 176), (uint64_t)&rest::kDefaultRegistrationStatuses);
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = a1 + 232;
  return a1;
}

void sub_10035AEC0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
}

const char *sub_10035B038(int a1)
{
  uint64_t v1 = "em.driver.?";
  if (a1 == 2) {
    uint64_t v1 = "em.driver.2";
  }
  if (a1 == 1) {
    return "em.driver.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_10035B064(uint64_t a1)
{
  *(void *)a1 = off_1019BC0B0;
  sub_10005CD2C(a1 + 224, *(char **)(a1 + 232));
  uint64_t v6 = (void **)(a1 + 200);
  sub_10008A88C(&v6);
  sub_1000346F8(a1 + 176, *(void **)(a1 + 184));
  sub_1000346F8(a1 + 152, *(void **)(a1 + 160));
  sub_1000346F8(a1 + 128, *(void **)(a1 + 136));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 120);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10035D6A8((void *)(a1 + 80));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  emergency::SearchDriver::~SearchDriver((emergency::SearchDriver *)a1);
  uint64_t v4 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_10035B158(uint64_t a1)
{
  sub_10035B064(a1);

  operator delete();
}

void sub_10035B190(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v6, *(Registry **)(a1 + 64));
  ctu::RestModule::connect();
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_10012E258(a1 + 128);
  sub_10035B420(a1 + 152);
  sub_10035B500(a1 + 176);
  sub_1001660E8(a1 + 224);
  sub_10035B5E0(a1 + 200);
  *(_DWORD *)(a1 + 56) = 0;
  sub_100058DB0(__p, "/cc/events/e911_state_ready");
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = off_1019BC3F8;
  v2[1] = a1;
  v2[2] = sub_10035B6C0;
  v2[3] = 0;
  uint64_t v11 = v2;
  ctu::RestModule::observeEvent();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (TelephonyRadiosGetRadioVendor() == 2
    || (RadioVendor = (capabilities::ct *)TelephonyRadiosGetRadioVendor(), RadioVendor == 3)
    || capabilities::ct::supportsEmergencyQMIExtensions(RadioVendor))
  {
    sub_100058DB0(__p, "/cc/events/e911_chosen_slot");
    uint64_t v4 = operator new(0x20uLL);
    *uint64_t v4 = off_1019BC478;
    v4[1] = a1;
    _OWORD v4[2] = sub_10035B844;
    v4[3] = 0;
    uint64_t v11 = v4;
    ctu::RestModule::observeEvent();
    sub_10003F600(v10);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  long long v5 = operator new(0x20uLL);
  *long long v5 = off_1019BC4F8;
  v5[1] = a1;
  v5[2] = sub_10035BA00;
  v5[3] = 0;
  uint64_t v11 = v5;
  ctu::RestModule::observeEvent();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10035B3C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10035B420(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/reg_cs_attached");
  v4[0] = off_1019BC278;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_10035B4D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10035B500(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/registration_status");
  v4[0] = off_1019BC2F8;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_10035B5B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10035B5E0(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/sims_in_use");
  v4[0] = off_1019BC378;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_10035B694(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10035B6C0(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    int v4 = *(_DWORD *)(a2 + 4);
  }
  else
  {
    long long v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v8[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "!! handleE911StateReady is not successful", (uint8_t *)v8, 2u);
    }
    int v4 = 0;
  }
  *(_DWORD *)(a1 + 56) = v4;
  if (*(void *)(a1 + 104))
  {
    uint64_t v6 = (void *)(a1 + 80);
    memset(v8, 0, sizeof(v8));
    sub_10035E960((uint64_t)v8, (uint64_t)v6);
    sub_10035E8D8(v6);
    sub_10035D3E0((uint64_t)v8, *(unsigned char *)a2, *(_DWORD *)(a2 + 4));
    sub_10035D6A8(v8);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a2 + 4));
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Search Done, but no call back handle was set.", (uint8_t *)v8, 2u);
    }
  }
}

void sub_10035B828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10035B844(uint64_t a1, unint64_t a2)
{
  char v2 = a2;
  unint64_t v4 = HIDWORD(a2);
  long long v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = subscriber::asString();
    uint64_t v7 = v2 & 1;
    uint64_t v8 = "true";
    if (!v7) {
      uint64_t v8 = "false";
    }
    LODWORD(v11[0]) = 136315394;
    *(void *)((char *)v11 + 4) = v6;
    WORD6(v11[0]) = 2080;
    *(void *)((char *)v11 + 14) = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I ChosenSlotForEmergency recommended by BB %s. Is normal setup: %s", (uint8_t *)v11, 0x16u);
  }
  else
  {
    uint64_t v7 = v2 & 1;
  }
  *(_DWORD *)(a1 + 56) = v4;
  if (v7)
  {
    *(unsigned char *)(a1 + 60) = 1;
    if (*(void *)(a1 + 104))
    {
      char v9 = (void *)(a1 + 80);
      memset(v11, 0, sizeof(v11));
      sub_10035E960((uint64_t)v11, (uint64_t)v9);
      sub_10035E8D8(v9);
      sub_10035D3E0((uint64_t)v11, 1, v4);
      sub_10035D6A8(v11);
    }
    else
    {
      long long v10 = *(NSObject **)(*(uint64_t (**)(void, unint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v11[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Have chosen a slot, but no call back handle was set.", (uint8_t *)v11, 2u);
      }
    }
  }
}

void sub_10035B9E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10035BA00(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    int v2 = 136315138;
    uint64_t v3 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I ChosenSlotForEmergency %s", (uint8_t *)&v2, 0xCu);
  }
}

uint64_t sub_10035BAA4(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 112));
}

void sub_10035BAAC(unint64_t a1, uint64_t a2, char a3, char a4, uint64_t a5)
{
  sub_10035C138((void *)(a1 + 80), a5);
  unsigned int SingleSlotForEmergency = getSingleSlotForEmergency();
  if (SingleSlotForEmergency <= 1) {
    int v10 = 1;
  }
  else {
    int v10 = SingleSlotForEmergency;
  }
  *(_DWORD *)(a1 + 56) = v10;
  std::string __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  uint64_t v11 = (capabilities::ct *)sub_10035D43C(&__p, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  if (!capabilities::ct::supportsEmergencyQMIExtensions(v11)) {
    goto LABEL_37;
  }
  *(void *)time_t v58 = 0;
  tm v59 = 0;
  unsigned __int8 v12 = a1 + 64;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  BOOL v14 = ServiceMap;
  if (v15 < 0)
  {
    uint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v15;
  long long v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
  if (v19)
  {
    uint64_t v21 = v19[3];
    long long v20 = (std::__shared_weak_count *)v19[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v14);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v20);
      char v22 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  std::mutex::unlock(v14);
  long long v20 = 0;
  char v22 = 1;
LABEL_13:
  PersonalityIdFromSlotIdEx();
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint8_t *))(*(void *)v21 + 40))(v58, v21, buf);
  if (SBYTE7(v66) < 0)
  {
    operator delete(*(void **)buf);
    if (v22) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  if ((v22 & 1) == 0) {
LABEL_15:
  }
    sub_10004D2C8(v20);
LABEL_16:
  uint64_t v23 = *(void *)v58;
  if (*(void *)v58) {
    unsigned __int8 v12 = (*(uint64_t (**)(void))(**(void **)v58 + 400))(*(void *)v58);
  }
  if (v59) {
    sub_10004D2C8(v59);
  }
  if (((v23 != 0) & v12) == 1)
  {
    unint64_t v24 = *(void *)(a1 + 136);
    if (v24)
    {
      int v25 = *(_DWORD *)(a1 + 56);
      unint64_t v26 = a1 + 136;
      do
      {
        int v27 = *(_DWORD *)(v24 + 28);
        BOOL v28 = v27 < v25;
        if (v27 >= v25) {
          long long v29 = (uint64_t *)v24;
        }
        else {
          long long v29 = (uint64_t *)(v24 + 8);
        }
        if (!v28) {
          unint64_t v26 = v24;
        }
        unint64_t v24 = *v29;
      }
      while (*v29);
      if (v26 != a1 + 136 && *(_DWORD *)(v26 + 28) <= v25 && *(_DWORD *)(v26 + 32) == 10)
      {
        BOOL v30 = v25 != 1;
        int v31 = *(_DWORD *)(*(void *)a2 + 4 * v30);
        if (v31 == 3) {
          int v31 = 4;
        }
        *((_DWORD *)__p + v30) = v31;
      }
    }
  }
LABEL_37:
  long long v32 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v33 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v33;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Default ChosenSlotForEmergency (before BB recommendation) %s", buf, 0xCu);
  }
  *(_OWORD *)std::string buf = 0u;
  long long v66 = 0u;
  long long v52 = a1;
  long long v53 = 0uLL;
  sub_10035D43C((void *)&v52 + 1, __p, (uint64_t)v56, (v56 - (unsigned char *)__p) >> 2);
  LOBYTE(v54) = a3;
  HIBYTE(v54) = a4;
  *((void *)&v66 + 1) = 0;
  long long v34 = (char *)operator new(0x30uLL);
  *(void *)long long v34 = off_1019BC578;
  long long v35 = v53;
  *(_OWORD *)(v34 + 8) = v52;
  *(_OWORD *)(v34 + 24) = v35;
  long long v53 = 0uLL;
  *((void *)&v52 + 1) = 0;
  *((_WORD *)v34 + 20) = v54;
  *((void *)&v66 + 1) = v34;
  if (sub_100529568())
  {
    long long v36 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
    long long v37 = v36;
    if (v38 < 0)
    {
      long long v39 = (unsigned __int8 *)(v38 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v40 = 5381;
      do
      {
        uint64_t v38 = v40;
        unsigned int v41 = *v39++;
        uint64_t v40 = (33 * v40) ^ v41;
      }
      while (v41);
    }
    std::mutex::lock(v36);
    *(void *)time_t v58 = v38;
    uint64_t v42 = sub_10004D37C(&v37[1].__m_.__sig, (unint64_t *)v58);
    if (v42)
    {
      uint64_t v44 = v42[3];
      uint64_t v43 = (std::__shared_weak_count *)v42[4];
      if (v43)
      {
        atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v37);
        atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v43);
        char v45 = 0;
        if (!v44)
        {
LABEL_54:
          if ((v45 & 1) == 0) {
            sub_10004D2C8(v43);
          }
          goto LABEL_56;
        }
LABEL_49:
        *(void *)&long long v60 = a1;
        uint64_t v46 = *(std::__shared_weak_count **)(a1 + 16);
        if (!v46 || (v47 = *(void *)(a1 + 8), (uint64_t v48 = std::__shared_weak_count::lock(v46)) == 0)) {
          sub_100088B9C();
        }
        *((void *)&v60 + 1) = v47;
        uint64_t v61 = v48;
        atomic_fetch_add_explicit(&v48->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v48);
        sub_1000DA470((uint64_t)v62, (uint64_t)buf);
        unint64_t v64 = 0;
        uint64_t v49 = (char *)operator new(0x40uLL);
        *(void *)uint64_t v49 = off_1019BC5F8;
        *(_OWORD *)(v49 + 8) = v60;
        *((void *)v49 + 3) = v61;
        *((void *)&v60 + 1) = 0;
        uint64_t v61 = 0;
        sub_1000DA470((uint64_t)(v49 + 32), (uint64_t)v62);
        unint64_t v64 = v49;
        (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v44 + 96))(v44, 900, v63);
        sub_100060644(v63);
        sub_10003B34C(v62);
        if (v61) {
          std::__shared_weak_count::__release_weak(v61);
        }
        sub_1003355AC(buf);
        goto LABEL_54;
      }
    }
    else
    {
      uint64_t v44 = 0;
    }
    std::mutex::unlock(v37);
    uint64_t v43 = 0;
    char v45 = 1;
    if (!v44) {
      goto LABEL_54;
    }
    goto LABEL_49;
  }
LABEL_56:
  uint64_t v50 = *((void *)&v66 + 1);
  if (*((void *)&v66 + 1))
  {
    uint64_t v51 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)time_t v58 = 0;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Temporary 2G enablement not needed. Triggering E911 state enter", v58, 2u);
      uint64_t v50 = *((void *)&v66 + 1);
      if (!*((void *)&v66 + 1)) {
        sub_10007B600();
      }
    }
    (*(void (**)(uint64_t))(*(void *)v50 + 48))(v50);
  }
  sub_10003B34C(buf);
  if (__p)
  {
    uint64_t v56 = __p;
    operator delete(__p);
  }
}

void sub_10035C05C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  sub_100060644(&a27);
  sub_10020F39C((uint64_t)&a19);
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  sub_10003B34C((void *)(v29 - 128));
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_10035C138(void *a1, uint64_t a2)
{
  sub_10035E960((uint64_t)v4, a2);
  sub_10035DDE4(v4, a1);
  sub_10035D6A8(v4);
  return a1;
}

void sub_10035C1AC(uint64_t a1)
{
  sub_10035E8D8((void *)(a1 + 80));
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Exit Search on slot %s", buf, 0xCu);
  }
  if (*(unsigned char *)(a1 + 60))
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Emergency call dialed with normal setup. No need to send E911 state exit.", buf, 2u);
    }
    *(unsigned char *)(a1 + 60) = 0;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 56);
    xpc_object_t v8 = 0;
    uint64_t v5 = subscriber::asString();
    ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, (ctu::rest::detail *)v4, v5, v6);
    sub_100058DB0(buf, "/cc/events/e911_state_exit");
    xpc_object_t object = v8;
    xpc_object_t v8 = xpc_null_create();
    ctu::RestModule::sendEvent();
    xpc_release(object);
    if (v10 < 0) {
      operator delete(*(void **)buf);
    }
    xpc_release(v8);
  }
}

void sub_10035C320(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, xpc_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10035C380(uint64_t a1, uint64_t a2)
{
  int v4 = (Registry **)(a1 + 64);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    xpc_object_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string __p = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)__p);
  if (v11)
  {
    uint64_t v13 = v11[3];
    unsigned __int8 v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v15 = 0;
      if (!v13) {
        goto LABEL_7;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  unsigned __int8 v12 = 0;
  char v15 = 1;
  if (!v13)
  {
LABEL_7:
    uint64_t v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string __p = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "!! Can't find RegistrationController. Bailing...", __p, 2u);
    }
    uint64_t v17 = 0;
    if (v15) {
      return v17;
    }
LABEL_65:
    sub_10004D2C8(v12);
    return v17;
  }
LABEL_13:
  int v18 = capabilities::ct::supportsEmergencyQMIExtensions(v14);
  long long v20 = *(_DWORD **)(a1 + 200);
  long long v19 = *(_DWORD **)(a1 + 208);
  if (v20 != v19)
  {
    while (*v20 != a2)
    {
      v20 += 42;
      if (v20 == v19) {
        goto LABEL_19;
      }
    }
  }
  if (v20 == v19 || (subscriber::isSimAbsent() & 1) != 0) {
LABEL_19:
  }
    int isSimUnreadable = 1;
  else {
    int isSimUnreadable = subscriber::isSimUnreadable();
  }
  uint64_t v52 = 0;
  long long v53 = 0;
  char v22 = (std::mutex *)Registry::getServiceMap(*v4);
  uint64_t v23 = v22;
  if (v24 < 0)
  {
    int v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v26 = 5381;
    do
    {
      uint64_t v24 = v26;
      unsigned int v27 = *v25++;
      uint64_t v26 = (33 * v26) ^ v27;
    }
    while (v27);
  }
  std::mutex::lock(v22);
  *(void *)std::string __p = v24;
  char v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)__p);
  if (v28)
  {
    uint64_t v30 = v28[3];
    uint64_t v29 = (std::__shared_weak_count *)v28[4];
    if (v29)
    {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v23);
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v29);
      char v31 = 0;
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v30 = 0;
  }
  std::mutex::unlock(v23);
  uint64_t v29 = 0;
  char v31 = 1;
LABEL_29:
  PersonalityIdFromSlotIdEx();
  (*(void (**)(uint64_t *__return_ptr, uint64_t, unsigned char *))(*(void *)v30 + 40))(&v52, v30, __p);
  if ((v57 & 0x80000000) == 0)
  {
    if (v31) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  operator delete(*(void **)__p);
  if ((v31 & 1) == 0) {
LABEL_31:
  }
    sub_10004D2C8(v29);
LABEL_32:
  uint64_t v32 = v52;
  if (v52) {
    LOBYTE(v29) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v52 + 384))(v52, 1);
  }
  if (v53) {
    sub_10004D2C8(v53);
  }
  uint64_t v33 = *(void *)(a1 + 136);
  if (v33)
  {
    int v34 = (v32 != 0) & v29;
    uint64_t v35 = a1 + 136;
    do
    {
      int v36 = *(_DWORD *)(v33 + 28);
      BOOL v37 = v36 < (int)a2;
      if (v36 >= (int)a2) {
        uint64_t v38 = (uint64_t *)v33;
      }
      else {
        uint64_t v38 = (uint64_t *)(v33 + 8);
      }
      if (!v37) {
        uint64_t v35 = v33;
      }
      uint64_t v33 = *v38;
    }
    while (*v38);
    if (v35 != a1 + 136 && *(_DWORD *)(v35 + 28) <= (int)a2)
    {
      int v39 = 1;
      unsigned int v50 = *(_DWORD *)(v35 + 32) + 1;
      if (v50 > 0xC) {
        goto LABEL_49;
      }
      if (((1 << v50) & 0x1821) == 0)
      {
        int v51 = (isSimUnreadable | ~v34) & v18;
        if (*(_DWORD *)(v35 + 32) == 7) {
          int v39 = v51;
        }
        else {
          int v39 = 1;
        }
        goto LABEL_49;
      }
    }
  }
  int v39 = 0;
LABEL_49:
  uint64_t v40 = *(void *)(a1 + 160);
  if (!v40) {
    goto LABEL_59;
  }
  uint64_t v41 = a1 + 160;
  do
  {
    int v42 = *(_DWORD *)(v40 + 28);
    BOOL v43 = v42 < (int)a2;
    if (v42 >= (int)a2) {
      uint64_t v44 = (uint64_t *)v40;
    }
    else {
      uint64_t v44 = (uint64_t *)(v40 + 8);
    }
    if (!v43) {
      uint64_t v41 = v40;
    }
    uint64_t v40 = *v44;
  }
  while (*v44);
  if (v41 != a1 + 160 && *(_DWORD *)(v41 + 28) <= (int)a2) {
    BOOL v45 = *(unsigned __int8 *)(v41 + 32) != 0;
  }
  else {
LABEL_59:
  }
    BOOL v45 = 0;
  uint64_t v46 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v47 = asString();
    uint64_t v48 = "NOT ";
    if (v45) {
      uint64_t v48 = "";
    }
    *(_DWORD *)std::string __p = 136315394;
    *(void *)&__p[4] = v47;
    __int16 v55 = 2080;
    uint64_t v56 = v48;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Camped RAT is %s, CS is %sattached.", __p, 0x16u);
  }
  uint64_t v17 = v45 | v39;
  if ((v15 & 1) == 0) {
    goto LABEL_65;
  }
  return v17;
}

void sub_10035C85C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10035C8D4(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)unsigned int v27 = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)v27);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_7:
    BOOL v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unsigned int v27 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "!! Can't find RegistrationController. Bailing...", v27, 2u);
    }
    BOOL v15 = 0;
    if (v13) {
      return v15;
    }
LABEL_29:
    sub_10004D2C8(v11);
    return v15;
  }
LABEL_13:
  uint64_t v16 = *(void *)(a1 + 136);
  if (!v16) {
    goto LABEL_23;
  }
  uint64_t v17 = a1 + 136;
  do
  {
    int v18 = *(_DWORD *)(v16 + 28);
    BOOL v19 = v18 < (int)a2;
    if (v18 >= (int)a2) {
      long long v20 = (uint64_t *)v16;
    }
    else {
      long long v20 = (uint64_t *)(v16 + 8);
    }
    if (!v19) {
      uint64_t v17 = v16;
    }
    uint64_t v16 = *v20;
  }
  while (*v20);
  if (v17 != a1 + 136 && *(_DWORD *)(v17 + 28) <= (int)a2) {
    int v21 = *(_DWORD *)(v17 + 32);
  }
  else {
LABEL_23:
  }
    int v21 = 11;
  int v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12 + 448))(v12, a2, 10);
  uint64_t v23 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = asString();
    int v25 = "false";
    if (v22) {
      int v25 = "true";
    }
    *(_DWORD *)unsigned int v27 = 136315394;
    *(void *)&v27[4] = v24;
    __int16 v28 = 2080;
    uint64_t v29 = v25;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I isNRAttached: Camped RAT is %s, limited service is %s.", v27, 0x16u);
  }
  BOOL v15 = v21 == 10;
  if ((v13 & 1) == 0) {
    goto LABEL_29;
  }
  return v15;
}

void sub_10035CB6C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10035CBA0(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)unsigned int v27 = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)v27);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_7:
    BOOL v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unsigned int v27 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "!! Can't find RegistrationController. Bailing...", v27, 2u);
    }
    uint64_t v15 = 0;
    if (v13) {
      return v15;
    }
LABEL_32:
    sub_10004D2C8(v11);
    return v15;
  }
LABEL_13:
  uint64_t v16 = *(void *)(a1 + 136);
  if (!v16) {
    goto LABEL_23;
  }
  uint64_t v17 = a1 + 136;
  do
  {
    int v18 = *(_DWORD *)(v16 + 28);
    BOOL v19 = v18 < (int)a2;
    if (v18 >= (int)a2) {
      long long v20 = (uint64_t *)v16;
    }
    else {
      long long v20 = (uint64_t *)(v16 + 8);
    }
    if (!v19) {
      uint64_t v17 = v16;
    }
    uint64_t v16 = *v20;
  }
  while (*v20);
  if (v17 != a1 + 136 && *(_DWORD *)(v17 + 28) <= (int)a2) {
    int v21 = *(_DWORD *)(v17 + 32);
  }
  else {
LABEL_23:
  }
    int v21 = 11;
  unsigned int v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12 + 448))(v12, a2, 7);
  uint64_t v23 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = asString();
    int v25 = "false";
    if (v22) {
      int v25 = "true";
    }
    *(_DWORD *)unsigned int v27 = 136315394;
    *(void *)&v27[4] = v24;
    __int16 v28 = 2080;
    uint64_t v29 = v25;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I isLTEAttached: Camped RAT is %s, limited service is %s.", v27, 0x16u);
  }
  if (v21 == 7) {
    uint64_t v15 = 1;
  }
  else {
    uint64_t v15 = v22;
  }
  if ((v13 & 1) == 0) {
    goto LABEL_32;
  }
  return v15;
}

void sub_10035CE38(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10035CE6C(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, &v18);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
LABEL_13:
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 432))(v12, a2);
      if (v13) {
        return v15;
      }
LABEL_14:
      sub_10004D2C8(v11);
      return v15;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (v12) {
    goto LABEL_13;
  }
LABEL_7:
  BOOL v14 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v17 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "!! Can't find RegistrationController. Bailing...", v17, 2u);
  }
  uint64_t v15 = 0;
  if ((v13 & 1) == 0) {
    goto LABEL_14;
  }
  return v15;
}

void sub_10035CFE0(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10035CFFC(uint64_t a1, int a2)
{
  void (***v17)(uint8_t *__return_ptr, void, uint64_t);
  char v18;
  NSObject *v19;
  void *v20;
  int v21;
  NSObject *v22;
  void *v23;
  void *v24;
  BOOL v25;
  uint64_t v26;
  BOOL v27;
  const char *v28;
  const char *v29;
  uint8_t v30[4];
  const char *v31;
  uint8_t buf[24];

  unint64_t v6 = *(_DWORD **)(a1 + 200);
  uint64_t v5 = *(_DWORD **)(a1 + 208);
  if (v6 != v5)
  {
    while (*v6 != a2)
    {
      v6 += 42;
      if (v6 == v5) {
        goto LABEL_8;
      }
    }
  }
  if (v6 == v5 || (subscriber::isSimAbsent() & 1) != 0 || subscriber::isSimUnreadable())
  {
LABEL_8:
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I SIM %s is not readable or absent - enabling VoNR by default", buf, 0xCu);
    }
    char v2 = 1;
    return v2 & 1;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  unsigned int v10 = ServiceMap;
  if (v11 < 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (v15)
  {
    uint64_t v17 = (void (***)(uint8_t *__return_ptr, void, uint64_t))v15[3];
    uint64_t v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      unint64_t v18 = 0;
      if (!v17) {
        goto LABEL_18;
      }
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  uint64_t v16 = 0;
  unint64_t v18 = 1;
  if (!v17)
  {
LABEL_18:
    BOOL v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
    }
    goto LABEL_49;
  }
LABEL_22:
  long long v20 = *(void **)(a1 + 224);
  if (v20 != (void *)(a1 + 232))
  {
    do
    {
      *(_OWORD *)std::string buf = 0uLL;
      (**v17)(buf, v17, (uint64_t)(v20 + 4));
      if (*(void *)buf)
      {
        if (*(unsigned char *)(*(void *)buf + 49) || *(_DWORD *)(*(void *)buf + 52) != a2)
        {
          int v21 = 0;
        }
        else
        {
          char v2 = v20[7] & (*((unsigned char *)v20 + 64) != 0);
          int v21 = 1;
        }
      }
      else
      {
        unsigned int v22 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          uint64_t v26 = *((unsigned __int8 *)v20 + 55);
          unsigned int v27 = (v26 & 0x80u) != 0;
          if ((v26 & 0x80u) != 0) {
            uint64_t v26 = v20[5];
          }
          if (v27) {
            __int16 v28 = (const char *)v20[4];
          }
          else {
            __int16 v28 = (const char *)(v20 + 4);
          }
          int v25 = v26 == 0;
          uint64_t v29 = "<invalid>";
          if (!v25) {
            uint64_t v29 = v28;
          }
          *(_DWORD *)uint64_t v30 = 136315138;
          char v31 = v29;
          _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "personalityInfo for personalityID: %s is not found!", v30, 0xCu);
        }
        int v21 = 7;
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (v21 != 7 && v21) {
        goto LABEL_50;
      }
      uint64_t v23 = (void *)v20[1];
      if (v23)
      {
        do
        {
          uint64_t v24 = v23;
          uint64_t v23 = (void *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          uint64_t v24 = (void *)v20[2];
          int v25 = *v24 == (void)v20;
          long long v20 = v24;
        }
        while (!v25);
      }
      long long v20 = v24;
    }
    while (v24 != (void *)(a1 + 232));
  }
LABEL_49:
  char v2 = 0;
LABEL_50:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  return v2 & 1;
}

void sub_10035D360(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10035D388(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 184);
  uint64_t v2 = a1 + 184;
  uint64_t v3 = v4;
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v2;
  do
  {
    int v6 = *(_DWORD *)(v3 + 28);
    BOOL v7 = v6 < a2;
    if (v6 >= a2) {
      uint64_t v8 = (uint64_t *)v3;
    }
    else {
      uint64_t v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  return v5 != v2 && *(_DWORD *)(v5 + 28) <= a2 && (*(_DWORD *)(v5 + 32) & 0xFFFFFFFE) == 4;
}

uint64_t sub_10035D3E0(uint64_t a1, char a2, int a3)
{
  char v6 = a2;
  int v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *, int *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void *sub_10035D43C(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    char v6 = result;
    uint64_t result = sub_10005CCE8(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_10035D49C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10035D4B8(void *a1@<X1>, NSObject **a2@<X2>, void *a3@<X8>)
{
  char v6 = operator new(0x110uLL);
  sub_10035D534(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  sub_1000B3BC8((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_10035D520(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10035D534(void *a1, void *a2, NSObject **a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019BC1E8;
  emergency::BBSearchDriver::BBSearchDriver((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_10035D57C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_10035D590(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019BC1E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10035D5B0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019BC1E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10035D604(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10035D630()
{
}

uint64_t sub_10035D644(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_10035D650(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10005DF6C(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_10035D690(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void *sub_10035D6A8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10035D730()
{
}

void *sub_10035D744(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019BC278;
  result[1] = v3;
  return result;
}

uint64_t sub_10035D78C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019BC278;
  a2[1] = v2;
  return result;
}

void sub_10035D7B8(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_10035D7C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10035D800()
{
}

void sub_10035D810()
{
}

void *sub_10035D824(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019BC2F8;
  result[1] = v3;
  return result;
}

uint64_t sub_10035D86C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019BC2F8;
  a2[1] = v2;
  return result;
}

void sub_10035D898(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_10035D8A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10035D8E0()
{
}

void sub_10035D8F0()
{
}

void *sub_10035D904(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019BC378;
  result[1] = v3;
  return result;
}

uint64_t sub_10035D94C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019BC378;
  a2[1] = v2;
  return result;
}

void sub_10035D978(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_10035D980(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10035D9C0()
{
}

void sub_10035D9D0()
{
}

__n128 sub_10035D9E4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019BC3F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10035DA38(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019BC3F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10035DA70(void *a1)
{
  uint64_t v6 = 0;
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, uint64_t *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_10035DAF0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10035DB30()
{
}

void sub_10035DB40()
{
}

__n128 sub_10035DB54(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019BC478;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10035DBA8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019BC478;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10035DBE0(void *a1)
{
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, 0);
}

uint64_t sub_10035DC60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10035DCA0()
{
}

void sub_10035DCB0()
{
}

__n128 sub_10035DCC4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019BC4F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10035DD18(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019BC4F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10035DD50(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10035DD98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10035DDD8()
{
}

void *sub_10035DDE4(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    int v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_10035E04C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void *sub_10035E058(void *a1)
{
  *a1 = off_1019BC578;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_10035E0A8(void *a1)
{
  *a1 = off_1019BC578;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  operator delete();
}

void *sub_10035E118(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(const void **)(a1 + 16);
  void *v2 = off_1019BC578;
  v2[1] = v4;
  v2[3] = 0;
  v2[4] = 0;
  v2[2] = 0;
  sub_10035D43C(v2 + 2, v3, *(void *)(a1 + 24), (uint64_t)(*(void *)(a1 + 24) - (void)v3) >> 2);
  *((_WORD *)v2 + 20) = *(_WORD *)(a1 + 40);
  return v2;
}

void sub_10035E188(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10035E19C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)a2 = off_1019BC578;
  *(void *)(a2 + 8) = v4;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 16) = 0;
  __n128 result = sub_10035D43C((void *)(a2 + 16), *(const void **)(a1 + 16), *(void *)(a1 + 24), (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 2);
  *(_WORD *)(a2 + 40) = *(_WORD *)(a1 + 40);
  return result;
}

void sub_10035E204(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    *(void *)(a1 + 24) = v2;
    operator delete(v2);
  }
}

void sub_10035E21C(void *__p)
{
  uint64_t v2 = (void *)__p[2];
  if (v2)
  {
    __p[3] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

void sub_10035E260(uint64_t a1)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  sub_10035D43C(&v2, *(const void **)(a1 + 16), *(void *)(a1 + 24), (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 2);
  __int16 v5 = *(_WORD *)(a1 + 40);
  int v6 = 0;
  xpc_object_t v10 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/events/e911_state_enter");
  xpc_object_t object = v10;
  xpc_object_t v10 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  xpc_object_t object = 0;
  if (v9 < 0) {
    operator delete(__p);
  }
  xpc_release(v10);
  if (v2)
  {
    uint64_t v3 = v2;
    operator delete(v2);
  }
}

void sub_10035E334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  xpc_release(object);
  if (a20 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v20 - 24));
  if (a10) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10035E390(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10035E3D0()
{
}

void *sub_10035E3DC(void *a1)
{
  *a1 = off_1019BC5F8;
  sub_10003B34C(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10035E42C(void *a1)
{
  *a1 = off_1019BC5F8;
  sub_10003B34C(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_10035E49C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_1019BC5F8;
  sub_10035E79C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10035E4F0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10035E504(uint64_t a1, void *a2)
{
  *a2 = off_1019BC5F8;
  return sub_10035E79C((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10035E530(uint64_t a1)
{
}

void sub_10035E538(void *a1)
{
  sub_100211E94((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10035E574(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = a1[2];
      if (v7)
      {
        size_t v8 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          char v9 = "succeeded";
          if (!v4) {
            char v9 = "failed";
          }
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v12 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Temporary 2G enablement %s. Triggering E911 state enter", buf, 0xCu);
        }
        sub_1000F0058((uint64_t)buf, (uint64_t)(a1 + 4));
        xpc_object_t v10 = *(std::__shared_weak_count **)(v7 + 16);
        if (v10)
        {
          if (std::__shared_weak_count::lock(v10)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10035E724(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10035E750(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10035E790()
{
}

uint64_t sub_10035E79C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  sub_1000F0058(a1 + 24, a2 + 24);
  return a1;
}

void sub_10035E7EC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_10035E804(void **a1)
{
  uint64_t v1 = *a1;
  int v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = v1[3];
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  sub_10035E890(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_10035E874(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void **sub_10035E890(void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_10003B34C(v2);
    operator delete();
  }
  return a1;
}

void *sub_10035E8D8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10035E960(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_10035EA00(char a1, std::string *a2)
{
  if ((a1 & 0x80) == 0) {
    return 0;
  }
  uint64_t v6 = sub_10035EAC0();
  uint64_t v9 = *(void *)(v6 + 8);
  uint64_t v7 = v6 + 8;
  uint64_t v8 = v9;
  if (!v9) {
    return 0;
  }
  unsigned int v10 = a1 & 0x7F;
  uint64_t v11 = v7;
  do
  {
    unsigned int v12 = *(_DWORD *)(v8 + 32);
    BOOL v13 = v12 >= v10;
    if (v12 >= v10) {
      unsigned int v14 = (uint64_t *)v8;
    }
    else {
      unsigned int v14 = (uint64_t *)(v8 + 8);
    }
    if (v13) {
      uint64_t v11 = v8;
    }
    uint64_t v8 = *v14;
  }
  while (*v14);
  if (v11 == v7 || *(_DWORD *)(v11 + 32) > v10) {
    return 0;
  }
  sub_10003ED78(a2, *(char **)(v11 + 40));
  uint64_t v2 = 1;
  std::string::append(a2, "/", 1uLL);
  uint64_t v15 = *(const char **)(v11 + 48);
  size_t v16 = strlen(v15);
  std::string::append(a2, v15, v16);
  return v2;
}

uint64_t sub_10035EAC0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13CC8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13CC8))
  {
    operator new();
  }
  return qword_101B13CC0;
}

void sub_10035EB94()
{
}

uint64_t sub_10035EBCC(char *a1)
{
  if (!a1) {
    return 0;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CC30, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0CC30))
  {
    operator new();
  }
  if (!*(void *)(qword_101B0CC28 + 24))
  {
    uint64_t v8 = (void *)sub_10035EAC0();
    uint64_t v9 = (void *)*v8;
    __int16 v54 = v8 + 1;
    if ((void *)*v8 != v8 + 1)
    {
      while (1)
      {
        memset(&v57, 0, sizeof(v57));
        sub_100058DB0(&v57, (char *)v9[5]);
        std::string::push_back(&v57, 47);
        size_t v10 = strlen((const char *)v9[6]);
        std::string::append(&v57, (const std::string::value_type *)v9[6], v10);
        uint64_t v11 = qword_101B0CC28;
        if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__p, v57.__r_.__value_.__l.__data_, v57.__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = v57;
        }
        int v56 = *((_DWORD *)v9 + 8);
        unint64_t v12 = sub_100206390(v11 + 24, (uint64_t)&__p);
        unint64_t v13 = v12;
        unint64_t v14 = *(void *)(v11 + 8);
        if (v14)
        {
          uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
          v15.i16[0] = vaddlv_u8(v15);
          unint64_t v16 = v15.u32[0];
          if (v15.u32[0] > 1uLL)
          {
            unint64_t v17 = v12;
            if (v12 >= v14) {
              unint64_t v17 = v12 % v14;
            }
          }
          else
          {
            unint64_t v17 = (v14 - 1) & v12;
          }
          unint64_t v18 = *(unsigned __int8 ***)(*(void *)v11 + 8 * v17);
          if (v18)
          {
            for (uint64_t i = *v18; i; uint64_t i = *(unsigned __int8 **)i)
            {
              unint64_t v20 = *((void *)i + 1);
              if (v20 == v13)
              {
                if (sub_1000609C0(v11 + 32, i + 16, (unsigned __int8 *)&__p)) {
                  goto LABEL_87;
                }
              }
              else
              {
                if (v16 > 1)
                {
                  if (v20 >= v14) {
                    v20 %= v14;
                  }
                }
                else
                {
                  v20 &= v14 - 1;
                }
                if (v20 != v17) {
                  break;
                }
              }
            }
          }
        }
        else
        {
          unint64_t v17 = 0;
        }
        int v21 = (char *)operator new(0x30uLL);
        *(void *)int v21 = 0;
        *((void *)v21 + 1) = v13;
        unsigned int v22 = v21 + 16;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          sub_10004FC84(v22, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
        }
        else
        {
          *(_OWORD *)unsigned int v22 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *((void *)v21 + 4) = *((void *)&__p.__r_.__value_.__l + 2);
        }
        *((_DWORD *)v21 + 10) = v56;
        float v23 = (float)(unint64_t)(*(void *)(v11 + 24) + 1);
        float v24 = *(float *)(v11 + 32);
        if (!v14 || (float)(v24 * (float)v14) < v23) {
          break;
        }
LABEL_77:
        uint64_t v40 = *(void **)v11;
        uint64_t v41 = *(void **)(*(void *)v11 + 8 * v17);
        if (v41)
        {
          *(void *)int v21 = *v41;
        }
        else
        {
          *(void *)int v21 = *(void *)(v11 + 16);
          *(void *)(v11 + 16) = v21;
          v40[v17] = v11 + 16;
          if (!*(void *)v21) {
            goto LABEL_86;
          }
          unint64_t v42 = *(void *)(*(void *)v21 + 8);
          if ((v14 & (v14 - 1)) != 0)
          {
            if (v42 >= v14) {
              v42 %= v14;
            }
          }
          else
          {
            v42 &= v14 - 1;
          }
          uint64_t v41 = (void *)(*(void *)v11 + 8 * v42);
        }
        void *v41 = v21;
LABEL_86:
        ++*(void *)(v11 + 24);
LABEL_87:
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v57.__r_.__value_.__l.__data_);
        }
        BOOL v43 = (void *)v9[1];
        if (v43)
        {
          do
          {
            uint64_t v44 = v43;
            BOOL v43 = (void *)*v43;
          }
          while (v43);
        }
        else
        {
          do
          {
            uint64_t v44 = (void *)v9[2];
            BOOL v45 = *v44 == (void)v9;
            uint64_t v9 = v44;
          }
          while (!v45);
        }
        uint64_t v9 = v44;
        if (v44 == v54) {
          goto LABEL_4;
        }
      }
      BOOL v25 = (v14 & (v14 - 1)) != 0;
      if (v14 < 3) {
        BOOL v25 = 1;
      }
      unint64_t v26 = v25 | (2 * v14);
      unint64_t v27 = vcvtps_u32_f32(v23 / v24);
      if (v26 <= v27) {
        int8x8_t prime = (int8x8_t)v27;
      }
      else {
        int8x8_t prime = (int8x8_t)v26;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      }
      unint64_t v14 = *(void *)(v11 + 8);
      if (*(void *)&prime > v14) {
        goto LABEL_43;
      }
      if (*(void *)&prime < v14)
      {
        unint64_t v35 = vcvtps_u32_f32((float)*(unint64_t *)(v11 + 24) / *(float *)(v11 + 32));
        if (v14 < 3 || (uint8x8_t v36 = (uint8x8_t)vcnt_s8((int8x8_t)v14), v36.i16[0] = vaddlv_u8(v36), v36.u32[0] > 1uLL))
        {
          unint64_t v35 = std::__next_prime(v35);
        }
        else
        {
          uint64_t v37 = 1 << -(char)__clz(v35 - 1);
          if (v35 >= 2) {
            unint64_t v35 = v37;
          }
        }
        if (*(void *)&prime <= v35) {
          int8x8_t prime = (int8x8_t)v35;
        }
        if (*(void *)&prime >= v14)
        {
          unint64_t v14 = *(void *)(v11 + 8);
        }
        else
        {
          if (prime)
          {
LABEL_43:
            if (*(void *)&prime >> 61) {
              sub_10006A7CC();
            }
            uint64_t v29 = operator new(8 * *(void *)&prime);
            uint64_t v30 = *(void **)v11;
            *(void *)uint64_t v11 = v29;
            if (v30) {
              operator delete(v30);
            }
            uint64_t v31 = 0;
            *(int8x8_t *)(v11 + 8) = prime;
            do
              *(void *)(*(void *)v11 + 8 * v31++) = 0;
            while (*(void *)&prime != v31);
            uint64_t v32 = *(void **)(v11 + 16);
            if (v32)
            {
              unint64_t v33 = v32[1];
              uint8x8_t v34 = (uint8x8_t)vcnt_s8(prime);
              v34.i16[0] = vaddlv_u8(v34);
              if (v34.u32[0] > 1uLL)
              {
                if (v33 >= *(void *)&prime) {
                  v33 %= *(void *)&prime;
                }
              }
              else
              {
                v33 &= *(void *)&prime - 1;
              }
              *(void *)(*(void *)v11 + 8 * v33) = v11 + 16;
              uint64_t v38 = (void *)*v32;
              if (*v32)
              {
                do
                {
                  unint64_t v39 = v38[1];
                  if (v34.u32[0] > 1uLL)
                  {
                    if (v39 >= *(void *)&prime) {
                      v39 %= *(void *)&prime;
                    }
                  }
                  else
                  {
                    v39 &= *(void *)&prime - 1;
                  }
                  if (v39 != v33)
                  {
                    if (!*(void *)(*(void *)v11 + 8 * v39))
                    {
                      *(void *)(*(void *)v11 + 8 * v39) = v32;
                      goto LABEL_68;
                    }
                    *uint64_t v32 = *v38;
                    *uint64_t v38 = **(void **)(*(void *)v11 + 8 * v39);
                    **(void **)(*(void *)v11 + 8 * v39) = v38;
                    uint64_t v38 = v32;
                  }
                  unint64_t v39 = v33;
LABEL_68:
                  uint64_t v32 = v38;
                  uint64_t v38 = (void *)*v38;
                  unint64_t v33 = v39;
                }
                while (v38);
              }
            }
            unint64_t v14 = (unint64_t)prime;
            goto LABEL_72;
          }
          uint64_t v46 = *(void **)v11;
          *(void *)uint64_t v11 = 0;
          if (v46) {
            operator delete(v46);
          }
          unint64_t v14 = 0;
          *(void *)(v11 + 8) = 0;
        }
      }
LABEL_72:
      if ((v14 & (v14 - 1)) != 0)
      {
        if (v13 >= v14) {
          unint64_t v17 = v13 % v14;
        }
        else {
          unint64_t v17 = v13;
        }
      }
      else
      {
        unint64_t v17 = (v14 - 1) & v13;
      }
      goto LABEL_77;
    }
  }
LABEL_4:
  uint64_t v1 = (void *)qword_101B0CC28;
  sub_100058DB0(&__p, a1);
  unint64_t v2 = sub_100206390((uint64_t)(v1 + 3), (uint64_t)&__p);
  int8x8_t v3 = (int8x8_t)v1[1];
  if (!*(void *)&v3) {
    goto LABEL_122;
  }
  unint64_t v4 = v2;
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  unint64_t v6 = v5.u32[0];
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v7 = v2;
    if (v2 >= *(void *)&v3) {
      unint64_t v7 = v2 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v3 - 1) & v2;
  }
  uint64_t v47 = *(unsigned __int8 ***)(*v1 + 8 * v7);
  if (v47)
  {
    uint64_t v48 = *v47;
    if (*v47)
    {
      uint64_t v49 = (uint64_t)(v1 + 4);
      do
      {
        unint64_t v50 = *((void *)v48 + 1);
        if (v50 == v4)
        {
          if (sub_1000609C0(v49, v48 + 16, (unsigned __int8 *)&__p)) {
            break;
          }
        }
        else
        {
          if (v6 > 1)
          {
            if (v50 >= *(void *)&v3) {
              v50 %= *(void *)&v3;
            }
          }
          else
          {
            v50 &= *(void *)&v3 - 1;
          }
          if (v50 != v7) {
            goto LABEL_122;
          }
        }
        uint64_t v48 = *(unsigned __int8 **)v48;
      }
      while (v48);
    }
  }
  else
  {
LABEL_122:
    uint64_t v48 = 0;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v48) {
      return (v48[40] | 0x80);
    }
    return 0;
  }
  if (!v48) {
    return 0;
  }
  return (v48[40] | 0x80);
}

void sub_10035F25C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
}

void sub_10035F2D0(char *a1@<X0>, void *a2@<X8>)
{
  if (a1) {
    int8x8_t v3 = a1;
  }
  else {
    int8x8_t v3 = "";
  }
  unint64_t v4 = strchr(v3, 59);
  memset(&__dst, 0, sizeof(__dst));
  memset(__s1, 0, sizeof(__s1));
  if (v4)
  {
    uint8x8_t v5 = v4;
    sub_10003ECB8(&__dst, v3, ((_BYTE)v4 - (_BYTE)v3));
    unint64_t v6 = v5 + 1;
    p_dst = (std::string *)__s1;
  }
  else
  {
    p_dst = &__dst;
    unint64_t v6 = v3;
  }
  sub_10003ED78(p_dst, v6);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v8 = &__dst;
  }
  else {
    uint64_t v8 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  int v9 = sub_10035EBCC((char *)v8);
  *a2 = 0;
  if (v9) {
    operator new();
  }
  size_t v10 = strchr(v3, 47);
  if (v10)
  {
    memset(__p, 0, sizeof(__p));
    sub_1000D95C8(__p, v3, ((_BYTE)v10 - (_BYTE)v3));
    operator new();
  }
  operator new();
}

void sub_10035F4A4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
}

uint64_t sub_10035F59C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13CA8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13CA8))
  {
    operator new();
  }
  return *(void *)qword_101B13CA0;
}

void sub_10035F624()
{
}

uint64_t sub_10035F65C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13CB8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13CB8))
  {
    operator new();
  }
  return *(void *)qword_101B13CB0;
}

void sub_10035F6E4()
{
}

uint64_t sub_10035F71C(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v17 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  *(_OWORD *)std::string __p = 0u;
  memset(v13, 0, sizeof(v13));
  sub_10004DE24((uint64_t)v13);
  unint64_t v4 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v5 = strlen(v4);
  unint64_t v6 = sub_10004B96C(v13, (uint64_t)v4, v5);
  unint64_t v7 = sub_10004B96C(v6, (uint64_t)"/", 1);
  uint64_t v8 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  size_t v9 = strlen(v8);
  sub_10004B96C(v7, (uint64_t)v8, v9);
  sub_10004BC98((uint64_t)v13 + 8, &v11);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = v11;
  *(void *)(a2 + 16) = v12;
  sub_10095B4B0(a1 + 8, (std::string *)a2);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return 1;
}

void sub_10035F944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000C937C((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL sub_10035F95C(uint64_t a1, const char *a2, const char *a3)
{
  unint64_t v6 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (strcasecmp(v6, a2)) {
    return 0;
  }
  uint64_t v8 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  return strcasecmp(v8, a3) == 0;
}

BOOL sub_10035F9FC(uint64_t a1)
{
  if (sub_10035F95C(a1, "application", "vnd.wap.multipart.mixed")
    || sub_10035F95C(a1, "application", "vnd.wap.multipart.related"))
  {
    return 1;
  }

  return sub_10035F95C(a1, "application", "vnd.wap.multipart.alternative");
}

uint64_t sub_10035FA84(uint64_t a1, unsigned int a2)
{
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 72) = 1065353216;
  *(void *)(a1 + 8) = off_101A1EBD0;
  *(void *)a1 = off_1019BC6B8;
  uint64_t v4 = sub_10035EAC0();
  uint64_t v7 = *(void *)(v4 + 8);
  uint64_t v5 = v4 + 8;
  uint64_t v6 = v7;
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v8 = v5;
  do
  {
    unsigned int v9 = *(_DWORD *)(v6 + 32);
    BOOL v10 = v9 >= a2;
    if (v9 >= a2) {
      long long v11 = (uint64_t *)v6;
    }
    else {
      long long v11 = (uint64_t *)(v6 + 8);
    }
    if (v10) {
      uint64_t v8 = v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if (v8 == v5 || *(_DWORD *)(v8 + 32) > a2) {
LABEL_12:
  }
    uint64_t v8 = v5;
  if (v8 == sub_10035EAC0() + 8) {
    unsigned int v12 = 0;
  }
  else {
    unsigned int v12 = a2;
  }
  *(_DWORD *)(a1 + 80) = v12;
  return a1;
}

void sub_10035FB60(_Unwind_Exception *a1)
{
  *uint64_t v1 = off_1019BC678;
  sub_100CC9A2C(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10035FB94(uint64_t a1)
{
  uint64_t v2 = sub_10035EAC0();
  uint64_t v5 = *(void *)(v2 + 8);
  uint64_t v3 = v2 + 8;
  uint64_t v4 = v5;
  if (!v5) {
    return 0;
  }
  unsigned int v6 = *(_DWORD *)(a1 + 80);
  uint64_t v7 = v3;
  do
  {
    unsigned int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 >= v6;
    if (v8 >= v6) {
      BOOL v10 = (uint64_t *)v4;
    }
    else {
      BOOL v10 = (uint64_t *)(v4 + 8);
    }
    if (v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }
  while (*v10);
  if (v7 != v3 && v6 >= *(_DWORD *)(v7 + 32)) {
    return *(void *)(v7 + 40);
  }
  else {
    return 0;
  }
}

uint64_t sub_10035FC04(uint64_t a1)
{
  uint64_t v2 = sub_10035EAC0();
  uint64_t v5 = *(void *)(v2 + 8);
  uint64_t v3 = v2 + 8;
  uint64_t v4 = v5;
  if (!v5) {
    return 0;
  }
  unsigned int v6 = *(_DWORD *)(a1 + 80);
  uint64_t v7 = v3;
  do
  {
    unsigned int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 >= v6;
    if (v8 >= v6) {
      BOOL v10 = (uint64_t *)v4;
    }
    else {
      BOOL v10 = (uint64_t *)(v4 + 8);
    }
    if (v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }
  while (*v10);
  if (v7 != v3 && v6 >= *(_DWORD *)(v7 + 32)) {
    return *(void *)(v7 + 48);
  }
  else {
    return 0;
  }
}

uint64_t sub_10035FC74(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 24) == *(void *)(a1 + 16))
  {
    std::string::push_back((std::string *)(a2 + 8), *(unsigned char *)(a1 + 80) | 0x80);
  }
  else
  {
    *(_OWORD *)std::string __p = 0u;
    long long v9 = 0u;
    LODWORD(__p[0]) = *(_DWORD *)a2;
    uint64_t v10 = 0;
    __p[1] = 0;
    long long v9 = 0uLL;
    sub_10078E66C((uint64_t)__p, *(_DWORD *)(a1 + 80));
    sub_10078E9B4((uint64_t)__p, a1 + 8);
    if (v9 >= 0) {
      unsigned int v4 = HIBYTE(v9);
    }
    else {
      unsigned int v4 = v9;
    }
    sub_10078E718(a2, v4);
    if (v9 >= 0) {
      uint64_t v5 = (const std::string::value_type *)&__p[1];
    }
    else {
      uint64_t v5 = (const std::string::value_type *)__p[1];
    }
    if (v9 >= 0) {
      std::string::size_type v6 = HIBYTE(v9);
    }
    else {
      std::string::size_type v6 = v9;
    }
    std::string::append((std::string *)(a2 + 8), v5, v6);
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[1]);
    }
  }
  return 1;
}

void sub_10035FD54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10035FD74()
{
}

void sub_10035FDBC()
{
}

uint64_t sub_10035FDE0(char *a1)
{
  uint64_t v2 = strchr(a1, 47);
  if (v2)
  {
    memset(__p, 0, sizeof(__p));
    sub_1000D95C8(__p, a1, ((_BYTE)v2 - (_BYTE)a1));
    operator new();
  }
  return 0;
}

void sub_10035FE90(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t sub_10035FECC(uint64_t a1, char *a2, char *a3)
{
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 72) = 1065353216;
  *(void *)(a1 + 8) = off_101A1EBD0;
  *(void *)a1 = off_1019BC6F8;
  uint64_t v5 = (unsigned char *)(a1 + 80);
  if (!a2) {
    a2 = "";
  }
  sub_100058DB0((void *)(a1 + 80), a2);
  if (a3) {
    std::string::size_type v6 = a3;
  }
  else {
    std::string::size_type v6 = "";
  }
  sub_100058DB0((void *)(a1 + 104), v6);
  if (*(char *)(a1 + 103) < 0)
  {
    unsigned int v8 = *(unsigned char **)(a1 + 80);
    uint64_t v7 = &v8[*(void *)(a1 + 88)];
  }
  else
  {
    uint64_t v7 = &v5[*(unsigned __int8 *)(a1 + 103)];
    unsigned int v8 = v5;
  }
  while (v8 != v7)
  {
    unsigned char *v8 = __tolower((char)*v8);
    ++v8;
  }
  if (*(char *)(a1 + 127) < 0)
  {
    uint64_t v10 = *(unsigned char **)(a1 + 104);
    uint64_t v9 = (uint64_t)&v10[*(void *)(a1 + 112)];
  }
  else
  {
    uint64_t v9 = a1 + 104 + *(unsigned __int8 *)(a1 + 127);
    uint64_t v10 = (unsigned char *)(a1 + 104);
  }
  while (v10 != (unsigned char *)v9)
  {
    *uint64_t v10 = __tolower((char)*v10);
    ++v10;
  }
  return a1;
}

void sub_10035FFF8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 103) < 0) {
    operator delete(*v3);
  }
  *(void *)uint64_t v1 = off_1019BC678;
  sub_100CC9A2C(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10036005C(uint64_t a1)
{
  uint64_t result = a1 + 80;
  if (*(char *)(a1 + 103) < 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t sub_100360078(uint64_t a1)
{
  uint64_t result = a1 + 104;
  if (*(char *)(a1 + 127) < 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t sub_100360094(uint64_t a1, uint64_t a2)
{
  v24[0] = 0;
  v24[1] = 0;
  uint64_t v25 = 0;
  sub_10035F71C(a1, (uint64_t)v24);
  if (*(void *)(a1 + 24) == *(void *)(a1 + 16))
  {
    if (v25 >= 0) {
      long long v16 = v24;
    }
    else {
      long long v16 = (void **)v24[0];
    }
    sub_10078E554(a2, v16);
  }
  else
  {
    *(_OWORD *)long long v21 = 0u;
    long long v22 = 0u;
    LODWORD(v21[0]) = *(_DWORD *)a2;
    uint64_t v23 = 0;
    v21[1] = 0;
    long long v22 = 0uLL;
    if (*(char *)(a1 + 103) >= 0) {
      size_t v4 = *(unsigned __int8 *)(a1 + 103);
    }
    else {
      size_t v4 = *(void *)(a1 + 88);
    }
    memset(&v18, 0, sizeof(v18));
    uint64_t v5 = &v18;
    sub_1000C140C((uint64_t)&v18, v4 + 1);
    if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v5 = (std::string *)v18.__r_.__value_.__r.__words[0];
    }
    if (v4)
    {
      if (*(char *)(a1 + 103) >= 0) {
        std::string::size_type v6 = (const void *)(a1 + 80);
      }
      else {
        std::string::size_type v6 = *(const void **)(a1 + 80);
      }
      memmove(v5, v6, v4);
    }
    *(_WORD *)((char *)&v5->__r_.__value_.__l.__data_ + v4) = 47;
    int v7 = *(char *)(a1 + 127);
    if (v7 >= 0) {
      unsigned int v8 = (const std::string::value_type *)(a1 + 104);
    }
    else {
      unsigned int v8 = *(const std::string::value_type **)(a1 + 104);
    }
    if (v7 >= 0) {
      std::string::size_type v9 = *(unsigned __int8 *)(a1 + 127);
    }
    else {
      std::string::size_type v9 = *(void *)(a1 + 112);
    }
    uint64_t v10 = std::string::append(&v18, v8, v9);
    long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    int64_t v20 = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v18.__r_.__value_.__l.__data_);
    }
    if (v20 >= 0) {
      unsigned int v12 = __p;
    }
    else {
      unsigned int v12 = (void **)__p[0];
    }
    sub_10078E554((uint64_t)v21, v12);
    sub_10078E9B4((uint64_t)v21, a1 + 8);
    if (v22 >= 0) {
      unsigned int v13 = HIBYTE(v22);
    }
    else {
      unsigned int v13 = v22;
    }
    sub_10078E718(a2, v13);
    if (v22 >= 0) {
      unint64_t v14 = (const std::string::value_type *)&v21[1];
    }
    else {
      unint64_t v14 = (const std::string::value_type *)v21[1];
    }
    if (v22 >= 0) {
      std::string::size_type v15 = HIBYTE(v22);
    }
    else {
      std::string::size_type v15 = v22;
    }
    std::string::append((std::string *)(a2 + 8), v14, v15);
    if (SHIBYTE(v20) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v22) < 0) {
      operator delete(v21[1]);
    }
  }
  if (SHIBYTE(v25) < 0) {
    operator delete(v24[0]);
  }
  return 1;
}

void sub_10036027C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (*(char *)(v29 - 41) < 0) {
    operator delete(*(void **)(v29 - 64));
  }
  _Unwind_Resume(exception_object);
}

void sub_1003602E0()
{
}

void sub_100360348()
{
}

void *sub_10036036C(void *a1)
{
  *a1 = off_1019BC678;
  sub_100CC9A2C(a1 + 1);
  return a1;
}

void sub_1003603B0(void *a1)
{
  *a1 = off_1019BC678;
  sub_100CC9A2C(a1 + 1);

  operator delete();
}

uint64_t sub_100360414(uint64_t a1)
{
  *(void *)a1 = off_1019BC6F8;
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  *(void *)a1 = off_1019BC678;
  sub_100CC9A2C((void *)(a1 + 8));
  return a1;
}

void sub_100360498(uint64_t a1)
{
  *(void *)a1 = off_1019BC6F8;
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  *(void *)a1 = off_1019BC678;
  sub_100CC9A2C((void *)(a1 + 8));

  operator delete();
}

uint64_t **sub_10036053C(uint64_t **a1, unsigned int *a2, uint64_t a3)
{
  a1[1] = 0;
  size_t v4 = (uint64_t *)(a1 + 1);
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  if (a3)
  {
    uint64_t v5 = a2;
    std::string::size_type v6 = (int *)&a2[6 * a3];
    while (1)
    {
      int v7 = a1[1];
      unsigned int v8 = v4;
      if (*a1 != v4)
      {
        std::string::size_type v9 = a1[1];
        uint64_t v10 = v4;
        if (v7)
        {
          do
          {
            unsigned int v8 = v9;
            std::string::size_type v9 = (uint64_t *)v9[1];
          }
          while (v9);
        }
        else
        {
          do
          {
            unsigned int v8 = (uint64_t *)v10[2];
            BOOL v11 = *v8 == (void)v10;
            uint64_t v10 = v8;
          }
          while (v11);
        }
        unsigned int v12 = *v5;
        if (*((_DWORD *)v8 + 8) >= *v5) {
          break;
        }
      }
      if (v7) {
        unsigned int v13 = v8;
      }
      else {
        unsigned int v13 = v4;
      }
      if (v7) {
        unint64_t v14 = v8 + 1;
      }
      else {
        unint64_t v14 = v4;
      }
      if (!*v14) {
        goto LABEL_25;
      }
LABEL_28:
      v5 += 6;
      if (v5 == (unsigned int *)v6) {
        return a1;
      }
    }
    unint64_t v14 = v4;
    unsigned int v13 = v4;
    if (v7)
    {
      std::string::size_type v15 = a1[1];
      while (1)
      {
        while (1)
        {
          unsigned int v13 = v15;
          unsigned int v16 = *((_DWORD *)v15 + 8);
          if (v12 >= v16) {
            break;
          }
          std::string::size_type v15 = (uint64_t *)*v13;
          unint64_t v14 = v13;
          if (!*v13) {
            goto LABEL_25;
          }
        }
        if (v16 >= v12) {
          goto LABEL_28;
        }
        std::string::size_type v15 = (uint64_t *)v13[1];
        if (!v15)
        {
          unint64_t v14 = v13 + 1;
          break;
        }
      }
    }
LABEL_25:
    long long v17 = operator new(0x38uLL);
    long long v18 = *(_OWORD *)v5;
    v17[6] = *((void *)v5 + 2);
    *((_OWORD *)v17 + 2) = v18;
    void *v17 = 0;
    v17[1] = 0;
    v17[2] = v13;
    *unint64_t v14 = (uint64_t)v17;
    long long v19 = (uint64_t *)**a1;
    if (v19)
    {
      *a1 = v19;
      long long v17 = (void *)*v14;
    }
    sub_100046C90(a1[1], v17);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    goto LABEL_28;
  }
  return a1;
}

void sub_1003606A4(_Unwind_Exception *a1)
{
  sub_10005D144(v1);
  _Unwind_Resume(a1);
}

void sub_1003606B8(char a1, void **__p)
{
  if (a1)
  {
    if (*((char *)__p + 39) < 0) {
      operator delete(__p[2]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void sub_100360720(void *a1)
{
}

void sub_100360808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100360930((uint64_t)&a9);
  sub_100160AF8((atomic_uint **)(v9 + 32));
  *(void *)uint64_t v9 = off_1019AC298;
  sub_10000A740((atomic_uint **)(v9 + 16));
  _Unwind_Resume(a1);
}

atomic_uint **sub_10036086C(uint64_t a1, int a2, int a3, int a4, uint64_t a5)
{
  uint64_t v9 = (uint64_t *)sub_1003610D0((uint64_t *)(a1 + 8));

  return sub_100362414(v9, a2, a3, a4, a5);
}

long long *sub_1003608C8(long long *a1, long long *a2)
{
  if (a2 != a1)
  {
    long long v4 = *a2;
    *(void *)a2 = 0;
    *((void *)a2 + 1) = 0;
    long long v5 = *a1;
    *a1 = v4;
    *((void *)&v9 + 1) = *((void *)&v5 + 1);
    std::string::size_type v6 = sub_100160AF8((atomic_uint **)&v9 + 1);
    long long v7 = *a2;
    *(void *)a2 = 0;
    *((void *)a2 + 1) = 0;
    *((void *)&v9 + 1) = *((void *)&v7 + 1);
    sub_100160AF8(v6);
  }
  return a1;
}

uint64_t sub_100360930(uint64_t a1)
{
  sub_100360F80((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

void sub_100360970(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    __TUAssertTrigger();
  }
  long long v5 = 0u;
  long long v6 = 0u;
  v7[2] = 0;
  v7[3] = a2;
  v7[0] = (uint64_t)off_1019BD128 + 1;
  v7[1] = (uint64_t)sub_100360A70;
  sub_100362128(v7, (uint64_t *)&v6 + 1);
  sub_100360F80(v7);
  long long v4 = (uint64_t *)sub_1003610D0((uint64_t *)(a1 + 8));
  sub_100361114(v4);
}

void sub_100360A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100360A70(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

atomic_uint **sub_100360A94(uint64_t *a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 4) {
      uint64_t v10 = "???";
    }
    else {
      uint64_t v10 = off_1019BCEA0[a2];
    }
    *(_DWORD *)std::string buf = 136316162;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = a3;
    *(_WORD *)&unsigned char buf[24] = 1024;
    *(_DWORD *)&buf[26] = a4;
    *(_WORD *)&buf[30] = 2048;
    uint64_t v30 = a5;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Sending internal notification %s (%d) params={%d, %d, %p}", buf, 0x28u);
  }
  BOOL v11 = (uint64_t *)sub_1003610D0(a1 + 1);
  sub_100362414(v11, a2, a3, a4, a5);
  *(void *)&unsigned char buf[24] = 0;
  uint64_t v12 = a1[4];
  *(void *)std::string buf = a1[3];
  *(_OWORD *)&uint8_t buf[8] = (unint64_t)v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v12 + 12), 1u, memory_order_relaxed);
  }
  *(_OWORD *)&uint8_t buf[16] = 0uLL;
  long long v28 = 0uLL;
  sub_10000A740((atomic_uint **)&v28 + 1);
  uint64_t v13 = *(void *)&buf[8];
  uint64_t v26 = 0;
  unint64_t v27 = *(atomic_uint **)&buf[8];
  if (!*(void *)&buf[8])
  {
LABEL_22:
    long long v28 = 0uLL;
    operator new();
  }
  uint64_t v14 = *(unsigned int *)(*(void *)&buf[8] + 8);
  do
  {
    if (!v14)
    {
      unint64_t v27 = 0;
      goto LABEL_22;
    }
    uint64_t v15 = v14;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v13 + 8), (unsigned int *)&v15, v14 + 1, memory_order_relaxed, memory_order_relaxed);
    BOOL v16 = v15 == v14;
    uint64_t v14 = v15;
  }
  while (!v16);
  uint64_t v26 = *(void *)buf;
  if (!*(void *)buf) {
    goto LABEL_22;
  }
  long long v17 = (void *)sub_1001611B4(&v26);
  (*(void (**)(void *))(*v17 + 24))(v17);
  uint64_t v18 = v17[2];
  *((void *)&v25 + 1) = v18;
  if (!v18)
  {
LABEL_24:
    long long v28 = 0uLL;
    sub_10000A740((atomic_uint **)&v28 + 1);
    goto LABEL_25;
  }
  uint64_t v19 = *(unsigned int *)(v18 + 8);
  do
  {
    if (!v19)
    {
      *((void *)&v25 + 1) = 0;
      goto LABEL_24;
    }
    uint64_t v20 = v19;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v18 + 8), (unsigned int *)&v20, v19 + 1, memory_order_relaxed, memory_order_relaxed);
    BOOL v16 = v20 == v19;
    uint64_t v19 = v20;
  }
  while (!v16);
  *(void *)&long long v25 = v17[1];
  long long v28 = 0uLL;
  sub_10000A740((atomic_uint **)&v28 + 1);
  if (!(void)v25) {
LABEL_25:
  }
    operator new();
  (*(void (**)(void *))(*v17 + 32))(v17);
  long long v23 = v25;
  long long v25 = 0uLL;
  long long v24 = *(_OWORD *)&buf[16];
  *(_OWORD *)&uint8_t buf[16] = v23;
  long long v28 = v24;
  sub_10000A740((atomic_uint **)&v28 + 1);
  sub_10000A740((atomic_uint **)&v25 + 1);
  sub_10000A740(&v27);
  long long v21 = (uint64_t *)sub_1003610D0((uint64_t *)&unk_101B09E30);
  sub_100362414(v21, a2, a3, a4, a5);
  sub_10000A740((atomic_uint **)&buf[24]);
  return sub_100160AF8((atomic_uint **)&buf[8]);
}

void sub_100360EAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100360F80(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

void sub_100360FD8()
{
}

uint64_t sub_100360FEC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    operator delete();
  }
  return result;
}

uint64_t sub_10036100C()
{
  return 0;
}

uint64_t sub_100361014()
{
  return 0;
}

uint64_t sub_10036101C()
{
  return 0;
}

void sub_10036102C()
{
}

uint64_t sub_100361040(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 24))(*(void *)(a1 + 16));
}

uint64_t sub_100361060(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019BCFD0)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t sub_1003610A0(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t sub_1003610C8(uint64_t a1)
{
  return a1 + 24;
}

uint64_t sub_1003610D0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100361114(uint64_t *a1)
{
  memset(v3, 0, sizeof(v3));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v3, v2);
  sub_10036120C(a1, v3);
}

void sub_1003611DC(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10036120C(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_100361304(a1, a2);
}

void sub_1003612EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10000A740((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_100361304(uint64_t *a1, void *a2)
{
}

void sub_100361378()
{
}

uint64_t sub_10036139C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_1003613E0(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  if (!v2 || atomic_load_explicit((atomic_uint *volatile)(v2 + 8), memory_order_acquire) != 1) {
    operator new();
  }

  return sub_1003616FC(a1, a2, 1, 2);
}

void sub_1003614DC()
{
}

void sub_100361500(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_100213944(&v2, a2);
}

uint64_t sub_10036157C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t *sub_1003615C0(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  long long v22 = *a4;
  uint64_t v10 = (uint64_t *)sub_1002132EC(a1);
  uint64_t result = (uint64_t *)sub_100213ADC(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_10036139C(result + 2);
        sub_100361850(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_10036139C(result + 2) + 24))
      {
        uint64_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        BOOL v16 = (uint64_t *)sub_1002132EC(a1);
        uint64_t v17 = sub_100213ADC(v16);
        uint64_t v18 = sub_10036139C(v22 + 2);
        uint64_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      long long v22 = (uint64_t *)v15;
      uint64_t v19 = (uint64_t *)sub_1002132EC(a1);
      uint64_t v20 = (uint64_t *)sub_100213ADC(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t *sub_1003616FC(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  long long v9 = (uint64_t *)sub_1002132EC(a1);
  uint64_t v10 = sub_100213ADC(v9);
  BOOL v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    unsigned int v12 = (uint64_t *)sub_1002132EC(a1);
    BOOL v11 = *(uint64_t **)(sub_100213ADC(v12) + 8);
  }
  uint64_t v14 = v11;
  return sub_1003615C0(a1, a2, a3, &v14, a4);
}

void sub_1003617B0()
{
}

void sub_10036182C()
{
}

uint64_t *sub_100361850(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    long long v6 = (uint64_t *)sub_1003618B8(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_1003618B8(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_1003618FC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)a1 = off_1019BD000;
  operator new();
}

void sub_100361A10(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100163C60((void ***)va);
  operator delete();
}

void sub_100361A78(uint64_t a1)
{
  sub_100361E2C(a1);

  operator delete();
}

BOOL sub_100361AB0(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  long long v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v4, v2);
  sub_100361E9C((atomic_uint **)v1, v4);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v5 + 1));
  sub_10000A5F8(v4);
  return v1 != 0;
}

void sub_100361B60(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100361B90(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_100361BBC(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_100361BE8@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  long long v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)long long v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

void sub_100361C44(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100361CB0(&v2);
}

void sub_100361C9C(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100361CB0(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100361D20(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100361D48(v1);
  __cxa_rethrow();
}

void sub_100361D34(_Unwind_Exception *a1)
{
}

uint64_t sub_100361D48(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100360F80((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_100361DA8()
{
}

uint64_t sub_100361DBC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100360F80((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100361E14()
{
  return 0;
}

uint64_t sub_100361E1C()
{
  return 0;
}

uint64_t sub_100361E24()
{
  return 0;
}

uint64_t sub_100361E2C(uint64_t a1)
{
  *(void *)a1 = off_1019BD000;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

atomic_uint **sub_100361E9C(atomic_uint **result, void *a2)
{
  uint64_t v2 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v4 = result;
    for (uint64_t i = *(atomic_uint **)sub_1003618B8((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_1003618B8(v2);
      if (i == result[1]) {
        break;
      }
      memset(v6, 0, sizeof(v6));
      sub_100060B10(i, (uint64_t)v6);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v4 + 24))
        {
          *((unsigned char *)v4 + 24) = 0;
          sub_100163448(v4, a2);
        }
        return sub_1000624B4((uint64_t)v6);
      }
      sub_1000624B4((uint64_t)v6);
    }
  }
  return result;
}

void sub_100361F80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100361FA0(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10036200C(&v2);
}

void sub_100361FF8(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10036200C(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10036207C(void *a1)
{
  __cxa_begin_catch(a1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  __cxa_rethrow();
}

void sub_1003620B4(_Unwind_Exception *a1)
{
}

void sub_1003620CC()
{
}

uint64_t sub_1003620E0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100362110()
{
  return 0;
}

uint64_t sub_100362118()
{
  return 0;
}

uint64_t sub_100362120()
{
  return 0;
}

uint64_t *sub_100362128(uint64_t *result, uint64_t *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = (uint64_t)result;
    memset(v4, 0, sizeof(v4));
    sub_10036226C((uint64_t)v4, result);
    sub_10036226C(v3, a2);
    sub_10036226C((uint64_t)a2, (uint64_t *)v4);
    return sub_100360F80((uint64_t *)v4);
  }
  return result;
}

void sub_100362190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1003621A4(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        *(_WORD *)(a2 + 8) = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tIvNS_4_mfi3mf4Iv21CSINotificationSenderN22CSINotificationHandl"
                                        "er16NotificationTypeEiiPvEENS0_5list5INS0_5valueIPS4_EENS_3argILi1EEENSD_ILi2EEE"
                                        "NSD_ILi3EEENSD_ILi4EEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tIvNS_4_mfi3mf4Iv21CSINotificationSenderN22CSINotificationHandler16NotificationTypeEiiPvEENS0_5list5INS0_5valueIPS4_EENS_3argILi1EEENSD_ILi2EEENSD_ILi3EEENSD_ILi4EEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(a2 + 16) = *(void *)(result + 16);
    *(_OWORD *)a2 = v5;
  }
  return result;
}

uint64_t sub_100362244(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(uint64_t (**)(void *))a1;
  uint64_t v3 = (void *)(*(void *)(a1 + 16) + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

uint64_t sub_10036226C(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        long long v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    uint64_t *v2 = 0;
  }
  return result;
}

void sub_100362308(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_rethrow();
}

void sub_100362318(_Unwind_Exception *a1)
{
}

uint64_t sub_10036232C(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        *(_WORD *)(a2 + 8) = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tIvNS_4_mfi3mf4Iv22CSINotificationHandlerNS4_16NotificationType"
                                        "EiiPvEENS0_5list5INS0_5valueIPS4_EENS_3argILi1EEENSC_ILi2EEENSC_ILi3EEENSC_ILi4EEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tIvNS_4_mfi3mf4Iv22CSINotificationHandlerNS4_16NotificationTypeEiiPvEENS0_5list5INS0_5valueIPS4_EENS_3argILi1EEENSC_ILi2EEENSC_ILi3EEENSC_ILi4EEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(a2 + 16) = *(void *)(result + 16);
    *(_OWORD *)a2 = v5;
  }
  return result;
}

uint64_t sub_1003623CC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(uint64_t (**)(void *))a1;
  uint64_t v3 = (void *)(*(void *)(a1 + 16) + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

atomic_uint **sub_100362414(uint64_t *a1, int a2, int a3, int a4, uint64_t a5)
{
  int v29 = a3;
  int v30 = a2;
  int v28 = a4;
  uint64_t v27 = a5;
  long long v26 = 0uLL;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v6 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(&v33, v6);
  uint64_t v7 = a1[1];
  if (v7)
  {
    if (atomic_load_explicit((atomic_uint *volatile)(v7 + 8), memory_order_acquire) == 1) {
      sub_1003616FC(a1, &v33, 0, 1);
    }
    uint64_t v8 = *a1;
    uint64_t v9 = a1[1];
    if (v9) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v9 + 8), 1u, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v8 = *a1;
  }
  long long v10 = v26;
  *(void *)&long long v26 = v8;
  *((void *)&v26 + 1) = v9;
  v32[0] = v10;
  sub_10000A740((atomic_uint **)v32 + 1);
  sub_10000A6C8(*((pthread_mutex_t **)&v44 + 1));
  sub_10000A5F8(&v33);
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v33 = 0u;
  uint64_t v48 = 0;
  uint64_t v49 = 10;
  unint64_t v50 = (char *)&v33 + 8;
  uint64_t v51 = 0;
  uint64_t v52 = &v30;
  long long v53 = &v29;
  __int16 v54 = &v28;
  __int16 v55 = &v27;
  uint64_t v57 = 0;
  uint64_t v56 = 0;
  BOOL v11 = (uint64_t *)sub_1002132EC((uint64_t *)&v26);
  v25[0] = &v33;
  v25[1] = a1;
  _OWORD v25[2] = sub_100213ADC(v11);
  uint64_t v12 = sub_1002132EC((uint64_t *)&v26);
  uint64_t v13 = sub_100060EA8((uint64_t *)(v12 + 16));
  uint64_t v14 = (uint64_t *)sub_1002132EC((uint64_t *)&v26);
  uint64_t v15 = *(void *)(sub_100213ADC(v14) + 8);
  BOOL v16 = (uint64_t *)sub_1002132EC((uint64_t *)&v26);
  *(void *)&long long v23 = v15;
  *((void *)&v23 + 1) = sub_100213ADC(v16);
  *(void *)&long long v24 = &v33;
  *((void *)&v24 + 1) = *((void *)&v23 + 1);
  sub_1003628D8((uint64_t *)&v23);
  uint64_t v17 = (uint64_t *)sub_1002132EC((uint64_t *)&v26);
  uint64_t v18 = sub_100213ADC(v17);
  uint64_t v19 = (uint64_t *)sub_1002132EC((uint64_t *)&v26);
  *(void *)&long long v21 = v18;
  *((void *)&v21 + 1) = sub_100213ADC(v19);
  *(void *)&long long v22 = &v33;
  *((void *)&v22 + 1) = *((void *)&v21 + 1);
  sub_1003628D8((uint64_t *)&v21);
  v32[0] = v23;
  v32[1] = v24;
  v31[0] = v21;
  v31[1] = v22;
  sub_1003626A8(v13, (uint64_t *)v32, v31);
  sub_100362D60((uint64_t)v25);
  sub_100362F44((uint64_t)&v33);
  return sub_10000A740((atomic_uint **)&v26 + 1);
}

void sub_100362654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,atomic_uint *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
}

void sub_1003626A8(uint64_t a1, uint64_t *a2, void *a3)
{
  while (*a2 != *a3)
  {
    sub_100362728(a2);
    *a2 = *(void *)(*a2 + 8);
    sub_1003628D8(a2);
    long long v5 = (unsigned char *)a2[2];
    if (*v5) {
      *long long v5 = 0;
    }
  }
}

unsigned char *sub_100362728(void *a1)
{
  uint64_t v2 = (unsigned char *)a1[2];
  if (!*v2)
  {
    sub_1003627E4((uint64_t)(v2 + 272), (uint64_t *)(*a1 + 16));
    if (!*v2) {
      unsigned char *v2 = 1;
    }
  }
  uint64_t v3 = (unsigned char *)a1[2];
  if (!*v3) {
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
  return v3 + 1;
}

uint64_t sub_1003627E4(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = sub_10036139C(a2);
  uint64_t v3 = (void *)(sub_1003618B8((uint64_t *)(v2 + 32)) + 24);

  return sub_100362840(v3);
}

uint64_t sub_100362840(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  uint64_t v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_1003628C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void sub_1003628D8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_15;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      uint64_t v3 = (uint64_t *)(*a1 + 16);
      long long v15 = 0u;
      long long v16 = 0u;
      uint64_t v4 = sub_100362B34(v3);
      sub_10000A4EC(&v15, v4);
      long long v5 = (atomic_uint **)sub_10036139C((uint64_t *)(*a1 + 16));
      sub_100362B78(v5, &v15, (void *)(a1[2] + 8));
      uint64_t v6 = sub_10036139C((uint64_t *)(*a1 + 16));
      uint64_t v7 = a1[2];
      if (*(unsigned char *)(v6 + 24)) {
        ++*(_DWORD *)(v7 + 304);
      }
      else {
        ++*(_DWORD *)(v7 + 308);
      }
      uint64_t v8 = sub_10036139C((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v8 + 24)
        || (uint64_t v9 = *(void *)(v8 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v9 + 8), memory_order_acquire))
      {
        int v10 = 1;
      }
      else
      {
        sub_100362C98(a1, &v15, *a1);
        int v10 = 0;
      }
      (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
      sub_10000A5F8(&v15);
      uint64_t v1 = *a1;
      uint64_t v11 = a1[1];
      if (!v10) {
        break;
      }
      uint64_t v12 = *(void *)(v1 + 8);
      *a1 = v12;
      if (v12 == v11)
      {
        uint64_t v1 = v11;
        goto LABEL_15;
      }
    }
    if (v1 == v11)
    {
LABEL_15:
      uint64_t v13 = a1[3];
      if (v13 != v1)
      {
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v15 = 0u;
        long long v16 = 0u;
        uint64_t v14 = sub_100362B34((uint64_t *)(v13 + 16));
        sub_10000A4EC(&v15, v14);
        sub_100362C98(a1, &v15, a1[1]);
        (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
        sub_10000A5F8(&v15);
      }
    }
  }
}

void sub_100362AF8(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100362B34(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_100362B78(atomic_uint **result, void *a2, void *a3)
{
  uint64_t v3 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v6 = result;
    for (uint64_t i = *(atomic_uint **)sub_1003618B8((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_1003618B8(v3);
      if (i == result[1]) {
        break;
      }
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v6 + 24))
        {
          *((unsigned char *)v6 + 24) = 0;
          sub_100060D70(v6, a2);
        }
        return sub_1000624B4((uint64_t)v8);
      }
      sub_100062188(a3, (uint64_t)v8);
      sub_1000624B4((uint64_t)v8);
    }
  }
  return result;
}

void sub_100362C74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_100362C98(void *a1, void *a2, uint64_t a3)
{
  a1[3] = a3;
  uint64_t v3 = a1[2];
  if (a1[1] == a3)
  {
    uint64_t result = *(atomic_uint ***)(v3 + 312);
    if (result) {
      uint64_t result = sub_100060D70(result, a2);
    }
    *(void *)(v3 + 312) = 0;
  }
  else
  {
    uint64_t v4 = *(void *)(a3 + 16);
    uint64_t v5 = a1[2];
    return sub_100362CF8(v5, a2, v4);
  }
  return result;
}

atomic_uint **sub_100362CF8(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t result = *(atomic_uint ***)(a1 + 312);
  if (result) {
    uint64_t result = sub_100060D70(result, a2);
  }
  *(void *)(a1 + 312) = a3;
  if (a3)
  {
    int v6 = *(_DWORD *)(a3 + 28);
    if (!v6) {
      __assert_rtn("inc_slot_refcount", "connection.hpp", 114, "m_slot_refcount != 0");
    }
    *(_DWORD *)(a3 + 28) = v6 + 1;
  }
  return result;
}

uint64_t sub_100362D60(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)a1 + 308) > *(_DWORD *)(*(void *)a1 + 304)) {
    sub_100362DA4(*(uint64_t **)(a1 + 8), *(void *)(a1 + 16));
  }
  return a1;
}

void sub_100362DA4(uint64_t *a1, uint64_t a2)
{
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  uint64_t v4 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v9, v4);
  uint64_t v5 = (uint64_t *)sub_1002132EC(a1);
  if (sub_100213ADC(v5) == a2)
  {
    uint64_t v6 = a1[1];
    if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
      operator new();
    }
    uint64_t v7 = (uint64_t *)sub_1002132EC(a1);
    uint64_t v8 = *(uint64_t **)(sub_100213ADC(v7) + 8);
    sub_1003615C0(a1, v9, 0, &v8, 0);
  }
  sub_10000A6C8(*((pthread_mutex_t **)&v10 + 1));
  sub_10000A5F8(v9);
}

void sub_100362EF0()
{
}

uint64_t sub_100362F44(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 312);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 312), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_100363018(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100363038()
{
}

void sub_100363074(CTWifiLocationFactoryInterface *a1)
{
  CTWifiLocationFactoryInterface::~CTWifiLocationFactoryInterface(a1);

  operator delete();
}

void sub_1003630AC(uint64_t *a1@<X1>, NSObject **a2@<X2>, long long *a3@<X4>, void *a4@<X8>)
{
  uint64_t v8 = *a1;
  uint64_t v7 = (std::__shared_weak_count *)a1[1];
  long long v10 = (std::__shared_weak_count *)operator new(0x100uLL);
  v10->__shared_owners_ = 0;
  v10->__shared_weak_owners_ = 0;
  v10->__vftable = (std::__shared_weak_count_vtbl *)off_1019BD1E0;
  uint64_t v11 = (uint64_t)&v10[1];
  v15[0] = v8;
  v15[1] = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = *a2;
  dispatch_object_t object = v12;
  if (v12) {
    dispatch_retain(v12);
  }
  sub_100B35E94(v11, v15, &object, v9, a3);
  if (object) {
    dispatch_release(object);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
  shared_weak_owners = (std::__shared_weak_count *)v10[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v10[1].__shared_owners_ = v11;
    v10[1].__shared_weak_owners_ = (uint64_t)v10;
    goto LABEL_13;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v10[1].__shared_owners_ = v11;
    v10[1].__shared_weak_owners_ = (uint64_t)v10;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
LABEL_13:
    sub_10004D2C8(v10);
  }
  *a4 = v10 + 3;
  a4[1] = v10;
}

void sub_1003631D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  std::__shared_weak_count::~__shared_weak_count(v10);
  operator delete(v13);
  _Unwind_Resume(a1);
}

void sub_100363204()
{
  v0 = operator new(0x58uLL);
  v0[1] = 0;
  v0[2] = 0;
  void *v0 = off_1019BD230;
  sub_1005960B8(v0 + 3);
}

void sub_100363258(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_100363274()
{
}

void sub_100363288(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019BD1E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1003632A8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019BD1E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1003632FC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 8))();
}

void sub_100363324(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019BD230;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100363344(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019BD230;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100363398(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 16))();
}

void sub_1003634E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100363518(void *a1, void *a2, Registry **a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a3);
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v27 = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v27);
  if (!v12)
  {
    uint64_t v14 = 0;
LABEL_9:
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    if (!v14) {
      goto LABEL_7;
    }
    goto LABEL_10;
  }
  uint64_t v14 = v12[3];
  uint64_t v13 = (std::__shared_weak_count *)v12[4];
  if (!v13) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
  if (!v14)
  {
LABEL_7:
    id v16 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:1 userInfo:0];
LABEL_19:
    *a2 = v16;
    *a1 = 0;
    a1[1] = 0;
    goto LABEL_20;
  }
LABEL_10:
  if (((*(uint64_t (**)(uint64_t))(*(void *)v14 + 32))(v14) & 1) == 0)
  {
    id v16 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:13 userInfo:0];
    goto LABEL_19;
  }
  long long v17 = (std::mutex *)Registry::getServiceMap(*a3);
  long long v18 = v17;
  if ((v19 & 0x8000000000000000) != 0)
  {
    long long v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      unint64_t v19 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(v17);
  unint64_t v27 = v19;
  long long v23 = sub_10004D37C(&v18[1].__m_.__sig, &v27);
  if (!v23)
  {
    std::mutex::unlock(v18);
LABEL_24:
    long long v24 = 0;
    char v26 = 1;
    goto LABEL_28;
  }
  uint64_t v25 = v23[3];
  long long v24 = (std::__shared_weak_count *)v23[4];
  if (!v24)
  {
    std::mutex::unlock(v18);
    if (v25)
    {
      *a1 = v25;
      a1[1] = 0;
      goto LABEL_20;
    }
    goto LABEL_24;
  }
  atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v18);
  atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v24);
  if (!v25)
  {
    char v26 = 0;
LABEL_28:
    *a2 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    *a1 = 0;
    a1[1] = 0;
    if (v26) {
      goto LABEL_20;
    }
    goto LABEL_29;
  }
  *a1 = v25;
  a1[1] = v24;
  atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_29:
  sub_10004D2C8(v24);
LABEL_20:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_100363794(_Unwind_Exception *exception_object)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100363958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, std::__shared_weak_count *a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_1000F25E0((uint64_t *)va);
  if (a7) {
    sub_10004D2C8(a7);
  }

  _Unwind_Resume(a1);
}

void sub_100363B50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, std::__shared_weak_count *a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100060644((uint64_t *)va);
  if (a7) {
    sub_10004D2C8(a7);
  }

  _Unwind_Resume(a1);
}

void sub_100363DF8(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100364214(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1003642B4(uint64_t a1, const void **a2)
{
  int v3 = *(unsigned __int8 *)a2;
  if (v3 == 2)
  {
    if (*((unsigned char *)a2 + 8) == 19)
    {
      char v4 = *(void **)(a1 + 32);
      if (v4)
      {
        [v4 getLogContext];
        char v5 = v17;
      }
      else
      {
        char v5 = 0;
        uint64_t v16 = 0;
        long long v17 = 0;
      }
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v16);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v16) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Driver not ready", (uint8_t *)&v16, 2u);
      }
      id v14 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }
    else
    {
      uint64_t v10 = *(void **)(a1 + 32);
      if (v10)
      {
        [v10 getLogContext];
        unsigned int v11 = v17;
      }
      else
      {
        unsigned int v11 = 0;
        uint64_t v16 = 0;
        long long v17 = 0;
      }
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v16);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v16) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Get Vinyl FW Update Info error", (uint8_t *)&v16, 2u);
      }
      id v14 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }
  }
  else
  {
    long long v18 = 0;
    if (v3 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    sub_100058198((const void **)&v18, a2 + 1);
    if (v18) {
      char v6 = sub_100080778;
    }
    else {
      char v6 = 0;
    }
    if (v6)
    {
      id v7 = [v18 mutableCopy];
      id v8 = v7;
      if (*(unsigned char *)(a1 + 48)) {
        CFStringRef v9 = @"halley";
      }
      else {
        CFStringRef v9 = @"eos";
      }
      [v7 setObject:v9 forKeyedSubscript:@"kEUICCType"];
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }
    else
    {
      uint64_t v12 = *(void **)(a1 + 32);
      if (v12)
      {
        [v12 getLogContext];
        uint64_t v13 = v17;
      }
      else
      {
        uint64_t v13 = 0;
        uint64_t v16 = 0;
        long long v17 = 0;
      }
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v16);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v16) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Empty dictionary - maybe eUICC does not exist", (uint8_t *)&v16, 2u);
      }
      id v8 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }

    sub_100057D78((const void **)&v18);
  }
}

void sub_1003645AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1003645F8(uint64_t a1)
{
  return a1;
}

void sub_100364624(uint64_t a1)
{
  operator delete();
}

void *sub_100364670(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019BD2A8;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1003646C8(uint64_t a1, void *a2)
{
  *a2 = off_1019BD2A8;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100364710(uint64_t a1)
{
}

void sub_100364718(id *a1)
{
  operator delete(a1);
}

void sub_100364754(uint64_t a1, unsigned __int16 *a2)
{
  unsigned int v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  if (v2 > 0xFF)
  {
    char v4 = *(void (**)(uint64_t, BOOL, void))(v3 + 16);
    uint64_t v5 = *(void *)(a1 + 8);
    v4(v5, v2 != 0, 0);
  }
  else
  {
    id v6 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    (*(void (**)(uint64_t, void))(v3 + 16))(v3, 0);
  }
}

void sub_100364818(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10036482C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019BD308)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10036486C()
{
  return &off_1019BD308;
}

uint64_t sub_100364878(uint64_t a1)
{
  return a1;
}

void sub_1003648A4(uint64_t a1)
{
  operator delete();
}

void *sub_1003648F0(uint64_t a1)
{
  unsigned int v2 = operator new(0x10uLL);
  void *v2 = off_1019BD328;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100364948(uint64_t a1, void *a2)
{
  *a2 = off_1019BD328;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100364990(uint64_t a1)
{
}

void sub_100364998(id *a1)
{
  operator delete(a1);
}

uint64_t sub_1003649D4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_1003649EC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019BD388)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100364A2C()
{
  return &off_1019BD388;
}

uint64_t sub_100364A38(uint64_t a1)
{
  return a1;
}

void sub_100364A64(uint64_t a1)
{
  operator delete();
}

void *sub_100364AB0(uint64_t a1)
{
  unsigned int v2 = operator new(0x10uLL);
  void *v2 = off_1019BD3A8;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100364B08(uint64_t a1, void *a2)
{
  *a2 = off_1019BD3A8;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100364B50(uint64_t a1)
{
}

void sub_100364B58(id *a1)
{
  operator delete(a1);
}

void sub_100364B94(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  if ((v3 - 1) > 1)
  {
    id v8 = 0;
  }
  else if (v3 == 2)
  {
    int v4 = a2[1];
    uint64_t v5 = 16;
    uint64_t v6 = -1;
    if (v4 == 3) {
      uint64_t v6 = 1;
    }
    if (v4 != 5) {
      uint64_t v5 = v6;
    }
    if (v4 == 11) {
      uint64_t v7 = 45;
    }
    else {
      uint64_t v7 = v5;
    }
    id v8 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:v7 userInfo:0];
  }
  else
  {
    id v8 = 0;
  }
  id v9 = v8;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_100364C74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100364C88(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019BD408)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100364CC8()
{
  return &off_1019BD408;
}

void sub_100364CD4()
{
}

void sub_100364CFC(int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const void **a4@<X3>, uint64_t a5@<X8>)
{
  memset(v22, 0, 40);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v22, "com.apple.telephony", "msg.mms.pdu");
  HIDWORD(v22[1]) = 106;
  char v10 = 1;
  LOWORD(v22[2]) = 1;
  BYTE2(v22[2]) = 1;
  DWORD1(v22[2]) = a1;
  *((void *)&v22[0] + 1) = a2;
  LODWORD(v22[1]) = a3;
  *(void *)((char *)&v22[1] + 4) = 0x6A00000000;
  if (a3 <= 2 || (char v10 = 2, DWORD1(v22[1]) = 2, *(unsigned char *)(a2 + 1) != 6))
  {
    *(void *)a5 = 0;
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = 0;
    goto LABEL_6;
  }
  DWORD1(v22[1]) = 3;
  unsigned int v11 = *(unsigned __int8 *)(a2 + 2);
  if ((int)a3 - 3 < v11)
  {
    *(void *)a5 = 0;
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = 0;
    char v10 = 1;
LABEL_6:
    *(unsigned char *)(a5 + 24) = v10;
    goto LABEL_7;
  }
  memset(__p, 0, 40);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)__p, (const ctu::OsLogLogger *)v22);
  *(_OWORD *)&__p[1] = *(_OWORD *)((char *)v22 + 8);
  *(_OWORD *)&__p[3] = *(_OWORD *)((char *)&v22[1] + 8);
  uint64_t v12 = sub_100FEEC44((uint64_t)__p);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)__p);
  if (!v12)
  {
    *(void *)a5 = 0;
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = 0;
    char v10 = 3;
    goto LABEL_6;
  }
  memset(__p, 0, 24);
  if (!sub_10035F71C(v12, (uint64_t)__p)) {
    goto LABEL_32;
  }
  int v13 = *((char *)a4 + 23);
  if (v13 >= 0) {
    unint64_t v14 = *((unsigned __int8 *)a4 + 23);
  }
  else {
    unint64_t v14 = (unint64_t)a4[1];
  }
  if (SHIBYTE(__p[2]) < 0)
  {
    if (v14 != -1)
    {
      uint64_t v16 = (void **)__p[0];
      if (__p[1] >= (void *)v14) {
        size_t v15 = v14;
      }
      else {
        size_t v15 = (size_t)__p[1];
      }
      goto LABEL_24;
    }
LABEL_36:
    sub_1000C14D8();
  }
  if (v14 == -1) {
    goto LABEL_36;
  }
  if (HIBYTE(__p[2]) >= v14) {
    size_t v15 = v14;
  }
  else {
    size_t v15 = HIBYTE(__p[2]);
  }
  uint64_t v16 = __p;
LABEL_24:
  if (v13 >= 0) {
    long long v17 = a4;
  }
  else {
    long long v17 = *a4;
  }
  if (!memcmp(v16, v17, v15) && v15 == v14)
  {
    int v18 = LODWORD(v22[1]) - DWORD1(v22[1]);
    if (LODWORD(v22[1]) - DWORD1(v22[1]) >= v11) {
      int v18 = v11;
    }
    uint64_t v19 = (v18 + DWORD1(v22[1]));
    DWORD1(v22[1]) = v19;
    long long v20 = 0uLL;
    uint64_t v21 = 0;
    sub_1001E7940(&v20, (const void *)(a2 + v19), a2 + a3, a3 - v19);
    *(_OWORD *)a5 = v20;
    *(void *)(a5 + 16) = v21;
    *(unsigned char *)(a5 + 24) = 0;
    goto LABEL_33;
  }
LABEL_32:
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  *(void *)(a5 + 16) = 0;
  *(unsigned char *)(a5 + 24) = 4;
LABEL_33:
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
LABEL_7:
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v22);
}

void sub_100364F6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100364FD4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void *sub_100364FE4(uint64_t a1)
{
  sub_1000F0058((uint64_t)v2, a1);
  sub_10017B514();
  return sub_10003B34C(v2);
}

void sub_1003650A0(_Unwind_Exception *a1)
{
  sub_10003B34C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1003650BC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  if (!v1) {
    sub_10007B600();
  }
  unsigned int v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);

  return v2();
}

uint64_t sub_10036510C(uint64_t a1, uint64_t a2)
{
  return sub_1000F0058(a1 + 32, a2 + 32);
}

void *sub_100365118(uint64_t a1)
{
  return sub_10003B34C((void *)(a1 + 32));
}

void sub_100365120(MCCAndMNC *a1@<X0>, std::string *a2@<X8>)
{
  MCCAndMNC::getStringValue((uint64_t *)&v8, a1);
  int v3 = std::string::append(&v8, ", ", 2uLL);
  long long v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  v9.__r_.__value_.__r.__words[2] = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v9.__r_.__value_.__l.__data_ = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  uint64_t v5 = (const char *)asString();
  size_t v6 = strlen(v5);
  uint64_t v7 = std::string::append(&v9, v5, v6);
  *a2 = *v7;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v8.__r_.__value_.__l.__data_);
  }
}

void sub_1003651D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10036520C(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  std::operator+<char>();
  long long v4 = std::string::append(&v10, ", Short name: ", 0xEuLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v11.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v11.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  int v6 = *(char *)(a1 + 23);
  if (v6 >= 0) {
    uint64_t v7 = (const std::string::value_type *)a1;
  }
  else {
    uint64_t v7 = *(const std::string::value_type **)a1;
  }
  if (v6 >= 0) {
    std::string::size_type v8 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    std::string::size_type v8 = *(void *)(a1 + 8);
  }
  std::string v9 = std::string::append(&v11, v7, v8);
  *a2 = *v9;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1003652D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100365304(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 48))
  {
    if (*(char *)(a1 + 23) < 0)
    {
      sub_10004FC84(v4, *(void **)a1, *(void *)(a1 + 8));
    }
    else
    {
      *(_OWORD *)long long v4 = *(_OWORD *)a1;
      uint64_t v5 = *(void *)(a1 + 16);
    }
    if (*(char *)(a1 + 47) < 0)
    {
      sub_10004FC84(&__p, *(void **)(a1 + 24), *(void *)(a1 + 32));
    }
    else
    {
      long long __p = *(_OWORD *)(a1 + 24);
      uint64_t v7 = *(void *)(a1 + 40);
    }
    sub_10036520C((uint64_t)v4, a2);
    if (SHIBYTE(v7) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v5) < 0) {
      operator delete(v4[0]);
    }
  }
  else
  {
    sub_100058DB0(a2, "<not present>");
  }
}

void sub_1003653E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100365414(uint64_t result)
{
  *(void *)id result = off_1019BD480;
  if (*(unsigned char *)(result + 16))
  {
    if (*(void *)(result + 24))
    {
      uint64_t v1 = *(void ***)(result + 24);
      sub_1002C0864(&v1);
      operator delete();
    }
  }
  return result;
}

void sub_100365494(uint64_t a1)
{
  sub_100365414(a1);

  operator delete();
}

void sub_1003654CC(uint64_t a1, char *a2, char a3)
{
  int v3 = *(void **)(a1 + 24);
  if (!v3) {
    operator new();
  }
  sub_100365C8C((uint64_t)v4, a3, a2);
  sub_10036557C(v3, v4);
  if (v6 < 0) {
    operator delete(__p);
  }
}

void sub_100365560(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10036557C(void *result, char *a2)
{
  int v3 = (char **)result;
  unint64_t v4 = result[2];
  unint64_t v5 = result[1];
  if (v5 >= v4)
  {
    uint64_t v8 = (uint64_t)(v5 - *result) >> 5;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 59) {
      sub_10006A748();
    }
    uint64_t v10 = v4 - *result;
    if (v10 >> 4 > v9) {
      unint64_t v9 = v10 >> 4;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v11 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    long long v23 = result + 2;
    if (v11)
    {
      if (v11 >> 59) {
        sub_10006A7CC();
      }
      uint64_t v12 = (char *)operator new(32 * v11);
    }
    else
    {
      uint64_t v12 = 0;
    }
    int v13 = &v12[32 * v8];
    char *v13 = *a2;
    *(_OWORD *)(v13 + 8) = *(_OWORD *)(a2 + 8);
    *((void *)v13 + 3) = *((void *)a2 + 3);
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    *((void *)a2 + 1) = 0;
    uint64_t v7 = v13 + 32;
    size_t v15 = *v3;
    unint64_t v14 = (unint64_t)v3[1];
    if ((char *)v14 == *v3)
    {
      int64x2_t v18 = vdupq_n_s64(v14);
    }
    else
    {
      do
      {
        char v16 = *(unsigned char *)(v14 - 32);
        v14 -= 32;
        *(v13 - 32) = v16;
        v13 -= 32;
        long long v17 = *(_OWORD *)(v14 + 8);
        *((void *)v13 + 3) = *(void *)(v14 + 24);
        *(_OWORD *)(v13 + 8) = v17;
        *(void *)(v14 + 16) = 0;
        *(void *)(v14 + 24) = 0;
        *(void *)(v14 + 8) = 0;
      }
      while ((char *)v14 != v15);
      int64x2_t v18 = *(int64x2_t *)v3;
    }
    *int v3 = v13;
    v3[1] = v7;
    int64x2_t v21 = v18;
    uint64_t v19 = v3[2];
    v3[2] = &v12[32 * v11];
    unsigned int v22 = v19;
    uint64_t v20 = v18.i64[0];
    id result = (void *)sub_100255B70((uint64_t)&v20);
  }
  else
  {
    *(unsigned char *)unint64_t v5 = *a2;
    long long v6 = *(_OWORD *)(a2 + 8);
    *(void *)(v5 + 24) = *((void *)a2 + 3);
    *(_OWORD *)(v5 + 8) = v6;
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    *((void *)a2 + 1) = 0;
    uint64_t v7 = (char *)(v5 + 32);
  }
  v3[1] = v7;
  return result;
}

uint64_t sub_1003656DC(uint64_t a1, char *a2)
{
  if ((sub_100365720(a1, a2) & 1) == 0) {
    *(unsigned char *)(a1 + 17) = strtoul(a2, 0, 0);
  }
  return 1;
}

uint64_t sub_100365720(uint64_t a1, std::string::value_type *__s)
{
  unsigned int v2 = *(uint64_t **)(a1 + 24);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *v2;
  if (*(void *)(*(void *)(a1 + 24) + 8) == v3) {
    return 0;
  }
  unint64_t v6 = 0;
  unsigned int v7 = 1;
  while (std::string::compare((const std::string *)(v3 + 32 * v6 + 8), __s))
  {
    unint64_t v6 = v7;
    uint64_t v3 = **(void **)(a1 + 24);
    ++v7;
    if (v6 >= (*(void *)(*(void *)(a1 + 24) + 8) - v3) >> 5) {
      return 0;
    }
  }
  *(unsigned char *)(a1 + 17) = *(unsigned char *)(**(void **)(a1 + 24) + 32 * v6);
  return 1;
}

BOOL sub_1003657B8(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a2 + 16);
  uint64_t v2 = *(unsigned int *)(a2 + 20);
  if (v2 < v3)
  {
    uint64_t v4 = *(void *)(a2 + 8);
    *(_DWORD *)(a2 + 20) = v2 + 1;
    *(unsigned char *)(a1 + 17) = *(unsigned char *)(v4 + v2);
  }
  return v2 < v3;
}

uint64_t sub_1003657E4(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t sub_10036580C(uint64_t a1, std::string *this)
{
  unsigned int v3 = *(uint64_t **)(a1 + 24);
  if (!v3 || (uint64_t v4 = *v3, v5 = *(void *)(*(void *)(a1 + 24) + 8), v6 = v5 - v4, v5 == v4))
  {
LABEL_6:
    uint64_t v27 = 0;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v18 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    *(_OWORD *)long long __p = 0u;
    memset(v14, 0, sizeof(v14));
    sub_10004DE24((uint64_t)v14);
    std::ostream::operator<<();
    sub_10004BC98((uint64_t)v14 + 8, &v12);
    if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
      operator delete(this->__r_.__value_.__l.__data_);
    }
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v12;
    this->__r_.__value_.__r.__words[2] = v13;
    if (SHIBYTE(v16) < 0) {
      operator delete(__p[1]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v8 = v6 >> 5;
    unsigned int v9 = 1;
    while (*(unsigned __int8 *)(v4 + 32 * v7) != *(unsigned __int8 *)(a1 + 17))
    {
      uint64_t v7 = v9;
      if (v8 <= v9++) {
        goto LABEL_6;
      }
    }
    std::string::operator=(this, (const std::string *)(v4 + 32 * v7 + 8));
  }
  return 1;
}

void sub_1003659F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000C937C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100365A08()
{
}

void sub_100365A6C()
{
}

const char *sub_100365AD8()
{
  return "enum";
}

void sub_100365AE4()
{
}

void sub_100365B6C()
{
}

void sub_100365BE4()
{
}

void sub_100365C54(uint64_t a1)
{
  sub_100365414(a1);

  operator delete();
}

uint64_t sub_100365C8C(uint64_t a1, char a2, char *a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(unsigned char *)a1 = a2;
  if (a3) {
    uint64_t v4 = a3;
  }
  else {
    uint64_t v4 = "";
  }
  sub_10003ED78((std::string *)(a1 + 8), v4);
  return a1;
}

void sub_100365CE0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100365CFC()
{
  sub_10070B5D4(&v0);
}

void sub_100365D3C(UsageAlertAlgorithmFactoryInterface *a1)
{
  UsageAlertAlgorithmFactoryInterface::~UsageAlertAlgorithmFactoryInterface(a1);

  operator delete();
}

uint64_t sub_100365D74()
{
  uint64_t result = qword_101B13CD0;
  if (!qword_101B13CD0)
  {
    std::mutex::lock(&stru_101B09FA8);
    if (byte_101B13CD8) {
      __TUAssertTrigger();
    }
    if (!qword_101B13CD0)
    {
      sub_100365E20();
      (*(void (**)(void))(**(void **)(qword_101B13CD0 + 24) + 24))(*(void *)(qword_101B13CD0 + 24));
    }
    std::mutex::unlock(&stru_101B09FA8);
    return qword_101B13CD0;
  }
  return result;
}

void sub_100365E08(_Unwind_Exception *a1)
{
}

void sub_100365E20()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CC38, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0CC38))
  {
    sub_100365F68();
  }
  qword_101B13CD0 = (uint64_t)&qword_101B0CC40;
}

void sub_100365EA0(_Unwind_Exception *a1)
{
}

uint64_t sub_100365EB8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    uint64_t v3 = *(void *)(a1 + 24);
    byte_101B13CD8 = 1;
    *(void *)(a1 + 24) = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  else
  {
    byte_101B13CD8 = 1;
    *(void *)(a1 + 24) = 0;
  }
  sub_10010C0E0(a1, *(void **)(a1 + 8));
  return a1;
}

void sub_100365F68()
{
  qword_101B0CC50 = 0;
  qword_101B0CC48 = 0;
  qword_101B0CC40 = (uint64_t)&qword_101B0CC48;
  createPlatformPropertyStore(&qword_101B0CC58);
}

void sub_100365FBC(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  uint64_t v5 = *(void *)(v3 + 3160);
  *(void *)(v3 + 3160) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  sub_10010C0E0(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_100366010(uint64_t a1)
{
  std::mutex::lock(&stru_101B09FA8);
  sub_10010C0E0(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  createPlatformPropertyStore(&v2);
}

void sub_1003660E0(_Unwind_Exception *a1)
{
}

uint64_t sub_1003660FC(uint64_t **a1, void **a2)
{
  std::mutex::lock(&stru_101B09FA8);
  uint64_t v4 = (uint64_t *)sub_100046F68((uint64_t)a1, a2);
  if (a1 + 1 != (uint64_t **)v4)
  {
    if (!(*(unsigned int (**)(uint64_t *, void **))(*a1[3] + 32))(a1[3], a2))
    {
      uint64_t v5 = 0;
      goto LABEL_6;
    }
    sub_10006C514(a1, v4);
    sub_1000FECD4((uint64_t)(v4 + 4));
    operator delete(v4);
  }
  uint64_t v5 = 1;
LABEL_6:
  std::mutex::unlock(&stru_101B09FA8);
  return v5;
}

void sub_1003661B8(_Unwind_Exception *a1)
{
}

uint64_t sub_1003661D4(uint64_t a1)
{
  std::mutex::lock(&stru_101B09FA8);
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
  if (v2)
  {
    sub_10010C0E0(a1, *(void **)(a1 + 8));
    *(void *)a1 = a1 + 8;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 8) = 0;
  }
  std::mutex::unlock(&stru_101B09FA8);
  return v2;
}

void sub_100366264(_Unwind_Exception *a1)
{
}

uint64_t sub_10036627C(uint64_t **a1, std::string *this, const std::string *a3)
{
  if (std::string::find(this, 61, 0) != -1) {
    __TUAssertTrigger();
  }
  std::mutex::lock(&stru_101B09FA8);
  uint64_t v6 = (*(uint64_t (**)(uint64_t *, std::string *, const std::string *))(*a1[3] + 16))(a1[3], this, a3);
  if (v6)
  {
    unsigned int v9 = (long long *)this;
    uint64_t v7 = sub_100366370(a1, (void **)&this->__r_.__value_.__l.__data_, (uint64_t)&unk_10144E20E, &v9);
    std::string::operator=((std::string *)(v7 + 7), a3);
  }
  std::mutex::unlock(&stru_101B09FA8);
  return v6;
}

void sub_100366358(_Unwind_Exception *a1)
{
}

uint64_t *sub_100366370(uint64_t **a1, void **a2, uint64_t a3, long long **a4)
{
  uint64_t v11 = 0;
  uint64_t v6 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v11, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    unint64_t v8 = v6;
    memset(v10, 0, sizeof(v10));
    sub_100366428((uint64_t)a1, a4, v10);
    sub_100046C38(a1, v11, v8, v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0;
    sub_10010E764((uint64_t)v10, 0);
  }
  return v7;
}

unsigned char *sub_100366428@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v6 = operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = v6 + 4;
  unint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_10004FC84(result, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    void v6[6] = *((void *)v8 + 2);
    *(_OWORD *)uint64_t result = v9;
  }
  v6[7] = 0;
  v6[8] = 0;
  v6[9] = 0;
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_1003664B0(_Unwind_Exception *a1)
{
  sub_10010E764(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1003664C8()
{
  return __cxa_atexit((void (*)(void *))&std::mutex::~mutex, &stru_101B09FA8, (void *)&_mh_execute_header);
}

void sub_1003664EC()
{
}

void sub_1003665C0(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003665F4(uint64_t a1, void *a2, uint64_t a3, dispatch_object_t *a4, unsigned int a5)
{
  PersonalitySpecificImpl::PersonalitySpecificImpl();
  uint64_t v10 = (const char *)kCtLoggingSystemName;
  uint64_t v11 = sub_10036689C((const char *)*(unsigned int *)(*(void *)a3 + 52), a5);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v23, v10, v11);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  long long v12 = *a4;
  *(void *)(a1 + 48) = *a4;
  if (v12) {
    dispatch_retain(v12);
  }
  *(void *)(a1 + 56) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v24, &v23);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 64), (const ctu::OsLogLogger *)v24);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v24);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
  *(void *)a1 = off_1019BD618;
  *(void *)(a1 + 24) = off_1019BD710;
  *(void *)(a1 + 72) = *a2;
  uint64_t v13 = a2[1];
  *(void *)(a1 + 80) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v14 = (const char *)PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  size_t v15 = (char *)sub_10036689C(v14, *(_DWORD *)(a1 + 112));
  sub_100058DB0(&__p, v15);
  long long v20 = *a4;
  if (*a4) {
    dispatch_retain(*a4);
  }
  long long v16 = *(NSObject **)(a1 + 56);
  dispatch_object_t object = v16;
  if (v16) {
    dispatch_retain(v16);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v20) {
    dispatch_release(v20);
  }
  if (v22 < 0) {
    operator delete(__p);
  }
  long long v17 = *a4;
  *(void *)(a1 + 104) = *a4;
  if (v17) {
    dispatch_retain(v17);
  }
  *(_DWORD *)(a1 + 112) = a5;
  return a1;
}

void sub_1003667EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  long long v24 = (std::__shared_weak_count *)*((void *)v19 + 10);
  if (v24) {
    sub_10004D2C8(v24);
  }
  ctu::OsLogLogger::~OsLogLogger(v22);
  sub_100087E88(v21);
  BBDataContextHelper::~BBDataContextHelper(v20);
  PersonalitySpecificImpl::~PersonalitySpecificImpl(v19);
  PersonalitySpecific::~PersonalitySpecific(v19);
  _Unwind_Resume(a1);
}

const char *sub_10036689C(const char *result, unsigned int a2)
{
  switch((int)result)
  {
    case 0:
    case 3:
      if (a2 <= 9)
      {
        int v2 = off_1019BDA18;
        goto LABEL_8;
      }
      uint64_t result = "DATA.BBContextHelper.X:N:";
      break;
    case 1:
      if (a2 < 0xA)
      {
        int v2 = off_1019BD978;
        goto LABEL_8;
      }
      uint64_t result = "DATA.BBContextHelper.1:N:";
      break;
    case 2:
      if (a2 >= 0xA)
      {
        uint64_t result = "DATA.BBContextHelper.2:N:";
      }
      else
      {
        int v2 = off_1019BD9C8;
LABEL_8:
        uint64_t result = v2[a2];
      }
      break;
    default:
      return result;
  }
  return result;
}

void sub_100366940(void *a1)
{
  *a1 = off_1019BD618;
  int v2 = (BBDataContextHelper *)(a1 + 3);
  a1[3] = off_1019BD710;
  uint64_t v3 = a1[13];
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[12];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[10];
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  sub_100087E88(a1 + 4);
  BBDataContextHelper::~BBDataContextHelper(v2);

  PersonalitySpecificImpl::~PersonalitySpecificImpl((PersonalitySpecificImpl *)a1);
}

void sub_100366A00(void *a1)
{
  sub_100366940(a1);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100366A28(uint64_t a1)
{
  sub_100366940((void *)(a1 - 24));

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100366A54(void *a1)
{
  sub_100366940(a1);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_100366A90(uint64_t a1)
{
}

void sub_100366A98(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v1, *(Registry **)(a1 + 72));
  ctu::RestModule::connect();
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_100366AE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100366AFC(uint64_t a1)
{
}

uint64_t sub_100366B04(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 72));
  int v2 = ServiceMap;
  if (v3 < 0)
  {
    uint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      uint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v3;
  uint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, (unint64_t *)__p);
  if (v7)
  {
    uint64_t v9 = v7[3];
    unint64_t v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  unint64_t v8 = 0;
  char v10 = 1;
LABEL_9:
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v14 = 0;
  if (!v9)
  {
    uint64_t v11 = 0;
    if (v10) {
      return v11;
    }
    goto LABEL_13;
  }
  uint64_t v11 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v9 + 520))(v9, __p);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  if ((v10 & 1) == 0) {
LABEL_13:
  }
    sub_10004D2C8(v8);
  return v11;
}

void sub_100366C40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100366C6C(uint64_t a1)
{
  return sub_100366B04(a1 - 24);
}

uint64_t sub_100366C7C(PersonalitySpecificImpl *a1)
{
  uint64_t v1 = (Registry **)((char *)a1 + 72);
  uint64_t v2 = PersonalitySpecificImpl::simSlot(a1);

  return isCallHandoverSupported(v1, v2);
}

uint64_t sub_100366CB8(uint64_t a1)
{
  uint64_t v1 = (Registry **)(a1 + 48);
  uint64_t v2 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)(a1 - 24));

  return isCallHandoverSupported(v1, v2);
}

uint64_t sub_100366CFC(PersonalitySpecificImpl *a1)
{
  uint64_t v1 = (Registry **)((char *)a1 + 72);
  uint64_t v2 = PersonalitySpecificImpl::simSlot(a1);

  return alwaysUseIpv4v6(v1, v2);
}

uint64_t sub_100366D38(uint64_t a1)
{
  uint64_t v1 = (Registry **)(a1 + 48);
  uint64_t v2 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)(a1 - 24));

  return alwaysUseIpv4v6(v1, v2);
}

BOOL *sub_100366D7C(PersonalitySpecificImpl *a1)
{
  uint64_t v1 = (Registry **)((char *)a1 + 72);
  uint64_t v2 = PersonalitySpecificImpl::simSlot(a1);

  return supportsPDNAuthentication(v1, v2);
}

BOOL *sub_100366DB8(uint64_t a1)
{
  uint64_t v1 = (Registry **)(a1 + 48);
  uint64_t v2 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)(a1 - 24));

  return supportsPDNAuthentication(v1, v2);
}

uint64_t sub_100366DFC(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 72));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v6;
  char v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  uint64_t v14 = v12 != 0;
  if (!v12) {
    goto LABEL_50;
  }
  uint64_t v15 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  if (!(*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12 + 792))(v12, v15, a2))
  {
    uint64_t v17 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    int v18 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 1104))(v12, v17);
    CFTypeRef cf = 0;
    long long v19 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 72));
    long long v20 = v19;
    if (v21 < 0)
    {
      char v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v23 = 5381;
      do
      {
        uint64_t v21 = v23;
        unsigned int v24 = *v22++;
        uint64_t v23 = (33 * v23) ^ v24;
      }
      while (v24);
    }
    std::mutex::lock(v19);
    *(void *)&long long buf = v21;
    long long v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)&buf);
    if (v25)
    {
      uint64_t v27 = v25[3];
      long long v26 = (std::__shared_weak_count *)v25[4];
      if (v26)
      {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v20);
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v26);
        char v28 = 0;
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v27 = 0;
    }
    std::mutex::unlock(v20);
    long long v26 = 0;
    char v28 = 1;
LABEL_21:
    uint64_t v29 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v27 + 96))(&cf, v27, v29, 1, @"mRABAvoidanceDisabled", kCFBooleanFalse, 0);
    if ((v28 & 1) == 0) {
      sub_10004D2C8(v26);
    }
    int v30 = (BOOL *)cf;
    LOBYTE(buf) = 0;
    if (cf)
    {
      CFTypeID v31 = CFGetTypeID(cf);
      if (v31 == CFBooleanGetTypeID()) {
        ctu::cf::assign((ctu::cf *)&buf, v30, v32);
      }
    }
    int v33 = buf;
    sub_100224000(*(Registry **)(a1 + 72), &buf);
    BOOL v34 = CallController::anyCallsConnected((CallController *)buf, 1);
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
    if (v18 != 2 || !v34) {
      goto LABEL_48;
    }
    long long v36 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 72));
    long long v37 = v36;
    if (v38 < 0)
    {
      long long v39 = (unsigned __int8 *)(v38 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v40 = 5381;
      do
      {
        uint64_t v38 = v40;
        unsigned int v41 = *v39++;
        uint64_t v40 = (33 * v40) ^ v41;
      }
      while (v41);
    }
    std::mutex::lock(v36);
    *(void *)&long long buf = v38;
    long long v42 = sub_10004D37C(&v37[1].__m_.__sig, (unint64_t *)&buf);
    if (v42)
    {
      uint64_t v43 = v42[3];
      long long v44 = (std::__shared_weak_count *)v42[4];
      if (v44)
      {
        atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v37);
        atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v44);
        char v45 = 0;
LABEL_40:
        uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v43 + 16))(v43);
        if ((v45 & 1) == 0) {
          sub_10004D2C8(v44);
        }
        if (v33) {
          char v46 = v14;
        }
        else {
          char v46 = 0;
        }
        if ((v46 & 1) == 0) {
          goto LABEL_49;
        }
        long long v47 = *(NSObject **)(a1 + 64);
        uint64_t v14 = 0;
        if (!os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_49;
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "tearDownNonAsserted";
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I %s: In mRAB situation but mRABAvoidanceDisabled is set to true", (uint8_t *)&buf, 0xCu);
LABEL_48:
        uint64_t v14 = 0;
LABEL_49:
        sub_1000577C4(&cf);
        goto LABEL_50;
      }
    }
    else
    {
      uint64_t v43 = 0;
    }
    std::mutex::unlock(v37);
    long long v44 = 0;
    char v45 = 1;
    goto LABEL_40;
  }
  char v16 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I tearDownNonAsserted: this is a secondary data connection on non-preferred data SIM, so we decided to tear it down", (uint8_t *)&buf, 2u);
    uint64_t v14 = 1;
  }
LABEL_50:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  return v14;
}

void sub_100367290(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v4);
  }
  sub_1000577C4((const void **)va);
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100367318(uint64_t a1, uint64_t a2)
{
  return sub_100366DFC(a1 - 24, a2);
}

uint64_t sub_100367320(uint64_t a1, int a2, unsigned char *a3)
{
  if (ApplePDPHelperInterface::getInstance((ApplePDPHelperInterface *)a1))
  {
    *a3 = 1;
    uint64_t v6 = *(NSObject **)(a1 + 64);
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    if (v7)
    {
      int v8 = *(_DWORD *)(a1 + 112);
      uint64_t v9 = a2 ^ 1u;
      int v14 = 136315650;
      uint64_t v15 = "enableOutgoingTraffic";
      __int16 v16 = 1024;
      int v17 = v8;
      __int16 v18 = 1024;
      int v19 = a2 ^ 1;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: pdp=%d, block traffic = %d", (uint8_t *)&v14, 0x18u);
    }
    else
    {
      uint64_t v9 = a2 ^ 1u;
    }
    uint64_t Instance = ApplePDPHelperInterface::getInstance((ApplePDPHelperInterface *)v7);
    return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)Instance + 48))(Instance, *(unsigned int *)(a1 + 112), v9);
  }
  else
  {
    char v10 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = *(_DWORD *)(a1 + 112);
      int v14 = 136315650;
      uint64_t v15 = "enableOutgoingTraffic";
      __int16 v16 = 1024;
      int v17 = v11;
      __int16 v18 = 1024;
      int v19 = a2 ^ 1;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E %s: NO INSTANCE: pdp=%d, block traffic = %d", (uint8_t *)&v14, 0x18u);
    }
    uint64_t result = 0;
    *a3 = 0;
  }
  return result;
}

uint64_t sub_1003674B0(uint64_t a1, int a2, unsigned char *a3)
{
  return sub_100367320(a1 - 24, a2, a3);
}

unint64_t sub_1003674B8()
{
  v1.tv_sec = 0;
  *(void *)&v1.tv_usec = 0;
  gettimeofday(&v1, 0);
  return 1000 * v1.tv_sec + v1.tv_usec / 0x3E8uLL;
}

unint64_t sub_100367510()
{
  v1.tv_sec = 0;
  *(void *)&v1.tv_usec = 0;
  gettimeofday(&v1, 0);
  return 1000 * v1.tv_sec + v1.tv_usec / 0x3E8uLL;
}

void sub_100367568(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1[9]);
  uint64_t v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v19 = v10;
  int v14 = sub_10004D37C(&v9[1].__m_.__sig, &v19);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  char v17 = 1;
LABEL_9:
  uint64_t v18 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v16 + 96))(v16, v18, 1, a2, a3, a4);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_1003676B0(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003676C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1003676D0(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1[9]);
  uint64_t v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v19 = v10;
  int v14 = sub_10004D37C(&v9[1].__m_.__sig, &v19);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  char v17 = 1;
LABEL_9:
  uint64_t v18 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v16 + 104))(v16, v18, 1, a2, a3, a4);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_100367818(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100367830(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

uint64_t sub_100367838(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 72));
  char v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    uint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v3;
  BOOL v7 = sub_10004D37C(&v2[1].__m_.__sig, &v13);
  if (v7)
  {
    uint64_t v9 = v7[3];
    int v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      if (!v9) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  int v8 = 0;
  char v10 = 1;
  if (!v9)
  {
LABEL_7:
    uint64_t v11 = 0;
    if (v10) {
      return v11;
    }
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 24))(v9);
  if ((v10 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v8);
  return v11;
}

void sub_100367950(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10036796C(uint64_t a1)
{
  return sub_100367838(a1 - 24);
}

uint64_t sub_100367974(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 72));
  char v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    uint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v3;
  BOOL v7 = sub_10004D37C(&v2[1].__m_.__sig, &v13);
  if (v7)
  {
    uint64_t v9 = v7[3];
    int v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      if (!v9) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  int v8 = 0;
  char v10 = 1;
  if (!v9)
  {
LABEL_7:
    uint64_t v11 = 0;
    if (v10) {
      return v11;
    }
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 16))(v9);
  if ((v10 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v8);
  return v11;
}

void sub_100367A8C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100367AA8(uint64_t a1)
{
  return sub_100367974(a1 - 24);
}

uint64_t sub_100367AB0(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 72));
  char v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    uint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v3;
  BOOL v7 = sub_10004D37C(&v2[1].__m_.__sig, &v13);
  if (v7)
  {
    uint64_t v9 = v7[3];
    int v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      if (!v9) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  int v8 = 0;
  char v10 = 1;
  if (!v9)
  {
LABEL_7:
    uint64_t v11 = 0;
    if (v10) {
      return v11;
    }
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 32))(v9);
  if ((v10 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v8);
  return v11;
}

void sub_100367BC8(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100367BE4(uint64_t a1)
{
  return sub_100367AB0(a1 - 24);
}

void sub_100367C14(PersonalitySpecificImpl *a1, int a2, unint64_t a3)
{
  ConnectionMaskToTypes((uint64_t *)&v6, a3);
  uint64_t v4 = v6;
  uint64_t v5 = v7;
  if (v6 != v7)
  {
    do
    {
      PersonalitySpecificImpl::simSlot(a1);
      sub_100367CE0();
      v4 += 4;
    }
    while (v4 != v5);
    uint64_t v4 = v6;
  }
  if (v4)
  {
    BOOL v7 = v4;
    operator delete(v4);
  }
}

void sub_100367CC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100367CE0()
{
  xpc_object_t v3 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/events/qos_flow_change");
  xpc_object_t object = v3;
  xpc_object_t v3 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_100367D74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_100367DB8(uint64_t a1, int a2, unint64_t a3)
{
}

void sub_100367DC0(PersonalitySpecificImpl *a1, int a2, unint64_t a3)
{
  ConnectionMaskToTypes((uint64_t *)&v6, a3);
  uint64_t v4 = v6;
  uint64_t v5 = v7;
  if (v6 != v7)
  {
    do
    {
      PersonalitySpecificImpl::simSlot(a1);
      sub_100367CE0();
      v4 += 4;
    }
    while (v4 != v5);
    uint64_t v4 = v6;
  }
  if (v4)
  {
    BOOL v7 = v4;
    operator delete(v4);
  }
}

void sub_100367E64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100367E80(uint64_t a1, int a2, unint64_t a3)
{
}

void *sub_100367E88(void *a1, const void *a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    sub_10004EF30(a1, a3);
    unsigned int v6 = (char *)a1[1];
    memmove(v6, a2, 8 * a3);
    a1[1] = &v6[8 * a3];
  }
  return a1;
}

void sub_100367EF0(_Unwind_Exception *exception_object)
{
  xpc_object_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100367F0C(uint64_t a1)
{
  char v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

unint64_t sub_100367F40(Registry **a1, __int32 a2, __int32 a3, uint64_t a4)
{
  v68[0] = 0;
  v68[1] = 0;
  std::locale v67 = (uint64_t *)v68;
  uint64_t v5 = (sd::IMSSubscriberConfigInterface *)capabilities::ct::supportsLLFiltersIMS((capabilities::ct *)a1);
  if (!v5) {
    goto LABEL_18;
  }
  int v6 = sd::IMSSubscriberConfigInterface::APOnlyModeDefaultVal(v5);
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1[9]);
  int v8 = ServiceMap;
  if (v9 < 0)
  {
    char v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v77 = v9;
  unint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v77);
  if (v13)
  {
    uint64_t v15 = v13[3];
    int v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  int v14 = 0;
  char v16 = 1;
  if (v15)
  {
LABEL_11:
    uint64_t v17 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    int v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v15 + 288))(v15, v17);
  }
LABEL_12:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  if (v6)
  {
    uint64_t v18 = (uint64_t *)operator new(0xCuLL);
    *uint64_t v18 = 0x700000001;
    *((_DWORD *)v18 + 2) = 8;
    unint64_t v19 = sub_100368DE4(&v67, 0x20000uLL, &qword_10148FCA8);
    long long v20 = (uint64_t *)((char *)v18 + 12);
    uint64_t v21 = v19[5];
    if (v21)
    {
      v19[6] = v21;
      operator delete(v21);
      v19[5] = 0;
      v19[6] = 0;
      v19[7] = 0;
    }
    v19[5] = v18;
    v19[6] = v20;
    v19[7] = v20;
  }
LABEL_18:
  CFArrayRef theArray = 0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CC60, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0CC60))
  {
    *(void *)&long long v77 = @"LowLatencyTraffic";
    sub_100367E88(qword_101B0CC68, &v77, 1uLL);
    __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0CC68, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0CC60);
  }
  char v22 = (std::mutex *)Registry::getServiceMap(a1[9]);
  uint64_t v23 = v22;
  if (v24 < 0)
  {
    long long v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v26 = 5381;
    do
    {
      uint64_t v24 = v26;
      unsigned int v27 = *v25++;
      uint64_t v26 = (33 * v26) ^ v27;
    }
    while (v27);
  }
  std::mutex::lock(v22);
  *(void *)&long long v77 = v24;
  char v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)&v77);
  if (v28)
  {
    uint64_t v30 = v28[3];
    uint64_t v29 = (std::__shared_weak_count *)v28[4];
    if (v29)
    {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v23);
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v29);
      char v31 = 0;
      goto LABEL_27;
    }
  }
  else
  {
    uint64_t v30 = 0;
  }
  std::mutex::unlock(v23);
  uint64_t v29 = 0;
  char v31 = 1;
LABEL_27:
  uint64_t v32 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, void *, void, void))(*(void *)v30 + 104))(&__p, v30, v32, 1, qword_101B0CC68, 0, 0);
  sub_100044D6C(v73, (CFTypeRef *)&__p);
  *(void *)&long long v77 = theArray;
  CFArrayRef theArray = (CFArrayRef)v73[0];
  v73[0] = 0;
  sub_100044D00((const void **)&v77);
  sub_100044D00((const void **)v73);
  sub_1000577C4((const void **)&__p);
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v29);
  }
  if (theArray) {
    int v33 = sub_100083F10;
  }
  else {
    int v33 = 0;
  }
  if (v33)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
        CFDictionaryRef v37 = ValueAtIndex;
        if (ValueAtIndex)
        {
          CFTypeID v38 = CFGetTypeID(ValueAtIndex);
          if (v38 == CFDictionaryGetTypeID())
          {
            if (CFDictionaryGetValue(v37, @"QciList"))
            {
              v73[0] = 0;
              v73[1] = 0;
              uint64_t v74 = 0;
              long long v77 = 0uLL;
              uint64_t v78 = 0;
              ctu::cf::assign();
              *(_OWORD *)v73 = v77;
              uint64_t v74 = v78;
              long long v77 = 0uLL;
              uint64_t v78 = 0;
              ctu::tokenize();
              long long __p = 0;
              v71 = 0;
              long long v72 = 0;
              uint64_t v40 = *((void *)&v77 + 1);
              uint64_t v39 = v77;
              if ((void)v77 != *((void *)&v77 + 1))
              {
                unsigned int v41 = 0;
                do
                {
                  long long v42 = (const char *)v39;
                  if (*(char *)(v39 + 23) < 0) {
                    long long v42 = *(const char **)v39;
                  }
                  int v43 = atoi(v42);
                  int v44 = v43;
                  if (v41 >= v72)
                  {
                    char v46 = (char *)__p;
                    uint64_t v47 = (v41 - (unsigned char *)__p) >> 2;
                    unint64_t v48 = v47 + 1;
                    if ((unint64_t)(v47 + 1) >> 62) {
                      sub_10006A748();
                    }
                    uint64_t v49 = v72 - (unsigned char *)__p;
                    if ((v72 - (unsigned char *)__p) >> 1 > v48) {
                      unint64_t v48 = v49 >> 1;
                    }
                    if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFFCLL) {
                      unint64_t v50 = 0x3FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v50 = v48;
                    }
                    if (v50)
                    {
                      uint64_t v51 = (char *)sub_10005ECD8((uint64_t)&v72, v50);
                      char v46 = (char *)__p;
                      unsigned int v41 = v71;
                    }
                    else
                    {
                      uint64_t v51 = 0;
                    }
                    uint64_t v52 = (int *)&v51[4 * v47];
                    *uint64_t v52 = v44;
                    char v45 = (char *)(v52 + 1);
                    while (v41 != v46)
                    {
                      int v53 = *((_DWORD *)v41 - 1);
                      v41 -= 4;
                      *--uint64_t v52 = v53;
                    }
                    long long __p = v52;
                    v71 = v45;
                    long long v72 = &v51[4 * v50];
                    if (v46) {
                      operator delete(v46);
                    }
                  }
                  else
                  {
                    *(_DWORD *)unsigned int v41 = v43;
                    char v45 = v41 + 4;
                  }
                  v71 = v45;
                  v39 += 24;
                  unsigned int v41 = v45;
                }
                while (v39 != v40);
              }
              Value = (unint64_t *)CFDictionaryGetValue(v37, @"ServiceMask");
              __int16 v55 = Value;
              if (Value)
              {
                long long v76 = 0;
                CFTypeID v56 = CFGetTypeID(Value);
                if (v56 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&v76, v55, v57);
                }
                unsigned __int8 v69 = v76;
                time_t v58 = (char *)(sub_100368DE4(&v67, (unint64_t)v76, &v69) + 5);
                if (v58 != (char *)&__p) {
                  sub_10008A534(v58, (char *)__p, (uint64_t)v71, (v71 - (unsigned char *)__p) >> 2);
                }
              }
              if (__p)
              {
                v71 = (char *)__p;
                operator delete(__p);
              }
              long long __p = &v77;
              sub_100047F64((void ***)&__p);
              if (SHIBYTE(v74) < 0) {
                operator delete(v73[0]);
              }
            }
          }
        }
      }
    }
  }
  sub_100044D00((const void **)&theArray);
  unint64_t v59 = sub_1003686B0((capabilities::ct *)&v67, a2, a4);
  uint64_t v60 = v59;
  if ((v59 & 0x100000000) != 0 && v59)
  {
    unint64_t v61 = (unint64_t)&_mh_execute_header;
  }
  else
  {
    unint64_t v62 = sub_1003686B0((capabilities::ct *)&v67, a3, a4);
    if (HIDWORD(v62))
    {
      uint64_t v60 = v62;
      unint64_t v61 = (unint64_t)&_mh_execute_header;
    }
    else
    {
      unint64_t v61 = v59 & (unint64_t)&_mh_execute_header;
    }
  }
  sub_100368D88(v68[0]);
  return v61 | v60;
}

void sub_100368594(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,const void *a25,uint64_t a26,char a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
}

unint64_t sub_1003686B0(capabilities::ct *a1, __int32 __c, uint64_t a3)
{
  xpc_object_t v3 = (void *)((char *)a1 + 8);
  uint64_t v4 = *(void **)a1;
  if (*(capabilities::ct **)a1 == (capabilities::ct *)((char *)a1 + 8))
  {
LABEL_13:
    int v12 = capabilities::ct::supportsIPCInterfaceConfig(a1);
    uint64_t v13 = 0;
    int v14 = &_mh_execute_header;
    if (!v12) {
      int v14 = 0;
    }
  }
  else
  {
    while (1)
    {
      if ((v4[4] & a3) != 0)
      {
        BOOL v7 = (capabilities::ct *)v4[6];
        a1 = (capabilities::ct *)wmemchr((__int32 *)v4[5], __c, ((uint64_t)v7 - v4[5]) >> 2);
        int v8 = a1 ? a1 : v7;
        if (v8 != (capabilities::ct *)v4[6]) {
          break;
        }
      }
      uint64_t v9 = (void *)v4[1];
      if (v9)
      {
        do
        {
          char v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          char v10 = (void *)v4[2];
          BOOL v11 = *v10 == (void)v4;
          uint64_t v4 = v10;
        }
        while (!v11);
      }
      uint64_t v4 = v10;
      if (v10 == v3) {
        goto LABEL_13;
      }
    }
    uint64_t v13 = 1;
    if ((a3 & 0x20000) != 0) {
      uint64_t v13 = 2;
    }
    int v14 = &_mh_execute_header;
  }
  return v13 | (unint64_t)v14;
}

uint64_t sub_10036878C(uint64_t a1, unsigned int a2, __int32 a3, __int32 a4, uint64_t a5)
{
  char v10 = (ApplePDPHelperInterface *)capabilities::ct::supportsLLFilters((capabilities::ct *)a1);
  if (!v10) {
    return 0;
  }
  if (!ApplePDPHelperInterface::getInstance(v10))
  {
    uint64_t v23 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "qosFlowAdded: AppleIPAppenderInterface not ready", buf, 2u);
    }
    return 0;
  }
  unint64_t v11 = sub_100367F40((Registry **)a1, a3, a4, a5);
  int v12 = v11;
  int v13 = BYTE4(v11);
  int v14 = *(NSObject **)(a1 + 64);
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (v15)
  {
    if (v13) {
      int v16 = v12;
    }
    else {
      int v16 = -1;
    }
    *(_DWORD *)long long buf = 67110144;
    unsigned int v28 = a2;
    LOWORD(v29) = 1024;
    *(_DWORD *)((char *)&v29 + 2) = a3;
    HIWORD(v29) = 1024;
    __int32 v30 = a4;
    __int16 v31 = 2048;
    uint64_t v32 = a5;
    __int16 v33 = 1024;
    int v34 = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I qosFlowAdded: bearerId=%u, qciRx=%u, qciTx=%u, cmask=0x%llx, service type=%d", buf, 0x24u);
  }
  if (!v13) {
    return 0;
  }
  unsigned int v17 = *(_DWORD *)(a1 + 112);
  *(_DWORD *)long long buf = 1;
  unsigned int v28 = v17;
  unint64_t v29 = __PAIR64__(v12, a2);
  v24[0] = 0;
  v24[1] = 0;
  uint64_t Instance = ApplePDPHelperInterface::getInstance((ApplePDPHelperInterface *)v15);
  char v19 = (*(uint64_t (**)(uint64_t, uint8_t *, void *))(*(void *)Instance + 16))(Instance, buf, v24);
  long long v20 = *(NSObject **)(a1 + 64);
  BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
  if ((v19 & 1) == 0)
  {
    if (v21)
    {
      *(_WORD *)long long v25 = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#N qosFlowAdded: notifyDedicatedBearer failed", v25, 2u);
    }
    return 0;
  }
  if (v21)
  {
    *(_DWORD *)long long v25 = 134217984;
    uint64_t v26 = v24[0];
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I qosFlowAdded: queueSetID=%llu", v25, 0xCu);
  }
  return v24[0];
}

uint64_t sub_1003689C0(uint64_t a1, unsigned int a2, __int32 a3, __int32 a4, uint64_t a5)
{
  return sub_10036878C(a1 - 24, a2, a3, a4, a5);
}

void sub_1003689C8(uint64_t a1, unsigned int a2, __int32 a3, __int32 a4, uint64_t a5)
{
  char v10 = (ApplePDPHelperInterface *)capabilities::ct::supportsLLFilters((capabilities::ct *)a1);
  if (v10)
  {
    if (ApplePDPHelperInterface::getInstance(v10))
    {
      unint64_t v11 = sub_100367F40((Registry **)a1, a3, a4, a5);
      int v12 = v11;
      int v13 = BYTE4(v11);
      int v14 = *(NSObject **)(a1 + 64);
      BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
      if (v15)
      {
        if (v13) {
          int v16 = v12;
        }
        else {
          int v16 = -1;
        }
        *(_DWORD *)long long buf = 67110144;
        unsigned int v24 = a2;
        LOWORD(v25) = 1024;
        *(_DWORD *)((char *)&v25 + 2) = a3;
        HIWORD(v25) = 1024;
        __int32 v26 = a4;
        __int16 v27 = 2048;
        uint64_t v28 = a5;
        __int16 v29 = 1024;
        int v30 = v16;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I qosFlowRemoved: bearerId=%u, qciRx=%u, qciTx=%u, cmask=0x%llx, service type=%d", buf, 0x24u);
      }
      if (v13)
      {
        unsigned int v17 = *(_DWORD *)(a1 + 112);
        *(_DWORD *)long long buf = 0;
        unsigned int v24 = v17;
        unint64_t v25 = __PAIR64__(v12, a2);
        v22[0] = 0;
        v22[1] = 0;
        uint64_t Instance = ApplePDPHelperInterface::getInstance((ApplePDPHelperInterface *)v15);
        if (((*(uint64_t (**)(uint64_t, uint8_t *, void *))(*(void *)Instance + 16))(Instance, buf, v22) & 1) == 0)
        {
          char v19 = *(NSObject **)(a1 + 64);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)BOOL v21 = 0;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#N qosFlowRemoved: notifyDedicatedBearer failed", v21, 2u);
          }
        }
      }
    }
    else
    {
      long long v20 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "qosFlowRemoved: AppleIPAppenderInterface not ready", buf, 2u);
      }
    }
  }
}

void sub_100368BB0(uint64_t a1, unsigned int a2, __int32 a3, __int32 a4, uint64_t a5)
{
}

void sub_100368BB8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100368C84(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[6], v1, (dispatch_function_t)sub_100368D5C);
  __cxa_rethrow();
}

void sub_100368CAC(_Unwind_Exception *a1)
{
}

void sub_100368CC4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100368CFC(uint64_t a1)
{
}

uint64_t sub_100368D18(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100368D5C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100368D88(void *a1)
{
  if (a1)
  {
    sub_100368D88(*a1);
    sub_100368D88(a1[1]);
    char v2 = (void *)a1[5];
    if (v2)
    {
      a1[6] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

uint64_t **sub_100368DE4(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  int v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        BOOL v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        int v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        int v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    BOOL v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)v7;
    BOOL v7 = (uint64_t **)operator new(0x40uLL);
    uint64_t v7[4] = *a3;
    v7[5] = 0;
    v7[6] = 0;
    v7[7] = 0;
    capabilities::ct *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *int v6 = (uint64_t *)v7;
    char v10 = (uint64_t *)**a1;
    unint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      unint64_t v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t sub_100368EBC()
{
  return 1;
}

uint64_t sub_100368EC4()
{
  return 1;
}

uint64_t sub_100368ECC()
{
  return 0;
}

uint64_t sub_100368ED4()
{
  return 0;
}

BOOL sub_100368EDC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  return v2 && *(unsigned __int8 *)(a1 + 26) != *(unsigned __int8 *)(v2 + 104);
}

BOOL sub_100368F00(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  return v2 && *(unsigned __int8 *)(a1 + 10) != *(unsigned __int8 *)(v2 + 104);
}

uint64_t sub_100368F24()
{
  return 0;
}

uint64_t sub_100368F2C()
{
  return 0;
}

uint64_t sub_100368F34(uint64_t a1, os_log_t *a2)
{
  xpc_object_t v3 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
  {
    uint64_t v5 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v6 = 136315138;
    BOOL v7 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Compression is not supported for this message", (uint8_t *)&v6, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_100368FE8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_100368FF0(uint64_t a1, os_log_t *a2)
{
  return sub_100368F34(a1 - 16, a2);
}

BOOL sub_100368FF8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  return v2 && *(unsigned char *)(v2 + 273) && *(void *)(v2 + 88) && *(void *)(v2 + 152) && *(void *)(v2 + 168) != 0;
}

BOOL sub_100369030(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  return v2 && *(unsigned char *)(v2 + 273) && *(void *)(v2 + 88) && *(void *)(v2 + 152) && *(void *)(v2 + 168) != 0;
}

uint64_t sub_100369068()
{
  return 1;
}

uint64_t sub_100369070()
{
  return 1;
}

void sub_100369078(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", buf, 0xCu);
  }
  uint64_t v8 = *(void *)(a2 + 8);
  if (!v8)
  {
    std::locale v67 = *(NSObject **)a2;
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      uint64_t v70 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v70;
      unsigned __int8 v69 = "[%s] Emergency environment doesn't exist";
      goto LABEL_104;
    }
LABEL_102:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
    return;
  }
  if (!*(unsigned char *)(v8 + 273) || !*(void *)(v8 + 88) || !*(void *)(v8 + 152) || !*(void *)(v8 + 168))
  {
    std::locale v67 = *(NSObject **)a2;
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      long long v68 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v68;
      unsigned __int8 v69 = "[%s] Emergency environment is not ready";
LABEL_104:
      _os_log_error_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, v69, buf, 0xCu);
      goto LABEL_102;
    }
    goto LABEL_102;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v74 = 0;
  v71 = 0;
  long long v72 = 0;
  sub_100BDEDF4(v8, &v71);
  unsigned int v9 = sub_10112625C(*(void *)(a2 + 8));
  uint64_t v10 = *(void *)(a2 + 8);
  if (v71) {
    unsigned int v11 = *(unsigned __int8 *)(a1 + 27);
  }
  else {
    unsigned int v11 = 0;
  }
  uint64_t v12 = *(char *)(v10 + 344);
  unint64_t v13 = sub_101125A48(v10);
  unsigned int v14 = v13;
  int v15 = BYTE4(v13);
  int v16 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v17 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    if (v12 > 3) {
      uint64_t v18 = "???";
    }
    else {
      uint64_t v18 = off_1019BE800[v12];
    }
    if (v9 > 4) {
      char v19 = "???";
    }
    else {
      char v19 = off_1019BE7D8[(char)v9];
    }
    unint64_t v20 = *(char *)(a1 + 27);
    if (v20 > 2) {
      BOOL v21 = "???";
    }
    else {
      BOOL v21 = off_1019BE840[v20];
    }
    int v22 = *(unsigned __int8 *)(a1 + 26);
    if (v11 > 2) {
      uint64_t v23 = "???";
    }
    else {
      uint64_t v23 = off_1019BE840[(char)v11];
    }
    unsigned int v24 = "yes";
    int v25 = *(unsigned __int8 *)(a1 + 56);
    if (v71) {
      __int32 v26 = "yes";
    }
    else {
      __int32 v26 = "no";
    }
    *(_DWORD *)long long buf = 136317442;
    if (!v25) {
      unsigned int v24 = "no";
    }
    *(void *)&uint8_t buf[4] = v17;
    *(_WORD *)&unsigned char buf[12] = 1024;
    if (v15) {
      unsigned int v27 = v14;
    }
    else {
      unsigned int v27 = 0;
    }
    *(_DWORD *)&buf[14] = v22;
    *(_WORD *)&buf[18] = 2080;
    *(void *)&buf[20] = "kAny";
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = v18;
    __int16 v79 = 2080;
    long long v80 = v19;
    __int16 v81 = 2080;
    uint64_t v82 = v21;
    __int16 v83 = 2080;
    uint64_t v84 = v23;
    __int16 v85 = 2080;
    v86 = v26;
    __int16 v87 = 2080;
    v88 = v24;
    __int16 v89 = 1024;
    unsigned int v90 = v27;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I [%s] ConversationID: %hhu, lineID: %s, user incapacitated: %s, battery: %s, notify option: %s, adjusted notify option: %s, has cloaking key: %s, has questionnaire answer: %s, preferred codec id: %u", buf, 0x5Eu);
  }
  memset(buf, 0, 32);
  sub_10024060C((uint64_t)buf, 0xC8uLL);
  if (sub_1002B45F4(*(void *)(a2 + 8)))
  {
    sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 24), 2uLL);
    sub_10024081C((unint64_t *)buf, 0, 6uLL);
    os_log_t v28 = *(os_log_t *)a2;
    if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_45;
    }
    __int16 v29 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    unint64_t v30 = *(char *)(a1 + 24);
    if (v30 > 4) {
      __int16 v31 = "???";
    }
    else {
      __int16 v31 = off_1019BE7B0[v30];
    }
    *(_DWORD *)long long v76 = 136315650;
    *(void *)&v76[4] = v29;
    *(_WORD *)&v76[12] = 2080;
    *(void *)&v76[14] = v31;
    *(_WORD *)&v76[22] = 2080;
    long long v77 = "kFakeEmergencyStart";
    long long v35 = "#I [%s] Mock mode is enabled. Serialized header: Version: %s, MessageType: %s";
    long long v36 = v28;
    uint32_t v37 = 32;
  }
  else
  {
    sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 24), 2uLL);
    sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 25), 6uLL);
    os_log_t v32 = *(os_log_t *)a2;
    if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_45;
    }
    unint64_t v33 = *(char *)(a1 + 24);
    if (v33 > 4) {
      int v34 = "???";
    }
    else {
      int v34 = off_1019BE7B0[v33];
    }
    CFTypeID v38 = sub_10093AA7C(*(unsigned __int8 *)(a1 + 25));
    *(_DWORD *)long long v76 = 136315394;
    *(void *)&v76[4] = v34;
    *(_WORD *)&v76[12] = 2080;
    *(void *)&v76[14] = v38;
    long long v35 = "#I Serialized header: Version: %s, MessageType: %s";
    long long v36 = v32;
    uint32_t v37 = 22;
  }
  _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, v35, v76, v37);
LABEL_45:
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 26), 8uLL);
  uint64_t v39 = *(void *)(a2 + 8);
  uint64_t v40 = *(double **)(v39 + 88);
  unsigned int v41 = *(std::__shared_weak_count **)(v39 + 96);
  if (v41) {
    atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10104992C(v40, a2, (unint64_t *)buf);
  sub_10024081C((unint64_t *)buf, 3, 2uLL);
  sub_10024081C((unint64_t *)buf, v12, 2uLL);
  sub_10024081C((unint64_t *)buf, v9, 2uLL);
  sub_10024081C((unint64_t *)buf, v11, 1uLL);
  sub_100BDEAE8(*(void *)(a2 + 8) + 296, v11);
  sub_100BDEA38(*(void *)(a2 + 8), v11);
  sub_10024081C((unint64_t *)buf, v71 != 0, 1uLL);
  if (*(void *)&buf[24]) {
    __TUAssertTrigger();
  }
  if (v71)
  {
    long long v42 = (unsigned char *)*v71;
    int v43 = (unsigned char *)v71[1];
    *(void *)long long v76 = buf;
    while (v42 != v43)
      sub_100240714((unint64_t **)v76, v42++);
  }
  sub_10024081C((unint64_t *)buf, 0, 4uLL);
  if (v15)
  {
    unint64_t v44 = v14;
    LODWORD(v45) = v14 & 7;
    if (v14 >= 8uLL)
    {
      do
      {
        sub_10024081C((unint64_t *)buf, v45 | 8, 4uLL);
        uint64_t v45 = (v44 >> 3) & 7;
        BOOL v46 = v44 > 0x3F;
        v44 >>= 3;
      }
      while (v46);
    }
  }
  else
  {
    LODWORD(v45) = 0;
  }
  sub_10024081C((unint64_t *)buf, v45, 4uLL);
  *(void *)&unsigned char buf[24] = 0;
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v47 = *(unsigned char **)(a1 + 32);
    unint64_t v48 = *(unsigned char **)(a1 + 40);
    *(void *)long long v76 = buf;
    while (v47 != v48)
      sub_100240714((unint64_t **)v76, v47++);
  }
  long long v49 = *(_OWORD *)__p;
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  *(_OWORD *)long long buf = v49;
  uint64_t v50 = v74;
  uint64_t v74 = *(void *)&buf[16];
  *(void *)&uint8_t buf[16] = v50;
  if (!v41)
  {
    uint64_t v51 = (void *)v49;
    if (!(void)v49) {
      goto LABEL_65;
    }
    goto LABEL_64;
  }
  sub_10004D2C8(v41);
  uint64_t v51 = *(void **)buf;
  if (*(void *)buf)
  {
LABEL_64:
    *(void *)&uint8_t buf[8] = v51;
    operator delete(v51);
  }
LABEL_65:
  uint64_t v52 = *(void *)(a2 + 8);
  uint64_t v54 = *(void *)(v52 + 168);
  int v53 = *(std::__shared_weak_count **)(v52 + 176);
  if (v53) {
    atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __int16 v55 = (char *)__p[0];
  uint64_t v56 = *(unsigned __int8 *)__p[0];
  uint64_t v57 = *((unsigned __int8 *)__p[0] + 1);
  time_t v58 = operator new(8uLL);
  *time_t v58 = v56 | (v57 << 8);
  *(void *)&v76[8] = v58 + 1;
  *(void *)&v76[16] = v58 + 1;
  *(void *)long long v76 = v58;
  unint64_t v59 = (char *)((char *)__p[1] - (char *)v55);
  if ((void *)((char *)__p[1] - (char *)v55) <= (void *)2)
  {
    __TUAssertTrigger();
    __int16 v55 = (char *)__p[0];
    unint64_t v59 = (char *)((char *)__p[1] - (char *)__p[0]);
  }
  memset(buf, 0, 32);
  sub_100BCAA0C((os_log_t *)a2, v54, (uint64_t)v76, v55 + 2, (size_t)(v59 - 2), buf);
  int v60 = buf[24];
  if (buf[24])
  {
    unint64_t v61 = (char *)__p[0];
    unint64_t v62 = (char *)__p[1] - (char *)__p[0];
    if ((char *)__p[1] - (char *)__p[0] != *(void *)&buf[8] - *(void *)buf + 2)
    {
      __TUAssertTrigger();
      unint64_t v61 = (char *)__p[0];
      unint64_t v62 = (char *)__p[1] - (char *)__p[0];
    }
    if (v62 > 1)
    {
      if (v62 != 2) {
        __p[1] = v61 + 2;
      }
    }
    else
    {
      sub_10011FDF0((unint64_t *)__p, 2 - v62);
    }
    if (!buf[24]) {
      sub_10016C840();
    }
    unint64_t v64 = *(unsigned char **)buf;
    uint64_t v65 = *(unsigned char **)&buf[8];
    *(void *)long long v75 = __p;
    while (v64 != v65)
      sub_100240714((unint64_t **)v75, v64++);
  }
  else
  {
    uint64_t v63 = *(NSObject **)a2;
    if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
    {
      long long v66 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)long long v75 = 136315138;
      *(void *)&v75[4] = v66;
      _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "[%s] Failed to encrypt", v75, 0xCu);
    }
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
  }
  if (buf[24] && *(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  if (*(void *)v76) {
    operator delete(*(void **)v76);
  }
  if (v53) {
    sub_10004D2C8(v53);
  }
  if (v60)
  {
    *(_OWORD *)a3 = *(_OWORD *)__p;
    *(void *)(a3 + 16) = v74;
    __p[1] = 0;
    uint64_t v74 = 0;
    __p[0] = 0;
    *(unsigned char *)(a3 + 24) = 1;
  }
  if (v72) {
    sub_10004D2C8(v72);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1003698E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,char a24)
{
  operator delete(v25);
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_1003699B0(void *a1, const void *a2, size_t __sz)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (__sz)
  {
    sub_10005C9F8(a1, __sz);
    int v6 = (char *)a1[1];
    memmove(v6, a2, __sz);
    a1[1] = &v6[__sz];
  }
  return a1;
}

void sub_100369A18(_Unwind_Exception *exception_object)
{
  xpc_object_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100369A34(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_100369A3C()
{
  return 0;
}

uint64_t sub_100369A44()
{
  return 0;
}

void sub_100369A4C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3)
  {
    sub_101125470(v3);
  }
  else
  {
    uint64_t v4 = *(NSObject **)a2;
    if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      int v6 = 136315138;
      BOOL v7 = v5;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "[%s] Emergency environment doesn't exist", (uint8_t *)&v6, 0xCu);
    }
  }
}

void sub_100369B34(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100369B44()
{
  return 1;
}

uint64_t sub_100369B4C()
{
  return 1;
}

uint64_t sub_100369B54()
{
  return 0;
}

uint64_t sub_100369B5C()
{
  return 0;
}

BOOL sub_100369B64(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  return v2 && *(unsigned __int8 *)(a1 + 26) != *(unsigned __int8 *)(v2 + 104);
}

BOOL sub_100369B88(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  return v2 && *(unsigned __int8 *)(a1 + 10) != *(unsigned __int8 *)(v2 + 104);
}

BOOL sub_100369BAC(void *a1, uint64_t a2)
{
  if (!*(void *)(a2 + 8)) {
    return 0;
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 16);
  v6[0] = *(void *)(a2 + 8);
  v6[1] = (uint64_t)v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (sub_1004D0838(a2, v6) == 3 && a1[4] != a1[5])
  {
    BOOL v4 = a1[8] == 0;
    if (!v3) {
      return v4;
    }
    goto LABEL_9;
  }
  BOOL v4 = 0;
  if (v3) {
LABEL_9:
  }
    sub_10004D2C8(v3);
  return v4;
}

void sub_100369C48(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100369C60(uint64_t a1, uint64_t a2)
{
  return sub_100369BAC((void *)(a1 - 16), a2);
}

void sub_100369C68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1 + 32;
  if (*(void *)(a1 + 32) == *(void *)(a1 + 40)) {
    __TUAssertTrigger();
  }
  BOOL v7 = *(unsigned char **)(a1 + 64);
  if (v7)
  {
    int v16 = *(NSObject **)a2;
    if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v18 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      char v19 = "complete";
      if (!*v7) {
        char v19 = "in progress";
      }
      *(_DWORD *)long long buf = 136315394;
      __int32 v26 = v18;
      __int16 v27 = 2080;
      os_log_t v28 = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "[%s] Compression attempt is already %s", buf, 0x16u);
    }
    goto LABEL_14;
  }
  uint64_t v8 = *(void *)(a2 + 8);
  if (!v8)
  {
    unsigned int v17 = *(NSObject **)a2;
    if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
    {
      unint64_t v20 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)long long buf = 136315138;
      __int32 v26 = v20;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "[%s] Emergency environment doesn't exist", buf, 0xCu);
    }
LABEL_14:
    __TUAssertTrigger();
    return;
  }
  unint64_t v9 = sub_101125A48(v8);
  if ((v9 & 0xFF00000000) != 0)
  {
    unint64_t v10 = v9;
    unsigned int v11 = (std::__shared_weak_count *)operator new(0x20uLL);
    v11->__shared_owners_ = 0;
    v11->__shared_weak_owners_ = 0;
    v11->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3378;
    LOBYTE(v11[1].__vftable) = 0;
    uint64_t v12 = v11 + 1;
    unint64_t v13 = *(std::__shared_weak_count **)(a1 + 72);
    *(void *)(a1 + 64) = v11 + 1;
    *(void *)(a1 + 72) = v11;
    if (!v13
      || (sub_10004D2C8(v13),
          uint64_t v12 = *(std::__shared_weak_count **)(a1 + 64),
          (unsigned int v11 = *(std::__shared_weak_count **)(a1 + 72)) != 0))
    {
      atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v14 = *(void *)(a2 + 24);
    *(void *)&long long v21 = a1;
    *((void *)&v21 + 1) = v12;
    int v22 = v11;
    sub_10036CD68((uint64_t)v23, a3);
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v24, (const ctu::OsLogLogger *)a2);
    __int16 v29 = 0;
    int v15 = (char *)operator new(0x48uLL);
    *(void *)int v15 = off_1019BE698;
    *(_OWORD *)(v15 + 8) = v21;
    *((void *)v15 + 3) = v22;
    sub_10036CD68((uint64_t)(v15 + 32), (uint64_t)v23);
    ctu::OsLogLogger::OsLogLogger();
    __int16 v29 = v15;
    (*(void (**)(uint64_t, unint64_t, uint64_t, uint8_t *))(*(void *)v14 + 16))(v14, v10, v6, buf);
    sub_1002726E4(buf);
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v24);
    sub_10026E5BC(v23);
  }
  else
  {
    __TUAssertTrigger();
  }
}

void sub_100369F94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t sub_100369FDC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

void *sub_100369FE4(void *a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 7));
  sub_10026E5BC(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10036A024(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

BOOL sub_10036A02C(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (!v2 || !*(unsigned char *)(v2 + 274)) {
    return 0;
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a2 + 16);
  v10[0] = *(void *)(a2 + 8);
  v10[1] = (uint64_t)v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v6 = sub_1004D0838(a2, v10);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v6 >= 2
    && (a1[4] == a1[5] || v6 != 3 || (BOOL v7 = (unsigned char *)a1[8]) != 0 && *v7)
    && (uint64_t v8 = *(void *)(a2 + 8), *(unsigned char *)(v8 + 273))
    && *(void *)(v8 + 88)
    && *(void *)(v8 + 152))
  {
    return *(void *)(v8 + 168) != 0;
  }
  else
  {
    return 0;
  }
}

void sub_10036A100(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10036A118(uint64_t a1, uint64_t a2)
{
  return sub_10036A02C((void *)(a1 - 16), a2);
}

uint64_t sub_10036A120()
{
  return 0;
}

uint64_t sub_10036A128()
{
  return 0;
}

void sub_10036A130(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  unsigned int v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", buf, 0xCu);
  }
  uint64_t v8 = *(void *)(a2 + 8);
  if (!v8)
  {
    __int16 v55 = *(NSObject **)a2;
    if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
      goto LABEL_84;
    }
    time_t v58 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v58;
    uint64_t v57 = "[%s] Emergency environment doesn't exist";
    goto LABEL_83;
  }
  if (!*(unsigned char *)(v8 + 273) || !*(void *)(v8 + 88) || !*(void *)(v8 + 152) || !*(void *)(v8 + 168))
  {
    __int16 v55 = *(NSObject **)a2;
    if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
      goto LABEL_84;
    }
    uint64_t v56 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v56;
    uint64_t v57 = "[%s] Emergency environment is not ready";
LABEL_83:
    _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, v57, buf, 0xCu);
    goto LABEL_84;
  }
  if (!*(unsigned char *)(v8 + 274))
  {
    __int16 v55 = *(NSObject **)a2;
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      unint64_t v59 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v59;
      uint64_t v57 = "[%s] Emergency start message hasn't been acked yet";
      goto LABEL_83;
    }
LABEL_84:
    *a3 = 0;
    a3[24] = 0;
    return;
  }
  if (*(unsigned char *)(a1 + 60))
  {
    if (!*(_DWORD *)(a1 + 56))
    {
      __TUAssertTrigger();
      uint64_t v8 = *(void *)(a2 + 8);
    }
    unint64_t v9 = sub_101125A48(v8);
    int v10 = v9;
    if ((v9 & 0xFF00000000) == 0) {
      __TUAssertTrigger();
    }
    if (*(_DWORD *)(a1 + 56) == v10) {
      unsigned __int8 v11 = 1;
    }
    else {
      unsigned __int8 v11 = 2;
    }
    uint64_t v8 = *(void *)(a2 + 8);
  }
  else
  {
    unsigned __int8 v11 = 0;
  }
  unsigned int v12 = sub_100BDE8A4(v8 + 296, 0);
  if (v12 == 2) {
    unsigned int v13 = 0;
  }
  else {
    unsigned int v13 = v12;
  }
  sub_100BDEA38(*(void *)(a2 + 8), v13);
  memset(__p, 0, 24);
  memset(buf, 0, 32);
  sub_10024060C((uint64_t)buf, 0xC8uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 24), 2uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 25), 6uLL);
  uint64_t v14 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v15 = *(char *)(a1 + 24);
    if (v15 > 4) {
      int v16 = "???";
    }
    else {
      int v16 = off_1019BE7B0[v15];
    }
    unsigned int v17 = sub_10093AA7C(*(unsigned __int8 *)(a1 + 25));
    *(_DWORD *)uint64_t v63 = 136315394;
    *(void *)&v63[4] = v16;
    *(_WORD *)&v63[12] = 2080;
    *(void *)&v63[14] = v17;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Serialized header: Version: %s, MessageType: %s", v63, 0x16u);
  }
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 26), 8uLL);
  sub_10024081C((unint64_t *)buf, v11, 2uLL);
  sub_10024081C((unint64_t *)buf, v13, 1uLL);
  unsigned int v18 = *(unsigned __int16 *)(a1 + 28);
  sub_10024081C((unint64_t *)buf, v18 >> 8, 5uLL);
  sub_10024081C((unint64_t *)buf, v18, 8uLL);
  if (v11 == 2)
  {
    unint64_t v19 = *(unsigned int *)(a1 + 56);
    if (v19 >= 0x80)
    {
      do
      {
        sub_10024081C((unint64_t *)buf, v19 | 0x80, 8uLL);
        unint64_t v20 = v19 >> 7;
        unint64_t v21 = v19 >> 14;
        v19 >>= 7;
      }
      while (v21);
    }
    else
    {
      LODWORD(v20) = *(_DWORD *)(a1 + 56);
    }
    sub_10024081C((unint64_t *)buf, v20 & 0x7F, 8uLL);
  }
  if (*(void *)&buf[24]) {
    __TUAssertTrigger();
  }
  int v22 = __p[0];
  uint64_t v23 = __p[2];
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  __p[2] = *(void **)&buf[16];
  *(void *)long long buf = v22;
  *(void *)&uint8_t buf[16] = v23;
  uint64_t v24 = *(unsigned char **)(a1 + 32);
  int v25 = *(unsigned char **)(a1 + 40);
  if (v25 == v24)
  {
    os_log_t v32 = *(NSObject **)a2;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      int v53 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v53;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "[%s] No text. Failed to encode", buf, 0xCu);
    }
    *a3 = 0;
    a3[24] = 0;
    unint64_t v33 = __p[0];
  }
  else
  {
    *(void *)long long buf = __p;
    do
      sub_100240714((unint64_t **)buf, v24++);
    while (v24 != v25);
    __int32 v26 = *(NSObject **)a2;
    if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v27 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      int v28 = *(unsigned __int8 *)(a1 + 60);
      if (*(unsigned char *)(a1 + 60)) {
        int v28 = *(_DWORD *)(a1 + 56);
      }
      int v29 = *(unsigned __int8 *)(a1 + 26);
      unint64_t v30 = off_1019BE798[v11];
      if (v13 > 2) {
        __int16 v31 = "???";
      }
      else {
        __int16 v31 = off_1019BE840[(char)v13];
      }
      int v34 = *(unsigned __int16 *)(a1 + 28);
      uint64_t v35 = *(void *)(a1 + 40) - *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 136316674;
      *(void *)&uint8_t buf[4] = v27;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v29;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = v30;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v28;
      __int16 v65 = 2080;
      long long v66 = v31;
      __int16 v67 = 1024;
      int v68 = v34;
      __int16 v69 = 2048;
      uint64_t v70 = v35;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I [%s] ConversationID: %hhu, Encoding: %s[%u], Notify option: %s, Outgoing sequence number: %hu, Text size: %zu", buf, 0x3Cu);
    }
    long long v36 = a3;
    uint64_t v37 = *(void *)(a2 + 8);
    uint64_t v39 = *(void *)(v37 + 168);
    CFTypeID v38 = *(std::__shared_weak_count **)(v37 + 176);
    if (v38) {
      atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v60 = v38;
    uint64_t v40 = (char *)__p[0];
    uint64_t v41 = *(unsigned __int8 *)__p[0];
    uint64_t v42 = *((unsigned __int8 *)__p[0] + 1);
    uint64_t v43 = *((unsigned __int8 *)__p[0] + 2);
    uint64_t v44 = *((unsigned __int8 *)__p[0] + 3);
    uint64_t v45 = operator new(8uLL);
    *uint64_t v45 = v41 | (v42 << 8) | (v43 << 48) | (v44 << 56);
    *(void *)&v63[8] = v45 + 1;
    *(void *)&v63[16] = v45 + 1;
    *(void *)uint64_t v63 = v45;
    BOOL v46 = (char *)((char *)__p[1] - (char *)v40);
    if ((void *)((char *)__p[1] - (char *)v40) <= (void *)4)
    {
      __TUAssertTrigger();
      uint64_t v40 = (char *)__p[0];
      BOOL v46 = (char *)((char *)__p[1] - (char *)__p[0]);
    }
    memset(buf, 0, 32);
    sub_100BCAA0C((os_log_t *)a2, v39, (uint64_t)v63, v40 + 4, (size_t)(v46 - 4), buf);
    int v47 = buf[24];
    if (buf[24])
    {
      unint64_t v48 = (char *)__p[0];
      unint64_t v49 = (char *)__p[1] - (char *)__p[0];
      if ((char *)__p[1] - (char *)__p[0] != *(void *)&buf[8] - *(void *)buf + 4)
      {
        __TUAssertTrigger();
        unint64_t v48 = (char *)__p[0];
        unint64_t v49 = (char *)__p[1] - (char *)__p[0];
      }
      if (v49 > 3)
      {
        if (v49 != 4) {
          __p[1] = v48 + 4;
        }
      }
      else
      {
        sub_10011FDF0((unint64_t *)__p, 4 - v49);
      }
      if (!buf[24]) {
        sub_10016C840();
      }
      uint64_t v51 = *(unsigned char **)buf;
      uint64_t v52 = *(unsigned char **)&buf[8];
      *(void *)unint64_t v62 = __p;
      while (v51 != v52)
        sub_100240714((unint64_t **)v62, v51++);
    }
    else
    {
      uint64_t v50 = *(NSObject **)a2;
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        uint64_t v54 = sub_10093AA58(*(_DWORD *)(a1 + 12));
        *(_DWORD *)unint64_t v62 = 136315138;
        *(void *)&v62[4] = v54;
        _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "[%s] Failed to encrypt", v62, 0xCu);
      }
      *long long v36 = 0;
      v36[24] = 0;
    }
    if (buf[24] && *(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    if (*(void *)v63) {
      operator delete(*(void **)v63);
    }
    if (v60) {
      sub_10004D2C8(v60);
    }
    unint64_t v33 = __p[0];
    if (v47)
    {
      *(void **)long long v36 = __p[0];
      *(_OWORD *)(v36 + 8) = *(_OWORD *)&__p[1];
      v36[24] = 1;
      return;
    }
  }
  if (v33)
  {
    __p[1] = v33;
    operator delete(v33);
  }
}

void sub_10036A888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,char a24)
{
  operator delete(v24);
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10036A928(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
}

uint64_t sub_10036A930()
{
  return 0;
}

uint64_t sub_10036A938()
{
  return 0;
}

uint64_t sub_10036A950()
{
  return 0;
}

uint64_t sub_10036A958()
{
  return 0;
}

uint64_t sub_10036A960()
{
  return 0;
}

uint64_t sub_10036A968()
{
  return 0;
}

BOOL sub_10036A970(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  return v2 && *(unsigned __int8 *)(a1 + 26) != *(unsigned __int8 *)(v2 + 104);
}

BOOL sub_10036A994(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  return v2 && *(unsigned __int8 *)(a1 + 10) != *(unsigned __int8 *)(v2 + 104);
}

uint64_t sub_10036A9B8()
{
  return 0;
}

uint64_t sub_10036A9C0()
{
  return 0;
}

uint64_t sub_10036A9C8(uint64_t a1, os_log_t *a2)
{
  uint64_t v3 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
  {
    uint64_t v5 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v6 = 136315138;
    BOOL v7 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Compression is not supported for this message", (uint8_t *)&v6, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_10036AA7C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_10036AA84(uint64_t a1, os_log_t *a2)
{
  return sub_10036A9C8(a1 - 16, a2);
}

BOOL sub_10036AA8C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  return v2 && *(unsigned char *)(v2 + 273) && *(void *)(v2 + 88) && *(void *)(v2 + 152) && *(void *)(v2 + 168) != 0;
}

BOOL sub_10036AAC4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  return v2 && *(unsigned char *)(v2 + 273) && *(void *)(v2 + 88) && *(void *)(v2 + 152) && *(void *)(v2 + 168) != 0;
}

uint64_t sub_10036AAFC()
{
  return 0;
}

uint64_t sub_10036AB04()
{
  return 0;
}

void sub_10036AB0C(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  int v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", buf, 0xCu);
  }
  uint64_t v8 = *(void *)(a2 + 8);
  if (!v8)
  {
    int v53 = *(NSObject **)a2;
    if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
      goto LABEL_82;
    }
    uint64_t v56 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v56;
    __int16 v55 = "[%s] Emergency environment doesn't exist";
    goto LABEL_81;
  }
  if (!*(unsigned char *)(v8 + 273) || !*(void *)(v8 + 88) || !*(void *)(v8 + 152) || !*(void *)(v8 + 168))
  {
    int v53 = *(NSObject **)a2;
    if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
      goto LABEL_82;
    }
    uint64_t v54 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v54;
    __int16 v55 = "[%s] Emergency environment is not ready";
LABEL_81:
    _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, v55, buf, 0xCu);
    goto LABEL_82;
  }
  if (!*(unsigned char *)(v8 + 274))
  {
    int v53 = *(NSObject **)a2;
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      uint64_t v57 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v57;
      __int16 v55 = "[%s] Emergency start message hasn't been acked yet";
      goto LABEL_81;
    }
LABEL_82:
    *a3 = 0;
    a3[24] = 0;
    return;
  }
  memset(__p, 0, 24);
  unsigned int v9 = sub_10112625C(v8);
  __int16 v10 = sub_1011257BC(*(void *)(a2 + 8));
  if (((v10 + 1) & 0x100) != 0) {
    char v11 = 1;
  }
  else {
    char v11 = v10 + 1;
  }
  if ((v10 & 0xFF00) != 0) {
    unsigned __int8 v12 = v11;
  }
  else {
    unsigned __int8 v12 = 0;
  }
  sub_1011258D4(*(void *)(a2 + 8));
  uint64_t v13 = *(void *)(a2 + 8);
  uint64_t v14 = *(void *)(v13 + 104);
  unsigned int v15 = sub_100BDE8A4(v13 + 296, 0);
  if (v15 == 2) {
    unsigned int v16 = 0;
  }
  else {
    unsigned int v16 = v15;
  }
  uint64_t v17 = *(void *)(a2 + 8);
  uint64_t v18 = *(char *)(v17 + 344);
  sub_100BDEA38(v17, v16);
  time_t v58 = a3;
  uint64_t v19 = *(void *)(a2 + 8);
  int v20 = *(unsigned __int8 *)(v19 + 276);
  *(unsigned char *)(v19 + 276) = 0;
  memset(buf, 0, 32);
  sub_10024060C((uint64_t)buf, 0xC8uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 24), 2uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 25), 6uLL);
  unint64_t v21 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v22 = *(char *)(a1 + 24);
    if (v22 > 4) {
      uint64_t v23 = "???";
    }
    else {
      uint64_t v23 = off_1019BE7B0[v22];
    }
    uint64_t v24 = sub_10093AA7C(*(unsigned __int8 *)(a1 + 25));
    *(_DWORD *)unint64_t v61 = 136315394;
    *(void *)&v61[4] = v23;
    *(_WORD *)&v61[12] = 2080;
    *(void *)&v61[14] = v24;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Serialized header: Version: %s, MessageType: %s", v61, 0x16u);
  }
  sub_10024081C((unint64_t *)buf, v14, 8uLL);
  sub_10024081C((unint64_t *)buf, v12, 8uLL);
  uint64_t v25 = *(void *)(a2 + 8);
  __int32 v26 = *(double **)(v25 + 88);
  __int16 v27 = *(std::__shared_weak_count **)(v25 + 96);
  if (v27) {
    atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10104992C(v26, a2, (unint64_t *)buf);
  sub_10024081C((unint64_t *)buf, v9, 2uLL);
  sub_10024081C((unint64_t *)buf, v16, 1uLL);
  sub_10024081C((unint64_t *)buf, v18, 2uLL);
  sub_10024081C((unint64_t *)buf, v20, 2uLL);
  sub_10024081C((unint64_t *)buf, 0, 1uLL);
  if (*(void *)&buf[24]) {
    __TUAssertTrigger();
  }
  long long v28 = *(_OWORD *)__p;
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  *(_OWORD *)long long buf = v28;
  int v29 = __p[2];
  __p[2] = *(void **)&buf[16];
  *(void *)&uint8_t buf[16] = v29;
  if (!v27)
  {
    unint64_t v30 = (void *)v28;
    if (!(void)v28) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  sub_10004D2C8(v27);
  unint64_t v30 = *(void **)buf;
  if (*(void *)buf)
  {
LABEL_29:
    *(void *)&uint8_t buf[8] = v30;
    operator delete(v30);
  }
LABEL_30:
  __int16 v31 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    os_log_t v32 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    if (v9 > 4) {
      unint64_t v33 = "???";
    }
    else {
      unint64_t v33 = off_1019BE7D8[(char)v9];
    }
    if (v16 > 2) {
      int v34 = "???";
    }
    else {
      int v34 = off_1019BE840[(char)v16];
    }
    if (v18 > 3) {
      uint64_t v35 = "???";
    }
    else {
      uint64_t v35 = off_1019BE800[v18];
    }
    long long v36 = "Yes";
    *(_DWORD *)long long buf = 136316674;
    *(void *)&uint8_t buf[4] = v32;
    *(_WORD *)&unsigned char buf[12] = 1024;
    if (!v20) {
      long long v36 = "No";
    }
    *(_DWORD *)&buf[14] = v14;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v12;
    *(_WORD *)&unsigned char buf[24] = 2080;
    *(void *)&buf[26] = v33;
    __int16 v63 = 2080;
    unint64_t v64 = v34;
    __int16 v65 = 2080;
    long long v66 = v35;
    __int16 v67 = 2080;
    int v68 = v36;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I [%s] ConversationID: %hhu, location sequence num: %hhu, battery: %s, notify option: %s, userIncapacitated: %s, Is Resume: %s", buf, 0x40u);
  }
  uint64_t v37 = *(void *)(a2 + 8);
  uint64_t v39 = *(void *)(v37 + 168);
  CFTypeID v38 = *(std::__shared_weak_count **)(v37 + 176);
  if (v38) {
    atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v40 = (char *)__p[0];
  uint64_t v41 = *(unsigned __int8 *)__p[0];
  uint64_t v42 = *((unsigned __int8 *)__p[0] + 1);
  uint64_t v43 = *((unsigned __int8 *)__p[0] + 2);
  uint64_t v44 = operator new(8uLL);
  *uint64_t v44 = v41 | (v42 << 8) | (v43 << 56);
  *(void *)&v61[8] = v44 + 1;
  *(void *)&v61[16] = v44 + 1;
  *(void *)unint64_t v61 = v44;
  uint64_t v45 = (char *)((char *)__p[1] - (char *)v40);
  if ((void *)((char *)__p[1] - (char *)v40) <= (void *)3)
  {
    __TUAssertTrigger();
    uint64_t v40 = (char *)__p[0];
    uint64_t v45 = (char *)((char *)__p[1] - (char *)__p[0]);
  }
  memset(buf, 0, 32);
  sub_100BCAA0C((os_log_t *)a2, v39, (uint64_t)v61, v40 + 3, (size_t)(v45 - 3), buf);
  int v46 = buf[24];
  if (buf[24])
  {
    int v47 = (char *)__p[0];
    unint64_t v48 = (char *)__p[1] - (char *)__p[0];
    if ((char *)__p[1] - (char *)__p[0] != *(void *)&buf[8] - *(void *)buf + 3)
    {
      __TUAssertTrigger();
      int v47 = (char *)__p[0];
      unint64_t v48 = (char *)__p[1] - (char *)__p[0];
    }
    if (v48 > 2)
    {
      if (v48 != 3) {
        __p[1] = v47 + 3;
      }
    }
    else
    {
      sub_10011FDF0((unint64_t *)__p, 3 - v48);
    }
    if (!buf[24]) {
      sub_10016C840();
    }
    uint64_t v50 = *(unsigned char **)buf;
    uint64_t v51 = *(unsigned char **)&buf[8];
    *(void *)int v60 = __p;
    while (v50 != v51)
      sub_100240714((unint64_t **)v60, v50++);
  }
  else
  {
    unint64_t v49 = *(NSObject **)a2;
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      uint64_t v52 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)int v60 = 136315138;
      *(void *)&v60[4] = v52;
      _os_log_error_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "[%s] Failed to encrypt", v60, 0xCu);
    }
    *time_t v58 = 0;
    v58[24] = 0;
  }
  if (buf[24] && *(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  if (*(void *)v61) {
    operator delete(*(void **)v61);
  }
  if (v38) {
    sub_10004D2C8(v38);
  }
  if (v46)
  {
    *(void **)time_t v58 = __p[0];
    *(_OWORD *)(v58 + 8) = *(_OWORD *)&__p[1];
    v58[24] = 1;
  }
  else if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_10036B1FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,char a24)
{
  operator delete(v25);
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10036B2B0(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
}

uint64_t sub_10036B2B8()
{
  return 0;
}

uint64_t sub_10036B2C0()
{
  return 0;
}

BOOL sub_10036B2D8(uint64_t a1)
{
  return *(unsigned char *)(a1 + 36) && !*(void *)(a1 + 64) && *(void *)(a1 + 40) != *(void *)(a1 + 48);
}

BOOL sub_10036B300(uint64_t a1)
{
  return *(unsigned char *)(a1 + 20) && !*(void *)(a1 + 48) && *(void *)(a1 + 24) != *(void *)(a1 + 32);
}

void sub_10036B328(uint64_t a1, uint64_t a2, NSObject **a3, uint64_t a4)
{
  if (!*(unsigned char *)(a1 + 36) || *(void *)(a1 + 64) || *(void *)(a1 + 40) == *(void *)(a1 + 48)) {
    __TUAssertTrigger();
  }
  if (!a3[1]) {
    goto LABEL_16;
  }
  BOOL v7 = (std::__shared_weak_count *)a3[2];
  *(void *)&long long buf = a3[1];
  *((void *)&buf + 1) = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v8 = sub_1004D0838((uint64_t)a3, (uint64_t *)&buf);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v8 != 3)
  {
LABEL_16:
    uint64_t v18 = *a3;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "[%s][Decompression] Failure: Environment is not ready", (uint8_t *)&buf, 0xCu);
    }
    sub_10036CD68((uint64_t)&buf, a4);
    operator new();
  }
  unsigned int v9 = (std::__shared_weak_count *)operator new(0x20uLL);
  v9->__shared_owners_ = 0;
  v9->__shared_weak_owners_ = 0;
  v9->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3378;
  LOBYTE(v9[1].__vftable) = 1;
  __int16 v10 = v9 + 1;
  char v11 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = v9 + 1;
  *(void *)(a1 + 72) = v9;
  if (!v11
    || (sub_10004D2C8(v11),
        __int16 v10 = *(std::__shared_weak_count **)(a1 + 64),
        (unsigned int v9 = *(std::__shared_weak_count **)(a1 + 72)) != 0))
  {
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = *(void *)(a1 + 40);
  uint64_t v12 = *(void *)(a1 + 48);
  uint64_t v14 = a3[3];
  unsigned int v20 = *(_DWORD *)(a1 + 32);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v21, (const ctu::OsLogLogger *)a3);
  sub_10036CD68((uint64_t)v22, a4);
  *(void *)&long long v23 = a1;
  *((void *)&v23 + 1) = v10;
  uint64_t v24 = v9;
  uint64_t v25 = v12 - v13;
  char v26 = 0;
  long long v28 = 0;
  unsigned int v15 = operator new(0x58uLL);
  *(void *)unsigned int v15 = off_1019BE718;
  ctu::OsLogLogger::OsLogLogger();
  sub_10036CD68((uint64_t)(v15 + 1), (uint64_t)v22);
  v15[3] = v23;
  unsigned int v16 = v24;
  *((void *)&v23 + 1) = 0;
  uint64_t v24 = 0;
  *((unsigned char *)v15 + 80) = v26;
  uint64_t v17 = v25;
  *((void *)v15 + 8) = v16;
  *((void *)v15 + 9) = v17;
  long long v28 = v15;
  (*((void (**)(NSObject *, void, uint64_t, long long *))v14->isa + 3))(v14, v20, a1 + 40, &buf);
  sub_1002BF950(&buf);
  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  sub_10026E5BC(v22);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v21);
}

void sub_10036B640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  sub_1002BF950((uint64_t *)va1);
  sub_10036B6A4((ctu::OsLogLogger *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10036B69C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

void sub_10036B6A4(ctu::OsLogLogger *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)a1 + 7);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_10026E5BC((void *)a1 + 1);

  ctu::OsLogLogger::~OsLogLogger(a1);
}

void sub_10036B6EC(uint64_t a1, uint64_t a2, NSObject **a3, uint64_t a4)
{
}

BOOL sub_10036B6F4(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  uint64_t v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding", buf, 0xCu);
  }
  uint64_t v8 = *(void *)(a2 + 8);
  if (v8)
  {
    if (*(unsigned char *)(v8 + 273) && *(void *)(v8 + 88) && *(void *)(v8 + 152) && *(void *)(v8 + 168))
    {
      unint64_t v9 = a3[1] - *a3;
      if (v9 > 4)
      {
        *(unsigned char *)(a1 + 26) = 0;
        unint64_t v16 = 8;
        while (1)
        {
          uint64_t v17 = a3[4];
          unint64_t v18 = (unint64_t)a3[5];
          if (!v18)
          {
            a3[4] = ++v17;
            a3[5] = (unsigned __int8 *)8;
            unint64_t v18 = 8;
          }
          uint64_t v19 = (uint64_t)*a3;
          if ((unint64_t)v17 >= a3[1] - *a3)
          {
            *((unsigned char *)a3 + 24) = 1;
            unint64_t v61 = *(NSObject **)a2;
            BOOL result = os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            v73 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v73;
            uint64_t v13 = "[%s] Failed to read conversationID";
            goto LABEL_73;
          }
          unint64_t v20 = v16 - v18;
          if (v16 <= v18) {
            break;
          }
          unsigned int v21 = v17[v19] & ~(-1 << v18);
          a3[5] = 0;
          *(unsigned char *)(a1 + 26) |= v21 << v20;
          unint64_t v16 = v20;
          if (v20 - 9 < 0xFFFFFFFFFFFFFFF8) {
            __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
          }
        }
        a3[5] = (unsigned __int8 *)(v18 - v16);
        if (v16 < 8) {
          char v22 = ~(-1 << v16);
        }
        else {
          char v22 = -1;
        }
        unsigned __int8 v23 = *(unsigned char *)(a1 + 26) | (v17[v19] >> (v18 - v16)) & v22;
        int v24 = v23;
        *(unsigned char *)(a1 + 26) = v23;
        uint64_t v25 = *(void *)(*(void *)(a2 + 8) + 104);
        if (v23 == v25)
        {
          int v26 = 0;
          uint64_t v27 = (uint64_t)*a3;
          unint64_t v28 = a3[1] - *a3;
          int v29 = a3[4];
          unint64_t v30 = (unint64_t)a3[5];
          unint64_t v31 = 2;
          if (v30) {
            goto LABEL_24;
          }
          while (1)
          {
            a3[4] = ++v29;
            a3[5] = (unsigned __int8 *)8;
            unint64_t v30 = 8;
LABEL_24:
            if ((unint64_t)v29 >= v28)
            {
              *((unsigned char *)a3 + 24) = 1;
              unint64_t v61 = *(NSObject **)a2;
              BOOL result = os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
              if (!result) {
                return result;
              }
              long long v76 = sub_10093AA58(*(_DWORD *)(a1 + 12));
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v76;
              uint64_t v13 = "[%s] Failed to read text encoding";
              goto LABEL_73;
            }
            BOOL v32 = v30 >= v31;
            uint64_t v33 = v30 - v31;
            if (v32) {
              break;
            }
            unsigned __int8 v34 = v29[v27];
            a3[5] = 0;
            v26 |= 2 * (v34 & 1);
            unint64_t v31 = 1;
          }
          a3[5] = (unsigned __int8 *)v33;
          uint64_t v37 = -1 << v31;
          int v38 = v26 | (v29[v27] >> v33) & ~v37;
          unsigned int v39 = (v26 | (v29[v27] >> v33) & ~(_BYTE)v37);
          if (v39 >= 3) {
            int v40 = 3;
          }
          else {
            int v40 = v39;
          }
          *(unsigned char *)(a1 + 27) = v40;
          if (v39 >= 3)
          {
            uint64_t v41 = *(NSObject **)a2;
            BOOL result = os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            uint64_t v42 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            uint64_t v43 = off_1019BE820[v40];
            *(_DWORD *)long long buf = 136315650;
            *(void *)&uint8_t buf[4] = v42;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v43;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = v38;
            uint64_t v13 = "[%s] Invalid encoding: %s (Received: %hhu)";
            uint64_t v14 = v41;
            uint32_t v15 = 28;
            goto LABEL_74;
          }
          if (!v33)
          {
            uint64_t v33 = 8;
            a3[4] = ++v29;
            a3[5] = (unsigned __int8 *)8;
          }
          if ((unint64_t)v29 >= v28)
          {
            *((unsigned char *)a3 + 24) = 1;
            unint64_t v61 = *(NSObject **)a2;
            BOOL result = os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            v94 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v94;
            uint64_t v13 = "[%s] Failed to read notify options";
            goto LABEL_73;
          }
          a3[5] = (unsigned __int8 *)(v33 - 1);
          int v44 = (v29[v27] >> (v33 - 1)) & 1;
          *(_WORD *)(a1 + 30) = 0;
          *(unsigned char *)(a1 + 28) = v44;
          if ((sub_10036C2D8((uint64_t *)a3, (_WORD *)(a1 + 30), 0xDuLL) & 1) == 0)
          {
            unint64_t v61 = *(NSObject **)a2;
            BOOL result = os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            unint64_t v62 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v62;
            uint64_t v13 = "[%s] Failed to read incoming sequence number";
            goto LABEL_73;
          }
          if (*((unsigned char *)a3 + 24))
          {
            __TUAssertTrigger();
            if (*((unsigned char *)a3 + 24)) {
              sub_10016C840();
            }
          }
          unint64_t v45 = (unint64_t)a3[5];
          if (v45) {
            uint64_t v46 = (uint64_t)a3[4];
          }
          else {
            uint64_t v46 = (uint64_t)(a3[4] + 1);
          }
          if ((v45 | 8) != 8) {
            __TUAssertTrigger();
          }
          if (v46 != 4) {
            __TUAssertTrigger();
          }
          *(_OWORD *)long long __p = 0u;
          long long v99 = 0u;
          uint64_t v47 = *(void *)(a2 + 8);
          unint64_t v48 = *(std::__shared_weak_count **)(v47 + 160);
          uint64_t v96 = *(void *)(v47 + 152);
          if (v48) {
            atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          *(void *)v105 = 0;
          uint64_t v49 = (uint64_t)*a3;
          uint64_t v50 = **a3;
          uint64_t v51 = (*a3)[1];
          uint64_t v52 = (*a3)[2];
          uint64_t v53 = (*a3)[3];
          uint64_t v54 = operator new(8uLL);
          void *v54 = (v52 << 48) | (v53 << 56) | (v51 << 8) | v50;
          *(void *)&v105[8] = v54 + 1;
          *(void *)&v105[16] = v54 + 1;
          *(void *)v105 = v54;
          sub_100BCAE0C((os_log_t *)a2, v96, (uint64_t)v105, (const void *)(v49 + 4), (size_t)&a3[1][-v49 - 4], buf);
          sub_10026E640((uint64_t)__p, (__n128 *)buf);
          if (buf[24] && *(void *)buf)
          {
            *(void *)&uint8_t buf[8] = *(void *)buf;
            operator delete(*(void **)buf);
          }
          operator delete(v54);
          if (v48) {
            sub_10004D2C8(v48);
          }
          if (BYTE8(v99))
          {
            if (__p[0] != __p[1])
            {
              *(void **)long long buf = __p[0];
              *(void **)&uint8_t buf[8] = __p[1];
              uint64_t v55 = v99;
              __p[1] = 0;
              *(void *)&long long v99 = 0;
              __p[0] = 0;
              *(void *)&uint8_t buf[16] = v55;
              *(void *)&unsigned char buf[24] = 0;
              *(void *)&unsigned char buf[32] = 0;
              *(void *)&buf[40] = 8;
              int v56 = *(unsigned __int8 *)(a1 + 27);
              if (v56 == 2)
              {
                unint64_t v97 = 0;
                if ((sub_10036C524((uint64_t *)buf, &v97) & 1) == 0)
                {
                  os_log_t v74 = *(os_log_t *)a2;
                  if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_92;
                  }
                  long long v75 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                  *(_DWORD *)v105 = 136315138;
                  *(void *)&v105[4] = v75;
                  uint64_t v70 = "[%s] Failed to read varint-128 codecId";
                  goto LABEL_128;
                }
                unint64_t v67 = v97;
                if (HIDWORD(v97))
                {
                  os_log_t v68 = *(os_log_t *)a2;
                  if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_92;
                  }
                  __int16 v69 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                  *(_DWORD *)v105 = 136315394;
                  *(void *)&v105[4] = v69;
                  *(_WORD *)&v105[12] = 2048;
                  *(void *)&v105[14] = v67;
                  uint64_t v70 = "[%s] CodecId must fit 32 bits (Received: %llu)";
                  v71 = v68;
                  uint32_t v72 = 22;
                  goto LABEL_129;
                }
                if (!v97)
                {
                  os_log_t v90 = *(os_log_t *)a2;
                  if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_92;
                  }
                  v91 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                  *(_DWORD *)v105 = 136315394;
                  *(void *)&v105[4] = v91;
                  *(_WORD *)&v105[12] = 1024;
                  *(_DWORD *)&v105[14] = 0;
                  uint64_t v70 = "[%s] Received invalid codecId(%u) from backend";
                  v71 = v90;
                  uint32_t v72 = 18;
                  goto LABEL_129;
                }
                if (!*(unsigned char *)(a1 + 36)) {
                  *(unsigned char *)(a1 + 36) = 1;
                }
                *(_DWORD *)(a1 + 32) = v67;
              }
              else if (v56 == 1)
              {
                unint64_t v57 = sub_101125A48(*(void *)(a2 + 8));
                if ((v57 & 0xFF00000000) != 0)
                {
                  *(_DWORD *)(a1 + 32) = v57;
                  *(unsigned char *)(a1 + 36) = 1;
                  goto LABEL_61;
                }
                os_log_t v74 = *(os_log_t *)a2;
                if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
                {
LABEL_92:
                  int v66 = 1;
                  goto LABEL_93;
                }
                v93 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                *(_DWORD *)v105 = 136315138;
                *(void *)&v105[4] = v93;
                uint64_t v70 = "[%s] Don't have a valid preferred codec id";
LABEL_128:
                v71 = v74;
                uint32_t v72 = 12;
LABEL_129:
                _os_log_error_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, v70, v105, v72);
                goto LABEL_92;
              }
LABEL_61:
              if (buf[24])
              {
                __TUAssertTrigger();
                if (buf[24]) {
                  sub_10016C840();
                }
              }
              if (*(void *)&buf[40]) {
                uint64_t v58 = *(void *)&buf[32];
              }
              else {
                uint64_t v58 = *(void *)&buf[32] + 1;
              }
              if ((*(void *)&buf[40] | 8) != 8) {
                __TUAssertTrigger();
              }
              unint64_t v59 = *(unsigned char **)&buf[8];
              int v60 = (unsigned char *)(*(void *)buf + v58);
              *(void *)v105 = a1 + 40;
              while (v60 != v59)
                sub_100240714((unint64_t **)v105, v60++);
              if (*(void *)(a1 + 40) == *(void *)(a1 + 48))
              {
                os_log_t v74 = *(os_log_t *)a2;
                if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_92;
                }
                v95 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                *(_DWORD *)v105 = 136315138;
                *(void *)&v105[4] = v95;
                uint64_t v70 = "[%s] Rejecting empty text received from backend";
                goto LABEL_128;
              }
              int v66 = 0;
LABEL_93:
              if (*(void *)buf)
              {
                *(void *)&uint8_t buf[8] = *(void *)buf;
                operator delete(*(void **)buf);
              }
LABEL_95:
              if (BYTE8(v99) && __p[0])
              {
                __p[1] = __p[0];
                operator delete(__p[0]);
              }
              if (!v66)
              {
                long long v77 = *(NSObject **)a2;
                if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v78 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                  unint64_t v79 = *(char *)(a1 + 27);
                  if (v79 > 3) {
                    long long v80 = "???";
                  }
                  else {
                    long long v80 = off_1019BE820[v79];
                  }
                  int v81 = *(unsigned __int8 *)(a1 + 36);
                  if (*(unsigned char *)(a1 + 36)) {
                    int v81 = *(_DWORD *)(a1 + 32);
                  }
                  int v82 = *(unsigned __int8 *)(a1 + 26);
                  unint64_t v83 = *(char *)(a1 + 28);
                  if (v83 > 2) {
                    uint64_t v84 = "???";
                  }
                  else {
                    uint64_t v84 = off_1019BE840[v83];
                  }
                  uint64_t v85 = *(void *)(a1 + 48) - *(void *)(a1 + 40);
                  int v86 = *(unsigned __int16 *)(a1 + 30);
                  if (*(unsigned char *)(a1 + 27)) {
                    __int16 v87 = "true";
                  }
                  else {
                    __int16 v87 = "false";
                  }
                  *(_DWORD *)long long buf = 136316930;
                  *(void *)&uint8_t buf[4] = v78;
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v82;
                  *(_WORD *)&buf[18] = 2080;
                  *(void *)&buf[20] = v80;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = v81;
                  *(_WORD *)&unsigned char buf[34] = 2080;
                  *(void *)&buf[36] = v84;
                  *(_WORD *)&buf[44] = 1024;
                  *(_DWORD *)&buf[46] = v86;
                  __int16 v101 = 2048;
                  uint64_t v102 = v85;
                  __int16 v103 = 2080;
                  v104 = v87;
                  _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "#I [%s] ConversationID: %hhu, Encoding: %s[%u], Notify option: %s, sequence number: %hu, Received text size: %zu, isCompressed: %s", buf, 0x46u);
                }
                return 1;
              }
              return 0;
            }
            __int16 v63 = *(NSObject **)a2;
            if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
            {
LABEL_78:
              int v66 = 1;
              goto LABEL_95;
            }
            __int16 v89 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v89;
            __int16 v65 = "[%s] Decrypted message contents are empty";
          }
          else
          {
            __int16 v63 = *(NSObject **)a2;
            if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR)) {
              return 0;
            }
            unint64_t v64 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v64;
            __int16 v65 = "[%s] Failed to decrypt incoming text message";
          }
          _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, v65, buf, 0xCu);
          goto LABEL_78;
        }
        uint64_t v35 = *(NSObject **)a2;
        BOOL result = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        long long v36 = sub_10093AA58(*(_DWORD *)(a1 + 12));
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v36;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v25;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v24;
        uint64_t v13 = "[%s] Expected conversationID: %hhu, got: %hhu. Rejecting message";
        uint64_t v14 = v35;
        uint32_t v15 = 24;
      }
      else
      {
        uint64_t v10 = *(NSObject **)a2;
        BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        uint64_t v12 = sub_10093AA58(*(_DWORD *)(a1 + 12));
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v12;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = 4;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&unsigned char buf[24] = v9;
        uint64_t v13 = "[%s] Incomplete message: Expected size > %zu, got %zu";
        uint64_t v14 = v10;
        uint32_t v15 = 32;
      }
      goto LABEL_74;
    }
    unint64_t v61 = *(NSObject **)a2;
    BOOL result = os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    v88 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v88;
    uint64_t v13 = "[%s] Emergency environment is not ready";
  }
  else
  {
    unint64_t v61 = *(NSObject **)a2;
    BOOL result = os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    v92 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v92;
    uint64_t v13 = "[%s] Emergency environment doesn't exist";
  }
LABEL_73:
  uint64_t v14 = v61;
  uint32_t v15 = 12;
LABEL_74:
  _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v13, buf, v15);
  return 0;
}

void sub_10036C254(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, char a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14)
  {
    if (a11) {
      operator delete(a11);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10036C2D8(uint64_t *a1, _WORD *a2, unint64_t a3)
{
  if (a3 - 17 <= 0xFFFFFFFFFFFFFFEFLL) {
    __assert_rtn("read", "CTBitwise.h", 231, "N > 0 && N <= 16");
  }
  unint64_t v3 = a3 - 8;
  if (a3 > 8)
  {
    int v11 = 0;
    uint64_t v12 = *a1;
    unint64_t v13 = a1[1] - *a1;
    unint64_t v14 = a1[4];
    unint64_t v15 = a1[5];
    while (1)
    {
      if (!v15)
      {
        a1[4] = ++v14;
        a1[5] = 8;
        unint64_t v15 = 8;
      }
      if (v14 >= v13) {
        break;
      }
      unint64_t v16 = v3 - v15;
      if (v3 <= v15)
      {
        int v21 = 0;
        unint64_t v22 = v15 - v3;
        a1[5] = v22;
        if (v3 < 8) {
          unsigned int v23 = ~(-1 << v3);
        }
        else {
          unsigned int v23 = 255;
        }
        int v24 = v11 | (*(unsigned __int8 *)(v12 + v14) >> v22) & v23;
        unint64_t v25 = 8;
        while (1)
        {
          if (!v22)
          {
            a1[4] = ++v14;
            a1[5] = 8;
            unint64_t v22 = 8;
          }
          if (v14 >= v13) {
            goto LABEL_37;
          }
          unint64_t v26 = v25 - v22;
          if (v25 <= v22)
          {
            a1[5] = v22 - v25;
            int v28 = *(unsigned __int8 *)(v12 + v14) >> (v22 - v25);
            if (v25 < 8) {
              char v29 = ~(-1 << v25);
            }
            else {
              char v29 = -1;
            }
            __int16 v20 = (v21 | v28 & v29) | (unsigned __int16)((_WORD)v24 << 8) | *a2;
LABEL_35:
            *a2 = v20;
            return 1;
          }
          unsigned int v27 = *(unsigned __int8 *)(v12 + v14) & ~(-1 << v22);
          a1[5] = 0;
          v21 |= v27 << v26;
          unint64_t v25 = v26;
          unint64_t v22 = 0;
          if (v26 - 9 < 0xFFFFFFFFFFFFFFF8) {
            goto LABEL_30;
          }
        }
      }
      unsigned int v17 = *(unsigned __int8 *)(v12 + v14) & ~(-1 << v15);
      a1[5] = 0;
      v11 |= v17 << v16;
      unint64_t v3 = v16;
      unint64_t v15 = 0;
      if (v16 - 9 < 0xFFFFFFFFFFFFFFF8) {
LABEL_30:
      }
        __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
    }
  }
  else
  {
    int v4 = 0;
    uint64_t v5 = *a1;
    unint64_t v6 = a1[1] - *a1;
    unint64_t v7 = a1[4];
    unint64_t v8 = a1[5];
    while (1)
    {
      if (!v8)
      {
        a1[4] = ++v7;
        a1[5] = 8;
        unint64_t v8 = 8;
      }
      if (v7 >= v6) {
        break;
      }
      unint64_t v9 = a3 - v8;
      if (a3 <= v8)
      {
        a1[5] = v8 - a3;
        int v18 = *(unsigned __int8 *)(v5 + v7) >> (v8 - a3);
        if (a3 < 8) {
          char v19 = ~(-1 << a3);
        }
        else {
          char v19 = -1;
        }
        __int16 v20 = *a2 | (v4 | v18 & v19);
        goto LABEL_35;
      }
      unsigned int v10 = *(unsigned __int8 *)(v5 + v7) & ~(-1 << v8);
      a1[5] = 0;
      v4 |= v10 << v9;
      a3 = v9;
      unint64_t v8 = 0;
      if (v9 - 9 < 0xFFFFFFFFFFFFFFF8) {
        goto LABEL_30;
      }
    }
  }
LABEL_37:
  uint64_t v30 = 0;
  *((unsigned char *)a1 + 24) = 1;
  return v30;
}

uint64_t sub_10036C524(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  unint64_t v3 = 0;
  uint64_t v4 = *a1;
  unint64_t v5 = a1[1] - *a1;
  unint64_t v6 = a1[4];
  unint64_t v7 = a1[5];
LABEL_2:
  if (v3 <= 0x3F)
  {
    int v8 = 0;
    unint64_t v9 = 8;
    while (1)
    {
      if (!v7)
      {
        a1[4] = ++v6;
        a1[5] = 8;
        unint64_t v7 = 8;
      }
      if (v6 >= v5) {
        break;
      }
      unint64_t v10 = v9 - v7;
      if (v9 <= v7)
      {
        v7 -= v9;
        a1[5] = v7;
        if (v9 < 8) {
          char v12 = ~(-1 << v9);
        }
        else {
          char v12 = -1;
        }
        char v13 = v8 | (*(unsigned __int8 *)(v4 + v6) >> v7) & v12;
        unint64_t v14 = v13 & 0x7F;
        if (v3 && v14 >> -(char)v3) {
          break;
        }
        v2 |= v14 << v3;
        v3 += 7;
        if (v13 < 0) {
          goto LABEL_2;
        }
        *a2 = v2;
        return 1;
      }
      unsigned int v11 = *(unsigned __int8 *)(v4 + v6) & ~(-1 << v7);
      a1[5] = 0;
      v8 |= v11 << v10;
      unint64_t v9 = v10;
      unint64_t v7 = 0;
      if (v10 - 9 < 0xFFFFFFFFFFFFFFF8) {
        __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
      }
    }
  }
  uint64_t v15 = 0;
  *((unsigned char *)a1 + 24) = 1;
  return v15;
}

BOOL sub_10036C640(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  return sub_10036B6F4(a1 - 16, a2, a3);
}

uint64_t sub_10036C648(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_10036C654()
{
}

uint64_t sub_10036C668(uint64_t a1)
{
  *(void *)a1 = off_1019BDAD8;
  *(void *)(a1 + 16) = &unk_1019BDB80;
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2)
    {
      *(void *)(a1 + 40) = v2;
      operator delete(v2);
    }
  }
  return a1;
}

void sub_10036C6E0(uint64_t a1)
{
  *(void *)a1 = off_1019BDAD8;
  *(void *)(a1 + 16) = &unk_1019BDB80;
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2)
    {
      *(void *)(a1 + 40) = v2;
      operator delete(v2);
    }
  }

  operator delete();
}

void sub_10036C778(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1019BDAD8;
  *(void *)a1 = &unk_1019BDB80;
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v1 = *(void **)(a1 + 16);
    if (v1)
    {
      *(void *)(a1 + 24) = v1;
      operator delete(v1);
    }
  }
}

void sub_10036C7E4(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1019BDAD8;
  *(void *)a1 = &unk_1019BDB80;
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v1 = *(void **)(a1 + 16);
    if (v1)
    {
      *(void *)(a1 + 24) = v1;
      operator delete(v1);
    }
  }

  operator delete();
}

uint64_t sub_10036C87C(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_10036C888()
{
}

void *sub_10036C89C(void *a1)
{
  *a1 = off_1019BDE00;
  a1[2] = &unk_1019BDEA8;
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_10036C918(void *a1)
{
  *a1 = off_1019BDE00;
  a1[2] = &unk_1019BDEA8;
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }

  operator delete();
}

void sub_10036C9B4(void *a1)
{
  *(a1 - 2) = off_1019BDE00;
  *a1 = &unk_1019BDEA8;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unint64_t v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
}

void sub_10036CA2C(void *a1)
{
  *(a1 - 2) = off_1019BDE00;
  *a1 = &unk_1019BDEA8;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unint64_t v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }

  operator delete();
}

uint64_t sub_10036CAC8(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_10036CAD4()
{
}

void sub_10036CAEC()
{
}

void sub_10036CB04()
{
}

uint64_t sub_10036CB1C(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_10036CB28()
{
}

void sub_10036CB3C(void *a1)
{
  *a1 = off_1019BE450;
  a1[2] = &unk_1019BE4B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unint64_t v3 = (void *)a1[5];
  if (v3)
  {
    a1[6] = v3;
    operator delete(v3);
  }

  operator delete();
}

void sub_10036CBD8(void *a1)
{
  *(a1 - 2) = off_1019BE450;
  *a1 = &unk_1019BE4B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unint64_t v3 = (void *)a1[3];
  if (v3)
  {
    a1[4] = v3;
    operator delete(v3);
  }
}

void sub_10036CC50(void *a1)
{
  *(a1 - 2) = off_1019BE450;
  *a1 = &unk_1019BE4B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unint64_t v3 = (void *)a1[3];
  if (v3)
  {
    a1[4] = v3;
    operator delete(v3);
  }

  operator delete();
}

void *sub_10036CCEC(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    unint64_t v6 = result;
    BOOL result = sub_10005C9F8(result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_10036CD4C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10036CD68(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    unint64_t v3 = (void *)(a1 + 24);
  }
  *unint64_t v3 = 0;
  return a1;
}

void *sub_10036CDE8(void *a1)
{
  *a1 = off_1019BE698;
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  sub_10026E5BC(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10036CE40(void *a1)
{
  *a1 = off_1019BE698;
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  sub_10026E5BC(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_10036CEB8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x48uLL);
  void *v2 = off_1019BE698;
  sub_10036D240((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10036CF0C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10036CF20(uint64_t a1, void *a2)
{
  *a2 = off_1019BE698;
  return sub_10036D240((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10036CF4C(uint64_t a1)
{
}

void sub_10036CF54(void *a1)
{
  sub_10036D36C(a1 + 1);

  operator delete(a1);
}

void sub_10036CF90(void *a1, uint64_t *a2, __n128 *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    uint64_t v6 = *a2;
    uint64_t v7 = a1[1];
    size_t v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      unint64_t v9 = v8;
      unint64_t v10 = (unsigned char *)a1[2];
      if (v10)
      {
        *unint64_t v10 = 1;
        if ((v6 & 0xFF00000000) != 0 && a3->n128_u64[0] != a3->n128_u64[1] && v6)
        {
          unint64_t v11 = *(void *)(v7 + 40) - *(void *)(v7 + 32);
          *(_DWORD *)(v7 + 56) = v6;
          *(unsigned char *)(v7 + 60) = 1;
          unint64_t v12 = a3->n128_u64[1] - a3->n128_u64[0];
          if (v11 < v12) {
            __TUAssertTrigger();
          }
          char v13 = a1[8];
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v14 = sub_10093AA58(*(_DWORD *)(v7 + 12));
            *(_DWORD *)int v21 = 136315650;
            *(void *)&v21[4] = v14;
            __int16 v22 = 2048;
            unint64_t v23 = v11;
            __int16 v24 = 2048;
            unint64_t v25 = v12;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [%s][Compression] Reduced size from %zu bytes -> %zu bytes", v21, 0x20u);
          }
          __n128 v15 = sub_10005C9A4(v7 + 32, a3);
          int v16 = *(_DWORD *)(v7 + 56);
          *(void *)int v21 = v11 - v12;
          *(_DWORD *)&char v21[8] = v16;
          BYTE2(v23) = 1;
          uint64_t v17 = a1[7];
          if (!v17) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t, unsigned char *, __n128))(*(void *)v17 + 48))(v17, v21, v15);
        }
        else
        {
          int v18 = a1[8];
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            char v19 = sub_10093AA58(*(_DWORD *)(v7 + 12));
            *(_DWORD *)int v21 = 136315138;
            *(void *)&v21[4] = v19;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I [%s][Compression] Going uncompressed", v21, 0xCu);
          }
          v21[0] = 0;
          BYTE2(v23) = 0;
          uint64_t v20 = a1[7];
          if (!v20) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v20 + 48))(v20, v21);
        }
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_10036D1D8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10036D1F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10036D234()
{
}

uint64_t sub_10036D240(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_10036D2D4(a1 + 24, a2 + 24);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 56), (const ctu::OsLogLogger *)(a2 + 56));
  return a1;
}

void sub_10036D2AC(_Unwind_Exception *a1)
{
  sub_10026E5BC(v2);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10036D2D4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_10036D36C(void *a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 7));
  sub_10026E5BC(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void **sub_10036D3C0(void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_10026E5BC(v2);
    operator delete();
  }
  return a1;
}

void **sub_10036D408(void *a1)
{
  uint64_t v3 = a1;
  v4[0] = 0;
  v4[16] = 0;
  uint64_t v1 = a1[3];
  if (!v1) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v1 + 48))(v1, v4);
  return sub_10036D3C0(&v3);
}

void sub_10036D478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

void *sub_10036D48C(void *a1)
{
  *a1 = off_1019BE718;
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_10026E5BC(a1 + 2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  return a1;
}

void sub_10036D4EC(void *a1)
{
  *a1 = off_1019BE718;
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_10026E5BC(a1 + 2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  operator delete();
}

void *sub_10036D56C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  void *v2 = off_1019BE718;
  sub_10036DA08((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10036D5C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10036D5D4(uint64_t a1, void *a2)
{
  *a2 = off_1019BE718;
  return sub_10036DA08((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10036D600(uint64_t a1)
{
}

void sub_10036D608(uint64_t a1)
{
  sub_10036B6A4((ctu::OsLogLogger *)(a1 + 8));

  operator delete((void *)a1);
}

void sub_10036D644(uint64_t a1, __n128 *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3)
  {
    uint64_t v5 = *(void *)(a1 + 48);
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (*(void *)(a1 + 56))
      {
        if (!*(unsigned char *)(v5 + 36)) {
          __TUAssertTrigger();
        }
        *(void *)(v5 + 48) = *(void *)(v5 + 40);
        unint64_t v8 = a2->n128_u64[1];
        if (a2->n128_u64[0] == v8)
        {
          unint64_t v25 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            unsigned int v27 = sub_10093AA58(*(_DWORD *)(v5 + 12));
            int v28 = *(_DWORD *)(v5 + 32);
            int v29 = *(unsigned __int8 *)(v5 + 26);
            int v30 = *(unsigned __int16 *)(v5 + 30);
            *(_DWORD *)long long buf = 136315906;
            *(void *)&uint8_t buf[4] = v27;
            __int16 v36 = 1024;
            int v37 = v28;
            __int16 v38 = 1024;
            int v39 = v29;
            __int16 v40 = 1024;
            int v41 = v30;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "[%s][Decompression] Failed. codecId: %u, conversationID: %hhu, incoming sequence number: %hu", buf, 0x1Eu);
          }
          buf[0] = 0;
          BYTE2(v37) = 0;
          uint64_t v26 = *(void *)(a1 + 40);
          if (!v26) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v26 + 48))(v26, buf);
        }
        else
        {
          unint64_t v9 = v8 - a2->n128_u64[0];
          unint64_t v10 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v11 = sub_10093AA58(*(_DWORD *)(v5 + 12));
            int v12 = *(_DWORD *)(v5 + 32);
            int v13 = *(unsigned __int8 *)(v5 + 26);
            int v14 = *(unsigned __int16 *)(v5 + 30);
            uint64_t v15 = *(void *)(a1 + 72);
            *(_DWORD *)long long buf = 136316418;
            *(void *)&uint8_t buf[4] = v11;
            __int16 v36 = 1024;
            int v37 = v12;
            __int16 v38 = 1024;
            int v39 = v13;
            __int16 v40 = 1024;
            int v41 = v14;
            __int16 v42 = 2048;
            uint64_t v43 = v15;
            __int16 v44 = 2048;
            unint64_t v45 = v9;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [%s][Decompression] For codecId: %u, conversationID: %hhu, incoming sequence number: %hu, compressed text size: %zu, uncompressed text size: %zu bytes", buf, 0x32u);
          }
          sub_10005C9A4(v5 + 40, a2);
          unint64_t v16 = *(void *)(a1 + 72);
          uint64_t v17 = v9 - v16;
          if (v9 < v16)
          {
            int v18 = *(NSObject **)(a1 + 8);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Backend is compressing in a way that does not yield any benefit. Please create radar.", buf, 2u);
            }
            uint64_t v17 = 0;
          }
          if (*(unsigned char *)(a1 + 80))
          {
            char v19 = *(NSObject **)(a1 + 8);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              unsigned int v20 = *(_DWORD *)(v5 + 12);
              sub_10012CD04(buf, *(char **)(v5 + 40), *(char **)(v5 + 48), *(void *)(v5 + 48) - *(void *)(v5 + 40));
              int v21 = sub_10093AA58(v20);
              __int16 v22 = v39 >= 0 ? buf : *(unsigned char **)buf;
              int v31 = 136315394;
              BOOL v32 = v21;
              __int16 v33 = 2080;
              unsigned __int8 v34 = v22;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I [%s] Decompressed text: %s", (uint8_t *)&v31, 0x16u);
              if (SHIBYTE(v39) < 0) {
                operator delete(*(void **)buf);
              }
            }
          }
          int v23 = *(_DWORD *)(v5 + 32);
          *(void *)long long buf = v17;
          *(_DWORD *)&uint8_t buf[8] = v23;
          BYTE2(v37) = 1;
          uint64_t v24 = *(void *)(a1 + 40);
          if (!v24) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v24 + 48))(v24, buf);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10036D9A0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10036D9BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10036D9FC()
{
}

uint64_t sub_10036DA08(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)a2);
  sub_10036D2D4(v4 + 8, a2 + 8);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  uint64_t v5 = *(void *)(a2 + 56);
  *(void *)(a1 + 56) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(void *)(a2 + 64);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  *(void *)(a1 + 64) = v6;
  return a1;
}

void sub_10036DA70(_Unwind_Exception *a1)
{
  ctu::OsLogLogger::~OsLogLogger(v1);
  _Unwind_Resume(a1);
}

void stewie::Anchors::create()
{
}

void sub_10036DB14(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10036DB94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_10036DC3C((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10036DBB8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10036DBF0(uint64_t a1)
{
}

uint64_t sub_10036DBF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10036DC3C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_10005D0E4(a2 + 16, *(void **)(a2 + 24));
    uint64_t v3 = *(std::__shared_weak_count **)(a2 + 8);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    operator delete();
  }
}

void sub_10036DCA0()
{
}

void sub_10036DD88(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10036DDBC(uint64_t a1, void *a2, NSObject **a3, void *a4, uint64_t a5)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v18, kCtLoggingSystemName, "ps.slc");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v10 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v19, &v18);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v19);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v19);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
  *(void *)a1 = off_1019BE8E0;
  *(void *)(a1 + 48) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 56) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 64) = *a4;
  uint64_t v12 = a4[1];
  *(void *)(a1 + 72) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 80) = a5;
  sub_100058DB0(&__p, "NetworkSlicingControl");
  int v13 = *(NSObject **)(a1 + 24);
  uint64_t v15 = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  ctu::RestModule::RestModule();
  if (v15) {
    dispatch_release(v15);
  }
  if (v17 < 0) {
    operator delete(__p);
  }
  *(unsigned char *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_WORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 116) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = a1 + 152;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 160) = 0;
  return a1;
}

void sub_10036DF58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  int v23 = *(std::__shared_weak_count **)(v19 + 72);
  if (v23) {
    sub_10004D2C8(v23);
  }
  uint64_t v24 = *(std::__shared_weak_count **)(v19 + 56);
  if (v24) {
    sub_10004D2C8(v24);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_10036DFE4(uint64_t a1)
{
  *(void *)a1 = off_1019BE8E0;
  int v2 = *(std::__shared_weak_count **)(a1 + 176);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10005D144(*(void **)(a1 + 152));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 136);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 96);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 56);
  if (v6) {
    sub_10004D2C8(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_10036E080(uint64_t a1)
{
  sub_10036DFE4(a1);

  operator delete();
}

uint64_t sub_10036E0B8(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 88));
}

uint64_t sub_10036E0C0(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v3;
    __int16 v18 = 2080;
    uint64_t v19 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sinitializing", buf, 0x16u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
LABEL_11:
  int v13 = *(std::__shared_weak_count **)(a1 + 136);
  *(void *)(a1 + 128) = v12;
  *(void *)(a1 + 136) = v11;
  if (v13) {
    sub_10004D2C8(v13);
  }
  Registry::createRestModuleOneTimeUseConnection(&v15, *(Registry **)(a1 + 48));
  ctu::RestModule::connect();
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10036E78C(a1);
  sub_10036E2A0(a1);
  uint64_t result = sub_10036F2E4(a1);
  *(unsigned char *)(a1 + 112) = result;
  return result;
}

void sub_10036E270(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10036E2A0(uint64_t a1)
{
  uint64_t v10 = 0;
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 128) + 96))(buf);
  sub_10004EFE4(&v10, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  if (v10) {
    int v2 = sub_100080778;
  }
  else {
    int v2 = 0;
  }
  int v3 = v2 != 0;
  int v4 = *(unsigned __int8 *)(a1 + 104);
  if (v4 != v3)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v7 = asStringBool(*(unsigned char *)(a1 + 104));
      uint64_t v8 = asStringBool(v2 != 0);
      *(_DWORD *)long long buf = 136315906;
      uint64_t v12 = v6;
      __int16 v13 = 2080;
      int v14 = " ";
      __int16 v15 = 2080;
      uint64_t v16 = v7;
      __int16 v17 = 2080;
      uint64_t v18 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sNetwork Slicing carrier support is changing from %s to %s", buf, 0x2Au);
    }
    *(unsigned char *)(a1 + 104) = v3;
  }
  sub_100057D78(&v10);
  return v4 != v3;
}

void sub_10036E44C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10036E478(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sstarted", (uint8_t *)&v5, 0x16u);
  }
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 104))(a1, 0, 1);
}

uint64_t sub_10036E564(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    int v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)__int16 v15 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)v15);
  if (v8)
  {
    uint64_t v10 = v8[3];
    unsigned int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  unsigned int v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v10 + 32))(v10, **(void **)(a1 + 64) + 24, @"SlicingWasDiscovered", kPhoneServicesWalletDomain, 0, 1);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  uint64_t v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)__int16 v15 = 136315394;
    *(void *)&v15[4] = v13;
    __int16 v16 = 2080;
    __int16 v17 = " ";
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%sNetwork Slicing Switch: review provisioning on migration", v15, 0x16u);
  }
  sub_10036E78C(a1);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

void sub_10036E75C(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10036E78C(uint64_t a1)
{
  int v56 = sub_10036EF20(a1);
  sub_10005D144(*(void **)(a1 + 152));
  *(void *)(a1 + 144) = a1 + 152;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  int v2 = (std::__shared_weak_count *)operator new(0x30uLL);
  v2->__shared_owners_ = 0;
  v2->__shared_weak_owners_ = 0;
  v2->__vftable = (std::__shared_weak_count_vtbl *)off_1019BEAC0;
  v2[1].__shared_owners_ = 0;
  v2[1].__vftable = (std::__shared_weak_count_vtbl *)&v2[1].__shared_owners_;
  uint64_t v3 = (uint64_t **)&v2[1];
  v2[1].__shared_weak_owners_ = 0;
  CFArrayRef theArray = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  int v5 = ServiceMap;
  uint64_t v7 = v6;
  if (v6 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  char v11 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  uint64_t v15 = kPhoneServicesWalletDomain;
  (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v13 + 24))(v60, v13, **(void **)(a1 + 64) + 24, @"SlicingCategories2", kPhoneServicesWalletDomain, 0, 1);
  sub_100044D6C(&theArray, (CFTypeRef *)v60);
  sub_1000577C4((const void **)v60);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  CFArrayRef v16 = theArray;
  if (theArray) {
    __int16 v17 = sub_100083F10;
  }
  else {
    __int16 v17 = 0;
  }
  if (v17)
  {
    BOOL v57 = 0;
LABEL_30:
    CFIndex Count = CFArrayGetCount(v16);
    if (Count)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
        CFDictionaryRef v31 = ValueAtIndex;
        if (ValueAtIndex)
        {
          CFTypeID v32 = CFGetTypeID(ValueAtIndex);
          if (v32 == CFDictionaryGetTypeID())
          {
            CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v31, @"id");
            CFNumberRef v34 = Value;
            if (Value)
            {
              CFTypeID v35 = CFGetTypeID(Value);
              if (v35 == CFNumberGetTypeID())
              {
                unint64_t valuePtr = 0;
                if (CFNumberGetValue(v34, kCFNumberLongLongType, &valuePtr))
                {
                  __int16 v36 = (int *)CFDictionaryGetValue(v31, @"user-preference");
                  int v37 = v36;
                  if (v36)
                  {
                    CFTypeID v38 = CFGetTypeID(v36);
                    if (v38 != CFNumberGetTypeID()) {
                      int v37 = 0;
                    }
                  }
                  int v39 = CFDictionaryGetValue(v31, @"name");
                  int v41 = v39;
                  if (v39)
                  {
                    CFTypeID v42 = CFGetTypeID(v39);
                    if (v42 != CFStringGetTypeID()) {
                      int v41 = 0;
                    }
                  }
                  if (v37)
                  {
                    *(_DWORD *)long long buf = 0;
                    ctu::cf::assign((ctu::cf *)buf, v37, v40);
                    if (*(int *)buf < 1)
                    {
                      int v45 = -*(_DWORD *)buf;
                      if (v56 <= -*(_DWORD *)buf)
                      {
                        uint64_t v43 = sub_100372D38((uint64_t **)(a1 + 144), valuePtr, &valuePtr);
                        int v44 = 1;
                      }
                      else
                      {
                        uint64_t v46 = *(NSObject **)(a1 + 40);
                        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v47 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
                          *(_DWORD *)long long buf = 136316162;
                          *(void *)&uint8_t buf[4] = v47;
                          *(_WORD *)&unsigned char buf[12] = 2080;
                          *(void *)&buf[14] = " ";
                          *(_WORD *)&buf[22] = 1024;
                          *(_DWORD *)unint64_t v62 = v45;
                          *(_WORD *)&v62[4] = 1024;
                          *(_DWORD *)&v62[6] = v56;
                          __int16 v63 = 2048;
                          unint64_t v64 = valuePtr;
                          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I %s%sNetwork Slicing Switch: user preference has ver:%d vs current:%d for category %lld, force reset to default", buf, 0x2Cu);
                        }
                        uint64_t v43 = sub_100372D38((uint64_t **)(a1 + 144), valuePtr, &valuePtr);
                        int v44 = 0;
                        BOOL v57 = 1;
                      }
                    }
                    else
                    {
                      uint64_t v43 = sub_100372D38((uint64_t **)(a1 + 144), valuePtr, &valuePtr);
                      int v44 = 2;
                    }
                  }
                  else
                  {
                    uint64_t v43 = sub_100372D38((uint64_t **)(a1 + 144), valuePtr, &valuePtr);
                    int v44 = 0;
                  }
                  *((_DWORD *)v43 + 10) = v44;
                  if (v41)
                  {
                    unint64_t v48 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v49 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
                      *(_DWORD *)long long buf = 136315650;
                      *(void *)&uint8_t buf[4] = v49;
                      *(_WORD *)&unsigned char buf[12] = 2080;
                      *(void *)&buf[14] = " ";
                      *(_WORD *)&buf[22] = 2114;
                      *(void *)unint64_t v62 = v41;
                      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I %s%sLoaded app category: %{public}@", buf, 0x20u);
                    }
                    memset(buf, 0, sizeof(buf));
                    ctu::cf::assign();
                    uint64_t v50 = *(void *)buf;
                    *(void *)int v60 = *(void *)&buf[8];
                    *(void *)&v60[7] = *(void *)&buf[15];
                    uint8_t v51 = buf[23];
                    *(void *)long long buf = &valuePtr;
                    uint64_t v52 = sub_100372E78(v3, &valuePtr, (uint64_t)&unk_10144E20E, (uint64_t **)buf);
                    uint64_t v53 = v52;
                    if (*((char *)v52 + 63) < 0) {
                      operator delete((void *)v52[5]);
                    }
                    uint64_t v54 = *(void *)v60;
                    v53[5] = v50;
                    v53[6] = v54;
                    *(uint64_t *)((char *)v53 + 55) = *(void *)&v60[7];
                    *((unsigned char *)v53 + 63) = v51;
                  }
                }
              }
            }
          }
        }
      }
    }
    goto LABEL_59;
  }
  uint64_t v18 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v19 = v18;
  if (v6 < 0)
  {
    unsigned int v20 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      uint64_t v6 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(v18);
  *(void *)long long buf = v6;
  int v23 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)buf);
  if (v23)
  {
    uint64_t v25 = v23[3];
    uint64_t v24 = (std::__shared_weak_count *)v23[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v19);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      char v26 = 0;
      goto LABEL_24;
    }
  }
  else
  {
    uint64_t v25 = 0;
  }
  std::mutex::unlock(v19);
  uint64_t v24 = 0;
  char v26 = 1;
LABEL_24:
  (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t, void, uint64_t))(*(void *)v25 + 24))(&valuePtr, v25, **(void **)(a1 + 64) + 24, @"SlicingCategories", v15, 0, 1);
  sub_100044D6C(v60, (CFTypeRef *)&valuePtr);
  *(void *)long long buf = theArray;
  CFArrayRef theArray = *(CFArrayRef *)v60;
  *(void *)int v60 = 0;
  sub_100044D00((const void **)buf);
  sub_100044D00((const void **)v60);
  sub_1000577C4((const void **)&valuePtr);
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  CFArrayRef v16 = theArray;
  if (theArray) {
    unsigned int v27 = sub_100083F10;
  }
  else {
    unsigned int v27 = 0;
  }
  BOOL v57 = v27 != 0;
  if (v27) {
    goto LABEL_30;
  }
LABEL_59:
  atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v55 = *(std::__shared_weak_count **)(a1 + 176);
  *(void *)(a1 + 168) = v3;
  *(void *)(a1 + 176) = v2;
  if (v55) {
    sub_10004D2C8(v55);
  }
  if (v57) {
    sub_10036FB50(a1);
  }
  sub_100044D00((const void **)&theArray);
  sub_10004D2C8(v2);
}

void sub_10036EE54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_100044D00((const void **)va);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

unint64_t sub_10036EF20(uint64_t a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CC80, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0CC80))
  {
    cf[0] = @"NRSlicing";
    cf[1] = @"ResetNetworkSlicingAfterUpgrade";
    sub_100367E88(qword_101B0CCB0, cf, 2uLL);
    __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0CCB0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0CC80);
  }
  cf[0] = 0;
  (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 128) + 104))(cf);
  if (cf[0]) {
    int v2 = sub_100080934;
  }
  else {
    int v2 = 0;
  }
  if (!v2) {
    goto LABEL_13;
  }
  CFTypeID v3 = CFGetTypeID(cf[0]);
  CFTypeID TypeID = CFNumberGetTypeID();
  unint64_t v5 = (unint64_t)cf[0];
  if (v3 != TypeID)
  {
    LOBYTE(v11) = 0;
    if (!cf[0]) {
      goto LABEL_14;
    }
    CFTypeID v8 = CFGetTypeID(cf[0]);
    if (v8 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v11, (BOOL *)v5, v9);
      unint64_t v5 = v11;
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  unsigned int v11 = 0;
  if (cf[0])
  {
    CFTypeID v6 = CFGetTypeID(cf[0]);
    if (v6 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v11, (int *)v5, v7);
      unint64_t v5 = v11;
      goto LABEL_14;
    }
LABEL_13:
    unint64_t v5 = 0;
  }
LABEL_14:
  sub_1000577C4(cf);
  return v5;
}

void sub_10036F0EC(_Unwind_Exception *a1)
{
}

BOOL sub_10036F11C(uint64_t a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CC88, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = a1;
    int v5 = __cxa_guard_acquire(&qword_101B0CC88);
    a1 = v4;
    if (v5)
    {
      BOOLean[0] = (CFBooleanRef)@"NRSlicing";
      BOOLean[1] = (CFBooleanRef)@"ShowNetworkSlicingSwitch";
      sub_100367E88(qword_101B0CCC8, BOOLean, 2uLL);
      __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0CCC8, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0CC88);
      a1 = v4;
    }
  }
  BOOLean[0] = 0;
  (*(void (**)(const void **__return_ptr, void, void, uint64_t, void *, const CFBooleanRef, void))(**(void **)(a1 + 128) + 104))(&v6, *(void *)(a1 + 128), *(unsigned int *)(**(void **)(a1 + 64) + 52), 1, qword_101B0CCC8, kCFBooleanTrue, 0);
  sub_1000057AC(BOOLean, &v6);
  sub_1000577C4(&v6);
  if (BOOLean[0]) {
    char v1 = sub_100084B4C;
  }
  else {
    char v1 = 0;
  }
  if (v1) {
    BOOL v2 = CFBooleanGetValue(BOOLean[0]) == 1;
  }
  else {
    BOOL v2 = 0;
  }
  sub_100062778((const void **)BOOLean);
  return v2;
}

void sub_10036F2A4(_Unwind_Exception *a1)
{
}

uint64_t sub_10036F2E4(uint64_t a1)
{
  sub_10036F11C(a1);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CC90, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0CC90))
  {
    *(void *)CFTypeRef cf = @"NRSlicing";
    *(void *)&cf[8] = @"EnableNetworkSlicingByDefault";
    sub_100367E88(qword_101B0CCE0, cf, 2uLL);
    __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0CCE0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0CC90);
  }
  BOOL v2 = 1;
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 128) + 104))(cf);
  CFTypeID v3 = *(BOOL **)cf;
  char v21 = 1;
  if (*(void *)cf)
  {
    CFTypeID v4 = CFGetTypeID(*(CFTypeRef *)cf);
    if (v4 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v21, v3, v5);
      BOOL v2 = v21 != 0;
    }
    else
    {
      BOOL v2 = 1;
    }
  }
  sub_1000577C4((const void **)cf);
  *(unsigned char *)(a1 + 113) = v2;
  CFTypeID v6 = *(void **)(a1 + 144);
  if (v6 == (void *)(a1 + 152))
  {
LABEL_18:
    CFArrayRef v16 = *(NSObject **)(a1 + 40);
    BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v17)
    {
      uint64_t v19 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)CFTypeRef cf = 136315394;
      *(void *)&cf[4] = v19;
      *(_WORD *)&cf[12] = 2080;
      *(void *)&cf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%sNetwork Slicing Switch: Cumulative state is OFF", cf, 0x16u);
      return 0;
    }
  }
  else
  {
    int v7 = 0;
    do
    {
      int v8 = *((_DWORD *)v6 + 10);
      if (v8 == 2)
      {
        uint64_t v13 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          return 1;
        }
        uint64_t v20 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
        *(_DWORD *)CFTypeRef cf = 136315394;
        *(void *)&cf[4] = v20;
        *(_WORD *)&cf[12] = 2080;
        *(void *)&cf[14] = " ";
        uint64_t v15 = "#I %s%sNetwork Slicing Switch: Cumulative state is ON based on user preferences";
        goto LABEL_22;
      }
      BOOL v9 = v8 == 0;
      unsigned int v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          unsigned int v11 = v10;
          unsigned int v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          unsigned int v11 = (void *)v6[2];
          BOOL v12 = *v11 == (void)v6;
          CFTypeID v6 = v11;
        }
        while (!v12);
      }
      v7 |= v9;
      CFTypeID v6 = v11;
    }
    while (v11 != (void *)(a1 + 152));
    if ((v7 & v2) != 1) {
      goto LABEL_18;
    }
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)CFTypeRef cf = 136315394;
      *(void *)&cf[4] = v14;
      *(_WORD *)&cf[12] = 2080;
      *(void *)&cf[14] = " ";
      uint64_t v15 = "#I %s%sNetwork Slicing Switch: Cumulative state is ON based on carrier default";
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v15, cf, 0x16u);
    }
    return 1;
  }
  return result;
}

void sub_10036F608(_Unwind_Exception *a1)
{
}

uint64_t sub_10036F638(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)uint64_t v46 = 136315394;
    *(void *)&v46[4] = v3;
    __int16 v47 = 2080;
    unint64_t v48 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sNetwork Slicing Switch: Reset", v46, 0x16u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  CFBooleanRef v5 = ServiceMap;
  uint64_t v7 = v6;
  if (v6 < 0)
  {
    int v8 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint64_t v46 = v7;
  unsigned int v11 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)v46);
  if (v11)
  {
    uint64_t v13 = v11[3];
    BOOL v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v5);
  BOOL v12 = 0;
  char v14 = 1;
LABEL_11:
  uint64_t v15 = kPhoneServicesWalletDomain;
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v13 + 32))(v13, **(void **)(a1 + 64) + 24, @"SlicingCategories", kPhoneServicesWalletDomain, 0, 1);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  CFArrayRef v16 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  BOOL v17 = v16;
  uint64_t v18 = v6;
  if (v6 < 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v16);
  *(void *)uint64_t v46 = v18;
  unsigned int v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)v46);
  if (v22)
  {
    uint64_t v24 = v22[3];
    int v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      char v25 = 0;
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  int v23 = 0;
  char v25 = 1;
LABEL_21:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, uint64_t, void, uint64_t))(*(void *)v24 + 32))(v24, **(void **)(a1 + 64) + 24, @"SlicingCategories2", v15, 0, 1);
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  char v26 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  unsigned int v27 = v26;
  uint64_t v28 = v6;
  if (v6 < 0)
  {
    int v29 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v30 = 5381;
    do
    {
      uint64_t v28 = v30;
      unsigned int v31 = *v29++;
      uint64_t v30 = (33 * v30) ^ v31;
    }
    while (v31);
  }
  std::mutex::lock(v26);
  *(void *)uint64_t v46 = v28;
  CFTypeID v32 = sub_10004D37C(&v27[1].__m_.__sig, (unint64_t *)v46);
  if (v32)
  {
    uint64_t v34 = v32[3];
    __int16 v33 = (std::__shared_weak_count *)v32[4];
    if (v33)
    {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v27);
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v33);
      char v35 = 0;
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v34 = 0;
  }
  std::mutex::unlock(v27);
  __int16 v33 = 0;
  char v35 = 1;
LABEL_31:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, uint64_t, void, uint64_t))(*(void *)v34 + 32))(v34, **(void **)(a1 + 64) + 24, @"SlicingWasDiscoveredByApp", v15, 0, 1);
  if ((v35 & 1) == 0) {
    sub_10004D2C8(v33);
  }
  __int16 v36 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  int v37 = v36;
  if (v6 < 0)
  {
    CFTypeID v38 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v39 = 5381;
    do
    {
      uint64_t v6 = v39;
      unsigned int v40 = *v38++;
      uint64_t v39 = (33 * v39) ^ v40;
    }
    while (v40);
  }
  std::mutex::lock(v36);
  *(void *)uint64_t v46 = v6;
  int v41 = sub_10004D37C(&v37[1].__m_.__sig, (unint64_t *)v46);
  if (v41)
  {
    uint64_t v43 = v41[3];
    CFTypeID v42 = (std::__shared_weak_count *)v41[4];
    if (v42)
    {
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v37);
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v42);
      char v44 = 0;
      goto LABEL_41;
    }
  }
  else
  {
    uint64_t v43 = 0;
  }
  std::mutex::unlock(v37);
  CFTypeID v42 = 0;
  char v44 = 1;
LABEL_41:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, uint64_t, void, uint64_t))(*(void *)v43 + 32))(v43, **(void **)(a1 + 64) + 24, @"SlicingWasDiscoveredByApp2", v15, 0, 1);
  if ((v44 & 1) == 0) {
    sub_10004D2C8(v42);
  }
  sub_10036E78C(a1);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

void sub_10036FB00(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10036FB50(uint64_t a1)
{
  int v2 = sub_10036EF20(a1);
  CFMutableArrayRef theArray = 0;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    CFMutableArrayRef v4 = theArray;
    CFMutableArrayRef theArray = Mutable;
    __p[0] = v4;
    sub_1000440D4((const void **)__p);
  }
  CFBooleanRef v5 = *(void **)(a1 + 144);
  if (v5 != (void *)(a1 + 152))
  {
    do
    {
      long long valuePtr = *((_OWORD *)v5 + 2);
      CFMutableDictionaryRef theDict = 0;
      uint64_t v6 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v6)
      {
        CFMutableDictionaryRef v7 = theDict;
        CFMutableDictionaryRef theDict = v6;
        __p[0] = v7;
        sub_10005717C((const void **)__p);
      }
      CFNumberRef v50 = 0;
      CFNumberRef v50 = CFNumberCreate(0, kCFNumberLongLongType, &valuePtr);
      CFDictionarySetValue(theDict, @"id", v50);
      uint64_t v8 = *(void *)(a1 + 168);
      if (v8)
      {
        unsigned int v11 = *(void **)(v8 + 8);
        uint64_t v9 = (void *)(v8 + 8);
        unsigned int v10 = v11;
        if (v11)
        {
          BOOL v12 = v9;
          do
          {
            unint64_t v13 = v10[4];
            BOOL v14 = v13 >= (unint64_t)valuePtr;
            if (v13 >= (unint64_t)valuePtr) {
              uint64_t v15 = v10;
            }
            else {
              uint64_t v15 = v10 + 1;
            }
            if (v14) {
              BOOL v12 = v10;
            }
            unsigned int v10 = (void *)*v15;
          }
          while (*v15);
          if (v12 != v9 && (unint64_t)valuePtr >= v12[4])
          {
            CFArrayRef v16 = theDict;
            if (*((char *)v12 + 63) < 0)
            {
              sub_10004FC84(v47, (void *)v12[5], v12[6]);
            }
            else
            {
              *(_OWORD *)__int16 v47 = *(_OWORD *)(v12 + 5);
              uint64_t v48 = v12[7];
            }
            if (SHIBYTE(v48) < 0)
            {
              sub_10004FC84(__dst, v47[0], (unint64_t)v47[1]);
            }
            else
            {
              *(_OWORD *)std::string __dst = *(_OWORD *)v47;
              uint64_t v56 = v48;
            }
            uint64_t v54 = 0;
            if (SHIBYTE(v56) < 0)
            {
              sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
            }
            else
            {
              *(_OWORD *)long long __p = *(_OWORD *)__dst;
              uint64_t v58 = v56;
            }
            unint64_t v59 = 0;
            if (ctu::cf::convert_copy())
            {
              BOOL v17 = v54;
              uint64_t v54 = v59;
              v60[0] = v17;
              sub_1000558F4(v60);
            }
            if (SHIBYTE(v58) < 0) {
              operator delete(__p[0]);
            }
            xpc_object_t value = v54;
            uint64_t v54 = 0;
            sub_1000558F4((const void **)&v54);
            if (SHIBYTE(v56) < 0) {
              operator delete(__dst[0]);
            }
            CFDictionarySetValue(v16, @"name", value);
            sub_1000558F4((const void **)&value);
            if (SHIBYTE(v48) < 0) {
              operator delete(v47[0]);
            }
          }
        }
      }
      if (DWORD2(valuePtr))
      {
        uint64_t v18 = theDict;
        if (DWORD2(valuePtr) == 2) {
          int v19 = v2 + 1;
        }
        else {
          int v19 = -v2;
        }
        __dst[0] = 0;
        LODWORD(__p[0]) = v19;
        CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, __p);
        if (v20)
        {
          unsigned int v21 = __dst[0];
          __dst[0] = v20;
          __p[0] = v21;
          sub_1000570E8((const void **)__p);
        }
        v60[0] = __dst[0];
        __dst[0] = 0;
        sub_1000570E8((const void **)__dst);
        CFDictionarySetValue(v18, @"user-preference", v60[0]);
        sub_1000570E8(v60);
      }
      CFArrayAppendValue(theArray, theDict);
      sub_1000570E8((const void **)&v50);
      sub_10005717C((const void **)&theDict);
      unsigned int v22 = (void *)v5[1];
      if (v22)
      {
        do
        {
          int v23 = v22;
          unsigned int v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          int v23 = (void *)v5[2];
          BOOL v24 = *v23 == (void)v5;
          CFBooleanRef v5 = v23;
        }
        while (!v24);
      }
      CFBooleanRef v5 = v23;
    }
    while (v23 != (void *)(a1 + 152));
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  char v26 = ServiceMap;
  uint64_t v28 = (void *)v27;
  if (v27 < 0)
  {
    int v29 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v30 = 5381;
    do
    {
      uint64_t v28 = (void *)v30;
      unsigned int v31 = *v29++;
      uint64_t v30 = (33 * v30) ^ v31;
    }
    while (v31);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = v28;
  CFTypeID v32 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)__p);
  if (v32)
  {
    uint64_t v34 = v32[3];
    __int16 v33 = (std::__shared_weak_count *)v32[4];
    if (v33)
    {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v26);
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v33);
      char v35 = 0;
      goto LABEL_56;
    }
  }
  else
  {
    uint64_t v34 = 0;
  }
  std::mutex::unlock(v26);
  __int16 v33 = 0;
  char v35 = 1;
LABEL_56:
  uint64_t v36 = kPhoneServicesWalletDomain;
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v34 + 32))(v34, **(void **)(a1 + 64) + 24, @"SlicingCategories", kPhoneServicesWalletDomain, 0, 1);
  if ((v35 & 1) == 0) {
    sub_10004D2C8(v33);
  }
  int v37 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  CFTypeID v38 = v37;
  if (v27 < 0)
  {
    uint64_t v39 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v40 = 5381;
    do
    {
      uint64_t v27 = v40;
      unsigned int v41 = *v39++;
      uint64_t v40 = (33 * v40) ^ v41;
    }
    while (v41);
  }
  std::mutex::lock(v37);
  __p[0] = (void *)v27;
  CFTypeID v42 = sub_10004D37C(&v38[1].__m_.__sig, (unint64_t *)__p);
  if (v42)
  {
    uint64_t v44 = v42[3];
    uint64_t v43 = (std::__shared_weak_count *)v42[4];
    if (v43)
    {
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v38);
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v43);
      char v45 = 0;
      goto LABEL_66;
    }
  }
  else
  {
    uint64_t v44 = 0;
  }
  std::mutex::unlock(v38);
  uint64_t v43 = 0;
  char v45 = 1;
LABEL_66:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, CFMutableArrayRef, uint64_t, void, uint64_t, void))(*(void *)v44 + 16))(v44, **(void **)(a1 + 64) + 24, @"SlicingCategories2", theArray, v36, 0, 1, 0);
  if ((v45 & 1) == 0) {
    sub_10004D2C8(v43);
  }
  return sub_1000440D4((const void **)&theArray);
}

void sub_100370080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, const void *a18, uint64_t a19, uint64_t a20,const void *a21,const void *a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_1000570E8(&a17);
  sub_10005717C(&a18);
  sub_1000440D4(&a21);
  _Unwind_Resume(a1);
}

BOOL sub_10037016C(uint64_t a1)
{
  return *(_DWORD *)(a1 + 116) == 2;
}

unint64_t sub_10037017C(uint64_t a1)
{
  return (unint64_t)*(unsigned __int8 *)(a1 + 112) << 32;
}

uint64_t sub_100370188(uint64_t result)
{
  if (*(unsigned char *)(**(void **)(result + 64) + 48)) {
    phoneservices::submitSwitchAnalytics();
  }
  return result;
}

uint64_t sub_1003701C4(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%spersonality config changed", (uint8_t *)&v5, 0x16u);
  }
  sub_10036E78C(a1);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

uint64_t sub_1003702B8(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%spersonal wallet changed", (uint8_t *)&v5, 0x16u);
  }
  sub_10036E78C(a1);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

const void **sub_1003703AC(const void **result, uint64_t a2, void *a3, void *a4)
{
  uint64_t v4 = (uint64_t)result;
  int v5 = (void *)*a3;
  uint64_t v70 = a3 + 1;
  if ((void *)*a3 == a3 + 1)
  {
    int v60 = (const void *)*a4;
    if (result[21] == (const void *)*a4) {
      return result;
    }
    goto LABEL_97;
  }
  uint64_t v6 = a2;
  __int16 v63 = a4;
  char v64 = 0;
  char v69 = 0;
  char v67 = 0;
  int v66 = (uint64_t **)(result + 18);
  __int16 v7 = (uint64_t **)(result + 19);
  uint64_t v8 = kPhoneServicesWalletDomain;
  uint64_t v68 = kPhoneServicesWalletDomain;
  do
  {
    unint64_t v9 = v5[4];
    v71 = 0;
    v73 = 0;
    sub_1003CA004(v9, (uint64_t *)&v73);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CCA0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_101B0CCA0))
    {
      *(void *)long long buf = @"SlicingWasDiscoveredByApp2";
      sub_100367E88(qword_101B0CD10, buf, 1uLL);
      __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0CD10, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0CCA0);
      uint64_t v6 = a2;
      uint64_t v8 = v68;
    }
    v71 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v4 + 48));
    unsigned int v11 = ServiceMap;
    uint64_t v13 = v12;
    if (v12 < 0)
    {
      BOOL v14 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        uint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v13;
    BOOL v17 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
    if (v17)
    {
      uint64_t v18 = v17[3];
      int v19 = (std::__shared_weak_count *)v17[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v8 = v68;
        uint64_t v6 = a2;
        sub_10004D2C8(v19);
        char v20 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    int v19 = 0;
    char v20 = 1;
LABEL_12:
    (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const void *, uint64_t, void *, uint64_t))(*(void *)v18 + 24))(&v71, v18, **(void **)(v4 + 64) + 24, v73, v8, qword_101B0CD10, 1);
    if ((v20 & 1) == 0) {
      sub_10004D2C8(v19);
    }
    if (v71) {
      unsigned int v21 = sub_100080934;
    }
    else {
      unsigned int v21 = 0;
    }
    if (v21)
    {
      BOOL v22 = 0;
      goto LABEL_34;
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CCA8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_101B0CCA8))
    {
      *(void *)long long buf = @"SlicingWasDiscoveredByApp";
      sub_100367E88(qword_101B0CD28, buf, 1uLL);
      __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0CD28, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0CCA8);
      uint64_t v6 = a2;
      uint64_t v8 = v68;
    }
    int v23 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v4 + 48));
    BOOL v24 = v23;
    uint64_t v25 = v12;
    if (v12 < 0)
    {
      char v26 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v27 = 5381;
      do
      {
        uint64_t v25 = v27;
        unsigned int v28 = *v26++;
        uint64_t v27 = (33 * v27) ^ v28;
      }
      while (v28);
    }
    std::mutex::lock(v23);
    *(void *)long long buf = v25;
    int v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)buf);
    if (!v29)
    {
      uint64_t v30 = 0;
LABEL_27:
      std::mutex::unlock(v24);
      unsigned int v31 = 0;
      char v32 = 1;
      goto LABEL_28;
    }
    uint64_t v30 = v29[3];
    unsigned int v31 = (std::__shared_weak_count *)v29[4];
    if (!v31) {
      goto LABEL_27;
    }
    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v24);
    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v8 = v68;
    uint64_t v6 = a2;
    sub_10004D2C8(v31);
    char v32 = 0;
LABEL_28:
    (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const void *, uint64_t, void *, uint64_t))(*(void *)v30 + 24))(&v72, v30, **(void **)(v4 + 64) + 24, v73, v8, qword_101B0CD10, 1);
    *(void *)long long buf = v71;
    v71 = v72;
    uint32_t v72 = 0;
    sub_1000577C4((const void **)buf);
    sub_1000577C4(&v72);
    if ((v32 & 1) == 0) {
      sub_10004D2C8(v31);
    }
    if (v71) {
      __int16 v33 = sub_100080934;
    }
    else {
      __int16 v33 = 0;
    }
    BOOL v22 = v33 != 0;
LABEL_34:
    sub_1000558F4(&v73);
    if (v71) {
      uint64_t v34 = sub_100080934;
    }
    else {
      uint64_t v34 = 0;
    }
    if (!v34)
    {
      char v35 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v4 + 64));
        if (*(char *)(v6 + 23) >= 0) {
          uint64_t v37 = v6;
        }
        else {
          uint64_t v37 = *(void *)v6;
        }
        *(_DWORD *)long long buf = 136315906;
        *(void *)&uint8_t buf[4] = v36;
        __int16 v75 = 2080;
        long long v76 = " ";
        __int16 v77 = 2080;
        uint64_t v78 = v37;
        __int16 v79 = 2048;
        unint64_t v80 = v9;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I %s%sSlicing was discovered for app: %s category %llu", buf, 0x2Au);
      }
      if ((v67 & 1) == 0) {
        sub_1003C93A8(v4, v6);
      }
      BOOL v22 = 1;
      char v67 = 1;
      char v64 = 1;
    }
    CFTypeID v38 = *v7;
    uint64_t v39 = (uint64_t **)(v4 + 152);
    uint64_t v40 = (uint64_t **)(v4 + 152);
    if (!*v7) {
      goto LABEL_64;
    }
    unsigned int v41 = (uint64_t **)(v4 + 152);
    CFTypeID v42 = *v7;
    do
    {
      unint64_t v43 = v42[4];
      BOOL v44 = v43 >= v9;
      if (v43 >= v9) {
        char v45 = (uint64_t **)v42;
      }
      else {
        char v45 = (uint64_t **)(v42 + 1);
      }
      if (v44) {
        unsigned int v41 = (uint64_t **)v42;
      }
      CFTypeID v42 = *v45;
    }
    while (*v45);
    if (v41 == v7 || v9 < (unint64_t)v41[4])
    {
      uint64_t v39 = (uint64_t **)(v4 + 152);
      uint64_t v40 = (uint64_t **)(v4 + 152);
      if (v38)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v40 = (uint64_t **)v38;
            unint64_t v46 = v38[4];
            if (v46 <= v9) {
              break;
            }
            CFTypeID v38 = *v40;
            uint64_t v39 = v40;
            if (!*v40) {
              goto LABEL_64;
            }
          }
          if (v46 >= v9) {
            break;
          }
          CFTypeID v38 = v40[1];
          if (!v38)
          {
            uint64_t v39 = v40 + 1;
            goto LABEL_64;
          }
        }
      }
      else
      {
LABEL_64:
        __int16 v47 = operator new(0x30uLL);
        v47[4] = v9;
        *((_DWORD *)v47 + 10) = 0;
        sub_100046C38(v66, (uint64_t)v40, v39, v47);
      }
      char v69 = 1;
    }
    if (!v22) {
      goto LABEL_79;
    }
    v73 = 0;
    sub_1003CA004(v9, (uint64_t *)&v73);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CC98, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_101B0CC98))
    {
      *(void *)long long buf = @"SlicingWasDiscoveredByApp2";
      sub_100367E88(qword_101B0CCF8, buf, 1uLL);
      __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0CCF8, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0CC98);
      uint64_t v6 = a2;
      uint64_t v8 = v68;
    }
    uint64_t v48 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v4 + 48));
    uint64_t v49 = v48;
    if (v12 < 0)
    {
      CFNumberRef v50 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v51 = 5381;
      do
      {
        uint64_t v12 = v51;
        unsigned int v52 = *v50++;
        uint64_t v51 = (33 * v51) ^ v52;
      }
      while (v52);
    }
    std::mutex::lock(v48);
    *(void *)long long buf = v12;
    uint64_t v53 = sub_10004D37C(&v49[1].__m_.__sig, (unint64_t *)buf);
    if (!v53)
    {
      uint64_t v54 = 0;
LABEL_75:
      std::mutex::unlock(v49);
      uint64_t v55 = 0;
      char v56 = 1;
      goto LABEL_76;
    }
    uint64_t v54 = v53[3];
    uint64_t v55 = (std::__shared_weak_count *)v53[4];
    if (!v55) {
      goto LABEL_75;
    }
    atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v49);
    atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v8 = v68;
    sub_10004D2C8(v55);
    char v56 = 0;
LABEL_76:
    (*(void (**)(uint64_t, uint64_t, const void *, const CFBooleanRef, uint64_t, void *, uint64_t, void))(*(void *)v54 + 16))(v54, **(void **)(v4 + 64) + 24, v73, kCFBooleanTrue, v8, qword_101B0CCF8, 1, 0);
    if ((v56 & 1) == 0) {
      sub_10004D2C8(v55);
    }
    sub_1000558F4(&v73);
LABEL_79:
    uint64_t result = sub_1000577C4(&v71);
    BOOL v57 = (void *)v5[1];
    if (v57)
    {
      do
      {
        uint64_t v58 = v57;
        BOOL v57 = (void *)*v57;
      }
      while (v57);
    }
    else
    {
      do
      {
        uint64_t v58 = (void *)v5[2];
        BOOL v59 = *v58 == (void)v5;
        int v5 = v58;
      }
      while (!v59);
    }
    int v5 = v58;
  }
  while (v58 != v70);
  a4 = v63;
  int v60 = (const void *)*v63;
  if (*(void *)(v4 + 168) != *v63)
  {
LABEL_97:
    uint64_t v61 = a4[1];
    if (v61) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v61 + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v62 = *(std::__shared_weak_count **)(v4 + 176);
    *(void *)(v4 + 168) = v60;
    *(void *)(v4 + 176) = v61;
    if (v62) {
      sub_10004D2C8(v62);
    }
    goto LABEL_101;
  }
  if (v69)
  {
LABEL_101:
    sub_10036FB50(v4);
    return (const void **)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v4 + 104))(v4, 1, 0);
  }
  if (v64) {
    return (const void **)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v4 + 104))(v4, 1, 0);
  }
  return result;
}

void sub_100370BD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va1, a14);
  va_start(va, a14);
  uint64_t v15 = va_arg(va1, const void *);
  uint64_t v17 = va_arg(va1, void);
  __cxa_guard_abort(&qword_101B0CCA8);
  sub_1000577C4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_100370CC0(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v5;
  unint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v13);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unsigned int v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  unsigned int v10 = 0;
  char v12 = 1;
LABEL_9:
  (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v11 + 40))(v11, kAlertDialogLocalizationTable, a2, 0);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100370DE8(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100370E04@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  CFMutableDictionaryRef theDict = 0;
  int v4 = *(_DWORD *)(a1 + 120);
  if ((v4 - 2) < 2)
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFMutableDictionaryRef v11 = theDict;
      CFMutableDictionaryRef theDict = Mutable;
      *(void *)long long valuePtr = v11;
      sub_10005717C((const void **)valuePtr);
    }
    CFDictionarySetValue(theDict, kCTCapabilityCanChangeSetting, kCFBooleanTrue);
    char v9 = 1;
    char v7 = 1;
    char v8 = 1;
  }
  else if (v4 == 4)
  {
    char v12 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v12)
    {
      CFMutableDictionaryRef v13 = theDict;
      CFMutableDictionaryRef theDict = v12;
      *(void *)long long valuePtr = v13;
      sub_10005717C((const void **)valuePtr);
    }
    CFDictionarySetValue(theDict, kCTCapabilityCanChangeSettingEnableStillProvisioning, kCFBooleanTrue);
    char v8 = 0;
    char v9 = 1;
    char v7 = 1;
  }
  else if (v4 == 5)
  {
    unint64_t v5 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v5)
    {
      CFMutableDictionaryRef v6 = theDict;
      CFMutableDictionaryRef theDict = v5;
      *(void *)long long valuePtr = v6;
      sub_10005717C((const void **)valuePtr);
    }
    CFDictionarySetValue(theDict, kCTCapabilityCannotChangeSettingNeedToCallCarrier, kCFBooleanTrue);
    char v7 = 0;
    char v8 = 0;
    char v9 = 1;
  }
  else
  {
    char v9 = 0;
    char v7 = 0;
    char v8 = 0;
  }
  if (theDict) {
    BOOL v14 = sub_1000C06D0;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14)
  {
    char v52 = v7;
    char v53 = v9;
    char v54 = v8;
    uint64_t v55 = a2;
    unint64_t v62 = 0;
    CFMutableArrayRef v15 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v15)
    {
      unsigned int v16 = v62;
      unint64_t v62 = v15;
      *(void *)long long valuePtr = v16;
      sub_1000440D4((const void **)valuePtr);
    }
    uint64_t v17 = *(void **)(a1 + 144);
    if (v17 != (void *)(a1 + 152))
    {
      uint64_t v18 = (const void *)kCTNetworkSlicingCategoryID;
      int v19 = (const void *)kCTNetworkSlicingCategoryName;
      char v20 = (const void *)kCTNetworkSlicingCategoryState;
      while (1)
      {
        CFMutableDictionaryRef v61 = 0;
        unsigned int v21 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v21)
        {
          CFMutableDictionaryRef v22 = v61;
          CFMutableDictionaryRef v61 = v21;
          *(void *)long long valuePtr = v22;
          sub_10005717C((const void **)valuePtr);
        }
        int v23 = v17 + 4;
        CFNumberRef v60 = 0;
        CFNumberRef v60 = CFNumberCreate(0, kCFNumberLongLongType, v17 + 4);
        CFDictionarySetValue(v61, v18, v60);
        xpc_object_t value = 0;
        uint64_t v24 = *(void *)(a1 + 168);
        if (!v24) {
          goto LABEL_36;
        }
        uint64_t v27 = *(void **)(v24 + 8);
        uint64_t v25 = (void *)(v24 + 8);
        char v26 = v27;
        if (!v27) {
          goto LABEL_36;
        }
        unint64_t v28 = *v23;
        int v29 = v25;
        do
        {
          unint64_t v30 = v26[4];
          BOOL v31 = v30 >= v28;
          if (v30 >= v28) {
            char v32 = v26;
          }
          else {
            char v32 = v26 + 1;
          }
          if (v31) {
            int v29 = v26;
          }
          char v26 = (void *)*v32;
        }
        while (*v32);
        if (v29 != v25 && v28 >= v29[4])
        {
          if (*((char *)v29 + 63) < 0)
          {
            sub_10004FC84(__dst, (void *)v29[5], v29[6]);
          }
          else
          {
            *(_OWORD *)std::string __dst = *(_OWORD *)(v29 + 5);
            uint64_t v57 = v29[7];
          }
          if (SHIBYTE(v57) < 0)
          {
            sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)__dst;
            uint64_t v66 = v57;
          }
          CFStringRef v64 = 0;
          if (SHIBYTE(v66) < 0)
          {
            sub_10004FC84(valuePtr, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)long long valuePtr = *(_OWORD *)__p;
            *(void *)&valuePtr[16] = v66;
          }
          CFStringRef v67 = 0;
          if (ctu::cf::convert_copy())
          {
            CFStringRef v48 = v64;
            CFStringRef v64 = v67;
            CFStringRef v68 = v48;
            sub_1000558F4((const void **)&v68);
          }
          if ((valuePtr[23] & 0x80000000) != 0) {
            operator delete(*(void **)valuePtr);
          }
          CFStringRef v58 = v64;
          CFStringRef v64 = 0;
          sub_1000558F4((const void **)&v64);
          if (SHIBYTE(v66) < 0) {
            operator delete(__p[0]);
          }
          *(void *)long long valuePtr = value;
          uint64_t v49 = (__CFString *)v58;
          CFStringRef v58 = 0;
          xpc_object_t value = v49;
          sub_1000558F4((const void **)valuePtr);
          sub_1000558F4((const void **)&v58);
          if (SHIBYTE(v57) < 0) {
            operator delete(__dst[0]);
          }
          __int16 v33 = value;
        }
        else
        {
LABEL_36:
          __int16 v33 = 0;
        }
        if (v33) {
          uint64_t v34 = sub_1000810B8;
        }
        else {
          uint64_t v34 = 0;
        }
        if (!v34)
        {
          if (*v23 == -1)
          {
            *(void *)long long valuePtr = @"Managed Apps";
            sub_100013168((const void **)&value, (CFTypeRef *)valuePtr);
          }
          else
          {
            CFStringRef v68 = 0;
            sub_100370CC0(a1, @"GENRE_FOR_SLICING_GENERIC_%@");
            CFStringRef v67 = 0;
            unint64_t v35 = *v23;
            __p[0] = 0;
            *(void *)long long valuePtr = v35;
            CFNumberRef v36 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, valuePtr);
            if (v36)
            {
              uint64_t v37 = __p[0];
              __p[0] = v36;
              *(void *)long long valuePtr = v37;
              sub_1000570E8((const void **)valuePtr);
            }
            CFStringRef v67 = (const __CFString *)__p[0];
            __p[0] = 0;
            sub_1000570E8((const void **)__p);
            if (v68) {
              CFTypeID v38 = sub_1000810B8;
            }
            else {
              CFTypeID v38 = 0;
            }
            if (v38)
            {
              uint64_t v39 = (__CFString *)CFStringCreateWithFormat(0, 0, v68, v67);
            }
            else
            {
              uint64_t v40 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
              {
                uint64_t v50 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
                *(_DWORD *)long long valuePtr = 136315394;
                *(void *)&valuePtr[4] = v50;
                *(_WORD *)&valuePtr[12] = 2080;
                *(void *)&valuePtr[14] = " ";
                _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "#E %s%sGENRE_FOR_SLICING_GENERIC is empty", valuePtr, 0x16u);
              }
              uint64_t v39 = (__CFString *)CFStringCreateWithFormat(0, 0, @"%@ Apps", v67);
            }
            unsigned int v41 = value;
            xpc_object_t value = v39;
            *(void *)long long valuePtr = v41;
            sub_1000558F4((const void **)valuePtr);
            sub_1000570E8((const void **)&v67);
            sub_1000558F4((const void **)&v68);
          }
        }
        CFDictionarySetValue(v61, v19, value);
        int v42 = *((_DWORD *)v17 + 10);
        if (v42 == 1) {
          break;
        }
        if (v42 == 2)
        {
          unint64_t v43 = v61;
        }
        else
        {
          unint64_t v43 = v61;
          if (!*(unsigned char *)(a1 + 112)) {
            goto LABEL_62;
          }
        }
        BOOL v44 = (const void **)&kCFBooleanTrue;
LABEL_63:
        CFDictionarySetValue(v43, v20, *v44);
        CFArrayAppendValue(v62, v61);
        sub_1000558F4((const void **)&value);
        sub_1000570E8((const void **)&v60);
        sub_10005717C((const void **)&v61);
        char v45 = (void *)v17[1];
        if (v45)
        {
          do
          {
            unint64_t v46 = v45;
            char v45 = (void *)*v45;
          }
          while (v45);
        }
        else
        {
          do
          {
            unint64_t v46 = (void *)v17[2];
            BOOL v47 = *v46 == (void)v17;
            uint64_t v17 = v46;
          }
          while (!v47);
        }
        uint64_t v17 = v46;
        if (v46 == (void *)(a1 + 152)) {
          goto LABEL_86;
        }
      }
      unint64_t v43 = v61;
LABEL_62:
      BOOL v44 = (const void **)&kCFBooleanFalse;
      goto LABEL_63;
    }
LABEL_86:
    CFDictionarySetValue(theDict, kCTNetworkSlicingCategories, v62);
    sub_1000440D4((const void **)&v62);
    a2 = v55;
    char v9 = v53;
    char v8 = v54;
    char v7 = v52;
  }
  *(unsigned char *)a2 = v9;
  *(unsigned char *)(a2 + 1) = v7;
  *(unsigned char *)(a2 + 2) = v8;
  sub_10004EFE4((void *)(a2 + 8), (CFTypeRef *)&theDict);
  return sub_10005717C((const void **)&theDict);
}

void sub_100371504(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,const void *a24,const void *a25,const void *a26,const void *a27,const void *a28,const void *a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  sub_1000558F4(&a24);
  sub_1000570E8(&a25);
  sub_10005717C(&a26);
  sub_1000440D4(&a27);
  sub_10005717C(&a28);
  _Unwind_Resume(a1);
}

const void **sub_1003715E8@<X0>(_DWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = 0;
  CFMutableDictionaryRef v6 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 56))(&v5);
  *(unsigned char *)a2 = a1[29] == 2;
  sub_100058198((const void **)(a2 + 8), &v6);
  return sub_100057D78(&v6);
}

void sub_100371678(uint64_t a1, BOOL a2, CFDictionaryRef *a3)
{
  CFMutableDictionaryRef v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v8 = asStringBool(a2);
    uint64_t v9 = *(int *)(a1 + 120);
    if (v9 > 5) {
      unsigned int v10 = "???";
    }
    else {
      unsigned int v10 = off_1019BEB50[v9];
    }
    *(_DWORD *)long long buf = 136315906;
    uint64_t v44 = v7;
    __int16 v45 = 2080;
    unint64_t v46 = " ";
    __int16 v47 = 2080;
    unint64_t v48 = v8;
    __int16 v49 = 2080;
    uint64_t v50 = (void *)v10;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%ssetEnabled(%s): Current 'Network Slicing canSet' status: %s", buf, 0x2Au);
  }
  unsigned int v11 = *(_DWORD *)(a1 + 120);
  BOOL v12 = v11 > 5;
  int v13 = (1 << v11) & 0x23;
  if (v12 || v13 == 0)
  {
    if (*a3) {
      CFMutableArrayRef v15 = sub_100080778;
    }
    else {
      CFMutableArrayRef v15 = 0;
    }
    if (v15)
    {
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*a3, kCTNetworkSlicingCategoryID);
      if (Value)
      {
        CFNumberRef v17 = Value;
        CFTypeID v18 = CFGetTypeID(Value);
        if (v18 == CFNumberGetTypeID())
        {
          unint64_t v41 = 0;
          if (CFNumberGetValue(v17, kCFNumberLongLongType, &v41))
          {
            unint64_t v19 = v41;
            unint64_t v42 = v41;
            if (a2) {
              int v20 = 2;
            }
            else {
              int v20 = 1;
            }
            unsigned int v21 = *(void **)(a1 + 152);
            if (!v21) {
              goto LABEL_32;
            }
            uint64_t v22 = a1 + 152;
            do
            {
              unint64_t v23 = v21[4];
              BOOL v24 = v23 >= v41;
              if (v23 >= v41) {
                uint64_t v25 = v21;
              }
              else {
                uint64_t v25 = v21 + 1;
              }
              if (v24) {
                uint64_t v22 = (uint64_t)v21;
              }
              unsigned int v21 = (void *)*v25;
            }
            while (*v25);
            if (v22 != a1 + 152 && *(void *)(v22 + 32) <= v41)
            {
              uint64_t v36 = *(int *)(v22 + 40);
              if (v36 != v20)
              {
                uint64_t v37 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v38 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
                  if (v36 > 2) {
                    uint64_t v39 = (char *)&unk_10161656E;
                  }
                  else {
                    uint64_t v39 = off_1019BEB80[v36];
                  }
                  uint64_t v40 = "Disabled";
                  *(_DWORD *)long long buf = 136316162;
                  uint64_t v44 = v38;
                  __int16 v45 = 2080;
                  unint64_t v46 = " ";
                  if (a2) {
                    uint64_t v40 = "Enabled";
                  }
                  __int16 v47 = 2048;
                  unint64_t v48 = v19;
                  __int16 v49 = 2080;
                  uint64_t v50 = v39;
                  __int16 v51 = 2080;
                  char v52 = v40;
                  _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s%sNetwork Slicing Switch: changed user preference for category %lld from %s to %s", buf, 0x34u);
                }
                *((_DWORD *)sub_100372D38((uint64_t **)(a1 + 144), v19, &v42) + 10) = v20;
                sub_10036FB50(a1);
                *(unsigned char *)(a1 + 112) = sub_10036F2E4(a1);
              }
            }
            else
            {
LABEL_32:
              char v26 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v27 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
                *(_DWORD *)long long buf = 136315650;
                uint64_t v44 = v27;
                __int16 v45 = 2080;
                unint64_t v46 = " ";
                __int16 v47 = 2048;
                unint64_t v48 = v19;
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sCategory %lld unknown/undiscovered", buf, 0x20u);
              }
            }
            (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, 1, 0);
            return;
          }
          uint64_t v34 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
            return;
          }
          uint64_t v35 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
          *(_DWORD *)long long buf = 136315650;
          uint64_t v44 = v35;
          __int16 v45 = 2080;
          unint64_t v46 = " ";
          __int16 v47 = 2112;
          unint64_t v48 = (unint64_t)v17;
          unint64_t v30 = "#E %s%scapability ID has wrong format '%@'";
          char v32 = v34;
          uint32_t v33 = 32;
LABEL_40:
          _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, v30, buf, v33);
          return;
        }
      }
      unint64_t v28 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        return;
      }
      uint64_t v29 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)long long buf = 136315394;
      uint64_t v44 = v29;
      __int16 v45 = 2080;
      unint64_t v46 = " ";
      unint64_t v30 = "#E %s%scannot set capability preference without capability ID";
    }
    else
    {
      unint64_t v28 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        return;
      }
      uint64_t v31 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)long long buf = 136315394;
      uint64_t v44 = v31;
      __int16 v45 = 2080;
      unint64_t v46 = " ";
      unint64_t v30 = "#E %s%scannot set capability preference without 'info' dictionary";
    }
    char v32 = v28;
    uint32_t v33 = 22;
    goto LABEL_40;
  }
}

void sub_100371B48(uint64_t a1, int a2, char a3)
{
  BOOL v6 = sub_10036E2A0(a1);
  int v7 = *(unsigned __int8 *)(a1 + 104);
  if (*(unsigned char *)(a1 + 104)) {
    int v8 = 2;
  }
  else {
    int v8 = 1;
  }
  int v9 = *(_DWORD *)(a1 + 108);
  char v91 = a3;
  BOOL v92 = v6;
  if (v9 != v8)
  {
    unsigned int v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)long long buf = 136315906;
      *(void *)&uint8_t buf[4] = v11;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&buf[22] = 2080;
      unint64_t v97 = (long long *)asString();
      LOWORD(v98) = 2080;
      *(void *)((char *)&v98 + 2) = asString();
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%sNetwork slicing account/network support is changing from %s to %s", buf, 0x2Au);
      int v7 = *(unsigned __int8 *)(a1 + 104);
    }
    *(_DWORD *)(a1 + 108) = v8;
  }
  if (!v7) {
    goto LABEL_45;
  }
  v94 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  int v13 = ServiceMap;
  uint64_t v15 = v14;
  if (v14 < 0)
  {
    unsigned int v16 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v15;
  unint64_t v19 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
  if (v19)
  {
    uint64_t v21 = v19[3];
    int v20 = (std::__shared_weak_count *)v19[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v13);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v20);
      char v22 = 0;
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  std::mutex::unlock(v13);
  int v20 = 0;
  char v22 = 1;
LABEL_17:
  uint64_t v23 = kPhoneServicesWalletDomain;
  (*(void (**)(uint64_t **__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v21 + 24))(&v94, v21, **(void **)(a1 + 64) + 24, @"SlicingWasDiscoveredByApp2", kPhoneServicesWalletDomain, 0, 1);
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  BOOL v24 = v94;
  if (v94) {
    uint64_t v25 = sub_100080934;
  }
  else {
    uint64_t v25 = 0;
  }
  if (!v25)
  {
    char v26 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    uint64_t v27 = v26;
    if (v14 < 0)
    {
      unint64_t v28 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v29 = 5381;
      do
      {
        uint64_t v14 = v29;
        unsigned int v30 = *v28++;
        uint64_t v29 = (33 * v29) ^ v30;
      }
      while (v30);
    }
    std::mutex::lock(v26);
    *(void *)long long buf = v14;
    uint64_t v31 = sub_10004D37C(&v27[1].__m_.__sig, (unint64_t *)buf);
    if (v31)
    {
      uint64_t v33 = v31[3];
      char v32 = (std::__shared_weak_count *)v31[4];
      if (v32)
      {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v27);
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v32);
        char v34 = 0;
LABEL_31:
        (*(void (**)(uint64_t **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t, void, uint64_t))(*(void *)v33 + 24))(&v93, v33, **(void **)(a1 + 64) + 24, @"SlicingWasDiscoveredByApp", v23, 0, 1);
        *(void *)long long buf = v94;
        uint64_t v35 = v93;
        v93 = 0;
        v94 = v35;
        sub_1000577C4((const void **)buf);
        sub_1000577C4((const void **)&v93);
        if ((v34 & 1) == 0) {
          sub_10004D2C8(v32);
        }
        BOOL v24 = v94;
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v33 = 0;
    }
    std::mutex::unlock(v27);
    char v32 = 0;
    char v34 = 1;
    goto LABEL_31;
  }
LABEL_34:
  if (v24) {
    uint64_t v36 = sub_100080934;
  }
  else {
    uint64_t v36 = 0;
  }
  sub_1000577C4((const void **)&v94);
  if (v36)
  {
    if (sub_10036F11C(a1))
    {
      int v37 = 2;
      uint64_t v38 = "kCanSetCanEnableDisable";
      goto LABEL_46;
    }
    uint64_t v39 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v42 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v42;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      unint64_t v41 = "#I %s%sEither Network Slicing switch support is not present or it is set to false";
      goto LABEL_44;
    }
  }
  else
  {
    uint64_t v39 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v40 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v40;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      unint64_t v41 = "#I %s%sNetwork Slicing was not yet discovered - hide settings";
LABEL_44:
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, v41, buf, 0x16u);
    }
  }
LABEL_45:
  int v37 = 1;
  uint64_t v38 = "kCannotSet";
LABEL_46:
  int v43 = *(_DWORD *)(a1 + 120);
  if (v43 != v37)
  {
    uint64_t v44 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v45 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v46 = *(int *)(a1 + 120);
      if (v46 > 5) {
        __int16 v47 = "???";
      }
      else {
        __int16 v47 = off_1019BEB50[v46];
      }
      *(_DWORD *)long long buf = 136315906;
      *(void *)&uint8_t buf[4] = v45;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&buf[22] = 2080;
      unint64_t v97 = (long long *)v47;
      LOWORD(v98) = 2080;
      *(void *)((char *)&v98 + 2) = v38;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I %s%sNetwork Slicing switch support is changing from %s to %s", buf, 0x2Au);
    }
    *(_DWORD *)(a1 + 120) = v37;
  }
  int v48 = *(unsigned __int8 *)(a1 + 112);
  int v49 = sub_10036F2E4(a1);
  *(unsigned char *)(a1 + 112) = v49;
  BOOL v50 = v48 != v49;
  __int16 v51 = **(PersonalityInfo ***)(a1 + 64);
  if (*((unsigned char *)v51 + 48))
  {
    int v52 = *(_DWORD *)(a1 + 108);
    if ((v49 & (v52 == 2)) != 0) {
      int v53 = 2;
    }
    else {
      int v53 = 1;
    }
    if (v52) {
      int v54 = v53;
    }
    else {
      int v54 = 0;
    }
  }
  else
  {
    int v54 = 0;
  }
  if (v54 != *(_DWORD *)(a1 + 116))
  {
    uint64_t v55 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v56 = PersonalityInfo::logPrefix(v51);
      uint64_t v57 = asString();
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v56;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&buf[22] = 2080;
      unint64_t v97 = (long long *)v57;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I %s%sNetwork Slicing feature re-evaluated to %s", buf, 0x20u);
    }
    *(_DWORD *)(a1 + 116) = v54;
    BOOL v50 = 1;
  }
  if (v43 != v37) {
    BOOL v50 = 1;
  }
  if (v9 != v8) {
    BOOL v50 = 1;
  }
  BOOL v58 = v50 || v92;
  sub_100A2FD3C(*(void *)(a1 + 80), 4, a2);
  if (v58 || (v91 & 1) != 0 || a2)
  {
    memset(buf, 0, sizeof(buf));
    unint64_t v97 = &v98;
    buf[0] = *(unsigned char *)(a1 + 104);
    uint8_t buf[8] = *(unsigned char *)(a1 + 112);
    unsigned char buf[12] = *(_DWORD *)(a1 + 108) == 2;
    *(_DWORD *)&uint8_t buf[16] = *(_DWORD *)(a1 + 116);
    long long v98 = 0uLL;
    BOOL v59 = *(void **)(a1 + 144);
    if (v59 != (void *)(a1 + 152))
    {
      do
      {
        uint64_t v60 = *((unsigned int *)v59 + 10);
        if (v60 == 1)
        {
          unint64_t v62 = 0;
          unint64_t v61 = v59[4];
        }
        else
        {
          if (v60 == 2)
          {
            unint64_t v61 = v59[4];
          }
          else
          {
            unint64_t v61 = v59[4];
            if (!*(unsigned char *)(a1 + 113))
            {
              unint64_t v62 = 0;
              goto LABEL_79;
            }
          }
          unint64_t v62 = &_mh_execute_header;
        }
LABEL_79:
        __int16 v63 = (uint64_t **)&v98;
        CFStringRef v64 = (uint64_t **)&v98;
        if ((void)v98)
        {
          __int16 v65 = (uint64_t *)v98;
          while (1)
          {
            while (1)
            {
              CFStringRef v64 = (uint64_t **)v65;
              unint64_t v66 = v65[4];
              if (v66 <= v61) {
                break;
              }
              __int16 v65 = *v64;
              __int16 v63 = v64;
              if (!*v64) {
                goto LABEL_87;
              }
            }
            if (v66 >= v61) {
              break;
            }
            __int16 v65 = v64[1];
            if (!v65)
            {
              __int16 v63 = v64 + 1;
              goto LABEL_87;
            }
          }
        }
        else
        {
LABEL_87:
          CFStringRef v67 = (uint64_t *)operator new(0x30uLL);
          v67[4] = v61;
          v67[5] = (unint64_t)v62 | v60;
          *CFStringRef v67 = 0;
          v67[1] = 0;
          v67[2] = (uint64_t)v64;
          void *v63 = v67;
          if (*(void *)v97)
          {
            unint64_t v97 = *(long long **)v97;
            CFStringRef v67 = *v63;
          }
          sub_100046C90((uint64_t *)v98, v67);
          ++*((void *)&v98 + 1);
        }
        CFStringRef v68 = (void *)v59[1];
        if (v68)
        {
          do
          {
            char v69 = v68;
            CFStringRef v68 = (void *)*v68;
          }
          while (v68);
        }
        else
        {
          do
          {
            char v69 = (void *)v59[2];
            BOOL v70 = *v69 == (void)v59;
            BOOL v59 = v69;
          }
          while (!v70);
        }
        BOOL v59 = v69;
      }
      while (v69 != (void *)(a1 + 152));
    }
    uint64_t v71 = *(void *)(a1 + 80);
    uint32_t v72 = (char *)operator new(0x48uLL);
    v73 = v72;
    *((void *)v72 + 1) = 0;
    *((void *)v72 + 2) = 0;
    *(void *)uint32_t v72 = off_1019BEB10;
    *(_OWORD *)(v72 + 24) = *(_OWORD *)buf;
    *((_DWORD *)v72 + 10) = *(_DWORD *)&buf[16];
    *((void *)v72 + 7) = 0;
    os_log_t v74 = v72 + 56;
    *((void *)v72 + 6) = v72 + 56;
    __int16 v75 = (void **)(v72 + 48);
    *((void *)v72 + 8) = 0;
    long long v76 = v97;
    if (v97 != &v98)
    {
      __int16 v77 = 0;
      uint64_t v78 = v72 + 56;
      while (1)
      {
        unint64_t v79 = *((void *)v76 + 4);
        unint64_t v80 = v74;
        if (v78 == v74) {
          break;
        }
        int v81 = v77;
        int v82 = v74;
        if (v77)
        {
          do
          {
            unint64_t v80 = v81;
            int v81 = (void *)v81[1];
          }
          while (v81);
        }
        else
        {
          do
          {
            unint64_t v80 = (void *)v82[2];
            BOOL v70 = *v80 == (void)v82;
            int v82 = v80;
          }
          while (v70);
        }
        if (v80[4] < v79) {
          break;
        }
        uint64_t v84 = v74;
        unint64_t v83 = v74;
        if (!v77) {
          goto LABEL_122;
        }
        uint64_t v85 = v77;
        while (1)
        {
          while (1)
          {
            unint64_t v83 = v85;
            unint64_t v86 = v85[4];
            if (v86 <= v79) {
              break;
            }
            uint64_t v85 = (void *)*v83;
            uint64_t v84 = v83;
            if (!*v83) {
              goto LABEL_122;
            }
          }
          if (v86 >= v79) {
            break;
          }
          uint64_t v85 = (void *)v83[1];
          if (!v85)
          {
            uint64_t v84 = v83 + 1;
            goto LABEL_122;
          }
        }
LABEL_125:
        __int16 v89 = (long long *)*((void *)v76 + 1);
        if (v89)
        {
          do
          {
            os_log_t v90 = v89;
            __int16 v89 = *(long long **)v89;
          }
          while (v89);
        }
        else
        {
          do
          {
            os_log_t v90 = (long long *)*((void *)v76 + 2);
            BOOL v70 = *(void *)v90 == (void)v76;
            long long v76 = v90;
          }
          while (!v70);
        }
        if (v90 == &v98) {
          goto LABEL_132;
        }
        __int16 v77 = (void *)*v74;
        uint64_t v78 = *v75;
        long long v76 = v90;
      }
      if (v77) {
        unint64_t v83 = v80;
      }
      else {
        unint64_t v83 = v74;
      }
      if (v77) {
        uint64_t v84 = v80 + 1;
      }
      else {
        uint64_t v84 = v74;
      }
      if (*v84) {
        goto LABEL_125;
      }
LABEL_122:
      __int16 v87 = operator new(0x30uLL);
      v87[2] = v76[2];
      *(void *)__int16 v87 = 0;
      *((void *)v87 + 1) = 0;
      *((void *)v87 + 2) = v83;
      *uint64_t v84 = v87;
      v88 = (void *)**v75;
      if (v88)
      {
        *__int16 v75 = v88;
        __int16 v87 = (_OWORD *)*v84;
      }
      sub_100046C90(*((uint64_t **)v73 + 7), (uint64_t *)v87);
      ++*((void *)v73 + 8);
      goto LABEL_125;
    }
LABEL_132:
    v94 = (uint64_t *)(v73 + 24);
    v95 = (std::__shared_weak_count *)v73;
    sub_100A321D8(v71, 4, &v94);
    if (v95) {
      sub_10004D2C8(v95);
    }
    sub_1000346F8((uint64_t)&v97, (void *)v98);
  }
}

void sub_1003724A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v6);
  }
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100372554(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v4 = **(void **)(a1 + 64);
    int v7 = *(const char **)(v4 + 24);
    char v5 = (const char *)(v4 + 24);
    BOOL v6 = v7;
    uint64_t v8 = *((unsigned __int8 *)v5 + 23);
    int v9 = (char)v8;
    if ((v8 & 0x80u) != 0) {
      uint64_t v8 = *((void *)v5 + 1);
    }
    if (v9 < 0) {
      char v5 = v6;
    }
    if (!v8) {
      char v5 = "<invalid>";
    }
    *(_DWORD *)long long buf = 136315650;
    uint64_t v45 = v3;
    __int16 v46 = 2080;
    __int16 v47 = " ";
    __int16 v48 = 2080;
    uint64_t v49 = (uint64_t)v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s== dump NetworkSlicingControl '%s'", buf, 0x20u);
    int v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v11 = asStringBool(*(unsigned char *)(a1 + 104));
    *(_DWORD *)long long buf = 136315650;
    uint64_t v45 = v10;
    __int16 v46 = 2080;
    __int16 v47 = " ";
    __int16 v48 = 2080;
    uint64_t v49 = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | Carrier support: %s", buf, 0x20u);
    int v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v13 = asString();
    *(_DWORD *)long long buf = 136315650;
    uint64_t v45 = v12;
    __int16 v46 = 2080;
    __int16 v47 = " ";
    __int16 v48 = 2080;
    uint64_t v49 = v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | Account/Network support: %s", buf, 0x20u);
    int v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v15 = asStringBool(*(unsigned char *)(a1 + 112));
    *(_DWORD *)long long buf = 136315650;
    uint64_t v45 = v14;
    __int16 v46 = 2080;
    __int16 v47 = " ";
    __int16 v48 = 2080;
    uint64_t v49 = v15;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | Actual Network Slicing switch state: %s", buf, 0x20u);
    int v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v17 = *(int *)(a1 + 120);
    if (v17 > 5) {
      unsigned int v18 = "???";
    }
    else {
      unsigned int v18 = off_1019BEB50[v17];
    }
    *(_DWORD *)long long buf = 136315650;
    uint64_t v45 = v16;
    __int16 v46 = 2080;
    __int16 v47 = " ";
    __int16 v48 = 2080;
    uint64_t v49 = (uint64_t)v18;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | CanSet state: %s", buf, 0x20u);
    int v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v20 = asString();
    *(_DWORD *)long long buf = 136315650;
    uint64_t v45 = v19;
    __int16 v46 = 2080;
    __int16 v47 = " ";
    __int16 v48 = 2080;
    uint64_t v49 = v20;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | Final capability state: %s", buf, 0x20u);
    int v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v22 = asStringBool(*(unsigned char *)(a1 + 113));
    *(_DWORD *)long long buf = 136315650;
    uint64_t v45 = v21;
    __int16 v46 = 2080;
    __int16 v47 = " ";
    __int16 v48 = 2080;
    uint64_t v49 = v22;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | EnableByDefault: %s", buf, 0x20u);
    int v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v24 = *(void *)(a1 + 160);
    *(_DWORD *)long long buf = 136315650;
    uint64_t v45 = v23;
    __int16 v46 = 2080;
    __int16 v47 = " ";
    __int16 v48 = 2048;
    uint64_t v49 = v24;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | DiscoveredCategories: %zu items", buf, 0x20u);
  }
  uint64_t v25 = *(void **)(a1 + 144);
  if (v25 != (void *)(a1 + 152))
  {
    do
    {
      uint64_t v26 = *(void *)(a1 + 168);
      if (!v26) {
        goto LABEL_41;
      }
      uint64_t v29 = *(void **)(v26 + 8);
      uint64_t v27 = (void *)(v26 + 8);
      unint64_t v28 = v29;
      if (!v29) {
        goto LABEL_41;
      }
      unint64_t v30 = v25[4];
      uint64_t v31 = v27;
      do
      {
        unint64_t v32 = v28[4];
        BOOL v33 = v32 >= v30;
        if (v32 >= v30) {
          char v34 = v28;
        }
        else {
          char v34 = v28 + 1;
        }
        if (v33) {
          uint64_t v31 = v28;
        }
        unint64_t v28 = (void *)*v34;
      }
      while (*v34);
      if (v31 != v27)
      {
        uint64_t v35 = "-";
        if (v30 >= v31[4])
        {
          uint64_t v35 = (const char *)(v31 + 5);
          if (*((char *)v31 + 63) < 0) {
            uint64_t v35 = *(const char **)v35;
          }
        }
      }
      else
      {
LABEL_41:
        uint64_t v35 = "-";
      }
      uint64_t v36 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v37 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
        uint64_t v38 = *((int *)v25 + 10);
        uint64_t v39 = (char *)&unk_10161656E;
        if (v38 <= 2) {
          uint64_t v39 = off_1019BEB80[v38];
        }
        uint64_t v40 = v25[4];
        *(_DWORD *)long long buf = 136316162;
        uint64_t v45 = v37;
        __int16 v46 = 2080;
        __int16 v47 = " ";
        __int16 v48 = 2048;
        uint64_t v49 = v40;
        __int16 v50 = 2080;
        __int16 v51 = v39;
        __int16 v52 = 2080;
        int v53 = v35;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I %s%s |   %llu : %s : '%s'", buf, 0x34u);
      }
      unint64_t v41 = (void *)v25[1];
      if (v41)
      {
        do
        {
          uint64_t v42 = v41;
          unint64_t v41 = (void *)*v41;
        }
        while (v41);
      }
      else
      {
        do
        {
          uint64_t v42 = (void *)v25[2];
          BOOL v43 = *v42 == (void)v25;
          uint64_t v25 = v42;
        }
        while (!v43);
      }
      uint64_t v25 = v42;
    }
    while (v42 != (void *)(a1 + 152));
  }
}

uint64_t sub_100372B58()
{
  return 0;
}

uint64_t sub_100372B60()
{
  return 0;
}

void sub_100372B68(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100372C34(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100372D0C);
  __cxa_rethrow();
}

void sub_100372C5C(_Unwind_Exception *a1)
{
}

void sub_100372C74(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100372CAC(uint64_t a1)
{
}

uint64_t sub_100372CC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100372D0C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t **sub_100372D38(uint64_t **a1, unint64_t a2, void *a3)
{
  BOOL v6 = a1 + 1;
  char v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        char v5 = *v7;
        BOOL v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      char v5 = v7[1];
      if (!v5)
      {
        BOOL v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    int v7 = a1 + 1;
LABEL_9:
    int v9 = operator new(0x30uLL);
    v9[4] = *a3;
    *((_DWORD *)v9 + 10) = 0;
    sub_100046C38(a1, (uint64_t)v7, v6, v9);
    return (uint64_t **)v9;
  }
  return v7;
}

void sub_100372DF0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019BEAC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100372E10(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019BEAC0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100372E64(uint64_t a1)
{
}

uint64_t *sub_100372E78(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  int v7 = a1 + 1;
  BOOL v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        int v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        BOOL v6 = *v9;
        int v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      BOOL v6 = v9[1];
      if (!v6)
      {
        int v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x40uLL);
    uint64_t v12 = **a4;
    v11[6] = 0;
    v11[7] = 0;
    v11[4] = v12;
    v11[5] = 0;
    sub_100046C38(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void sub_100372F3C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019BEB10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100372F5C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019BEB10;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100372FB0(uint64_t a1)
{
}

void sub_100372FC4(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100373030()
{
}

uint64_t sub_100373054(uint64_t a1, uint64_t a2, int a3)
{
  char v5 = (ctu::OsLogLogger *)(a1 + 8);
  BOOL v6 = "loc.mdl.?";
  if (a3 == 2) {
    BOOL v6 = "loc.mdl.2";
  }
  if (a3 == 1) {
    int v7 = "loc.mdl.1";
  }
  else {
    int v7 = v6;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, kCtLoggingSystemName, v7);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v10, &v9);
  ctu::OsLogLogger::OsLogLogger(v5, (const ctu::OsLogLogger *)v10);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v10);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_1019BEBA8;
  *(_DWORD *)(a1 + 32) = a3;
  *(unsigned char *)(a1 + 36) = 0;
  return a1;
}

void sub_100373138(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  LocationModelInterface::~LocationModelInterface(v2);
  _Unwind_Resume(a1);
}

void sub_10037316C(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 36)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    int v4 = 136315138;
    char v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Already sent not registered hints: %s", (uint8_t *)&v4, 0xCu);
  }
}

uint64_t sub_100373224(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 36);
}

void sub_10037322C(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 36);
  if (v2 != a2)
  {
    char v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = "true";
      if (v2) {
        int v7 = "true";
      }
      else {
        int v7 = "false";
      }
      if (!a2) {
        uint64_t v6 = "false";
      }
      int v8 = 136315394;
      OsLogContext v9 = v7;
      __int16 v10 = 2080;
      uint64_t v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Already sent not registered hints changing from %s to %s", (uint8_t *)&v8, 0x16u);
    }
    *(unsigned char *)(a1 + 36) = a2;
  }
}

void sub_100373310(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  LocationModelInterface::~LocationModelInterface((LocationModelInterface *)a1);
}

void sub_100373358(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  LocationModelInterface::~LocationModelInterface((LocationModelInterface *)a1);

  operator delete();
}

void sub_1003733B4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100373434(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100373470(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1003734A8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1003734D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

CFUserNotificationRef sub_10037351C(unsigned int a1, void *a2, void *a3, void *a4, int a5, int a6, void *a7, void *a8)
{
  SInt32 v20 = 0;
  int valuePtr = a5;
  double v14 = (double)a1;
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  keys[0] = (void *)kCFUserNotificationAlertHeaderKey;
  keys[1] = (void *)kCFUserNotificationAlertMessageKey;
  keys[2] = (void *)kCFUserNotificationDefaultButtonTitleKey;
  keys[3] = (void *)kCFUserNotificationAlternateButtonTitleKey;
  keys[4] = (void *)kCFUserNotificationTextFieldTitlesKey;
  keys[5] = (void *)kCFUserNotificationKeyboardTypesKey;
  values[0] = a2;
  values[1] = a3;
  values[2] = a7;
  values[3] = a8;
  values[4] = a4;
  values[5] = v15;
  CFDictionaryRef v16 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 6, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (a6) {
    CFOptionFlags v17 = 65539;
  }
  else {
    CFOptionFlags v17 = 3;
  }
  CFUserNotificationRef v18 = CFUserNotificationCreate(kCFAllocatorDefault, v14, v17, &v20, v16);
  if (v16) {
    CFRelease(v16);
  }
  if (v15) {
    CFRelease(v15);
  }
  return v18;
}

uint64_t sub_10037369C(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_OWORD *)__int16 v10 = 0u;
  long long v11 = 0u;
  uint64_t v12 = 0;
  memset(v8, 0, sizeof(v8));
  uint64_t v9 = 0;
  if (a2)
  {
    v10[0] = (void *)kCFUserNotificationAlertHeaderKey;
    *(void *)&v8[0] = a2;
    uint64_t v4 = 1;
    if (!a3) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  uint64_t v4 = 0;
  if (a3)
  {
LABEL_3:
    *(void *)((unint64_t)v10 | (8 * v4)) = kCFUserNotificationAlertMessageKey;
    char v5 = (void *)((unint64_t)v8 & 0xFFFFFFFFFFFFFFF7 | (8 * (v4++ & 1)));
    *char v5 = a3;
  }
LABEL_4:
  if (a4)
  {
    v10[v4] = (void *)kCFUserNotificationDefaultButtonTitleKey;
    *((void *)v8 + v4++) = a4;
  }
  v10[v4] = (void *)SBUserNotificationAllowInStarkKey;
  *((void *)v8 + v4) = kCFBooleanTrue;
  uint64_t v6 = 8 * v4 + 8;
  *(void **)((char *)v10 + v6) = (void *)kCFUserNotificationAlertTopMostKey;
  *(void *)((char *)v8 + v6) = kCFBooleanTrue;
  return _CreateSimpleUserNotificationHelper(a1, v4 + 2, (const void **)v10, (const void **)v8);
}

void sub_1003742D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003746DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100374D18(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v13 = va_arg(va1, const void *);

  sub_100044D00((const void **)va);
  sub_100057D78((const void **)va1);

  _Unwind_Resume(a1);
}

void sub_100375040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  char v5 = va_arg(va1, const void *);
  sub_100044D00((const void **)va);
  sub_100057D78((const void **)va1);

  _Unwind_Resume(a1);
}

void sub_100375258(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100375360(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1003754D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1003755EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100375824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_1000577C4(&a9);
  sub_100057D78(&a10);
  _Unwind_Resume(a1);
}

void sub_100375AAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100375BCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100375CDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100375E50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100375F68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100376078(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1003761EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100376304(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_10037649C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100376630(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1003767C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1003769E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100376A88()
{
}

void sub_100376AB0()
{
}

void sub_100376B88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (v12) {
    dispatch_release(v12);
  }
  operator delete();
}

void *sub_100376BD8(void *a1, NSObject **a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, "cp.mux");
  sub_100376CC0(v6, a2, &v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
  *a1 = off_1019BECC0;
  a1[6] = off_1019BEDD8;
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  *(_OWORD *)(a1 + 7) = *(_OWORD *)a3;
  a1[9] = *(void *)(a3 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  a1[10] = 0;
  a1[11] = 0;
  a1[12] = 0;
  return a1;
}

void sub_100376CAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100376CC0(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  char v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_100376D28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100376D4C(uint64_t a1)
{
  *(void *)a1 = off_1019BECC0;
  *(void *)(a1 + 48) = off_1019BEDD8;
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 88);
    uint64_t v4 = *(void **)(a1 + 80);
    if (v3 != v2)
    {
      do
      {
        char v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5) {
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 80);
    }
    *(void *)(a1 + 88) = v2;
    operator delete(v4);
  }
  int v7 = (void **)(a1 + 56);
  sub_10005CBF0(&v7);
  CellularPlanMultiplexerInterface::~CellularPlanMultiplexerInterface((CellularPlanMultiplexerInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100376E28(uint64_t a1)
{
  return sub_100376D4C(a1 - 48);
}

void sub_100376E30(uint64_t a1)
{
  sub_100376D4C(a1);

  operator delete();
}

void sub_100376E68(uint64_t a1)
{
  sub_100376D4C(a1 - 48);

  operator delete();
}

uint64_t sub_100376EA4(uint64_t result)
{
  uint64_t v1 = *(uint64_t **)(result + 56);
  uint64_t v2 = *(uint64_t **)(result + 64);
  if (v1 != v2)
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
      if (!v4 || (uint64_t v5 = *v1, v6 = *(void *)(v3 + 8), (v7 = std::__shared_weak_count::lock(v4)) == 0)) {
        sub_100088B9C();
      }
      OsLogContext v8 = v7;
      uint64_t v9 = v6 + 48;
      if (!v6) {
        uint64_t v9 = 0;
      }
      uint64_t v11 = v9;
      uint64_t v12 = v7;
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v5 + 56))(v5, &v11);
      if (v12) {
        std::__shared_weak_count::__release_weak(v12);
      }
      sub_10004D2C8(v8);
      uint64_t v10 = *v1;
      v1 += 2;
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 40))(v10);
    }
    while (v1 != v2);
  }
  return result;
}

void sub_100376F9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_100376FBC(uint64_t result)
{
  uint64_t v1 = *(uint64_t **)(result + 56);
  uint64_t v2 = *(uint64_t **)(result + 64);
  while (v1 != v2)
  {
    uint64_t v3 = *v1;
    v1 += 2;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 48))(v3);
  }
  return result;
}

void sub_100377010(void *a1)
{
  uint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = (uint64_t)(a1[8] - a1[7]) >> 4;
    int v9 = 134217984;
    uint64_t v10 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Number of handlers: %lu", (uint8_t *)&v9, 0xCu);
  }
  uint64_t v4 = (uint64_t *)a1[7];
  for (CFIndex i = (uint64_t *)a1[8]; v4 != i; v4 += 2)
  {
    uint64_t v6 = *v4;
    int v7 = (std::__shared_weak_count *)v4[1];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6)
    {
      (*(void (**)(uint64_t))(*(void *)v6 + 216))(v6);
    }
    else
    {
      OsLogContext v8 = a1[5];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v9) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Null handler", (uint8_t *)&v9, 2u);
      }
    }
    if (v7) {
      sub_10004D2C8(v7);
    }
  }
}

void sub_100377178(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100377190(void *a1, uint64_t *a2)
{
  uint64_t v4 = (char *)a1[10];
  uint64_t v5 = (char *)a1[11];
  uint64_t v7 = *a2;
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v4 != v5)
  {
    do
    {
      OsLogContext v8 = (std::__shared_weak_count *)*((void *)v4 + 1);
      if (v8 && (int v9 = std::__shared_weak_count::lock(v8)) != 0)
      {
        uint64_t v10 = *(void *)v4;
        sub_10004D2C8(v9);
        if (v7 == v10) {
          goto LABEL_11;
        }
      }
      else if (!v7)
      {
        goto LABEL_11;
      }
      v4 += 16;
    }
    while (v4 != v5);
    uint64_t v4 = v5;
  }
LABEL_11:
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (v4 == (char *)a1[11])
  {
    long long v11 = *(_OWORD *)a2;
    unint64_t v12 = a1[12];
    if ((unint64_t)v4 >= v12)
    {
      double v14 = (char *)a1[10];
      uint64_t v15 = (v4 - v14) >> 4;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 60) {
        sub_10006A748();
      }
      long long v25 = v11;
      uint64_t v17 = v12 - (void)v14;
      if (v17 >> 3 > v16) {
        unint64_t v16 = v17 >> 3;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18 >> 60) {
        sub_10006A7CC();
      }
      uint64_t v19 = (char *)operator new(16 * v18);
      SInt32 v20 = &v19[16 * v15];
      *(_OWORD *)SInt32 v20 = v25;
      if (*((void *)&v25 + 1))
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v25 + 1) + 16), 1uLL, memory_order_relaxed);
        double v14 = (char *)a1[10];
        uint64_t v4 = (char *)a1[11];
      }
      uint64_t v21 = &v19[16 * v18];
      uint64_t v13 = v20 + 16;
      if (v4 == v14)
      {
        a1[10] = v20;
        a1[11] = v13;
        a1[12] = v21;
      }
      else
      {
        do
        {
          long long v22 = *((_OWORD *)v4 - 1);
          v4 -= 16;
          *((_OWORD *)v20 - 1) = v22;
          v20 -= 16;
          *(void *)uint64_t v4 = 0;
          *((void *)v4 + 1) = 0;
        }
        while (v4 != v14);
        double v14 = (char *)a1[10];
        uint64_t v23 = (char *)a1[11];
        a1[10] = v20;
        a1[11] = v13;
        a1[12] = v21;
        while (v23 != v14)
        {
          uint64_t v24 = (std::__shared_weak_count *)*((void *)v23 - 1);
          if (v24) {
            std::__shared_weak_count::__release_weak(v24);
          }
          v23 -= 16;
        }
      }
      if (v14) {
        operator delete(v14);
      }
    }
    else
    {
      *(_OWORD *)uint64_t v4 = v11;
      if (*((void *)&v11 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v11 + 1) + 16), 1uLL, memory_order_relaxed);
      }
      uint64_t v13 = v4 + 16;
    }
    a1[11] = v13;
  }
}

void sub_100377350(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t *)a2[7];
  uint64_t v6 = (uint64_t *)a2[8];
  if (v5 == v6)
  {
LABEL_8:
    uint64_t v10 = a2[5];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Could not locate CSN", v11, 2u);
    }
    *a1 = 0;
    a1[1] = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v8 = *v5;
      int v9 = (std::__shared_weak_count *)v5[1];
      *a1 = *v5;
      a1[1] = (uint64_t)v9;
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 16))(v8, a3)) {
        break;
      }
      if (v9) {
        sub_10004D2C8(v9);
      }
      v5 += 2;
      if (v5 == v6) {
        goto LABEL_8;
      }
    }
  }
}

void sub_100377440(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100377458(void *a1, void *a2, uint64_t *a3)
{
  uint64_t v6 = (void *)a2[7];
  uint64_t v7 = (void *)a2[8];
  while (v6 != v7)
  {
    if ((*(unsigned int (**)(void, uint64_t *))(*(void *)*v6 + 24))(*v6, a3))
    {
      uint64_t v10 = v6[1];
      *a1 = *v6;
      a1[1] = v10;
      if (v10) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
      }
      return;
    }
    v6 += 2;
  }
  uint64_t v8 = a2[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) >= 0) {
      int v9 = a3;
    }
    else {
      int v9 = (uint64_t *)*a3;
    }
    int v11 = 136315138;
    unint64_t v12 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E Could not find device by iccid : %s", (uint8_t *)&v11, 0xCu);
  }
  *a1 = 0;
  a1[1] = 0;
}

void sub_100377580(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void (**a5)(void, void))
{
  uint64_t v16 = a2;
  uint64_t v17 = a3;
  uint64_t v13 = 0;
  double v14 = 0;
  sub_100377350(&v13, a1, (uint64_t)&v16);
  uint64_t v7 = v13;
  if (v13)
  {
    uint64_t v8 = v16;
    uint64_t v9 = v17;
    if (a5) {
      uint64_t v10 = _Block_copy(a5);
    }
    else {
      uint64_t v10 = 0;
    }
    v15[0] = off_1019BEF50;
    v15[1] = v10;
    uint64_t v12 = 0;
    v15[3] = v15;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v7 + 160))(v7, v8, v9, a4, v15);
    sub_1000C752C(v15);
  }
  else
  {
    __int16 v11 = 3074;
    ((void (**)(void, __int16 *))a5)[2](a5, &v11);
    LOBYTE(v11) = 0;
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
}

void sub_1003776BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, char a17)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100377708(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10037773C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void (**a5)(void, void))
{
  uint64_t v16 = a2;
  uint64_t v17 = a3;
  uint64_t v13 = 0;
  double v14 = 0;
  sub_100377350(&v13, a1, (uint64_t)&v16);
  uint64_t v7 = v13;
  if (v13)
  {
    uint64_t v8 = v16;
    uint64_t v9 = v17;
    if (a5) {
      uint64_t v10 = _Block_copy(a5);
    }
    else {
      uint64_t v10 = 0;
    }
    v15[0] = off_1019BEFD0;
    v15[1] = v10;
    uint64_t v12 = 0;
    v15[3] = v15;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v7 + 168))(v7, v8, v9, a4, v15);
    sub_1000C752C(v15);
  }
  else
  {
    __int16 v11 = 3074;
    ((void (**)(void, __int16 *))a5)[2](a5, &v11);
    LOBYTE(v11) = 0;
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
}

void sub_100377878(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, char a17)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1003778C4(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_1003778F8(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4, const void *a5, void (**a6)(void, void, void))
{
  uint64_t v25 = a2;
  uint64_t v26 = a3;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  sub_100377350(&v20, a1, (uint64_t)&v25);
  uint64_t v9 = v20;
  if (v20)
  {
    uint64_t v10 = v25;
    uint64_t v11 = v26;
    uint64_t v12 = (std::__shared_weak_count *)a4[1];
    uint64_t v18 = *a4;
    uint64_t v19 = v12;
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (a5) {
      uint64_t v13 = _Block_copy(a5);
    }
    else {
      uint64_t v13 = 0;
    }
    v24[0] = off_1019BF050;
    v24[1] = v13;
    uint64_t v17 = 0;
    v24[3] = v24;
    if (a6) {
      double v14 = _Block_copy(a6);
    }
    else {
      double v14 = 0;
    }
    v23[0] = off_1019BF0E0;
    v23[1] = v14;
    uint64_t v16 = 0;
    v23[3] = v23;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *, void *, void *))(*(void *)v9 + 88))(v9, v10, v11, &v18, v24, v23);
    sub_1000C7B20(v23);
    sub_1000C7744(v24);
    if (v19) {
      sub_10004D2C8(v19);
    }
  }
  else
  {
    __int16 v15 = 3074;
    v22[0] = 0;
    ((void (**)(void, __int16 *, unsigned char *))a6)[2](a6, &v15, v22);
    sub_1000C60A0(v22);
    LOBYTE(v15) = 0;
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
}

void sub_100377AC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, std::__shared_weak_count *a8, ...)
{
  va_start(va, a8);
  sub_1000C60A0(va);
  if (a8) {
    sub_10004D2C8(a8);
  }
  _Unwind_Resume(a1);
}

const void **sub_100377B34(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

const void **sub_100377B68(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100377B9C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void (**a5)(void, void))
{
  uint64_t v16 = a2;
  uint64_t v17 = a3;
  uint64_t v13 = 0;
  double v14 = 0;
  sub_100377350(&v13, a1, (uint64_t)&v16);
  uint64_t v7 = v13;
  if (v13)
  {
    uint64_t v8 = v16;
    uint64_t v9 = v17;
    if (a5) {
      uint64_t v10 = _Block_copy(a5);
    }
    else {
      uint64_t v10 = 0;
    }
    v15[0] = off_1019BF170;
    v15[1] = v10;
    uint64_t v12 = 0;
    v15[3] = v15;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v7 + 96))(v7, v8, v9, a4, v15);
    sub_1000C752C(v15);
  }
  else
  {
    __int16 v11 = 3074;
    ((void (**)(void, __int16 *))a5)[2](a5, &v11);
    LOBYTE(v11) = 0;
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
}

void sub_100377CD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, char a17)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100377D24(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100377D58(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void (**a5)(void, void))
{
  uint64_t v21 = a2;
  uint64_t v22 = a3;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  sub_100377350(&v18, a1, (uint64_t)&v21);
  uint64_t v7 = v18;
  if (v18)
  {
    uint64_t v8 = v21;
    uint64_t v9 = v22;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    __int16 v15 = 0;
    sub_10005C928(&v15, *(const void **)a4, *(void *)(a4 + 8), *(void *)(a4 + 8) - *(void *)a4);
    if (a5) {
      uint64_t v10 = _Block_copy(a5);
    }
    else {
      uint64_t v10 = 0;
    }
    v20[0] = off_1019BF1F0;
    v20[1] = v10;
    uint64_t v14 = 0;
    v20[3] = v20;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void **, void *))(*(void *)v7 + 64))(v7, v8, v9, &v15, v20);
    sub_1000C6860(v20);
    if (v15)
    {
      uint64_t v16 = v15;
      operator delete(v15);
    }
  }
  else
  {
    v11[0] = 2;
    LOBYTE(__p) = 12;
    ((void (**)(void, char *))a5)[2](a5, v11);
    if (v11[0] == 1 && __p)
    {
      uint64_t v13 = __p;
      operator delete(__p);
    }
    v11[0] = 0;
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
}

void sub_100377EE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, uint64_t a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, char a20)
{
  if (a10 == 1 && __p) {
    operator delete(__p);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100377F60(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100377F94(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = a2;
  uint64_t v15 = a3;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  sub_100377350(&v11, a1, (uint64_t)&v14);
  uint64_t v7 = v11;
  if (v11)
  {
    uint64_t v8 = v14;
    uint64_t v9 = v15;
    sub_1000C6BDC(v10, a4);
    sub_1000C6AC0((uint64_t)v13, a5);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *, void *))(*(void *)v7 + 72))(v7, v8, v9, v10, v13);
    sub_1000C6B58(v13);
    sub_10005CD2C((uint64_t)v10, (char *)v10[1]);
  }
  else
  {
    sub_1000C26BC(a5, 268);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
}

void sub_1003780A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, char a14)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003780EC(void *a1, uint64_t a2, uint64_t a3, long long *a4, void (**a5)(void, void))
{
  uint64_t v20 = a2;
  uint64_t v21 = a3;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  sub_100377350(&v13, a1, (uint64_t)&v20);
  uint64_t v7 = v13;
  if (v13)
  {
    uint64_t v8 = v20;
    uint64_t v9 = v21;
    long long v16 = *a4;
    if (*((char *)a4 + 39) < 0)
    {
      sub_10004FC84(&__p, *((void **)a4 + 2), *((void *)a4 + 3));
    }
    else
    {
      long long __p = a4[1];
      uint64_t v18 = *((void *)a4 + 4);
    }
    char v19 = *((unsigned char *)a4 + 40);
    if (a5) {
      uint64_t v10 = _Block_copy(a5);
    }
    else {
      uint64_t v10 = 0;
    }
    v15[0] = off_1019BF280;
    v15[1] = v10;
    uint64_t v12 = 0;
    v15[3] = v15;
    (*(void (**)(uint64_t, uint64_t, uint64_t, long long *, void *))(*(void *)v7 + 80))(v7, v8, v9, &v16, v15);
    sub_1000C752C(v15);
    if (SHIBYTE(v18) < 0) {
      operator delete((void *)__p);
    }
  }
  else
  {
    __int16 v11 = 3074;
    ((void (**)(void, __int16 *))a5)[2](a5, &v11);
    LOBYTE(v11) = 0;
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
}

void sub_100378278(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, __int16 a10, char a11, char a12, char a13, uint64_t a14, std::__shared_weak_count *a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1003782DC(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100378310(void *a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, void (**a6)(void, void))
{
  uint64_t v28 = a2;
  uint64_t v29 = a3;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  sub_100377350(&v24, a1, (uint64_t)&v28);
  uint64_t v9 = v24;
  if (v24)
  {
    uint64_t v10 = v28;
    uint64_t v11 = v29;
    sub_10037AA60((char *)__dst, a4);
    char v12 = *(unsigned char *)a5;
    if (*(unsigned char *)a5)
    {
      memset(v16, 0, sizeof(v16));
      sub_10037C544(v16, *(void *)(a5 + 8), *(void *)(a5 + 16), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a5 + 16) - *(void *)(a5 + 8)) >> 3));
      char v12 = 1;
    }
    else
    {
      LOBYTE(v16[0]) = 0;
    }
    char v17 = v12;
    if (a6) {
      uint64_t v13 = _Block_copy(a6);
    }
    else {
      uint64_t v13 = 0;
    }
    v27[0] = off_1019BF300;
    v27[1] = v13;
    uint64_t v15 = 0;
    v27[3] = v27;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void **, void *, void *))(*(void *)v9 + 104))(v9, v10, v11, __dst, v16, v27);
    sub_1000C752C(v27);
    if (v17)
    {
      uint64_t v26 = (void **)v16;
      sub_10037AB58(&v26);
    }
    if (v23 < 0) {
      operator delete(__p);
    }
    if (v21 < 0) {
      operator delete(v20);
    }
    if (v19 < 0) {
      operator delete(__dst[0]);
    }
  }
  else
  {
    __int16 v14 = 3074;
    ((void (**)(void, __int16 *))a6)[2](a6, &v14);
    LOBYTE(v14) = 0;
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
}

void sub_1003784FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21,int a22,__int16 a23,char a24,char a25)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100378578(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

uint64_t sub_1003785AC(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100378600(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void (**a6)(void, void))
{
  uint64_t v22 = a2;
  uint64_t v23 = a3;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  sub_100377350(&v19, a1, (uint64_t)&v22);
  uint64_t v9 = v19;
  if (v19)
  {
    uint64_t v10 = v22;
    uint64_t v11 = v23;
    if (*(char *)(a4 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a4, *(void *)(a4 + 8));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a4;
      uint64_t v18 = *(void *)(a4 + 16);
    }
    if (*(char *)(a5 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)a5;
      uint64_t v16 = *(void *)(a5 + 16);
    }
    if (a6) {
      char v12 = _Block_copy(a6);
    }
    else {
      char v12 = 0;
    }
    v21[0] = off_1019BF380;
    v21[1] = v12;
    uint64_t v14 = 0;
    void v21[3] = v21;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void **, void **, void *))(*(void *)v9 + 112))(v9, v10, v11, __dst, __p, v21);
    sub_1000C752C(v21);
    if (SHIBYTE(v16) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v18) < 0) {
      operator delete(__dst[0]);
    }
  }
  else
  {
    __int16 v13 = 3074;
    ((void (**)(void, __int16 *))a6)[2](a6, &v13);
    LOBYTE(v13) = 0;
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
}

void sub_1003787B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, __int16 a10, char a11, char a12, char a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,std::__shared_weak_count *a28,char a29)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a28) {
    sub_10004D2C8(a28);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100378830(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100378864(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  sub_100377458(&v22, a1, (uint64_t *)a4);
  uint64_t v16 = v22;
  if (v22)
  {
    if (*(char *)(a4 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)a4;
      uint64_t v21 = *(void *)(a4 + 16);
    }
    sub_1000C7494((uint64_t)v24, a9);
    uint64_t v26 = 0;
    uint64_t v18 = operator new(0x28uLL);
    *uint64_t v18 = off_1019BF400;
    sub_1000C7494((uint64_t)(v18 + 1), (uint64_t)v24);
    uint64_t v26 = v18;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v16 + 120))(v16, a2, a3, __p, a5, a6, a7, a8, v25);
    sub_1000C752C(v25);
    sub_1000C752C(v24);
    if (SHIBYTE(v21) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v17 = *(void *)(a9 + 24);
    if (v17)
    {
      __int16 v19 = 5122;
      (*(void (**)(uint64_t, __int16 *))(*(void *)v17 + 48))(v17, &v19);
      LOBYTE(v19) = 0;
    }
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
}

void sub_100378A34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, std::__shared_weak_count *a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  if (a20) {
    sub_10004D2C8(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_100378AA8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  sub_100377458(&v19, a1, (uint64_t *)a4);
  uint64_t v13 = v19;
  if (v19)
  {
    if (*(char *)(a4 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)a4;
      uint64_t v18 = *(void *)(a4 + 16);
    }
    sub_1000C7494((uint64_t)v21, a7);
    uint64_t v23 = 0;
    uint64_t v15 = operator new(0x28uLL);
    void *v15 = off_1019BF480;
    sub_1000C7494((uint64_t)(v15 + 1), (uint64_t)v21);
    uint64_t v23 = v15;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void **, uint64_t, uint64_t, void *))(*(void *)v13 + 128))(v13, a2, a3, __p, a5, a6, v22);
    sub_1000C752C(v22);
    sub_1000C752C(v21);
    if (SHIBYTE(v18) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v14 = *(void *)(a7 + 24);
    if (v14)
    {
      __int16 v16 = 5122;
      (*(void (**)(uint64_t, __int16 *))(*(void *)v14 + 48))(v14, &v16);
      LOBYTE(v16) = 0;
    }
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
}

void sub_100378C5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, std::__shared_weak_count *a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  if (a20) {
    sub_10004D2C8(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_100378CD0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  sub_100377458(&v28, a1, (uint64_t *)a3);
  uint64_t v15 = v28;
  if (v28)
  {
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a2;
      uint64_t v27 = *(void *)(a2 + 16);
    }
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v24, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)uint64_t v24 = *(_OWORD *)a3;
      uint64_t v25 = *(void *)(a3 + 16);
    }
    if (*(char *)(a6 + 23) < 0)
    {
      sub_10004FC84(v22, *(void **)a6, *(void *)(a6 + 8));
    }
    else
    {
      *(_OWORD *)uint64_t v22 = *(_OWORD *)a6;
      uint64_t v23 = *(void *)(a6 + 16);
    }
    long long __p = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    sub_10005C928(&__p, *(const void **)a7, *(void *)(a7 + 8), *(void *)(a7 + 8) - *(void *)a7);
    sub_1000C7494((uint64_t)v30, a8);
    unint64_t v32 = 0;
    uint64_t v17 = operator new(0x28uLL);
    void *v17 = off_1019BF500;
    sub_10037D228((uint64_t)(v17 + 1), (uint64_t)v30);
    unint64_t v32 = v17;
    (*(void (**)(uint64_t, void **, void **, uint64_t, uint64_t, void **, void **, void *))(*(void *)v15 + 136))(v15, __dst, v24, a4, a5, v22, &__p, v31);
    sub_1000C752C(v31);
    sub_1000C752C(v30);
    if (__p)
    {
      uint64_t v20 = __p;
      operator delete(__p);
    }
    if (SHIBYTE(v23) < 0) {
      operator delete(v22[0]);
    }
    if (SHIBYTE(v25) < 0) {
      operator delete(v24[0]);
    }
    if (SHIBYTE(v27) < 0) {
      operator delete(__dst[0]);
    }
  }
  else
  {
    uint64_t v16 = *(void *)(a8 + 24);
    if (v16)
    {
      __int16 v18 = 5122;
      (*(void (**)(uint64_t, __int16 *))(*(void *)v16 + 48))(v16, &v18);
      LOBYTE(v18) = 0;
    }
  }
  if (v29) {
    sub_10004D2C8(v29);
  }
}

void sub_100378F2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, __int16 a10, char a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,std::__shared_weak_count *a36,char a37)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  if (a36) {
    sub_10004D2C8(a36);
  }
  _Unwind_Resume(exception_object);
}

void sub_100378FD8(void *a1, uint64_t a2, uint64_t a3, void (**a4)(void, void))
{
  uint64_t v14 = a2;
  uint64_t v15 = a3;
  uint64_t v11 = 0;
  char v12 = 0;
  sub_100377350(&v11, a1, (uint64_t)&v14);
  uint64_t v5 = v11;
  if (v11)
  {
    uint64_t v6 = v14;
    uint64_t v7 = v15;
    if (a4) {
      uint64_t v8 = _Block_copy(a4);
    }
    else {
      uint64_t v8 = 0;
    }
    v13[0] = off_1019BF580;
    v13[1] = v8;
    v10[1] = 0;
    v13[3] = v13;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v5 + 144))(v5, v6, v7, v13);
    sub_1000C7F10(v13);
  }
  else
  {
    v9[0] = 2;
    LOBYTE(v10[0]) = 12;
    ((void (**)(void, char *))a4)[2](a4, v9);
    if (v9[0] == 1) {
      sub_100057D78(v10);
    }
    v9[0] = 0;
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
}

void sub_100379128(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, char a11, uint64_t a12, std::__shared_weak_count *a13, char a14)
{
  if (a9 == 1) {
    sub_100057D78(v14);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100379188(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_1003791BC(void *a1, uint64_t a2, uint64_t a3, void (**a4)(void, void))
{
  uint64_t v14 = a2;
  uint64_t v15 = a3;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_100377350(&v9, a1, (uint64_t)&v14);
  uint64_t v5 = v9;
  if (v9)
  {
    uint64_t v6 = v14;
    uint64_t v7 = v15;
    if (a4) {
      uint64_t v8 = _Block_copy(a4);
    }
    else {
      uint64_t v8 = 0;
    }
    v13[0] = off_1019BF610;
    v13[1] = v8;
    v13[3] = v13;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v5 + 152))(v5, v6, v7, v13);
    sub_1000C6254(v13);
  }
  else
  {
    v11[0] = 2;
    v12[0] = 12;
    ((void (**)(void, char *))a4)[2](a4, v11);
    if (v11[0] == 1) {
      sub_1000C60A0(v12);
    }
    v11[0] = 0;
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_10037930C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::__shared_weak_count *a12, char a13)
{
  if (a13 == 1) {
    sub_1000C60A0(v13);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10037936C(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_1003793A0(void *a1, uint64_t *a2)
{
  long long v36 = 0uLL;
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 != v3)
  {
    do
    {
      char v5 = *(unsigned char *)(v2 + 31);
      if (v5 < 0) {
        uint64_t v6 = *(void *)(v2 + 16);
      }
      else {
        uint64_t v6 = *(unsigned __int8 *)(v2 + 31);
      }
      uint64_t v7 = (void *)(v2 + 8);
      if (v6 == 32)
      {
        uint64_t v17 = 0;
        __int16 v18 = 0;
        uint64_t v19 = 0;
        ctu::parse_hex();
        long long v36 = *(_OWORD *)v17;
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        sub_100377350(&v15, a1, (uint64_t)&v36);
        uint64_t v8 = v15;
        if (v15)
        {
          long long v9 = v36;
          sub_10023FB90((uint64_t)buf, v2);
          char v12 = 0;
          uint64_t v13 = 0;
          uint64_t v14 = 0;
          v20[0] = (void **)&v12;
          v20[1] = 0;
          char v12 = (char *)operator new(0xC0uLL);
          uint64_t v13 = (uint64_t)v12;
          uint64_t v14 = v12 + 192;
          uint64_t v13 = sub_10037AC44((uint64_t)&v14, (uint64_t)buf, (uint64_t)&v36, (uint64_t)v12);
          (*(void (**)(uint64_t, void, void, char **, uint64_t))(*(void *)v8 + 176))(v8, v9, *((void *)&v9 + 1), &v12, 1);
          v20[0] = (void **)&v12;
          sub_10023FDC8(v20);
          if (v35 < 0) {
            operator delete(__p);
          }
          if (v33 < 0) {
            operator delete(v32);
          }
          if (v31 < 0) {
            operator delete(v30);
          }
          if (v29 < 0) {
            operator delete(v28);
          }
          if (v27 < 0) {
            operator delete(v26);
          }
          if (v25 < 0) {
            operator delete(v24);
          }
          if (v23 < 0) {
            operator delete(*(void **)&v22[4]);
          }
        }
        else
        {
          uint64_t v11 = a1[5];
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            if (*(char *)(v2 + 31) < 0) {
              uint64_t v7 = (void *)*v7;
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)uint64_t v22 = v7;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I EID (%s) not found", buf, 0xCu);
          }
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
        if (v17)
        {
          __int16 v18 = v17;
          operator delete(v17);
        }
      }
      else
      {
        uint64_t v10 = a1[5];
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          if (v5 < 0) {
            uint64_t v7 = (void *)*v7;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)uint64_t v22 = v7;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I DeviceId (%s) is not an EID", buf, 0xCu);
        }
      }
      v2 += 192;
    }
    while (v2 != v3);
  }
}

void sub_100379670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *__p, uint64_t a17, uint64_t a18, char *a19, uint64_t a20,char a21)
{
  a19 = &a11;
  sub_10023FDC8((void ***)&a19);
  sub_1000C62D8((uint64_t)&a21);
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (__p)
  {
    a17 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1003796DC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  sub_100377350(&v25, a1, a2);
  uint64_t v7 = v25;
  if (v25)
  {
    sub_10037DC40((uint64_t)v27, a4);
    char v29 = 0;
    uint64_t v8 = operator new(0x28uLL);
    void *v8 = off_1019BF6A0;
    sub_10037E368((uint64_t)(v8 + 1), (uint64_t)v27);
    char v29 = v8;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v7 + 184))(v7, a2, a3, v28);
    sub_10037DCD8(v28);
    sub_10037DCD8(v27);
  }
  else
  {
    v10[0] = 2;
    unsigned char v10[8] = 12;
    uint64_t v9 = *(void *)(a4 + 24);
    if (!v9) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v9 + 48))(v9, v10);
    if (v10[0] == 1)
    {
      if (v24 < 0) {
        operator delete(__p);
      }
      if (v22 < 0) {
        operator delete(v21);
      }
      if (v20 < 0) {
        operator delete(v19);
      }
      if (v18 < 0) {
        operator delete(v17);
      }
      if (v16 < 0) {
        operator delete(v15);
      }
      if (v14 < 0) {
        operator delete(v13);
      }
      if (v12 < 0) {
        operator delete(v11);
      }
    }
    v10[0] = 0;
  }
  if (v26) {
    sub_10004D2C8(v26);
  }
}

void sub_1003798CC(_Unwind_Exception *a1)
{
  sub_10037DCD8((void *)(v1 - 88));
  sub_10037DCD8((void *)(v1 - 120));
  uint64_t v3 = *(std::__shared_weak_count **)(v1 - 128);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(a1);
}

void sub_10037992C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = a2;
  uint64_t v15 = a3;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_100377350(&v10, a1, (uint64_t)&v14);
  uint64_t v5 = v10;
  uint64_t v6 = v14;
  uint64_t v7 = v15;
  if (v10)
  {
    sub_10037E838((uint64_t)v13, a4);
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v5 + 208))(v5, v6, v7, v13);
    sub_10037E8D0(v13);
  }
  else
  {
    v8[0] = 2;
    char v9 = 12;
    sub_1000C5120(a4, v14, v15, (uint64_t)v8);
    if (v8[0] == 1)
    {
      char v12 = (void **)&v9;
      sub_1000C63B8(&v12);
    }
    v8[0] = 0;
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_100379A5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, char a16)
{
  if (a9 == 1) {
    sub_1000C63B8((void ***)&a15);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100379AB0(void *a1, uint64_t *a2, uint64_t a3)
{
  if (*(void *)(a3 + 24))
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    sub_100377458(&v9, a1, a2);
    uint64_t v5 = v9;
    if (v9)
    {
      sub_10037E954((uint64_t)v11, a3);
      (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v5 + 192))(v5, a2, v11);
      sub_10032B10C(v11);
    }
    else
    {
      v7[0] = 0;
      char v8 = 0;
      sub_1000C4EAC(a3, (uint64_t)v7, 6);
      sub_1000C636C((uint64_t)v7);
    }
    if (v10) {
      sub_10004D2C8(v10);
    }
  }
  else
  {
    uint64_t v6 = a1[5];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "invalid callback", v7, 2u);
    }
  }
}

void sub_100379BE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(a1);
}

void sub_100379C28(void *a1, uint64_t *a2, uint64_t a3)
{
  if (*(void *)(a3 + 24))
  {
    sub_100058DB0(v27, "CellularPlanRegisteredCommandHandler");
    uint64_t v6 = (void *)a1[7];
    for (CFIndex i = (void *)a1[8]; v6 != i; v6 += 2)
    {
      char v8 = (char *)(*(uint64_t (**)(void))(*(void *)*v6 + 32))();
      sub_100058DB0(__p, v8);
      if (v31 >= 0) {
        uint64_t v9 = (void *)HIBYTE(v31);
      }
      else {
        uint64_t v9 = __p[1];
      }
      unint64_t v10 = v28;
      if ((v28 & 0x80u) != 0) {
        unint64_t v10 = (unint64_t)v27[1];
      }
      if (v9 == (void *)v10)
      {
        if ((v28 & 0x80u) == 0) {
          uint64_t v11 = v27;
        }
        else {
          uint64_t v11 = (void **)v27[0];
        }
        if (v31 < 0)
        {
          char v16 = __p[0];
          int v17 = memcmp(__p[0], v11, (size_t)__p[1]);
          operator delete(v16);
          if (!v17) {
            goto LABEL_47;
          }
        }
        else
        {
          if (!HIBYTE(v31)) {
            goto LABEL_47;
          }
          uint64_t v12 = 0;
          do
          {
            int v13 = *((unsigned __int8 *)__p + v12);
            int v14 = *((unsigned __int8 *)v11 + v12);
          }
          while (v13 == v14 && HIBYTE(v31) - 1 != v12++);
          if (v13 == v14)
          {
LABEL_47:
            uint64_t v20 = *v6;
            uint64_t v21 = (std::__shared_weak_count *)v6[1];
            if (v21) {
              atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            goto LABEL_31;
          }
        }
      }
      else if (v31 < 0)
      {
        operator delete(__p[0]);
      }
    }
    char v18 = a1[5];
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = v27;
      if ((v28 & 0x80u) != 0) {
        uint64_t v19 = (void **)v27[0];
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Could not locate handler: [%s]", (uint8_t *)__p, 0xCu);
    }
    uint64_t v20 = 0;
    uint64_t v21 = 0;
LABEL_31:
    if ((char)v28 < 0)
    {
      operator delete(v27[0]);
      if (v20)
      {
LABEL_33:
        char v22 = (std::__shared_weak_count *)a2[1];
        uint64_t v25 = *a2;
        uint64_t v26 = v22;
        if (v22) {
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_10037E9EC((uint64_t)v29, a3);
        (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v20 + 200))(v20, &v25, v29);
        sub_10034ABC0(v29);
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (!v21) {
          return;
        }
LABEL_45:
        sub_10004D2C8(v21);
        return;
      }
    }
    else if (v20)
    {
      goto LABEL_33;
    }
    char v24 = a1[5];
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "RegisteredCommandHandler missing", (uint8_t *)__p, 2u);
    }
    *(_OWORD *)long long __p = 0uLL;
    uint64_t v31 = 0;
    sub_1000C1BB8(a3, (uint64_t)__p, 1);
    v27[0] = __p;
    sub_1000C5238((void ***)v27);
    if (v21) {
      goto LABEL_45;
    }
  }
  else
  {
    char v23 = a1[5];
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "invalid callback", (uint8_t *)__p, 2u);
    }
  }
}

void sub_100379F64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  sub_1000C5238((void ***)&__p);
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(a1);
}

void sub_100379FC4(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(uint64_t **)(a1 + 80);
  uint64_t v5 = *(uint64_t **)(a1 + 88);
  if (v4 == v5)
  {
LABEL_14:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 72) = 0;
    *(unsigned char *)(a3 + 80) = 0;
    *(unsigned char *)(a3 + 216) = 0;
    return;
  }
  while (1)
  {
    uint64_t v7 = (std::__shared_weak_count *)v4[1];
    if (!v7) {
      goto LABEL_13;
    }
    char v8 = std::__shared_weak_count::lock(v7);
    if (!v8) {
      goto LABEL_13;
    }
    uint64_t v9 = v8;
    uint64_t v10 = *v4;
    if (*v4) {
      break;
    }
LABEL_12:
    sub_10004D2C8(v9);
LABEL_13:
    v4 += 2;
    if (v4 == v5) {
      goto LABEL_14;
    }
  }
  uint64_t v21 = 0;
  long long v20 = 0u;
  long long v18 = 0u;
  memset(v19, 0, sizeof(v19));
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v13 = *(void *)(a2 + 16);
  }
  (*(void (**)(long long *__return_ptr, uint64_t, void **))(*(void *)v10 + 16))(&v14, v10, __p);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  if (!(_BYTE)v21)
  {
    sub_10037ADA0((uint64_t)&v14);
    goto LABEL_12;
  }
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 72) = 0;
  if (BYTE8(v18))
  {
    if (SBYTE7(v15) < 0)
    {
      sub_10004FC84((unsigned char *)a3, (void *)v14, *((unint64_t *)&v14 + 1));
    }
    else
    {
      *(_OWORD *)a3 = v14;
      *(void *)(a3 + 16) = v15;
    }
    *(void *)(a3 + 32) = 0;
    uint64_t v11 = v16;
    *(void *)(a3 + 24) = *((void *)&v15 + 1);
    *(void *)(a3 + 40) = 0;
    *(void *)(a3 + 48) = 0;
    sub_100311ED8((void *)(a3 + 32), v11, *((uint64_t *)&v16 + 1), 0x2E8BA2E8BA2E8BA3 * ((*((void *)&v16 + 1) - v11) >> 3));
    *(void *)(a3 + 56) = *((void *)&v17 + 1);
    *(_DWORD *)(a3 + 64) = v18;
    *(unsigned char *)(a3 + 72) = 1;
  }
  *(unsigned char *)(a3 + 80) = 0;
  *(unsigned char *)(a3 + 216) = 0;
  if (BYTE8(v20))
  {
    sub_100313228((char *)(a3 + 80), v19);
    *(unsigned char *)(a3 + 216) = 1;
  }
  sub_10037ADA0((uint64_t)&v14);
  sub_10004D2C8(v9);
}

void sub_10037A1E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  sub_10037ACC8(v17);
  sub_10037ADA0((uint64_t)&a16);
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void sub_10037A250(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void sub_10037A258(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 80);
  uint64_t v3 = *(void **)(a1 + 88);
  if (v2 == v3) {
    return;
  }
  while (1)
  {
    uint64_t v5 = (std::__shared_weak_count *)v2[1];
    if (!v5) {
      goto LABEL_7;
    }
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (!v6) {
      goto LABEL_7;
    }
    uint64_t v7 = v6;
    if (*v2)
    {
      if ((*(uint64_t (**)(void, uint64_t))(*(void *)*v2 + 24))(*v2, a2)) {
        break;
      }
    }
    sub_10004D2C8(v7);
LABEL_7:
    v2 += 2;
    if (v2 == v3) {
      return;
    }
  }

  sub_10004D2C8(v7);
}

void sub_10037A30C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10037A320(uint64_t a1, uint64_t a2)
{
}

void sub_10037A328(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 *a7)
{
  uint64_t v7 = *(uint64_t **)(a1 + 80);
  for (CFIndex i = *(uint64_t **)(a1 + 88); v7 != i; v7 += 2)
  {
    long long v15 = (std::__shared_weak_count *)v7[1];
    if (v15)
    {
      long long v16 = std::__shared_weak_count::lock(v15);
      if (v16)
      {
        uint64_t v17 = v16;
        uint64_t v18 = *v7;
        if (*v7)
        {
          __int16 v20 = 0;
          if (*a7 - 1 <= 1) {
            __int16 v20 = *(_WORD *)a7;
          }
          char v19 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __int16 *))(*(void *)v18 + 32))(v18, a2, a3, a4, a5, a6, &v20);
          LOBYTE(v20) = 0;
          if (v19)
          {
            sub_10004D2C8(v17);
            return;
          }
        }
        sub_10004D2C8(v17);
      }
    }
  }
}

void sub_10037A430(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10037A448(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 *a7)
{
}

void sub_10037A450(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 *a7)
{
  uint64_t v7 = *(uint64_t **)(a1 + 80);
  for (CFIndex i = *(uint64_t **)(a1 + 88); v7 != i; v7 += 2)
  {
    long long v15 = (std::__shared_weak_count *)v7[1];
    if (v15)
    {
      long long v16 = std::__shared_weak_count::lock(v15);
      if (v16)
      {
        uint64_t v17 = v16;
        uint64_t v18 = *v7;
        if (*v7)
        {
          __int16 v20 = 0;
          if (*a7 - 1 <= 1) {
            __int16 v20 = *(_WORD *)a7;
          }
          char v19 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __int16 *))(*(void *)v18 + 40))(v18, a2, a3, a4, a5, a6, &v20);
          LOBYTE(v20) = 0;
          if (v19)
          {
            sub_10004D2C8(v17);
            return;
          }
        }
        sub_10004D2C8(v17);
      }
    }
  }
}

void sub_10037A558(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10037A570(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 *a7)
{
}

void sub_10037A578(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 80);
  uint64_t v3 = *(void **)(a1 + 88);
  if (v2 == v3) {
    return;
  }
  while (1)
  {
    uint64_t v5 = (std::__shared_weak_count *)v2[1];
    if (!v5) {
      goto LABEL_7;
    }
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (!v6) {
      goto LABEL_7;
    }
    uint64_t v7 = v6;
    if (*v2)
    {
      if ((*(uint64_t (**)(void, uint64_t))(*(void *)*v2 + 48))(*v2, a2)) {
        break;
      }
    }
    sub_10004D2C8(v7);
LABEL_7:
    v2 += 2;
    if (v2 == v3) {
      return;
    }
  }

  sub_10004D2C8(v7);
}

void sub_10037A62C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10037A640(uint64_t a1, uint64_t a2)
{
}

void sub_10037A648(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 80);
  uint64_t v4 = *(void **)(a1 + 88);
  if (v3 == v4) {
    return;
  }
  while (1)
  {
    uint64_t v7 = (std::__shared_weak_count *)v3[1];
    if (!v7) {
      goto LABEL_7;
    }
    char v8 = std::__shared_weak_count::lock(v7);
    if (!v8) {
      goto LABEL_7;
    }
    uint64_t v9 = v8;
    if (*v3)
    {
      if ((*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*v3 + 56))(*v3, a2, a3)) {
        break;
      }
    }
    sub_10004D2C8(v9);
LABEL_7:
    v3 += 2;
    if (v3 == v4) {
      return;
    }
  }

  sub_10004D2C8(v9);
}

void sub_10037A710(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10037A724(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_10037A72C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void **)(a1 + 80);
  uint64_t v5 = *(void **)(a1 + 88);
  if (v4 == v5) {
    return;
  }
  while (1)
  {
    uint64_t v9 = (std::__shared_weak_count *)v4[1];
    if (!v9) {
      goto LABEL_7;
    }
    uint64_t v10 = std::__shared_weak_count::lock(v9);
    if (!v10) {
      goto LABEL_7;
    }
    uint64_t v11 = v10;
    if (*v4)
    {
      if ((*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)*v4 + 64))(*v4, a2, a3, a4)) {
        break;
      }
    }
    sub_10004D2C8(v11);
LABEL_7:
    v4 += 2;
    if (v4 == v5) {
      return;
    }
  }

  sub_10004D2C8(v11);
}

void sub_10037A7FC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10037A810(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_10037A818(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 80);
  for (CFIndex i = *(void **)(a1 + 88); v3 != i; v3 += 2)
  {
    uint64_t v7 = (std::__shared_weak_count *)v3[1];
    if (v7)
    {
      char v8 = std::__shared_weak_count::lock(v7);
      if (v8)
      {
        uint64_t v9 = v8;
        if (*v3) {
          (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v3 + 72))(*v3, a2, a3);
        }
        sub_10004D2C8(v9);
      }
    }
  }
}

void sub_10037A8B4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10037A8C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void *sub_10037A8D0(void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_1001577CC(result, a4);
    uint64_t result = sub_10037A958((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_10037A938(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_10005CBF0(&a9);
  _Unwind_Resume(a1);
}

void *sub_10037A958(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v9 = a4;
  v7[0] = a1;
  v7[1] = &v8;
  v7[3] = 1;
  char v8 = a4;
  v7[2] = &v9;
  if (a2 != a3)
  {
    do
    {
      *uint64_t v4 = *a2;
      uint64_t v5 = a2[1];
      v4[1] = v5;
      if (v5) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      }
      v4 += 2;
      a2 += 2;
    }
    while (a2 != a3);
    uint64_t v9 = v4;
  }
  sub_10037A9E4((uint64_t)v7);
  return v4;
}

uint64_t sub_10037A9E4(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_10037AA1C(a1);
  }
  return a1;
}

void sub_10037AA1C(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 - 8);
    if (v3) {
      sub_10004D2C8(v3);
    }
    v1 -= 16;
  }
}

char *sub_10037AA60(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  *((_DWORD *)__dst + 6) = *((_DWORD *)a2 + 6);
  if (*((char *)a2 + 55) < 0)
  {
    sub_10004FC84(__dst + 32, *((void **)a2 + 4), *((void *)a2 + 5));
  }
  else
  {
    long long v5 = a2[2];
    *((void *)__dst + 6) = *((void *)a2 + 6);
    *((_OWORD *)__dst + 2) = v5;
  }
  uint64_t v6 = __dst + 56;
  if (*((char *)a2 + 79) < 0)
  {
    sub_10004FC84(v6, *((void **)a2 + 7), *((void *)a2 + 8));
  }
  else
  {
    long long v7 = *(long long *)((char *)a2 + 56);
    *((void *)__dst + 9) = *((void *)a2 + 9);
    *(_OWORD *)uint64_t v6 = v7;
  }
  *((_DWORD *)__dst + 20) = *((_DWORD *)a2 + 20);
  return __dst;
}

void sub_10037AB24(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10037AB58(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    long long v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 88;
        sub_10037ABDC(v4);
      }
      while ((void *)v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_10037ABDC(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

uint64_t sub_10037AC44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_10023FB90(a4 + v7, a2 + v7);
      v7 += 192;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_10037ACA4(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 192;
    do
    {
      sub_1000C62D8(v4 + v2);
      v2 -= 192;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10037ACC8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v3 = (void **)(a1 + 32);
    sub_1000C56F4(&v3);
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

uint64_t sub_10037AD1C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 136))
  {
    if (*(char *)(a1 + 119) < 0) {
      operator delete(*(void **)(a1 + 96));
    }
    if (*(unsigned char *)(a1 + 56))
    {
      if (*(char *)(a1 + 87) < 0) {
        operator delete(*(void **)(a1 + 64));
      }
      *(unsigned char *)(a1 + 56) = 0;
    }
    if (*(unsigned char *)(a1 + 24))
    {
      if (*(char *)(a1 + 55) < 0) {
        operator delete(*(void **)(a1 + 32));
      }
      *(unsigned char *)(a1 + 24) = 0;
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

uint64_t sub_10037ADA0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 224))
  {
    sub_10037AD1C(a1 + 80);
    sub_10037ACC8(a1);
  }
  return a1;
}

void sub_10037ADDC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10037AEA8(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10037AF80);
  __cxa_rethrow();
}

void sub_10037AED0(_Unwind_Exception *a1)
{
}

void sub_10037AEE8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10037AF20(uint64_t a1)
{
}

uint64_t sub_10037AF3C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10037AF80(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *sub_10037AFAC(void *a1)
{
  *a1 = off_1019BEF50;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10037AFFC(void *a1)
{
  *a1 = off_1019BEF50;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10037B06C(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 8);
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019BEF50;
  sub_10037B1D4(v2 + 1, v1);
  return v2;
}

void *sub_10037B0C0(uint64_t a1, void *a2)
{
  *a2 = off_1019BEF50;
  return sub_10037B1D4(a2 + 1, (void **)(a1 + 8));
}

void sub_10037B0EC(uint64_t a1)
{
}

void sub_10037B0F4(const void **a1)
{
  sub_10037B20C(a1[1]);

  operator delete(a1);
}

uint64_t sub_10037B130(uint64_t a1, unsigned __int8 *a2)
{
  if (*a2 - 1 >= 2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    __int16 v5 = 0;
  }
  else
  {
    unsigned __int8 v2 = a2[1];
    uint64_t v3 = *(void *)(a1 + 8);
    LOBYTE(v5) = *a2;
    HIBYTE(v5) = v2;
  }
  return (*(uint64_t (**)(uint64_t, __int16 *))(v3 + 16))(v3, &v5);
}

uint64_t sub_10037B188(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037B1C8()
{
}

void *sub_10037B1D4(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  *a1 = v3;
  return a1;
}

void sub_10037B20C(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_10037B22C(void *a1)
{
  *a1 = off_1019BEFD0;
  unsigned __int8 v2 = (const void *)a1[1];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10037B27C(void *a1)
{
  *a1 = off_1019BEFD0;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10037B2EC(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 8);
  unsigned __int8 v2 = operator new(0x10uLL);
  void *v2 = off_1019BEFD0;
  sub_10037B454(v2 + 1, v1);
  return v2;
}

void *sub_10037B340(uint64_t a1, void *a2)
{
  *a2 = off_1019BEFD0;
  return sub_10037B454(a2 + 1, (void **)(a1 + 8));
}

void sub_10037B36C(uint64_t a1)
{
}

void sub_10037B374(const void **a1)
{
  sub_10037B48C(a1[1]);

  operator delete(a1);
}

uint64_t sub_10037B3B0(uint64_t a1, unsigned __int8 *a2)
{
  if (*a2 - 1 >= 2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    __int16 v5 = 0;
  }
  else
  {
    unsigned __int8 v2 = a2[1];
    uint64_t v3 = *(void *)(a1 + 8);
    LOBYTE(v5) = *a2;
    HIBYTE(v5) = v2;
  }
  return (*(uint64_t (**)(uint64_t, __int16 *))(v3 + 16))(v3, &v5);
}

uint64_t sub_10037B408(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037B448()
{
}

void *sub_10037B454(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  *a1 = v3;
  return a1;
}

void sub_10037B48C(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_10037B4AC(void *a1)
{
  *a1 = off_1019BF050;
  unsigned __int8 v2 = (const void *)a1[1];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10037B4FC(void *a1)
{
  *a1 = off_1019BF050;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10037B56C(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 8);
  unsigned __int8 v2 = operator new(0x10uLL);
  void *v2 = off_1019BF050;
  sub_10037B92C(v2 + 1, v1);
  return v2;
}

void *sub_10037B5C0(uint64_t a1, void *a2)
{
  *a2 = off_1019BF050;
  return sub_10037B92C(a2 + 1, (void **)(a1 + 8));
}

void sub_10037B5EC(uint64_t a1)
{
}

void sub_10037B5F4(const void **a1)
{
  sub_10037B964(a1[1]);

  operator delete(a1);
}

uint64_t sub_10037B630(uint64_t a1, uint64_t a2)
{
  LOBYTE(v14[0]) = 0;
  char v33 = 0;
  if (*(unsigned char *)(a2 + 240))
  {
    long long v3 = *(_OWORD *)(a2 + 16);
    v14[0] = *(_OWORD *)a2;
    v14[1] = v3;
    uint64_t v15 = *(void *)(a2 + 32);
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    long long v16 = *(_OWORD *)(a2 + 40);
    uint64_t v17 = *(void *)(a2 + 56);
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 56) = 0;
    long long v4 = *(_OWORD *)(a2 + 64);
    uint64_t v19 = *(void *)(a2 + 80);
    long long v18 = v4;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = 0;
    *(void *)(a2 + 80) = 0;
    int v20 = *(_DWORD *)(a2 + 88);
    long long v5 = *(_OWORD *)(a2 + 96);
    uint64_t v22 = *(void *)(a2 + 112);
    long long v21 = v5;
    *(void *)(a2 + 96) = 0;
    *(void *)(a2 + 104) = 0;
    long long v6 = *(_OWORD *)(a2 + 120);
    uint64_t v24 = *(void *)(a2 + 136);
    long long v23 = v6;
    *(void *)(a2 + 112) = 0;
    *(void *)(a2 + 120) = 0;
    *(void *)(a2 + 128) = 0;
    *(void *)(a2 + 136) = 0;
    uint64_t v7 = *(void *)(a2 + 160);
    long long v25 = *(_OWORD *)(a2 + 144);
    *(void *)(a2 + 144) = 0;
    *(void *)(a2 + 152) = 0;
    long long v8 = *(_OWORD *)(a2 + 168);
    uint64_t v9 = *(void *)(a2 + 184);
    uint64_t v26 = v7;
    uint64_t v28 = v9;
    long long v27 = v8;
    *(void *)(a2 + 160) = 0;
    *(void *)(a2 + 168) = 0;
    *(void *)(a2 + 176) = 0;
    *(void *)(a2 + 184) = 0;
    uint64_t v10 = *(void *)(a2 + 208);
    long long v29 = *(_OWORD *)(a2 + 192);
    *(void *)(a2 + 192) = 0;
    *(void *)(a2 + 200) = 0;
    long long v31 = *(_OWORD *)(a2 + 216);
    uint64_t v11 = *(void *)(a2 + 232);
    uint64_t v30 = v10;
    uint64_t v32 = v11;
    *(void *)(a2 + 208) = 0;
    *(void *)(a2 + 216) = 0;
    *(void *)(a2 + 224) = 0;
    *(void *)(a2 + 232) = 0;
    char v33 = 1;
    v34[0] = 0;
    sub_1000C5A48((uint64_t)v34, (uint64_t)v14);
    uint64_t v12 = *(void *)(a1 + 8);
    v55[0] = 0;
    if (v34[0])
    {
      uint64_t v58 = v37;
      uint64_t v60 = v39;
      uint64_t v62 = v41;
      int v63 = v42;
      uint64_t v65 = v44;
      uint64_t v67 = v46;
      uint64_t v69 = v48;
      uint64_t v71 = v50;
      uint64_t v73 = v52;
      long long v56 = v35;
      long long v57 = v36;
      long long v36 = 0uLL;
      long long v59 = v38;
      uint64_t v37 = 0;
      long long v38 = 0uLL;
      uint64_t v39 = 0;
      long long v61 = v40;
      long long v40 = 0uLL;
      long long v64 = v43;
      uint64_t v41 = 0;
      long long v43 = 0uLL;
      long long v66 = v45;
      uint64_t v46 = 0;
      uint64_t v44 = 0;
      long long v45 = 0uLL;
      long long v68 = v47;
      long long v47 = 0uLL;
      long long v70 = v49;
      uint64_t v50 = 0;
      uint64_t v48 = 0;
      long long v49 = 0uLL;
      long long v72 = v51;
      long long v51 = 0uLL;
      long long v74 = v53;
      uint64_t v75 = v54;
      uint64_t v54 = 0;
      uint64_t v52 = 0;
      long long v53 = 0uLL;
      v55[0] = 1;
    }
  }
  else
  {
    v34[0] = 0;
    uint64_t v12 = *(void *)(a1 + 8);
    v55[0] = 0;
  }
  (*(void (**)(uint64_t, char *))(v12 + 16))(v12, v55);
  sub_1000C5D34(v55);
  sub_1000C5D34(v34);
  return sub_1000C7A44((uint64_t)v14);
}

void sub_10037B8B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10037B8E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037B920()
{
}

void *sub_10037B92C(void *a1, void **a2)
{
  long long v3 = *a2;
  if (*a2) {
    long long v3 = _Block_copy(v3);
  }
  *a1 = v3;
  return a1;
}

void sub_10037B964(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_10037B984(void *a1)
{
  *a1 = off_1019BF0E0;
  unsigned __int8 v2 = (const void *)a1[1];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10037B9D4(void *a1)
{
  *a1 = off_1019BF0E0;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10037BA44(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 8);
  unsigned __int8 v2 = operator new(0x10uLL);
  void *v2 = off_1019BF0E0;
  sub_10037BCE4(v2 + 1, v1);
  return v2;
}

void *sub_10037BA98(uint64_t a1, void *a2)
{
  *a2 = off_1019BF0E0;
  return sub_10037BCE4(a2 + 1, (void **)(a1 + 8));
}

void sub_10037BAC4(uint64_t a1)
{
}

void sub_10037BACC(const void **a1)
{
  sub_10037BD1C(a1[1]);

  operator delete(a1);
}

uint64_t sub_10037BB08(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  int v4 = *a2;
  if ((v4 - 1) >= 2) {
    unsigned __int8 v5 = 0;
  }
  else {
    unsigned __int8 v5 = a2[1];
  }
  if ((v4 - 1) >= 2) {
    int v6 = 0;
  }
  else {
    int v6 = *a2;
  }
  sub_1000C8A70(v12, a3);
  int v7 = v13;
  if (v13)
  {
    v14[0] = 0;
    sub_1000C5DA8((uint64_t)v15, (uint64_t)v12);
    char v8 = 1;
  }
  else
  {
    char v8 = 0;
  }
  v14[0] = v8;
  uint64_t v9 = *(void *)(a1 + 8);
  __int16 v11 = 0;
  if ((v6 - 1) <= 1)
  {
    LOBYTE(v11) = v6;
    HIBYTE(v11) = v5;
  }
  v21[0] = 0;
  if (v7)
  {
    long long v22 = v15[0];
    long long v23 = v15[1];
    long long v24 = v16;
    uint64_t v25 = v17;
    long long v16 = 0uLL;
    uint64_t v17 = 0;
    LOBYTE(v26) = 0;
    char v28 = 0;
    if (v20)
    {
      long long v26 = v18;
      uint64_t v27 = v19;
      uint64_t v19 = 0;
      long long v18 = 0uLL;
      char v28 = 1;
    }
    v21[0] = 1;
  }
  (*(void (**)(uint64_t, __int16 *, char *))(v9 + 16))(v9, &v11, v21);
  sub_1000C60A0(v21);
  sub_1000C60A0(v14);
  return sub_1000C612C((uint64_t)v12);
}

void sub_10037BC6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C612C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10037BC98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037BCD8()
{
}

void *sub_10037BCE4(void *a1, void **a2)
{
  long long v3 = *a2;
  if (*a2) {
    long long v3 = _Block_copy(v3);
  }
  *a1 = v3;
  return a1;
}

void sub_10037BD1C(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_10037BD3C(void *a1)
{
  *a1 = off_1019BF170;
  unsigned __int8 v2 = (const void *)a1[1];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10037BD8C(void *a1)
{
  *a1 = off_1019BF170;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10037BDFC(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 8);
  unsigned __int8 v2 = operator new(0x10uLL);
  void *v2 = off_1019BF170;
  sub_10037BF64(v2 + 1, v1);
  return v2;
}

void *sub_10037BE50(uint64_t a1, void *a2)
{
  *a2 = off_1019BF170;
  return sub_10037BF64(a2 + 1, (void **)(a1 + 8));
}

void sub_10037BE7C(uint64_t a1)
{
}

void sub_10037BE84(const void **a1)
{
  sub_10037BF9C(a1[1]);

  operator delete(a1);
}

uint64_t sub_10037BEC0(uint64_t a1, unsigned __int8 *a2)
{
  if (*a2 - 1 >= 2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    __int16 v5 = 0;
  }
  else
  {
    unsigned __int8 v2 = a2[1];
    uint64_t v3 = *(void *)(a1 + 8);
    LOBYTE(v5) = *a2;
    HIBYTE(v5) = v2;
  }
  return (*(uint64_t (**)(uint64_t, __int16 *))(v3 + 16))(v3, &v5);
}

uint64_t sub_10037BF18(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037BF58()
{
}

void *sub_10037BF64(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  *a1 = v3;
  return a1;
}

void sub_10037BF9C(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_10037BFBC(void *a1)
{
  *a1 = off_1019BF1F0;
  unsigned __int8 v2 = (const void *)a1[1];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10037C00C(void *a1)
{
  *a1 = off_1019BF1F0;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10037C07C(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 8);
  unsigned __int8 v2 = operator new(0x10uLL);
  void *v2 = off_1019BF1F0;
  sub_10037C26C(v2 + 1, v1);
  return v2;
}

void *sub_10037C0D0(uint64_t a1, void *a2)
{
  *a2 = off_1019BF1F0;
  return sub_10037C26C(a2 + 1, (void **)(a1 + 8));
}

void sub_10037C0FC(uint64_t a1)
{
}

void sub_10037C104(const void **a1)
{
  sub_10037C2A4(a1[1]);

  operator delete(a1);
}

void sub_10037C140(uint64_t a1, unsigned __int8 *a2)
{
  *(_OWORD *)int v4 = 0u;
  long long v5 = 0u;
  sub_1000C68E4((unsigned __int8 *)v4, a2);
  uint64_t v3 = *(void *)(a1 + 8);
  sub_1000C58F0((uint64_t)v6, (unsigned __int8 *)v4);
  (*(void (**)(uint64_t, unsigned char *))(v3 + 16))(v3, v6);
  if (v6[0] == 1 && __p)
  {
    char v8 = __p;
    operator delete(__p);
  }
  if (LOBYTE(v4[0]) == 1)
  {
    if (v4[1])
    {
      *(void **)&long long v5 = v4[1];
      operator delete(v4[1]);
    }
  }
}

void sub_10037C1D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, void *a10, uint64_t a11, uint64_t a12, char a13, void *__p, uint64_t a15)
{
  if (a13 == 1 && __p) {
    operator delete(__p);
  }
  if (a9 == 1)
  {
    if (a10) {
      operator delete(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10037C220(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037C260()
{
}

void *sub_10037C26C(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  *a1 = v3;
  return a1;
}

void sub_10037C2A4(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_10037C2C4(void *a1)
{
  *a1 = off_1019BF280;
  unsigned __int8 v2 = (const void *)a1[1];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10037C314(void *a1)
{
  *a1 = off_1019BF280;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10037C384(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 8);
  unsigned __int8 v2 = operator new(0x10uLL);
  void *v2 = off_1019BF280;
  sub_10037C4EC(v2 + 1, v1);
  return v2;
}

void *sub_10037C3D8(uint64_t a1, void *a2)
{
  *a2 = off_1019BF280;
  return sub_10037C4EC(a2 + 1, (void **)(a1 + 8));
}

void sub_10037C404(uint64_t a1)
{
}

void sub_10037C40C(const void **a1)
{
  sub_10037C524(a1[1]);

  operator delete(a1);
}

uint64_t sub_10037C448(uint64_t a1, unsigned __int8 *a2)
{
  if (*a2 - 1 >= 2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    __int16 v5 = 0;
  }
  else
  {
    unsigned __int8 v2 = a2[1];
    uint64_t v3 = *(void *)(a1 + 8);
    LOBYTE(v5) = *a2;
    HIBYTE(v5) = v2;
  }
  return (*(uint64_t (**)(uint64_t, __int16 *))(v3 + 16))(v3, &v5);
}

uint64_t sub_10037C4A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037C4E0()
{
}

void *sub_10037C4EC(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  *a1 = v3;
  return a1;
}

void sub_10037C524(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_10037C544(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    int v6 = result;
    sub_100311F60(result, a4);
    uint64_t result = (void *)sub_10037C5CC((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_10037C5AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_10037AB58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10037C5CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_10037AA60((char *)(a4 + v7), (long long *)(a2 + v7));
      v7 += 88;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_10037C62C(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 88;
    do
    {
      sub_10037ABDC(v4 + v2);
      v2 -= 88;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10037C650(void *a1)
{
  *a1 = off_1019BF300;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10037C6A0(void *a1)
{
  *a1 = off_1019BF300;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10037C710(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 8);
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019BF300;
  sub_10037C878(v2 + 1, v1);
  return v2;
}

void *sub_10037C764(uint64_t a1, void *a2)
{
  *a2 = off_1019BF300;
  return sub_10037C878(a2 + 1, (void **)(a1 + 8));
}

void sub_10037C790(uint64_t a1)
{
}

void sub_10037C798(const void **a1)
{
  sub_10037C8B0(a1[1]);

  operator delete(a1);
}

uint64_t sub_10037C7D4(uint64_t a1, unsigned __int8 *a2)
{
  if (*a2 - 1 >= 2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    __int16 v5 = 0;
  }
  else
  {
    unsigned __int8 v2 = a2[1];
    uint64_t v3 = *(void *)(a1 + 8);
    LOBYTE(v5) = *a2;
    HIBYTE(v5) = v2;
  }
  return (*(uint64_t (**)(uint64_t, __int16 *))(v3 + 16))(v3, &v5);
}

uint64_t sub_10037C82C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037C86C()
{
}

void *sub_10037C878(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  *a1 = v3;
  return a1;
}

void sub_10037C8B0(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_10037C8D0(void *a1)
{
  *a1 = off_1019BF380;
  unsigned __int8 v2 = (const void *)a1[1];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10037C920(void *a1)
{
  *a1 = off_1019BF380;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10037C990(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 8);
  unsigned __int8 v2 = operator new(0x10uLL);
  void *v2 = off_1019BF380;
  sub_10037CAF8(v2 + 1, v1);
  return v2;
}

void *sub_10037C9E4(uint64_t a1, void *a2)
{
  *a2 = off_1019BF380;
  return sub_10037CAF8(a2 + 1, (void **)(a1 + 8));
}

void sub_10037CA10(uint64_t a1)
{
}

void sub_10037CA18(const void **a1)
{
  sub_10037CB30(a1[1]);

  operator delete(a1);
}

uint64_t sub_10037CA54(uint64_t a1, unsigned __int8 *a2)
{
  if (*a2 - 1 >= 2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    __int16 v5 = 0;
  }
  else
  {
    unsigned __int8 v2 = a2[1];
    uint64_t v3 = *(void *)(a1 + 8);
    LOBYTE(v5) = *a2;
    HIBYTE(v5) = v2;
  }
  return (*(uint64_t (**)(uint64_t, __int16 *))(v3 + 16))(v3, &v5);
}

uint64_t sub_10037CAAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037CAEC()
{
}

void *sub_10037CAF8(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  *a1 = v3;
  return a1;
}

void sub_10037CB30(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_10037CB50(void *a1)
{
  *a1 = off_1019BF400;
  sub_1000C752C(a1 + 1);
  return a1;
}

void sub_10037CB94(void *a1)
{
  *a1 = off_1019BF400;
  sub_1000C752C(a1 + 1);

  operator delete();
}

void *sub_10037CBF8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  unsigned __int8 v2 = operator new(0x28uLL);
  void *v2 = off_1019BF400;
  sub_1000C7494((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10037CC4C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10037CC60(uint64_t a1, void *a2)
{
  *a2 = off_1019BF400;
  return sub_1000C7494((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_10037CC8C(uint64_t a1)
{
  return sub_1000C752C((void *)(a1 + 8));
}

void sub_10037CC94(void *a1)
{
  sub_1000C752C(a1 + 1);

  operator delete(a1);
}

uint64_t sub_10037CCD0(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  if ((v2 - 1) >= 2) {
    unsigned __int8 v3 = 0;
  }
  else {
    unsigned __int8 v3 = a2[1];
  }
  if ((v2 - 1) >= 2) {
    int v2 = 0;
  }
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    __int16 v5 = 0;
    if ((v2 - 1) <= 1)
    {
      LOBYTE(v5) = v2;
      HIBYTE(v5) = v3;
    }
    return (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)result + 48))(result, &v5);
  }
  return result;
}

uint64_t sub_10037CD4C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037CD8C()
{
}

void *sub_10037CD98(void *a1)
{
  *a1 = off_1019BF480;
  sub_1000C752C(a1 + 1);
  return a1;
}

void sub_10037CDDC(void *a1)
{
  *a1 = off_1019BF480;
  sub_1000C752C(a1 + 1);

  operator delete();
}

void *sub_10037CE40(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x28uLL);
  void *v2 = off_1019BF480;
  sub_1000C7494((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10037CE94(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10037CEA8(uint64_t a1, void *a2)
{
  *a2 = off_1019BF480;
  return sub_1000C7494((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_10037CED4(uint64_t a1)
{
  return sub_1000C752C((void *)(a1 + 8));
}

void sub_10037CEDC(void *a1)
{
  sub_1000C752C(a1 + 1);

  operator delete(a1);
}

uint64_t sub_10037CF18(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  if ((v2 - 1) >= 2) {
    unsigned __int8 v3 = 0;
  }
  else {
    unsigned __int8 v3 = a2[1];
  }
  if ((v2 - 1) >= 2) {
    int v2 = 0;
  }
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    __int16 v5 = 0;
    if ((v2 - 1) <= 1)
    {
      LOBYTE(v5) = v2;
      HIBYTE(v5) = v3;
    }
    return (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)result + 48))(result, &v5);
  }
  return result;
}

uint64_t sub_10037CF94(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037CFD4()
{
}

void *sub_10037CFE0(void *a1)
{
  *a1 = off_1019BF500;
  sub_1000C752C(a1 + 1);
  return a1;
}

void sub_10037D024(void *a1)
{
  *a1 = off_1019BF500;
  sub_1000C752C(a1 + 1);

  operator delete();
}

void *sub_10037D088(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x28uLL);
  void *v2 = off_1019BF500;
  sub_1000C7494((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10037D0DC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10037D0F0(uint64_t a1, void *a2)
{
  *a2 = off_1019BF500;
  return sub_1000C7494((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_10037D11C(uint64_t a1)
{
  return sub_1000C752C((void *)(a1 + 8));
}

void sub_10037D124(void *a1)
{
  sub_1000C752C(a1 + 1);

  operator delete(a1);
}

uint64_t sub_10037D160(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  if ((v2 - 1) >= 2) {
    unsigned __int8 v3 = 0;
  }
  else {
    unsigned __int8 v3 = a2[1];
  }
  if ((v2 - 1) >= 2) {
    int v2 = 0;
  }
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    __int16 v5 = 0;
    if ((v2 - 1) <= 1)
    {
      LOBYTE(v5) = v2;
      HIBYTE(v5) = v3;
    }
    return (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)result + 48))(result, &v5);
  }
  return result;
}

uint64_t sub_10037D1DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037D21C()
{
}

uint64_t sub_10037D228(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    unsigned __int8 v3 = (void *)(a1 + 24);
  }
  *unsigned __int8 v3 = 0;
  return a1;
}

void *sub_10037D2A8(void *a1)
{
  *a1 = off_1019BF580;
  int v2 = (const void *)a1[1];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10037D2F8(void *a1)
{
  *a1 = off_1019BF580;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10037D368(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 8);
  int v2 = operator new(0x10uLL);
  void *v2 = off_1019BF580;
  sub_10037D540(v2 + 1, v1);
  return v2;
}

void *sub_10037D3BC(uint64_t a1, void *a2)
{
  *a2 = off_1019BF580;
  return sub_10037D540(a2 + 1, (void **)(a1 + 8));
}

void sub_10037D3E8(uint64_t a1)
{
}

void sub_10037D3F0(const void **a1)
{
  sub_10037D578(a1[1]);

  operator delete(a1);
}

const void **sub_10037D42C(uint64_t a1, const void **a2)
{
  __int16 v5 = 0;
  int v6 = 0;
  sub_1000C7F94(&v5, a2);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v7 = 0;
  char v8 = 0;
  sub_1000C6188(&v7, &v5);
  uint64_t result = (const void **)(*(uint64_t (**)(uint64_t, const void **))(v3 + 16))(v3, &v7);
  if (v7 == 1) {
    uint64_t result = sub_100057D78(&v8);
  }
  if (v5 == 1) {
    return sub_100057D78(&v6);
  }
  return result;
}

void sub_10037D4B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, char a11, const void *a12)
{
  if (a11 == 1) {
    sub_100057D78(&a12);
  }
  if (a9 == 1) {
    sub_100057D78((const void **)&a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10037D4F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037D534()
{
}

void *sub_10037D540(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  *a1 = v3;
  return a1;
}

void sub_10037D578(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_10037D598(void *a1)
{
  *a1 = off_1019BF610;
  int v2 = (const void *)a1[1];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10037D5E8(void *a1)
{
  *a1 = off_1019BF610;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10037D658(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 8);
  int v2 = operator new(0x10uLL);
  void *v2 = off_1019BF610;
  sub_10037DA04(v2 + 1, v1);
  return v2;
}

void *sub_10037D6AC(uint64_t a1, void *a2)
{
  *a2 = off_1019BF610;
  return sub_10037DA04(a2 + 1, (void **)(a1 + 8));
}

void sub_10037D6D8(uint64_t a1)
{
}

void sub_10037D6E0(const void **a1)
{
  sub_10037DA3C(a1[1]);

  operator delete(a1);
}

unsigned char *sub_10037D71C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  int v3 = *a2;
  if (v3 == 2)
  {
    LOBYTE(v10[0]) = 2;
    char v4 = a2[8];
    BYTE8(v10[0]) = v4;
  }
  else
  {
    if (v3 != 1) {
      goto LABEL_21;
    }
    sub_10037DB78(v10, (uint64_t)(a2 + 8));
    if (LOBYTE(v10[0]) == 1)
    {
      if ((_BYTE)v11)
      {
        char v12 = 0;
        sub_1000C5DA8((uint64_t)v13, (uint64_t)v10 + 8);
        char v12 = 1;
        uint64_t v8 = *(void *)(a1 + 8);
        v19[0] = 1;
        long long v21 = v13[0];
        long long v22 = v13[1];
        long long v23 = v14;
        uint64_t v24 = v15;
        long long v14 = 0uLL;
        uint64_t v15 = 0;
        LOBYTE(v25) = 0;
        char v27 = 0;
        if (v18)
        {
          long long v25 = v16;
          uint64_t v26 = v17;
          uint64_t v17 = 0;
          long long v16 = 0uLL;
          char v27 = 1;
        }
        v20[0] = 1;
      }
      else
      {
        char v12 = 0;
        uint64_t v8 = *(void *)(a1 + 8);
        v19[0] = 1;
        v20[0] = 0;
      }
      (*(void (**)(uint64_t, char *))(v8 + 16))(v8, v19);
      if (v19[0] == 1) {
        sub_1000C60A0(v20);
      }
      uint64_t v7 = &v12;
      goto LABEL_17;
    }
    if (LOBYTE(v10[0]) != 2)
    {
LABEL_21:
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    char v4 = BYTE8(v10[0]);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  v19[0] = 2;
  v20[0] = v4;
  uint64_t result = (unsigned char *)(*(uint64_t (**)(void))(v5 + 16))();
  if (v19[0] != 1) {
    goto LABEL_18;
  }
  uint64_t v7 = v20;
LABEL_17:
  uint64_t result = sub_1000C60A0(v7);
LABEL_18:
  if (LOBYTE(v10[0]) == 1) {
    return (unsigned char *)sub_1000C612C((uint64_t)v10 + 8);
  }
  return result;
}

void sub_10037D938(_Unwind_Exception *a1, char a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  if (*(unsigned char *)(v3 - 144) == 1) {
    sub_1000C60A0(v2);
  }
  sub_1000C60A0(va1);
  if (a2 == 1) {
    sub_1000C612C((uint64_t)va);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10037D9B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037D9F8()
{
}

void *sub_10037DA04(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  *a1 = v3;
  return a1;
}

void sub_10037DA3C(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

uint64_t sub_10037DA5C(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  uint64_t v5 = a1 + 32;
  int v6 = (long long *)(a2 + 32);
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)v5);
  }
  long long v7 = *v6;
  *(void *)(v5 + 16) = *((void *)v6 + 2);
  *(_OWORD *)uint64_t v5 = v7;
  *(unsigned char *)(a2 + 55) = 0;
  *(unsigned char *)(a2 + 32) = 0;
  sub_10037DAD4(a1 + 56, (__n128 *)(a2 + 56));
  return a1;
}

__n128 sub_10037DAD4(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(unsigned char *)(a1 + 24))
    {
      sub_1000C8948((void **)a1);
      __n128 result = *a2;
      *(__n128 *)a1 = *a2;
      *(void *)(a1 + 16) = a2[1].n128_u64[0];
      a2->n128_u64[0] = 0;
      a2->n128_u64[1] = 0;
      a2[1].n128_u64[0] = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v5 = (void **)a1;
    sub_1000C57C8(&v5);
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    __n128 result = *a2;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

void sub_10037DB78(unsigned char *a1, uint64_t a2)
{
  if (*a1 == 1)
  {
    sub_10037DBC4((uint64_t)(a1 + 8), a2);
  }
  else
  {
    *a1 = 1;
    int v2 = a1 + 8;
    sub_1000C8A70(v2, a2);
  }
}

void sub_10037DBC4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a2 + 88))
  {
    if (*(unsigned char *)(a1 + 88)) {
      sub_10037DA5C(a1, a2);
    }
  }
  else if (*(unsigned char *)(a1 + 88))
  {
    sub_1000C8C70(a1);
  }
  else
  {
    sub_1000C8AB0(a1, a2);
  }
}

unsigned __int8 *sub_10037DBEC(unsigned __int8 *result, unsigned char *a2)
{
  uint64_t v3 = result;
  int v4 = *result;
  if (v4 == 1)
  {
    __n128 result = (unsigned __int8 *)sub_1000C62D8((uint64_t)(result + 8));
LABEL_5:
    *uint64_t v3 = 2;
    goto LABEL_6;
  }
  if (v4 != 2) {
    goto LABEL_5;
  }
LABEL_6:
  v3[8] = *a2;
  return result;
}

uint64_t sub_10037DC40(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_10037DCD8(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10037DD5C(void *a1)
{
  *a1 = off_1019BF6A0;
  sub_10037DCD8(a1 + 1);
  return a1;
}

void sub_10037DDA0(void *a1)
{
  *a1 = off_1019BF6A0;
  sub_10037DCD8(a1 + 1);

  operator delete();
}

void *sub_10037DE04(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x28uLL);
  void *v2 = off_1019BF6A0;
  sub_10037DC40((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10037DE58(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10037DE6C(uint64_t a1, void *a2)
{
  *a2 = off_1019BF6A0;
  return sub_10037DC40((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_10037DE98(uint64_t a1)
{
  return sub_10037DCD8((void *)(a1 + 8));
}

void sub_10037DEA0(void *a1)
{
  sub_10037DCD8(a1 + 1);

  operator delete(a1);
}

void sub_10037DEDC(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v19 = 0;
  *(_OWORD *)uint64_t v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  *(_OWORD *)uint64_t v16 = 0u;
  *(_OWORD *)uint64_t v13 = 0u;
  *(_OWORD *)uint64_t v14 = 0u;
  *(_OWORD *)uint64_t v11 = 0u;
  long long v12 = 0u;
  *(_OWORD *)uint64_t v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  *(_OWORD *)uint64_t v8 = 0u;
  sub_10037E570((unsigned __int8 *)&v7, a2);
  if (v7 == 2)
  {
    v20[0] = 2;
    char v20[8] = BYTE8(v7);
    uint64_t v5 = *(void *)(a1 + 32);
    if (!v5) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v5 + 48))(v5, v20);
    if (v20[0] == 1)
    {
      if (v32 < 0) {
        operator delete(__p);
      }
      if (v30 < 0) {
        operator delete(v29);
      }
      if (v28 < 0) {
        operator delete(v27);
      }
      if (v26 < 0) {
        operator delete(v25);
      }
      if (v24 < 0) {
        operator delete(v23);
      }
      if (v22 < 0) {
        operator delete(v21);
      }
      if ((v20[39] & 0x80000000) != 0)
      {
        int v4 = (void **)v20;
        goto LABEL_35;
      }
    }
  }
  else
  {
    if (v7 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    sub_10037E3E8((uint64_t)v33, (unsigned __int8 *)&v7);
    uint64_t v3 = *(void *)(a1 + 32);
    if (!v3) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v3 + 48))(v3, v33);
    if (v33[0] == 1)
    {
      if (v45 < 0) {
        operator delete(v44);
      }
      if (v43 < 0) {
        operator delete(v42);
      }
      if (v41 < 0) {
        operator delete(v40);
      }
      if (v39 < 0) {
        operator delete(v38);
      }
      if (v37 < 0) {
        operator delete(v36);
      }
      if (v35 < 0) {
        operator delete(v34);
      }
      if ((v33[39] & 0x80000000) != 0)
      {
        int v4 = (void **)v33;
LABEL_35:
        operator delete(v4[2]);
      }
    }
  }
  if (v7 == 1)
  {
    if (SHIBYTE(v18) < 0) {
      operator delete(v17[1]);
    }
    if (SHIBYTE(v17[0]) < 0) {
      operator delete(v16[0]);
    }
    if (SHIBYTE(v15) < 0) {
      operator delete(v14[1]);
    }
    if (SHIBYTE(v14[0]) < 0) {
      operator delete(v13[0]);
    }
    if (SHIBYTE(v12) < 0) {
      operator delete(v11[1]);
    }
    if (SHIBYTE(v10) < 0) {
      operator delete(v9[1]);
    }
    if (SHIBYTE(v9[0]) < 0) {
      operator delete(v8[0]);
    }
  }
}

void sub_10037E180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,void *__p,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  __cxa_free_exception(v53);
  if (a9 == 1)
  {
    if (a53 < 0) {
      operator delete(__p);
    }
    if (a47 < 0) {
      operator delete(a42);
    }
    if (a41 < 0) {
      operator delete(a36);
    }
    if (a35 < 0) {
      operator delete(a30);
    }
    if (a29 < 0) {
      operator delete(a24);
    }
    if (a22 < 0) {
      operator delete(a17);
    }
    if (a16 < 0) {
      operator delete(a11);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10037E31C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10037E35C()
{
}

uint64_t sub_10037E368(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t sub_10037E3E8(uint64_t a1, unsigned __int8 *a2)
{
  *(void *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  sub_10037E454((unsigned __int8 *)a1, a2);
  return a1;
}

void sub_10037E430(_Unwind_Exception *exception_object)
{
  if (*v1 == 1) {
    sub_1000C62D8((uint64_t)(v1 + 8));
  }
  *uint64_t v1 = 0;
  _Unwind_Resume(exception_object);
}

unsigned __int8 *sub_10037E454(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  if (v3 == 2)
  {
    sub_10037DBEC(a1, a2 + 8);
  }
  else if (v3 == 1)
  {
    sub_10037E4A8((uint64_t)a1, (uint64_t)(a2 + 8));
  }
  return a1;
}

std::string *sub_10037E4A8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a1 == 1)
  {
    *(void *)(a1 + 8) = *(void *)a2;
    std::string::operator=((std::string *)(a1 + 16), (const std::string *)(a2 + 8));
    std::string::operator=((std::string *)(a1 + 40), (const std::string *)(a2 + 32));
    *(_WORD *)(a1 + 64) = *(_WORD *)(a2 + 56);
    std::string::operator=((std::string *)(a1 + 72), (const std::string *)(a2 + 64));
    std::string::operator=((std::string *)(a1 + 96), (const std::string *)(a2 + 88));
    std::string::operator=((std::string *)(a1 + 120), (const std::string *)(a2 + 112));
    std::string::operator=((std::string *)(a1 + 144), (const std::string *)(a2 + 136));
    __n128 result = std::string::operator=((std::string *)(a1 + 168), (const std::string *)(a2 + 160));
    *(_WORD *)(a1 + 192) = *(_WORD *)(a2 + 184);
  }
  else
  {
    *(unsigned char *)a1 = 1;
    uint64_t v5 = a1 + 8;
    return (std::string *)sub_10023FB90(v5, a2);
  }
  return result;
}

unsigned __int8 *sub_10037E570(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  if (v3 == 2)
  {
    sub_10037DBEC(a1, a2 + 8);
  }
  else if (v3 == 1)
  {
    sub_10037E5C4((uint64_t)a1, (uint64_t)(a2 + 8));
  }
  return a1;
}

__n128 sub_10037E5C4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a1 == 1)
  {
    sub_10037E6A4(a1 + 8, a2);
  }
  else
  {
    *(unsigned char *)a1 = 1;
    *(void *)(a1 + 8) = *(void *)a2;
    long long v3 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 32) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 16) = v3;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 8) = 0;
    long long v4 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 56) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 40) = v4;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 32) = 0;
    *(_WORD *)(a1 + 64) = *(_WORD *)(a2 + 56);
    long long v5 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 88) = *(void *)(a2 + 80);
    *(_OWORD *)(a1 + 72) = v5;
    *(void *)(a2 + 72) = 0;
    *(void *)(a2 + 80) = 0;
    *(void *)(a2 + 64) = 0;
    long long v6 = *(_OWORD *)(a2 + 88);
    *(void *)(a1 + 112) = *(void *)(a2 + 104);
    *(_OWORD *)(a1 + 96) = v6;
    *(void *)(a2 + 96) = 0;
    *(void *)(a2 + 104) = 0;
    *(void *)(a2 + 88) = 0;
    long long v7 = *(_OWORD *)(a2 + 112);
    *(void *)(a1 + 136) = *(void *)(a2 + 128);
    *(_OWORD *)(a1 + 120) = v7;
    *(void *)(a2 + 120) = 0;
    *(void *)(a2 + 128) = 0;
    *(void *)(a2 + 112) = 0;
    long long v8 = *(_OWORD *)(a2 + 136);
    *(void *)(a1 + 160) = *(void *)(a2 + 152);
    *(_OWORD *)(a1 + 144) = v8;
    *(void *)(a2 + 136) = 0;
    *(void *)(a2 + 144) = 0;
    *(void *)(a2 + 152) = 0;
    __n128 result = *(__n128 *)(a2 + 160);
    *(void *)(a1 + 184) = *(void *)(a2 + 176);
    *(__n128 *)(a1 + 168) = result;
    *(void *)(a2 + 160) = 0;
    *(void *)(a2 + 168) = 0;
    *(void *)(a2 + 176) = 0;
    *(_WORD *)(a1 + 192) = *(_WORD *)(a2 + 184);
  }
  return result;
}

uint64_t sub_10037E6A4(uint64_t a1, uint64_t a2)
{
  long long v4 = (long long *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  uint64_t v5 = a1 + 8;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)v5);
  }
  long long v6 = *v4;
  *(void *)(v5 + 16) = *((void *)v4 + 2);
  *(_OWORD *)uint64_t v5 = v6;
  *(unsigned char *)(a2 + 31) = 0;
  *(unsigned char *)(a2 + 8) = 0;
  long long v7 = (void **)(a1 + 32);
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*v7);
  }
  long long v8 = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)long long v7 = v8;
  *(unsigned char *)(a2 + 55) = 0;
  *(unsigned char *)(a2 + 32) = 0;
  *(_WORD *)(a1 + 56) = *(_WORD *)(a2 + 56);
  uint64_t v9 = (void **)(a1 + 64);
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*v9);
  }
  long long v10 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(_OWORD *)uint64_t v9 = v10;
  *(unsigned char *)(a2 + 87) = 0;
  *(unsigned char *)(a2 + 64) = 0;
  uint64_t v11 = (void **)(a1 + 88);
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*v11);
  }
  long long v12 = *(_OWORD *)(a2 + 88);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(_OWORD *)uint64_t v11 = v12;
  *(unsigned char *)(a2 + 111) = 0;
  *(unsigned char *)(a2 + 88) = 0;
  uint64_t v13 = (void **)(a1 + 112);
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*v13);
  }
  long long v14 = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(_OWORD *)uint64_t v13 = v14;
  *(unsigned char *)(a2 + 135) = 0;
  *(unsigned char *)(a2 + 112) = 0;
  long long v15 = (void **)(a1 + 136);
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*v15);
  }
  long long v16 = *(_OWORD *)(a2 + 136);
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  *(_OWORD *)long long v15 = v16;
  *(unsigned char *)(a2 + 159) = 0;
  *(unsigned char *)(a2 + 136) = 0;
  uint64_t v17 = (void **)(a1 + 160);
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*v17);
  }
  long long v18 = *(_OWORD *)(a2 + 160);
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  *(_OWORD *)uint64_t v17 = v18;
  *(unsigned char *)(a2 + 183) = 0;
  *(unsigned char *)(a2 + 160) = 0;
  *(_WORD *)(a1 + 184) = *(_WORD *)(a2 + 184);
  return a1;
}

uint64_t sub_10037E838(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_10037E8D0(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10037E954(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_10037E9EC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void sub_10037EA6C()
{
}

void sub_10037EAB0()
{
}

void *sub_10037EAD4(void *a1)
{
  *a1 = off_1019E7510;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "pdp");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v4, &v3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 1), (const ctu::OsLogLogger *)v4);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v4);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
  *a1 = off_1019BF730;
  a1[3] = 0;
  a1[2] = a1 + 3;
  a1[7] = 0;
  a1[6] = 0;
  a1[4] = 0;
  a1[5] = a1 + 6;
  return a1;
}

void sub_10037EB98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10037EBBC(uint64_t a1)
{
  *(void *)a1 = off_1019BF730;
  sub_10037F764(*(char **)(a1 + 48));
  sub_10037F764(*(char **)(a1 + 24));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  return a1;
}

void sub_10037EC18(uint64_t a1)
{
  sub_10037EBBC(a1);

  operator delete();
}

void sub_10037EC50()
{
}

void sub_10037EC60()
{
}

void sub_10037F498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v29 - 105) < 0) {
    operator delete(*(void **)(v29 - 128));
  }
  sub_10037FC40(&a29);
  sub_10004D2C8(a13);
  _Unwind_Resume(a1);
}

void sub_10037F550(uint64_t a1, unsigned int a2, char a3)
{
  uint64_t v6 = a1 + 24;
  uint64_t v5 = *(void *)(a1 + 24);
  long long v7 = (void *)(v6 - 8);
  if (a3)
  {
    if (!v5) {
      goto LABEL_13;
    }
    uint64_t v8 = v6;
    do
    {
      unsigned int v9 = *(_DWORD *)(v5 + 32);
      BOOL v10 = v9 >= a2;
      if (v9 >= a2) {
        uint64_t v11 = (uint64_t *)v5;
      }
      else {
        uint64_t v11 = (uint64_t *)(v5 + 8);
      }
      if (v10) {
        uint64_t v8 = v5;
      }
      uint64_t v5 = *v11;
    }
    while (*v11);
    if (v8 == v6 || *(_DWORD *)(v8 + 32) > a2) {
LABEL_13:
    }
      sub_10037EC60();
  }
  else if (v5)
  {
    uint64_t v12 = v6;
    uint64_t v13 = v5;
    do
    {
      unsigned int v14 = *(_DWORD *)(v13 + 32);
      BOOL v15 = v14 >= a2;
      if (v14 >= a2) {
        long long v16 = (uint64_t *)v13;
      }
      else {
        long long v16 = (uint64_t *)(v13 + 8);
      }
      if (v15) {
        uint64_t v12 = v13;
      }
      uint64_t v13 = *v16;
    }
    while (*v16);
    if (v12 != v6 && *(_DWORD *)(v12 + 32) <= a2)
    {
      uint64_t v17 = *(void **)(v12 + 8);
      if (v17)
      {
        do
        {
          long long v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        uint64_t v19 = (void *)v12;
        do
        {
          long long v18 = (void *)v19[2];
          BOOL v20 = *v18 == (void)v19;
          uint64_t v19 = v18;
        }
        while (!v20);
      }
      if (*v7 == v12) {
        void *v7 = v18;
      }
      --*(void *)(a1 + 32);
      sub_10005EE6C((uint64_t *)v5, (uint64_t *)v12);
      if (*(char *)(v12 + 79) < 0) {
        operator delete(*(void **)(v12 + 56));
      }
      operator delete((void *)v12);
    }
  }
}

void sub_10037F748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10037F764(char *a1)
{
  if (a1)
  {
    sub_10037F764(*(void *)a1);
    sub_10037F764(*((void *)a1 + 1));
    if (a1[79] < 0) {
      operator delete(*((void **)a1 + 7));
    }
    operator delete(a1);
  }
}

void sub_10037F7C4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10037F7FC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    sub_10037F764(*(char **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_10037F858(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t *sub_10037F89C(uint64_t *result)
{
  uint64_t v1 = *result;
  std::string *result = 0;
  if (v1)
  {
    sub_10037F764(*(char **)(v1 + 8));
    operator delete();
  }
  return result;
}

void *sub_10037F8FC(void *a1)
{
  *a1 = off_1019BF820;
  int v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10037F948(void *a1)
{
  *a1 = off_1019BF820;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_10037F9B4(void *a1)
{
  __n128 result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  void *result = off_1019BF820;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *sub_10037FA18(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_1019BF820;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void sub_10037FA58(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10037FA68(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_10037FAA8(uint64_t a1, uint64_t *a2, unsigned int *a3)
{
  uint64_t v4 = *a2;
  unsigned int v5 = *a3;
  int v6 = *(_DWORD *)(*a2 + 16);
  memset(&__str, 0, sizeof(__str));
  sub_100058DB0(&__str, *(char **)(v4 + 8));
  long long v7 = *(uint64_t ***)(a1 + 8);
  unsigned int v9 = v7 + 1;
  uint64_t v8 = (uint64_t)v7[1];
  if (v8)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v10 = v8;
        unsigned int v11 = *(_DWORD *)(v8 + 32);
        if (v11 <= v5) {
          break;
        }
        uint64_t v8 = *(void *)v10;
        unsigned int v9 = (uint64_t **)v10;
        if (!*(void *)v10) {
          goto LABEL_9;
        }
      }
      if (v11 >= v5) {
        break;
      }
      uint64_t v8 = *(void *)(v10 + 8);
      if (!v8)
      {
        unsigned int v9 = (uint64_t **)(v10 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v10 = (uint64_t)(v7 + 1);
LABEL_9:
    uint64_t v12 = (char *)operator new(0x58uLL);
    *((_DWORD *)v12 + 8) = v5;
    *(_OWORD *)(v12 + 40) = 0u;
    *(_OWORD *)(v12 + 56) = 0u;
    *(_OWORD *)(v12 + 72) = 0u;
    sub_100046C38(v7, v10, v9, (uint64_t *)v12);
    uint64_t v10 = (uint64_t)v12;
  }
  *(unsigned char *)(v10 + 48) |= v6 & 1;
  std::string::operator=((std::string *)(v10 + 56), &__str);
  uint64_t v13 = *(void *)(v4 + 48);
  if (v13)
  {
    int v14 = *(_DWORD *)(v10 + 44);
    *(_DWORD *)(v10 + 40) += *(_DWORD *)(v13 + 28);
    *(_DWORD *)(v10 + 44) = v14 + *(_DWORD *)(v13 + 20);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_10037FBD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10037FBF4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10037FC34()
{
}

void *sub_10037FC40(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10037FCC4(uint64_t a1)
{
  sub_10037F764(*(char **)(a1 + 16));
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = *(void *)(v3 + 16);
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_10037F764((char *)v2);
  }
  return a1;
}

uint64_t **sub_10037FD14(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  int v6 = a1 + 1;
  unsigned int v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        long long v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        unsigned int v5 = *v7;
        int v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      unsigned int v5 = v7[1];
      if (!v5)
      {
        int v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    long long v7 = a1 + 1;
LABEL_9:
    unsigned int v9 = (char *)operator new(0x58uLL);
    *((_DWORD *)v9 + 8) = *a3;
    *(_OWORD *)(v9 + 40) = 0u;
    *(_OWORD *)(v9 + 56) = 0u;
    *(_OWORD *)(v9 + 72) = 0u;
    sub_100046C38(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t sub_10037FDCC@<X0>(uint64_t a1@<X2>, void *a2@<X8>)
{
  if (!a1
    || (uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 488))(a1)) == 0
    || (uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 40))(v3), (result & 1) != 0))
  {
    *a2 = 0;
    a2[1] = 0;
    operator new();
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void sub_10037FF28(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10037FF88(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, NSObject **a5, int a6)
{
  uint64_t v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v20 = *a2;
  long long v21 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v11 = *a5;
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  int v12 = *(_DWORD *)(*(void *)a3 + 52);
  if (v12 == 2)
  {
    int v13 = a6 - 28;
    if ((a6 - 28) <= 7)
    {
      int v14 = off_1019C11B0;
      BOOL v15 = off_1019C1170;
      goto LABEL_11;
    }
    long long v16 = "unknown.2";
  }
  else if (v12 == 1)
  {
    int v13 = a6 - 28;
    if ((a6 - 28) < 8)
    {
      int v14 = off_1019C1130;
      BOOL v15 = off_1019C10F0;
LABEL_11:
      long long v16 = v15[v13];
      uint64_t v17 = (uint64_t)v14[v13];
      goto LABEL_16;
    }
    long long v16 = "unknown.1";
  }
  else
  {
    long long v16 = "unknown.?";
  }
  uint64_t v17 = (uint64_t)v16;
LABEL_16:
  sub_10129653C((uint64_t)a1, (uint64_t *)&off_1019C0310, &v20, a3, a4, &object, v16, v17, a6);
  if (object) {
    dispatch_release(object);
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  *a1 = off_1019BF8D8;
  a1[8] = off_1019BFE28;
  a1[9] = off_1019C00B8;
  a1[10] = off_1019C02A8;
  a1[49] = a1 + 50;
  a1[50] = 0;
  a1[53] = 0;
  a1[54] = 0;
  a1[51] = 0;
  a1[52] = a1 + 53;
  return a1;
}

void sub_10038015C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  PersonalitySpecific::~PersonalitySpecific(v12);
  _Unwind_Resume(a1);
}

void sub_100380188(uint64_t a1)
{
  *(void *)a1 = off_1019BF8D8;
  *(void *)(a1 + 64) = off_1019BFE28;
  *(void *)(a1 + 72) = off_1019C00B8;
  *(void *)(a1 + 80) = off_1019C02A8;
  sub_10005D9E0(a1 + 416, *(void **)(a1 + 424));
  sub_10005D9E0(a1 + 392, *(void **)(a1 + 400));

  sub_101296BD8(a1, (uint64_t *)&off_1019C0310);
}

void sub_100380258(uint64_t a1)
{
  sub_100380188(a1);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100380280(uint64_t a1)
{
  sub_100380188(a1 - 64);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1003802AC(uint64_t a1)
{
  sub_100380188(a1 - 72);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1003802D8(uint64_t a1)
{
  sub_100380188(a1 - 80);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100380304(uint64_t a1)
{
  sub_100380188(a1);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_100380340(uint64_t a1)
{
}

void sub_100380348(uint64_t a1)
{
}

void sub_100380350(uint64_t a1)
{
}

uint64_t sub_100380358(uint64_t a1, unsigned int a2)
{
  if (!a2 && *(_DWORD *)(a1 + 168) && *(void *)(a1 + 176))
  {
    uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 216) + 488))(*(void *)(a1 + 216));
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 160))(v4);
    }
    (*(void (**)(void, void))(**(void **)(a1 + 176) + 144))(*(void *)(a1 + 176), 0);
  }
  switch(a2)
  {
    case 0u:
    case 5u:
      (*(void (**)(void))(**(void **)(a1 + 216) + 520))(*(void *)(a1 + 216));
      break;
    case 2u:
      if (*(void *)(a1 + 408))
      {
        unsigned int v5 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v14 = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I pending TrafficDescriptors (1)", v14, 2u);
        }
        sub_10005DA3C((uint64_t **)(a1 + 416), *(void **)(a1 + 392), (void *)(a1 + 400));
      }
      break;
    case 3u:
      if (!*(void *)(a1 + 408) && *(void *)(a1 + 432))
      {
        int v6 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I unpending TrafficDescriptors (1)", buf, 2u);
        }
        long long v7 = *(void **)(a1 + 416);
        unsigned int v8 = (void *)(a1 + 424);
        if (v7 != (void *)(a1 + 424))
        {
          do
          {
            sub_1003816BC((uint64_t **)(a1 + 392), (uint64_t)(v7 + 4), (const TrafficDescriptor *)(v7 + 4));
            unsigned int v9 = (void *)v7[1];
            if (v9)
            {
              do
              {
                uint64_t v10 = v9;
                unsigned int v9 = (void *)*v9;
              }
              while (v9);
            }
            else
            {
              do
              {
                uint64_t v10 = (void *)v7[2];
                BOOL v11 = *v10 == (void)v7;
                long long v7 = v10;
              }
              while (!v11);
            }
            long long v7 = v10;
          }
          while (v10 != v8);
        }
        sub_10005D9E0(a1 + 416, *(void **)(a1 + 424));
        *(void *)(a1 + 424) = 0;
        *(void *)(a1 + 432) = 0;
        *(void *)(a1 + 416) = v8;
      }
      break;
    default:
      break;
  }
  sub_101296F3C(a1, a2);
  uint64_t v12 = (*(uint64_t (**)(void))(**(void **)(a1 + 216) + 488))(*(void *)(a1 + 216));
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 160))(v12);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 216) + 512))(*(void *)(a1 + 216));
}

void sub_100380658(uint64_t a1, int a2, int a3, int a4, int a5)
{
  (*(void (**)(void))(**(void **)(a1 + 216) + 520))(*(void *)(a1 + 216));
  uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 216) + 488))();
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 160))(v10);
  }

  sub_10129CF74(a1, a2, a3, a4, a5);
}

void sub_100380750(uint64_t a1, int a2, int a3, int a4, int a5)
{
}

void sub_100380758(uint64_t a1, int a2, int a3, int a4, int a5)
{
}

uint64_t sub_100380760(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 216) + 488))(*(void *)(a1 + 216));
  if (v2 && *(void *)(a1 + 408))
  {
    uint64_t v3 = *(void **)(a1 + 392);
    uint64_t v4 = (void *)(a1 + 400);
    if (v3 != (void *)(a1 + 400))
    {
      uint64_t v5 = v2;
      do
      {
        int v6 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          TrafficDescriptor::toString((uint64_t *)v15, (TrafficDescriptor *)(v3 + 4));
          long long v7 = v16 >= 0 ? v15 : *(uint8_t **)v15;
          *(_DWORD *)long long buf = 136315138;
          long long v18 = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I redirect TrafficDescriptor: td = %s", buf, 0xCu);
          if (v16 < 0) {
            operator delete(*(void **)v15);
          }
        }
        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v14, (const TrafficDescriptor *)(v3 + 4));
        (*(void (**)(uint64_t, uint8_t *))(*(void *)v5 + 24))(v5, v14);
        TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v14);
        unsigned int v8 = (void *)v3[1];
        if (v8)
        {
          do
          {
            unsigned int v9 = v8;
            unsigned int v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            unsigned int v9 = (void *)v3[2];
            BOOL v10 = *v9 == (void)v3;
            uint64_t v3 = v9;
          }
          while (!v10);
        }
        uint64_t v3 = v9;
      }
      while (v9 != v4);
    }
    BOOL v11 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v15 = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I clearing TrafficDescriptors (1)", v15, 2u);
    }
    sub_10005D9E0(a1 + 392, *(void **)(a1 + 400));
    *(void *)(a1 + 400) = 0;
    *(void *)(a1 + 408) = 0;
    *(void *)(a1 + 392) = v4;
    sub_10005D9E0(a1 + 416, *(void **)(a1 + 424));
    *(void *)(a1 + 424) = 0;
    *(void *)(a1 + 432) = 0;
    *(void *)(a1 + 416) = a1 + 424;
    (*(void (**)(void))(**(void **)(a1 + 216) + 520))();
    sub_10129A688((void **)a1, 39, 0, 0);
  }
  if (*(void *)(a1 + 176))
  {
    uint64_t v12 = (*(uint64_t (**)(void))(**(void **)(a1 + 216) + 488))(*(void *)(a1 + 216));
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 160))(v12);
    }
    (*(void (**)(void, void))(**(void **)(a1 + 176) + 144))(*(void *)(a1 + 176), 0);
  }
  return 1;
}

void sub_100380A74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)va);
  _Unwind_Resume(a1);
}

void sub_100380A90(PersonalitySpecificImpl *a1, const char *a2, const char *a3, int a4, BOOL a5)
{
  uint64_t v10 = (*(uint64_t (**)(void *))(**((void **)a1 + 27) + 488))(*((void **)a1 + 27));
  if (v10)
  {
    BOOL v11 = (void (***)(void, uint64_t))v10;
    uint64_t v12 = PersonalitySpecificImpl::simSlot(a1);
    (**v11)(v11, v12);
  }

  sub_1012985D8((uint64_t)a1, a2, a3, a4, a5);
}

void sub_100380B60(uint64_t a1, const char *a2, const char *a3, int a4, BOOL a5)
{
}

void sub_100380B68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10129D47C(a1, a2, a3);
  if (*(void *)(a1 + 176))
  {
    uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 216) + 488))(*(void *)(a1 + 216));
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 160))(v4);
    }
    uint64_t v5 = *(void (**)(void))(**(void **)(a1 + 176) + 144);
    v5();
  }
}

void sub_100380C30(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100380C38(_DWORD *a1, long long *a2)
{
  long long v4 = a2[1];
  long long v5 = *a2;
  v6[0] = v4;
  *(_OWORD *)((char *)v6 + 10) = *(long long *)((char *)a2 + 26);
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long __p = a2[3];
    uint64_t v8 = *((void *)a2 + 8);
  }
  char v9 = *((unsigned char *)a2 + 72);
  sub_10129ECD0(a1, (uint64_t)&v5);
  if (SHIBYTE(v8) < 0) {
    operator delete((void *)__p);
  }
}

void sub_100380CC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100380CE4(uint64_t a1, long long *a2)
{
}

void sub_100380CEC(uint64_t a1, long long *a2)
{
}

uint64_t sub_100380CF4(uint64_t a1, TrafficDescriptor *a2)
{
  long long v4 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    TrafficDescriptor::toString((uint64_t *)__p, a2);
    long long v5 = v8 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136315138;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I add TrafficDescriptor: td = %s", buf, 0xCu);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }
  if (*(_DWORD *)(a1 + 168) == 2) {
    sub_1003816BC((uint64_t **)(a1 + 416), (uint64_t)a2, a2);
  }
  sub_1003816BC((uint64_t **)(a1 + 392), (uint64_t)a2, a2);
  sub_1012A4878(a1, (uint64_t)a2);
  (*(void (**)(void))(**(void **)(a1 + 216) + 520))(*(void *)(a1 + 216));
  return sub_10129A688((void **)a1, 39, 0, 0);
}

uint64_t sub_100380E4C(uint64_t a1, TrafficDescriptor *a2)
{
  return sub_100380CF4(a1 - 64, a2);
}

uint64_t sub_100380E54(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 408))
  {
    long long v4 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)char v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I clearing TrafficDescriptors (2)", v9, 2u);
    }
    sub_10005D9E0(a1 + 392, *(void **)(a1 + 400));
    *(void *)(a1 + 400) = 0;
    *(void *)(a1 + 408) = 0;
    *(void *)(a1 + 392) = a1 + 400;
    (*(void (**)(void))(**(void **)(a1 + 216) + 520))();
    sub_10129A688((void **)a1, 39, 0, 0);
  }
  if (*(void *)(a1 + 176))
  {
    uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 216) + 488))(*(void *)(a1 + 216));
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 160))(v5);
    }
    (*(void (**)(void, void))(**(void **)(a1 + 176) + 144))(*(void *)(a1 + 176), 0);
  }
  sub_10129D924((void **)a1, a2);
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 216) + 488))(*(void *)(a1 + 216));
  if (result)
  {
    uint64_t v7 = result;
    uint64_t v8 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 8))(v7, v8);
  }
  return result;
}

uint64_t sub_10038103C(uint64_t a1, uint64_t a2)
{
  return sub_100380E54(a1 - 72, a2);
}

char *sub_100381044(PersonalitySpecificImpl *a1, uint64_t a2)
{
  sub_10129C8F8(a1, 0, 0, &v5);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = v5;
  *(void *)(a2 + 16) = v6;
  return (char *)a1 + 392;
}

char *sub_1003810A4(uint64_t a1, uint64_t a2)
{
  return sub_100381044((PersonalitySpecificImpl *)(a1 - 64), a2);
}

void sub_1003810AC(void *a1)
{
  sub_1012A3D10((uint64_t)a1);
  if (a1[51])
  {
    uint64_t v2 = a1[7];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fSliceTrafficDescriptors: {", buf, 2u);
    }
    uint64_t v3 = (void *)a1[49];
    if (v3 != a1 + 50)
    {
      long long v4 = (void *)kDefaultAppBundleId;
      do
      {
        long long v5 = a1[7];
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          TrafficDescriptor::toString((uint64_t *)buf, (TrafficDescriptor *)(v3 + 4));
          if (v22 >= 0) {
            uint64_t v6 = buf;
          }
          else {
            uint64_t v6 = *(uint8_t **)buf;
          }
          uint64_t v7 = v4;
          if (*((unsigned char *)v3 + 104))
          {
            uint64_t v7 = v3 + 10;
            if (*((char *)v3 + 103) < 0) {
              uint64_t v7 = (void *)*v7;
            }
          }
          *(_DWORD *)long long v23 = 136315394;
          char v24 = v6;
          __int16 v25 = 2082;
          char v26 = v7;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\t %s: bundleId=%{public}s", v23, 0x16u);
          if (v22 < 0) {
            operator delete(*(void **)buf);
          }
        }
        uint64_t v8 = (void *)v3[1];
        if (v8)
        {
          do
          {
            char v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            char v9 = (void *)v3[2];
            BOOL v10 = *v9 == (void)v3;
            uint64_t v3 = v9;
          }
          while (!v10);
        }
        uint64_t v3 = v9;
      }
      while (v9 != a1 + 50);
    }
    BOOL v11 = a1[7];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t }", buf, 2u);
    }
  }
  if (a1[54])
  {
    uint64_t v12 = a1[7];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fSliceTrafficDescriptorsPending: {", buf, 2u);
    }
    int v13 = (void *)a1[52];
    if (v13 != a1 + 53)
    {
      int v14 = (void *)kDefaultAppBundleId;
      do
      {
        BOOL v15 = a1[7];
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          TrafficDescriptor::toString((uint64_t *)buf, (TrafficDescriptor *)(v13 + 4));
          if (v22 >= 0) {
            char v16 = buf;
          }
          else {
            char v16 = *(uint8_t **)buf;
          }
          uint64_t v17 = v14;
          if (*((unsigned char *)v13 + 104))
          {
            uint64_t v17 = v13 + 10;
            if (*((char *)v13 + 103) < 0) {
              uint64_t v17 = (void *)*v17;
            }
          }
          *(_DWORD *)long long v23 = 136315394;
          char v24 = v16;
          __int16 v25 = 2082;
          char v26 = v17;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\t %s: bundleId=%{public}s", v23, 0x16u);
          if (v22 < 0) {
            operator delete(*(void **)buf);
          }
        }
        long long v18 = (void *)v13[1];
        if (v18)
        {
          do
          {
            uint64_t v19 = v18;
            long long v18 = (void *)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            uint64_t v19 = (void *)v13[2];
            BOOL v10 = *v19 == (void)v13;
            int v13 = v19;
          }
          while (!v10);
        }
        int v13 = v19;
      }
      while (v19 != a1 + 53);
    }
    uint64_t v20 = a1[7];
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t }", buf, 2u);
    }
  }
}

void sub_100381430(uint64_t a1)
{
}

void sub_100381438(PersonalitySpecificImpl *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = (*(uint64_t (**)(void *))(**((void **)a1 + 27) + 488))(*((void **)a1 + 27));
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 160))(v8);
  }

  sub_1012A46B4(a1, a2, a3, a4);
}

void sub_1003814E4(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
}

void sub_1003814EC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1003815B8(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[5], v1, (dispatch_function_t)sub_100381690);
  __cxa_rethrow();
}

void sub_1003815E0(_Unwind_Exception *a1)
{
}

void sub_1003815F8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100381630(uint64_t a1)
{
}

uint64_t sub_10038164C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100381690(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1003816BC(uint64_t **a1, uint64_t a2, const TrafficDescriptor *a3)
{
  uint64_t v10 = 0;
  long long v5 = sub_10038175C((uint64_t)a1, &v10);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    memset(v9, 0, sizeof(v9));
    sub_1003817F0((uint64_t)a1, a3, v9);
    sub_100046C38(a1, v10, v7, (uint64_t *)v9[0]);
    uint64_t v6 = v9[0];
    v9[0] = 0;
    sub_100381864(v9, 0);
  }
  return v6;
}

void *sub_10038175C(uint64_t a1, void *a2)
{
  long long v4 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (v3)
  {
    do
    {
      while (1)
      {
        long long v5 = v3;
        if (!TrafficDescriptor::operator<()) {
          break;
        }
        uint64_t v3 = (void *)*v5;
        long long v4 = v5;
        if (!*v5) {
          goto LABEL_9;
        }
      }
      if (!TrafficDescriptor::operator<()) {
        break;
      }
      long long v4 = v5 + 1;
      uint64_t v3 = (void *)v5[1];
    }
    while (v3);
  }
  else
  {
    long long v5 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v5;
  return v4;
}

TrafficDescriptor *sub_1003817F0@<X0>(uint64_t a1@<X0>, const TrafficDescriptor *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v6 = (char *)operator new(0x150uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)(v6 + 32), a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_10038184C(_Unwind_Exception *a1)
{
  sub_100381864(v1, 0);
  _Unwind_Resume(a1);
}

void sub_100381864(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16)) {
      TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(v2 + 32));
    }
    operator delete((void *)v2);
  }
}

uint64_t *sub_1003818BC(uint64_t **a1, uint64_t *a2)
{
  uint64_t v5 = a1 + 1;
  long long v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v5 = (uint64_t **)v4;
        if (!TrafficDescriptor::operator<()) {
          break;
        }
        long long v4 = *v5;
        uint64_t v6 = v5;
        if (!*v5) {
          goto LABEL_8;
        }
      }
      long long v4 = v5[1];
    }
    while (v4);
    uint64_t v6 = v5 + 1;
  }
  else
  {
    uint64_t v6 = a1 + 1;
  }
LABEL_8:
  sub_100046C38(a1, (uint64_t)v5, v6, a2);
  return a2;
}

uint64_t sub_100381944(uint64_t a1)
{
  sub_10005D9E0(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_10005D9E0(*(void *)a1, v2);
  }
  return a1;
}

uint64_t sub_10038199C(uint64_t a1, const TrafficDescriptor *a2)
{
  memset(v8, 0, sizeof(v8));
  sub_1003817F0(a1, a2, v8);
  long long v4 = (uint64_t **)(a1 + 8);
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  if (v3)
  {
    do
    {
      while (1)
      {
        long long v4 = (uint64_t **)v3;
        if (!TrafficDescriptor::operator<()) {
          break;
        }
        uint64_t v3 = *v4;
        uint64_t v5 = v4;
        if (!*v4) {
          goto LABEL_8;
        }
      }
      uint64_t v3 = v4[1];
    }
    while (v3);
    uint64_t v5 = v4 + 1;
  }
  else
  {
    uint64_t v5 = (uint64_t **)(a1 + 8);
  }
LABEL_8:
  sub_100046C38((uint64_t **)a1, (uint64_t)v4, v5, (uint64_t *)v8[0]);
  uint64_t v6 = v8[0];
  v8[0] = 0;
  sub_100381864(v8, 0);
  return v6;
}

void sub_100381A50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100381864((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void sub_100381A68(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100381CEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

void sub_100381DD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)char v9 = *(_OWORD *)a2;
  uint64_t v10 = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  long long v4 = *(_OWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(_OWORD *)BOOL v11 = v4;
  uint64_t v12 = *(void *)(a2 + 40);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v14 = *(void *)(a2 + 64);
  *(_OWORD *)int v13 = *(_OWORD *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(_OWORD *)BOOL v15 = *(_OWORD *)(a2 + 72);
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  uint64_t v5 = *(void *)(a2 + 88);
  uint64_t v6 = *(void *)(a2 + 96);
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  uint64_t v16 = v5;
  uint64_t v17 = v6;
  long long v7 = *(_OWORD *)(a2 + 104);
  uint64_t v19 = *(void *)(a2 + 120);
  *(_OWORD *)long long __p = v7;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 120) = 0;
  char v20 = *(unsigned char *)(a2 + 128);
  sub_10033F0E0((uint64_t)&v21, a3);
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8)
  {
    if (std::__shared_weak_count::lock(v8)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10038206C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100382080(void *a1)
{
  sub_1003820B8(a1);

  operator delete();
}

void sub_1003820B8(void *a1)
{
  *a1 = off_1019C1200;
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[6];
  if (v3) {
    dispatch_release(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  AutoBugCaptureReporterInterface::~AutoBugCaptureReporterInterface((AutoBugCaptureReporterInterface *)a1);
}

void sub_100382138(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100382170(uint64_t a1)
{
}

uint64_t sub_10038218C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1003821D0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1003821FC(ServiceManager::Service *this)
{
  *(void *)this = off_1019C1330;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100382258(ServiceManager::Service *this)
{
  *(void *)this = off_1019C1330;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1003822C8@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "AutoBugCaptureReporter");
}

unsigned char *sub_1003822D8@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 5;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100382318(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v2);
    dispatch_group_leave(v2);
    dispatch_release(v2);
  }
}

uint64_t sub_100382374()
{
  return 0;
}

uint64_t sub_10038237C()
{
  return 1;
}

uint64_t sub_100382384()
{
  return 0;
}

uint64_t *sub_100382398(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v26 = a1;
  uint64_t v27 = v1;
  uint64_t v2 = v1;
  if (*(char *)(v1 + 23) < 0) {
    uint64_t v2 = *(void *)v1;
  }
  char v24 = +[NSString stringWithUTF8String:v2];
  uint64_t v3 = (void *)(v1 + 24);
  if (*(char *)(v1 + 47) < 0) {
    uint64_t v3 = (void *)*v3;
  }
  long long v4 = +[NSString stringWithUTF8String:v3];
  uint64_t v5 = (void *)(v1 + 48);
  if (*(char *)(v1 + 71) < 0) {
    uint64_t v5 = (void *)*v5;
  }
  uint64_t v6 = +[NSString stringWithUTF8String:v5];
  long long v7 = (void *)(v1 + 72);
  if (*(char *)(v1 + 95) < 0) {
    long long v7 = (void *)*v7;
  }
  __int16 v25 = +[NSString stringWithUTF8String:v7];
  uint64_t v28 = 0;
  uint64_t v29 = &v28;
  uint64_t v30 = 0x3032000000;
  long long v31 = sub_100382A58;
  char v32 = sub_100382A68;
  id v33 = 0;
  id v33 = objc_alloc_init((Class)SDRDiagnosticReporter);
  uint64_t v8 = [(id)v29[5] signatureWithDomain:v24 type:v4 subType:v6 subtypeContext:v25 detectedProcess:@"Commcenter" triggerThresholdValues:0];
  char v9 = (void *)(v1 + 104);
  if (*(char *)(v1 + 127) < 0)
  {
    if (!*(void *)(v1 + 112)) {
      goto LABEL_15;
    }
    char v9 = (void *)*v9;
    goto LABEL_14;
  }
  if (*(unsigned char *)(v1 + 127))
  {
LABEL_14:
    uint64_t v10 = +[NSString stringWithUTF8String:v9];
    [v8 setObject:v10 forKey:kSymptomDiagnosticSignatureCaseGroupID];
  }
LABEL_15:
  if (*(unsigned char *)(v1 + 128))
  {
    BOOL v11 = 1;
  }
  else
  {
    if (*(char *)(v1 + 127) < 0) {
      uint64_t v12 = *(void *)(v1 + 112);
    }
    else {
      uint64_t v12 = *(unsigned __int8 *)(v1 + 127);
    }
    BOOL v11 = v12 != 0;
  }
  id v13 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v14 = +[NSNumber numberWithBool:*(_DWORD *)(v1 + 96) & 1];
  [v13 setObject:v14 forKey:kSymptomDiagnosticActionLogArchive];

  BOOL v15 = +[NSNumber numberWithBool:(*(void *)(v1 + 96) >> 1) & 1];
  [v13 setObject:v15 forKey:kSymptomDiagnosticActionGetNetworkInfo];

  uint64_t v16 = +[NSNumber numberWithBool:(*(void *)(v1 + 96) >> 2) & 1];
  [v13 setObject:v16 forKey:kSymptomDiagnosticActionCrashAndSpinLogs];

  uint64_t v17 = +[NSNumber numberWithBool:(*(void *)(v1 + 96) >> 3) & 1];
  [v13 setObject:v17 forKey:kSymptomDiagnosticActionProbePacketCapture];

  if ((*(unsigned char *)(v1 + 96) & 0x10) != 0)
  {
    long long v18 = +[NSString stringWithFormat:@"AutoBugCapture - %@, %@", v4, v6];
    [v13 setObject:&__kCFBooleanTrue forKey:kSymptomDiagnosticActionDiagnosticExtensions];
    uint64_t v40 = kSymptomDiagnosticKeyPayloadDEParameters;
    v37[1] = v18;
    CFStringRef v38 = @"com.apple.DiagnosticExtensions.Cellular";
    v36[0] = @"CellularExtensionCommandKey";
    v36[1] = @"CellularExtensionDumpReasonKey";
    v37[0] = @"dump_attach";
    char v20 = +[NSDictionary dictionaryWithObjects:v37 forKeys:v36 count:2];
    char v39 = v20;
    uint64_t v21 = +[NSDictionary dictionaryWithObjects:&v39 forKeys:&v38 count:1];
    char v41 = v21;
    uint64_t v19 = +[NSDictionary dictionaryWithObjects:&v41 forKeys:&v40 count:1];
  }
  else
  {
    v36[0] = kSymptomDiagnosticExtensionsCommonActions;
    v37[0] = &__kCFBooleanFalse;
    long long v18 = +[NSDictionary dictionaryWithObjects:v37 forKeys:v36 count:1];
    [v13 setObject:v18 forKey:kSymptomDiagnosticActionDiagnosticExtensions];
    uint64_t v19 = 0;
  }

  char v22 = (void *)v29[5];
  v34[0] = _NSConcreteStackBlock;
  v34[1] = 3321888768;
  v34[2] = sub_100382A70;
  v34[3] = &unk_1019C13A8;
  v34[4] = &v28;
  sub_10033ECA0((uint64_t)v35, v1 + 136);
  [v22 snapshotWithSignature:v8 duration:0 events:v19 payload:v13 actions:v11 wantsRemoteCase:v34 reply:0.0];
  sub_1000DBADC(v35);

  _Block_object_dispose(&v28, 8);
  sub_1003829B8(&v27);
  return sub_100046B58((uint64_t *)&v26);
}

void sub_100382898(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id a21)
{
  _Block_object_dispose(&a16, 8);
  sub_1003829B8(&a15);
  sub_100046B58(&a14);
  _Unwind_Resume(a1);
}

uint64_t *sub_1003829B8(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    sub_1000DBADC((void *)(v1 + 136));
    if (*(char *)(v1 + 127) < 0) {
      operator delete(*(void **)(v1 + 104));
    }
    if (*(char *)(v1 + 95) < 0) {
      operator delete(*(void **)(v1 + 72));
    }
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100382A58(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100382A68(uint64_t a1)
{
}

void sub_100382A70(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0;

  uint64_t v6 = [v3 objectForKey:kSymptomDiagnosticReplyReason];
  id v7 = [v6 intValue];

  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    BOOL v11 = +[NSString stringWithFormat:@"Unknown Code [%d]", v7];
    uint64_t v12 = v11;
    if (kSymptomDiagnosticErrorNone == v7)
    {
      CFStringRef v13 = @"Success";
    }
    else if (kSymptomDiagnosticErrorDisabled == v7)
    {
      CFStringRef v13 = @"The service is disabled";
    }
    else if (kSymptomDiagnosticErrorServiceNotReady == v7)
    {
      CFStringRef v13 = @"The service is not yet ready";
    }
    else if (kSymptomDiagnosticErrorNotSupported == v7)
    {
      CFStringRef v13 = @"The requested API is not yet implemented";
    }
    else if (kSymptomDiagnosticErrorServiceUnavailable == v7)
    {
      CFStringRef v13 = @"The remote service did not respond";
    }
    else if (kSymptomDiagnosticErrorServiceInterrupted == v7)
    {
      CFStringRef v13 = @"The connection with the remote service was interrupted";
    }
    else if (kSymptomDiagnosticErrorInvalidParameters == v7)
    {
      CFStringRef v13 = @"The API was called with invalid or unsupported parameters";
    }
    else if (kSymptomDiagnosticErrorHourlyLimitExceeded == v7)
    {
      CFStringRef v13 = @"The session was rate limited based on the hourly quota";
    }
    else if (kSymptomDiagnosticErrorDailyLimitExceeded == v7)
    {
      CFStringRef v13 = @"The session was rate limited based on the daily quota";
    }
    else if (kSymptomDiagnosticErrorRandomizedSuppression == v7)
    {
      CFStringRef v13 = @"The session was rate limited based on randomized suppression";
    }
    else if (kSymptomDiagnosticErrorSessionNotFound == v7)
    {
      CFStringRef v13 = @"The session requested was not found";
    }
    else
    {
      if (kSymptomDiagnosticErrorRequestThrottled != v7)
      {
LABEL_39:
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
        _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "ABC snapshot responded: %@", (uint8_t *)&buf, 0xCu);

        goto LABEL_2;
      }
      CFStringRef v13 = @"The API request is temporarily throttled due to execssive calls";
    }

    uint64_t v12 = (__CFString *)v13;
    goto LABEL_39;
  }
LABEL_2:
  if (*(void *)(a1 + 64))
  {
    memset(&buf, 0, sizeof(buf));
    uint64_t v8 = [v3 objectForKeyedSubscript:kSymptomDiagnosticReplySuccess];
    unsigned __int8 v9 = [v8 BOOLValue];

    if ((v9 & 1) == 0) {
      goto LABEL_7;
    }
    uint64_t v10 = [v3 objectForKeyedSubscript:kSymptomDiagnosticReplyGroupID];
    if ([v10 length]) {
      sub_10003ED78(&buf, (char *)[v10 UTF8String]);
    }

    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__p, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    }
    else {
LABEL_7:
    }
      std::string __p = buf;
    sub_10033F214(a1 + 40, v7 == kSymptomDiagnosticErrorNone);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
  }
}

void sub_100382DF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100382E6C(uint64_t a1, uint64_t a2)
{
  return sub_10033ECA0(a1 + 40, a2 + 40);
}

void *sub_100382E78(uint64_t a1)
{
  return sub_1000DBADC((void *)(a1 + 40));
}

void sub_100382E80(StockholmHelperInterface *a1)
{
  *(void *)a1 = &off_1019C13E8;
  uint64_t v2 = *((void *)a1 + 1);
  if (v2) {
    dispatch_release(v2);
  }

  StockholmHelperInterface::~StockholmHelperInterface(a1);
}

void sub_100382EE0(StockholmHelperInterface *a1)
{
  sub_100382E80(a1);

  operator delete();
}

void sub_100382F6C(id a1)
{
  uint64_t v1 = objc_alloc_init(CTNFHardwareManager);
  uint64_t v2 = (void *)qword_101B0CD40;
  qword_101B0CD40 = (uint64_t)v1;
}

void sub_100383144(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1003831D8(uint64_t a1)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_100383250;
  v2[3] = &unk_1019C1450;
  void v2[4] = a1;
  return +[NFHardwareManager sharedHardwareManager:v2];
}

void sub_100383250(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "stockholm.helper");
  id v3 = v7;
  ctu::OsLogContext::~OsLogContext(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "sharedHardwareManager ready", buf, 2u);
  }
  uint64_t v4 = *(NSObject **)(v1 + 8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100383328;
  block[3] = &unk_1019A1BF8;
  block[4] = v1;
  dispatch_async(v4, block);
}

void sub_100383328()
{
  long long v0 = +[CTNFHardwareManager sharedManager];
  unsigned int v1 = [v0 fNFHWManagerReady];

  if (v1)
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v7, kCtLoggingSystemName, "stockholm.helper");
    uint64_t v2 = v8;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v7);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)id v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "setupHWStateChangeListener already called", v7, 2u);
    }
  }
  else
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v7, kCtLoggingSystemName, "stockholm.helper");
    id v3 = v8;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v7);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)id v7 = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "setupHWStateChangeListener", v7, 2u);
    }
    uint64_t v4 = +[CTNFHardwareManager sharedManager];
    [v4 setFNFHWManagerReady:1];

    uint64_t v5 = +[NFHardwareManager sharedHardwareManager];
    uint64_t v6 = +[CTNFHardwareManager sharedManager];
    [v5 registerEventListener:v6];
  }
}

void sub_10038347C(_Unwind_Exception *a1)
{
  id v3 = v2;

  _Unwind_Resume(a1);
}

uint64_t sub_1003834A4(uint64_t a1)
{
  (*(void (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v2 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40);

  return v2(a1, 1);
}

void sub_100383524(uint64_t a1, int a2)
{
  id v3 = +[CTNFHardwareManager sharedManager];
  unsigned __int8 v4 = [v3 fNFHWManagerReady];

  if (v4)
  {
    if (a2)
    {
      if (a2 != 1)
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "stockholm.helper");
        uint64_t v14 = *(NSObject **)&v28[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Assertion type unknown", buf, 2u);
        }
        goto LABEL_15;
      }
      uint64_t v5 = +[CTNFHardwareManager sharedManager];
      uint64_t v6 = [v5 fSEBootedAssertionHandle];

      if (v6)
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "stockholm.helper");
        id v7 = *(NSObject **)&v28[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO)) {
          goto LABEL_11;
        }
        goto LABEL_15;
      }
      uint64_t v16 = +[CTNFHardwareManager sharedManager];
      uint64_t v17 = +[NFHardwareManager sharedHardwareManager];
      id v26 = 0;
      long long v18 = [v17 requestAssertion:0 error:&v26];
      id v15 = v26;
      [v16 setFSEBootedAssertionHandle:v18];
    }
    else
    {
      unsigned __int8 v9 = +[CTNFHardwareManager sharedManager];
      uint64_t v10 = [v9 fSENoResetAssertionHandle];

      if (v10)
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "stockholm.helper");
        id v7 = *(NSObject **)&v28[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
        {
LABEL_11:
          uint64_t v11 = asString();
          *(_DWORD *)std::string buf = 136315138;
          *(void *)uint64_t v28 = v11;
          uint64_t v12 = "%s assertion already held";
          CFStringRef v13 = v7;
LABEL_12:
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, v12, buf, 0xCu);
        }
LABEL_15:
        id v15 = 0;
LABEL_16:

        return;
      }
      uint64_t v16 = +[CTNFHardwareManager sharedManager];
      uint64_t v17 = +[NFHardwareManager sharedHardwareManager];
      id v25 = 0;
      long long v18 = [v17 requestAssertion:1 error:&v25];
      id v15 = v25;
      [v16 setFSENoResetAssertionHandle:v18];
    }

    if (v15)
    {
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "stockholm.helper");
      uint64_t v19 = *(NSObject **)&v28[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        uint64_t v20 = asString();
        id v21 = [v15 localizedDescription];
        id v22 = [v21 UTF8String];
        *(_DWORD *)std::string buf = 136315394;
        *(void *)uint64_t v28 = v20;
        *(_WORD *)&v28[8] = 2080;
        *(void *)&v28[10] = v22;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%s assertion request failed : %s", buf, 0x16u);
      }
      goto LABEL_16;
    }
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "stockholm.helper");
    long long v23 = *(NSObject **)&v28[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
    {
      uint64_t v24 = asString();
      *(_DWORD *)std::string buf = 136315138;
      *(void *)uint64_t v28 = v24;
      uint64_t v12 = "%s assertion request successful";
      CFStringRef v13 = v23;
      goto LABEL_12;
    }
    goto LABEL_15;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "stockholm.helper");
  uint64_t v8 = *(NSObject **)&v28[4];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "NFHardwareManager not ready", buf, 2u);
  }
}

void sub_100383974(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100383A08(uint64_t a1, int a2)
{
  id v3 = +[CTNFHardwareManager sharedManager];
  unsigned __int8 v4 = [v3 fNFHWManagerReady];

  if (v4)
  {
    if (a2)
    {
      if (a2 != 1)
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v29, kCtLoggingSystemName, "stockholm.helper");
        id v22 = *(NSObject **)&v30[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v29);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v29) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Assertion type unknown", (uint8_t *)&v29, 2u);
        }
        goto LABEL_22;
      }
      uint64_t v5 = +[CTNFHardwareManager sharedManager];
      uint64_t v6 = [v5 fSEBootedAssertionHandle];

      if (v6)
      {
        id v7 = +[NFHardwareManager sharedHardwareManager];
        uint64_t v8 = +[CTNFHardwareManager sharedManager];
        unsigned __int8 v9 = [v8 fSEBootedAssertionHandle];
        uint64_t v10 = [v7 releaseAssertion:v9];

        uint64_t v11 = +[CTNFHardwareManager sharedManager];
        [v11 setFSEBootedAssertionHandle:0];
        goto LABEL_10;
      }
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v29, kCtLoggingSystemName, "stockholm.helper");
      uint64_t v27 = *(NSObject **)&v30[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v29);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_INFO)) {
        goto LABEL_22;
      }
    }
    else
    {
      CFStringRef v13 = +[CTNFHardwareManager sharedManager];
      uint64_t v14 = [v13 fSENoResetAssertionHandle];

      if (v14)
      {
        id v15 = +[NFHardwareManager sharedHardwareManager];
        uint64_t v16 = +[CTNFHardwareManager sharedManager];
        uint64_t v17 = [v16 fSENoResetAssertionHandle];
        uint64_t v10 = [v15 releaseAssertion:v17];

        uint64_t v11 = +[CTNFHardwareManager sharedManager];
        [v11 setFSENoResetAssertionHandle:0];
LABEL_10:

        if (v10)
        {
          ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v29, kCtLoggingSystemName, "stockholm.helper");
          long long v18 = *(NSObject **)&v30[4];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v29);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            uint64_t v19 = asString();
            id v20 = [v10 localizedDescription];
            id v21 = [v20 UTF8String];
            int v29 = 136315394;
            *(void *)uint64_t v30 = v19;
            *(_WORD *)&v30[8] = 2080;
            *(void *)&v30[10] = v21;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%s assertion release failed (%s)", (uint8_t *)&v29, 0x16u);
          }
          goto LABEL_23;
        }
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v29, kCtLoggingSystemName, "stockholm.helper");
        long long v23 = *(NSObject **)&v30[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v29);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
        {
          uint64_t v24 = asString();
          int v29 = 136315138;
          *(void *)uint64_t v30 = v24;
          id v25 = "%s assertion release successful";
          id v26 = v23;
LABEL_21:
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_INFO, v25, (uint8_t *)&v29, 0xCu);
        }
LABEL_22:
        uint64_t v10 = 0;
LABEL_23:

        return;
      }
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v29, kCtLoggingSystemName, "stockholm.helper");
      uint64_t v27 = *(NSObject **)&v30[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v29);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_INFO)) {
        goto LABEL_22;
      }
    }
    uint64_t v28 = asString();
    int v29 = 136315138;
    *(void *)uint64_t v30 = v28;
    id v25 = "%s assertion release not needed";
    id v26 = v27;
    goto LABEL_21;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v29, kCtLoggingSystemName, "stockholm.helper");
  uint64_t v12 = *(NSObject **)&v30[4];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v29);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v29) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "NFHardwareManager not ready", (uint8_t *)&v29, 2u);
  }
}

void sub_100383E84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100383F0C()
{
  id v3 = +[CTNFHardwareManager sharedManager];
  unsigned __int8 v0 = [v3 fNFHWManagerReady];

  if (v0)
  {
    id v4 = +[NFHardwareManager sharedHardwareManager];
    id v1 = [v4 startSecureElementManagerSession:&stru_1019C1490];
  }
  else
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "stockholm.helper");
    uint64_t v2 = v6;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "NFHardwareManager not ready", buf, 2u);
    }
  }
}

void sub_100384008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_100384020(id a1, NFSecureElementManagerSession *a2, NSError *a3)
{
  id v4 = a2;
  uint64_t v5 = a3;
  if (v5)
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "stockholm.helper");
    uint64_t v6 = *(NSObject **)&v29[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = [(NSError *)v5 localizedDescription];
      id v8 = [v7 UTF8String];
      *(_DWORD *)std::string buf = 136315138;
      *(void *)int v29 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Session open failed: %s", buf, 0xCu);
    }
  }
  else if (v4)
  {
    unsigned __int8 v9 = (const char *)kCtLoggingSystemName;
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "stockholm.helper");
    uint64_t v10 = *(NSObject **)&v29[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "Started SE manager session", buf, 2u);
    }
    id v27 = 0;
    uint64_t v11 = +[NFSecureElement embeddedSecureElementWithError:&v27];
    id v12 = v27;
    if (v12)
    {
      id v13 = v12;
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v9, "stockholm.helper");
      uint64_t v14 = *(NSObject **)&v29[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        id v24 = [v13 localizedDescription];
        id v25 = [v24 UTF8String];
        *(_DWORD *)std::string buf = 136315138;
        *(void *)int v29 = v25;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to get EOS Secure Element (%s)", buf, 0xCu);
      }
    }
    else if (v11)
    {
      uint64_t v17 = [v11 serialNumber];
      id v26 = 0;
      unsigned int v18 = [(NFSecureElementManagerSession *)v4 powerCycleSEID:v17 error:&v26];
      id v13 = v26;

      if (v18)
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v9, "stockholm.helper");
        uint64_t v19 = *(NSObject **)&v29[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "SE reset triggered successfully", buf, 2u);
        }
      }
      else if (v13)
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v9, "stockholm.helper");
        id v21 = *(NSObject **)&v29[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          id v22 = [v13 localizedDescription];
          id v23 = [v22 UTF8String];
          *(_DWORD *)std::string buf = 136315138;
          *(void *)int v29 = v23;
          _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "SE reset trigger failed (%s)", buf, 0xCu);
        }
      }
    }
    else
    {
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v9, "stockholm.helper");
      id v20 = *(NSObject **)&v29[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to get EOS Secure Element (returned null)", buf, 2u);
      }
      id v13 = 0;
    }
    [(NFSecureElementManagerSession *)v4 endSession];
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v9, "stockholm.helper");
    id v15 = *(NSObject **)&v29[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "Stopped SE manager session", buf, 2u);
    }
  }
  else
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "stockholm.helper");
    uint64_t v16 = *(NSObject **)&v29[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Session handle invalid", buf, 2u);
    }
  }
}

void sub_100384494(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100384554()
{
  unsigned __int8 v0 = +[CTNFHardwareManager sharedManager];
  unsigned __int8 v1 = [v0 fNFHWManagerReady];

  if (v1)
  {
    uint64_t v2 = +[CTNFHardwareManager sharedManager];
    id v3 = [v2 fSEBootedAssertionHandle];

    if (v3)
    {
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v9, kCtLoggingSystemName, "stockholm.helper");
      id v4 = v10;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v9);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)unsigned __int8 v9 = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "[EOS] : Booted assertion active", v9, 2u);
      }
    }
    uint64_t v5 = +[CTNFHardwareManager sharedManager];
    uint64_t v6 = [v5 fSENoResetAssertionHandle];

    if (v6)
    {
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v9, kCtLoggingSystemName, "stockholm.helper");
      id v7 = v10;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v9);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)unsigned __int8 v9 = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "[EOS] : No-reset assertion active", v9, 2u);
      }
    }
  }
  else
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v9, kCtLoggingSystemName, "stockholm.helper");
    id v8 = v10;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v9);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unsigned __int8 v9 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "[EOS] : NFHardwareManager not ready", v9, 2u);
    }
  }
}

void sub_10038471C(_Unwind_Exception *a1)
{
  uint64_t v2 = v1;

  _Unwind_Resume(a1);
}

id sub_100384738()
{
  unsigned __int8 v0 = +[CTNFHardwareManager sharedManager];
  unsigned __int8 v1 = [v0 fNFHWManagerReady];

  if (v1)
  {
    uint64_t v2 = +[NFHardwareManager sharedHardwareManager];
    id v10 = 0;
    id v3 = [v2 currentInMetroStatus:&v10];
    id v4 = v10;

    if (v4)
    {
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "stockholm.helper");
      uint64_t v5 = *(NSObject **)&v12[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        id v8 = [v4 localizedDescription];
        id v9 = [v8 UTF8String];
        *(_DWORD *)std::string buf = 136315138;
        *(void *)id v12 = v9;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Error calling currentInMetroStatus: (%s)", buf, 0xCu);
      }
      id v3 = 0;
    }
  }
  else
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "stockholm.helper");
    uint64_t v6 = *(NSObject **)&v12[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "NFHardwareManager not ready", buf, 2u);
    }
    return 0;
  }
  return v3;
}

void sub_1003848F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_100384938(void *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[3] = 0;
  *a1 = off_1019C14D8;
  a1[1] = a2;
  id v3 = operator new(0x20uLL);
  v3[1] = 0;
  v3[2] = 0;
  *id v3 = off_1019B3378;
  *((unsigned char *)v3 + 24) = 0;
  a1[4] = v3 + 3;
  a1[5] = v3;
  return a1;
}

void sub_1003849B0(_Unwind_Exception *a1)
{
  sub_1003849C4(v1);
  _Unwind_Resume(a1);
}

void *sub_1003849C4(void *a1)
{
  *a1 = off_1019C18A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  a1[2] = 0;
  a1[3] = 0;
  if (v2)
  {
    sub_10004D2C8(v2);
    id v3 = (std::__shared_weak_count *)a1[3];
    if (v3) {
      sub_10004D2C8(v3);
    }
  }
  return a1;
}

void sub_100384A20(void *a1)
{
  uint64_t v2 = *(NSObject **)(a1[1] + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    unsigned int v3 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
    if (v3 > 6) {
      id v4 = "???";
    }
    else {
      id v4 = off_1019C2038[v3];
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%s Suspend request ignored", (uint8_t *)&v5, 0xCu);
  }
}

void sub_100384B0C(void *a1)
{
  uint64_t v2 = *(NSObject **)(a1[1] + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    unsigned int v3 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
    if (v3 > 6) {
      id v4 = "???";
    }
    else {
      id v4 = off_1019C2038[v3];
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%s Deactivation complete ignored", (uint8_t *)&v5, 0xCu);
  }
}

void sub_100384BF8(void *a1)
{
  uint64_t v2 = a1[1];
  unsigned int v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    unsigned int v4 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
    if (v4 > 6) {
      int v5 = "???";
    }
    else {
      int v5 = off_1019C2038[v4];
    }
    int v6 = 136315138;
    id v7 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%s Baseband reset", (uint8_t *)&v6, 0xCu);
    uint64_t v2 = a1[1];
  }
  sub_100384CFC(v2, 0);
}

void sub_100384CFC(uint64_t a1, unsigned int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  unsigned int v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    unsigned int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 424) + 16))(*(void *)(a1 + 424));
    if (v5 > 6) {
      int v6 = "???";
    }
    else {
      int v6 = off_1019C2038[v5];
    }
    if (a2 > 7) {
      id v7 = "???";
    }
    else {
      id v7 = off_1019C1FF8[a2];
    }
    int v8 = 136315394;
    id v9 = v6;
    __int16 v10 = 2080;
    uint64_t v11 = v7;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed in state: %s, reason: %s", (uint8_t *)&v8, 0x16u);
  }
  sub_1003882B4(a1);
}

void sub_100384E64(void *a1)
{
  uint64_t v2 = a1[1];
  unsigned int v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    unsigned int v4 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
    if (v4 > 6) {
      unsigned int v5 = "???";
    }
    else {
      unsigned int v5 = off_1019C2038[v4];
    }
    int v6 = 136315138;
    id v7 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%s Stewie mode failure", (uint8_t *)&v6, 0xCu);
    uint64_t v2 = a1[1];
  }
  sub_100384F68(v2, 1u);
}

void sub_100384F68(uint64_t a1, unsigned int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  unsigned int v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    unsigned int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 424) + 16))(*(void *)(a1 + 424));
    if (v5 > 6) {
      int v6 = "???";
    }
    else {
      int v6 = off_1019C2038[v5];
    }
    if (a2 > 7) {
      id v7 = "???";
    }
    else {
      id v7 = off_1019C1FF8[a2];
    }
    int v8 = 136315394;
    id v9 = v6;
    __int16 v10 = 2080;
    uint64_t v11 = v7;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed in state: %s, reason: %s", (uint8_t *)&v8, 0x16u);
  }
  sub_100388554(a1);
}

uint64_t sub_1003850D0()
{
  return 0;
}

uint64_t sub_1003850D8()
{
  return 0;
}

void *sub_1003850E0(void *a1)
{
  *a1 = off_1019C14D8;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }

  return sub_1003849C4(a1);
}

void *sub_100385144(void *a1, uint64_t a2)
{
  unsigned int v3 = sub_100384938(a1, a2);
  *unsigned int v3 = off_1019C1538;
  sub_1005CA910(v3[1]);
  sub_1005C8A18(a1[1]);
  sub_1005C47B0(a1[1]);
  unsigned int v4 = (void *)a1[1];
  unsigned int v5 = (void *)v4[12];
  v4 += 12;
  sub_1000346F8((uint64_t)(v4 - 1), v5);
  *(v4 - 1) = v4;
  *unsigned int v4 = 0;
  v4[1] = 0;
  uint64_t v6 = a1[1];
  __int16 v10 = 0;
  sub_1005CA860(v6, (uint64_t)&v10);
  uint64_t v7 = a1[1];
  *(unsigned char *)(v7 + 68) = 0;
  *(_DWORD *)(v7 + 124) = 0;
  int v8 = *(std::__shared_weak_count **)(v7 + 136);
  *(void *)(v7 + 128) = 0;
  *(void *)(v7 + 136) = 0;
  if (v8) {
    sub_10004D2C8(v8);
  }
  *(unsigned char *)(a1[1] + 316) = 0;
  return a1;
}

void sub_1003851F4(_Unwind_Exception *a1)
{
  sub_1003850E0(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10038520C()
{
  return 0;
}

void sub_100385214(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 24));
  if (!*(void *)(v2 + 464))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    if (*(unsigned char *)(v3 + 64))
    {
      if (*(unsigned char *)(v3 + 65))
      {
        if (!*(unsigned char *)(v3 + 67) && !*(unsigned char *)(v3 + 66) && !*(unsigned char *)(v3 + 281))
        {
          uint64_t v5 = *(void *)(v3 + 336);
          if (v5)
          {
            if (*(_DWORD *)(v5 + 68) == 2)
            {
              uint64_t v6 = *(void *)(a1 + 8);
              sub_1003852FC(v6);
            }
          }
        }
      }
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
    (***(void (****)(void, void))(v3 + 432))(*(void *)(v3 + 432), 0);
    uint64_t v4 = *(void *)(a1 + 8);
    sub_1005CA648(v4);
  }
}

void sub_1003852FC(uint64_t a1)
{
}

void sub_1003855E4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_100385640(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    int v2 = 136315138;
    uint64_t v3 = "[BB:kIdle]";
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "%s Ignoring baseband reset", (uint8_t *)&v2, 0xCu);
  }
}

void sub_1003856E8(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    int v2 = 136315138;
    uint64_t v3 = "[BB:kIdle]";
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "%s Ignoring Stewie mode failure", (uint8_t *)&v2, 0xCu);
  }
}

uint64_t sub_100385790()
{
  return 1;
}

void sub_100385798(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!*(unsigned char *)(v2 + 64))
  {
    if (*(unsigned char *)(a1 + 49))
    {
      sub_100385C60(v2);
    }
    sub_100385D1C(v2);
  }
  if (!*(unsigned char *)(a1 + 48))
  {
    if (*(unsigned char *)(v2 + 352) && !*(void *)(a1 + 72))
    {
      sub_1005CA910(v2);
      sub_1005C8A18(*(void *)(a1 + 8));
      uint64_t v8 = *(void *)(a1 + 8);
      sub_1005C47B0(v8);
    }
    else if (*(unsigned char *)(v2 + 144) && !*(void *)(a1 + 72))
    {
      uint64_t v10 = *(void *)(v2 + 176);
      uint64_t v9 = *(void *)(v2 + 184);
      if (v9) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v11 = *(std::__shared_weak_count **)(a1 + 80);
      *(void *)(a1 + 72) = v10;
      *(void *)(a1 + 80) = v9;
      if (v11) {
        sub_10004D2C8(v11);
      }
      uint64_t v12 = *(void *)(a1 + 8);
      uint64_t v14 = *(void *)(v12 + 160);
      uint64_t v13 = *(void *)(v12 + 168);
      if (v13) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
      }
      id v15 = *(std::__shared_weak_count **)(a1 + 64);
      *(void *)(a1 + 56) = v14;
      *(void *)(a1 + 64) = v13;
      if (v15) {
        sub_10004D2C8(v15);
      }
      uint64_t v16 = *(void *)(a1 + 8);
      uint64_t v17 = *(NSObject **)(v16 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        double v18 = *(float *)(*(void *)(a1 + 56) + 40);
        *(_DWORD *)std::string buf = 136315394;
        uint64_t v30 = "[BB:kActivating]";
        __int16 v31 = 2048;
        double v32 = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s Selected uncertainity: %f", buf, 0x16u);
        uint64_t v16 = *(void *)(a1 + 8);
      }
      sub_1005C457C(v16);
      uint64_t v20 = *(void *)(a1 + 32);
      uint64_t v19 = *(void *)(a1 + 40);
      if (v19) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 16), 1uLL, memory_order_relaxed);
      }
      uint64_t v21 = *(void *)(a1 + 8);
      id v22 = operator new(0x20uLL);
      *id v22 = off_1019C1958;
      v22[1] = a1;
      void v22[2] = v20;
      void v22[3] = v19;
      id v33 = v22;
      sub_1005C8B38(v21, a1 + 72, (uint64_t)buf);
      sub_1003891A4(buf);
    }
    else if (*(unsigned char *)(a1 + 50) && *(unsigned char *)(v2 + 67))
    {
      *(unsigned char *)(a1 + 48) = 1;
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      sub_1005C9DAC(v2, &v27);
      uint64_t v3 = *(void *)(a1 + 8);
      if (!v27)
      {
        id v23 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v30 = "[BB:kActivating]";
          _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%s Failed to fetch target line sets", buf, 0xCu);
          uint64_t v3 = *(void *)(a1 + 8);
        }
        sub_100384CFC(v3, 2u);
      }
      sub_1005CA4C0(*(void *)(a1 + 8), a1 + 56, a1 + 72);
      uint64_t v4 = *(void *)(a1 + 8);
      *(unsigned char *)(v4 + 68) = 0;
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v5 = *(std::__shared_weak_count **)(a1 + 40);
      if (v5)
      {
        atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        uint64_t v4 = *(void *)(a1 + 8);
        uint64_t v7 = std::__shared_weak_count::lock(v5);
        if (v7)
        {
          atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          uint64_t v25 = v6;
          id v26 = v7;
          sub_10004D2C8(v7);
        }
        else
        {
          uint64_t v25 = 0;
          id v26 = 0;
        }
        atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      else
      {
        uint64_t v25 = 0;
        id v26 = 0;
      }
      id v24 = operator new(0x20uLL);
      *id v24 = off_1019C19D8;
      v24[1] = v6;
      void v24[2] = v5;
      v24[3] = a1;
      id v33 = v24;
      sub_1005C9E98((void *)v4, &v25, &v27, (uint64_t)buf);
      sub_100060644(buf);
      if (v26) {
        std::__shared_weak_count::__release_weak(v26);
      }
      if (v5) {
        std::__shared_weak_count::__release_weak(v5);
      }
      if (v28) {
        sub_10004D2C8(v28);
      }
    }
  }
}

void sub_100385BA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13)
{
  sub_100060644(&a13);
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100385C24(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100385C60(uint64_t a1)
{
}

void sub_100385D1C(uint64_t a1)
{
}

void *sub_100385DD8(void *a1, uint64_t *a2)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *a2;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v8 = (std::__shared_weak_count *)a1[1];
      *a1 = v7;
      a1[1] = v6;
      if (v8) {
        std::__shared_weak_count::__release_weak(v8);
      }
      sub_10004D2C8(v6);
    }
    else
    {
      uint64_t v9 = (std::__shared_weak_count *)a1[1];
      *a1 = 0;
      a1[1] = 0;
      if (v9) {
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  return a1;
}

void sub_100385E5C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    int v4 = 136315138;
    uint64_t v5 = "[BB:kActivating]";
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%s Stewie mode failure", (uint8_t *)&v4, 0xCu);
    uint64_t v2 = *(void *)(a1 + 8);
  }
  if (*(unsigned char *)(a1 + 49)) {
    sub_100384F68(v2, 1u);
  }
  sub_100384CFC(v2, 1u);
}

uint64_t sub_100385F38()
{
  return 2;
}

void sub_100385F40(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!*(unsigned char *)(v2 + 64))
  {
    sub_100385C60(v2);
  }
  sub_1005C6200(v2);
  if (!*(unsigned char *)(a1 + 48) && !*(unsigned char *)(a1 + 50))
  {
    if (sub_1005CA7F4(*(void *)(a1 + 8)))
    {
      *(unsigned char *)(a1 + 50) = 1;
      uint64_t v4 = *(void *)(a1 + 32);
      uint64_t v3 = *(void *)(a1 + 40);
      if (v3) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
      }
      uint64_t v5 = *(void *)(*(void *)(a1 + 8) + 320);
      uint64_t v6 = (long long *)operator new(0x20uLL);
      *(void *)uint64_t v6 = off_1019C1B58;
      *((void *)v6 + 1) = v4;
      *((void *)v6 + 2) = v3;
      *((void *)v6 + 3) = a1;
      p_long long buf = v6;
      (*(void (**)(uint64_t, long long *))(*(void *)v5 + 80))(v5, &buf);
      sub_100060644(&buf);
    }
    else
    {
      if (*(unsigned char *)(a1 + 49))
      {
        *(unsigned char *)(a1 + 49) = 0;
        uint64_t v7 = *(void *)(a1 + 8);
        uint64_t v8 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = "[BB:kActive]";
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s Processing postponed suspend", (uint8_t *)&buf, 0xCu);
          uint64_t v7 = *(void *)(a1 + 8);
        }
        sub_100386604(v7);
      }
      uint64_t v9 = *(void *)(a1 + 8);
      if (*(unsigned char *)(v9 + 68))
      {
        uint64_t v40 = 0;
        char v41 = 0;
        sub_1005C9DAC(v9, &v40);
        uint64_t v10 = *(void *)(a1 + 8);
        if (!v40)
        {
          uint64_t v16 = *(NSObject **)(v10 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "[BB:kActive]";
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%s Failed to fetch target line sets", (uint8_t *)&buf, 0xCu);
            uint64_t v10 = *(void *)(a1 + 8);
          }
          sub_100384F68(v10, 2u);
        }
        *(unsigned char *)(v10 + 68) = 0;
        *(unsigned char *)(a1 + 48) = 1;
        uint64_t v12 = *(void *)(a1 + 32);
        uint64_t v11 = *(std::__shared_weak_count **)(a1 + 40);
        v39[0] = v12;
        v39[1] = (uint64_t)v11;
        if (v11)
        {
          atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          uint64_t v10 = *(void *)(a1 + 8);
          sub_100385DD8(&v37, v39);
          atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          sub_100385DD8(&v37, v39);
        }
        uint64_t v17 = (long long *)operator new(0x20uLL);
        *(void *)uint64_t v17 = off_1019C1BD8;
        *((void *)v17 + 1) = a1;
        *((void *)v17 + 2) = v12;
        *((void *)v17 + 3) = v11;
        p_long long buf = v17;
        sub_1005C9E98((void *)v10, &v37, &v40, (uint64_t)&buf);
        sub_100060644(&buf);
        if (v38) {
          std::__shared_weak_count::__release_weak(v38);
        }
        if (v11) {
          std::__shared_weak_count::__release_weak(v11);
        }
        if (v41) {
          sub_10004D2C8(v41);
        }
      }
      else
      {
        if (*(unsigned char *)(v9 + 280))
        {
          uint64_t v13 = *(NSObject **)(v9 + 40);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "[BB:kActive]";
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s Time to suspend for a regulatory location check. Will perform regulatory location check before resume", (uint8_t *)&buf, 0xCu);
            uint64_t v9 = *(void *)(a1 + 8);
          }
          *(_DWORD *)(v9 + 124) = 1;
          sub_1005CA910(v9);
          uint64_t v15 = *(void *)(a1 + 8);
          uint64_t v14 = (uint64_t *)(a1 + 8);
          sub_1005C8A18(v15);
          sub_1005C47B0(*v14);
          sub_100386604(*v14);
        }
        if (*(unsigned char *)(v9 + 352))
        {
          double v18 = *(NSObject **)(v9 + 40);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "[BB:kActive]";
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s Time to suspend due to high speed non-emergency environment", (uint8_t *)&buf, 0xCu);
            uint64_t v9 = *(void *)(a1 + 8);
          }
          *(_DWORD *)(v9 + 124) = 3;
          sub_1005CA910(v9);
          uint64_t v20 = *(void *)(a1 + 8);
          uint64_t v19 = (uint64_t *)(a1 + 8);
          sub_1005C8A18(v20);
          sub_1005C47B0(*v19);
          sub_100386604(*v19);
        }
        if (*(void *)(v9 + 160) && *(void *)(v9 + 176) && *(void *)(v9 + 264))
        {
          uint64_t v21 = *(void *)(v9 + 240);
          sub_1005C4B48(*(void *)(a1 + 8), (uint64_t *)&buf);
          uint64_t v22 = (**(uint64_t (***)(void))buf)(buf);
          uint64_t v23 = v21 + 30000000000;
          if (*((void *)&buf + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
          }
          id v24 = *(void **)(a1 + 8);
          if (v22 >= v23)
          {
            uint64_t v25 = v24[30];
            if (v24[27] >= v25 || v24[26] >= v25 || v24[28] >= v25)
            {
              sub_1005CA4C0((uint64_t)v24, (uint64_t)(v24 + 20), (uint64_t)(v24 + 22));
              id v26 = *(void **)(a1 + 8);
              if (v26[28] >= v26[30])
              {
                uint64_t v27 = (std::__shared_weak_count *)v26[25];
                uint64_t v40 = v26[24];
                char v41 = v27;
                if (v27)
                {
                  atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
                  id v26 = *(void **)(a1 + 8);
                }
              }
              else
              {
                uint64_t v40 = 0;
                char v41 = 0;
              }
              v26[30] = v22;
              uint64_t v28 = v26[40];
              uint64_t v29 = v26[20];
              uint64_t v30 = v26[22];
              uint64_t v31 = v26[33];
              *(void *)&long long buf = off_1019C1C58;
              p_long long buf = &buf;
              (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *, long long *))(*(void *)v28 + 144))(v28, v29, v30, v31, v31 + 72, &v40, &buf);
              sub_100060644(&buf);
              if (v41) {
                sub_10004D2C8(v41);
              }
              id v24 = *(void **)(a1 + 8);
            }
          }
          uint64_t v32 = v24[31];
          if (v22 >= v32 + 300000000000 && v24[27] >= v32)
          {
            sub_1005C457C((uint64_t)v24);
            uint64_t v34 = *(void *)(a1 + 32);
            uint64_t v33 = *(void *)(a1 + 40);
            if (v33) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v33 + 16), 1uLL, memory_order_relaxed);
            }
            uint64_t v35 = *(void *)(a1 + 8);
            long long v36 = (long long *)operator new(0x20uLL);
            *(void *)long long v36 = off_1019C1CD8;
            *((void *)v36 + 1) = a1;
            *((void *)v36 + 2) = v34;
            *((void *)v36 + 3) = v33;
            p_long long buf = v36;
            sub_1005C8B38(v35, v35 + 176, (uint64_t)&buf);
            sub_1003891A4(&buf);
          }
        }
      }
    }
  }
}

void sub_100386550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
}

void sub_100386604(uint64_t a1)
{
}

void sub_100386920(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_10038697C(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 48);
  if (!*(unsigned char *)(a1 + 48) && !*(unsigned char *)(a1 + 50))
  {
    uint64_t v7 = *(void *)(a1 + 8);
    sub_100386604(v7);
  }
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "Configuring S4";
    if (!v2) {
      uint64_t v4 = "";
    }
    int v5 = *(unsigned __int8 *)(a1 + 50);
    uint64_t v9 = "[BB:kActive]";
    int v8 = 136315650;
    __int16 v10 = 2080;
    uint64_t v11 = v4;
    if (v5) {
      uint64_t v6 = "Initiating registration";
    }
    else {
      uint64_t v6 = "";
    }
    __int16 v12 = 2080;
    uint64_t v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s Currently busy [%s] [%s]. Will postpone suspend.", (uint8_t *)&v8, 0x20u);
  }
  *(unsigned char *)(a1 + 49) = 1;
}

uint64_t sub_100386AC4()
{
  return 1;
}

uint64_t sub_100386ACC()
{
  return 1;
}

uint64_t sub_100386AD4()
{
  return 3;
}

void *sub_100386ADC(void *result)
{
  uint64_t v1 = result[1];
  if (!*(unsigned char *)(v1 + 64))
  {
    uint64_t v8 = result[1];
    sub_100385C60(v8);
  }
  if (!*(unsigned char *)(v1 + 67))
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 24));
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 24));
    operator new();
  }
  int v2 = result;
  if (!*((unsigned char *)result + 48))
  {
    *((unsigned char *)result + 48) = 1;
    uint64_t v4 = result[4];
    uint64_t v3 = result[5];
    if (v3)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
      uint64_t v1 = result[1];
    }
    uint64_t v5 = *(void *)(v1 + 320);
    uint64_t v6 = *(unsigned int *)(v1 + 124);
    uint64_t v7 = operator new(0x20uLL);
    void *v7 = off_1019C1D58;
    v7[1] = v2;
    v7[2] = v4;
    v7[3] = v3;
    uint64_t v9[3] = v7;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v5 + 64))(v5, v6, v9);
    return sub_100060644(v9);
  }
  return result;
}

void sub_100386F94(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_100387040(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    sub_100058DB0(&__p, "ReEvaluationTimer");
    v7[0] = off_1019C1DD8;
    v7[1] = a1;
    v7[3] = v7;
    AutoStartTimer::create();
    long long v2 = v6;
    long long v6 = 0uLL;
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
    *(_OWORD *)(a1 + 16) = v2;
    if (v3)
    {
      sub_10004D2C8(v3);
      if (*((void *)&v6 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v6 + 1));
      }
    }
    sub_10003B34C(v7);
    if (v5 < 0) {
      operator delete(__p);
    }
  }
}

void sub_10038713C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100387168()
{
  return 4;
}

uint64_t sub_100387170(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 8);
  if (!*(unsigned char *)(v2 + 64))
  {
    uint64_t v5 = *(void *)(result + 8);
    sub_100385C60(v5);
  }
  uint64_t v3 = result;
  if (a2)
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v16 = 136315394;
      uint64_t v17 = "[BB:kSuspended]";
      __int16 v18 = 2048;
      uint64_t v19 = 60;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%s Timer expired (after %lld seconds): Not going to wait for BB to finish search any longer", (uint8_t *)&v16, 0x16u);
      uint64_t v2 = *(void *)(v3 + 8);
    }
    sub_10038736C(v2);
  }
  long long v6 = *(void **)(v2 + 88);
  if (v6 == (void *)(v2 + 96))
  {
    if (*(unsigned char *)(v2 + 282)) {
      return result;
    }
LABEL_29:
    LOBYTE(v12) = 0;
    goto LABEL_30;
  }
  unsigned int v7 = 0;
  int v8 = 0;
  do
  {
    int v9 = *((unsigned __int8 *)v6 + 32);
    if (!*((unsigned char *)v6 + 32)) {
      ++v7;
    }
    __int16 v10 = (void *)v6[1];
    if (v10)
    {
      do
      {
        uint64_t v11 = v10;
        __int16 v10 = (void *)*v10;
      }
      while (v10);
    }
    else
    {
      do
      {
        uint64_t v11 = (void *)v6[2];
        BOOL v13 = *v11 == (void)v6;
        long long v6 = v11;
      }
      while (!v13);
    }
    v8 += v9;
    long long v6 = v11;
  }
  while (v11 != (void *)(v2 + 96));
  LOBYTE(v12) = v8 != 0;
  if (*(unsigned char *)(v2 + 282)) {
    BOOL v13 = v8 == 0;
  }
  else {
    BOOL v13 = 0;
  }
  if (!v13)
  {
LABEL_30:
    LOBYTE(v16) = v12;
    BYTE1(v16) = 1;
    sub_1005CA860(v2, (uint64_t)&v16);
    uint64_t v14 = *(void **)(v3 + 8);
    uint64_t v15 = (void *)v14[12];
    v14 += 12;
    sub_1000346F8((uint64_t)(v14 - 1), v15);
    *(v14 - 1) = v14;
    *uint64_t v14 = 0;
    v14[1] = 0;
    sub_10038736C(*(void *)(v3 + 8));
  }
  if (v7)
  {
    uint64_t v12 = *(void *)(v2 + 72);
    if (!v12) {
      goto LABEL_30;
    }
    if (*(void *)(v12 + 16) <= (unint64_t)v7) {
      goto LABEL_29;
    }
  }
  return result;
}

void sub_10038736C(uint64_t a1)
{
}

void sub_100387710(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1003877A0()
{
  return 5;
}

void sub_1003877A8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!*(unsigned char *)(v2 + 64))
  {
    sub_100385C60(v2);
  }
  if (!*(unsigned char *)(a1 + 48))
  {
    if (*(unsigned char *)(v2 + 352) && !*(void *)(a1 + 72))
    {
      sub_1005CA910(v2);
      sub_1005C8A18(*(void *)(a1 + 8));
      uint64_t v14 = *(void *)(a1 + 8);
      sub_1005C47B0(v14);
    }
    else if (*(unsigned char *)(v2 + 144) && !*(void *)(a1 + 72))
    {
      uint64_t v16 = *(void *)(v2 + 176);
      uint64_t v15 = *(void *)(v2 + 184);
      if (v15) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v17 = *(std::__shared_weak_count **)(a1 + 80);
      *(void *)(a1 + 72) = v16;
      *(void *)(a1 + 80) = v15;
      if (v17) {
        sub_10004D2C8(v17);
      }
      uint64_t v18 = *(void *)(a1 + 8);
      uint64_t v20 = *(void *)(v18 + 160);
      uint64_t v19 = *(void *)(v18 + 168);
      if (v19) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v21 = *(std::__shared_weak_count **)(a1 + 64);
      *(void *)(a1 + 56) = v20;
      *(void *)(a1 + 64) = v19;
      if (v21) {
        sub_10004D2C8(v21);
      }
      uint64_t v22 = *(void *)(a1 + 8);
      uint64_t v23 = *(NSObject **)(v22 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        double v24 = *(float *)(*(void *)(a1 + 56) + 40);
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = "[BB:kResuming]";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(double *)&buf[14] = v24;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s Selected uncertainity: %f", buf, 0x16u);
        uint64_t v22 = *(void *)(a1 + 8);
      }
      sub_1005C457C(v22);
      uint64_t v26 = *(void *)(a1 + 32);
      uint64_t v25 = *(void *)(a1 + 40);
      if (v25) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 16), 1uLL, memory_order_relaxed);
      }
      uint64_t v27 = *(void *)(a1 + 8);
      uint64_t v28 = operator new(0x20uLL);
      *uint64_t v28 = off_1019C1E58;
      v28[1] = a1;
      v28[2] = v26;
      void v28[3] = v25;
      uint64_t v33 = v28;
      sub_1005C8B38(v27, a1 + 72, (uint64_t)buf);
      sub_1003891A4(buf);
    }
    else if (*(unsigned char *)(a1 + 49) && *(unsigned char *)(v2 + 67))
    {
      *(unsigned char *)(a1 + 48) = 1;
      sub_1005CA4C0(v2, a1 + 56, a1 + 72);
      uint64_t v3 = *(void *)(a1 + 8);
      *(_DWORD *)(v3 + 124) = 0;
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v4 = *(void *)(a1 + 40);
      if (v4)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
        uint64_t v3 = *(void *)(a1 + 8);
      }
      uint64_t v6 = *(void *)(v3 + 232);
      if (*(void *)(v3 + 208) >= v6 && *(void *)(v3 + 224) >= v6)
      {
        uint64_t v29 = *(std::__shared_weak_count **)(v3 + 200);
        uint64_t v30 = *(void *)(v3 + 192);
        uint64_t v31 = v29;
        if (v29)
        {
          atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v3 = *(void *)(a1 + 8);
        }
      }
      else
      {
        uint64_t v30 = 0;
        uint64_t v31 = 0;
      }
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
      Registry::getTimerService((uint64_t *)buf, *(Registry **)(v3 + 360));
      uint64_t v7 = (***(uint64_t (****)(void))buf)(*(void *)buf);
      uint64_t v8 = *(void *)(a1 + 8);
      *(void *)(v8 + 240) = v7;
      if (*(void *)&buf[8])
      {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        uint64_t v8 = *(void *)(a1 + 8);
      }
      uint64_t v9 = *(void *)(v8 + 320);
      uint64_t v10 = *(void *)(a1 + 56);
      uint64_t v11 = *(void *)(a1 + 72);
      uint64_t v12 = *(void *)(a1 + 88);
      BOOL v13 = operator new(0x20uLL);
      void *v13 = off_1019C1ED8;
      v13[1] = a1;
      _OWORD v13[2] = v5;
      v13[3] = v4;
      uint64_t v33 = v13;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *, unsigned char *))(*(void *)v9 + 72))(v9, v10, v11, v12, v12 + 72, &v30, buf);
      sub_100060644(buf);
      if (v31) {
        sub_10004D2C8(v31);
      }
    }
  }
}

void sub_100387B78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1003891A4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100387C0C()
{
  if (v0) {
    JUMPOUT(0x100387BCCLL);
  }
  JUMPOUT(0x100387BECLL);
}

uint64_t sub_100387C18()
{
  return 6;
}

void sub_100387C20(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (a2)
  {
    uint64_t v4 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v12 = 136315394;
      *(void *)BOOL v13 = "[BB:kDeactivating]";
      *(_WORD *)&unsigned char v13[8] = 2048;
      *(void *)&v13[10] = 30;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%s Timer expired (after %lld seconds): Not going to wait for BB to send deactivation complete any longer", (uint8_t *)&v12, 0x16u);
      uint64_t v3 = *(void *)(a1 + 8);
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
    (***(void (****)(void, void))(v3 + 432))(*(void *)(v3 + 432), 0);
    sub_100385D1C(*(void *)(a1 + 8));
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  if (!*(void *)(v3 + 464) && !*(unsigned char *)(a1 + 48))
  {
    *(unsigned char *)(a1 + 48) = 1;
    uint64_t v5 = *(void *)(a1 + 8);
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v5 + 24));
    Registry::getTimerService((uint64_t *)&v12, *(Registry **)(v5 + 360));
    sub_100387040(a1);
    if (*(void *)&v13[4]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v13[4]);
    }
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v9 = *(void *)(v8 + 320);
    int v10 = *(unsigned __int8 *)(v8 + 66);
    uint64_t v11 = operator new(0x20uLL);
    *uint64_t v11 = off_1019C1F58;
    v11[1] = a1;
    _OWORD v11[2] = v7;
    v11[3] = v6;
    uint64_t v14 = v11;
    (*(void (**)(uint64_t, BOOL, int *))(*(void *)v9 + 48))(v9, v10 == 0, &v12);
    sub_100060644(&v12);
  }
}

void sub_100387E18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100387E5C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 24));
  (***(void (****)(void, void))(v2 + 432))(*(void *)(v2 + 432), 0);
  uint64_t v3 = *(void *)(a1 + 8);

  sub_100385D1C(v3);
}

void sub_100387EC8(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    int v2 = 136315138;
    uint64_t v3 = "[BB:kDeactivating]";
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "%s Ignoring Stewie mode failure", (uint8_t *)&v2, 0xCu);
  }
}

void sub_100387F74(void *a1)
{
  sub_1003850E0(a1);

  operator delete();
}

void *sub_100387FAC(void *a1)
{
  *a1 = off_1019C1598;
  int v2 = (std::__shared_weak_count *)a1[14];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[12];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[10];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[8];
  if (v5) {
    sub_10004D2C8(v5);
  }

  return sub_1003850E0(a1);
}

void sub_10038802C(void *a1)
{
  *a1 = off_1019C1598;
  int v2 = (std::__shared_weak_count *)a1[14];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[12];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[10];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[8];
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_1003850E0(a1);

  operator delete();
}

void sub_1003880C4(void *a1)
{
  sub_1003850E0(a1);

  operator delete();
}

void sub_100388100(void *a1)
{
  sub_1003850E0(a1);

  operator delete();
}

void sub_10038813C(void *a1)
{
  sub_1003850E0(a1);

  operator delete();
}

void *sub_100388174(void *a1)
{
  *a1 = off_1019C1718;
  int v2 = (std::__shared_weak_count *)a1[12];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[10];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[8];
  if (v4) {
    sub_10004D2C8(v4);
  }

  return sub_1003850E0(a1);
}

void sub_1003881E8(void *a1)
{
  *a1 = off_1019C1718;
  int v2 = (std::__shared_weak_count *)a1[12];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[10];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[8];
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_1003850E0(a1);

  operator delete();
}

void sub_100388274(void *a1)
{
  sub_1003850E0(a1);

  operator delete();
}

void sub_1003882B4(uint64_t a1)
{
}

void sub_1003884F8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_100388554(uint64_t a1)
{
}

void sub_10038878C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void *sub_1003887E8(void *a1)
{
  *a1 = off_1019C18D8;
  int v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100388840(void *a1)
{
  *a1 = off_1019C18D8;
  int v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

char *sub_1003888B8(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x30uLL);
  *(void *)uint64_t result = off_1019C18D8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  *((void *)result + 4) = *(void *)(a1 + 32);
  *((void *)result + 5) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100388934(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019C18D8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 40) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10038898C(uint64_t a1)
{
}

void sub_100388994(void *a1)
{
  sub_100388C68((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1003889D0(void *a1, uint64_t *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    uint64_t v5 = a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[2])
      {
        uint64_t v8 = *a2;
        if (!*a2)
        {
          uint64_t v15 = *(void *)(v5 + 8);
          uint64_t v16 = *(NSObject **)(v15 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = "[BB:kActivating]";
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%s Failed to get security credentials", buf, 0xCu);
            uint64_t v15 = *(void *)(v5 + 8);
          }
          sub_100384CFC(v15, 2u);
        }
        uint64_t v9 = a2[1];
        if (v9) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
        }
        int v10 = *(std::__shared_weak_count **)(v5 + 112);
        *(void *)(v5 + 104) = v8;
        *(void *)(v5 + 112) = v9;
        if (v10) {
          sub_10004D2C8(v10);
        }
        uint64_t v11 = *(void *)(v5 + 8);
        int v12 = *(NSObject **)(v11 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "[BB:kActivating]";
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s Activation package ready", buf, 0xCu);
          uint64_t v11 = *(void *)(v5 + 8);
        }
        *(unsigned char *)(v5 + 50) = 1;
        if (!*(void *)(v11 + 128))
        {
          sub_100C5CE70(buf);
          uint64_t v13 = *(void *)(v5 + 8);
          uint64_t v14 = *(std::__shared_weak_count **)(v13 + 136);
          *(_OWORD *)(v13 + 128) = *(_OWORD *)buf;
          if (v14) {
            sub_10004D2C8(v14);
          }
          uint64_t v11 = *(void *)(v5 + 8);
        }
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v11 + 24));
        (***(void (****)(void, uint64_t))(v11 + 432))(*(void *)(v11 + 432), 1);
        sub_100385798(v5);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100388C08(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100388C1C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100388C5C()
{
}

void sub_100388C68(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *sub_100388CB8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100388D3C(void *a1)
{
  *a1 = off_1019C1958;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100388D88(void *a1)
{
  *a1 = off_1019C1958;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100388DF4(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019C1958;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100388E58(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019C1958;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100388E98(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100388EA8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100388EE8(void *a1, uint64_t *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    uint64_t v5 = (void *)a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[2])
      {
        uint64_t v8 = *a2;
        if (!*a2)
        {
          uint64_t v21 = v5[1];
          uint64_t v22 = *(NSObject **)(v21 + 40);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            LODWORD(v23) = 136315138;
            *(void *)((char *)&v23 + 4) = "[BB:kActivating]";
            _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%s Failed to get provisioning data", (uint8_t *)&v23, 0xCu);
            uint64_t v21 = v5[1];
          }
          sub_100384CFC(v21, 4u);
        }
        uint64_t v9 = a2[1];
        if (v9) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
        }
        int v10 = (std::__shared_weak_count *)v5[12];
        v5[11] = v8;
        v5[12] = v9;
        if (v10) {
          sub_10004D2C8(v10);
        }
        uint64_t v11 = v5[1];
        uint64_t v13 = *a2;
        uint64_t v12 = a2[1];
        if (v12) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v14 = *(std::__shared_weak_count **)(v11 + 272);
        *(void *)(v11 + 264) = v13;
        *(void *)(v11 + 272) = v12;
        if (v14) {
          sub_10004D2C8(v14);
        }
        uint64_t v16 = v5[4];
        uint64_t v15 = v5[5];
        if (v15) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 16), 1uLL, memory_order_relaxed);
        }
        uint64_t v17 = v5[1];
        *(void *)&long long v23 = v5;
        *((void *)&v23 + 1) = v16;
        uint64_t v19 = *a2;
        uint64_t v18 = (std::__shared_weak_count *)a2[1];
        uint64_t v24 = v15;
        uint64_t v25 = v19;
        uint64_t v26 = v18;
        if (v18) {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v28 = 0;
        uint64_t v20 = operator new(0x30uLL);
        void *v20 = off_1019C18D8;
        v20[1] = v5;
        v20[2] = v16;
        v20[3] = v15;
        *((void *)&v23 + 1) = 0;
        uint64_t v24 = 0;
        void v20[4] = v19;
        v20[5] = v18;
        if (v18) {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v28 = v20;
        sub_1005C7A8C(v17, (uint64_t)v27);
        sub_100388CB8(v27);
        if (v18) {
          sub_10004D2C8(v18);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100389124(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100389158(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100389198()
{
}

void *sub_1003891A4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100389228(void *a1)
{
  *a1 = off_1019C19D8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100389274(void *a1)
{
  *a1 = off_1019C19D8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_1003892E0(void *a1)
{
  uint64_t result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  void *result = off_1019C19D8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *sub_100389344(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_1019C19D8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void sub_100389384(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100389394(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1003893D4(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = (void *)a1[3];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[1])
      {
        if (v4)
        {
          uint64_t v8 = v5[4];
          uint64_t v7 = v5[5];
          if (v7) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 16), 1uLL, memory_order_relaxed);
          }
          uint64_t v9 = v5[1];
          uint64_t v10 = v5[11];
          uint64_t v11 = operator new(0x20uLL);
          *uint64_t v11 = off_1019C1A58;
          v11[1] = v5;
          _OWORD v11[2] = v8;
          v11[3] = v7;
          uint64_t v16 = v11;
          sub_1005C8EE8(v9, 1, v10 + 48, (uint64_t)&v14);
        }
        uint64_t v12 = v5[1];
        uint64_t v13 = *(NSObject **)(v12 + 40);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          int v14 = 136315138;
          uint64_t v15 = "[BB:kActivating]";
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%s Failed to configureS4", (uint8_t *)&v14, 0xCu);
          uint64_t v12 = v5[1];
        }
        sub_100384CFC(v12, 3u);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100389538(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100389570(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1003895B0()
{
}

void *sub_1003895BC(void *a1)
{
  *a1 = off_1019C1A58;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100389608(void *a1)
{
  *a1 = off_1019C1A58;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100389674(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019C1A58;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1003896D8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019C1A58;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100389718(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100389728(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100389768(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[2])
      {
        uint64_t v7 = *(void *)(v5 + 8);
        if (v4) {
          sub_1005C7000(*(void *)(v5 + 8));
        }
        uint64_t v8 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          buf[0] = 136315138;
          *(void *)&buf[1] = "[BB:kActivating]";
          _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%s Failed to transfer config file", (uint8_t *)buf, 0xCu);
          uint64_t v7 = *(void *)(v5 + 8);
        }
        sub_100384CFC(v7, 3u);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100389A2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, ...)
{
  va_start(va, a5);
  sub_10038A13C((uint64_t *)va);
  sub_10004D2C8(a5);
  _Unwind_Resume(a1);
}

uint64_t sub_100389A84(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100389AC4()
{
}

void *sub_100389AD0(void *a1)
{
  *a1 = off_1019C1AC8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100389B1C(void *a1)
{
  *a1 = off_1019C1AC8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100389B88(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019C1AC8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100389BEC(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019C1AC8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100389C2C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100389C3C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100389C7C(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  int v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    int v6 = *a2;
    uint64_t v7 = a1[1];
    uint64_t v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      if (a1[2])
      {
        uint64_t v9 = *(void *)(v7 + 8);
        if (v6)
        {
          sub_1005C48CC(*(void *)(v7 + 8));
          if (*(unsigned char *)(a3 + 8))
          {
            if (*(void *)a3) {
              sub_1005CA5A0(*(void *)(v7 + 8), a3);
            }
          }
          sub_100389E0C(*(void *)(v7 + 8));
        }
        uint64_t v10 = *(NSObject **)(v9 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          int v11 = 136315138;
          uint64_t v12 = "[BB:kActivating]";
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%s Failed to activate", (uint8_t *)&v11, 0xCu);
          uint64_t v9 = *(void *)(v7 + 8);
        }
        sub_100384CFC(v9, 3u);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_100389DAC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100389DC0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100389E00()
{
}

void sub_100389E0C(uint64_t a1)
{
}

void sub_10038A0E0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void *sub_10038A13C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10038A1C0(void *a1)
{
  *a1 = off_1019C1B58;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10038A20C(void *a1)
{
  *a1 = off_1019C1B58;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_10038A278(void *a1)
{
  uint64_t result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  void *result = off_1019C1B58;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *sub_10038A2DC(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_1019C1B58;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void sub_10038A31C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10038A32C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10038A36C(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[3];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[1])
      {
        uint64_t v8 = *(void *)(v5 + 8);
        uint64_t v9 = *(NSObject **)(v8 + 40);
        if (!v4)
        {
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            int v10 = 136315138;
            int v11 = "[BB:kActive]";
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%s [Registration] Failed to initiate registration", (uint8_t *)&v10, 0xCu);
            uint64_t v8 = *(void *)(v5 + 8);
          }
          sub_100384F68(v8, 3u);
        }
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = 136315138;
          int v11 = "[BB:kActive]";
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s [Registration] Succesfully asked BB to initate registration", (uint8_t *)&v10, 0xCu);
          uint64_t v8 = *(void *)(v5 + 8);
        }
        *(unsigned char *)(v5 + 50) = 0;
        *(unsigned char *)(v8 + 316) = 1;
        sub_100385F40(v5);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10038A4D0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10038A4E4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10038A524()
{
}

void *sub_10038A530(void *a1)
{
  *a1 = off_1019C1BD8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10038A57C(void *a1)
{
  *a1 = off_1019C1BD8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10038A5E8(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019C1BD8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10038A64C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019C1BD8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10038A68C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10038A69C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10038A6DC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[2]) {
        *(unsigned char *)(v3 + 48) = 0;
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_10038A738(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10038A778()
{
}

void sub_10038A788()
{
}

void *sub_10038A79C()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019C1C58;
  return result;
}

void sub_10038A7D4(uint64_t a1, void *a2)
{
  *a2 = off_1019C1C58;
}

uint64_t sub_10038A800(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10038A840()
{
}

void *sub_10038A84C(void *a1)
{
  *a1 = off_1019C1CD8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10038A898(void *a1)
{
  *a1 = off_1019C1CD8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10038A904(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019C1CD8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10038A968(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019C1CD8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10038A9A8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10038A9B8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10038A9F8(void *a1, uint64_t *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    uint64_t v5 = a1[1];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[2])
      {
        uint64_t v8 = *(void *)(v5 + 8);
        uint64_t v10 = *a2;
        uint64_t v9 = a2[1];
        if (v9) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
        }
        int v11 = *(std::__shared_weak_count **)(v8 + 272);
        *(void *)(v8 + 264) = v10;
        *(void *)(v8 + 272) = v9;
        if (v11) {
          sub_10004D2C8(v11);
        }
        if (!*a2)
        {
          uint64_t v12 = *(void *)(v5 + 8);
          uint64_t v13 = *(NSObject **)(v12 + 40);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          {
            int v14 = 136315138;
            uint64_t v15 = "[BB:kActive]";
            _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%s Failed to get provisioning data", (uint8_t *)&v14, 0xCu);
            uint64_t v12 = *(void *)(v5 + 8);
          }
          sub_100384F68(v12, 4u);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10038AB50(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10038AB64(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10038ABA4()
{
}

void *sub_10038ABB0(void *a1)
{
  *a1 = off_1019C1D58;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10038ABFC(void *a1)
{
  *a1 = off_1019C1D58;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10038AC68(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019C1D58;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10038ACCC(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019C1D58;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10038AD0C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10038AD1C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10038AD5C(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = (void *)a1[1];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[2])
      {
        uint64_t v8 = v5[1];
        if (!v4)
        {
          uint64_t v9 = *(NSObject **)(v8 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            int v10 = 136315138;
            int v11 = "[BB:kSuspending]";
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%s Failed to suspend", (uint8_t *)&v10, 0xCu);
            uint64_t v8 = v5[1];
          }
          sub_100384F68(v8, 3u);
        }
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v8 + 24));
        (***(void (****)(void, void))(v8 + 432))(*(void *)(v8 + 432), 0);
        sub_100386ADC(v5);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10038AE94(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10038AEA8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10038AEE8()
{
}

void sub_10038AEF8()
{
}

void *sub_10038AF0C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019C1DD8;
  result[1] = v3;
  return result;
}

uint64_t sub_10038AF54(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019C1DD8;
  a2[1] = v2;
  return result;
}

uint64_t sub_10038AF80(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v2 = (std::__shared_weak_count *)v1[3];
  v1[2] = 0;
  v1[3] = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v1 + 24);

  return v3(v1, 1);
}

uint64_t sub_10038AFE8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10038B028()
{
}

void *sub_10038B034(void *a1)
{
  *a1 = off_1019C1E58;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10038B080(void *a1)
{
  *a1 = off_1019C1E58;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10038B0EC(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019C1E58;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10038B150(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019C1E58;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10038B190(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10038B1A0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10038B1E0(void *a1, uint64_t *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    uint64_t v5 = a1[1];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[2])
      {
        uint64_t v8 = *a2;
        if (!*a2)
        {
          uint64_t v17 = *(void *)(v5 + 8);
          uint64_t v18 = *(NSObject **)(v17 + 40);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            int v19 = 136315138;
            uint64_t v20 = "[BB:kResuming]";
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%s Failed to get provisioning data", (uint8_t *)&v19, 0xCu);
            uint64_t v17 = *(void *)(v5 + 8);
          }
          sub_100384F68(v17, 4u);
        }
        uint64_t v9 = a2[1];
        if (v9) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
        }
        int v10 = *(std::__shared_weak_count **)(v5 + 96);
        *(void *)(v5 + 88) = v8;
        *(void *)(v5 + 96) = v9;
        if (v10) {
          sub_10004D2C8(v10);
        }
        uint64_t v11 = *(void *)(v5 + 8);
        uint64_t v13 = *a2;
        uint64_t v12 = a2[1];
        if (v12) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
        }
        int v14 = *(std::__shared_weak_count **)(v11 + 272);
        *(void *)(v11 + 264) = v13;
        *(void *)(v11 + 272) = v12;
        if (v14) {
          sub_10004D2C8(v14);
        }
        uint64_t v15 = *(void *)(v5 + 8);
        uint64_t v16 = *(NSObject **)(v15 + 40);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          int v19 = 136315138;
          uint64_t v20 = "[BB:kResuming]";
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s Resume package ready", (uint8_t *)&v19, 0xCu);
          uint64_t v15 = *(void *)(v5 + 8);
        }
        *(unsigned char *)(v5 + 49) = 1;
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v15 + 24));
        (***(void (****)(void, uint64_t))(v15 + 432))(*(void *)(v15 + 432), 1);
        sub_1003877A8(v5);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10038B400(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10038B414(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10038B454()
{
}

void *sub_10038B460(void *a1)
{
  *a1 = off_1019C1ED8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10038B4AC(void *a1)
{
  *a1 = off_1019C1ED8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10038B518(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019C1ED8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10038B57C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019C1ED8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10038B5BC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10038B5CC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10038B60C(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[2])
      {
        uint64_t v7 = *(void *)(v5 + 8);
        if (v4) {
          sub_100389E0C(*(void *)(v5 + 8));
        }
        uint64_t v8 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          int v9 = 136315138;
          int v10 = "[BB:kResuming]";
          _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%s Failed to resume", (uint8_t *)&v9, 0xCu);
          uint64_t v7 = *(void *)(v5 + 8);
        }
        sub_100384F68(v7, 3u);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10038B714(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10038B728(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10038B768()
{
}

void *sub_10038B774(void *a1)
{
  *a1 = off_1019C1F58;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10038B7C0(void *a1)
{
  *a1 = off_1019C1F58;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10038B82C(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019C1F58;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10038B890(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019C1F58;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10038B8D0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10038B8E0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10038B920(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[2])
      {
        uint64_t v8 = *(void *)(v5 + 8);
        int v9 = *(NSObject **)(v8 + 40);
        if (!v4)
        {
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            int v10 = 136315138;
            uint64_t v11 = "[BB:kDeactivating]";
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%s Deactivate request failed: Not going to wait for BB to send deactivation complete", (uint8_t *)&v10, 0xCu);
            uint64_t v8 = *(void *)(v5 + 8);
          }
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v8 + 24));
          (***(void (****)(void, void))(v8 + 432))(*(void *)(v8 + 432), 0);
          sub_100385D1C(*(void *)(v5 + 8));
        }
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = 136315138;
          uint64_t v11 = "[BB:kDeactivating]";
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s Waiting for BB to send deactivation complete", (uint8_t *)&v10, 0xCu);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10038BA98(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10038BAAC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10038BAEC()
{
}

void sub_10038BAF8(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = (long long *)*a1;
  if (*a1)
  {
    if (*((char *)v2 + 55) < 0) {
      sub_10004FC84(&__dst, *((void **)v2 + 4), *((void *)v2 + 5));
    }
    else {
      std::string __dst = *(std::string *)(v2 + 2);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = __dst;
    }
    uint64_t v17 = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v19, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string v19 = __p;
    }
    uint64_t v20 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v5 = v17;
      uint64_t v17 = v20;
      uint64_t v21 = v5;
      sub_1000558F4(&v21);
    }
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v19.__r_.__value_.__l.__data_);
    }
    std::string::size_type v16 = (std::string::size_type)v17;
    uint64_t v17 = 0;
    sub_1000558F4(&v17);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (&v16 != (std::string::size_type *)a2)
    {
      v19.__r_.__value_.__r.__words[0] = *(void *)a2;
      *(void *)a2 = v16;
      std::string::size_type v16 = 0;
      sub_1000558F4((const void **)&v19.__r_.__value_.__l.__data_);
    }
    sub_1000558F4((const void **)&v16);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    int v6 = (long long *)*a1;
    *(unsigned char *)(a2 + 8) = *(unsigned char *)(*a1 + 56);
    if (*((char *)v6 + 23) < 0)
    {
      sub_10004FC84(&v14, *(void **)v6, *((void *)v6 + 1));
    }
    else
    {
      long long v7 = *v6;
      v14.__r_.__value_.__r.__words[2] = *((void *)v6 + 2);
      *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v7;
    }
    if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__p, v14.__r_.__value_.__l.__data_, v14.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v14;
    }
    uint64_t v17 = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v19, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string v19 = __p;
    }
    uint64_t v20 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v8 = v17;
      uint64_t v17 = v20;
      uint64_t v21 = v8;
      sub_1000558F4(&v21);
    }
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v19.__r_.__value_.__l.__data_);
    }
    std::string::size_type v16 = (std::string::size_type)v17;
    uint64_t v17 = 0;
    sub_1000558F4(&v17);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    int v9 = (std::string::size_type *)(a2 + 16);
    if ((std::string::size_type *)(a2 + 16) != &v16)
    {
      v19.__r_.__value_.__r.__words[0] = *v9;
      std::string::size_type *v9 = v16;
      std::string::size_type v16 = 0;
      sub_1000558F4((const void **)&v19.__r_.__value_.__l.__data_);
    }
    sub_1000558F4((const void **)&v16);
    if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v14.__r_.__value_.__l.__data_);
    }
    std::to_string(&v13, *(_DWORD *)(*a1 + 24));
    if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__p, v13.__r_.__value_.__l.__data_, v13.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v13;
    }
    uint64_t v17 = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v19, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string v19 = __p;
    }
    uint64_t v20 = 0;
    if (ctu::cf::convert_copy())
    {
      int v10 = v17;
      uint64_t v17 = v20;
      uint64_t v21 = v10;
      sub_1000558F4(&v21);
    }
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v19.__r_.__value_.__l.__data_);
    }
    std::string::size_type v11 = (std::string::size_type)v17;
    std::string::size_type v16 = (std::string::size_type)v17;
    uint64_t v17 = 0;
    sub_1000558F4(&v17);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    uint64_t v12 = (std::string::size_type *)(a2 + 24);
    if ((std::string::size_type *)(a2 + 24) != &v16)
    {
      v19.__r_.__value_.__r.__words[0] = *v12;
      std::string::size_type *v12 = v11;
      std::string::size_type v16 = 0;
      sub_1000558F4((const void **)&v19.__r_.__value_.__l.__data_);
    }
    sub_1000558F4((const void **)&v16);
    if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v13.__r_.__value_.__l.__data_);
    }
  }
}

void sub_10038BEA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,const void *a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10038BF94(uint64_t a1)
{
  *(void *)a1 = off_1019C2080;
  std::mutex::~mutex((std::mutex *)(a1 + 160));
  uint64_t v2 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 104);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 112);
    uint64_t v5 = *(void **)(a1 + 104);
    if (v4 != v3)
    {
      do
      {
        v4 -= 32;
        sub_100390F8C(v4);
      }
      while (v4 != v3);
      uint64_t v5 = *(void **)(a1 + 104);
    }
    *(void *)(a1 + 112) = v3;
    operator delete(v5);
  }
  int v6 = *(const void ***)(a1 + 80);
  if (v6)
  {
    long long v7 = *(const void ***)(a1 + 88);
    uint64_t v8 = *(void **)(a1 + 80);
    if (v7 != v6)
    {
      do
        long long v7 = sub_100391094((uint64_t)(v7 - 5));
      while (v7 != v6);
      uint64_t v8 = *(void **)(a1 + 80);
    }
    *(void *)(a1 + 88) = v6;
    operator delete(v8);
  }
  int v9 = *(std::__shared_weak_count **)(a1 + 72);
  if (v9) {
    sub_10004D2C8(v9);
  }
  int v10 = *(std::__shared_weak_count **)(a1 + 56);
  if (v10) {
    sub_10004D2C8(v10);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_10038C0B0(uint64_t a1)
{
  sub_10038BF94(a1);

  operator delete();
}

void sub_10038C0E8(uint64_t a1, int a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  _OWORD v4[2] = sub_10038C1FC;
  v4[3] = &unk_1019C2118;
  void v4[4] = a1;
  int v5 = a2;
  uint64_t v8 = 0;
  int v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100391108;
  block[3] = &unk_1019C2600;
  void block[5] = v8;
  long long v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_10038C1FC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(long long **)(v1 + 104);
  uint64_t v3 = *(long long **)(v1 + 112);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  std::string::size_type v16 = (BOOL (*)(uint64_t, long long *))sub_10038C4B8;
  uint64_t v17 = &unk_1019C20F8;
  int v18 = *(_DWORD *)(a1 + 40);
  if (v2 == v3) {
    goto LABEL_25;
  }
  uint64_t v4 = v3;
  while (1)
  {
    long long v19 = *v2;
    sub_100083DA4(&v20, (const void **)v2 + 2);
    int v5 = (void *)*((void *)v2 + 3);
    if (v5) {
      int v5 = _Block_copy(v5);
    }
    aBlock = v5;
    BOOL v6 = v16((uint64_t)v15, &v19);
    if (aBlock) {
      _Block_release(aBlock);
    }
    sub_1000558F4(&v20);
    if (v6) {
      break;
    }
    v2 += 2;
    if (v2 == v3) {
      goto LABEL_26;
    }
  }
  if (v2 != v3)
  {
    long long v7 = v2 + 2;
    if (v2 + 2 != v3)
    {
      uint64_t v4 = v2;
      do
      {
        long long v19 = *v7;
        uint64_t v8 = v7 + 1;
        sub_100083DA4(&v20, (const void **)v7 + 2);
        int v9 = (void *)*((void *)v7 + 3);
        if (v9) {
          int v9 = _Block_copy(v9);
        }
        aBlock = v9;
        BOOL v10 = v16((uint64_t)v15, &v19);
        if (aBlock) {
          _Block_release(aBlock);
        }
        sub_1000558F4(&v20);
        if (!v10)
        {
          *uint64_t v4 = *v7;
          if (v7 != v4)
          {
            std::string::size_type v11 = (const void *)*((void *)v4 + 2);
            *((void *)v4 + 2) = 0;
            uint64_t v22 = v11;
            *((void *)v4 + 2) = *v8;
            void *v8 = 0;
            sub_1000558F4(&v22);
          }
          uint64_t v12 = *((void *)v7 + 3);
          *((void *)v7 + 3) = 0;
          std::string v13 = (const void *)*((void *)v4 + 3);
          *((void *)v4 + 3) = v12;
          if (v13) {
            _Block_release(v13);
          }
          v4 += 2;
        }
        v7 += 2;
      }
      while (v7 != v3);
      goto LABEL_26;
    }
LABEL_25:
    uint64_t v4 = v2;
  }
LABEL_26:
  uint64_t v14 = *(void *)(v1 + 112);
  if (v4 != (long long *)v14)
  {
    while ((long long *)v14 != v4)
    {
      v14 -= 32;
      sub_100390F8C(v14);
    }
    *(void *)(v1 + 112) = v4;
  }
}

void sub_10038C480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, const void *a17, const void *a18)
{
  if (a18) {
    _Block_release(a18);
  }
  sub_1000558F4(&a17);
  _Unwind_Resume(a1);
}

BOOL sub_10038C4B8(uint64_t a1, _DWORD *a2)
{
  return *a2 == *(_DWORD *)(a1 + 32);
}

void sub_10038C4CC(uint64_t a1, uint64_t a2)
{
  long long v8 = 0u;
  long long v9 = 0u;
  if (&v8 == (long long *)a2)
  {
    *(unsigned char *)(a2 + 8) = 0;
  }
  else
  {
    BOOL v10 = *(const void **)a2;
    *(void *)a2 = 0;
    *(void *)&long long v8 = 0;
    uint64_t v4 = sub_1000558F4(&v10);
    *(unsigned char *)(a2 + 8) = BYTE8(v8);
    BOOL v10 = *(const void **)(a2 + 16);
    *(void *)(a2 + 16) = v9;
    *(void *)&long long v9 = 0;
    int v5 = sub_1000558F4(v4);
    BOOL v10 = *(const void **)(a2 + 24);
    *(void *)(a2 + 24) = *((void *)&v9 + 1);
    *((void *)&v9 + 1) = 0;
    sub_1000558F4(v5);
  }
  sub_1000558F4((const void **)&v9 + 1);
  sub_1000558F4((const void **)&v9);
  sub_1000558F4((const void **)&v8);
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 64) + 120))(&v6);
  sub_10038BAF8(&v6, a2);
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_10038C5D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10038C5E8(const void **a1)
{
  sub_1000558F4(a1 + 3);
  sub_1000558F4(a1 + 2);

  return sub_1000558F4(a1);
}

void sub_10038C62C(uint64_t a1)
{
  std::mutex::lock((std::mutex *)(a1 + 160));
  ++*(_DWORD *)(a1 + 128);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    if (std::__shared_weak_count::lock(v2)) {
      sub_101364A38(&v3);
    }
  }
  sub_100088B9C();
}

void sub_10038C6C8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_10038C6EC(CFMutableDictionaryRef *a1, const void *a2, const void *a3, const void *a4)
{
  *a1 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  long long v9 = Mutable;
  if (Mutable)
  {
    *a1 = Mutable;
    BOOL v10 = 0;
    sub_10005717C(&v10);
  }
  CFDictionaryAddValue(v9, @"tid", a2);
  if (a3) {
    CFDictionaryAddValue(v9, @"subscriber-topic", a3);
  }
  if (a4) {
    CFDictionaryAddValue(v9, @"payload", a4);
  }
}

void sub_10038C7B4(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

const void **sub_10038C7C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v15 = 0;
  if (a5) {
    long long v8 = sub_1000FCC20;
  }
  else {
    long long v8 = 0;
  }
  if (v8) {
    (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 64) + 112))(&v14);
  }
  else {
    (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 64) + 88))(&v14);
  }
  long long v9 = v15;
  uint64_t v15 = v14;
  *(void *)long long buf = v9;
  uint64_t v14 = 0;
  sub_1000558F4((const void **)buf);
  sub_1000558F4(&v14);
  BOOL v10 = v15;
  if (v15) {
    std::string::size_type v11 = sub_1000810B8;
  }
  else {
    std::string::size_type v11 = 0;
  }
  if (!v11)
  {
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#E Send message failed directly!", buf, 2u);
      BOOL v10 = v15;
    }
    (*(void (**)(uint64_t, const void *, void, uint64_t))(a6 + 16))(a6, v10, 0, 57);
  }
  return sub_1000558F4(&v15);
}

void sub_10038C940(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_10038C95C(uint64_t a1, uint64_t a2, char a3, int a4)
{
  int v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    long long v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      BOOL v10 = v9;
      if (*(void *)(a1 + 48))
      {
        if (a3)
        {
          memset(buf, 0, 32);
          Registry::getTimerService((uint64_t *)&v35, *(Registry **)(v8 + 48));
          *(void *)&uint8_t buf[8] = (**v35)(v35);
          if (v36) {
            sub_10004D2C8(v36);
          }
          *(_DWORD *)long long buf = *(_DWORD *)(*(void *)(a1 + 72) + 8);
          sub_100083EB8((const void **)&buf[16], (const void **)(a1 + 64));
          std::string::size_type v11 = *(void **)(a1 + 32);
          if (v11) {
            std::string::size_type v11 = _Block_copy(v11);
          }
          uint64_t v12 = *(const void **)&buf[24];
          *(void *)&uint8_t buf[24] = v11;
          if (v12) {
            _Block_release(v12);
          }
          unint64_t v13 = *(void *)(v8 + 112);
          unint64_t v14 = *(void *)(v8 + 120);
          if (v13 >= v14)
          {
            uint64_t v22 = *(void *)(v8 + 104);
            uint64_t v23 = (uint64_t)(v13 - v22) >> 5;
            if ((unint64_t)(v23 + 1) >> 59) {
              sub_10006A748();
            }
            uint64_t v24 = v14 - v22;
            uint64_t v25 = v24 >> 4;
            if (v24 >> 4 <= (unint64_t)(v23 + 1)) {
              uint64_t v25 = v23 + 1;
            }
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v26 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v26 = v25;
            }
            if (v26)
            {
              if (v26 >> 59) {
                sub_10006A7CC();
              }
              uint64_t v27 = (char *)operator new(32 * v26);
            }
            else
            {
              uint64_t v27 = 0;
            }
            uint64_t v28 = &v27[32 * v26];
            uint64_t v29 = sub_100390FD0((uint64_t)&v27[32 * v23], (uint64_t)buf);
            uint64_t v15 = v29 + 32;
            uint64_t v30 = *(char **)(v8 + 104);
            uint64_t v31 = *(char **)(v8 + 112);
            if (v31 == v30)
            {
              *(void *)(v8 + 104) = v29;
              *(void *)(v8 + 112) = v15;
              *(void *)(v8 + 120) = v28;
            }
            else
            {
              do
              {
                *(_OWORD *)(v29 - 32) = *((_OWORD *)v31 - 2);
                *(void *)(v29 - 16) = 0;
                *(_OWORD *)(v29 - 16) = *((_OWORD *)v31 - 1);
                v29 -= 32;
                *((void *)v31 - 2) = 0;
                *((void *)v31 - 1) = 0;
                v31 -= 32;
              }
              while (v31 != v30);
              uint64_t v31 = *(char **)(v8 + 104);
              uint64_t v32 = *(void *)(v8 + 112);
              *(void *)(v8 + 104) = v29;
              *(void *)(v8 + 112) = v15;
              *(void *)(v8 + 120) = v28;
              while ((char *)v32 != v31)
              {
                v32 -= 32;
                sub_100390F8C(v32);
              }
            }
            if (v31) {
              operator delete(v31);
            }
          }
          else
          {
            uint64_t v15 = sub_100390FD0(v13, (uint64_t)buf) + 32;
          }
          *(void *)(v8 + 112) = v15;
          if (*(void *)&buf[24]) {
            _Block_release(*(const void **)&buf[24]);
          }
          uint64_t v21 = (const void **)&buf[16];
        }
        else
        {
          std::string::size_type v16 = *(NSObject **)(v8 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            CStringPtr = CFStringGetCStringPtr(*(CFStringRef *)(a1 + 64), 0x8000100u);
            int v34 = *(_DWORD *)(*(void *)(a1 + 72) + 8);
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = CStringPtr;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v34;
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Send request failed IDS Ack with device id: %s and transaction id: %d", buf, 0x12u);
          }
          uint64_t v17 = *(void *)(a1 + 32);
          sub_100083DA4(&v39, (const void **)(a1 + 64));
          uint64_t v37 = 0;
          CFStringRef v38 = 0;
          if (a4 == 57) {
            int v18 = 2;
          }
          else {
            int v18 = 1;
          }
          if (a4 == 94) {
            unsigned int v19 = 4;
          }
          else {
            unsigned int v19 = v18;
          }
          if (a4) {
            uint64_t v20 = v19;
          }
          else {
            uint64_t v20 = 0;
          }
          (*(void (**)(uint64_t, const void **, const void **, uint64_t))(v17 + 16))(v17, &v39, &v37, v20);
          sub_1000FE824(&v38);
          sub_1000577C4(&v37);
          uint64_t v21 = &v39;
        }
        sub_1000558F4(v21);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_10038CC88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10038CCFC(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    _Block_release(v2);
  }
  sub_1000558F4((const void **)(a1 + 16));
  return a1;
}

const void **sub_10038CD38(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = sub_100083DA4((const void **)(a1 + 64), (const void **)(a2 + 64));
  uint64_t v6 = *(void *)(a2 + 80);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a1 + 80) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10038CD98(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 64);
  long long v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1000558F4(v2);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_10038CDF4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    long long v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      if (*(void *)(a1 + 48))
      {
        if (a3)
        {
          uint64_t v9 = *(void *)(a1 + 32);
          BOOL v10 = (const void **)(a1 + 64);
          std::string::size_type v11 = &v18;
          sub_100083DA4(&v18, v10);
          (*(void (**)(uint64_t, const void **, void))(v9 + 16))(v9, &v18, 0);
        }
        else
        {
          uint64_t v12 = *(NSObject **)(v6 + 40);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            CStringPtr = CFStringGetCStringPtr(*(CFStringRef *)(a1 + 64), 0x8000100u);
            int v16 = *(_DWORD *)(*(void *)(a1 + 72) + 8);
            *(_DWORD *)long long buf = 136315394;
            uint64_t v20 = CStringPtr;
            __int16 v21 = 1024;
            int v22 = v16;
            _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Send indication failed IDS Ack with device id: %s and transaction id: %d", buf, 0x12u);
          }
          uint64_t v13 = *(void *)(a1 + 32);
          unint64_t v14 = (const void **)(a1 + 64);
          std::string::size_type v11 = &v17;
          sub_100083DA4(&v17, v14);
          (*(void (**)(uint64_t, const void **, uint64_t))(v13 + 16))(v13, &v17, 1);
        }
        sub_1000558F4(v11);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10038CF54(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

const void **sub_10038CF84(uint64_t a1, uint64_t *a2, const void **a3, CFTypeRef cf, const void **a5, uint64_t a6)
{
  int v22 = cf;
  if (cf) {
    CFRetain(cf);
  }
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 1174405120;
  v16[2] = sub_10038D178;
  void v16[3] = &unk_1019C21B0;
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  v16[5] = a1;
  v16[6] = v13;
  uint64_t v17 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100083DA4(&v18, a3);
  unsigned int v19 = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_1000584C8(&v20, a5);
  sub_100119B5C(&v21, a5 + 1);
  v16[4] = a6;
  uint64_t v25 = 0;
  unint64_t v26 = 0;
  sub_10003E168(&v25, (void *)(a1 + 8));
  unint64_t v14 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100391108;
  block[3] = &unk_1019C2600;
  void block[5] = v25;
  uint64_t v24 = v26;
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v16;
  dispatch_async(v14, block);
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (v26) {
    sub_10004D2C8(v26);
  }
  sub_1000FE824(&v21);
  sub_1000577C4(&v20);
  sub_1000558F4(&v19);
  sub_1000558F4(&v18);
  if (v17) {
    sub_10004D2C8(v17);
  }
  return sub_1000558F4(&v22);
}

void sub_10038D178(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  long long v3 = *(unsigned int **)(a1 + 48);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100083DA4(&cf, (const void **)(a1 + 64));
  int v5 = *(const void **)(a1 + 72);
  sub_1000584C8(&v17, (const void **)(a1 + 80));
  sub_100119B5C(&v18, (const void **)(a1 + 88));
  uint64_t v6 = *(void *)(a1 + 32);
  if (v3)
  {
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v31 = 0;
    CFNumberRef v32 = 0;
    valuePtr[0] = (const void *)v3[2];
    CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, valuePtr);
    if (v7)
    {
      CFNumberRef v8 = v32;
      CFNumberRef v32 = v7;
      valuePtr[0] = v8;
      sub_1000570E8(valuePtr);
    }
    CFNumberRef v9 = v32;
    CFNumberRef v30 = v32;
    CFNumberRef v32 = 0;
    sub_1000570E8((const void **)&v32);
    sub_10038C6EC((CFMutableDictionaryRef *)&v31, v9, v5, v17);
    sub_1000570E8((const void **)&v30);
    BOOL v10 = (std::__shared_weak_count *)v2[2];
    if (!v10 || (uint64_t v11 = v2[1], (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v13 = v12;
    p_shared_weak_owners = &v12->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v12);
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 1174405120;
    _OWORD v26[2] = sub_10038C95C;
    v26[3] = &unk_1019C2140;
    v26[5] = v2;
    v26[6] = v11;
    uint64_t v27 = v13;
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    v28[0] = cf;
    if (cf) {
      CFRetain(cf);
    }
    v28[1] = v3;
    uint64_t v29 = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v26[4] = v6;
    CFTypeRef v25 = cf;
    if (cf) {
      CFRetain(cf);
    }
    sub_10004EFE4(&v24, &v31);
    CFTypeRef v15 = v18;
    CFTypeRef v23 = v18;
    if (v18) {
      CFRetain(v18);
    }
    sub_10038C7C8((uint64_t)v2, @"ITM-req", (uint64_t)v25, v24, (uint64_t)v15, (uint64_t)v26);
    sub_1000FE824(&v23);
    sub_100057D78((const void **)&v24);
    sub_1000558F4(&v25);
    if (v29) {
      sub_10004D2C8(v29);
    }
    sub_1000558F4(v28);
    if (v27) {
      std::__shared_weak_count::__release_weak(v27);
    }
    std::__shared_weak_count::__release_weak(v13);
    sub_10005717C(&v31);
    if (!v4)
    {
      sub_1000FE824(&v18);
      sub_1000577C4(&v17);
      sub_1000558F4(&cf);
      return;
    }
    sub_10004D2C8(v4);
  }
  else
  {
    int v16 = v2[5];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(valuePtr[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#E missing transaction id", (uint8_t *)valuePtr, 2u);
    }
    CFTypeRef v22 = cf;
    if (cf) {
      CFRetain(cf);
    }
    uint64_t v20 = 0;
    __int16 v21 = 0;
    (*(void (**)(uint64_t, CFTypeRef *, const void **, uint64_t))(v6 + 16))(v6, &v22, &v20, 4);
    sub_1000FE824(&v21);
    sub_1000577C4(&v20);
    sub_1000558F4(&v22);
  }
  sub_1000FE824(&v18);
  sub_1000577C4(&v17);
  sub_1000558F4(&cf);
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_10038D4A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, const void *a12, const void *a13, uint64_t a14, const void *a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,std::__shared_weak_count *a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
  sub_1000FE824(v39);
  sub_1000577C4(&a13);
  sub_1000558F4(&a15);
  sub_1000FE824(v38);
  sub_1000577C4(&a10);
  sub_1000558F4(&a12);
  if (v37) {
    sub_10004D2C8(v37);
  }
  _Unwind_Resume(a1);
}

const void **sub_10038D584(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100083DA4((const void **)(a1 + 64), (const void **)(a2 + 64));
  sub_100083DA4((const void **)(a1 + 72), (const void **)(a2 + 72));
  sub_1000584C8((const void **)(a1 + 80), (const void **)(a2 + 80));

  return sub_100119B5C((const void **)(a1 + 88), (const void **)(a2 + 88));
}

void sub_10038D5FC(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 64);
  long long v3 = (const void **)(a1 + 72);
  uint64_t v4 = (const void **)(a1 + 80);
  sub_1000FE824((const void **)(a1 + 88));
  sub_1000577C4(v4);
  sub_1000558F4(v3);
  sub_1000558F4(v2);
  int v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5)
  {
    sub_10004D2C8(v5);
  }
}

const void **sub_10038D678(uint64_t a1, uint64_t *a2, const void **a3, CFTypeRef cf, const void **a5, uint64_t a6)
{
  CFTypeRef v22 = cf;
  if (cf) {
    CFRetain(cf);
  }
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 1174405120;
  v16[2] = sub_10038D86C;
  void v16[3] = &unk_1019C21E8;
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  v16[5] = a1;
  v16[6] = v13;
  uint64_t v17 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100083DA4(&v18, a3);
  unsigned int v19 = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_1000584C8(&v20, a5);
  sub_100119B5C(&v21, a5 + 1);
  v16[4] = a6;
  uint64_t v25 = 0;
  unint64_t v26 = 0;
  sub_10003E168(&v25, (void *)(a1 + 8));
  unint64_t v14 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100391108;
  block[3] = &unk_1019C2600;
  void block[5] = v25;
  uint64_t v24 = v26;
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v16;
  dispatch_async(v14, block);
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (v26) {
    sub_10004D2C8(v26);
  }
  sub_1000FE824(&v21);
  sub_1000577C4(&v20);
  sub_1000558F4(&v19);
  sub_1000558F4(&v18);
  if (v17) {
    sub_10004D2C8(v17);
  }
  return sub_1000558F4(&v22);
}

void sub_10038D86C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  long long v3 = *(unsigned int **)(a1 + 48);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100083DA4(&cf, (const void **)(a1 + 64));
  int v5 = *(const void **)(a1 + 72);
  sub_1000584C8(&v17, (const void **)(a1 + 80));
  sub_100119B5C(&v18, (const void **)(a1 + 88));
  uint64_t v6 = *(void *)(a1 + 32);
  if (v3)
  {
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v29 = 0;
    CFNumberRef v30 = 0;
    valuePtr[0] = (const void *)v3[2];
    CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, valuePtr);
    if (v7)
    {
      CFNumberRef v8 = v30;
      CFNumberRef v30 = v7;
      valuePtr[0] = v8;
      sub_1000570E8(valuePtr);
    }
    CFNumberRef v9 = v30;
    CFNumberRef v28 = v30;
    CFNumberRef v30 = 0;
    sub_1000570E8((const void **)&v30);
    sub_10038C6EC((CFMutableDictionaryRef *)&v29, v9, v5, v17);
    sub_1000570E8((const void **)&v28);
    BOOL v10 = (std::__shared_weak_count *)v2[2];
    if (!v10 || (uint64_t v11 = v2[1], (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v13 = v12;
    p_shared_weak_owners = &v12->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v12);
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 1174405120;
    void v24[2] = sub_10038CDF4;
    v24[3] = &unk_1019C2178;
    v24[5] = v2;
    v24[6] = v11;
    uint64_t v25 = v13;
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    void v24[4] = v6;
    v26[0] = cf;
    if (cf) {
      CFRetain(cf);
    }
    v26[1] = v3;
    uint64_t v27 = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CFTypeRef v23 = cf;
    if (cf) {
      CFRetain(cf);
    }
    sub_10004EFE4(&v22, &v29);
    CFTypeRef v15 = v18;
    CFTypeRef v21 = v18;
    if (v18) {
      CFRetain(v18);
    }
    sub_10038C7C8((uint64_t)v2, @"ITM-ind", (uint64_t)v23, v22, (uint64_t)v15, (uint64_t)v24);
    sub_1000FE824(&v21);
    sub_100057D78((const void **)&v22);
    sub_1000558F4(&v23);
    if (v27) {
      sub_10004D2C8(v27);
    }
    sub_1000558F4(v26);
    if (v25) {
      std::__shared_weak_count::__release_weak(v25);
    }
    std::__shared_weak_count::__release_weak(v13);
    sub_10005717C(&v29);
    if (!v4)
    {
      sub_1000FE824(&v18);
      sub_1000577C4(&v17);
      sub_1000558F4(&cf);
      return;
    }
    sub_10004D2C8(v4);
  }
  else
  {
    int v16 = v2[5];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(valuePtr[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#E missing transaction id", (uint8_t *)valuePtr, 2u);
    }
    CFTypeRef v20 = cf;
    if (cf) {
      CFRetain(cf);
    }
    (*(void (**)(uint64_t, CFTypeRef *, uint64_t))(v6 + 16))(v6, &v20, 4);
    sub_1000558F4(&v20);
  }
  sub_1000FE824(&v18);
  sub_1000577C4(&v17);
  sub_1000558F4(&cf);
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_10038DB7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, const void *a12, const void *a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  sub_1000558F4(&a13);
  sub_1000FE824(v36);
  sub_1000577C4(&a10);
  sub_1000558F4(&a12);
  if (v35) {
    sub_10004D2C8(v35);
  }
  _Unwind_Resume(a1);
}

void sub_10038DC48(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = v1;
  v1[2] = 0x3802000000;
  v1[3] = sub_10038DE48;
  v1[5] = 0;
  v1[6] = 0;
  v1[4] = sub_10038DE58;
  sub_10038C62C(a1);
}

void sub_10038DE24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28)
{
  if (a28) {
    sub_10004D2C8(a28);
  }
  _Unwind_Resume(a1);
}

__n128 sub_10038DE48(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void sub_10038DE58(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_10038DE68(void *a1, const void **a2, const void **a3, uint64_t a4)
{
  int v5 = (std::__shared_weak_count *)a1[7];
  if (!v5) {
    return 0;
  }
  CFNumberRef v9 = std::__shared_weak_count::lock(v5);
  if (!v9) {
    return 0;
  }
  BOOL v10 = v9;
  if (a1[6])
  {
    uint64_t v11 = a1[4];
    sub_100083DA4(&v18, a2);
    sub_1000584C8(&v16, a3);
    sub_100119B5C(&v17, a3 + 1);
    uint64_t v12 = (*(uint64_t (**)(uint64_t, const void **, const void **, uint64_t))(v11 + 16))(v11, &v18, &v16, a4);
    sub_1000FE824(&v17);
    sub_1000577C4(&v16);
    sub_1000558F4(&v18);
    uint64_t v13 = *(void *)(a1[5] + 8);
    unint64_t v14 = *(std::__shared_weak_count **)(v13 + 48);
    *(void *)(v13 + 40) = 0;
    *(void *)(v13 + 48) = 0;
    if (v14) {
      sub_10004D2C8(v14);
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  sub_10004D2C8(v10);
  return v12;
}

void sub_10038DF64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  int v5 = va_arg(va1, const void *);
  uint64_t v7 = va_arg(va1, void);
  sub_1000FE824(v3);
  sub_1000577C4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10038DF90(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10038DFAC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10038DFBC(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = v1;
  v1[2] = 0x3802000000;
  v1[3] = sub_10038DE48;
  v1[5] = 0;
  v1[6] = 0;
  v1[4] = sub_10038DE58;
  sub_10038C62C(a1);
}

void sub_10038E198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28)
{
  if (a28) {
    sub_10004D2C8(a28);
  }
  _Unwind_Resume(a1);
}

void sub_10038E1BC(void *a1, const void **a2, uint64_t a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      CFNumberRef v8 = v7;
      if (a1[6])
      {
        uint64_t v9 = a1[4];
        sub_100083DA4(&v12, a2);
        (*(void (**)(uint64_t, const void **, uint64_t))(v9 + 16))(v9, &v12, a3);
        sub_1000558F4(&v12);
        uint64_t v10 = *(void *)(a1[5] + 8);
        uint64_t v11 = *(std::__shared_weak_count **)(v10 + 48);
        *(void *)(v10 + 40) = 0;
        *(void *)(v10 + 48) = 0;
        if (v11) {
          sub_10004D2C8(v11);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10038E268(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void sub_10038E284(uint64_t a1, const void **a2, uint64_t a3, const void **a4)
{
  sub_100083DA4(&v7, a2);
  sub_1000584C8(v6, a4);
  v6[1] = 0;
  sub_10038DC48(a1);
}

void sub_10038E318(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  sub_1000FE824(v2);
  sub_1000577C4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_10038E33C(uint64_t a1, uint64_t *a2, const void **a3, const void *a4, const void **a5, uint64_t a6)
{
  uint64_t v10 = (std::__shared_weak_count *)a2[1];
  v14[0] = *a2;
  v14[1] = (uint64_t)v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_100083DA4(&v13, a3);
    sub_1000584C8(&v11, a5);
    uint64_t v12 = 0;
    sub_10038CF84(a1, v14, &v13, a4, &v11, a6);
    sub_1000FE824(&v12);
    sub_1000577C4(&v11);
    sub_1000558F4(&v13);
    sub_10004D2C8(v10);
  }
  else
  {
    sub_100083DA4(&v13, a3);
    sub_1000584C8(&v11, a5);
    uint64_t v12 = 0;
    sub_10038CF84(a1, v14, &v13, a4, &v11, a6);
    sub_1000FE824(&v12);
    sub_1000577C4(&v11);
    sub_1000558F4(&v13);
  }
}

void sub_10038E454(uint64_t a1, const void **a2, uint64_t a3, const void **a4)
{
  sub_100083DA4(&v7, a2);
  sub_1000584C8(v6, a4);
  v6[1] = 0;
  sub_10038DFBC(a1);
}

void sub_10038E4E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  sub_1000FE824(v2);
  sub_1000577C4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_10038E50C(uint64_t a1, uint64_t *a2, const void **a3, const void *a4, const void **a5, uint64_t a6)
{
  uint64_t v10 = (std::__shared_weak_count *)a2[1];
  v14[0] = *a2;
  v14[1] = (uint64_t)v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_100083DA4(&v13, a3);
    sub_1000584C8(&v11, a5);
    uint64_t v12 = 0;
    sub_10038D678(a1, v14, &v13, a4, &v11, a6);
    sub_1000FE824(&v12);
    sub_1000577C4(&v11);
    sub_1000558F4(&v13);
    sub_10004D2C8(v10);
  }
  else
  {
    sub_100083DA4(&v13, a3);
    sub_1000584C8(&v11, a5);
    uint64_t v12 = 0;
    sub_10038D678(a1, v14, &v13, a4, &v11, a6);
    sub_1000FE824(&v12);
    sub_1000577C4(&v11);
    sub_1000558F4(&v13);
  }
}

const void **sub_10038E624(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v16 = cf;
  if (cf) {
    CFRetain(cf);
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 1174405120;
  uint64_t v14[2] = sub_10038E79C;
  void v14[3] = &unk_1019C22C0;
  char v14[8] = a1;
  CFTypeRef v15 = cf;
  if (cf) {
    CFRetain(cf);
  }
  _OWORD v14[4] = a3;
  void v14[5] = a4;
  v14[6] = a5;
  v14[7] = a6;
  uint64_t v19 = 0;
  CFTypeRef v20 = 0;
  sub_10003E168(&v19, (void *)(a1 + 8));
  uint64_t v12 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100391108;
  block[3] = &unk_1019C2600;
  void block[5] = v19;
  CFTypeRef v18 = v20;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v14;
  dispatch_async(v12, block);
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  sub_1000558F4(&v15);
  return sub_1000558F4(&v16);
}

const void **sub_10038E79C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  long long v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    HIDWORD(buf) = 0;
    *(void *)&long long v50 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = 0u;
    uint64_t v48 = 0;
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = __p;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Registering callbacks for %s", (uint8_t *)&buf, 0xCu);
    if (SHIBYTE(v48) < 0) {
      operator delete(__p[0]);
    }
  }
  long long v51 = 0;
  long long buf = 0u;
  long long v50 = 0u;
  sub_100083EB8((const void **)&buf, (const void **)(a1 + 72));
  uint64_t v4 = *(void **)(a1 + 32);
  if (v4) {
    uint64_t v4 = _Block_copy(v4);
  }
  int v5 = (const void *)*((void *)&buf + 1);
  *((void *)&buf + 1) = v4;
  if (v5) {
    _Block_release(v5);
  }
  uint64_t v6 = *(void **)(a1 + 40);
  if (v6) {
    uint64_t v6 = _Block_copy(v6);
  }
  uint64_t v7 = (const void *)v50;
  *(void *)&long long v50 = v6;
  if (v7) {
    _Block_release(v7);
  }
  CFNumberRef v8 = *(void **)(a1 + 48);
  if (v8) {
    CFNumberRef v8 = _Block_copy(v8);
  }
  uint64_t v9 = (const void *)*((void *)&v50 + 1);
  *((void *)&v50 + 1) = v8;
  if (v9) {
    _Block_release(v9);
  }
  uint64_t v10 = *(void **)(a1 + 56);
  if (v10) {
    uint64_t v10 = _Block_copy(v10);
  }
  uint64_t v11 = v51;
  long long v51 = v10;
  if (v11) {
    _Block_release(v11);
  }
  unint64_t v12 = *(void *)(v2 + 88);
  unint64_t v13 = *(void *)(v2 + 96);
  if (v12 >= v13)
  {
    uint64_t v15 = *(void *)(v2 + 80);
    unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v12 - v15) >> 3);
    if (v16 + 1 > 0x666666666666666) {
      sub_10006A748();
    }
    unint64_t v17 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v13 - v15) >> 3);
    uint64_t v18 = 2 * v17;
    if (2 * v17 <= v16 + 1) {
      uint64_t v18 = v16 + 1;
    }
    if (v17 >= 0x333333333333333) {
      unint64_t v19 = 0x666666666666666;
    }
    else {
      unint64_t v19 = v18;
    }
    if (v19)
    {
      if (v19 > 0x666666666666666) {
        sub_10006A7CC();
      }
      CFTypeRef v20 = (char *)operator new(40 * v19);
    }
    else
    {
      CFTypeRef v20 = 0;
    }
    CFTypeRef v21 = &v20[40 * v19];
    uint64_t v22 = sub_100391018((uint64_t)&v20[40 * v16], (uint64_t)&buf);
    uint64_t v14 = v22 + 40;
    CFTypeRef v23 = *(char **)(v2 + 80);
    uint64_t v24 = *(char **)(v2 + 88);
    if (v24 == v23)
    {
      *(void *)(v2 + 80) = v22;
      *(void *)(v2 + 88) = v14;
      *(void *)(v2 + 96) = v21;
    }
    else
    {
      uint64_t v25 = 0;
      do
      {
        uint64_t v26 = v22 + v25;
        uint64_t v27 = &v24[v25];
        *(void *)(v26 - 40) = 0;
        *(_OWORD *)(v26 - 40) = *(_OWORD *)&v24[v25 - 40];
        *(_OWORD *)(v27 - 40) = 0uLL;
        *(_OWORD *)(v26 - 24) = *(_OWORD *)&v24[v25 - 24];
        *(_OWORD *)(v27 - 24) = 0uLL;
        *(void *)(v26 - 8) = *(void *)&v24[v25 - 8];
        *((void *)v27 - 1) = 0;
        v25 -= 40;
      }
      while (&v24[v25] != v23);
      uint64_t v24 = *(char **)(v2 + 80);
      uint64_t v28 = *(void *)(v2 + 88);
      *(void *)(v2 + 80) = v22 + v25;
      *(void *)(v2 + 88) = v14;
      *(void *)(v2 + 96) = v21;
      while ((char *)v28 != v24)
      {
        v28 -= 40;
        sub_100391094(v28);
      }
    }
    if (v24) {
      operator delete(v24);
    }
  }
  else
  {
    uint64_t v14 = sub_100391018(v12, (uint64_t)&buf) + 40;
  }
  *(void *)(v2 + 88) = v14;
  uint64_t v29 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v29 || (v30 = *(void *)(v2 + 8), (uint64_t v31 = std::__shared_weak_count::lock(v29)) == 0)) {
    sub_100088B9C();
  }
  CFNumberRef v32 = v31;
  atomic_fetch_add_explicit(&v31->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v31);
  Registry::getTimerService((uint64_t *)__p, *(Registry **)(v2 + 48));
  uint64_t v33 = __p[0];
  sub_100058DB0(v44, "IDSTransactionManagerTimer");
  uint64_t v34 = *(void *)(v2 + 144);
  uint64_t v35 = *(NSObject **)(v2 + 24);
  dispatch_object_t object = v35;
  if (v35) {
    dispatch_retain(v35);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 1174405120;
  aBlock[2] = sub_10005B73C;
  aBlock[3] = &unk_1019C2288;
  aBlock[4] = v2;
  aBlock[5] = v30;
  char v41 = v32;
  atomic_fetch_add_explicit(&v32->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  int v42 = _Block_copy(aBlock);
  sub_10038ECF0((uint64_t)v33, (uint64_t)v44, 1, 1000000 * v34, &object, &v42);
  uint64_t v36 = v46;
  uint64_t v46 = 0;
  uint64_t v37 = *(void *)(v2 + 136);
  *(void *)(v2 + 136) = v36;
  if (v37)
  {
    (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
    uint64_t v38 = v46;
    uint64_t v46 = 0;
    if (v38) {
      (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
    }
  }
  if (v42) {
    _Block_release(v42);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v45 < 0) {
    operator delete(v44[0]);
  }
  if (__p[1]) {
    sub_10004D2C8((std::__shared_weak_count *)__p[1]);
  }
  if (v41) {
    std::__shared_weak_count::__release_weak(v41);
  }
  std::__shared_weak_count::__release_weak(v32);
  return sub_100391094((uint64_t)&buf);
}

void sub_10038EC28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (*(char *)(v27 - 73) < 0) {
    operator delete(*(void **)(v27 - 96));
  }
  _Unwind_Resume(exception_object);
}

void sub_10038ECF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, NSObject **a5, void **a6)
{
  uint64_t v17 = a3;
  uint64_t v18 = a4;
  ctu::TimerService::throwIfPeriodIsZero();
  *(_OWORD *)std::string __p = *(_OWORD *)a2;
  uint64_t v16 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  uint64_t v10 = v17;
  uint64_t v11 = v18;
  unint64_t v12 = *a5;
  *a5 = 0;
  aBlock = *a6;
  dispatch_object_t object = v12;
  *a6 = 0;
  (*(void (**)(uint64_t, void **, uint64_t, uint64_t, void, dispatch_object_t *, void **))(*(void *)a1 + 24))(a1, __p, v10, v11, 0, &object, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10038EDDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10038EE14(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10038EE30(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

const void **sub_10038EE40(uint64_t a1, uint64_t a2)
{
  return sub_100083DA4((const void **)(a1 + 72), (const void **)(a2 + 72));
}

const void **sub_10038EE4C(uint64_t a1)
{
  return sub_1000558F4((const void **)(a1 + 72));
}

void sub_10038EE54(void *a1)
{
  uint64_t v5 = a1[1];
  long long v3 = (std::__shared_weak_count *)a1[2];
  uint64_t v4 = a1 + 1;
  if (!v3 || (uint64_t v6 = std::__shared_weak_count::lock(v3)) == 0) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  p_shared_weak_owners = &v6->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v6);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  uint64_t v10[2] = sub_10038EFB8;
  uint64_t v10[3] = &unk_1019C23B0;
  v10[4] = a1;
  v10[5] = v5;
  uint64_t v11 = v7;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  sub_10003E168(&v14, v4);
  uint64_t v9 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100391108;
  block[3] = &unk_1019C2600;
  void block[5] = v14;
  unint64_t v13 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v10;
  dispatch_async(v9, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  std::__shared_weak_count::__release_weak(v7);
}

void sub_10038EFB8(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  uint64_t v3 = v2[8];
  uint64_t v4 = v2[3];
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 1174405120;
  v21[2] = sub_10038F36C;
  void v21[3] = &unk_1019C22F0;
  uint64_t v5 = a1[5];
  uint64_t v6 = (std::__shared_weak_count *)a1[6];
  void v21[4] = v2;
  v21[5] = v5;
  uint64_t v22 = v6;
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v5 = a1[5];
    uint64_t v6 = (std::__shared_weak_count *)a1[6];
  }
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 1174405120;
  v19[2] = sub_10038F518;
  v19[3] = &unk_1019C2320;
  void v19[4] = v2;
  v19[5] = v5;
  CFTypeRef v20 = v6;
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v5 = a1[5];
    uint64_t v6 = (std::__shared_weak_count *)a1[6];
  }
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 1174405120;
  v17[2] = sub_10038F6CC;
  v17[3] = &unk_1019C2350;
  void v17[4] = v2;
  void v17[5] = v5;
  uint64_t v18 = v6;
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v5 = a1[5];
    uint64_t v7 = (std::__shared_weak_count *)a1[6];
  }
  else
  {
    uint64_t v7 = 0;
  }
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 1174405120;
  void v15[2] = sub_10038FDDC;
  v15[3] = &unk_1019C2380;
  void v15[4] = v2;
  v15[5] = v5;
  uint64_t v16 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t, void *, void *, void *, void *))(*(void *)v3 + 16))(v3, v4, v21, v19, v17, v15);
  CFNumberRef v8 = v2[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "IDSTransactionManager";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s started for following subscribers:", buf, 0xCu);
  }
  uint64_t v9 = v2[10];
  for (uint64_t i = v2[11]; v9 != i; v9 += 40)
  {
    uint64_t v11 = v2[5];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v26 = 0;
      ctu::cf::assign();
      *(_OWORD *)std::string __p = *(_OWORD *)buf;
      uint64_t v14 = v26;
      unint64_t v12 = *(void ***)buf;
      if (v26 >= 0) {
        unint64_t v12 = __p;
      }
      *(_DWORD *)CFTypeRef v23 = 136315138;
      uint64_t v24 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I            %s", v23, 0xCu);
      if (SHIBYTE(v14) < 0) {
        operator delete(__p[0]);
      }
    }
  }
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  if (v18) {
    std::__shared_weak_count::__release_weak(v18);
  }
  if (v20) {
    std::__shared_weak_count::__release_weak(v20);
  }
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
}

void sub_10038F318(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,std::__shared_weak_count *a35)
{
  if (a21) {
    std::__shared_weak_count::__release_weak(a21);
  }
  if (a28) {
    std::__shared_weak_count::__release_weak(a28);
  }
  if (a35) {
    std::__shared_weak_count::__release_weak(a35);
  }
  uint64_t v37 = *(std::__shared_weak_count **)(v35 - 136);
  if (v37) {
    std::__shared_weak_count::__release_weak(v37);
  }
  _Unwind_Resume(exception_object);
}

void sub_10038F36C(void *a1, uint64_t *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        uint64_t v9 = *a2;
        CFNumberRef v8 = (std::__shared_weak_count *)a2[1];
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v10 = v5[5];
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Processing device changed", buf, 2u);
        }
        *(_OWORD *)long long buf = 0u;
        long long v16 = 0u;
        v14[0] = v9;
        v14[1] = (uint64_t)v8;
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_10038BAF8(v14, (uint64_t)buf);
        if (v8) {
          sub_10004D2C8(v8);
        }
        uint64_t v11 = v5[10];
        uint64_t v12 = v5[11];
        while (v11 != v12)
        {
          uint64_t v13 = *(void *)(v11 + 8);
          if (v13) {
            sub_100390124(v13, (uint64_t)buf);
          }
          v11 += 40;
        }
        sub_1000558F4((const void **)&v16 + 1);
        sub_1000558F4((const void **)&v16);
        sub_1000558F4((const void **)buf);
        if (v8) {
          sub_10004D2C8(v8);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10038F4C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if (v4)
  {
    sub_10004D2C8(v4);
    sub_10038C5E8((const void **)va);
    sub_10004D2C8(v4);
  }
  else
  {
    sub_10038C5E8((const void **)va);
  }
  sub_10004D2C8(v3);
  _Unwind_Resume(a1);
}

void sub_10038F518(void *a1, uint64_t *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        uint64_t v9 = *a2;
        CFNumberRef v8 = (std::__shared_weak_count *)a2[1];
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v9)
        {
          uint64_t v10 = v5[5];
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Processing active device changed", buf, 2u);
          }
          *(_OWORD *)long long buf = 0u;
          long long v16 = 0u;
          v14[0] = v9;
          v14[1] = (uint64_t)v8;
          if (v8) {
            atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_10038BAF8(v14, (uint64_t)buf);
          if (v8) {
            sub_10004D2C8(v8);
          }
          uint64_t v11 = v5[10];
          uint64_t v12 = v5[11];
          while (v11 != v12)
          {
            uint64_t v13 = *(void *)(v11 + 16);
            if (v13) {
              sub_100390124(v13, (uint64_t)buf);
            }
            v11 += 40;
          }
          sub_1000558F4((const void **)&v16 + 1);
          sub_1000558F4((const void **)&v16);
          sub_1000558F4((const void **)buf);
        }
        if (v8) {
          sub_10004D2C8(v8);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10038F67C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if (v4)
  {
    sub_10004D2C8(v4);
    sub_10038C5E8((const void **)va);
    sub_10004D2C8(v4);
  }
  else
  {
    sub_10038C5E8((const void **)va);
  }
  sub_10004D2C8(v3);
  _Unwind_Resume(a1);
}

void sub_10038F6CC(void *a1, const void *a2, const __CFString *a3, const void *a4)
{
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v9 = (void *)a1[4];
    uint64_t v10 = std::__shared_weak_count::lock(v5);
    if (v10)
    {
      uint64_t v11 = v10;
      if (a1[5])
      {
        uint64_t v12 = a2;
        if (a2) {
          CFRetain(a2);
        }
        sub_10038F78C(v9, &v12, a3, a4, 0, &v13);
        sub_1000558F4(&v12);
      }
      sub_10004D2C8(v11);
    }
  }
}

void sub_10038F770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1000558F4(&a9);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void sub_10038F78C(void *a1, const void **a2, const __CFString *a3, CFTypeRef cf, const void *a5, unsigned char *a6)
{
  if (cf)
  {
    CFTypeID v12 = CFGetTypeID(cf);
    if (v12 == CFDictionaryGetTypeID())
    {
      CFNumberRef Value = (unsigned int *)CFDictionaryGetValue((CFDictionaryRef)cf, @"tid");
      *(_DWORD *)long long buf = 0;
      if (Value && (uint64_t v14 = Value, v15 = CFGetTypeID(Value), v15 == CFNumberGetTypeID()))
      {
        ctu::cf::assign((ctu::cf *)buf, v14, v16);
        int v17 = *(_DWORD *)buf;
      }
      else
      {
        int v17 = 0;
      }
      CFStringRef v20 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"subscriber-topic");
      CFStringRef v21 = v20;
      if (v20)
      {
        CFTypeID v22 = CFGetTypeID(v20);
        if (v22 == CFStringGetTypeID()) {
          CFStringRef v23 = v21;
        }
        else {
          CFStringRef v23 = 0;
        }
      }
      else
      {
        CFStringRef v23 = 0;
      }
      uint64_t v24 = CFDictionaryGetValue((CFDictionaryRef)cf, @"payload");
      if (CFEqual(a3, @"ITM-rsp"))
      {
        uint64_t v27 = a1[13];
        uint64_t v28 = a1[14];
        while (v27 != v28)
        {
          if (*(_DWORD *)v27 == v17)
          {
            CFStringRef v29 = *(const __CFString **)(v27 + 16);
            uint64_t v30 = v29 ? sub_1000810B8 : 0;
            if (!v30 || CFEqual(v29, (CFStringRef)*a2))
            {
              if (v24)
              {
                *(void *)&long long v50 = v24;
                CFRetain(v24);
              }
              else
              {
                *(void *)&long long v50 = 0;
              }
              if (a5)
              {
                *((void *)&v50 + 1) = a5;
                CFRetain(a5);
              }
              else
              {
                *((void *)&v50 + 1) = 0;
              }
              uint64_t v40 = (int *)CFDictionaryGetValue((CFDictionaryRef)cf, @"error-code");
              char v41 = v40;
              *(_DWORD *)long long buf = 0;
              if (v40)
              {
                CFTypeID v42 = CFGetTypeID(v40);
                if (v42 == CFNumberGetTypeID())
                {
                  ctu::cf::assign((ctu::cf *)buf, v41, v43);
                  char v41 = (int *)*(unsigned int *)buf;
                }
                else
                {
                  char v41 = 0;
                }
              }
              uint64_t v44 = *(void *)(v27 + 24);
              sub_100083DA4((const void **)&v51, a2);
              *(_OWORD *)long long buf = v50;
              long long v50 = 0uLL;
              char v45 = (*(uint64_t (**)(uint64_t, void **, uint8_t *, int *))(v44 + 16))(v44, &v51, buf, v41);
              sub_1000FE824((const void **)&buf[8]);
              sub_1000577C4((const void **)buf);
              sub_1000558F4((const void **)&v51);
              *a6 = v45;
              sub_1000FE824((const void **)&v50 + 1);
              uint64_t v46 = (const void **)&v50;
LABEL_60:
              sub_1000577C4(v46);
LABEL_70:
              uint64_t v18 = a1[5];
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                unint64_t v19 = "#E Transaction message processed";
                goto LABEL_8;
              }
              return;
            }
          }
          v27 += 32;
        }
        goto LABEL_44;
      }
      if (CFStringCompare(a3, @"ITM-req", 0))
      {
        if (CFEqual(a3, @"ITM-ind"))
        {
          if (v23)
          {
            uint64_t v25 = a1[10];
            uint64_t v26 = a1[11];
            while (v25 != v26)
            {
              if (CFStringHasPrefix(v23, *(CFStringRef *)v25))
              {
                *(void *)&long long v50 = v23;
                if (v24)
                {
                  *(void *)long long buf = v24;
                  CFRetain(v24);
                }
                else
                {
                  *(void *)long long buf = 0;
                }
                if (a5)
                {
                  *(void *)&uint8_t buf[8] = a5;
                  CFRetain(a5);
                }
                else
                {
                  *(void *)&uint8_t buf[8] = 0;
                }
                *a6 = sub_10039090C(*(void *)(v25 + 24), a2, (const void **)&v50, (long long *)buf);
                sub_1000FE824((const void **)&buf[8]);
                uint64_t v46 = (const void **)buf;
                goto LABEL_60;
              }
              v25 += 40;
            }
            goto LABEL_44;
          }
          uint64_t v33 = a1[5];
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            uint64_t v34 = "#E no subtopic in indication";
            goto LABEL_43;
          }
        }
      }
      else
      {
        if (v23)
        {
          uint64_t v31 = a1[10];
          uint64_t v32 = a1[11];
          while (v31 != v32)
          {
            if (CFStringHasPrefix(v23, *(CFStringRef *)v31))
            {
              uint64_t v36 = (std::__shared_weak_count *)a1[2];
              if (!v36 || (uint64_t v37 = a1[1], (v38 = std::__shared_weak_count::lock(v36)) == 0)) {
                sub_100088B9C();
              }
              char v39 = v38;
              atomic_fetch_add_explicit(&v38->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v38);
              *(void *)&long long v50 = v23;
              if (v24)
              {
                *(void *)long long buf = v24;
                CFRetain(v24);
              }
              else
              {
                *(void *)long long buf = 0;
              }
              if (a5)
              {
                *(void *)&uint8_t buf[8] = a5;
                CFRetain(a5);
              }
              else
              {
                *(void *)&uint8_t buf[8] = 0;
              }
              v47[0] = _NSConcreteStackBlock;
              v47[1] = 1174405120;
              v47[2] = sub_1003902AC;
              v47[3] = &unk_1019C2480;
              v47[4] = a1;
              v47[5] = v37;
              uint64_t v48 = v39;
              atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              int v49 = v17;
              long long v51 = v47;
              *a6 = sub_1003901CC(*(void *)(v31 + 32), a2, (const void **)&v50, (long long *)buf, &v51);
              sub_1000FE824((const void **)&buf[8]);
              sub_1000577C4((const void **)buf);
              if (v48) {
                std::__shared_weak_count::__release_weak(v48);
              }
              std::__shared_weak_count::__release_weak(v39);
              goto LABEL_70;
            }
            v31 += 40;
          }
          goto LABEL_44;
        }
        uint64_t v33 = a1[5];
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          uint64_t v34 = "#E no subtopic in request";
LABEL_43:
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, v34, buf, 2u);
        }
      }
LABEL_44:
      uint64_t v35 = a1[5];
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = cf;
        _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Cannot find the callback for %@", buf, 0xCu);
      }
      return;
    }
  }
  uint64_t v18 = a1[5];
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    unint64_t v19 = "#E Incoming message is not a dictionary. Ignored.";
LABEL_8:
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, buf, 2u);
  }
}

void sub_10038FD34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, char a20,int a21,__int16 a22,char a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10038FDDC(void *a1, const void *a2, const __CFString *a3, const void *a4, const void *a5, unsigned char *a6)
{
  uint64_t v7 = (std::__shared_weak_count *)a1[6];
  if (v7)
  {
    char v13 = (void *)a1[4];
    uint64_t v14 = std::__shared_weak_count::lock(v7);
    if (v14)
    {
      CFTypeID v15 = v14;
      if (a1[5])
      {
        CFNumberRef v16 = a2;
        if (a2) {
          CFRetain(a2);
        }
        sub_10038F78C(v13, &v16, a3, a4, a5, a6);
        sub_1000558F4(&v16);
      }
      sub_10004D2C8(v15);
    }
  }
}

void sub_10038FE90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void sub_10038FEAC(uint64_t a1, void **a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 1174405120;
  v5[2] = sub_10038FFDC;
  v5[3] = &unk_1019C23E0;
  _OWORD v5[4] = a1;
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlock = v3;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_10003E168(&v9, (void *)(a1 + 8));
  uint64_t v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100391108;
  block[3] = &unk_1019C2600;
  void block[5] = v9;
  CFNumberRef v8 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
}

void sub_10038FFDC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  (*(void (**)(long long **__return_ptr))(**(void **)(v2 + 64) + 128))(&v4);
  uint64_t v3 = *(void *)(a1 + 40);
  memset(v7, 0, sizeof(v7));
  sub_1000302C0((char *)v7, v4, v5, 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)v4) >> 3));
  (*(void (**)(uint64_t, void ***))(v3 + 16))(v3, v7);
  CFNumberRef v8 = v7;
  sub_100047F64((void ***)&v8);
  v7[0] = (void **)&v4;
  sub_100047F64(v7);
}

void sub_10039009C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  *(void *)(v11 - 24) = v10;
  sub_100047F64((void ***)(v11 - 24));
  *(void *)(v11 - 24) = &a10;
  sub_100047F64((void ***)(v11 - 24));
  _Unwind_Resume(a1);
}

void *sub_1003900CC(uint64_t a1, uint64_t a2)
{
  __n128 result = *(void **)(a2 + 40);
  if (result) {
    __n128 result = _Block_copy(result);
  }
  *(void *)(a1 + 40) = result;
  return result;
}

void sub_100390100(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 40);
  if (v1) {
    _Block_release(v1);
  }
}

const void **sub_100390124(uint64_t a1, uint64_t a2)
{
  sub_100083DA4(&v5, (const void **)a2);
  char v6 = *(unsigned char *)(a2 + 8);
  sub_100083DA4(&v7, (const void **)(a2 + 16));
  sub_100083DA4(&v8, (const void **)(a2 + 24));
  (*(void (**)(uint64_t, const void **))(a1 + 16))(a1, &v5);
  sub_1000558F4(&v8);
  sub_1000558F4(&v7);
  return sub_1000558F4(&v5);
}

void sub_1003901B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_1003901CC(uint64_t a1, const void **a2, const void **a3, long long *a4, void *a5)
{
  sub_100083DA4(&v14, a2);
  uint64_t v9 = *a3;
  char v13 = v9;
  if (v9) {
    CFRetain(v9);
  }
  long long v12 = *a4;
  *(void *)a4 = 0;
  *((void *)a4 + 1) = 0;
  uint64_t v10 = (*(uint64_t (**)(uint64_t, const void **, const void **, long long *, void))(a1 + 16))(a1, &v14, &v13, &v12, *a5);
  sub_1000FE824((const void **)&v12 + 1);
  sub_1000577C4((const void **)&v12);
  sub_1000558F4(&v13);
  sub_1000558F4(&v14);
  return v10;
}

void sub_100390280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, const void *a11, const void *a12)
{
  sub_1000FE824(v12);
  sub_1000577C4(&a9);
  sub_1000558F4(&a11);
  sub_1000558F4(&a12);
  _Unwind_Resume(a1);
}

void sub_1003902AC(uint64_t a1, const void **a2, const void **a3, int a4, uint64_t a5)
{
  char v6 = *(std::__shared_weak_count **)(a1 + 48);
  if (v6)
  {
    uint64_t v11 = *(void *)(a1 + 32);
    long long v12 = std::__shared_weak_count::lock(v6);
    if (v12)
    {
      char v13 = v12;
      if (*(void *)(a1 + 40))
      {
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 1174405120;
        v16[2] = sub_100390490;
        void v16[3] = &unk_1019C2450;
        v16[5] = v11;
        int v21 = *(_DWORD *)(a1 + 56);
        sub_1000584C8(&v17, a3);
        sub_100119B5C(v18, a3 + 1);
        int v22 = a4;
        uint64_t v14 = *(std::__shared_weak_count **)(a1 + 48);
        v18[1] = *(const void **)(a1 + 40);
        unint64_t v19 = v14;
        if (v14) {
          atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        v16[4] = a5;
        sub_100083DA4(&v20, a2);
        uint64_t v25 = 0;
        uint64_t v26 = 0;
        sub_10003E168(&v25, (void *)(v11 + 8));
        CFTypeID v15 = *(NSObject **)(v11 + 24);
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100391108;
        block[3] = &unk_1019C2600;
        void block[5] = v25;
        uint64_t v24 = v26;
        if (v26) {
          atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        block[4] = v16;
        dispatch_async(v15, block);
        if (v24) {
          sub_10004D2C8(v24);
        }
        if (v26) {
          sub_10004D2C8(v26);
        }
        sub_1000558F4(&v20);
        if (v19) {
          std::__shared_weak_count::__release_weak(v19);
        }
        sub_1000FE824(v18);
        sub_1000577C4(&v17);
      }
      sub_10004D2C8(v13);
    }
  }
}

const void **sub_100390490(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  CFStringRef v20 = 0;
  CFNumberRef v21 = 0;
  unint64_t valuePtr = *(unsigned int *)(a1 + 88);
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v3)
  {
    unint64_t v4 = (unint64_t)v21;
    CFNumberRef v21 = v3;
    unint64_t valuePtr = v4;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v5 = v21;
  CFNumberRef v19 = v21;
  CFNumberRef v21 = 0;
  sub_1000570E8((const void **)&v21);
  sub_10038C6EC(&v20, v5, 0, *(const void **)(a1 + 48));
  sub_1000570E8((const void **)&v19);
  char v6 = v20;
  int v7 = *(_DWORD *)(a1 + 92);
  CFNumberRef v21 = 0;
  LODWORD(valuePtr) = v7;
  CFNumberRef v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v8)
  {
    unint64_t v9 = (unint64_t)v21;
    CFNumberRef v21 = v8;
    unint64_t valuePtr = v9;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v10 = v21;
  CFNumberRef v19 = v21;
  CFNumberRef v21 = 0;
  sub_1000570E8((const void **)&v21);
  CFDictionaryAddValue(v6, @"error-code", v10);
  sub_1000570E8((const void **)&v19);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 1174405120;
  v16[2] = sub_100390700;
  void v16[3] = &unk_1019C2418;
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 72);
  v16[5] = *(void *)(a1 + 64);
  int v17 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  v16[4] = *(void *)(a1 + 32);
  sub_100083DA4(&v18, (const void **)(a1 + 80));
  sub_100083DA4((const void **)&v15, (const void **)(a1 + 80));
  sub_10004EFE4(&v14, (CFTypeRef *)&v20);
  sub_100119B5C((const void **)&v13, (const void **)(a1 + 56));
  sub_10038C7C8(v2, @"ITM-rsp", v15, v14, v13, (uint64_t)v16);
  sub_1000FE824((const void **)&v13);
  sub_100057D78((const void **)&v14);
  sub_1000558F4((const void **)&v15);
  sub_1000558F4(&v18);
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  return sub_10005717C((const void **)&v20);
}

void sub_100390680(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, const void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  sub_1000FE824(&a10);
  sub_100057D78(&a11);
  sub_1000558F4(&a12);
  sub_1000558F4(v19);
  if (a19) {
    std::__shared_weak_count::__release_weak(a19);
  }
  sub_10005717C((const void **)(v20 - 56));
  _Unwind_Resume(a1);
}

void sub_100390700(uint64_t a1, uint64_t a2, char a3, int a4)
{
  CFNumberRef v5 = *(std::__shared_weak_count **)(a1 + 48);
  if (v5)
  {
    CFNumberRef v8 = std::__shared_weak_count::lock(v5);
    if (v8)
    {
      unint64_t v9 = v8;
      if (*(void *)(a1 + 40))
      {
        uint64_t v10 = *(void *)(a1 + 32);
        if (v10)
        {
          sub_100083DA4(&v14, (const void **)(a1 + 56));
          if (a4 == 57) {
            int v11 = 2;
          }
          else {
            int v11 = 1;
          }
          if (a4 == 94) {
            unsigned int v12 = 4;
          }
          else {
            unsigned int v12 = v11;
          }
          if (!a4) {
            unsigned int v12 = 0;
          }
          if (a3) {
            uint64_t v13 = 0;
          }
          else {
            uint64_t v13 = v12;
          }
          (*(void (**)(uint64_t, const void **, uint64_t))(v10 + 16))(v10, &v14, v13);
          sub_1000558F4(&v14);
        }
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_1003907C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

const void **sub_1003907DC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return sub_100083DA4((const void **)(a1 + 56), (const void **)(a2 + 56));
}

void sub_100390800(uint64_t a1)
{
  sub_1000558F4((const void **)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

const void **sub_10039084C(uint64_t a1, uint64_t a2)
{
  sub_1000584C8((const void **)(a1 + 48), (const void **)(a2 + 48));
  sub_100119B5C((const void **)(a1 + 56), (const void **)(a2 + 56));
  uint64_t v4 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }

  return sub_100083DA4((const void **)(a1 + 80), (const void **)(a2 + 80));
}

const void **sub_1003908B8(uint64_t a1)
{
  sub_1000558F4((const void **)(a1 + 80));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_1000FE824((const void **)(a1 + 56));

  return sub_1000577C4((const void **)(a1 + 48));
}

uint64_t sub_10039090C(uint64_t a1, const void **a2, const void **a3, long long *a4)
{
  sub_100083DA4(&v12, a2);
  int v7 = *a3;
  int v11 = v7;
  if (v7) {
    CFRetain(v7);
  }
  long long v10 = *a4;
  *(void *)a4 = 0;
  *((void *)a4 + 1) = 0;
  uint64_t v8 = (*(uint64_t (**)(uint64_t, const void **, const void **, long long *))(a1 + 16))(a1, &v12, &v11, &v10);
  sub_1000FE824((const void **)&v10 + 1);
  sub_1000577C4((const void **)&v10);
  sub_1000558F4(&v11);
  sub_1000558F4(&v12);
  return v8;
}

void sub_1003909B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, const void *a11, const void *a12)
{
  sub_1000FE824(v12);
  sub_1000577C4(&a9);
  sub_1000558F4(&a11);
  sub_1000558F4(&a12);
  _Unwind_Resume(a1);
}

void sub_1003909E8(uint64_t a1)
{
  sub_10038BF94(a1);

  operator delete();
}

void sub_100390A20(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100390D94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8))(a9);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

void sub_100390EC4(Registry **a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v4 = ServiceMap;
  CFNumberRef v5 = "30IDSTransactionManagerInterface";
  if (((unint64_t)"30IDSTransactionManagerInterface" & 0x8000000000000000) != 0)
  {
    char v6 = (unsigned __int8 *)((unint64_t)"30IDSTransactionManagerInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      CFNumberRef v5 = (const char *)v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unsigned int v12 = v5;
  unint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v12);
  if (v9)
  {
    uint64_t v11 = v9[3];
    long long v10 = (std::__shared_weak_count *)v9[4];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v11 = 0;
    long long v10 = 0;
  }
  std::mutex::unlock(v4);
  *a2 = v11;
  a2[1] = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
}

const void **sub_100390F8C(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    _Block_release(v2);
  }

  return sub_1000558F4((const void **)(a1 + 16));
}

uint64_t sub_100390FD0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  sub_100083DA4((const void **)(a1 + 16), (const void **)(a2 + 16));
  uint64_t v4 = *(void **)(a2 + 24);
  if (v4) {
    uint64_t v4 = _Block_copy(v4);
  }
  *(void *)(a1 + 24) = v4;
  return a1;
}

uint64_t sub_100391018(uint64_t a1, uint64_t a2)
{
  sub_100083DA4((const void **)a1, (const void **)a2);
  uint64_t v4 = *(void **)(a2 + 8);
  if (v4) {
    uint64_t v4 = _Block_copy(v4);
  }
  *(void *)(a1 + 8) = v4;
  CFNumberRef v5 = *(void **)(a2 + 16);
  if (v5) {
    CFNumberRef v5 = _Block_copy(v5);
  }
  *(void *)(a1 + 16) = v5;
  char v6 = *(void **)(a2 + 24);
  if (v6) {
    char v6 = _Block_copy(v6);
  }
  *(void *)(a1 + 24) = v6;
  uint64_t v7 = *(void **)(a2 + 32);
  if (v7) {
    uint64_t v7 = _Block_copy(v7);
  }
  *(void *)(a1 + 32) = v7;
  return a1;
}

const void **sub_100391094(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    _Block_release(v2);
  }
  CFNumberRef v3 = *(const void **)(a1 + 24);
  if (v3) {
    _Block_release(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 16);
  if (v4) {
    _Block_release(v4);
  }
  CFNumberRef v5 = *(const void **)(a1 + 8);
  if (v5) {
    _Block_release(v5);
  }

  return sub_1000558F4((const void **)a1);
}

uint64_t sub_100391108(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100391118(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100391134(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100391148(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100391180(uint64_t a1)
{
}

uint64_t sub_10039119C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1003911E0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10039120C(ServiceManager::Service *this)
{
  *(void *)this = off_1019C26A0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100391268(ServiceManager::Service *this)
{
  *(void *)this = off_1019C26A0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1003912D8@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "IDSTransactionManager");
}

unsigned char *sub_1003912E8@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 0;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100391324(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v2);
    dispatch_group_leave(v2);
    dispatch_release(v2);
  }
}

uint64_t sub_100391380()
{
  return 0;
}

uint64_t sub_100391388()
{
  return 1;
}

uint64_t sub_100391390()
{
  return 0;
}

uint64_t sub_10039139C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v2 = v1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I starting", v4, 2u);
  }
  return (*(uint64_t (**)(void *))(*v1 + 96))(v1);
}

void sub_10039142C()
{
}

void sub_100391498()
{
}

uint64_t sub_1003914BC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v18, kCtLoggingSystemName, "cb.xml.cache");
  initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  char v6 = dispatch_queue_create_with_target_V2("CarrierBundleXMLCacheHandler", initially_inactive, 0);
  dispatch_set_qos_class_floor(v6, QOS_CLASS_UTILITY, 0);
  dispatch_activate(v6);
  *uint64_t v4 = 0;
  v4[1] = 0;
  *(void *)(a1 + 24) = v6;
  if (v6)
  {
    dispatch_retain(v6);
    *(void *)(a1 + 32) = 0;
    dispatch_release(v6);
  }
  else
  {
    *(void *)(a1 + 32) = 0;
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v19, &v18);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v19);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v19);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
  *(void *)a1 = off_1019C2720;
  *(void *)(a1 + 48) = *(void *)a2;
  uint64_t v7 = *(void *)(a2 + 8);
  *(void *)(a1 + 56) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  Registry::getFileSystemInterface((uint64_t *)(a1 + 64), *(Registry **)a2);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  unint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  v18.var0 = (char *)v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v18);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v16 = 0;
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v9);
  *(void *)(a1 + 80) = v16;
  *(void *)(a1 + 88) = v15;
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v15);
  }
  *(unsigned char *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  return a1;
}

void sub_1003916AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v12 + 7);
  if (v16) {
    sub_10004D2C8(v16);
  }
  ctu::OsLogLogger::~OsLogLogger(v14);
  sub_100087E88(v13);
  CarrierBundleXMLCacheInterface::~CarrierBundleXMLCacheInterface(v12);
  _Unwind_Resume(a1);
}

BOOL sub_100391720(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100391FE8;
  v5[3] = &unk_1019C2858;
  _OWORD v5[4] = a1 + 8;
  void v5[5] = &v4;
  char v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    unint64_t v9 = sub_10005AC30;
    uint64_t v10 = &unk_1019C2898;
    uint64_t v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    unint64_t v9 = sub_100059ECC;
    uint64_t v10 = &unk_1019C2878;
    uint64_t v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

void sub_100391850(uint64_t a1, const void **a2)
{
  sub_100058198((const void **)&v4 + 1, a2);
  CFNumberRef v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10039195C(uint64_t a1)
{
  return *(void *)a1;
}

void sub_100391964(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10039276C;
  v5[3] = &unk_1019C28B8;
  _OWORD v5[4] = a1 + 8;
  void v5[5] = &v4;
  char v6 = v5;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    *a2 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    unint64_t v9 = sub_1003929A8;
    uint64_t v10 = &unk_1019C28F8;
    uint64_t v11 = a2;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    *a2 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    unint64_t v9 = sub_100392930;
    uint64_t v10 = &unk_1019C28D8;
    uint64_t v11 = a2;
    uint64_t v12 = &v6;
    dispatch_sync(v2, &block);
  }
}

uint64_t sub_100391A80(uint64_t a1)
{
  CFDictionaryRef v2 = *(const __CFDictionary **)(a1 + 104);
  if (v2) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    CFDictionaryGetValue(v2, @"Filename");
    memset(buf, 0, sizeof(buf));
    uint64_t v10 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = 0u;
    uint64_t v8 = 0;
    if ((*(uint64_t (**)(void, void **))(**(void **)(a1 + 64) + 112))(*(void *)(a1 + 64), __p))
    {
      uint64_t v4 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        char v6 = __p;
        if (v8 < 0) {
          char v6 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v6;
        _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to remove cache file: %{public}s", buf, 0xCu);
      }
    }
    if (SHIBYTE(v8) < 0) {
      operator delete(__p[0]);
    }
    CFDictionaryRef v2 = *(const __CFDictionary **)(a1 + 104);
  }
  *(unsigned char *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)long long buf = v2;
  sub_100057D78((const void **)buf);
  uint64_t result = *(void *)(a1 + 80);
  if (result) {
    return (*(uint64_t (**)(uint64_t, const __CFString *, void, void, const CFStringRef, const CFStringRef))(*(void *)result + 16))(result, @"CBVersionXMLCacheInfo", 0, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  }
  return result;
}

void sub_100391C38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

void sub_100391C70(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100391D54(uint64_t a1)
{
  sub_100391D8C(a1);

  operator delete();
}

void sub_100391D8C(uint64_t a1)
{
  *(void *)a1 = off_1019C2720;
  sub_100057D78((const void **)(a1 + 104));
  CFDictionaryRef v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  CarrierBundleXMLCacheInterface::~CarrierBundleXMLCacheInterface((CarrierBundleXMLCacheInterface *)a1);
}

void sub_100391E18(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100391EE4(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100391FBC);
  __cxa_rethrow();
}

void sub_100391F0C(_Unwind_Exception *a1)
{
}

void sub_100391F24(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100391F5C(uint64_t a1)
{
}

uint64_t sub_100391F78(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100391FBC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100391FE8(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 80);
  if (!v3) {
    return 0;
  }
  CFDictionaryRef theDict = 0;
  (*(void (**)(const void **__return_ptr))(*(void *)v3 + 40))(&v16);
  sub_10004EFE4(&theDict, &v16);
  sub_1000577C4(&v16);
  if (theDict) {
    uint64_t v4 = sub_100080778;
  }
  else {
    uint64_t v4 = 0;
  }
  if (!v4)
  {
LABEL_15:
    sub_100057D78((const void **)&theDict);
    return 0;
  }
  CFNumberRef Value = CFDictionaryGetValue(theDict, @"ExpiresAt");
  char v6 = Value;
  if (Value)
  {
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFDateGetTypeID()) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = 0;
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v16 = v8;
  double AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)v8);
  double Current = CFAbsoluteTimeGetCurrent();
  sub_100058140((const void **)(v2 + 104), (const void **)&theDict);
  uint64_t v11 = *(NSObject **)(v2 + 40);
  BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if (AbsoluteTime < Current)
  {
    if (v12)
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I XML cache not valid anymore. Removing it.", v15, 2u);
    }
    sub_100391A80(v2);
    sub_10007CA64(&v16);
    goto LABEL_15;
  }
  if (v12)
  {
    *(_WORD *)uint64_t v15 = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I XML cache still valid.", v15, 2u);
  }
  uint64_t v13 = 1;
  *(unsigned char *)(v2 + 96) = 1;
  sub_10007CA64(&v16);
  sub_100057D78((const void **)&theDict);
  return v13;
}

void sub_1003921B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  sub_10007CA64((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1003921F0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v24 = a1;
  uint64_t v25 = v1;
  uint64_t v2 = *(void *)v1;
  sub_100058198((const void **)&theDict, (const void **)(v1 + 8));
  if (theDict) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3 && CFDictionaryGetCount(theDict))
  {
    WirelessUserDirectory = (char *)_GetWirelessUserDirectory();
    memset(&v34, 0, sizeof(v34));
    sub_100058DB0(&v34, WirelessUserDirectory);
    ctu::path_join_impl();
    v32[0] = 0;
    v32[1] = 0;
    int64_t v33 = 0;
    sub_1006C6B78((uint64_t)&v29);
    CFNumberRef v5 = std::string::insert(&v29, 0, "cb_version_", 0xBuLL);
    long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    std::string::size_type v31 = v5->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    memset(&__dst, 0, sizeof(__dst));
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, v34.__r_.__value_.__l.__data_, v34.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = v34;
    }
    ctu::path_join_impl();
    CFTypeID v7 = std::string::append(&__dst, ".plist", 6uLL);
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    int64_t v33 = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v32 = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v31) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v29.__r_.__value_.__l.__data_);
    }
    __p[0] = 0;
    if ((*(uint64_t (**)(void, void **, CFDictionaryRef, void **))(**(void **)(v2 + 64) + 192))(*(void *)(v2 + 64), v32, theDict, __p))
    {
      *(unsigned char *)(v2 + 96) = 1;
      v29.__r_.__value_.__r.__words[0] = 0;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        std::string::size_type v10 = v29.__r_.__value_.__r.__words[0];
        v29.__r_.__value_.__r.__words[0] = (std::string::size_type)Mutable;
        __dst.__r_.__value_.__r.__words[0] = v10;
        sub_10005717C((const void **)&__dst.__r_.__value_.__l.__data_);
      }
      if (v33 >= 0) {
        uint64_t v11 = v32;
      }
      else {
        uint64_t v11 = (void **)v32[0];
      }
      CFStringRef v12 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v11, 0x8000100u);
      sub_10010F3F0((__CFDictionary *)v29.__r_.__value_.__l.__data_, @"Filename", (uint64_t)v12);
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      CFDateRef v28 = CFDateCreate(kCFAllocatorDefault, Current + 900.0);
      sub_1001C6AF0((__CFDictionary *)v29.__r_.__value_.__l.__data_, @"ExpiresAt", (uint64_t)v28);
      uint64_t v14 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(__dst.__r_.__value_.__l.__data_) = 138543362;
        *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = v29.__r_.__value_.__r.__words[0];
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I cache dict: %{public}@", (uint8_t *)&__dst, 0xCu);
      }
      sub_10004EFE4(&v27, (CFTypeRef *)&v29.__r_.__value_.__l.__data_);
      uint64_t v15 = (std::string::size_type *)(v2 + 104);
      if ((std::string::size_type *)(v2 + 104) != &v27)
      {
        __dst.__r_.__value_.__r.__words[0] = *v15;
        std::string::size_type *v15 = v27;
        std::string::size_type v27 = 0;
        sub_100057D78((const void **)&__dst.__r_.__value_.__l.__data_);
      }
      sub_100057D78((const void **)&v27);
      uint64_t v16 = *(void *)(v2 + 80);
      if (v16) {
        (*(void (**)(uint64_t, const __CFString *, std::string::size_type, void, const CFStringRef, const CFStringRef))(*(void *)v16 + 16))(v16, @"CBVersionXMLCacheInfo", v29.__r_.__value_.__r.__words[0], kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
      }
      sub_10007CA64((const void **)&v28);
      sub_10005717C((const void **)&v29.__r_.__value_.__l.__data_);
    }
    else
    {
      int v17 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        int v22 = v32;
        if (v33 < 0) {
          int v22 = (void **)v32[0];
        }
        LODWORD(__dst.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v22;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to write xml dict to path :%{public}s", (uint8_t *)&__dst, 0xCu);
      }
      OsLogContext v18 = (__CFError *)__p[0];
      if (__p[0]) {
        CFNumberRef v19 = sub_10039195C;
      }
      else {
        CFNumberRef v19 = 0;
      }
      if (v19)
      {
        uint64_t v20 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v23 = CFErrorCopyDescription(v18);
          LODWORD(__dst.__r_.__value_.__l.__data_) = 138543362;
          *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "XML cache write failed with error: %{public}@", (uint8_t *)&__dst, 0xCu);
        }
      }
    }
    sub_100127D74((const void **)__p);
    if (SHIBYTE(v33) < 0) {
      operator delete(v32[0]);
    }
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v34.__r_.__value_.__l.__data_);
    }
  }
  sub_100057D78((const void **)&theDict);
  sub_10005F900(&v25);
  return sub_100046B58((uint64_t *)&v24);
}

void sub_10039268C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  sub_100127D74((const void **)&a20);
  if (a32 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v32 - 65) < 0) {
    operator delete(*(void **)(v32 - 88));
  }
  sub_100057D78(&a11);
  sub_10005F900(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

const void **sub_10039276C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(uint64_t **)(a1 + 40);
  uint64_t v4 = *v3;
  uint64_t result = *(const void ***)(*v3 + 104);
  if (result) {
    long long v6 = sub_100080778;
  }
  else {
    long long v6 = 0;
  }
  if (!v6) {
    goto LABEL_11;
  }
  CFNumberRef Value = CFDictionaryGetValue((CFDictionaryRef)result, @"ExpiresAt");
  if (Value)
  {
    long long v8 = Value;
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == CFDateGetTypeID()) {
      CFNumberRef Value = v8;
    }
    else {
      CFNumberRef Value = 0;
    }
  }
  uint64_t v14 = Value;
  double AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)Value);
  if (AbsoluteTime < CFAbsoluteTimeGetCurrent())
  {
    sub_100391A80(v4);
    uint64_t result = sub_10007CA64(&v14);
LABEL_11:
    *a2 = 0;
    return result;
  }
  uint64_t v11 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I XML cache is still valid. Using it", buf, 2u);
  }
  CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 104), @"Filename");
  memset(buf, 0, sizeof(buf));
  uint64_t v16 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = *(_OWORD *)buf;
  uint64_t v13 = v16;
  (*(void (**)(void, const CFAllocatorRef, void **))(**(void **)(v4 + 64) + 160))(*(void *)(v4 + 64), kCFAllocatorDefault, __p);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  return sub_10007CA64(&v14);
}

void sub_1003928E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10007CA64(&a15);
  _Unwind_Resume(a1);
}

const void **sub_100392930(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    std::__shared_weak_count *v2 = 0;
    long long v6 = v3;
    std::__shared_weak_count *v2 = v5;
    CFNumberRef v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

const void **sub_1003929A8(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    std::__shared_weak_count *v2 = 0;
    long long v6 = v3;
    std::__shared_weak_count *v2 = v5;
    CFNumberRef v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

void sub_100392A20(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  if (*(unsigned char *)(v1 + 96))
  {
    uint64_t v2 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I XML cache available. Need to reset.", buf, 2u);
    }
    sub_100391A80(v1);
  }
  operator delete();
}

void sub_100392AC4()
{
}

const char *sub_100392AF0(unsigned int a1)
{
  if (a1 > 0xB) {
    return "???";
  }
  else {
    return off_1019C2918[a1];
  }
}

void sub_100392B14(int *a1, os_log_t *a2)
{
  uint64_t v4 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    CFNumberRef v5 = "CALL_TYPE_CS_Voice";
    if (*a1 == 5) {
      CFNumberRef v5 = "CALL_TYPE_NR_Voice";
    }
    if (*a1 == 4) {
      long long v6 = "CALL_TYPE_VoLTE_Voice";
    }
    else {
      long long v6 = v5;
    }
    int v50 = 136315138;
    long long v51 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Call Type: %s", (uint8_t *)&v50, 0xCu);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *a1;
    if (v7 > 5) {
      long long v8 = "???";
    }
    else {
      long long v8 = off_1019C2978[v7];
    }
    int v50 = 136315138;
    long long v51 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I RAT Type: %s", (uint8_t *)&v50, 0xCu);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = a1[1];
    int v50 = 67109120;
    LODWORD(v51) = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Direction: %d", (uint8_t *)&v50, 8u);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v10 = (const char *)(a1 + 2);
    if (*((char *)a1 + 31) < 0) {
      std::string::size_type v10 = *(const char **)v10;
    }
    int v50 = 136315138;
    long long v51 = v10;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Vocoder Type: %s", (uint8_t *)&v50, 0xCu);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = a1[8];
    int v50 = 67109120;
    LODWORD(v51) = v11;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Vocoder Sample Rate: %u", (uint8_t *)&v50, 8u);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = a1[9];
    int v50 = 67109120;
    LODWORD(v51) = v12;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Vocoder Bit Rate: %u", (uint8_t *)&v50, 8u);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = a1[10];
    int v50 = 67109120;
    LODWORD(v51) = v13;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Total number of frames: %u", (uint8_t *)&v50, 8u);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = a1[11];
    int v50 = 67109120;
    LODWORD(v51) = v14;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Active number of frames: %u", (uint8_t *)&v50, 8u);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = a1[12];
    int v50 = 67109120;
    LODWORD(v51) = v15;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Silence number of frames: %u", (uint8_t *)&v50, 8u);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v16 = a1[13];
    int v50 = 67109120;
    LODWORD(v51) = v16;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Bad number of frames: %u", (uint8_t *)&v50, 8u);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v17 = a1[14];
    int v50 = 67109120;
    LODWORD(v51) = v17;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Lost number of frames: %u", (uint8_t *)&v50, 8u);
  }
  char v18 = *((unsigned char *)a1 + 87);
  if (v18 < 0)
  {
    if (!*((void *)a1 + 9)) {
      goto LABEL_41;
    }
  }
  else if (!*((unsigned char *)a1 + 87))
  {
    goto LABEL_41;
  }
  CFNumberRef v19 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = (const char *)(a1 + 16);
    if (v18 < 0) {
      uint64_t v20 = *(const char **)v20;
    }
    int v50 = 136315138;
    long long v51 = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Top 1 used bit rate: %s", (uint8_t *)&v50, 0xCu);
  }
LABEL_41:
  char v21 = *((unsigned char *)a1 + 111);
  if (v21 < 0)
  {
    if (!*((void *)a1 + 12)) {
      goto LABEL_49;
    }
  }
  else if (!*((unsigned char *)a1 + 111))
  {
    goto LABEL_49;
  }
  int v22 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v23 = (const char *)(a1 + 22);
    if (v21 < 0) {
      CFStringRef v23 = *(const char **)v23;
    }
    int v50 = 136315138;
    long long v51 = v23;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Top 2 used bit rate: %s", (uint8_t *)&v50, 0xCu);
  }
LABEL_49:
  char v24 = *((unsigned char *)a1 + 135);
  if (v24 < 0)
  {
    if (!*((void *)a1 + 15)) {
      goto LABEL_57;
    }
  }
  else if (!*((unsigned char *)a1 + 135))
  {
    goto LABEL_57;
  }
  uint64_t v25 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = (const char *)(a1 + 28);
    if (v24 < 0) {
      uint64_t v26 = *(const char **)v26;
    }
    int v50 = 136315138;
    long long v51 = v26;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Top 3 used bit rate: %s", (uint8_t *)&v50, 0xCu);
  }
LABEL_57:
  if (*((unsigned char *)a1 + 136))
  {
    std::string::size_type v27 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v50) = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I DistortionTypesDistUL:", (uint8_t *)&v50, 2u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v28 = a1[50];
      int v50 = 67109120;
      LODWORD(v51) = v28;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I TotalCallDuration: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v29 = a1[35];
      int v50 = 67109120;
      LODWORD(v51) = v29;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Tx High Noise Count: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v30 = a1[36];
      int v50 = 67109120;
      LODWORD(v51) = v30;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Tx Low Energy Count: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v31 = a1[37];
      int v50 = 67109120;
      LODWORD(v51) = v31;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Tx Silence Count: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v32 = a1[38];
      int v50 = 67109120;
      LODWORD(v51) = v32;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Tx Zeros Count: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v33 = a1[51];
      int v50 = 67109120;
      LODWORD(v51) = v33;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Number of Non-zero Distortions: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      std::string v34 = (const char *)*((void *)a1 + 26);
      int v50 = 136315138;
      long long v51 = v34;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Longest Distortion Type: %s", (uint8_t *)&v50, 0xCu);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v35 = a1[54];
      int v50 = 67109120;
      LODWORD(v51) = v35;
LABEL_107:
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Longest Distortion Duration: %u", (uint8_t *)&v50, 8u);
    }
  }
  else if (*((unsigned char *)a1 + 156))
  {
    std::string::size_type v27 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v50) = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I DistortionTypesDistDL:", (uint8_t *)&v50, 2u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v36 = a1[50];
      int v50 = 67109120;
      LODWORD(v51) = v36;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I TotalCallDuration: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v37 = a1[40];
      int v50 = 67109120;
      LODWORD(v51) = v37;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Rx High Noise Count: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v38 = a1[41];
      int v50 = 67109120;
      LODWORD(v51) = v38;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Rx Low Energy Count: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v39 = a1[42];
      int v50 = 67109120;
      LODWORD(v51) = v39;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Rx Silence Count: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v40 = a1[43];
      int v50 = 67109120;
      LODWORD(v51) = v40;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Rx Zeros Count: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v41 = a1[44];
      int v50 = 67109120;
      LODWORD(v51) = v41;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Average Speech Loss Count: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v42 = a1[45];
      int v50 = 67109120;
      LODWORD(v51) = v42;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Average Speech Loss Duration: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v43 = a1[46];
      int v50 = 67109120;
      LODWORD(v51) = v43;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Continuous Speech Loss Count: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v44 = a1[47];
      int v50 = 67109120;
      LODWORD(v51) = v44;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Continuous Speech Loss Duration: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v45 = a1[48];
      int v50 = 67109120;
      LODWORD(v51) = v45;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Rx Link Broken Count: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v46 = a1[49];
      int v50 = 67109120;
      LODWORD(v51) = v46;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Rx Link Broken Duration: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v47 = a1[51];
      int v50 = 67109120;
      LODWORD(v51) = v47;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Number of Non-zero Distortions: %u", (uint8_t *)&v50, 8u);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v48 = (const char *)*((void *)a1 + 26);
      int v50 = 136315138;
      long long v51 = v48;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Longest Distortion Type: %s", (uint8_t *)&v50, 0xCu);
      std::string::size_type v27 = *a2;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v49 = a1[54];
      int v50 = 67109120;
      LODWORD(v51) = v49;
      goto LABEL_107;
    }
  }
}

void sub_100393704(int *a1, os_log_t *a2)
{
  uint64_t v4 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    CFNumberRef v5 = "CALL_TYPE_CS_Voice";
    if (*a1 == 5) {
      CFNumberRef v5 = "CALL_TYPE_NR_Voice";
    }
    if (*a1 == 4) {
      CFNumberRef v5 = "CALL_TYPE_VoLTE_Voice";
    }
    int v14 = 136315138;
    int v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Call Type: %s", (uint8_t *)&v14, 0xCu);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *a1;
    if (v6 > 5) {
      uint64_t v7 = "???";
    }
    else {
      uint64_t v7 = off_1019C2978[v6];
    }
    int v14 = 136315138;
    int v15 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I RAT Type: %s", (uint8_t *)&v14, 0xCu);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = a1[8];
    int v14 = 67109120;
    LODWORD(v15) = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Rtp Pkt Loss Rate Jb: %d", (uint8_t *)&v14, 8u);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = a1[9];
    int v14 = 67109120;
    LODWORD(v15) = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Rtp Pkt Loss Rate Nw: %d", (uint8_t *)&v14, 8u);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = a1[10];
    int v14 = 67109120;
    LODWORD(v15) = v10;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Inter Arrival Jitter Avg: %d", (uint8_t *)&v14, 8u);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = a1[11];
    int v14 = 67109120;
    LODWORD(v15) = v11;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Inter Arrival Jitter Max: %d", (uint8_t *)&v14, 8u);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = a1[12];
    int v14 = 67109120;
    LODWORD(v15) = v12;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I FrameDelay Avg: %d", (uint8_t *)&v14, 8u);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = a1[13];
    int v14 = 67109120;
    LODWORD(v15) = v13;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I FrameDelay Max: %d", (uint8_t *)&v14, 8u);
  }
}

void sub_1003939F4(uint64_t a1, os_log_t *a2)
{
  uint64_t v4 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    CFNumberRef v5 = "CALL_TYPE_CS_Voice";
    int v6 = *(_DWORD *)(a1 + 8);
    if (v6 == 5) {
      CFNumberRef v5 = "CALL_TYPE_NR_Voice";
    }
    if (v6 == 4) {
      CFNumberRef v5 = "CALL_TYPE_VoLTE_Voice";
    }
    int v24 = 136315138;
    uint64_t v25 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Call Type: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = sub_100392AF0(*(_DWORD *)a1);
    int v24 = 136315138;
    uint64_t v25 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Distortion Type: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(_DWORD *)(a1 + 4);
    int v24 = 67109120;
    LODWORD(v25) = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Distortion Duration: %u", (uint8_t *)&v24, 8u);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(int *)(a1 + 8);
    if (v9 > 5) {
      int v10 = "???";
    }
    else {
      int v10 = off_1019C2978[v9];
    }
    int v24 = 136315138;
    uint64_t v25 = v10;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I RAT Type: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = (const char *)(a1 + 16);
    if (*(char *)(a1 + 39) < 0) {
      int v11 = *(const char **)v11;
    }
    int v24 = 136315138;
    uint64_t v25 = v11;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Vocoder Type: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = *(_DWORD *)(a1 + 44);
    int v24 = 67109120;
    LODWORD(v25) = v12;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Vocoder Bandwidth: %u", (uint8_t *)&v24, 8u);
    uint64_t v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = *(_DWORD *)(a1 + 40);
    int v24 = 67109120;
    LODWORD(v25) = v13;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Vocoder Bit Rate: %u", (uint8_t *)&v24, 8u);
  }
  if (*(unsigned char *)(a1 + 84))
  {
    int v14 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = *(_DWORD *)(a1 + 48);
      int v24 = 67109120;
      LODWORD(v25) = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I DL RSRP dBM: %d", (uint8_t *)&v24, 8u);
      int v14 = *a2;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = *(_DWORD *)(a1 + 52);
      int v24 = 67109120;
      LODWORD(v25) = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I DL RSSI dBM: %d", (uint8_t *)&v24, 8u);
      int v14 = *a2;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *(_DWORD *)(a1 + 56);
      int v24 = 67109120;
      LODWORD(v25) = v17;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I DL SNR dB: %d", (uint8_t *)&v24, 8u);
      int v14 = *a2;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = *(_DWORD *)(a1 + 60);
      int v24 = 67109120;
      LODWORD(v25) = v18;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I UL BLER: %u%%", (uint8_t *)&v24, 8u);
      int v14 = *a2;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v19 = *(_DWORD *)(a1 + 64);
      int v24 = 67109120;
      LODWORD(v25) = v19;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I DL BLER: %u%%", (uint8_t *)&v24, 8u);
      int v14 = *a2;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = *(_DWORD *)(a1 + 68);
      int v24 = 67109120;
      LODWORD(v25) = v20;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I TTI on/off: %u", (uint8_t *)&v24, 8u);
      int v14 = *a2;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = *(_DWORD *)(a1 + 72);
      int v24 = 67109120;
      LODWORD(v25) = v21;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I cDRX on/off: %u", (uint8_t *)&v24, 8u);
      int v14 = *a2;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v22 = *(_DWORD *)(a1 + 76);
      int v24 = 67109120;
      LODWORD(v25) = v22;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I cDRX cycle config: %ums", (uint8_t *)&v24, 8u);
      int v14 = *a2;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = *(_DWORD *)(a1 + 80);
      int v24 = 67109120;
      LODWORD(v25) = v23;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Time elapsed from last HO end: %u", (uint8_t *)&v24, 8u);
    }
  }
}

void sub_100393F44(NSObject **a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  int v8 = (char *)operator new(0x1D0uLL);
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *(void *)int v8 = off_1019C2B50;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "lazuli.lifetime");
  *((void *)v8 + 4) = 0;
  *((void *)v8 + 5) = 0;
  uint64_t v9 = *a1;
  *((void *)v8 + 6) = *a1;
  if (v9) {
    dispatch_retain(v9);
  }
  *((void *)v8 + 7) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v39, &__p);
  std::string v34 = a4;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v8 + 64), (const ctu::OsLogLogger *)v39);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v39);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  v39[0] = off_101999E18;
  v39[1] = sub_100394768;
  v39[3] = v39;
  *((void *)v8 + 9) = 0;
  int v11 = v8 + 24;
  if ((capabilities::ct::supportsGemini(v10) & 1) == 0) {
    operator new();
  }
  if (!*((void *)v8 + 9)) {
    operator new();
  }
  sub_10008863C(v39);
  uint64_t v12 = *(void *)(a2 + 8);
  *((void *)v8 + 10) = *(void *)a2;
  *((void *)v8 + 3) = off_1019C29B8;
  *((void *)v8 + 11) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "LazuliLifetimeManager");
  int v13 = *((void *)v8 + 6);
  dispatch_object_t v38 = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  dispatch_object_t object = 0;
  ctu::RestModule::RestModule();
  if (v38) {
    dispatch_release(v38);
  }
  if (v41 < 0) {
    operator delete(__p.var0);
  }
  sub_100058DB0(v35, "LazuliLifetimeManager");
  PersonalitiesTracker::PersonalitiesTracker();
  if (v36 < 0) {
    operator delete(v35[0]);
  }
  uint64_t v14 = a3[1];
  *((void *)v8 + 35) = *a3;
  *((void *)v8 + 36) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*((Registry **)v8 + 10));
  int v16 = ServiceMap;
  if (v17 < 0)
  {
    int v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v19 = 5381;
    do
    {
      uint64_t v17 = v19;
      unsigned int v20 = *v18++;
      uint64_t v19 = (33 * v19) ^ v20;
    }
    while (v20);
  }
  std::mutex::lock(ServiceMap);
  v35[0] = (void *)v17;
  int v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)v35);
  if (v21)
  {
    uint64_t v23 = v21[3];
    int v22 = (std::__shared_weak_count *)v21[4];
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v23 = 0;
    int v22 = 0;
  }
  std::mutex::unlock(v16);
  *((void *)v8 + 37) = v23;
  *((void *)v8 + 38) = v22;
  if (v22)
  {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v22);
  }
  int v24 = (std::mutex *)Registry::getServiceMap(*((Registry **)v8 + 10));
  uint64_t v25 = v24;
  if (v26 < 0)
  {
    std::string::size_type v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v28 = 5381;
    do
    {
      uint64_t v26 = v28;
      unsigned int v29 = *v27++;
      uint64_t v28 = (33 * v28) ^ v29;
    }
    while (v29);
  }
  std::mutex::lock(v24);
  v35[0] = (void *)v26;
  int v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)v35);
  if (v30)
  {
    uint64_t v32 = v30[3];
    int v31 = (std::__shared_weak_count *)v30[4];
    if (v31) {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v32 = 0;
    int v31 = 0;
  }
  std::mutex::unlock(v25);
  *((void *)v8 + 39) = v32;
  *((void *)v8 + 40) = v31;
  if (v31)
  {
    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v31);
  }
  (*(void (**)(void, char *, char *))(*(void *)*a3 + 80))(*a3, v8 + 48, v8 + 80);
  *(_OWORD *)(v8 + 344) = 0u;
  *(_OWORD *)(v8 + 360) = 0u;
  *((_WORD *)v8 + 188) = 1;
  v8[378] = 0;
  *((void *)v8 + 48) = 0;
  *((void *)v8 + 49) = 0;
  *((void *)v8 + 52) = 0;
  *((void *)v8 + 53) = 0;
  *((void *)v8 + 50) = 0;
  *((void *)v8 + 51) = v8 + 416;
  *((void *)v8 + 56) = 0;
  *((void *)v8 + 57) = 0;
  *((void *)v8 + 55) = v8 + 448;
  *((void *)v8 + 3) = off_1019C2BA0;
  int v33 = (std::__shared_weak_count *)*((void *)v8 + 5);
  if (v33)
  {
    if (v33->__shared_owners_ != -1) {
      goto LABEL_42;
    }
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 2, 1uLL, memory_order_relaxed);
    *((void *)v8 + 4) = v11;
    *((void *)v8 + 5) = v8;
    std::__shared_weak_count::__release_weak(v33);
  }
  else
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 2, 1uLL, memory_order_relaxed);
    *((void *)v8 + 4) = v11;
    *((void *)v8 + 5) = v8;
  }
  sub_10004D2C8((std::__shared_weak_count *)v8);
LABEL_42:
  __p.var0 = 0;
  __p.var1.fRef = 0;
  Registry::getServiceManager((uint64_t *)&__p, *(Registry **)a2);
  if (__p.var0)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
    operator new();
  }
  if (__p.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)__p.var1.fRef);
  }
  void *v34 = v11;
  v34[1] = v8;
}

void sub_10039453C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, ctu::OsLogLogger *a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, dispatch_object_t object, dispatch_object_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
}

const char *sub_100394768(int a1)
{
  uint64_t v1 = "lazuli.lifetime.?";
  if (a1 == 2) {
    uint64_t v1 = "lazuli.lifetime.2";
  }
  if (a1 == 1) {
    return "lazuli.lifetime.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_100394794(uint64_t a1)
{
  CFNumberRef v5 = 0;
  (*(void (**)(const void **__return_ptr))(*(void *)a1 + 40))(&v4);
  sub_1000057AC(&v5, &v4);
  sub_1000577C4(&v4);
  LOBYTE(v4) = 0;
  ctu::cf::assign((ctu::cf *)&v4, v5, v1);
  uint64_t v2 = v4;
  sub_100062778((const void **)&v5);
  return v2;
}

void sub_100394844(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100394868(void *a1)
{
  if (!a1[40])
  {
    uint64_t v2 = a1[5];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Creating Lazuli manager", buf, 2u);
    }
    uint64_t v3 = a1[3];
    uint64_t v7 = v3;
    if (v3) {
      dispatch_retain(v3);
    }
    uint64_t v6 = 0;
    operator new();
  }
  return 0;
}

void sub_100394D7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  unsigned int v20 = a10;
  a10 = 0;
  if (v20) {
    sub_1003996F0((uint64_t)&a10, v20);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  int v21 = *(void **)(v18 - 48);
  *(void *)(v18 - 48) = 0;
  if (v21) {
    sub_1003996F0(v18 - 48, v21);
  }
  int v22 = *(NSObject **)(v18 - 40);
  if (v22) {
    dispatch_release(v22);
  }
  _Unwind_Resume(exception_object);
}

void sub_100394E24(uint64_t a1, NSObject **a2)
{
  uint64_t v2 = *(void *)(a1 + 320);
  if (v2)
  {
    CFNumberRef v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Tearing down", buf, 2u);
      uint64_t v2 = *(void *)(a1 + 320);
    }
    uint64_t v6 = *a2;
    dispatch_group_t group = v6;
    if (v6)
    {
      dispatch_retain(v6);
      dispatch_group_enter(v6);
    }
    (*(void (**)(uint64_t, uint64_t, dispatch_group_t *))(*(void *)v2 + 16))(v2, 3, &group);
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
  }
}

void sub_100394F04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100394F28(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Clearing disable due to lockdown mode flag", v4, 2u);
  }
  return (*(uint64_t (**)(void, const __CFString *, void, void, const CFStringRef, const CFStringRef))(**(void **)(a1 + 288) + 16))(*(void *)(a1 + 288), @"DisabledDueToLockDownModeKey", 0, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
}

uint64_t sub_100394FE4(uint64_t a1, _DWORD **a2)
{
  uint64_t result = subscriber::makeSimSlotRange();
  uint64_t v6 = v19;
  CFNumberRef v5 = v20;
  if (v19 != v20)
  {
    uint64_t v7 = v21;
    while (1)
    {
      uint64_t result = v21(*v6);
      if (result) {
        break;
      }
      if (++v6 == v20)
      {
        uint64_t v6 = v20;
        break;
      }
    }
    int v8 = v20;
LABEL_7:
    while (v6 != v8)
    {
      unsigned int v9 = *v6;
      (*(void (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *v6);
      long long v18 = 0u;
      memset(v17, 0, sizeof(v17));
      for (uint64_t i = *(_DWORD **)(a1 + 360); ; i += 42)
      {
        if (i == *(_DWORD **)(a1 + 368))
        {
          char v11 = 0;
          goto LABEL_14;
        }
        if (*i == v9) {
          break;
        }
      }
      sub_10002E664((uint64_t)v17, (uint64_t)i);
      char v11 = 1;
LABEL_14:
      BYTE8(v18) = v11;
      long long v16 = 0u;
      memset(v15, 0, sizeof(v15));
      for (j = *a2; ; j += 42)
      {
        if (j == a2[1])
        {
          char v13 = 0;
          goto LABEL_20;
        }
        if (*j == v9) {
          break;
        }
      }
      sub_10002E664((uint64_t)v15, (uint64_t)j);
      char v13 = 1;
LABEL_20:
      BYTE8(v16) = v13;
      sub_100397998((uint64_t)v15);
      uint64_t result = sub_100397998((uint64_t)v17);
      uint64_t v14 = v6 + 1;
      uint64_t v6 = v5;
      if (v14 != v5)
      {
        while (1)
        {
          uint64_t result = v7(*v14);
          if (result) {
            break;
          }
          if (++v14 == v5)
          {
            uint64_t v6 = v5;
            goto LABEL_7;
          }
        }
        uint64_t v6 = v14;
      }
    }
  }
  return result;
}

void sub_100395190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

uint64_t sub_1003951A4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 416);
  if (v2 == (void *)(a1 + 424))
  {
LABEL_12:
    uint64_t v6 = *(NSObject **)(a1 + 40);
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v7) {
      return result;
    }
    *(_WORD *)int v22 = 0;
    unsigned int v9 = "#I Lazuli manager not needed --> no personalities active (*yet)";
LABEL_39:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v9, v22, 2u);
    return 0;
  }
  while (1)
  {
    if ((*((char *)v2 + 103) & 0x80000000) == 0)
    {
      if (*((unsigned char *)v2 + 103)) {
        break;
      }
      goto LABEL_6;
    }
    if (v2[11]) {
      break;
    }
LABEL_6:
    uint64_t v3 = (void *)v2[1];
    if (v3)
    {
      do
      {
        uint64_t v4 = v3;
        uint64_t v3 = (void *)*v3;
      }
      while (v3);
    }
    else
    {
      do
      {
        uint64_t v4 = (void *)v2[2];
        BOOL v5 = *v4 == (void)v2;
        uint64_t v2 = v4;
      }
      while (!v5);
    }
    uint64_t v2 = v4;
    if (v4 == (void *)(a1 + 424)) {
      goto LABEL_12;
    }
  }
  if (!*(unsigned char *)(a1 + 352))
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    BOOL v20 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v20) {
      return result;
    }
    *(_WORD *)int v22 = 0;
    unsigned int v9 = "#I Messages app is not installed";
    goto LABEL_39;
  }
  subscriber::makeSimSlotRange();
  int v10 = *(unsigned int **)v22;
  if (*(unsigned int **)v22 == v23) {
    goto LABEL_35;
  }
  while ((v24(*v10) & 1) == 0)
  {
    if (++v10 == v23)
    {
      int v10 = v23;
      break;
    }
  }
  if (v10 == v23)
  {
LABEL_35:
    uint64_t v6 = *(NSObject **)(a1 + 40);
    BOOL v19 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v19) {
      return result;
    }
    *(_WORD *)int v22 = 0;
    unsigned int v9 = "#I Feature is disabled for all slots";
    goto LABEL_39;
  }
  while (2)
  {
    uint64_t v11 = *v10;
    if ((sub_100394794(*(void *)(a1 + 288)) & 1) != 0 || *(unsigned char *)(a1 + 353) || *(unsigned char *)(a1 + 354)) {
      goto LABEL_29;
    }
    int v12 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 304) + 40))(*(void *)(a1 + 304), v11);
    __int16 v13 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 304) + 16))(*(void *)(a1 + 304), v11);
    int v14 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 304) + 48))(*(void *)(a1 + 304), v11);
    BOOL v15 = v13 != 0;
    if ((v13 & 0xFF00) == 0) {
      BOOL v15 = v14;
    }
    int v16 = v15 & v12;
    uint64_t v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v11);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Feature enabled: %{BOOL}d", buf, 8u);
      if (v16) {
        break;
      }
      goto LABEL_29;
    }
    if (!v16)
    {
LABEL_29:
      long long v18 = v10 + 1;
      int v10 = v23;
      if (v18 != v23)
      {
        int v10 = v18;
        while ((v24(*v10) & 1) == 0)
        {
          if (++v10 == v23)
          {
            int v10 = v23;
            break;
          }
        }
      }
      if (v10 == v23) {
        goto LABEL_35;
      }
      continue;
    }
    break;
  }
  int v21 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v11);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Feature is enabled", buf, 2u);
  }
  return 1;
}

void sub_100395574(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100395674(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10039B3F4;
  v5[3] = &unk_1019C2F48;
  _OWORD v5[4] = a1 + 8;
  void v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    *a2 = 0;
    a2[1] = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    unsigned int v9 = sub_10039B480;
    int v10 = &unk_1019C2F88;
    uint64_t v11 = a2;
    int v12 = &v6;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    unsigned int v9 = sub_10039B418;
    int v10 = &unk_1019C2F68;
    uint64_t v11 = a2;
    int v12 = &v6;
    dispatch_sync(v2, &block);
  }
}

void sub_100395790(uint64_t a1)
{
  if (sub_1005295EC())
  {
    if (sub_100529568()) {
      (*(void (**)(void, const __CFString *, const CFBooleanRef, void, const CFStringRef, const CFStringRef))(**(void **)(a1 + 288) + 16))(*(void *)(a1 + 288), @"DisabledDueToLockDownModeKey", kCFBooleanTrue, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    }
    else {
      sub_100394F28(a1);
    }
  }
  if (sub_1003951A4(a1) && sub_100394868((void *)a1))
  {
    (***(void (****)(void))(a1 + 320))(*(void *)(a1 + 320));
    (*(void (**)(void))(**(void **)(a1 + 320) + 8))(*(void *)(a1 + 320));
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    BOOL v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  v21[0] = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, v21);
  if (v8)
  {
    uint64_t v10 = v8[3];
    unsigned int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_34;
      }
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  unsigned int v9 = 0;
  char v11 = 1;
  if (!v10) {
    goto LABEL_34;
  }
LABEL_17:
  int v12 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v12 || (v13 = *(void *)(a1 + 8), (int v14 = std::__shared_weak_count::lock(v12)) == 0)) {
    sub_100088B9C();
  }
  BOOL v15 = v14;
  atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  int v16 = *(NSObject **)(a1 + 24);
  if (v16) {
    dispatch_retain(*(dispatch_object_t *)(a1 + 24));
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_100395B50;
  aBlock[3] = &unk_1019C2A08;
  aBlock[4] = a1;
  if (v16)
  {
    uint64_t v17 = _Block_copy(aBlock);
    long long v18 = v17;
    dispatch_object_t v24 = v16;
    v21[0] = (unint64_t)_NSConcreteStackBlock;
    v21[1] = 1174405120;
    v21[2] = (unint64_t)sub_10039B4E8;
    void v21[3] = (unint64_t)&unk_1019C2FA8;
    void v21[4] = v13;
    int v22 = v15;
    atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    if (v17) {
      BOOL v19 = _Block_copy(v17);
    }
    else {
      BOOL v19 = 0;
    }
    uint64_t v23 = v19;
    (*(void (**)(uint64_t, const char *, uint64_t, dispatch_object_t *, unint64_t *))(*(void *)v10 + 40))(v10, "commCenterSwitchState", 1, &v24, v21);
    if (v24) {
      dispatch_release(v24);
    }
    if (v23) {
      _Block_release(v23);
    }
    if (v22) {
      std::__shared_weak_count::__release_weak(v22);
    }
    if (v18) {
      _Block_release(v18);
    }
  }
  std::__shared_weak_count::__release_weak(v15);
LABEL_34:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100395AE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a20) {
    std::__shared_weak_count::__release_weak(a20);
  }
  std::string::size_type v27 = *(NSObject **)(v25 - 72);
  if (v27) {
    dispatch_release(v27);
  }
  if (v22) {
    _Block_release(v22);
  }
  std::__shared_weak_count::__release_weak(v23);
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100395B50(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  uint64_t v3 = *(unsigned int **)(v1 + 360);
  for (uint64_t i = *(unsigned int **)(v1 + 368); v3 != i; v3 += 42)
  {
    if (v3[2] == 5)
    {
      uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(v1 + 304) + 16))(*(void *)(v1 + 304), *v3);
      if ((unsigned __int16)result >= 0x100u) {
        operator new();
      }
    }
  }
  return result;
}

void sub_100395D98(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL sub_100395DF0(uint64_t a1, int a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v7 = a1;
  int v8 = a2;
  uint64_t v9 = v4;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  uint64_t v10[2] = sub_10039B67C;
  uint64_t v10[3] = &unk_1019C2FD8;
  v10[4] = a1 + 8;
  v10[5] = &v7;
  char v11 = v10;
  BOOL v5 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    char v18 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    int v14 = sub_10005AC6C;
    BOOL v15 = &unk_1019C3018;
    int v16 = &v18;
    uint64_t v17 = &v11;
    dispatch_async_and_wait(v5, &block);
  }
  else
  {
    char v18 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    int v14 = sub_100059F08;
    BOOL v15 = &unk_1019C2FF8;
    int v16 = &v18;
    uint64_t v17 = &v11;
    dispatch_sync(v5, &block);
  }
  return v18 != 0;
}

BOOL sub_100395F60(uint64_t a1, int a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v7 = a1;
  int v8 = a2;
  uint64_t v9 = v4;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  uint64_t v10[2] = sub_10039B79C;
  uint64_t v10[3] = &unk_1019C3038;
  v10[4] = a1 + 8;
  v10[5] = &v7;
  char v11 = v10;
  BOOL v5 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    char v18 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    int v14 = sub_10005AC6C;
    BOOL v15 = &unk_1019C3018;
    int v16 = &v18;
    uint64_t v17 = &v11;
    dispatch_async_and_wait(v5, &block);
  }
  else
  {
    char v18 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    int v14 = sub_100059F08;
    BOOL v15 = &unk_1019C2FF8;
    int v16 = &v18;
    uint64_t v17 = &v11;
    dispatch_sync(v5, &block);
  }
  return v18 != 0;
}

void sub_1003960D0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      BOOL v5 = v4;
      if (a1[5])
      {
        (*(void (**)(void))(**(void **)(v3 + 320) + 24))(*(void *)(v3 + 320));
        uint64_t v6 = *(std::__shared_weak_count **)(v3 + 328);
        *(void *)(v3 + 320) = 0;
        *(void *)(v3 + 328) = 0;
        if (v6) {
          sub_10004D2C8(v6);
        }
        uint64_t v7 = *(NSObject **)(v3 + 336);
        *(void *)(v3 + 336) = 0;
        if (v7) {
          dispatch_release(v7);
        }
        uint64_t v8 = *(void *)(v3 + 344);
        *(void *)(v3 + 344) = 0;
        if (v8) {
          (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
        }
        uint64_t v9 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v10 = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Tear down complete", v10, 2u);
        }
        sub_100395790(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1003961E4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1003961F8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100396214(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_100396224(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  sub_100394F28(a1);
  uint64_t v7 = *(void *)(a1 + 320);
  uint64_t v8 = *v6;
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    if (v9)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Disabling Lazuli", buf, 2u);
    }
    if (!(*(unsigned int (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 304) + 24))(*(void *)(a1 + 304), a2, 1, a3))return 0; {
    if (!*(void *)(a1 + 336) && (sub_1003951A4(a1) & 1) == 0)
    }
    {
      uint64_t v10 = dispatch_group_create();
      char v11 = v10;
      uint64_t v17 = v10;
      if (v10)
      {
        dispatch_retain(v10);
        dispatch_group_enter(v11);
      }
      sub_100394E24(a1, &v17);
      if (v11)
      {
        dispatch_group_leave(v11);
        dispatch_release(v11);
      }
      int v12 = *(std::__shared_weak_count **)(a1 + 16);
      if (v12)
      {
        uint64_t v13 = std::__shared_weak_count::lock(v12);
        if (v13)
        {
          atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v13);
          operator new();
        }
      }
      sub_100088B9C();
    }
    return 1;
  }
  if (v9)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Lazuli is already disabled", buf, 2u);
  }
  if (a3 != 3) {
    return 1;
  }
  uint64_t v14 = *(void *)(a1 + 304);
  uint64_t v15 = 1;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v14 + 24))(v14, a2, 1, 3);
  return v15;
}

void sub_100396494(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_weak(v2);
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(a1);
}

BOOL sub_1003964DC(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10039BB0C;
  v7[3] = &unk_1019C3058;
  void v7[4] = a1 + 8;
  v7[5] = &v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    char v11 = sub_10005AC6C;
    int v12 = &unk_1019C3018;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    char v11 = sub_100059F08;
    int v12 = &unk_1019C2FF8;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

uint64_t sub_100396614(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v7 = *(void *)(a1 + 320);
  uint64_t v8 = *v6;
  BOOL v9 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    if (v9)
    {
      *(_WORD *)int v12 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Disabling business messaging", v12, 2u);
    }
    return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 304) + 64))(*(void *)(a1 + 304), a2, 1, a3);
  }
  else
  {
    if (v9)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Lazuli is disabled", buf, 2u);
    }
    if (a3 == 3)
    {
      uint64_t v10 = 1;
      (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 304) + 64))(*(void *)(a1 + 304), a2, 1, 3);
    }
    else
    {
      return 1;
    }
  }
  return v10;
}

BOOL sub_100396774(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10039BB20;
  v7[3] = &unk_1019C3078;
  void v7[4] = a1 + 8;
  v7[5] = &v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    char v11 = sub_10005AC6C;
    int v12 = &unk_1019C3018;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    char v11 = sub_100059F08;
    int v12 = &unk_1019C2FF8;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

void sub_1003968AC(uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  int v6 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Fetching system config", buf, 2u);
  }
  uint64_t v8 = a1;
  int v9 = a2;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  uint64_t v10[2] = sub_10039BB34;
  uint64_t v10[3] = &unk_1019C3098;
  v10[4] = a1 + 8;
  v10[5] = &v8;
  char v11 = v10;
  uint64_t v7 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    a3[28] = 0u;
    a3[29] = 0u;
    a3[26] = 0u;
    a3[27] = 0u;
    a3[24] = 0u;
    a3[25] = 0u;
    a3[22] = 0u;
    a3[23] = 0u;
    a3[20] = 0u;
    a3[21] = 0u;
    a3[18] = 0u;
    a3[19] = 0u;
    a3[16] = 0u;
    a3[17] = 0u;
    a3[14] = 0u;
    a3[15] = 0u;
    a3[12] = 0u;
    a3[13] = 0u;
    a3[10] = 0u;
    a3[11] = 0u;
    a3[8] = 0u;
    a3[9] = 0u;
    a3[6] = 0u;
    a3[7] = 0u;
    a3[4] = 0u;
    a3[5] = 0u;
    a3[2] = 0u;
    a3[3] = 0u;
    *a3 = 0u;
    a3[1] = 0u;
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    uint64_t v14 = sub_10039C5EC;
    char v15 = &unk_1019C30D8;
    int v16 = a3;
    uint64_t v17 = &v11;
    dispatch_async_and_wait(v7, buf);
  }
  else
  {
    a3[28] = 0u;
    a3[29] = 0u;
    a3[26] = 0u;
    a3[27] = 0u;
    a3[24] = 0u;
    a3[25] = 0u;
    a3[22] = 0u;
    a3[23] = 0u;
    a3[20] = 0u;
    a3[21] = 0u;
    a3[18] = 0u;
    a3[19] = 0u;
    a3[16] = 0u;
    a3[17] = 0u;
    a3[14] = 0u;
    a3[15] = 0u;
    a3[12] = 0u;
    a3[13] = 0u;
    a3[10] = 0u;
    a3[11] = 0u;
    a3[8] = 0u;
    a3[9] = 0u;
    a3[6] = 0u;
    a3[7] = 0u;
    a3[4] = 0u;
    a3[5] = 0u;
    a3[2] = 0u;
    a3[3] = 0u;
    *a3 = 0u;
    a3[1] = 0u;
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    uint64_t v14 = sub_10039BFD4;
    char v15 = &unk_1019C30B8;
    int v16 = a3;
    uint64_t v17 = &v11;
    dispatch_sync(v7, buf);
  }
}

void sub_100396AC8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100396BC8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v6 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(*a3 + 52));
  uint64_t v7 = *v6;
  if (*a3)
  {
    uint64_t v8 = v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(unsigned __int8 *)(a2 + 23);
      BOOL v10 = (v9 & 0x80u) != 0;
      if ((v9 & 0x80u) != 0) {
        uint64_t v9 = *(void *)(a2 + 8);
      }
      if (v10) {
        char v11 = *(const char **)a2;
      }
      else {
        char v11 = (const char *)a2;
      }
      if (v9) {
        int v12 = v11;
      }
      else {
        int v12 = "<invalid>";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = asString();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Personality event: [%s], state: [%s]", buf, 0x16u);
    }
    int v13 = *(unsigned __int8 *)(a2 + 24);
    BOOL v14 = v13 == 6 || v13 == 2;
    if (v14)
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v15 = *a3;
      if (*(char *)(*a3 + 47) < 0)
      {
        sub_10004FC84(buf, *(void **)(v15 + 24), *(void *)(v15 + 32));
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)(v15 + 24);
        *(void *)&uint8_t buf[16] = *(void *)(v15 + 40);
      }
      char v18 = *v8;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v19 = buf;
        if ((buf[23] & 0x80u) != 0) {
          BOOL v19 = *(uint8_t **)buf;
        }
        int v25 = 141558275;
        uint64_t v26 = 1752392040;
        __int16 v27 = 2081;
        uint64_t v28 = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Subscription removed for: %{private, mask.hash}s", (uint8_t *)&v25, 0x16u);
      }
      if (*(void *)(a1 + 320))
      {
        BOOL v20 = *(unsigned __int8 **)(a1 + 416);
        if (v20 != (unsigned __int8 *)(a1 + 424))
        {
          int v21 = (unsigned __int8 *)(*a3 + 24);
          while (!sub_10001D294(v20 + 32, v21))
          {
            int v22 = (unsigned __int8 *)*((void *)v20 + 1);
            if (v22)
            {
              do
              {
                uint64_t v23 = v22;
                int v22 = *(unsigned __int8 **)v22;
              }
              while (v22);
            }
            else
            {
              do
              {
                uint64_t v23 = (unsigned __int8 *)*((void *)v20 + 2);
                BOOL v14 = *(void *)v23 == (void)v20;
                BOOL v20 = v23;
              }
              while (!v14);
            }
            BOOL v20 = v23;
            if (v23 == (unsigned __int8 *)(a1 + 424)) {
              goto LABEL_44;
            }
          }
          uint64_t v24 = SlotIdFromPersonalityId();
          (*(void (**)(void, uint64_t, void *))(**(void **)(a1 + 320) + 40))(*(void *)(a1 + 320), v24, (void *)v20 + 10);
        }
      }
LABEL_44:
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
    }
    else if (v13 == 1)
    {
      int v16 = *(_DWORD *)(*a3 + 52);
      if (v16) {
        BOOL v17 = v16 == 3;
      }
      else {
        BOOL v17 = 1;
      }
      if (!v17) {
        sub_100395790(a1);
      }
    }
  }
  else if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Invalid info for personality event", buf, 2u);
  }
}

void sub_100396EC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100396EEC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v19) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Managed configuration changed", (uint8_t *)&v19, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  BOOL v19 = (unsigned int *)v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v19);
  if (v9)
  {
    uint64_t v11 = v9[3];
    BOOL v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_9;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  BOOL v10 = 0;
  char v12 = 1;
  if (!v11)
  {
LABEL_9:
    int v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not find managed configuration", (uint8_t *)&v19, 2u);
    }
    goto LABEL_27;
  }
LABEL_13:
  *(unsigned char *)(a1 + 353) = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 80))(v11) ^ 1;
  if ((*(uint64_t (**)(uint64_t))(*(void *)v11 + 80))(v11))
  {
    sub_100395790(a1);
  }
  else
  {
    subscriber::makeSimSlotRange();
    uint64_t v15 = v19;
    BOOL v14 = v20;
    if (v19 != v20)
    {
      int v16 = v21;
      while ((v16(*v15) & 1) == 0)
      {
        if (++v15 == v14)
        {
          uint64_t v15 = v14;
          break;
        }
      }
      BOOL v17 = v20;
LABEL_21:
      while (v15 != v17)
      {
        sub_100396224(a1, *v15, 1);
        char v18 = v15 + 1;
        uint64_t v15 = v14;
        if (v18 != v14)
        {
          uint64_t v15 = v18;
          while ((v16(*v15) & 1) == 0)
          {
            if (++v15 == v14)
            {
              uint64_t v15 = v14;
              goto LABEL_21;
            }
          }
        }
      }
    }
  }
LABEL_27:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100397148(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100397174(uint64_t a1, uint64_t a2)
{
  char v2 = *(void **)(a1 + 416);
  uint64_t v3 = (void *)(a1 + 424);
  if (v2 != (void *)(a1 + 424))
  {
    int v6 = (void **)(a2 + 8);
    do
    {
      uint64_t v7 = (long long *)(v2 + 4);
      if (v6 == sub_100046F68(a2, (void **)v2 + 4))
      {
        if (*((char *)v2 + 55) < 0)
        {
          sub_10004FC84(&__dst, (void *)v2[4], v2[5]);
        }
        else
        {
          long long __dst = *v7;
          uint64_t v31 = v2[6];
        }
        sub_10039CAC4((char *)v22, (long long *)(v2 + 7));
        sub_10039C93C(a1, (uint64_t)&__dst, (uint64_t)v22);
        if (v29 < 0) {
          operator delete(__p);
        }
        if (v27 < 0) {
          operator delete(v26);
        }
        if (v25 < 0) {
          operator delete(v24);
        }
        if (v23 < 0) {
          operator delete(v22[0]);
        }
        if ((SHIBYTE(v31) & 0x80000000) == 0) {
          goto LABEL_32;
        }
        p_dst = (void **)&__dst;
      }
      else
      {
        if (operator==()) {
          goto LABEL_32;
        }
        if (*((char *)v2 + 55) < 0)
        {
          sub_10004FC84(&v20, (void *)v2[4], v2[5]);
        }
        else
        {
          long long v20 = *v7;
          uint64_t v21 = v2[6];
        }
        sub_10039CAC4((char *)v12, (long long *)(v2 + 7));
        sub_10039C93C(a1, (uint64_t)&v20, (uint64_t)v12);
        if (v19 < 0) {
          operator delete(v18);
        }
        if (v17 < 0) {
          operator delete(v16);
        }
        if (v15 < 0) {
          operator delete(v14);
        }
        if (v13 < 0) {
          operator delete(v12[0]);
        }
        if ((SHIBYTE(v21) & 0x80000000) == 0) {
          goto LABEL_32;
        }
        p_dst = (void **)&v20;
      }
      operator delete(*p_dst);
LABEL_32:
      uint64_t v9 = (void *)v2[1];
      if (v9)
      {
        do
        {
          BOOL v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          BOOL v10 = (void *)v2[2];
          BOOL v11 = *v10 == (void)v2;
          char v2 = v10;
        }
        while (!v11);
      }
      char v2 = v10;
    }
    while (v10 != v3);
  }
}

void sub_10039735C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  _Unwind_Resume(exception_object);
}

void sub_100397420(uint64_t a1, uint64_t a2)
{
  char v2 = *(void **)(a1 + 384);
  uint64_t v3 = (void *)(a1 + 392);
  if (v2 != (void *)(a1 + 392))
  {
    unint64_t v5 = (void *)(a2 + 8);
    do
    {
      uint64_t v6 = *v5;
      if (*v5)
      {
        uint64_t v7 = *((unsigned int *)v2 + 8);
        unsigned int v8 = v5;
        do
        {
          int v9 = *(_DWORD *)(v6 + 32);
          BOOL v10 = v9 < (int)v7;
          if (v9 >= (int)v7) {
            BOOL v11 = (uint64_t *)v6;
          }
          else {
            BOOL v11 = (uint64_t *)(v6 + 8);
          }
          if (!v10) {
            unsigned int v8 = (void *)v6;
          }
          uint64_t v6 = *v11;
        }
        while (*v11);
        if (v8 != v5 && (int)v7 >= *((_DWORD *)v8 + 8))
        {
          if (rest::operator==()) {
            goto LABEL_35;
          }
          uint64_t v12 = *((unsigned int *)v2 + 8);
          if (*((char *)v2 + 71) < 0)
          {
            sub_10004FC84(&v27, (void *)v2[6], v2[7]);
          }
          else
          {
            long long v27 = *((_OWORD *)v2 + 3);
            uint64_t v28 = v2[8];
          }
          if (*((char *)v2 + 95) < 0)
          {
            sub_10004FC84(&v29, (void *)v2[9], v2[10]);
          }
          else
          {
            long long v29 = *(_OWORD *)(v2 + 9);
            uint64_t v30 = v2[11];
          }
          int v22 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v12);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v23 = asString();
            uint64_t v24 = asString();
            if (v28 >= 0) {
              char v25 = &v27;
            }
            else {
              char v25 = (long long *)v27;
            }
            uint64_t v26 = &v29;
            if (v30 < 0) {
              uint64_t v26 = (long long *)v29;
            }
            *(_DWORD *)long long buf = 136315906;
            uint64_t v37 = v23;
            __int16 v38 = 2080;
            uint64_t v39 = v24;
            __int16 v40 = 2080;
            char v41 = v25;
            __int16 v42 = 2080;
            int v43 = v26;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle updated, bundle change type: %s, bundle technology type: %s, bundle id: %s, bundle version: %s", buf, 0x2Au);
          }
          sub_100395790(a1);
          if (SHIBYTE(v30) < 0) {
            operator delete((void *)v29);
          }
          char v18 = (void **)&v27;
          if ((SHIBYTE(v28) & 0x80000000) == 0) {
            goto LABEL_35;
          }
          goto LABEL_34;
        }
      }
      else
      {
        uint64_t v7 = *((unsigned int *)v2 + 8);
      }
      __int16 v31 = *((_WORD *)v2 + 20);
      if (*((char *)v2 + 71) < 0)
      {
        sub_10004FC84(&v32, (void *)v2[6], v2[7]);
      }
      else
      {
        long long v32 = *((_OWORD *)v2 + 3);
        uint64_t v33 = v2[8];
      }
      if (*((char *)v2 + 95) < 0)
      {
        sub_10004FC84(&__p, (void *)v2[9], v2[10]);
      }
      else
      {
        long long __p = *(_OWORD *)(v2 + 9);
        uint64_t v35 = v2[11];
      }
      char v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = asString();
        uint64_t v15 = asString();
        if (v33 >= 0) {
          int v16 = &v32;
        }
        else {
          int v16 = (long long *)v32;
        }
        if (v35 >= 0) {
          p_p = &__p;
        }
        else {
          p_p = (long long *)__p;
        }
        *(_DWORD *)long long buf = 136315906;
        uint64_t v37 = v14;
        __int16 v38 = 2080;
        uint64_t v39 = v15;
        __int16 v40 = 2080;
        char v41 = v16;
        __int16 v42 = 2080;
        int v43 = p_p;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle updated, bundle change type: %s, bundle technology type: %s, bundle id: %s, bundle version: %s", buf, 0x2Au);
      }
      sub_100395790(a1);
      if (SHIBYTE(v35) < 0) {
        operator delete((void *)__p);
      }
      char v18 = (void **)&v32;
      if ((SHIBYTE(v33) & 0x80000000) == 0) {
        goto LABEL_35;
      }
LABEL_34:
      operator delete(*v18);
LABEL_35:
      char v19 = (void *)v2[1];
      if (v19)
      {
        do
        {
          long long v20 = v19;
          char v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          long long v20 = (void *)v2[2];
          BOOL v21 = *v20 == (void)v2;
          char v2 = v20;
        }
        while (!v21);
      }
      char v2 = v20;
    }
    while (v20 != v3);
  }
}

void sub_100397804(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a19 < 0) {
    operator delete(*v38);
  }
  _Unwind_Resume(exception_object);
}

void sub_10039786C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100397960(uint64_t a1)
{
  sub_100399020(a1);

  operator delete();
}

uint64_t sub_100397998(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 168))
  {
    if (*(char *)(a1 + 167) < 0) {
      operator delete(*(void **)(a1 + 144));
    }
    if (*(char *)(a1 + 143) < 0) {
      operator delete(*(void **)(a1 + 120));
    }
    if (*(char *)(a1 + 119) < 0) {
      operator delete(*(void **)(a1 + 96));
    }
    if (*(char *)(a1 + 95) < 0) {
      operator delete(*(void **)(a1 + 72));
    }
    uint64_t v4 = (void **)(a1 + 40);
    sub_10002E39C(&v4);
    char v2 = *(void **)(a1 + 16);
    if (v2)
    {
      *(void *)(a1 + 24) = v2;
      operator delete(v2);
    }
  }
  return a1;
}

void sub_100397A2C(uint64_t a1, uint64_t a2, void *__src, int a4)
{
  size_t v7 = __src[2];
  size_t __n = v7;
  __srca[0] = 0;
  if (v7 < 0x11)
  {
    memcpy(__srca, __src, v7);
    size_t v13 = __n;
    v12[0] = 0;
    if (__n < 0x11)
    {
      memcpy(v12, __srca, __n);
      __dst[2] = v13;
      __dst[0] = 0;
      if (v13 <= 0x10)
      {
        memcpy(__dst, v12, v13);
        int v11 = a4;
        sub_100397C78(a1, a2, (uint64_t)__dst);
      }
      operator new[]();
    }
    operator new[]();
  }
  operator new[]();
}

void sub_100397C08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a17) {
    operator delete[]();
  }
  if (v17 >= 0x11)
  {
    if (a10) {
      operator delete[]();
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100397C78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(char *)(a2 + 23);
  BOOL v5 = v4 < 0;
  if (v4 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *(void *)a2;
  }
  uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
  if (v5) {
    uint64_t v7 = *(void *)(a2 + 8);
  }
  uint64_t v8 = v6 + v7;
  size_t v9 = *(void *)(a3 + 16);
  v16[2] = v9;
  v16[0] = 0;
  if (v9 < 0x11)
  {
    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    long long v11 = 0u;
    memcpy(v16, (const void *)a3, v9);
    int v17 = *(_DWORD *)(a3 + 24);
    sub_100397F78(v10, v6, v8, (uint64_t)v16);
  }
  operator new[]();
}

void sub_100397E68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  sub_100398C1C(&a9);
  sub_100398C1C(&a19);
  sub_100398C1C(&a41);
  sub_100398C1C((uint64_t *)(v41 - 176));
  _Unwind_Resume(a1);
}

uint64_t sub_100397EF0(uint64_t a1, uint64_t *a2)
{
  *(void *)a1 = 0;
  uint64_t v4 = *a2;
  if (*a2)
  {
    *(void *)a1 = v4;
    if (v4)
    {
      long long v5 = *(_OWORD *)(a2 + 1);
      *(void *)(a1 + 24) = a2[3];
      *(_OWORD *)(a1 + 8) = v5;
    }
    else
    {
      (*(void (**)(uint64_t *, uint64_t, void))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, a1 + 8, 0);
    }
  }
  *(_OWORD *)(a1 + 32) = *((_OWORD *)a2 + 2);
  *(void *)(a1 + 48) = a2[6];
  *(void *)(a1 + 56) = a2[7];
  *(unsigned char *)(a1 + 64) = *((unsigned char *)a2 + 64);
  return a1;
}

void sub_100397F78(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  size_t v6 = *(void *)(a4 + 16);
  v7[2] = v6;
  v7[0] = 0;
  if (v6 < 0x11)
  {
    memcpy(v7, (const void *)a4, v6);
    int v8 = *(_DWORD *)(a4 + 24);
    sub_1003980D4(a1, (uint64_t)v7);
  }
  operator new[]();
}

void sub_100398090(_Unwind_Exception *a1)
{
  sub_100398C1C(v1);
  _Unwind_Resume(a1);
}

void sub_1003980D4(void *a1, uint64_t a2)
{
  size_t v4 = *(void *)(a2 + 16);
  v5[2] = v4;
  v5[0] = 0;
  if (v4 < 0x11)
  {
    memcpy(v5, (const void *)a2, v4);
    int v6 = *(_DWORD *)(a2 + 24);
    sub_100398268(a1, (uint64_t)v5);
  }
  operator new[]();
}

void sub_1003981C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, unint64_t a12)
{
  if (a12 >= 0x11)
  {
    if (a10) {
      operator delete[]();
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003981F4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (*(void *)a1)
  {
    uint64_t result = sub_100398B84((void *)a1);
    uint64_t v2 = *(void *)(a1 + 56);
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 56);
    uint64_t result = v4;
  }
  BOOL v5 = result == v2 && v4 == v2;
  if (v5 && *(void *)(a1 + 40) == v2) {
    *(unsigned char *)(a1 + 64) = 1;
  }
  *(void *)(a1 + 32) = *(void *)(a1 + 48);
  *(void *)(a1 + 40) = result;
  *(void *)(a1 + 48) = v4;
  return result;
}

void sub_100398268(void *a1, uint64_t a2)
{
  *a1 = 0;
  size_t v4 = *(void *)(a2 + 16);
  v5[2] = v4;
  v5[0] = 0;
  if (v4 < 0x11)
  {
    memcpy(v5, (const void *)a2, v4);
    int v6 = *(_DWORD *)(a2 + 24);
    sub_100398388((uint64_t)a1, (uint64_t)v5);
  }
  operator new[]();
}

void sub_100398354(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, unint64_t a12)
{
  if (a12 >= 0x11)
  {
    if (a10) {
      operator delete[]();
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100398388(uint64_t a1, uint64_t a2)
{
  size_t v3 = *(void *)(a2 + 16);
  _OWORD v4[2] = v3;
  v4[0] = 0;
  if (v3 < 0x11)
  {
    memcpy(v4, (const void *)a2, v3);
    int v5 = *(_DWORD *)(a2 + 24);
    sub_1003984E4((uint64_t)off_1019C2B20, (uint64_t)v4);
  }
  operator new[]();
}

void sub_100398488(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, unint64_t a12)
{
  if (a12 >= 0x11)
  {
    if (a10) {
      operator delete[]();
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003984BC(uint64_t result, _WORD *a2, int a3)
{
  if (a3 != 4) {
    return sub_10039860C(result, a2, a3);
  }
  a2[4] = 0;
  return result;
}

char *sub_1003984DC(uint64_t *a1, char *a2, char *a3)
{
  return sub_1003987B8(*a1, a2, a3);
}

void sub_1003984E4(uint64_t a1, uint64_t a2)
{
  size_t v4 = *(void *)(a2 + 16);
  v5[2] = v4;
  v5[0] = 0;
  if (v4 < 0x11)
  {
    memcpy(v5, (const void *)a2, v4);
    int v6 = *(_DWORD *)(a2 + 24);
    sub_1003989A0(a1, (uint64_t)v5);
  }
  operator new[]();
}

void sub_1003985D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, unint64_t a12)
{
  if (a12 >= 0x11)
  {
    if (a10) {
      operator delete[]();
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10039860C(uint64_t result, _WORD *a2, int a3)
{
  size_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      int v5 = *(void **)a2;
      if (*(void *)a2)
      {
        if (v5[2] >= 0x11uLL)
        {
          if (*v5) {
            operator delete[]();
          }
        }
        operator delete();
      }
      goto LABEL_10;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost9algorithm6detail13token_finderFINS1_10is_any_ofFIcEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost9algorithm6detail13token_finderFINS1_10is_any_ofFIcEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_10:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

void sub_100398784()
{
}

char *sub_1003987B8(uint64_t a1, char *a2, char *a3)
{
  size_t v6 = *(void *)(a1 + 16);
  unint64_t v10 = v6;
  v9[0] = 0;
  if (v6 >= 0x11) {
    operator new[]();
  }
  memcpy(v9, (const void *)a1, v6);
  while (a2 != a3)
  {
    if (sub_100398938(v9, *a2)) {
      goto LABEL_8;
    }
    ++a2;
  }
  a2 = a3;
LABEL_8:
  if (v10 >= 0x11 && v9[0]) {
    operator delete[]();
  }
  if (a2 == a3) {
    return a3;
  }
  if (!*(_DWORD *)(a1 + 24))
  {
    uint64_t v7 = a2;
    do
    {
      if (!sub_100398938((void *)a1, *v7)) {
        break;
      }
      ++v7;
    }
    while (v7 != a3);
  }
  return a2;
}

void sub_1003988FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

BOOL sub_100398938(void *a1, int a2)
{
  unint64_t v2 = a1[2];
  if (v2 >= 0x11)
  {
    a1 = (void *)*a1;
    size_t v3 = (void *)((char *)a1 + v2);
  }
  else
  {
    size_t v3 = (void *)((char *)a1 + v2);
    if (!v2) {
      return a1 != v3 && *(char *)a1 <= a2;
    }
  }
  do
  {
    size_t v4 = (char *)a1 + (v2 >> 1);
    int v6 = *v4;
    int v5 = v4 + 1;
    unint64_t v7 = v2 >> 1;
    v2 += ~(v2 >> 1);
    if (v6 >= a2) {
      unint64_t v2 = v7;
    }
    else {
      a1 = v5;
    }
  }
  while (v2);
  return a1 != v3 && *(char *)a1 <= a2;
}

void sub_1003989A0(uint64_t a1, uint64_t a2)
{
  size_t v3 = *(void *)(a2 + 16);
  _OWORD v4[2] = v3;
  v4[0] = 0;
  if (v3 < 0x11)
  {
    memcpy(v4, (const void *)a2, v3);
    int v5 = *(_DWORD *)(a2 + 24);
    sub_100398AC4();
  }
  operator new[]();
}

void sub_100398A90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, unint64_t a12)
{
  if (a12 >= 0x11)
  {
    if (a10) {
      operator delete[]();
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100398AC4()
{
}

void sub_100398B60()
{
}

uint64_t sub_100398B84(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  uint64_t v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  unint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_100398C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

uint64_t *sub_100398C1C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      size_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t *sub_100398C70(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_100397EF0((uint64_t)v7, a2);
  sub_100397EF0((uint64_t)v6, a3);
  sub_100398D00(a1, (uint64_t)v7, (uint64_t)v6);
  sub_100398C1C(v6);
  sub_100398C1C(v7);
  return a1;
}

void sub_100398CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
}

BOOL sub_100398D00(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  int v22 = a1;
  uint64_t v23 = 0;
  uint64_t v6 = (uint64_t)(a1 + 2);
  while (1)
  {
    BOOL result = sub_100398EC4(a2, a3);
    if (result) {
      break;
    }
    sub_10012CD04(__p, *(char **)(a2 + 32), *(char **)(a2 + 40), *(void *)(a2 + 40) - *(void *)(a2 + 32));
    unint64_t v9 = a1[1];
    unint64_t v8 = a1[2];
    if (v9 >= v8)
    {
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - *a1) >> 3);
      unint64_t v12 = v11 + 1;
      if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_1000D8578();
      }
      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - *a1) >> 3);
      if (2 * v13 > v12) {
        unint64_t v12 = 2 * v13;
      }
      if (v13 >= 0x555555555555555) {
        unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v14 = v12;
      }
      void v24[4] = v6;
      if (v14) {
        long long v15 = (char *)sub_10004812C(v6, v14);
      }
      else {
        long long v15 = 0;
      }
      int v16 = &v15[24 * v11];
      v24[0] = v15;
      v24[1] = v16;
      v24[3] = &v15[24 * v14];
      long long v17 = *(_OWORD *)__p;
      *((void *)v16 + 2) = v21;
      *(_OWORD *)int v16 = v17;
      __p[1] = 0;
      uint64_t v21 = 0;
      __p[0] = 0;
      void v24[2] = v16 + 24;
      sub_100048204(a1, v24);
      uint64_t v18 = a1[1];
      sub_100048174((uint64_t)v24);
      int v19 = SHIBYTE(v21);
      a1[1] = v18;
      if (v19 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      long long v10 = *(_OWORD *)__p;
      *(void *)(v9 + 16) = v21;
      *(_OWORD *)unint64_t v9 = v10;
      a1[1] = v9 + 24;
    }
    sub_1003981F4(a2);
  }
  return result;
}

void sub_100398E80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void **a15, uint64_t a16, char a17)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_100047F64(&a15);
  _Unwind_Resume(a1);
}

BOOL sub_100398EC4(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1) {
    BOOL v4 = *(unsigned char *)(a1 + 64) != 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!*(void *)a2)
  {
    BOOL v5 = 1;
    return v4 ^ v5 ^ 1;
  }
  BOOL v5 = *(unsigned char *)(a2 + 64) != 0;
  if (*(unsigned char *)(a2 + 64)) {
    int v6 = 1;
  }
  else {
    int v6 = v4;
  }
  if (v6 == 1) {
    return v4 ^ v5 ^ 1;
  }
  unint64_t v7 = *(const void **)(a1 + 32);
  unint64_t v8 = *(const void **)(a2 + 32);
  size_t v9 = *(void *)(a1 + 40) - (void)v7;
  return v9 == *(void *)(a2 + 40) - (void)v8
      && !memcmp(v7, v8, v9)
      && *(void *)(a1 + 48) == *(void *)(a2 + 48)
      && *(void *)(a1 + 56) == *(void *)(a2 + 56);
}

void *sub_100398F7C(void *__dst, uint64_t a2)
{
  *long long __dst = 0;
  BOOL v4 = *(unsigned char **)a2;
  BOOL v5 = *(unsigned char **)(a2 + 8);
  __dst[2] = v5 - v4;
  if ((unint64_t)(v5 - v4) >= 0x11) {
    operator new[]();
  }
  if (v5 != v4) {
    memmove(__dst, v4, v5 - v4);
  }
  std::__sort<std::__less<char,char> &,char *>();
  return __dst;
}

uint64_t sub_100399020(uint64_t a1)
{
  *(void *)a1 = off_1019C29B8;
  sub_100399174(a1 + 416, *(void **)(a1 + 424));
  sub_100087F94(a1 + 384, *(void **)(a1 + 392));
  unint64_t v13 = (void **)(a1 + 360);
  sub_10008A88C(&v13);
  uint64_t v2 = *(void *)(a1 + 344);
  *(void *)(a1 + 344) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  size_t v3 = *(NSObject **)(a1 + 336);
  if (v3) {
    dispatch_release(v3);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 328);
  if (v4) {
    sub_10004D2C8(v4);
  }
  BOOL v5 = *(std::__shared_weak_count **)(a1 + 312);
  if (v5) {
    sub_10004D2C8(v5);
  }
  int v6 = *(std::__shared_weak_count **)(a1 + 296);
  if (v6) {
    sub_10004D2C8(v6);
  }
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 280);
  if (v7) {
    sub_10004D2C8(v7);
  }
  unint64_t v8 = *(std::__shared_weak_count **)(a1 + 264);
  if (v8) {
    sub_10004D2C8(v8);
  }
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 88));
  size_t v9 = *(std::__shared_weak_count **)(a1 + 80);
  if (v9) {
    sub_10004D2C8(v9);
  }
  long long v10 = *(std::__shared_weak_count **)(a1 + 64);
  if (v10) {
    sub_10004D2C8(v10);
  }
  LazuliLifetimeManagerInterface::~LazuliLifetimeManagerInterface((LazuliLifetimeManagerInterface *)a1);
  uint64_t v11 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100399174(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100399174(a1, *a2);
    sub_100399174(a1, a2[1]);
    sub_1003991D0((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_1003991D0(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_100399258(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019C2B50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100399278(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019C2B50;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1003992CC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1003992F8(uint64_t a1)
{
  sub_100399020(a1);

  operator delete();
}

void sub_100399330(ServiceManager::Service *this)
{
  *(void *)this = off_1019C2C18;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10039938C(ServiceManager::Service *this)
{
  *(void *)this = off_1019C2C18;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1003993FC@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "LazuliLifetimeManager");
}

unsigned char *sub_10039940C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 0;
  BOOL result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100399448(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  size_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    sub_100395574(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100395574(v4, 0);
}

uint64_t sub_1003994BC()
{
  return 0;
}

uint64_t sub_1003994C4()
{
  return 1;
}

uint64_t sub_1003994CC()
{
  return 0;
}

void sub_1003994D8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1003995B8(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1003996D0()
{
}

uint64_t sub_1003996E4(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_1003996F0(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = (std::__shared_weak_count *)a2[13];
    if (v3) {
      sub_10004D2C8(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)a2[11];
    if (v4) {
      sub_10004D2C8(v4);
    }
    BOOL v5 = (std::__shared_weak_count *)a2[9];
    if (v5) {
      sub_10004D2C8(v5);
    }
    int v6 = (std::__shared_weak_count *)a2[7];
    if (v6) {
      sub_10004D2C8(v6);
    }
    unint64_t v7 = (std::__shared_weak_count *)a2[5];
    if (v7) {
      sub_10004D2C8(v7);
    }
    unint64_t v8 = (std::__shared_weak_count *)a2[3];
    if (v8) {
      sub_10004D2C8(v8);
    }
    size_t v9 = (std::__shared_weak_count *)a2[1];
    if (v9) {
      sub_10004D2C8(v9);
    }
    operator delete();
  }
}

uint64_t *sub_100399790(void **a1)
{
  uint64_t v1 = *a1;
  unint64_t v7 = a1;
  unint64_t v8 = v1;
  uint64_t v2 = (void *)*v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = v1[1];
  *(void *)long long buf = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v4);
  }
  sub_100394E24((uint64_t)v2, (NSObject **)buf);
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  PersonalitiesTracker::unbind((PersonalitiesTracker *)(v2 + 11));
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 9));
  BOOL v5 = v2[5];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)size_t v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Shutdown complete", v9, 2u);
  }
  sub_100088C88((uint64_t *)&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_10039989C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10)
  {
    dispatch_group_leave(v10);
    dispatch_release(v10);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1003998D4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v10 = a1;
  uint64_t v11 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v12, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_100058DB0(__p, "/cc/props/sims_in_use");
  uint64_t v4 = operator new(0x28uLL);
  *uint64_t v4 = off_1019C2CD8;
  v4[1] = v2 + 360;
  _OWORD v4[2] = v2;
  void v4[3] = sub_100394FE4;
  void v4[4] = 0;
  int v19 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  BOOL v5 = operator new(0x20uLL);
  *BOOL v5 = off_1019C2D58;
  v5[1] = v2;
  v5[2] = sub_100396BC8;
  void v5[3] = 0;
  int v19 = v5;
  uint64_t v17 = 0;
  void v14[3] = 0;
  PersonalitiesTracker::bind();
  sub_100100490(v14);
  sub_10010040C(__p);
  sub_100100388(buf);
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  int v6 = operator new(0x28uLL);
  *int v6 = off_1019C2DD8;
  v6[1] = v2 + 384;
  _OWORD v6[2] = v2;
  void v6[3] = sub_100397420;
  v6[4] = 0;
  int v19 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/managed_configuration_changed");
  unint64_t v7 = operator new(0x20uLL);
  void *v7 = off_1019C2E58;
  v7[1] = v2;
  v7[2] = sub_100396EEC;
  void v7[3] = 0;
  int v19 = v7;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/imsi_identity_ready");
  unint64_t v8 = operator new(0x28uLL);
  void *v8 = off_1019C2ED8;
  v8[1] = v2 + 416;
  _OWORD v8[2] = v2;
  uint64_t v8[3] = sub_100397174;
  v8[4] = 0;
  int v19 = v8;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  sub_100088C88(&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100399C10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  sub_10003F600((void *)(v22 - 80));
  if (a22 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100399CA4()
{
}

__n128 sub_100399CB8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019C2CD8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100399D0C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C2CD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100399D44(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (uint64_t *)a1[1];
  long long v7 = *(_OWORD *)v3;
  uint64_t v8 = v3[2];
  *uint64_t v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  sub_100089CF0(v3, a2);
  uint64_t v4 = (void (*)(void *, long long *))a1[3];
  uint64_t v5 = a1[4];
  int v6 = (void *)(a1[2] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(void (**)(void *, long long *))(*v6 + v4);
  }
  v4(v6, &v7);
  size_t v9 = (void **)&v7;
  sub_10008A88C(&v9);
}

void sub_100399DE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100399E04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100399E44()
{
}

void sub_100399E54()
{
}

__n128 sub_100399E68(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019C2D58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100399EBC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C2D58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100399EF4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, uint64_t))a1[2];
  uint64_t v5 = a1[3];
  int v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v6 + v4);
  }
  return v4(v6, a3, a4);
}

uint64_t sub_100399F44(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100399F84()
{
}

void sub_100399F94()
{
}

__n128 sub_100399FA8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019C2DD8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100399FFC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C2DD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10039A034(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  size_t v9 = (void **)*v3;
  long long v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    size_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  int v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    int v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_10039A0F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10039A10C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10039A14C()
{
}

void sub_10039A15C()
{
}

__n128 sub_10039A170(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019C2E58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10039A1C4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C2E58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10039A1FC(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10039A244(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10039A284()
{
}

void sub_10039A294()
{
}

__n128 sub_10039A2A8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019C2ED8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10039A2FC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C2ED8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10039A334(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  size_t v9 = (void **)*v3;
  long long v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    size_t v9 = &v10;
  }
  sub_10039A458((uint64_t)v3, a2);
  int v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    int v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100399174((uint64_t)&v9, v10);
}

void sub_10039A3F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10039A40C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10039A44C()
{
}

void sub_10039A458(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_100399174(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v17, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v16, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v18; i != v16[1] || v17 != v16[0]; uint64_t i = ++v18)
    {
      xpc_object_t v15 = 0;
      object[0] = &v17;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v15);
      if (xpc_get_type(v15) == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v14 = 0;
        long long v12 = 0u;
        *(_OWORD *)long long __p = 0u;
        *(_OWORD *)long long v10 = 0u;
        *(_OWORD *)uint64_t v11 = 0u;
        *(_OWORD *)uint64_t v8 = 0u;
        long long v9 = 0u;
        *(_OWORD *)dispatch_object_t object = 0u;
        xpc_object_t v6 = v15;
        if (v15) {
          xpc_retain(v15);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_10039A748((uint64_t)object, &v6);
        xpc_release(v6);
        sub_10039A904((uint64_t **)a1, object, (long long *)object);
        if (SHIBYTE(v14) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v12) < 0) {
          operator delete(v11[1]);
        }
        if (SHIBYTE(v11[0]) < 0) {
          operator delete(v10[0]);
        }
        if (SHIBYTE(v9) < 0) {
          operator delete(v8[1]);
        }
        if (SHIBYTE(v8[0]) < 0) {
          operator delete(object[0]);
        }
      }
      xpc_release(v15);
    }
    xpc_release(v17);
    xpc_release(v17);
  }
  xpc_release(v3);
}

void sub_10039A6AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 48));
  xpc_release(v11);
  _Unwind_Resume(a1);
}

void sub_10039A748(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v2 = *a2;
  xpc_object_t v6 = v2;
  if (v2 && xpc_get_type(v2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v2);
  }
  else
  {
    xpc_object_t v2 = xpc_null_create();
    xpc_object_t v6 = v2;
  }
  if (xpc_get_type(v2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v3 = &v6;
    uint64_t v4 = "first";
    sub_100048BAC((uint64_t)&v3, &object);
    read_rest_value();
    xpc_release(object);
    xpc_object_t v3 = &v6;
    uint64_t v4 = "second";
    sub_100048BAC((uint64_t)&v3, &object);
    read_rest_value();
    xpc_release(object);
    xpc_object_t v2 = v6;
  }
  xpc_release(v2);
}

void sub_10039A83C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12)
{
}

uint64_t sub_10039A890(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *sub_10039A904(uint64_t **a1, void **a2, long long *a3)
{
  uint64_t v10 = 0;
  uint64_t v5 = (char **)sub_100046ED4((uint64_t)a1, &v10, a2);
  xpc_object_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    memset(v9, 0, sizeof(v9));
    sub_10039A9A4((uint64_t)a1, a3, v9);
    sub_100046C38(a1, v10, v7, (uint64_t *)v9[0]);
    xpc_object_t v6 = v9[0];
    v9[0] = 0;
    sub_10039AAC8((uint64_t)v9, 0);
  }
  return v6;
}

char *sub_10039A9A4@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, char **a3@<X8>)
{
  uint64_t v5 = (char *)(a1 + 8);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  xpc_object_t v6 = (char *)operator new(0x98uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  __n128 result = sub_10039AA18(v6 + 32, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_10039AA00(_Unwind_Exception *a1)
{
  sub_10039AAC8(v1, 0);
  _Unwind_Resume(a1);
}

char *sub_10039AA18(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  long long v5 = *(long long *)((char *)a2 + 24);
  *((void *)__dst + 5) = *((void *)a2 + 5);
  *(_OWORD *)(__dst + 24) = v5;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 3) = 0;
  long long v6 = a2[3];
  *((void *)__dst + 8) = *((void *)a2 + 8);
  *((_OWORD *)__dst + 3) = v6;
  *((void *)a2 + 7) = 0;
  *((void *)a2 + 8) = 0;
  *((void *)a2 + 6) = 0;
  long long v7 = *(long long *)((char *)a2 + 72);
  *((void *)__dst + 11) = *((void *)a2 + 11);
  *(_OWORD *)(__dst + 72) = v7;
  *((void *)a2 + 10) = 0;
  *((void *)a2 + 11) = 0;
  *((void *)a2 + 9) = 0;
  long long v8 = a2[6];
  *((void *)__dst + 14) = *((void *)a2 + 14);
  *((_OWORD *)__dst + 6) = v8;
  *((void *)a2 + 12) = 0;
  *((void *)a2 + 13) = 0;
  *((void *)a2 + 14) = 0;
  return __dst;
}

void sub_10039AAC8(uint64_t a1, uint64_t a2)
{
  xpc_object_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1003991D0((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void sub_10039AB20(uint64_t **a1)
{
  uint64_t v1 = **a1;
  xpc_object_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", (uint8_t *)&buf, 2u);
  }
  *(unsigned char *)(v1 + 352) = MessageCenterModel::isMessagesInstalled((Registry **)(v1 + 56));
  sub_100562274((Registry **)(v1 + 56), (uint64_t)&buf);
  *(_OWORD *)uint64_t v21 = buf;
  uint64_t v22 = v26;
  uint64_t v26 = 0;
  long long buf = 0uLL;
  ctu::path_join_impl();
  if (SHIBYTE(v26) < 0) {
    operator delete((void *)buf);
  }
  uint64_t v18 = (uint64_t)&v18;
  int v19 = &v18;
  uint64_t v20 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  Registry::getFileSystemInterface(&v16, *(Registry **)(v1 + 56));
  if (v16)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t, void **, uint64_t *, uint64_t))(*(void *)v16 + 256))(v16, v21, &v18, 1);
    if (v3)
    {
      long long v4 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v3;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Directory reading failed with error: %ld", (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      for (uint64_t i = v19; i != &v18; uint64_t i = (uint64_t *)i[1])
      {
        v14[0] = 0;
        v14[1] = 0;
        uint64_t v15 = 0;
        if (*((char *)i + 39) < 0)
        {
          sub_10004FC84(v14, (void *)i[2], i[3]);
        }
        else
        {
          *(_OWORD *)uint64_t v14 = *((_OWORD *)i + 1);
          uint64_t v15 = i[4];
        }
        ctu::path_join_impl();
        if ((*(uint64_t (**)(uint64_t, void **))(*(void *)v16 + 88))(v16, v14))
        {
          long long v6 = *(NSObject **)(v1 + 40);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          {
            uint64_t v10 = v14;
            if (v15 < 0) {
              uint64_t v10 = (void **)v14[0];
            }
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = v10;
            _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Scanning unauthorized XML for removal: %{public}s", (uint8_t *)&buf, 0xCu);
          }
          CFDataRef theData = 0;
          (*(void (**)(CFDataRef *__return_ptr))(*(void *)v16 + 168))(&theData);
          if (theData) {
            long long v7 = sub_10008324C;
          }
          else {
            long long v7 = 0;
          }
          if (v7)
          {
            memset(__p, 0, sizeof(__p));
            BytePtr = (UInt8 *)CFDataGetBytePtr(theData);
            size_t Length = CFDataGetLength(theData);
            sub_1000D95C8(__p, BytePtr, Length);
            long long buf = 0uLL;
            uint64_t v26 = 0;
            v23[0] = "\n";
            v23[1] = "";
            sub_100398F7C(__dst, (uint64_t)v23);
            sub_100397A2C((uint64_t)&buf, (uint64_t)__p, __dst, 1);
          }
          sub_100030068((const void **)&theData);
        }
        if (SHIBYTE(v15) < 0) {
          operator delete(v14[0]);
        }
      }
    }
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  sub_1001257B0(&v18);
  if (SHIBYTE(v22) < 0) {
    operator delete(v21[0]);
  }
  sub_100395790(v1);
  uint64_t v11 = *(void *)(v1 + 320);
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  operator delete();
}

void sub_10039B2DC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,const void *a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,std::__shared_weak_count *a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  sub_100030068(&a25);
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a33) {
    sub_10004D2C8(a33);
  }
  sub_1001257B0(&a34);
  if (a42 < 0) {
    operator delete(a37);
  }
  operator delete();
}

uint64_t sub_10039B3F4@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = **(void **)(result + 40);
  uint64_t v4 = *(void *)(v2 + 320);
  uint64_t v3 = *(void *)(v2 + 328);
  *a2 = v4;
  a2[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10039B418(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = v5;
  long long v5 = 0uLL;
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 8);
  *(_OWORD *)uint64_t v2 = v3;
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*((void *)&v5 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v5 + 1));
  }
}

void sub_10039B480(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = v5;
  long long v5 = 0uLL;
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 8);
  *(_OWORD *)uint64_t v2 = v3;
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*((void *)&v5 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v5 + 1));
  }
}

void sub_10039B4E8(void *a1, uint64_t a2)
{
  long long v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    long long v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      long long v6 = v5;
      if (a1[4])
      {
        uint64_t v7 = a1[6];
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)a2;
          uint64_t v9 = *(void *)(a2 + 16);
        }
        (*(void (**)(uint64_t, void **))(v7 + 16))(v7, __p);
        if (SHIBYTE(v9) < 0) {
          operator delete(__p[0]);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10039B5B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

void *sub_10039B5DC(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  __n128 result = (void *)a2[6];
  if (result) {
    __n128 result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_10039B628(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t sub_10039B67C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = **(NSObject ***)(v1 + 16);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Enabling Lazuli", v6, 2u);
  }
  sub_100394F28(v2);
  uint64_t v4 = (*(uint64_t (**)(void, void, uint64_t, uint64_t))(**(void **)(v2 + 304) + 24))(*(void *)(v2 + 304), *(unsigned int *)(v1 + 8), 2, 2);
  if (v4 && !*(void *)(v2 + 336) && sub_100394868((void *)v2))
  {
    (***(void (****)(void))(v2 + 320))(*(void *)(v2 + 320));
    (*(void (**)(void))(**(void **)(v2 + 320) + 8))(*(void *)(v2 + 320));
  }
  return v4;
}

uint64_t sub_10039B79C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)v1[2];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Enabling business messaging", v5, 2u);
  }
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(**(void **)(v2 + 304) + 64))(*(void *)(v2 + 304), *((unsigned int *)v1 + 2), 2, 2);
}

uint64_t *sub_10039B844(void *a1)
{
  uint64_t v17 = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (a1[1])
      {
        long long v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Starting teardown debounce", buf, 2u);
        }
        uint64_t v7 = *(std::__shared_weak_count **)(v3 + 16);
        if (!v7 || (uint64_t v8 = *(void *)(v3 + 8), (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v10 = v9;
        atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v9);
        Registry::getTimerService(&v29, *(Registry **)(v3 + 56));
        uint64_t v11 = v29;
        sub_100058DB0(__p, "Teardown Debounce");
        uint64_t v12 = *(NSObject **)(v3 + 24);
        dispatch_object_t object = v12;
        if (v12) {
          dispatch_retain(v12);
        }
        *(void *)long long buf = _NSConcreteStackBlock;
        uint64_t v19 = 1174405120;
        uint64_t v20 = sub_1003960D0;
        uint64_t v21 = &unk_1019C2A28;
        uint64_t v22 = v3;
        uint64_t v23 = v8;
        uint64_t v24 = v10;
        atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        aBlock = _Block_copy(buf);
        sub_100118A44(v11, (uint64_t)__p, 0, 3000000, &object, &aBlock);
        uint64_t v13 = v31;
        uint64_t v31 = 0;
        uint64_t v14 = *(void *)(v3 + 344);
        *(void *)(v3 + 344) = v13;
        if (v14)
        {
          (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
          uint64_t v15 = v31;
          uint64_t v31 = 0;
          if (v15) {
            (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
          }
        }
        if (aBlock) {
          _Block_release(aBlock);
        }
        if (object) {
          dispatch_release(object);
        }
        if (v28 < 0) {
          operator delete(__p[0]);
        }
        if (v30) {
          sub_10004D2C8(v30);
        }
        if (v24) {
          std::__shared_weak_count::__release_weak(v24);
        }
        std::__shared_weak_count::__release_weak(v10);
      }
      sub_10004D2C8(v5);
    }
  }
  return sub_100004A84((uint64_t *)&v17);
}

void sub_10039BA88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, void *aBlock, dispatch_object_t object,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a26 < 0) {
    operator delete(__p);
  }
  uint64_t v30 = *(std::__shared_weak_count **)(v28 - 64);
  if (v30) {
    sub_10004D2C8(v30);
  }
  std::__shared_weak_count::__release_weak(v27);
  sub_10004D2C8(v26);
  sub_100004A84(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_10039BB0C(uint64_t a1)
{
  return sub_100396224(**(void **)(a1 + 40), *(unsigned int *)(*(void *)(a1 + 40) + 8), 2);
}

uint64_t sub_10039BB20(uint64_t a1)
{
  return sub_100396614(**(void **)(a1 + 40), *(unsigned int *)(*(void *)(a1 + 40) + 8), 2);
}

void sub_10039BB34(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(uint64_t **)(a1 + 40);
  uint64_t v4 = *v3;
  uint64_t v5 = *((unsigned int *)v3 + 2);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 208) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 240) = 0u;
  *(_OWORD *)(a2 + 256) = 0u;
  *(_OWORD *)(a2 + 272) = 0u;
  *(_OWORD *)(a2 + 288) = 0u;
  *(_OWORD *)(a2 + 304) = 0u;
  *(_OWORD *)(a2 + 320) = 0u;
  *(_OWORD *)(a2 + 336) = 0u;
  *(_OWORD *)(a2 + 352) = 0u;
  *(_OWORD *)(a2 + 368) = 0u;
  *(_OWORD *)(a2 + 384) = 0u;
  *(_OWORD *)(a2 + 400) = 0u;
  *(_OWORD *)(a2 + 416) = 0u;
  *(_OWORD *)(a2 + 432) = 0u;
  *(_OWORD *)(a2 + 448) = 0u;
  *(_OWORD *)(a2 + 464) = 0u;
  uint64_t v6 = *(void *)(v4 + 320);
  if (v6)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 120))(v6, v5);
    goto LABEL_27;
  }
  sub_100563588((void *)(v4 + 304), v5, a2);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v4 + 56));
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  v28[0] = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, v28);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_11:
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v15 = v13[3];
  uint64_t v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (v15) {
LABEL_12:
  }
    *(unsigned char *)(a2 + 454) = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 80))(v15) ^ 1;
LABEL_13:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  uint64_t v17 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v4 + 56));
  uint64_t v18 = v17;
  uint64_t v19 = "24MobileStoreDemoInterface";
  if (((unint64_t)"24MobileStoreDemoInterface" & 0x8000000000000000) != 0)
  {
    uint64_t v20 = (unsigned __int8 *)((unint64_t)"24MobileStoreDemoInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      uint64_t v19 = (const char *)v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(v17);
  v28[0] = (unint64_t)v19;
  uint64_t v23 = sub_10004D37C(&v18[1].__m_.__sig, v28);
  if (!v23)
  {
    uint64_t v25 = 0;
LABEL_23:
    std::mutex::unlock(v18);
    uint64_t v24 = 0;
    char v26 = 1;
    if (!v25) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  uint64_t v25 = v23[3];
  uint64_t v24 = (std::__shared_weak_count *)v23[4];
  if (!v24) {
    goto LABEL_23;
  }
  atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v18);
  atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v24);
  char v26 = 0;
  if (v25) {
LABEL_24:
  }
    *(unsigned char *)(a2 + 455) = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 16))(v25);
LABEL_25:
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }
LABEL_27:
  if (sub_100394794(*(void *)(v4 + 288)))
  {
    long long v27 = *(NSObject **)(v4 + 40);
    if (*(unsigned char *)(a2 + 372))
    {
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v28[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Feature disabled due to Lockdown", (uint8_t *)v28, 2u);
      }
      *(_DWORD *)(a2 + 364) = 2;
    }
    else if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v28[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Missing status field", (uint8_t *)v28, 2u);
    }
  }
}

void sub_10039BE48(_Unwind_Exception *a1)
{
  char v4 = v2;
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  sub_10039BE98(v1 + 384);
  sub_10039BEEC(v1 + 136);
  sub_10039BF90(v1 + 16);
  _Unwind_Resume(a1);
}

uint64_t sub_10039BE98(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v3 = (void **)(a1 + 24);
    sub_100047F64(&v3);
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

uint64_t sub_10039BEEC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 216))
  {
    if (*(unsigned char *)(a1 + 152) && *(char *)(a1 + 151) < 0) {
      operator delete(*(void **)(a1 + 128));
    }
    if (*(unsigned char *)(a1 + 120) && *(char *)(a1 + 119) < 0) {
      operator delete(*(void **)(a1 + 96));
    }
    if (*(unsigned char *)(a1 + 88) && *(char *)(a1 + 87) < 0) {
      operator delete(*(void **)(a1 + 64));
    }
    if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
    if (*(unsigned char *)(a1 + 24) && *(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

uint64_t sub_10039BF90(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72) && *(unsigned char *)(a1 + 64) && *(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  return a1;
}

void sub_10039BFD4(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 40) + 16))(&v9);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = v9;
  *(unsigned char *)(v2 + 8) = v10;
  *(void *)uint64_t v2 = v3;
  sub_10039C0E8(v2 + 16, &v11);
  long long v4 = v16;
  long long v5 = v17;
  *(unsigned char *)(v2 + 128) = v18;
  *(_OWORD *)(v2 + 96) = v4;
  *(_OWORD *)(v2 + 112) = v5;
  sub_10039C1E0(v2 + 136, (uint64_t)v19);
  long long v6 = *(_OWORD *)v20;
  *(void *)(v2 + 373) = *(void *)&v20[13];
  *(_OWORD *)(v2 + 360) = v6;
  sub_10039C4B0(v2 + 384, (long long *)v21);
  long long v7 = *(_OWORD *)&v21[7];
  long long v8 = *(_OWORD *)&v21[9];
  *(unsigned char *)(v2 + 472) = v22;
  *(_OWORD *)(v2 + 440) = v7;
  *(_OWORD *)(v2 + 456) = v8;
  sub_10039BE98((uint64_t)v21);
  sub_10039BEEC((uint64_t)v19);
  if (v15 && v14 && v13 < 0) {
    operator delete(__p);
  }
}

void sub_10039C0E8(uint64_t a1, long long *a2)
{
  if (*(unsigned __int8 *)(a1 + 72) == *((unsigned __int8 *)a2 + 72))
  {
    if (*(unsigned char *)(a1 + 72))
    {
      long long v2 = *a2;
      long long v3 = a2[1];
      *(unsigned char *)(a1 + 32) = *((unsigned char *)a2 + 32);
      *(_OWORD *)a1 = v2;
      *(_OWORD *)(a1 + 16) = v3;
      sub_100179CB0(a1 + 40, (__n128 *)((char *)a2 + 40));
    }
  }
  else if (*(unsigned char *)(a1 + 72))
  {
    sub_10039C19C(a1);
  }
  else
  {
    long long v4 = *a2;
    long long v5 = a2[1];
    *(unsigned char *)(a1 + 32) = *((unsigned char *)a2 + 32);
    *(_OWORD *)a1 = v4;
    *(_OWORD *)(a1 + 16) = v5;
    *(unsigned char *)(a1 + 40) = 0;
    *(unsigned char *)(a1 + 64) = 0;
    if (*((unsigned char *)a2 + 64))
    {
      long long v6 = *(long long *)((char *)a2 + 40);
      *(void *)(a1 + 56) = *((void *)a2 + 7);
      *(_OWORD *)(a1 + 40) = v6;
      *((void *)a2 + 6) = 0;
      *((void *)a2 + 7) = 0;
      *((void *)a2 + 5) = 0;
      *(unsigned char *)(a1 + 64) = 1;
    }
    *(unsigned char *)(a1 + 72) = 1;
  }
}

void sub_10039C19C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    if (*(unsigned char *)(a1 + 64))
    {
      if (*(char *)(a1 + 63) < 0) {
        operator delete(*(void **)(a1 + 40));
      }
    }
    *(unsigned char *)(a1 + 72) = 0;
  }
}

void sub_10039C1E0(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 216) == *(unsigned __int8 *)(a2 + 216))
  {
    if (*(unsigned char *)(a1 + 216))
    {
      sub_10039C268(a1, a2);
    }
  }
  else if (*(unsigned char *)(a1 + 216))
  {
    sub_10039C2F0(a1);
  }
  else
  {
    sub_10039C394(a1, (long long *)a2);
    *(unsigned char *)(a1 + 216) = 1;
  }
}

uint64_t sub_10039C268(uint64_t a1, uint64_t a2)
{
  sub_100179CB0(a1, (__n128 *)a2);
  sub_100179CB0(a1 + 32, (__n128 *)(a2 + 32));
  sub_100179CB0(a1 + 64, (__n128 *)(a2 + 64));
  sub_100179CB0(a1 + 96, (__n128 *)(a2 + 96));
  sub_100179CB0(a1 + 128, (__n128 *)(a2 + 128));
  long long v4 = *(_OWORD *)(a2 + 160);
  long long v5 = *(_OWORD *)(a2 + 176);
  long long v6 = *(_OWORD *)(a2 + 192);
  *(unsigned char *)(a1 + 208) = *(unsigned char *)(a2 + 208);
  *(_OWORD *)(a1 + 176) = v5;
  *(_OWORD *)(a1 + 192) = v6;
  *(_OWORD *)(a1 + 160) = v4;
  return a1;
}

void sub_10039C2F0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 216))
  {
    if (*(unsigned char *)(a1 + 152) && *(char *)(a1 + 151) < 0) {
      operator delete(*(void **)(a1 + 128));
    }
    if (*(unsigned char *)(a1 + 120) && *(char *)(a1 + 119) < 0) {
      operator delete(*(void **)(a1 + 96));
    }
    if (*(unsigned char *)(a1 + 88) && *(char *)(a1 + 87) < 0) {
      operator delete(*(void **)(a1 + 64));
    }
    if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
    if (*(unsigned char *)(a1 + 24))
    {
      if (*(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
    }
    *(unsigned char *)(a1 + 216) = 0;
  }
}

__n128 sub_10039C394(uint64_t a1, long long *a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  if (*((unsigned char *)a2 + 24))
  {
    long long v2 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v2;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 56) = 0;
  if (*((unsigned char *)a2 + 56))
  {
    long long v3 = a2[2];
    *(void *)(a1 + 48) = *((void *)a2 + 6);
    *(_OWORD *)(a1 + 32) = v3;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 6) = 0;
    *((void *)a2 + 4) = 0;
    *(unsigned char *)(a1 + 56) = 1;
  }
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 88) = 0;
  if (*((unsigned char *)a2 + 88))
  {
    long long v4 = a2[4];
    *(void *)(a1 + 80) = *((void *)a2 + 10);
    *(_OWORD *)(a1 + 64) = v4;
    *((void *)a2 + 9) = 0;
    *((void *)a2 + 10) = 0;
    *((void *)a2 + 8) = 0;
    *(unsigned char *)(a1 + 88) = 1;
  }
  *(unsigned char *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  if (*((unsigned char *)a2 + 120))
  {
    long long v5 = a2[6];
    *(void *)(a1 + 112) = *((void *)a2 + 14);
    *(_OWORD *)(a1 + 96) = v5;
    *((void *)a2 + 13) = 0;
    *((void *)a2 + 14) = 0;
    *((void *)a2 + 12) = 0;
    *(unsigned char *)(a1 + 120) = 1;
  }
  *(unsigned char *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 152) = 0;
  if (*((unsigned char *)a2 + 152))
  {
    long long v6 = a2[8];
    *(void *)(a1 + 144) = *((void *)a2 + 18);
    *(_OWORD *)(a1 + 128) = v6;
    *((void *)a2 + 17) = 0;
    *((void *)a2 + 18) = 0;
    *((void *)a2 + 16) = 0;
    *(unsigned char *)(a1 + 152) = 1;
  }
  __n128 result = (__n128)a2[10];
  long long v8 = a2[11];
  long long v9 = a2[12];
  *(unsigned char *)(a1 + 208) = *((unsigned char *)a2 + 208);
  *(_OWORD *)(a1 + 176) = v8;
  *(_OWORD *)(a1 + 192) = v9;
  *(__n128 *)(a1 + 160) = result;
  return result;
}

__n128 sub_10039C4B0(uint64_t a1, long long *a2)
{
  if (*(unsigned __int8 *)(a1 + 48) == *((unsigned __int8 *)a2 + 48))
  {
    if (*(unsigned char *)(a1 + 48))
    {
      if (*(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
      long long v4 = *a2;
      *(void *)(a1 + 16) = *((void *)a2 + 2);
      *(_OWORD *)a1 = v4;
      *((unsigned char *)a2 + 23) = 0;
      *(unsigned char *)a2 = 0;
      sub_10005CBB4((uint64_t *)(a1 + 24));
      __n128 result = *(__n128 *)((char *)a2 + 24);
      *(__n128 *)(a1 + 24) = result;
      *(void *)(a1 + 40) = *((void *)a2 + 5);
      *((void *)a2 + 3) = 0;
      *((void *)a2 + 4) = 0;
      *((void *)a2 + 5) = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 48))
  {
    sub_10039C598(a1);
  }
  else
  {
    long long v6 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v6;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    __n128 result = *(__n128 *)((char *)a2 + 24);
    *(__n128 *)(a1 + 24) = result;
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *((void *)a2 + 3) = 0;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *(unsigned char *)(a1 + 48) = 1;
  }
  return result;
}

void sub_10039C598(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    long long v2 = (void **)(a1 + 24);
    sub_100047F64(&v2);
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(unsigned char *)(a1 + 48) = 0;
  }
}

void sub_10039C5EC(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 40) + 16))(&v9);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = v9;
  *(unsigned char *)(v2 + 8) = v10;
  *(void *)uint64_t v2 = v3;
  sub_10039C0E8(v2 + 16, &v11);
  long long v4 = v16;
  long long v5 = v17;
  *(unsigned char *)(v2 + 128) = v18;
  *(_OWORD *)(v2 + 96) = v4;
  *(_OWORD *)(v2 + 112) = v5;
  sub_10039C1E0(v2 + 136, (uint64_t)v19);
  long long v6 = *(_OWORD *)v20;
  *(void *)(v2 + 373) = *(void *)&v20[13];
  *(_OWORD *)(v2 + 360) = v6;
  sub_10039C4B0(v2 + 384, (long long *)v21);
  long long v7 = *(_OWORD *)&v21[7];
  long long v8 = *(_OWORD *)&v21[9];
  *(unsigned char *)(v2 + 472) = v22;
  *(_OWORD *)(v2 + 440) = v7;
  *(_OWORD *)(v2 + 456) = v8;
  sub_10039BE98((uint64_t)v21);
  sub_10039BEEC((uint64_t)v19);
  if (v15 && v14 && v13 < 0) {
    operator delete(__p);
  }
}

uint64_t *sub_10039C700(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v9 = a1;
  char v10 = v1;
  uint64_t v2 = *v1;
  uint64_t v14 = 0;
  char v15 = 0;
  Registry::getFileSystemInterface(&v14, *(Registry **)(v2 + 56));
  if (v14)
  {
    *(void *)long long v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    sub_100562274((Registry **)(v2 + 56), (uint64_t)v11);
    uint64_t v3 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v14 + 112))(v14, v11);
    long long v4 = *(NSObject **)(v2 + 40);
    if (v3)
    {
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        long long v5 = v11;
        if (v13 < 0) {
          long long v5 = *(uint8_t **)v11;
        }
        *(_DWORD *)long long buf = 136446466;
        long long v17 = v5;
        __int16 v18 = 2048;
        uint64_t v19 = v3;
        _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Unable to remove %{public}s, %ld", buf, 0x16u);
      }
    }
    else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      long long v7 = v11;
      if (v13 < 0) {
        long long v7 = *(uint8_t **)v11;
      }
      *(_DWORD *)long long buf = 136446210;
      long long v17 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Successfully removed %{public}s", buf, 0xCu);
    }
    if (SHIBYTE(v13) < 0) {
      operator delete(*(void **)v11);
    }
  }
  else
  {
    long long v6 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v11 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not get interface to filesystem", v11, 2u);
    }
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_100088C88((uint64_t *)&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_10039C8F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10039C93C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = SlotIdFromPersonalityId();
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v5);
  long long v6 = (void **)(a3 + 24);
  if (*(char *)(a3 + 47) < 0)
  {
    unint64_t v7 = *(void *)(a3 + 32);
    if (!v7) {
      return;
    }
    sub_10004FC84(__p, *v6, v7);
  }
  else
  {
    if (!*(unsigned char *)(a3 + 47)) {
      return;
    }
    *(_OWORD *)long long __p = *(_OWORD *)v6;
    uint64_t v10 = *(void *)(a3 + 40);
  }
  char v11 = 1;
  long long v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v5);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Updating switch identifier", buf, 2u);
  }
  (*(void (**)(void, uint64_t, void **))(**(void **)(a1 + 304) + 32))(*(void *)(a1 + 304), v5, __p);
  if (v11)
  {
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100395790(a1);
}

void sub_10039CAA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

char *sub_10039CAC4(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84(__dst + 48, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v6 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *((_OWORD *)__dst + 3) = v6;
  }
  unint64_t v7 = __dst + 72;
  if (*((char *)a2 + 95) < 0)
  {
    sub_10004FC84(v7, *((void **)a2 + 9), *((void *)a2 + 10));
  }
  else
  {
    long long v8 = *(long long *)((char *)a2 + 72);
    *((void *)__dst + 11) = *((void *)a2 + 11);
    *(_OWORD *)unint64_t v7 = v8;
  }
  return __dst;
}

void sub_10039CBA8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10039CBF4(uint64_t **a1)
{
  uint64_t v1 = **a1;
  int v2 = *((unsigned __int8 *)*a1 + 8);
  *(unsigned char *)(v1 + 352) = v2;
  if (v2)
  {
    sub_100395790(v1);
  }
  else
  {
    subscriber::makeSimSlotRange();
    uint64_t v3 = v6;
    if (v6 != v7)
    {
      do
      {
        if (v8(*v3)) {
          goto LABEL_8;
        }
        ++v3;
      }
      while (v3 != v7);
      uint64_t v3 = v7;
LABEL_8:
      while (v3 != v7)
      {
        uint64_t v4 = *v3;
        sub_100396224(v1, v4, 3);
        sub_100396614(v1, v4, 3);
        long long v5 = v3 + 1;
        uint64_t v3 = v7;
        if (v5 != v7)
        {
          uint64_t v3 = v5;
          do
          {
            if (v8(*v3)) {
              goto LABEL_8;
            }
            ++v3;
          }
          while (v3 != v7);
          uint64_t v3 = v7;
        }
      }
    }
  }
  operator delete();
}

void sub_10039CD10()
{
}

void sub_10039CD48(uint64_t a1)
{
  *(void *)a1 = off_1019C3108;
  uint64_t v4 = *(void *)(a1 + 32);
  int v2 = (void *)(a1 + 32);
  uint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  sub_100110A40((void ***)(a1 + 24), 0);
  sub_100110A40((void ***)(a1 + 16), 0);
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v5) {
    sub_100206334(a1 + 8, v5);
  }

  PB::Base::~Base((PB::Base *)a1);
}

void sub_10039CDD8(uint64_t a1)
{
  sub_10039CD48(a1);

  operator delete();
}

uint64_t sub_10039CE10(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  if (*(unsigned char *)(a1 + 44)) {
    PB::TextFormatter::format(this, "consentState", *(_DWORD *)(a1 + 40));
  }
  if (*(void *)(a1 + 8)) {
    PB::TextFormatter::format();
  }
  uint64_t v5 = *(const PB::Data **)(a1 + 16);
  if (v5) {
    PB::TextFormatter::format(this, "sourceCsn", v5);
  }
  long long v6 = *(const PB::Data **)(a1 + 24);
  if (v6) {
    PB::TextFormatter::format(this, "targetCsn", v6);
  }
  if (*(void *)(a1 + 32)) {
    PB::TextFormatter::format();
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_10039CED0(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)this;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
      break;
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    do
    {
      if (v3 == v2)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_22;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
    }
    while (!v14);
LABEL_19:
    unsigned __int8 v19 = 0;
    LODWORD(v20) = 0;
LABEL_20:
    uint64_t result = PB::Reader::skip(this, v20, v19, 0);
    if (!result) {
      return result;
    }
LABEL_46:
    unint64_t v2 = *((void *)this + 1);
    unint64_t v3 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v9 = 0;
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = v2 + 1;
    *((void *)this + 1) = v2 + 1;
    char v13 = *(unsigned char *)(v8 + v2);
    v11 |= (unint64_t)(v13 & 0x7F) << v9;
    if ((v13 & 0x80) == 0) {
      break;
    }
    v9 += 7;
    unint64_t v2 = v12;
    BOOL v14 = v10++ > 8;
    if (v14) {
      goto LABEL_19;
    }
  }
LABEL_22:
  unsigned __int8 v19 = v11 & 7;
  if ((v11 & 7) != 4)
  {
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 1u:
        operator new();
      case 2u:
        operator new();
      case 3u:
        operator new();
      case 4u:
        *(unsigned char *)(a1 + 44) |= 1u;
        unint64_t v22 = *((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        uint64_t v24 = *(void *)this;
        if (v22 <= 0xFFFFFFFFFFFFFFF5 && v22 + 10 <= v23)
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          do
          {
            unint64_t v28 = v22 + 1;
            *((void *)this + 1) = v22 + 1;
            char v29 = *(unsigned char *)(v24 + v22);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0) {
              goto LABEL_45;
            }
            v25 += 7;
            unint64_t v22 = v28;
            BOOL v14 = v26++ > 8;
          }
          while (!v14);
LABEL_41:
          LODWORD(v27) = 0;
          goto LABEL_45;
        }
        char v30 = 0;
        unsigned int v31 = 0;
        uint64_t v27 = 0;
        if (v23 <= v22) {
          unint64_t v23 = *((void *)this + 1);
        }
        break;
      case 5u:
        operator new();
      default:
        goto LABEL_20;
    }
    while (1)
    {
      if (v23 == v22)
      {
        LODWORD(v27) = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_45;
      }
      unint64_t v32 = v22 + 1;
      char v33 = *(unsigned char *)(v24 + v22);
      *((void *)this + 1) = v32;
      v27 |= (unint64_t)(v33 & 0x7F) << v30;
      if ((v33 & 0x80) == 0) {
        break;
      }
      v30 += 7;
      unint64_t v22 = v32;
      BOOL v14 = v31++ > 8;
      if (v14) {
        goto LABEL_41;
      }
    }
    if (*((unsigned char *)this + 24)) {
      LODWORD(v27) = 0;
    }
LABEL_45:
    *(_DWORD *)(a1 + 40) = v27;
    goto LABEL_46;
  }
  int v4 = 0;
  return v4 == 0;
}

uint64_t sub_10039D29C(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 16);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  uint64_t v5 = *(const PB::Data **)(v3 + 24);
  if (v5) {
    uint64_t result = PB::Writer::write(this, v5, 2u);
  }
  if (*(void *)(v3 + 8)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(unsigned char *)(v3 + 44)) {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 40), 4u);
  }
  if (*(void *)(v3 + 32))
  {
    return PB::Writer::write();
  }
  return result;
}

uint64_t sub_10039D340(uint64_t a1, char *a2)
{
  *(void *)a1 = off_1019C3158;
  sub_100058DB0((void *)(a1 + 8), a2);
  sub_100058DB0(&v7, a2);
  int v4 = std::string::append(&v7, ".tmp", 4uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  *(void *)(a1 + 48) = *((void *)&v4->__r_.__value_.__l + 2);
  *(_OWORD *)(a1 + 32) = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return a1;
}

void sub_10039D3E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v15 + 31) < 0) {
    operator delete(*v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10039D41C(uint64_t a1)
{
  *(void *)a1 = off_1019C3158;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_10039D480(uint64_t a1)
{
  sub_10039D41C(a1);

  operator delete();
}

BOOL sub_10039D4B8(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  BOOL v5 = sub_10039D518(a1, a2, a3, 0);
  BOOL result = 0;
  if (v5)
  {
    std::string v7 = (const std::__fs::filesystem::path *)(a1 + 32);
    if (*(char *)(a1 + 55) < 0) {
      std::string v7 = (const std::__fs::filesystem::path *)v7->__pn_.__r_.__value_.__r.__words[0];
    }
    uint64_t v8 = (const std::__fs::filesystem::path *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      uint64_t v8 = (const std::__fs::filesystem::path *)v8->__pn_.__r_.__value_.__r.__words[0];
    }
    rename(v7, v8, v4);
    return v9 == 0;
  }
  return result;
}

BOOL sub_10039D518(uint64_t a1, unsigned __int8 *a2, uint64_t a3, char a4)
{
  uint64_t v7 = a2[23];
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *((void *)a2 + 1);
  }
  uint64_t v8 = *(unsigned __int8 *)(a3 + 23);
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(a3 + 8);
  }
  if ((unint64_t)(v7 + v8 + 1) >= 0x200) {
    __TUAssertTrigger();
  }
  bzero(v86, 0x248uLL);
  sub_100358650((uint64_t)v86);
  int v50 = v86;
  if (*((unsigned char *)&v86[4] + *(void *)(v86[0] - 24)))
  {
    BOOL v43 = 0;
    goto LABEL_78;
  }
  bzero(v84, 0x248uLL);
  sub_100358650((uint64_t)v84);
  int v49 = v84;
  if (*((unsigned char *)&v85[2] + *(void *)(v84[0] - 24)))
  {
    BOOL v43 = 0;
    goto LABEL_77;
  }
  long long v82 = 0u;
  long long v83 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  *(_OWORD *)__s = 0u;
  long long v53 = 0u;
  int v9 = (const std::ios_base *)((char *)v86 + *(void *)(v86[0] - 24));
  if (v9->__rdstate_) {
    goto LABEL_61;
  }
  char v45 = 0;
  do
  {
    std::ios_base::getloc(v9);
    unsigned int v10 = std::locale::use_facet((const std::locale *)&v48, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10);
    std::locale::~locale((std::locale *)&v48);
    std::istream::getline();
    memset(&v48, 0, sizeof(v48));
    sub_100058DB0(&v48, __s);
    char v11 = HIBYTE(v48.__r_.__value_.__r.__words[2]);
    if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t size = HIBYTE(v48.__r_.__value_.__r.__words[2]);
    }
    else {
      size_t size = v48.__r_.__value_.__l.__size_;
    }
    if (!size) {
      goto LABEL_57;
    }
    char v13 = (v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &v48
        : (std::string *)v48.__r_.__value_.__r.__words[0];
    BOOL v14 = memchr(v13, 61, size);
    if (!v14) {
      goto LABEL_57;
    }
    std::string::size_type v15 = v14 - (unsigned char *)v13;
    if (v15 == -1) {
      goto LABEL_57;
    }
    memset(&v47, 0, sizeof(v47));
    std::string::basic_string(&v47, &v48, 0, v15, (std::allocator<char> *)&v46);
    memset(&v46, 0, sizeof(v46));
    std::string::basic_string(&v46, &v48, v15 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v51);
    uint64_t v16 = HIBYTE(v47.__r_.__value_.__r.__words[2]);
    char v17 = HIBYTE(v47.__r_.__value_.__r.__words[2]);
    std::string::size_type v18 = v47.__r_.__value_.__l.__size_;
    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v19 = HIBYTE(v47.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v19 = v47.__r_.__value_.__l.__size_;
    }
    uint64_t v20 = a2[23];
    int v21 = (char)v20;
    if ((v20 & 0x80u) != 0) {
      uint64_t v20 = *((void *)a2 + 1);
    }
    if (v19 != v20) {
      goto LABEL_39;
    }
    if (v21 >= 0) {
      unint64_t v22 = a2;
    }
    else {
      unint64_t v22 = *(unsigned __int8 **)a2;
    }
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
    {
      if (memcmp(v47.__r_.__value_.__l.__data_, v22, v47.__r_.__value_.__l.__size_)) {
        goto LABEL_39;
      }
    }
    else if (*((unsigned char *)&v47.__r_.__value_.__s + 23))
    {
      unint64_t v23 = &v47;
      uint64_t v24 = HIBYTE(v47.__r_.__value_.__r.__words[2]);
      while (v23->__r_.__value_.__s.__data_[0] == *v22)
      {
        unint64_t v23 = (std::string *)((char *)v23 + 1);
        ++v22;
        if (!--v24) {
          goto LABEL_36;
        }
      }
      goto LABEL_39;
    }
LABEL_36:
    if ((a4 & 1) == 0)
    {
      std::string::operator=(&v46, (const std::string *)a3);
      uint64_t v16 = HIBYTE(v47.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v47.__r_.__value_.__l.__size_;
      char v45 = 1;
      char v17 = HIBYTE(v47.__r_.__value_.__r.__words[2]);
LABEL_39:
      if (v17 >= 0) {
        char v25 = &v47;
      }
      else {
        char v25 = (std::string *)v47.__r_.__value_.__r.__words[0];
      }
      if (v17 >= 0) {
        uint64_t v26 = v16;
      }
      else {
        uint64_t v26 = v18;
      }
      uint64_t v27 = sub_10004B96C(v85, (uint64_t)v25, v26);
      unint64_t v28 = sub_10004B96C(v27, (uint64_t)"=", 1);
      if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        char v29 = &v46;
      }
      else {
        char v29 = (std::string *)v46.__r_.__value_.__r.__words[0];
      }
      if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v30 = HIBYTE(v46.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v30 = v46.__r_.__value_.__l.__size_;
      }
      unsigned int v31 = sub_10004B96C(v28, (uint64_t)v29, v30);
      std::ios_base::getloc((const std::ios_base *)((char *)v31 + *(void *)(*v31 - 24)));
      unint64_t v32 = std::locale::use_facet(&v51, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v32->__vftable[2].~facet_0)(v32, 10);
      std::locale::~locale(&v51);
      std::ostream::put();
      std::ostream::flush();
      goto LABEL_52;
    }
    char v45 = 1;
LABEL_52:
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v47.__r_.__value_.__l.__data_);
    }
    char v11 = HIBYTE(v48.__r_.__value_.__r.__words[2]);
LABEL_57:
    if (v11 < 0) {
      operator delete(v48.__r_.__value_.__l.__data_);
    }
    int v9 = (const std::ios_base *)((char *)v86 + *(void *)(v86[0] - 24));
  }
  while (!v9->__rdstate_);
  if ((v45 & 1) == 0)
  {
LABEL_61:
    int v33 = (char)a2[23];
    if (v33 >= 0) {
      uint64_t v34 = (uint64_t)a2;
    }
    else {
      uint64_t v34 = *(void *)a2;
    }
    if (v33 >= 0) {
      uint64_t v35 = a2[23];
    }
    else {
      uint64_t v35 = *((void *)a2 + 1);
    }
    char v36 = sub_10004B96C(v85, v34, v35);
    uint64_t v37 = sub_10004B96C(v36, (uint64_t)"=", 1);
    int v38 = *(char *)(a3 + 23);
    if (v38 >= 0) {
      uint64_t v39 = a3;
    }
    else {
      uint64_t v39 = *(void *)a3;
    }
    if (v38 >= 0) {
      uint64_t v40 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v40 = *(void *)(a3 + 8);
    }
    uint64_t v41 = sub_10004B96C(v37, v39, v40);
    std::ios_base::getloc((const std::ios_base *)((char *)v41 + *(void *)(*v41 - 24)));
    __int16 v42 = std::locale::use_facet((const std::locale *)&v48, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v42->__vftable[2].~facet_0)(v42, 10);
    std::locale::~locale((std::locale *)&v48);
    std::ostream::put();
    std::ostream::flush();
  }
  BOOL v43 = (*(_DWORD *)((unsigned char *)&v85[2] + *(void *)(v84[0] - 24)) & 1) == 0;
LABEL_77:
  sub_10039E2A0(&v49);
  v84[0] = off_1019BBD08;
  v85[52] = off_1019BBD58;
  v85[0] = off_1019BBD30;
  std::filebuf::~filebuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
LABEL_78:
  sub_10039E2A0(&v50);
  v86[0] = off_1019BBD08;
  v86[54] = off_1019BBD58;
  v86[2] = off_1019BBD30;
  std::filebuf::~filebuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  return v43;
}

void sub_10039DBDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, void *__p, uint64_t a8, uint64_t a9, ...)
{
  va_start(va2, a9);
  va_start(va1, a9);
  va_start(va, a9);
  v10.__locale_ = va_arg(va1, std::locale::__imp *);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  va_copy(va2, va1);
  BOOL v14 = va_arg(va2, void *);
  std::locale::~locale((std::locale *)va);
  sub_10039E2A0((void **)va1);
  sub_1003587C8(&STACK[0x270]);
  sub_10039E2A0((void **)va2);
  sub_1003587C8(&STACK[0x4B8]);
  _Unwind_Resume(a1);
}

uint64_t sub_10039DC8C(uint64_t a1, uint64_t **a2)
{
  bzero(v50, 0x248uLL);
  sub_100358650((uint64_t)v50);
  uint64_t v16 = v50;
  if (*((unsigned char *)&v50[4] + *(void *)(v50[0] - 24)))
  {
LABEL_24:
    uint64_t v4 = 0;
  }
  else
  {
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    *(_OWORD *)__s = 0u;
    long long v19 = 0u;
    for (uint64_t i = (const std::ios_base *)((char *)v50 + *(void *)(v50[0] - 24));
          !i->__rdstate_;
          uint64_t i = (const std::ios_base *)((char *)v50 + *(void *)(v50[0] - 24)))
    {
      std::ios_base::getloc(i);
      BOOL v5 = std::locale::use_facet((const std::locale *)&v15, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
      std::locale::~locale((std::locale *)&v15);
      std::istream::getline();
      if ((*((unsigned char *)&v50[4] + *(void *)(v50[0] - 24)) & 2) != 0) {
        break;
      }
      memset(&v15, 0, sizeof(v15));
      sub_100058DB0(&v15, __s);
      int v6 = SHIBYTE(v15.__r_.__value_.__r.__words[2]);
      if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t size = HIBYTE(v15.__r_.__value_.__r.__words[2]);
      }
      else {
        size_t size = v15.__r_.__value_.__l.__size_;
      }
      if (!size
        || ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? (uint64_t v8 = &v15)
          : (uint64_t v8 = (std::string *)v15.__r_.__value_.__r.__words[0]),
            (int v9 = memchr(v8, 61, size)) == 0 || (v10 = v9 - (unsigned char *)v8, v10 == -1)))
      {
        if (v6 < 0) {
          operator delete(v15.__r_.__value_.__l.__data_);
        }
        goto LABEL_24;
      }
      memset(&v14, 0, sizeof(v14));
      std::string::basic_string(&v14, &v15, 0, v10, (std::allocator<char> *)&__p);
      memset(&__p, 0, sizeof(__p));
      std::string::basic_string(&__p, &v15, v10 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v17);
      char v17 = &v14;
      char v11 = sub_100366370(a2, (void **)&v14.__r_.__value_.__l.__data_, (uint64_t)&unk_10144E20E, (long long **)&v17);
      std::string::operator=((std::string *)(v11 + 7), &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v14.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v15.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v4 = 1;
  }
  sub_10039E2A0(&v16);
  v50[0] = off_1019BBD08;
  v50[54] = off_1019BBD58;
  v50[2] = off_1019BBD30;
  std::filebuf::~filebuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  return v4;
}

void sub_10039E024(_Unwind_Exception *a1)
{
}

BOOL sub_10039E0A4(uint64_t a1, unsigned __int8 *a2)
{
  sub_100058DB0(__p, "");
  BOOL v4 = sub_10039D518(a1, a2, (uint64_t)__p, 1);
  BOOL v6 = v4;
  if (v12 < 0)
  {
    operator delete(__p[0]);
    if (v6) {
      goto LABEL_3;
    }
    return 0;
  }
  if (!v4) {
    return 0;
  }
LABEL_3:
  uint64_t v7 = (const std::__fs::filesystem::path *)(a1 + 32);
  if (*(char *)(a1 + 55) < 0) {
    uint64_t v7 = (const std::__fs::filesystem::path *)v7->__pn_.__r_.__value_.__r.__words[0];
  }
  uint64_t v8 = (const std::__fs::filesystem::path *)(a1 + 8);
  if (*(char *)(a1 + 31) < 0) {
    uint64_t v8 = (const std::__fs::filesystem::path *)v8->__pn_.__r_.__value_.__r.__words[0];
  }
  rename(v7, v8, v5);
  return v9 == 0;
}

void sub_10039E144(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10039E160()
{
  bzero(v3, 0x248uLL);
  sub_100358650((uint64_t)v3);
  unint64_t v2 = v3;
  BOOL v0 = (*(_DWORD *)((unsigned char *)&v3[4] + *(void *)(v3[0] - 24)) & 1) == 0;
  sub_10039E2A0(&v2);
  v3[0] = off_1019BBD08;
  v3[54] = off_1019BBD58;
  v3[2] = off_1019BBD30;
  std::filebuf::~filebuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  return v0;
}

void **sub_10039E2A0(void **a1)
{
  unint64_t v2 = *a1;
  if (!std::filebuf::close()) {
    std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24)), *(_DWORD *)((char *)v2 + *(void *)(*v2 - 24) + 32) | 4);
  }
  return a1;
}

void *sub_10039E2FC(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_10004EF30(a1, a2);
    BOOL v6 = (void *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_10039E364(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_10039E380(int a1)
{
  if ((a1 - 1) > 2) {
    return "cm.?";
  }
  else {
    return off_1019C3B10[a1 - 1];
  }
}

void CellMonitor::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10039E9E8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, dispatch_object_t a12, dispatch_object_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
}

void sub_10039ECB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v6);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  if (v5) {
    dispatch_release(v5);
  }
  JUMPOUT(0x10039EC48);
}

void sub_10039ECEC(uint64_t a1, dispatch_object_t object)
{
  uint64_t v3 = (void *)(a1 + 8);
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v3);
  operator new();
}

void sub_10039EDE4(uint64_t a1, uint64_t a2)
{
  if ((operator==() & 1) == 0 && !*(unsigned char *)(a2 + 4))
  {
    if (*(unsigned char *)(a1 + 132))
    {
      BOOL v4 = *(void **)(a1 + 176);
      BOOL v5 = (void *)(a1 + 184);
      if (v4 != v5)
      {
        do
        {
          uint64_t v6 = v4[5];
          v11[0] = 0;
          v11[1] = 0;
          uint64_t v10 = v11;
          (*(void (**)(uint64_t, void ***))(*(void *)v6 + 104))(v6, &v10);
          sub_1000346F8((uint64_t)&v10, v11[0]);
          uint64_t v7 = (void *)v4[1];
          if (v7)
          {
            do
            {
              uint64_t v8 = v7;
              uint64_t v7 = (void *)*v7;
            }
            while (v7);
          }
          else
          {
            do
            {
              uint64_t v8 = (void *)v4[2];
              BOOL v9 = *v8 == (void)v4;
              BOOL v4 = v8;
            }
            while (!v9);
          }
          BOOL v4 = v8;
        }
        while (v8 != v5);
      }
    }
  }
}

void sub_10039EEC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

void sub_10039EEE0(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 136);
  if (v2 != a2)
  {
    BOOL v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = "false";
      if (a2) {
        uint64_t v7 = "true";
      }
      else {
        uint64_t v7 = "false";
      }
      if (v2) {
        uint64_t v6 = "true";
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v16 = v7;
      __int16 v17 = 2080;
      std::string::size_type v18 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Airplane mode changed from %s to %s", buf, 0x16u);
      int v2 = *(unsigned __int8 *)(a1 + 136);
      BOOL v5 = *(NSObject **)(a1 + 40);
    }
    BOOL v8 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (!v2)
    {
      if (v8)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Refreshing cell info due to radio mode transition", buf, 2u);
      }
      v14[0] = off_1019C38C0;
      v14[1] = a1;
      void v14[3] = v14;
      sub_10001FF4C(a1, 3, 5, (uint64_t)v14);
    }
    if (v8)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Clearing cell info due to airplane mode transition", buf, 2u);
    }
    BOOL v9 = *(void **)(a1 + 176);
    uint64_t v10 = (void *)(a1 + 184);
    if (v9 != v10)
    {
      do
      {
        (*(void (**)(void))(*(void *)v9[5] + 80))(v9[5]);
        uint64_t v11 = (void *)v9[1];
        if (v11)
        {
          do
          {
            char v12 = v11;
            uint64_t v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            char v12 = (void *)v9[2];
            BOOL v13 = *v12 == (void)v9;
            BOOL v9 = v12;
          }
          while (!v13);
        }
        BOOL v9 = v12;
      }
      while (v12 != v10);
    }
  }
}

void sub_10039F0E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10039F100(uint64_t a1)
{
  int v2 = *(void **)(a1 + 176);
  uint64_t v3 = (void *)(a1 + 184);
  if (v2 != (void *)(a1 + 184))
  {
    do
    {
      (*(void (**)(void))(*(void *)v2[5] + 128))(v2[5]);
      BOOL v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          BOOL v5 = v4;
          BOOL v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          BOOL v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          int v2 = v5;
        }
        while (!v6);
      }
      int v2 = v5;
    }
    while (v5 != v3);
  }
  uint64_t v7 = *(uint64_t (**)(void))(**(void **)(a1 + 160) + 56);

  return v7();
}

uint64_t sub_10039F1CC(uint64_t a1)
{
  *(void *)a1 = off_1019C31E0;
  int v2 = (CellMonitorDriverEventHandlerInterface *)(a1 + 48);
  *(void *)(a1 + 48) = off_1019C3290;
  sub_10005D0E4(a1 + 176, *(void **)(a1 + 184));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 168);
  if (v3) {
    sub_10004D2C8(v3);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 152);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_1000346F8(a1 + 104, *(void **)(a1 + 112));
  uint64_t v5 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  BOOL v6 = *(std::__shared_weak_count **)(a1 + 88);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 72);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  CellMonitorDriverEventHandlerInterface::~CellMonitorDriverEventHandlerInterface(v2);
  CellMonitorInterface::~CellMonitorInterface((CellMonitorInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_10039F2FC(uint64_t a1)
{
  return sub_10039F1CC(a1 - 48);
}

void sub_10039F304(uint64_t a1)
{
  sub_10039F1CC(a1);

  operator delete();
}

void sub_10039F33C(uint64_t a1)
{
  sub_10039F1CC(a1 - 48);

  operator delete();
}

uint64_t sub_10039F378(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 160) + 40))(*(void *)(a1 + 160), 0);
  uint64_t result = *(void *)(a1 + 96);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 16))(result);
    uint64_t result = *(void *)(a1 + 96);
    *(void *)(a1 + 96) = 0;
    if (result)
    {
      uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 8);
      return v3();
    }
  }
  return result;
}

void sub_10039F438(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_10039F51C(uint64_t a1)
{
}

void sub_10039F524(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_10039F600(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_10039F6DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_10039F6E4(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    BOOL v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[5])
      {
        v5[0] = off_1019C39C0;
        v5[1] = v3;
        void v5[3] = v5;
        sub_10001FF4C(v3, 3, 2, (uint64_t)v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10039F7A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10001C9D4((uint64_t *)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10039F7C4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10039F7E0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10039F7F0(uint64_t a1, int a2, uint64_t a3)
{
  void v4[4] = a1;
  int v5 = a2;
  sub_1003A3A50((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_10039F934(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10039F94C(uint64_t a1, int a2, uint64_t a3)
{
  void v4[4] = a1;
  int v5 = a2;
  sub_1003A3A50((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_10039FA90(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_10039FAA8(uint64_t a1, int a2)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_1003A3E78;
  void v7[3] = &unk_1019C3A30;
  void v7[4] = a1 + 8;
  v7[5] = v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_1003A3FD8;
    char v12 = &unk_1019C3A70;
    BOOL v13 = &v15;
    std::string v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_1003A3F98;
    char v12 = &unk_1019C3A50;
    BOOL v13 = &v15;
    std::string v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15;
}

uint64_t sub_10039FBDC(uint64_t a1, int a2)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_1003A4018;
  void v7[3] = &unk_1019C3A90;
  void v7[4] = a1 + 8;
  v7[5] = v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_1003A3FD8;
    char v12 = &unk_1019C3A70;
    BOOL v13 = &v15;
    std::string v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    long long block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_1003A3F98;
    char v12 = &unk_1019C3A50;
    BOOL v13 = &v15;
    std::string v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15;
}

void sub_10039FD10(uint64_t a1, int a2, uint64_t a3)
{
  void v4[4] = a1;
  int v5 = a2;
  sub_100356358((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_10039FE54(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10039FE6C(uint64_t a1, int a2, void *a3)
{
  void v5[4] = a1;
  int v6 = a2;
  BOOL v4 = (void *)a3[3];
  if (v4)
  {
    if (v4 == a3)
    {
      uint64_t v8 = v7;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v7);
    }
    else
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_1003A0068(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void *sub_1003A0084(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    int v6 = result;
    sub_1003A010C(result, a4);
    uint64_t result = (void *)sub_1003A01B0((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1003A00EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1003A02B8(&a9);
  _Unwind_Resume(a1);
}

char *sub_1003A010C(void *a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277) {
    sub_10006A748();
  }
  uint64_t result = (char *)sub_1003A0164((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[104 * v4];
  return result;
}

void *sub_1003A0164(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277) {
    sub_10006A7CC();
  }
  return operator new(104 * a2);
}

uint64_t sub_1003A01B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_1003A0234(a4 + v7, a2 + v7);
      v7 += 104;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1003A0210(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 104;
    do
    {
      sub_10003FB84(v4 + v2);
      v2 -= 104;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A0234(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  int v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  long long v6 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 82) = *(_OWORD *)(a2 + 82);
  *(_OWORD *)(a1 + 72) = v6;
  return a1;
}

void sub_1003A029C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

void sub_1003A02B8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    int v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 104;
        sub_10003FB84(v4);
      }
      while ((void *)v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_1003A033C(void *result, uint64_t a2, char *a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_10019E6A8(result, a4);
    uint64_t result = (void *)sub_1003A03C4((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1003A03A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1003A0504(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1003A03C4(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v12 = a4;
  uint64_t v13 = a4;
  v10[0] = a1;
  v10[1] = &v12;
  uint64_t v10[2] = &v13;
  uint64_t v11 = 0;
  if ((char *)a2 != a3)
  {
    long long v6 = (_OWORD *)(a2 + 8);
    do
    {
      uint64_t v7 = (char *)v6 - 8;
      *(_WORD *)uint64_t v4 = *((_WORD *)v6 - 4);
      MCC::MCC((MCC *)(v4 + 8), (const MCC *)v6);
      long long v8 = v6[2];
      *(_OWORD *)(v4 + 54) = *(_OWORD *)((char *)v6 + 46);
      *(_OWORD *)(v4 + 40) = v8;
      uint64_t v4 = v13 + 72;
      v13 += 72;
      long long v6 = (_OWORD *)((char *)v6 + 72);
    }
    while (v7 + 72 != a3);
  }
  LOBYTE(v11) = 1;
  sub_1003A0484((uint64_t)v10);
  return v4;
}

void sub_1003A0470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1003A0484(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1003A04BC(a1);
  }
  return a1;
}

void sub_1003A04BC(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 - 33) < 0) {
      operator delete(*(void **)(v1 - 56));
    }
    v1 -= 72;
  }
}

void sub_1003A0504(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1003A0558((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_1003A0558(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 72)
  {
    if (*(char *)(i - 33) < 0) {
      operator delete(*(void **)(i - 56));
    }
  }
  a1[1] = v2;
}

void *sub_1003A05A8(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_10019FF04(result, a4);
    uint64_t result = (void *)sub_1003A0630((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1003A0610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1003A0738(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1003A0630(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_1003A06B4(a4 + v7, a2 + v7);
      v7 += 96;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1003A0690(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 96;
    do
    {
      sub_10003FB84(v4 + v2);
      v2 -= 96;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A06B4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  int v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  long long v6 = *(_OWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v6;
  return a1;
}

void sub_1003A071C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

void sub_1003A0738(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    int v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 96;
        sub_10003FB84(v4);
      }
      while ((void *)v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_1003A07BC(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_100311F60(result, a4);
    uint64_t result = (void *)sub_1003A0844((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1003A0824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1003A0944(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1003A0844(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_1003A08C8(a4 + v7, a2 + v7);
      v7 += 88;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1003A08A4(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 88;
    do
    {
      sub_10003FB84(v4 + v2);
      v2 -= 88;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A08C8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  int v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  return a1;
}

void sub_1003A0928(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

void sub_1003A0944(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    int v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 88;
        sub_10003FB84(v4);
      }
      while ((void *)v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_1003A09C8(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_10019FF04(result, a4);
    uint64_t result = (void *)sub_1003A0A50((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1003A0A30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1003A0738(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1003A0A50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_1003A0AD4(a4 + v7, a2 + v7);
      v7 += 96;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1003A0AB0(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 96;
    do
    {
      sub_10003FB84(v4 + v2);
      v2 -= 96;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A0AD4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  int v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  long long v6 = *(_OWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v6;
  return a1;
}

void sub_1003A0B3C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

void *sub_1003A0B58(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_1003A0BE0(result, a4);
    uint64_t result = (void *)sub_1003A0C34((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1003A0BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1003A0D4C(&a9);
  _Unwind_Resume(a1);
}

char *sub_1003A0BE0(void *a1, unint64_t a2)
{
  if (a2 >= 0x1E1E1E1E1E1E1E2) {
    sub_10006A748();
  }
  uint64_t result = (char *)sub_100320E18((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[136 * v4];
  return result;
}

uint64_t sub_1003A0C34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_1003A0CB8(a4 + v7, a2 + v7);
      v7 += 136;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1003A0C94(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 136;
    do
    {
      sub_10003FB84(v4 + v2);
      v2 -= 136;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A0CB8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  int v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  long long v6 = *(_OWORD *)(a2 + 72);
  long long v7 = *(_OWORD *)(a2 + 88);
  long long v8 = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 116) = *(_OWORD *)(a2 + 116);
  *(_OWORD *)(a1 + 104) = v8;
  *(_OWORD *)(a1 + 88) = v7;
  *(_OWORD *)(a1 + 72) = v6;
  return a1;
}

void sub_1003A0D30(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

void sub_1003A0D4C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    int v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 136;
        sub_10003FB84(v4);
      }
      while ((void *)v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_1003A0DD0(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    uint64_t result = sub_10004EF30(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1003A0E30(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1003A0E4C(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    uint64_t result = sub_10005CCE8(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1003A0EAC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1003A0EC8(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    uint64_t result = sub_10004EF30(result, a4);
    uint64_t v7 = v6[1];
    uint64_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8 - 1);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1003A0F28(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1003A0F44(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    uint64_t result = sub_10004EF30(result, a4);
    uint64_t v7 = v6[1];
    uint64_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8 - 1);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1003A0FA4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1003A0FC0(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    uint64_t result = sub_10004EF30(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1003A1020(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1003A103C(void *a1, unint64_t a2)
{
  if (a2 >= 0x924924924924925) {
    sub_10006A748();
  }
  uint64_t result = (char *)sub_1003A1094((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[28 * v4];
  return result;
}

void *sub_1003A1094(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x924924924924925) {
    sub_10006A7CC();
  }
  return operator new(28 * a2);
}

void *sub_1003A10E0(void *result, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    uint64_t result = sub_1003A115C(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1003A1140(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1003A115C(void *a1, uint64_t a2)
{
  if (a2 < 0) {
    sub_10006A748();
  }
  uint64_t result = (char *)sub_10006E5B8((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

uint64_t sub_1003A119C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  int v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  long long v6 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 82) = *(_OWORD *)(a2 + 82);
  *(_OWORD *)(a1 + 72) = v6;
  return a1;
}

void sub_1003A1204(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A1220(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  int v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  return a1;
}

void sub_1003A1280(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A129C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  int v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  long long v6 = *(_OWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v6;
  return a1;
}

void sub_1003A1304(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A1320(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  int v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  long long v6 = *(_OWORD *)(a2 + 72);
  long long v7 = *(_OWORD *)(a2 + 88);
  long long v8 = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 116) = *(_OWORD *)(a2 + 116);
  *(_OWORD *)(a1 + 104) = v8;
  *(_OWORD *)(a1 + 88) = v7;
  *(_OWORD *)(a1 + 72) = v6;
  return a1;
}

void sub_1003A1398(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A13B4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  int v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  long long v6 = *(_OWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v6;
  return a1;
}

void sub_1003A141C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

void *sub_1003A1438(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1003A14BC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1003A1544()
{
}

uint64_t sub_1003A1558(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_1003A1568(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1003A15A0(uint64_t a1)
{
}

uint64_t sub_1003A15BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1003A1600(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1003A162C(ServiceManager::Service *this)
{
  *(void *)this = off_1019C3488;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1003A1688(ServiceManager::Service *this)
{
  *(void *)this = off_1019C3488;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1003A16F8@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "CellMonitor");
}

unsigned char *sub_1003A1708@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1003A1748(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_10039ECEC(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_10039ECEC(v4, 0);
}

uint64_t sub_1003A17CC()
{
  return 0;
}

uint64_t sub_1003A17D4()
{
  return 1;
}

uint64_t sub_1003A17DC()
{
  return 0;
}

void sub_1003A17E8(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

void sub_1003A18C4(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(v3 + 8));
  operator new();
}

uint64_t *sub_1003A19D8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void **)(*(void *)v1 + 176);
  uint64_t v4 = *(void *)v1 + 184;
  if (v3 != (void *)v4)
  {
    do
    {
      (*(void (**)(void))(*(void *)v3[5] + 24))(v3[5]);
      int v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          long long v6 = v5;
          int v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          long long v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          uint64_t v3 = v6;
        }
        while (!v7);
      }
      uint64_t v3 = v6;
    }
    while (v6 != (void *)v4);
  }
  sub_10039F378(v2);
  (*(void (**)(void))(**(void **)(v2 + 80) + 32))(*(void *)(v2 + 80));
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 144));
  sub_100088C88(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_1003A1AC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1003A1AE8(void **a1)
{
  uint64_t v1 = *a1;
  long long v19 = a1;
  long long v20 = v1;
  uint64_t v2 = *v1;
  sub_100058DB0(__p, "/cc/props/in_home_countries");
  uint64_t v3 = (uint64_t (***)())operator new(0x28uLL);
  *uint64_t v3 = off_1019C35C0;
  v3[1] = (uint64_t (**)())(v2 + 104);
  v3[2] = (uint64_t (**)())v2;
  v3[3] = (uint64_t (**)())sub_100068C44;
  v3[4] = 0;
  long long v26 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v23);
  if (v22 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/radio_mode");
  uint64_t v4 = (uint64_t (***)())operator new(0x28uLL);
  *uint64_t v4 = off_1019C3640;
  v4[1] = (uint64_t (**)())(v2 + 128);
  void v4[2] = (uint64_t (**)())v2;
  void v4[3] = (uint64_t (**)())sub_10039EDE4;
  void v4[4] = 0;
  long long v26 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v23);
  if (v22 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/airplane_mode");
  int v5 = (uint64_t (***)())operator new(0x28uLL);
  *int v5 = off_1019C36C0;
  v5[1] = (uint64_t (**)())(v2 + 136);
  void v5[2] = (uint64_t (**)())v2;
  void v5[3] = (uint64_t (**)())sub_10039EEE0;
  void v5[4] = 0;
  long long v26 = v5;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v23);
  if (v22 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  long long v6 = (uint64_t (***)())operator new(0x20uLL);
  *long long v6 = off_1019C3740;
  v6[1] = (uint64_t (**)())v2;
  _OWORD v6[2] = (uint64_t (**)())sub_10039F100;
  void v6[3] = 0;
  long long v26 = v6;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v23);
  if (v22 < 0) {
    operator delete(__p[0]);
  }
  sub_10003E168(&v23, (void *)(v2 + 8));
  long long v8 = (std::__shared_weak_count *)v23;
  BOOL v7 = v24;
  if (v24)
  {
    atomic_fetch_add_explicit(&v24->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v7);
  }
  sub_100058DB0(__p, "/cc/events/registration_hints");
  long long v23 = off_1019C37C0;
  long long v24 = v8;
  long long v25 = v7;
  long long v26 = &v23;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v23);
  if (v22 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/lasd_status_hint");
  uint64_t v9 = (uint64_t (***)())operator new(0x20uLL);
  uint64_t *v9 = off_1019C3840;
  v9[1] = (uint64_t (**)())v2;
  void v9[2] = (uint64_t (**)())CellMonitor::sendStatusHint_sync;
  uint64_t v9[3] = 0;
  long long v26 = v9;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v23);
  if (v22 < 0) {
    operator delete(__p[0]);
  }
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)&v23, *(Registry **)(v2 + 64));
  ctu::RestModule::connect();
  if (v24) {
    sub_10004D2C8(v24);
  }
  uint64_t v10 = *(void **)(v2 + 176);
  if (v10 != (void *)(v2 + 184))
  {
    do
    {
      (*(void (**)(void))(*(void *)v10[5] + 16))(v10[5]);
      uint64_t v11 = (void *)v10[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v10[2];
          BOOL v13 = *v12 == (void)v10;
          uint64_t v10 = v12;
        }
        while (!v13);
      }
      uint64_t v10 = v12;
    }
    while (v12 != (void *)(v2 + 184));
  }
  sub_10003E168(&v23, (void *)(v2 + 8));
  std::string v14 = (std::__shared_weak_count *)operator new(0x30uLL);
  v14->__shared_owners_ = 0;
  v14->__shared_weak_owners_ = 0;
  v14->__vftable = (std::__shared_weak_count_vtbl *)off_1019C3508;
  uint64_t v16 = v23;
  uint64_t v15 = v24;
  long long v23 = 0;
  long long v24 = 0;
  v14[1].__vftable = (std::__shared_weak_count_vtbl *)off_1019C3558;
  v14[1].__shared_owners_ = (uint64_t)v16;
  v14[1].__shared_weak_owners_ = (uint64_t)v15;
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v15);
    if (v24) {
      sub_10004D2C8(v24);
    }
  }
  uint64_t v17 = *(void *)(v2 + 80);
  long long v23 = (uint64_t (**)())&v14[1];
  long long v24 = v14;
  (*(void (**)(uint64_t, uint64_t (***)()))(*(void *)v17 + 16))(v17, &v23);
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_100088C88((uint64_t *)&v20);
  return sub_100046B58((uint64_t *)&v19);
}

void sub_1003A1FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_1003A203C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019C3508;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1003A205C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019C3508;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1003A20B0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1003A20D8(CellMonitorDriverEventHandlerInterface *this)
{
  *(void *)this = off_1019C3558;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  CellMonitorDriverEventHandlerInterface::~CellMonitorDriverEventHandlerInterface(this);
}

void sub_1003A2134(CellMonitorDriverEventHandlerInterface *this)
{
  *(void *)this = off_1019C3558;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  CellMonitorDriverEventHandlerInterface::~CellMonitorDriverEventHandlerInterface(this);

  operator delete();
}

void sub_1003A21A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      long long v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 112))(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1003A2238(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1003A224C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      long long v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        std::string __p = 0;
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        sub_1003A10E0(&__p, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 1);
        (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v9 + 128))(v9, a2, &__p);
        if (__p)
        {
          uint64_t v11 = __p;
          operator delete(__p);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1003A2304(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_1003A2330(uint64_t a1, uint64_t a2, int **a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      long long v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        std::string __p = 0;
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        sub_1003A2684((char *)&__p, *a3, a3[1], a3[1] - *a3);
        (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v9 + 136))(v9, a2, &__p);
        if (__p)
        {
          uint64_t v11 = __p;
          operator delete(__p);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1003A23E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_1003A2414(uint64_t a1, uint64_t a2, uint64_t a3, const MCC *a4, const MCC *a5, uint64_t a6, uint64_t a7)
{
  long long v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8)
  {
    uint64_t v15 = std::__shared_weak_count::lock(v8);
    if (v15)
    {
      uint64_t v16 = v15;
      uint64_t v17 = *(void *)(a1 + 8);
      if (v17)
      {
        MCC::MCC((MCC *)v21, a4);
        MCC::MCC((MCC *)&v18, a5);
        (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, uint64_t *, uint64_t, uint64_t))(*(void *)v17 + 152))(v17, a2, a3, v21, &v18, a6, a7);
        if (v20 < 0) {
          operator delete(__p);
        }
        if (v23 < 0) {
          operator delete(v22);
        }
      }
      sub_10004D2C8(v16);
    }
  }
}

void sub_1003A2508(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  sub_10004D2C8(v22);
  _Unwind_Resume(a1);
}

void sub_1003A254C(uint64_t a1, uint64_t a2, uint64_t a3, const MCC *a4, const MCC *a5, uint64_t a6, uint64_t a7)
{
  long long v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8)
  {
    uint64_t v15 = std::__shared_weak_count::lock(v8);
    if (v15)
    {
      uint64_t v16 = v15;
      uint64_t v17 = *(void *)(a1 + 8);
      if (v17)
      {
        MCC::MCC((MCC *)v21, a4);
        MCC::MCC((MCC *)&v18, a5);
        (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, uint64_t *, uint64_t, uint64_t))(*(void *)v17 + 144))(v17, a2, a3, v21, &v18, a6, a7);
        if (v20 < 0) {
          operator delete(__p);
        }
        if (v23 < 0) {
          operator delete(v22);
        }
      }
      sub_10004D2C8(v16);
    }
  }
}

void sub_1003A2640(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  sub_10004D2C8(v22);
  _Unwind_Resume(a1);
}

char *sub_1003A2684(char *result, int *a2, int *a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    uint64_t result = sub_10005CCE8(result, a4);
    uint64_t v7 = (_DWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1003A26DC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003A26F8(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void))(**(void **)(**(void **)a1 + 80) + 24))(*(void *)(**(void **)a1 + 80));
  operator delete();
}

void sub_1003A2770()
{
}

void sub_1003A27A0()
{
}

__n128 sub_1003A27B4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019C35C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1003A2808(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C35C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1003A2840(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003A2880()
{
}

void sub_1003A2890()
{
}

__n128 sub_1003A28A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019C3640;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1003A28F8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C3640;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1003A2930(uint64_t a1)
{
  uint64_t v6 = **(void **)(a1 + 8);
  read_rest_value();
  uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = (void *)(*(void *)(a1 + 16) + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_1003A29B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003A29F4()
{
}

void sub_1003A2A04()
{
}

__n128 sub_1003A2A18(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019C36C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1003A2A6C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C36C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1003A2AA4(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_1003A2B40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003A2B80()
{
}

void sub_1003A2B90()
{
}

__n128 sub_1003A2BA4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019C3740;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1003A2BF8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C3740;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1003A2C30(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1003A2C78(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003A2CB8()
{
}

void *sub_1003A2CC4(void *a1)
{
  *a1 = off_1019C37C0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1003A2D10(void *a1)
{
  *a1 = off_1019C37C0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_1003A2D7C(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019C37C0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1003A2DD8(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019C37C0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1003A2E10(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1003A2E20(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

const void **sub_1003A2E60(uint64_t a1, void **a2)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  lasd::read_rest_value(&v10, a2);
  unsigned int v8 = v10;
  uint64_t v9 = v11;
  uint64_t v11 = 0;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      int v5 = v4;
      uint64_t v6 = *(capabilities::ct **)(a1 + 8);
      if (v6)
      {
        sub_10004EFE4(&v12, &v9);
        CellMonitor::sendBulkHints_sync(v6, 4u, v8, (CFDictionaryRef *)&v12);
        sub_100057D78(&v12);
      }
      sub_10004D2C8(v5);
    }
  }
  sub_1000577C4(&v9);
  return sub_1000577C4(&v11);
}

void sub_1003A2F28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100057D78((const void **)va);
  sub_10004D2C8(v8);
  sub_1000577C4(v7);
  sub_1000577C4(v6);
  _Unwind_Resume(a1);
}

uint64_t sub_1003A2F64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003A2FA4()
{
}

void sub_1003A2FB4()
{
}

__n128 sub_1003A2FC8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019C3840;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1003A301C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C3840;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1003A3054(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  uint64_t v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_1003A3138(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003A3178()
{
}

void sub_1003A3188()
{
}

void *sub_1003A319C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019C38C0;
  result[1] = v3;
  return result;
}

uint64_t sub_1003A31E4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019C38C0;
  a2[1] = v2;
  return result;
}

void sub_1003A3210(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Cell monitor refresh complete", v2, 2u);
  }
}

uint64_t sub_1003A3274(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1003A32B4()
{
}

void sub_1003A32C0(uint64_t a1)
{
  uint64_t v2 = a1;
  if (!*(unsigned char *)(*(void *)a1 + 8))
  {
    uint64_t v1 = *(NSObject **)(**(void **)a1 + 40);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Network Registration Driver went down", buf, 2u);
    }
  }
  operator delete();
}

void sub_1003A3354(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting cell monitor", buf, 2u);
  }
  (*(void (**)(void, uint64_t))(**(void **)(v1 + 160) + 40))(*(void *)(v1 + 160), 1);
  *(void *)long long buf = off_1019C3940;
  uint64_t v5 = v1;
  uint64_t v6 = buf;
  sub_10001FF4C(v1, 3, 2, (uint64_t)buf);
}

void sub_1003A3480(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10001C9D4((uint64_t *)va);
  operator delete();
}

void sub_1003A34C0()
{
}

void *sub_1003A34D4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019C3940;
  result[1] = v3;
  return result;
}

uint64_t sub_1003A351C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019C3940;
  a2[1] = v2;
  return result;
}

void sub_1003A3548(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Cell monitor refresh complete", v2, 2u);
  }
}

uint64_t sub_1003A35AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003A35EC()
{
}

void sub_1003A35F8(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_10039F378(**a1);
  operator delete();
}

void sub_1003A364C()
{
}

void sub_1003A367C()
{
}

void *sub_1003A3690(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019C39C0;
  result[1] = v3;
  return result;
}

uint64_t sub_1003A36D8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019C39C0;
  a2[1] = v2;
  return result;
}

void sub_1003A3704(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Cell monitor refresh complete", v2, 2u);
  }
}

uint64_t sub_1003A3768(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019C3A20)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1003A37A8()
{
  return &off_1019C3A20;
}

uint64_t sub_1003A37B4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  uint64_t v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  long long v6 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 82) = *(_OWORD *)(a2 + 82);
  *(_OWORD *)(a1 + 72) = v6;
  return a1;
}

void sub_1003A381C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A3838(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  uint64_t v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  return a1;
}

void sub_1003A3898(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A38B4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  uint64_t v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  long long v6 = *(_OWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v6;
  return a1;
}

void sub_1003A391C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A3938(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  uint64_t v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  long long v6 = *(_OWORD *)(a2 + 72);
  long long v7 = *(_OWORD *)(a2 + 88);
  long long v8 = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 116) = *(_OWORD *)(a2 + 116);
  *(_OWORD *)(a1 + 104) = v8;
  *(_OWORD *)(a1 + 88) = v7;
  *(_OWORD *)(a1 + 72) = v6;
  return a1;
}

void sub_1003A39B0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A39CC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  uint64_t v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  long long v6 = *(_OWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v6;
  return a1;
}

void sub_1003A3A34(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A3A50(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_1003A3AE8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_1003A3B68(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  CellMonitor::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v9);
  if (v9)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 48))(v9);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find model for getting area code", buf, 2u);
    }
    uint64_t v3 = 0;
  }
  sub_1003A3CF0(*(void *)(v1 + 40), v3);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1003A3CA0(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_1003A3C74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_1003A3CA0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1003A3CA0(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1003A1438((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_1003A3CF0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v3);
}

uint64_t *sub_1003A3D40(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  CellMonitor::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v9);
  if (v9)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 56))(v9);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find model for getting cell ID", buf, 2u);
    }
    uint64_t v3 = 0;
  }
  sub_1003A3CF0(*(void *)(v1 + 40), v3);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1003A3CA0(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_1003A3E4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_1003A3CA0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1003A3E78(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v7 = 0;
  long long v8 = 0;
  uint64_t v2 = *(void *)v1;
  CellMonitor::getModel_sync(*(void *)v1, **(_DWORD **)(v1 + 8), &v7);
  if (v7)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 48))(v7);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), **(unsigned int **)(v1 + 8));
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v6 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find model for getting area code", v6, 2u);
    }
    uint64_t v3 = 0;
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  return v3;
}

void sub_1003A3F7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A3F98(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)uint64_t v3 = result;
  *(unsigned char *)(v3 + 8) = v4;
  return result;
}

uint64_t sub_1003A3FD8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)uint64_t v3 = result;
  *(unsigned char *)(v3 + 8) = v4;
  return result;
}

uint64_t sub_1003A4018(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v7 = 0;
  long long v8 = 0;
  uint64_t v2 = *(void *)v1;
  CellMonitor::getModel_sync(*(void *)v1, **(_DWORD **)(v1 + 8), &v7);
  if (v7)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 56))(v7);
  }
  else
  {
    char v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), **(unsigned int **)(v1 + 8));
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v6 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find model for getting cell ID", v6, 2u);
    }
    uint64_t v3 = 0;
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  return v3;
}

void sub_1003A411C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1003A4138(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  CellMonitor::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v9);
  if (v9)
  {
    int v3 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 64))(v9);
  }
  else
  {
    char v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find model for getting base ID", buf, 2u);
    }
    int v3 = 0;
  }
  sub_100356304(v1 + 16, v3);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1003A4270(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_1003A4244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_1003A4270(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1003A4270(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1000F8E94((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_1003A42C0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  CellMonitor::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v11);
  uint64_t v3 = v11;
  if (v11)
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 56))(v11);
    int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 64))(v3);
    sub_1003A4498(*(void *)(v1 + 40), v4, v5);
  }
  else
  {
    long long v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find model for getting public cell ID", buf, 2u);
    }
    sub_1003A4498(*(void *)(v1 + 40), 0, 0);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_1003A4448(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_1003A4414(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_1003A4448(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1003A4448(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1003A14BC((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_1003A4498(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = a2;
  int v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, int *))(*(void *)a1 + 48))(a1, &v5, &v4);
}

uint64_t sub_1003A44F0(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  uint64_t v3 = *(void *)(a1 + 32);
  *(_DWORD *)uint64_t v3 = result;
  *(_WORD *)(v3 + 4) = WORD2(result);
  return result;
}

const void **sub_1003A4534@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  CFMutableDictionaryRef v35 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v5 = v35;
    CFMutableDictionaryRef v35 = Mutable;
    *(void *)&long long v53 = v5;
    sub_10005717C((const void **)&v53);
  }
  if (*(unsigned char *)(a1 + 120))
  {
    long long v6 = v35;
    if (*(char *)(a1 + 119) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 96), *(void *)(a1 + 104));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 96);
      uint64_t v34 = *(void *)(a1 + 112);
    }
    if (SHIBYTE(v34) < 0)
    {
      sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long __dst = *(_OWORD *)__p;
      uint64_t v52 = v34;
    }
    v43[0] = 0;
    if (SHIBYTE(v52) < 0)
    {
      sub_10004FC84(&v53, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      long long v53 = __dst;
      uint64_t v54 = v52;
    }
    v45[0] = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v7 = v43[0];
      v43[0] = v45[0];
      *(void *)&long long v47 = v7;
      sub_1000558F4((const void **)&v47);
    }
    if (SHIBYTE(v54) < 0) {
      operator delete((void *)v53);
    }
    value[0] = v43[0];
    v43[0] = 0;
    sub_1000558F4((const void **)v43);
    if (SHIBYTE(v52) < 0) {
      operator delete((void *)__dst);
    }
    CFDictionaryAddValue(v6, @"connectivity-auth-type", value[0]);
    sub_1000558F4((const void **)value);
    if (SHIBYTE(v34) < 0) {
      operator delete(__p[0]);
    }
  }
  if (*(unsigned char *)(a1 + 448))
  {
    long long v8 = v35;
    CFMutableDictionaryRef v9 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    long long v49 = v9;
    if (*(unsigned char *)(a1 + 280))
    {
      if (*(char *)(a1 + 279) < 0)
      {
        sub_10004FC84(&v47, *(void **)(a1 + 256), *(void *)(a1 + 264));
      }
      else
      {
        long long v47 = *(_OWORD *)(a1 + 256);
        uint64_t v48 = *(void *)(a1 + 272);
      }
      if (SHIBYTE(v48) < 0)
      {
        sub_10004FC84(&__dst, (void *)v47, *((unint64_t *)&v47 + 1));
      }
      else
      {
        long long __dst = v47;
        uint64_t v52 = v48;
      }
      value[0] = 0;
      if (SHIBYTE(v52) < 0)
      {
        sub_10004FC84(&v53, (void *)__dst, *((unint64_t *)&__dst + 1));
      }
      else
      {
        long long v53 = __dst;
        uint64_t v54 = v52;
      }
      v43[0] = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v10 = value[0];
        value[0] = v43[0];
        v45[0] = v10;
        sub_1000558F4((const void **)v45);
      }
      if (SHIBYTE(v54) < 0) {
        operator delete((void *)v53);
      }
      v39[0] = value[0];
      value[0] = 0;
      sub_1000558F4((const void **)value);
      if (SHIBYTE(v52) < 0) {
        operator delete((void *)__dst);
      }
      CFDictionaryAddValue(v9, @"organization", v39[0]);
      sub_1000558F4((const void **)v39);
      if (SHIBYTE(v48) < 0) {
        operator delete((void *)v47);
      }
    }
    if (*(unsigned char *)(a1 + 312))
    {
      uint64_t v11 = v49;
      if (*(char *)(a1 + 311) < 0)
      {
        sub_10004FC84(v45, *(void **)(a1 + 288), *(void *)(a1 + 296));
      }
      else
      {
        *(_OWORD *)long long v45 = *(_OWORD *)(a1 + 288);
        uint64_t v46 = *(void *)(a1 + 304);
      }
      if (SHIBYTE(v46) < 0)
      {
        sub_10004FC84(&__dst, v45[0], (unint64_t)v45[1]);
      }
      else
      {
        long long __dst = *(_OWORD *)v45;
        uint64_t v52 = v46;
      }
      v39[0] = 0;
      if (SHIBYTE(v52) < 0)
      {
        sub_10004FC84(&v53, (void *)__dst, *((unint64_t *)&__dst + 1));
      }
      else
      {
        long long v53 = __dst;
        uint64_t v54 = v52;
      }
      value[0] = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v12 = v39[0];
        v39[0] = value[0];
        v43[0] = v12;
        sub_1000558F4((const void **)v43);
      }
      if (SHIBYTE(v54) < 0) {
        operator delete((void *)v53);
      }
      v36[0] = v39[0];
      v39[0] = 0;
      sub_1000558F4((const void **)v39);
      if (SHIBYTE(v52) < 0) {
        operator delete((void *)__dst);
      }
      CFDictionaryAddValue(v11, @"department", v36[0]);
      sub_1000558F4((const void **)v36);
      if (SHIBYTE(v46) < 0) {
        operator delete(v45[0]);
      }
    }
    if (*(unsigned char *)(a1 + 344))
    {
      unsigned int v13 = v49;
      if (*(char *)(a1 + 343) < 0)
      {
        sub_10004FC84(v43, *(void **)(a1 + 320), *(void *)(a1 + 328));
      }
      else
      {
        *(_OWORD *)long long v43 = *(_OWORD *)(a1 + 320);
        uint64_t v44 = *(void *)(a1 + 336);
      }
      if (SHIBYTE(v44) < 0)
      {
        sub_10004FC84(&__dst, v43[0], (unint64_t)v43[1]);
      }
      else
      {
        long long __dst = *(_OWORD *)v43;
        uint64_t v52 = v44;
      }
      v36[0] = 0;
      if (SHIBYTE(v52) < 0)
      {
        sub_10004FC84(&v53, (void *)__dst, *((unint64_t *)&__dst + 1));
      }
      else
      {
        long long v53 = __dst;
        uint64_t v54 = v52;
      }
      v39[0] = 0;
      if (ctu::cf::convert_copy())
      {
        std::string v14 = v36[0];
        v36[0] = v39[0];
        value[0] = v14;
        sub_1000558F4((const void **)value);
      }
      if (SHIBYTE(v54) < 0) {
        operator delete((void *)v53);
      }
      long long v56 = v36[0];
      v36[0] = 0;
      sub_1000558F4((const void **)v36);
      if (SHIBYTE(v52) < 0) {
        operator delete((void *)__dst);
      }
      CFDictionaryAddValue(v13, @"city", v56);
      sub_1000558F4(&v56);
      if (SHIBYTE(v44) < 0) {
        operator delete(v43[0]);
      }
    }
    if (*(unsigned char *)(a1 + 376))
    {
      uint64_t v15 = v49;
      if (*(char *)(a1 + 375) < 0)
      {
        sub_10004FC84(value, *(void **)(a1 + 352), *(void *)(a1 + 360));
      }
      else
      {
        *(_OWORD *)xpc_object_t value = *(_OWORD *)(a1 + 352);
        uint64_t v42 = *(void *)(a1 + 368);
      }
      if (SHIBYTE(v42) < 0)
      {
        sub_10004FC84(&__dst, value[0], (unint64_t)value[1]);
      }
      else
      {
        long long __dst = *(_OWORD *)value;
        uint64_t v52 = v42;
      }
      long long v56 = 0;
      if (SHIBYTE(v52) < 0)
      {
        sub_10004FC84(&v53, (void *)__dst, *((unint64_t *)&__dst + 1));
      }
      else
      {
        long long v53 = __dst;
        uint64_t v54 = v52;
      }
      v36[0] = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v16 = (void *)v56;
        long long v56 = v36[0];
        v39[0] = v16;
        sub_1000558F4((const void **)v39);
      }
      if (SHIBYTE(v54) < 0) {
        operator delete((void *)v53);
      }
      long long v55 = v56;
      long long v56 = 0;
      sub_1000558F4(&v56);
      if (SHIBYTE(v52) < 0) {
        operator delete((void *)__dst);
      }
      CFDictionaryAddValue(v15, @"state", v55);
      sub_1000558F4(&v55);
      if (SHIBYTE(v42) < 0) {
        operator delete(value[0]);
      }
    }
    if (*(unsigned char *)(a1 + 408))
    {
      uint64_t v17 = v49;
      if (*(char *)(a1 + 407) < 0)
      {
        sub_10004FC84(v39, *(void **)(a1 + 384), *(void *)(a1 + 392));
      }
      else
      {
        *(_OWORD *)long long v39 = *(_OWORD *)(a1 + 384);
        uint64_t v40 = *(void *)(a1 + 400);
      }
      if (SHIBYTE(v40) < 0)
      {
        sub_10004FC84(&__dst, v39[0], (unint64_t)v39[1]);
      }
      else
      {
        long long __dst = *(_OWORD *)v39;
        uint64_t v52 = v40;
      }
      long long v55 = 0;
      if (SHIBYTE(v52) < 0)
      {
        sub_10004FC84(&v53, (void *)__dst, *((unint64_t *)&__dst + 1));
      }
      else
      {
        long long v53 = __dst;
        uint64_t v54 = v52;
      }
      long long v56 = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v18 = (void *)v55;
        long long v55 = v56;
        v36[0] = v18;
        sub_1000558F4((const void **)v36);
      }
      if (SHIBYTE(v54) < 0) {
        operator delete((void *)v53);
      }
      int v50 = v55;
      long long v55 = 0;
      sub_1000558F4(&v55);
      if (SHIBYTE(v52) < 0) {
        operator delete((void *)__dst);
      }
      CFDictionaryAddValue(v17, @"country", v50);
      sub_1000558F4(&v50);
      if (SHIBYTE(v40) < 0) {
        operator delete(v39[0]);
      }
    }
    if (*(unsigned char *)(a1 + 440))
    {
      long long v19 = v49;
      if (*(char *)(a1 + 439) < 0)
      {
        sub_10004FC84(v36, *(void **)(a1 + 416), *(void *)(a1 + 424));
      }
      else
      {
        *(_OWORD *)long long v36 = *(_OWORD *)(a1 + 416);
        uint64_t v37 = *(void *)(a1 + 432);
      }
      if (SHIBYTE(v37) < 0)
      {
        sub_10004FC84(&__dst, v36[0], (unint64_t)v36[1]);
      }
      else
      {
        long long __dst = *(_OWORD *)v36;
        uint64_t v52 = v37;
      }
      int v50 = 0;
      if (SHIBYTE(v52) < 0)
      {
        sub_10004FC84(&v53, (void *)__dst, *((unint64_t *)&__dst + 1));
      }
      else
      {
        long long v53 = __dst;
        uint64_t v54 = v52;
      }
      long long v55 = 0;
      if (ctu::cf::convert_copy())
      {
        char v20 = v50;
        int v50 = v55;
        long long v56 = v20;
        sub_1000558F4(&v56);
      }
      if (SHIBYTE(v54) < 0) {
        operator delete((void *)v53);
      }
      long long v21 = v50;
      long long v38 = v50;
      int v50 = 0;
      sub_1000558F4(&v50);
      if (SHIBYTE(v52) < 0) {
        operator delete((void *)__dst);
      }
      CFDictionaryAddValue(v19, @"email", v21);
      sub_1000558F4(&v38);
      if (SHIBYTE(v37) < 0) {
        operator delete(v36[0]);
      }
    }
    sub_10004EFE4(&v32, (CFTypeRef *)&v49);
    sub_10005717C((const void **)&v49);
    CFDictionaryAddValue(v8, @"certificate-info", v32);
    sub_100057D78((const void **)&v32);
  }
  if (*(unsigned char *)(a1 + 184))
  {
    char v22 = v35;
    if (*(char *)(a1 + 183) < 0)
    {
      sub_10004FC84(v30, *(void **)(a1 + 160), *(void *)(a1 + 168));
    }
    else
    {
      *(_OWORD *)long long v30 = *(_OWORD *)(a1 + 160);
      uint64_t v31 = *(void *)(a1 + 176);
    }
    if (SHIBYTE(v31) < 0)
    {
      sub_10004FC84(&__dst, v30[0], (unint64_t)v30[1]);
    }
    else
    {
      long long __dst = *(_OWORD *)v30;
      uint64_t v52 = v31;
    }
    v43[0] = 0;
    if (SHIBYTE(v52) < 0)
    {
      sub_10004FC84(&v53, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      long long v53 = __dst;
      uint64_t v54 = v52;
    }
    v45[0] = 0;
    if (ctu::cf::convert_copy())
    {
      char v23 = v43[0];
      v43[0] = v45[0];
      *(void *)&long long v47 = v23;
      sub_1000558F4((const void **)&v47);
    }
    if (SHIBYTE(v54) < 0) {
      operator delete((void *)v53);
    }
    value[0] = v43[0];
    v43[0] = 0;
    sub_1000558F4((const void **)v43);
    if (SHIBYTE(v52) < 0) {
      operator delete((void *)__dst);
    }
    CFDictionaryAddValue(v22, @"gateway-address", value[0]);
    sub_1000558F4((const void **)value);
    if (SHIBYTE(v31) < 0) {
      operator delete(v30[0]);
    }
  }
  if (*(unsigned char *)(a1 + 216))
  {
    long long v24 = v35;
    if (*(char *)(a1 + 215) < 0)
    {
      sub_10004FC84(v28, *(void **)(a1 + 192), *(void *)(a1 + 200));
    }
    else
    {
      *(_OWORD *)long long v28 = *(_OWORD *)(a1 + 192);
      uint64_t v29 = *(void *)(a1 + 208);
    }
    if (SHIBYTE(v29) < 0)
    {
      sub_10004FC84(&__dst, v28[0], (unint64_t)v28[1]);
    }
    else
    {
      long long __dst = *(_OWORD *)v28;
      uint64_t v52 = v29;
    }
    v43[0] = 0;
    if (SHIBYTE(v52) < 0)
    {
      sub_10004FC84(&v53, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      long long v53 = __dst;
      uint64_t v54 = v52;
    }
    v45[0] = 0;
    if (ctu::cf::convert_copy())
    {
      long long v25 = v43[0];
      v43[0] = v45[0];
      *(void *)&long long v47 = v25;
      sub_1000558F4((const void **)&v47);
    }
    if (SHIBYTE(v54) < 0) {
      operator delete((void *)v53);
    }
    long long v26 = v43[0];
    value[0] = v43[0];
    v43[0] = 0;
    sub_1000558F4((const void **)v43);
    if (SHIBYTE(v52) < 0) {
      operator delete((void *)__dst);
    }
    CFDictionaryAddValue(v24, @"entitlement-server-address", v26);
    sub_1000558F4((const void **)value);
    if (SHIBYTE(v29) < 0) {
      operator delete(v28[0]);
    }
  }
  sub_10004EFE4(a2, (CFTypeRef *)&v35);
  return sub_10005717C((const void **)&v35);
}

void sub_1003A5068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,const void *a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,uint64_t a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,uint64_t a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  sub_1000558F4((const void **)(v63 - 152));
  if (*(char *)(v63 - 121) < 0) {
    operator delete(*(void **)(v63 - 144));
  }
  if (a35 < 0) {
    operator delete(__p);
  }
  sub_10005717C((const void **)(v63 - 160));
  sub_10005717C(&a29);
  _Unwind_Resume(a1);
}

void sub_1003A5408(uint64_t a1, CFDictionaryRef theDict)
{
  CFNumberRef Value = CFDictionaryGetValue(theDict, @"connectivity-auth-type");
  if (Value)
  {
    CFTypeID v5 = CFGetTypeID(Value);
    if (v5 == CFStringGetTypeID())
    {
      long long v25 = 0uLL;
      *(void *)&long long v26 = 0;
      ctu::cf::assign();
      long long v39 = 0uLL;
      uint64_t v40 = 0;
      sub_10008BE4C(a1 + 96, &v39);
      if (SHIBYTE(v40) < 0) {
        operator delete((void *)v39);
      }
    }
  }
  CFDictionaryRef v6 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"certificate-info");
  if (v6)
  {
    CFDictionaryRef v7 = v6;
    CFTypeID v8 = CFGetTypeID(v6);
    if (v8 == CFDictionaryGetTypeID())
    {
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      sub_1003A58F0(a1 + 224, (__n128 *)&v25);
      sub_10019D7CC((uint64_t)&v25);
      CFMutableDictionaryRef v9 = CFDictionaryGetValue(v7, @"organization");
      if (v9)
      {
        CFTypeID v10 = CFGetTypeID(v9);
        if (v10 == CFStringGetTypeID())
        {
          long long v25 = 0uLL;
          *(void *)&long long v26 = 0;
          ctu::cf::assign();
          long long v39 = v25;
          uint64_t v40 = v26;
          sub_10008BE4C(a1 + 256, &v39);
          if (SHIBYTE(v40) < 0) {
            operator delete((void *)v39);
          }
        }
      }
      uint64_t v11 = CFDictionaryGetValue(v7, @"department");
      if (v11)
      {
        CFTypeID v12 = CFGetTypeID(v11);
        if (v12 == CFStringGetTypeID())
        {
          long long v25 = 0uLL;
          *(void *)&long long v26 = 0;
          ctu::cf::assign();
          long long v39 = v25;
          uint64_t v40 = v26;
          sub_10008BE4C(a1 + 288, &v39);
          if (SHIBYTE(v40) < 0) {
            operator delete((void *)v39);
          }
        }
      }
      unsigned int v13 = CFDictionaryGetValue(v7, @"city");
      if (v13)
      {
        CFTypeID v14 = CFGetTypeID(v13);
        if (v14 == CFStringGetTypeID())
        {
          long long v25 = 0uLL;
          *(void *)&long long v26 = 0;
          ctu::cf::assign();
          long long v39 = v25;
          uint64_t v40 = v26;
          sub_10008BE4C(a1 + 320, &v39);
          if (SHIBYTE(v40) < 0) {
            operator delete((void *)v39);
          }
        }
      }
      uint64_t v15 = CFDictionaryGetValue(v7, @"state");
      if (v15)
      {
        CFTypeID v16 = CFGetTypeID(v15);
        if (v16 == CFStringGetTypeID())
        {
          long long v25 = 0uLL;
          *(void *)&long long v26 = 0;
          ctu::cf::assign();
          long long v39 = v25;
          uint64_t v40 = v26;
          sub_10008BE4C(a1 + 352, &v39);
          if (SHIBYTE(v40) < 0) {
            operator delete((void *)v39);
          }
        }
      }
      uint64_t v17 = CFDictionaryGetValue(v7, @"country");
      if (v17)
      {
        CFTypeID v18 = CFGetTypeID(v17);
        if (v18 == CFStringGetTypeID())
        {
          long long v25 = 0uLL;
          *(void *)&long long v26 = 0;
          ctu::cf::assign();
          long long v39 = v25;
          uint64_t v40 = v26;
          sub_10008BE4C(a1 + 384, &v39);
          if (SHIBYTE(v40) < 0) {
            operator delete((void *)v39);
          }
        }
      }
      long long v19 = CFDictionaryGetValue(v7, @"email");
      if (v19)
      {
        CFTypeID v20 = CFGetTypeID(v19);
        if (v20 == CFStringGetTypeID())
        {
          long long v25 = 0uLL;
          *(void *)&long long v26 = 0;
          ctu::cf::assign();
          long long v39 = v25;
          uint64_t v40 = v26;
          sub_10008BE4C(a1 + 416, &v39);
          if (SHIBYTE(v40) < 0) {
            operator delete((void *)v39);
          }
        }
      }
    }
  }
  long long v21 = CFDictionaryGetValue(theDict, @"gateway-address");
  if (v21)
  {
    CFTypeID v22 = CFGetTypeID(v21);
    if (v22 == CFStringGetTypeID())
    {
      long long v25 = 0uLL;
      *(void *)&long long v26 = 0;
      ctu::cf::assign();
      long long v39 = v25;
      uint64_t v40 = v26;
      sub_10008BE4C(a1 + 160, &v39);
      if (SHIBYTE(v40) < 0) {
        operator delete((void *)v39);
      }
    }
  }
  char v23 = CFDictionaryGetValue(theDict, @"entitlement-server-address");
  if (v23)
  {
    CFTypeID v24 = CFGetTypeID(v23);
    if (v24 == CFStringGetTypeID())
    {
      long long v25 = 0uLL;
      *(void *)&long long v26 = 0;
      ctu::cf::assign();
      long long v39 = v25;
      uint64_t v40 = v26;
      sub_10008BE4C(a1 + 192, &v39);
      if (SHIBYTE(v40) < 0) {
        operator delete((void *)v39);
      }
    }
  }
}

void sub_1003A5870(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (*(char *)(v14 - 57) < 0) {
    operator delete(*(void **)(v14 - 80));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A58F0(uint64_t a1, __n128 *a2)
{
  if (*(unsigned char *)(a1 + 224))
  {
    sub_1003AA440(a1, a2);
  }
  else
  {
    sub_1003AA4D0(a1, a2);
    *(unsigned char *)(a1 + 224) = 1;
  }
  return a1;
}

void sub_1003A5938(long long *a1@<X0>, CFMutableDictionaryRef *a2@<X8>)
{
  *a2 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFTypeID v5 = Mutable;
  if (Mutable)
  {
    *a2 = Mutable;
    *(void *)&long long v58 = 0;
    sub_10005717C((const void **)&v58);
  }
  if (*((unsigned char *)a1 + 256))
  {
    CFMutableDictionaryRef v6 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v54 = v6;
    if (*((unsigned char *)a1 + 24))
    {
      if (*((char *)a1 + 23) < 0)
      {
        sub_10004FC84(&__dst, *(void **)a1, *((void *)a1 + 1));
      }
      else
      {
        long long __dst = *a1;
        uint64_t v53 = *((void *)a1 + 2);
      }
      if (SHIBYTE(v53) < 0)
      {
        sub_10004FC84(&v56, (void *)__dst, *((unint64_t *)&__dst + 1));
      }
      else
      {
        long long v56 = __dst;
        uint64_t v57 = v53;
      }
      __p[0] = 0;
      if (SHIBYTE(v57) < 0)
      {
        sub_10004FC84(&v58, (void *)v56, *((unint64_t *)&v56 + 1));
      }
      else
      {
        long long v58 = v56;
        uint64_t v59 = v57;
      }
      *(void *)&long long v48 = 0;
      if (ctu::cf::convert_copy())
      {
        CFDictionaryRef v7 = __p[0];
        __p[0] = (void *)v48;
        *(void *)&long long v50 = v7;
        sub_1000558F4((const void **)&v50);
      }
      if (SHIBYTE(v59) < 0) {
        operator delete((void *)v58);
      }
      value[0] = __p[0];
      __p[0] = 0;
      sub_1000558F4((const void **)__p);
      if (SHIBYTE(v57) < 0) {
        operator delete((void *)v56);
      }
      CFDictionaryAddValue(v6, @"csr", value[0]);
      sub_1000558F4((const void **)value);
      if (SHIBYTE(v53) < 0) {
        operator delete((void *)__dst);
      }
    }
    if (*((unsigned char *)a1 + 56))
    {
      CFTypeID v8 = v54;
      if (*((char *)a1 + 55) < 0)
      {
        sub_10004FC84(&v50, *((void **)a1 + 4), *((void *)a1 + 5));
      }
      else
      {
        long long v50 = a1[2];
        uint64_t v51 = *((void *)a1 + 6);
      }
      if (SHIBYTE(v51) < 0)
      {
        sub_10004FC84(&v56, (void *)v50, *((unint64_t *)&v50 + 1));
      }
      else
      {
        long long v56 = v50;
        uint64_t v57 = v51;
      }
      value[0] = 0;
      if (SHIBYTE(v57) < 0)
      {
        sub_10004FC84(&v58, (void *)v56, *((unint64_t *)&v56 + 1));
      }
      else
      {
        long long v58 = v56;
        uint64_t v59 = v57;
      }
      __p[0] = 0;
      if (ctu::cf::convert_copy())
      {
        CFMutableDictionaryRef v9 = value[0];
        value[0] = __p[0];
        *(void *)&long long v48 = v9;
        sub_1000558F4((const void **)&v48);
      }
      if (SHIBYTE(v59) < 0) {
        operator delete((void *)v58);
      }
      v42[0] = value[0];
      value[0] = 0;
      sub_1000558F4((const void **)value);
      if (SHIBYTE(v57) < 0) {
        operator delete((void *)v56);
      }
      CFDictionaryAddValue(v8, @"sip-uri", v42[0]);
      sub_1000558F4((const void **)v42);
      if (SHIBYTE(v51) < 0) {
        operator delete((void *)v50);
      }
    }
    if (*((unsigned char *)a1 + 88))
    {
      CFTypeID v10 = v54;
      if (*((char *)a1 + 87) < 0)
      {
        sub_10004FC84(&v48, *((void **)a1 + 8), *((void *)a1 + 9));
      }
      else
      {
        long long v48 = a1[4];
        uint64_t v49 = *((void *)a1 + 10);
      }
      if (SHIBYTE(v49) < 0)
      {
        sub_10004FC84(&v56, (void *)v48, *((unint64_t *)&v48 + 1));
      }
      else
      {
        long long v56 = v48;
        uint64_t v57 = v49;
      }
      v42[0] = 0;
      if (SHIBYTE(v57) < 0)
      {
        sub_10004FC84(&v58, (void *)v56, *((unint64_t *)&v56 + 1));
      }
      else
      {
        long long v58 = v56;
        uint64_t v59 = v57;
      }
      value[0] = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v11 = v42[0];
        v42[0] = value[0];
        __p[0] = v11;
        sub_1000558F4((const void **)__p);
      }
      if (SHIBYTE(v59) < 0) {
        operator delete((void *)v58);
      }
      v40[0] = v42[0];
      v42[0] = 0;
      sub_1000558F4((const void **)v42);
      if (SHIBYTE(v57) < 0) {
        operator delete((void *)v56);
      }
      CFDictionaryAddValue(v10, @"apn", v40[0]);
      sub_1000558F4((const void **)v40);
      if (SHIBYTE(v49) < 0) {
        operator delete((void *)v48);
      }
    }
    if (*((unsigned char *)a1 + 120))
    {
      CFTypeID v12 = v54;
      if (*((char *)a1 + 119) < 0)
      {
        sub_10004FC84(__p, *((void **)a1 + 12), *((void *)a1 + 13));
      }
      else
      {
        *(_OWORD *)std::string __p = a1[6];
        uint64_t v47 = *((void *)a1 + 14);
      }
      if (SHIBYTE(v47) < 0)
      {
        sub_10004FC84(&v56, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        long long v56 = *(_OWORD *)__p;
        uint64_t v57 = v47;
      }
      v40[0] = 0;
      if (SHIBYTE(v57) < 0)
      {
        sub_10004FC84(&v58, (void *)v56, *((unint64_t *)&v56 + 1));
      }
      else
      {
        long long v58 = v56;
        uint64_t v59 = v57;
      }
      v42[0] = 0;
      if (ctu::cf::convert_copy())
      {
        unsigned int v13 = v40[0];
        v40[0] = v42[0];
        value[0] = v13;
        sub_1000558F4((const void **)value);
      }
      if (SHIBYTE(v59) < 0) {
        operator delete((void *)v58);
      }
      v37[0] = v40[0];
      v40[0] = 0;
      sub_1000558F4((const void **)v40);
      if (SHIBYTE(v57) < 0) {
        operator delete((void *)v56);
      }
      CFDictionaryAddValue(v12, @"username", v37[0]);
      sub_1000558F4((const void **)v37);
      if (SHIBYTE(v47) < 0) {
        operator delete(__p[0]);
      }
    }
    if (*((unsigned char *)a1 + 152))
    {
      uint64_t v14 = v54;
      if (*((char *)a1 + 151) < 0)
      {
        sub_10004FC84(value, *((void **)a1 + 16), *((void *)a1 + 17));
      }
      else
      {
        *(_OWORD *)xpc_object_t value = a1[8];
        uint64_t v45 = *((void *)a1 + 18);
      }
      if (SHIBYTE(v45) < 0)
      {
        sub_10004FC84(&v56, value[0], (unint64_t)value[1]);
      }
      else
      {
        long long v56 = *(_OWORD *)value;
        uint64_t v57 = v45;
      }
      v37[0] = 0;
      if (SHIBYTE(v57) < 0)
      {
        sub_10004FC84(&v58, (void *)v56, *((unint64_t *)&v56 + 1));
      }
      else
      {
        long long v58 = v56;
        uint64_t v59 = v57;
      }
      v40[0] = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v15 = v37[0];
        v37[0] = v40[0];
        v42[0] = v15;
        sub_1000558F4((const void **)v42);
      }
      if (SHIBYTE(v59) < 0) {
        operator delete((void *)v58);
      }
      long long v61 = v37[0];
      v37[0] = 0;
      sub_1000558F4((const void **)v37);
      if (SHIBYTE(v57) < 0) {
        operator delete((void *)v56);
      }
      CFDictionaryAddValue(v14, @"password", v61);
      sub_1000558F4(&v61);
      if (SHIBYTE(v45) < 0) {
        operator delete(value[0]);
      }
    }
    if (*((unsigned char *)a1 + 184))
    {
      CFTypeID v16 = v54;
      if (*((char *)a1 + 183) < 0)
      {
        sub_10004FC84(v42, *((void **)a1 + 20), *((void *)a1 + 21));
      }
      else
      {
        *(_OWORD *)uint64_t v42 = a1[10];
        uint64_t v43 = *((void *)a1 + 22);
      }
      if (SHIBYTE(v43) < 0)
      {
        sub_10004FC84(&v56, v42[0], (unint64_t)v42[1]);
      }
      else
      {
        long long v56 = *(_OWORD *)v42;
        uint64_t v57 = v43;
      }
      long long v61 = 0;
      if (SHIBYTE(v57) < 0)
      {
        sub_10004FC84(&v58, (void *)v56, *((unint64_t *)&v56 + 1));
      }
      else
      {
        long long v58 = v56;
        uint64_t v59 = v57;
      }
      v37[0] = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v17 = (void *)v61;
        long long v61 = v37[0];
        v40[0] = v17;
        sub_1000558F4((const void **)v40);
      }
      if (SHIBYTE(v59) < 0) {
        operator delete((void *)v58);
      }
      long long v60 = v61;
      long long v61 = 0;
      sub_1000558F4(&v61);
      if (SHIBYTE(v57) < 0) {
        operator delete((void *)v56);
      }
      CFDictionaryAddValue(v16, @"imsi", v60);
      sub_1000558F4(&v60);
      if (SHIBYTE(v43) < 0) {
        operator delete(v42[0]);
      }
    }
    if (*((unsigned char *)a1 + 216))
    {
      CFTypeID v18 = v54;
      if (*((char *)a1 + 215) < 0)
      {
        sub_10004FC84(v40, *((void **)a1 + 24), *((void *)a1 + 25));
      }
      else
      {
        *(_OWORD *)uint64_t v40 = a1[12];
        uint64_t v41 = *((void *)a1 + 26);
      }
      if (SHIBYTE(v41) < 0)
      {
        sub_10004FC84(&v56, v40[0], (unint64_t)v40[1]);
      }
      else
      {
        long long v56 = *(_OWORD *)v40;
        uint64_t v57 = v41;
      }
      long long v60 = 0;
      if (SHIBYTE(v57) < 0)
      {
        sub_10004FC84(&v58, (void *)v56, *((unint64_t *)&v56 + 1));
      }
      else
      {
        long long v58 = v56;
        uint64_t v59 = v57;
      }
      long long v61 = 0;
      if (ctu::cf::convert_copy())
      {
        long long v19 = (void *)v60;
        long long v60 = v61;
        v37[0] = v19;
        sub_1000558F4((const void **)v37);
      }
      if (SHIBYTE(v59) < 0) {
        operator delete((void *)v58);
      }
      long long v55 = v60;
      long long v60 = 0;
      sub_1000558F4(&v60);
      if (SHIBYTE(v57) < 0) {
        operator delete((void *)v56);
      }
      CFDictionaryAddValue(v18, @"impu", v55);
      sub_1000558F4(&v55);
      if (SHIBYTE(v41) < 0) {
        operator delete(v40[0]);
      }
    }
    if (*((unsigned char *)a1 + 248))
    {
      CFTypeID v20 = v54;
      if (*((char *)a1 + 247) < 0)
      {
        sub_10004FC84(v37, *((void **)a1 + 28), *((void *)a1 + 29));
      }
      else
      {
        *(_OWORD *)long long v37 = a1[14];
        uint64_t v38 = *((void *)a1 + 30);
      }
      if (SHIBYTE(v38) < 0)
      {
        sub_10004FC84(&v56, v37[0], (unint64_t)v37[1]);
      }
      else
      {
        long long v56 = *(_OWORD *)v37;
        uint64_t v57 = v38;
      }
      long long v55 = 0;
      if (SHIBYTE(v57) < 0)
      {
        sub_10004FC84(&v58, (void *)v56, *((unint64_t *)&v56 + 1));
      }
      else
      {
        long long v58 = v56;
        uint64_t v59 = v57;
      }
      long long v60 = 0;
      if (ctu::cf::convert_copy())
      {
        long long v21 = v55;
        long long v55 = v60;
        long long v61 = v21;
        sub_1000558F4(&v61);
      }
      if (SHIBYTE(v59) < 0) {
        operator delete((void *)v58);
      }
      CFTypeID v22 = v55;
      long long v39 = v55;
      long long v55 = 0;
      sub_1000558F4(&v55);
      if (SHIBYTE(v57) < 0) {
        operator delete((void *)v56);
      }
      CFDictionaryAddValue(v20, @"pcscf-address", v22);
      sub_1000558F4(&v39);
      if (SHIBYTE(v38) < 0) {
        operator delete(v37[0]);
      }
    }
    sub_10004EFE4(&v36, (CFTypeRef *)&v54);
    sub_10005717C((const void **)&v54);
    CFDictionaryAddValue(v5, @"imsIndividualCredentials", v36);
    sub_100057D78((const void **)&v36);
  }
  if (*((unsigned char *)a1 + 288))
  {
    if (*((char *)a1 + 287) < 0)
    {
      sub_10004FC84(v34, *((void **)a1 + 33), *((void *)a1 + 34));
    }
    else
    {
      *(_OWORD *)long long v34 = *(long long *)((char *)a1 + 264);
      uint64_t v35 = *((void *)a1 + 35);
    }
    if (SHIBYTE(v35) < 0)
    {
      sub_10004FC84(&v56, v34[0], (unint64_t)v34[1]);
    }
    else
    {
      long long v56 = *(_OWORD *)v34;
      uint64_t v57 = v35;
    }
    *(void *)&long long v48 = 0;
    if (SHIBYTE(v57) < 0)
    {
      sub_10004FC84(&v58, (void *)v56, *((unint64_t *)&v56 + 1));
    }
    else
    {
      long long v58 = v56;
      uint64_t v59 = v57;
    }
    *(void *)&long long v50 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v23 = v48;
      *(void *)&long long v48 = v50;
      *(void *)&long long __dst = v23;
      sub_1000558F4((const void **)&__dst);
    }
    if (SHIBYTE(v59) < 0) {
      operator delete((void *)v58);
    }
    __p[0] = (void *)v48;
    *(void *)&long long v48 = 0;
    sub_1000558F4((const void **)&v48);
    if (SHIBYTE(v57) < 0) {
      operator delete((void *)v56);
    }
    CFDictionaryAddValue(v5, @"token", __p[0]);
    sub_1000558F4((const void **)__p);
    if (SHIBYTE(v35) < 0) {
      operator delete(v34[0]);
    }
  }
  if (*((unsigned char *)a1 + 320))
  {
    if (*((char *)a1 + 319) < 0)
    {
      sub_10004FC84(v32, *((void **)a1 + 37), *((void *)a1 + 38));
    }
    else
    {
      *(_OWORD *)long long v32 = *(long long *)((char *)a1 + 296);
      uint64_t v33 = *((void *)a1 + 39);
    }
    if (SHIBYTE(v33) < 0)
    {
      sub_10004FC84(&v56, v32[0], (unint64_t)v32[1]);
    }
    else
    {
      long long v56 = *(_OWORD *)v32;
      uint64_t v57 = v33;
    }
    *(void *)&long long v48 = 0;
    if (SHIBYTE(v57) < 0)
    {
      sub_10004FC84(&v58, (void *)v56, *((unint64_t *)&v56 + 1));
    }
    else
    {
      long long v58 = v56;
      uint64_t v59 = v57;
    }
    *(void *)&long long v50 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v24 = v48;
      *(void *)&long long v48 = v50;
      *(void *)&long long __dst = v24;
      sub_1000558F4((const void **)&__dst);
    }
    if (SHIBYTE(v59) < 0) {
      operator delete((void *)v58);
    }
    __p[0] = (void *)v48;
    *(void *)&long long v48 = 0;
    sub_1000558F4((const void **)&v48);
    if (SHIBYTE(v57) < 0) {
      operator delete((void *)v56);
    }
    CFDictionaryAddValue(v5, @"subscriberId", __p[0]);
    sub_1000558F4((const void **)__p);
    if (SHIBYTE(v33) < 0) {
      operator delete(v32[0]);
    }
  }
  if (*((unsigned char *)a1 + 352))
  {
    if (*((char *)a1 + 351) < 0)
    {
      sub_10004FC84(v30, *((void **)a1 + 41), *((void *)a1 + 42));
    }
    else
    {
      *(_OWORD *)long long v30 = *(long long *)((char *)a1 + 328);
      uint64_t v31 = *((void *)a1 + 43);
    }
    if (SHIBYTE(v31) < 0)
    {
      sub_10004FC84(&v56, v30[0], (unint64_t)v30[1]);
    }
    else
    {
      long long v56 = *(_OWORD *)v30;
      uint64_t v57 = v31;
    }
    *(void *)&long long v48 = 0;
    if (SHIBYTE(v57) < 0)
    {
      sub_10004FC84(&v58, (void *)v56, *((unint64_t *)&v56 + 1));
    }
    else
    {
      long long v58 = v56;
      uint64_t v59 = v57;
    }
    *(void *)&long long v50 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v25 = v48;
      *(void *)&long long v48 = v50;
      *(void *)&long long __dst = v25;
      sub_1000558F4((const void **)&__dst);
    }
    if (SHIBYTE(v59) < 0) {
      operator delete((void *)v58);
    }
    __p[0] = (void *)v48;
    *(void *)&long long v48 = 0;
    sub_1000558F4((const void **)&v48);
    if (SHIBYTE(v57) < 0) {
      operator delete((void *)v56);
    }
    CFDictionaryAddValue(v5, @"gatewayUsername", __p[0]);
    sub_1000558F4((const void **)__p);
    if (SHIBYTE(v31) < 0) {
      operator delete(v30[0]);
    }
  }
  if (*((unsigned char *)a1 + 384))
  {
    if (*((char *)a1 + 383) < 0)
    {
      sub_10004FC84(v28, *((void **)a1 + 45), *((void *)a1 + 46));
    }
    else
    {
      *(_OWORD *)long long v28 = *(long long *)((char *)a1 + 360);
      uint64_t v29 = *((void *)a1 + 47);
    }
    if (SHIBYTE(v29) < 0)
    {
      sub_10004FC84(&v56, v28[0], (unint64_t)v28[1]);
    }
    else
    {
      long long v56 = *(_OWORD *)v28;
      uint64_t v57 = v29;
    }
    *(void *)&long long v48 = 0;
    if (SHIBYTE(v57) < 0)
    {
      sub_10004FC84(&v58, (void *)v56, *((unint64_t *)&v56 + 1));
    }
    else
    {
      long long v58 = v56;
      uint64_t v59 = v57;
    }
    *(void *)&long long v50 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v26 = v48;
      *(void *)&long long v48 = v50;
      *(void *)&long long __dst = v26;
      sub_1000558F4((const void **)&__dst);
    }
    if (SHIBYTE(v59) < 0) {
      operator delete((void *)v58);
    }
    long long v27 = (const void *)v48;
    __p[0] = (void *)v48;
    *(void *)&long long v48 = 0;
    sub_1000558F4((const void **)&v48);
    if (SHIBYTE(v57) < 0) {
      operator delete((void *)v56);
    }
    CFDictionaryAddValue(v5, @"gatewayPassword", v27);
    sub_1000558F4((const void **)__p);
    if (SHIBYTE(v29) < 0) {
      operator delete(v28[0]);
    }
  }
}

void sub_1003A67AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  sub_1000558F4((const void **)(v31 - 152));
  if (*(char *)(v31 - 121) < 0) {
    operator delete(*(void **)(v31 - 144));
  }
  if (a30 < 0) {
    operator delete(__p);
  }
  sub_10005717C((const void **)(v31 - 160));
  sub_10005717C(v30);
  _Unwind_Resume(a1);
}

void sub_1003A6C60()
{
}

void sub_1003A6C6C(uint64_t a1, CFDictionaryRef theDict)
{
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"imsIndividualCredentials");
  if (Value)
  {
    CFDictionaryRef v5 = Value;
    memset(v38, 0, sizeof(v38));
    memset(v37, 0, sizeof(v37));
    memset(v36, 0, sizeof(v36));
    memset(v35, 0, sizeof(v35));
    memset(v34, 0, sizeof(v34));
    memset(v33, 0, sizeof(v33));
    memset(v32, 0, sizeof(v32));
    long long v30 = 0u;
    long long v31 = 0u;
    if (*(unsigned char *)(a1 + 256))
    {
      sub_100179CB0(a1, (__n128 *)&v30);
      sub_100179CB0(a1 + 32, v32);
      sub_100179CB0(a1 + 64, v33);
      sub_100179CB0(a1 + 96, v34);
      sub_100179CB0(a1 + 128, v35);
      sub_100179CB0(a1 + 160, v36);
      sub_100179CB0(a1 + 192, v37);
      sub_100179CB0(a1 + 224, v38);
    }
    else
    {
      sub_1003AA63C(a1, (__n128 *)&v30);
      *(unsigned char *)(a1 + 256) = 1;
    }
    sub_1003AA7DC((uint64_t)&v30);
    CFMutableDictionaryRef v6 = CFDictionaryGetValue(v5, @"csr");
    if (v6)
    {
      CFTypeID v7 = CFGetTypeID(v6);
      if (v7 == CFStringGetTypeID())
      {
        long long v30 = 0uLL;
        *(void *)&long long v31 = 0;
        ctu::cf::assign();
        long long v39 = v30;
        uint64_t v40 = v31;
        sub_10008BE4C(a1, &v39);
        if (SHIBYTE(v40) < 0) {
          operator delete((void *)v39);
        }
      }
    }
    CFTypeID v8 = CFDictionaryGetValue(v5, @"sip-uri");
    if (v8)
    {
      CFTypeID v9 = CFGetTypeID(v8);
      if (v9 == CFStringGetTypeID())
      {
        long long v30 = 0uLL;
        *(void *)&long long v31 = 0;
        ctu::cf::assign();
        long long v39 = v30;
        uint64_t v40 = v31;
        sub_10008BE4C(a1 + 32, &v39);
        if (SHIBYTE(v40) < 0) {
          operator delete((void *)v39);
        }
      }
    }
    CFTypeID v10 = CFDictionaryGetValue(v5, @"apn");
    if (v10)
    {
      CFTypeID v11 = CFGetTypeID(v10);
      if (v11 == CFStringGetTypeID())
      {
        long long v30 = 0uLL;
        *(void *)&long long v31 = 0;
        ctu::cf::assign();
        long long v39 = v30;
        uint64_t v40 = v31;
        sub_10008BE4C(a1 + 64, &v39);
        if (SHIBYTE(v40) < 0) {
          operator delete((void *)v39);
        }
      }
    }
    CFTypeID v12 = CFDictionaryGetValue(v5, @"username");
    if (v12)
    {
      CFTypeID v13 = CFGetTypeID(v12);
      if (v13 == CFStringGetTypeID())
      {
        long long v30 = 0uLL;
        *(void *)&long long v31 = 0;
        ctu::cf::assign();
        long long v39 = v30;
        uint64_t v40 = v31;
        sub_10008BE4C(a1 + 96, &v39);
        if (SHIBYTE(v40) < 0) {
          operator delete((void *)v39);
        }
      }
    }
    uint64_t v14 = CFDictionaryGetValue(v5, @"password");
    if (v14)
    {
      CFTypeID v15 = CFGetTypeID(v14);
      if (v15 == CFStringGetTypeID())
      {
        long long v30 = 0uLL;
        *(void *)&long long v31 = 0;
        ctu::cf::assign();
        long long v39 = v30;
        uint64_t v40 = v31;
        sub_10008BE4C(a1 + 128, &v39);
        if (SHIBYTE(v40) < 0) {
          operator delete((void *)v39);
        }
      }
    }
    CFTypeID v16 = CFDictionaryGetValue(v5, @"imsi");
    if (v16)
    {
      CFTypeID v17 = CFGetTypeID(v16);
      if (v17 == CFStringGetTypeID())
      {
        long long v30 = 0uLL;
        *(void *)&long long v31 = 0;
        ctu::cf::assign();
        long long v39 = v30;
        uint64_t v40 = v31;
        sub_10008BE4C(a1 + 160, &v39);
        if (SHIBYTE(v40) < 0) {
          operator delete((void *)v39);
        }
      }
    }
    CFTypeID v18 = CFDictionaryGetValue(v5, @"impu");
    if (v18)
    {
      CFTypeID v19 = CFGetTypeID(v18);
      if (v19 == CFStringGetTypeID())
      {
        long long v30 = 0uLL;
        *(void *)&long long v31 = 0;
        ctu::cf::assign();
        long long v39 = v30;
        uint64_t v40 = v31;
        sub_10008BE4C(a1 + 192, &v39);
        if (SHIBYTE(v40) < 0) {
          operator delete((void *)v39);
        }
      }
    }
    CFTypeID v20 = CFDictionaryGetValue(v5, @"pcscf-address");
    if (v20)
    {
      CFTypeID v21 = CFGetTypeID(v20);
      if (v21 == CFStringGetTypeID())
      {
        long long v30 = 0uLL;
        *(void *)&long long v31 = 0;
        ctu::cf::assign();
        long long v39 = v30;
        uint64_t v40 = v31;
        sub_10008BE4C(a1 + 224, &v39);
        if (SHIBYTE(v40) < 0) {
          operator delete((void *)v39);
        }
      }
    }
  }
  CFTypeID v22 = CFDictionaryGetValue(theDict, @"token");
  if (v22)
  {
    CFTypeID v23 = CFGetTypeID(v22);
    if (v23 == CFStringGetTypeID())
    {
      long long v30 = 0uLL;
      *(void *)&long long v31 = 0;
      ctu::cf::assign();
      long long v39 = v30;
      uint64_t v40 = v31;
      sub_10008BE4C(a1 + 264, &v39);
      if (SHIBYTE(v40) < 0) {
        operator delete((void *)v39);
      }
    }
  }
  uint64_t v24 = CFDictionaryGetValue(theDict, @"subscriberId");
  if (v24)
  {
    CFTypeID v25 = CFGetTypeID(v24);
    if (v25 == CFStringGetTypeID())
    {
      long long v30 = 0uLL;
      *(void *)&long long v31 = 0;
      ctu::cf::assign();
      long long v39 = v30;
      uint64_t v40 = v31;
      sub_10008BE4C(a1 + 296, &v39);
      if (SHIBYTE(v40) < 0) {
        operator delete((void *)v39);
      }
    }
  }
  uint64_t v26 = CFDictionaryGetValue(theDict, @"gatewayUsername");
  if (v26)
  {
    CFTypeID v27 = CFGetTypeID(v26);
    if (v27 == CFStringGetTypeID())
    {
      long long v30 = 0uLL;
      *(void *)&long long v31 = 0;
      ctu::cf::assign();
      long long v39 = v30;
      uint64_t v40 = v31;
      sub_10008BE4C(a1 + 328, &v39);
      if (SHIBYTE(v40) < 0) {
        operator delete((void *)v39);
      }
    }
  }
  long long v28 = CFDictionaryGetValue(theDict, @"gatewayPassword");
  if (v28)
  {
    CFTypeID v29 = CFGetTypeID(v28);
    if (v29 == CFStringGetTypeID())
    {
      long long v30 = 0uLL;
      *(void *)&long long v31 = 0;
      ctu::cf::assign();
      long long v39 = v30;
      uint64_t v40 = v31;
      sub_10008BE4C(a1 + 360, &v39);
      if (SHIBYTE(v40) < 0) {
        operator delete((void *)v39);
      }
    }
  }
}

void sub_1003A728C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (*(char *)(v14 - 57) < 0) {
    operator delete(*(void **)(v14 - 80));
  }
  _Unwind_Resume(exception_object);
}

void *IMSInfo::serialize@<X0>(IMSInfo *this@<X0>, void *a2@<X8>)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (*((char *)this + 23) < 0)
  {
    unint64_t v5 = *((void *)this + 1);
    if (!v5) {
      goto LABEL_20;
    }
    sub_10004FC84(&__dst, *(void **)this, v5);
  }
  else
  {
    if (!*((unsigned char *)this + 23)) {
      goto LABEL_20;
    }
    long long __dst = *(_OWORD *)this;
    uint64_t v64 = *((void *)this + 2);
  }
  if (SHIBYTE(v64) < 0)
  {
    sub_10004FC84(&v67, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v67 = __dst;
    uint64_t v68 = v64;
  }
  CFMutableArrayRef v66 = 0;
  if (SHIBYTE(v68) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)v67, *((unint64_t *)&v67 + 1));
  }
  else
  {
    long long valuePtr = v67;
    uint64_t v70 = v68;
  }
  CFMutableArrayRef v71 = 0;
  if (ctu::cf::convert_copy())
  {
    CFMutableArrayRef v6 = v66;
    CFMutableArrayRef v66 = v71;
    CFMutableArrayRef v72 = v6;
    sub_1000558F4((const void **)&v72);
  }
  if (SHIBYTE(v70) < 0) {
    operator delete((void *)valuePtr);
  }
  CFMutableArrayRef v65 = v66;
  CFMutableArrayRef v66 = 0;
  sub_1000558F4((const void **)&v66);
  if (SHIBYTE(v68) < 0) {
    operator delete((void *)v67);
  }
  CFDictionaryAddValue(Mutable, @"imsi", v65);
  sub_1000558F4((const void **)&v65);
  if (SHIBYTE(v64) < 0) {
    operator delete((void *)__dst);
  }
LABEL_20:
  CFTypeID v7 = (void **)((char *)this + 24);
  if (*((char *)this + 47) < 0)
  {
    unint64_t v8 = *((void *)this + 4);
    if (!v8) {
      goto LABEL_39;
    }
    sub_10004FC84(__p, *v7, v8);
  }
  else
  {
    if (!*((unsigned char *)this + 47)) {
      goto LABEL_39;
    }
    *(_OWORD *)std::string __p = *(_OWORD *)v7;
    uint64_t v62 = *((void *)this + 5);
  }
  if (SHIBYTE(v62) < 0)
  {
    sub_10004FC84(&v67, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long v67 = *(_OWORD *)__p;
    uint64_t v68 = v62;
  }
  CFMutableArrayRef v66 = 0;
  if (SHIBYTE(v68) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)v67, *((unint64_t *)&v67 + 1));
  }
  else
  {
    long long valuePtr = v67;
    uint64_t v70 = v68;
  }
  CFMutableArrayRef v71 = 0;
  if (ctu::cf::convert_copy())
  {
    CFMutableArrayRef v9 = v66;
    CFMutableArrayRef v66 = v71;
    CFMutableArrayRef v72 = v9;
    sub_1000558F4((const void **)&v72);
  }
  if (SHIBYTE(v70) < 0) {
    operator delete((void *)valuePtr);
  }
  CFMutableArrayRef v65 = v66;
  CFMutableArrayRef v66 = 0;
  sub_1000558F4((const void **)&v66);
  if (SHIBYTE(v68) < 0) {
    operator delete((void *)v67);
  }
  CFDictionaryAddValue(Mutable, @"impi", v65);
  sub_1000558F4((const void **)&v65);
  if (SHIBYTE(v62) < 0) {
    operator delete(__p[0]);
  }
LABEL_39:
  uint64_t v10 = *((void *)this + 7) - *((void *)this + 6);
  if (v10)
  {
    CFMutableArrayRef v71 = 0;
    CFMutableArrayRef v11 = CFArrayCreateMutable(kCFAllocatorDefault, 0xAAAAAAAAAAAAAAABLL * (v10 >> 3), &kCFTypeArrayCallBacks);
    CFMutableArrayRef v71 = v11;
    uint64_t v13 = *((void *)this + 6);
    if (*((void *)this + 7) == v13)
    {
      CFMutableArrayRef v19 = v11;
    }
    else
    {
      uint64_t v14 = 0;
      unint64_t v15 = 0;
      do
      {
        CFTypeID v16 = (const __CFString **)(v13 + v14);
        if (*(char *)(v13 + v14 + 23) < 0) {
          CFTypeID v16 = (const __CFString **)*v16;
        }
        CFTypeID v17 = v71;
        CFMutableArrayRef v72 = 0;
        *(void *)&long long v67 = 0;
        if (ctu::cf::convert_copy((ctu::cf *)&v67, v16, (const char *)0x8000100, kCFAllocatorDefault, v12))
        {
          CFMutableArrayRef v18 = v72;
          CFMutableArrayRef v72 = (CFMutableArrayRef)v67;
          *(void *)&long long valuePtr = v18;
          sub_1000558F4((const void **)&valuePtr);
        }
        CFMutableArrayRef v66 = v72;
        CFMutableArrayRef v72 = 0;
        sub_1000558F4((const void **)&v72);
        CFArrayAppendValue(v17, v66);
        sub_1000558F4((const void **)&v66);
        ++v15;
        uint64_t v13 = *((void *)this + 6);
        v14 += 24;
      }
      while (v15 < 0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 7) - v13) >> 3));
      CFMutableArrayRef v19 = v71;
    }
    CFDictionaryAddValue(Mutable, @"impuList", v19);
    sub_1000440D4((const void **)&v71);
  }
  CFTypeID v20 = (void **)((char *)this + 72);
  if (*((char *)this + 95) < 0)
  {
    unint64_t v21 = *((void *)this + 10);
    if (!v21) {
      goto LABEL_69;
    }
    sub_10004FC84(v59, *v20, v21);
  }
  else
  {
    if (!*((unsigned char *)this + 95)) {
      goto LABEL_69;
    }
    *(_OWORD *)uint64_t v59 = *(_OWORD *)v20;
    uint64_t v60 = *((void *)this + 11);
  }
  if (SHIBYTE(v60) < 0)
  {
    sub_10004FC84(&v67, v59[0], (unint64_t)v59[1]);
  }
  else
  {
    long long v67 = *(_OWORD *)v59;
    uint64_t v68 = v60;
  }
  CFMutableArrayRef v66 = 0;
  if (SHIBYTE(v68) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)v67, *((unint64_t *)&v67 + 1));
  }
  else
  {
    long long valuePtr = v67;
    uint64_t v70 = v68;
  }
  CFMutableArrayRef v71 = 0;
  if (ctu::cf::convert_copy())
  {
    CFMutableArrayRef v22 = v66;
    CFMutableArrayRef v66 = v71;
    CFMutableArrayRef v72 = v22;
    sub_1000558F4((const void **)&v72);
  }
  if (SHIBYTE(v70) < 0) {
    operator delete((void *)valuePtr);
  }
  CFMutableArrayRef v65 = v66;
  CFMutableArrayRef v66 = 0;
  sub_1000558F4((const void **)&v66);
  if (SHIBYTE(v68) < 0) {
    operator delete((void *)v67);
  }
  CFDictionaryAddValue(Mutable, @"mdn", v65);
  sub_1000558F4((const void **)&v65);
  if (SHIBYTE(v60) < 0) {
    operator delete(v59[0]);
  }
LABEL_69:
  CFTypeID v23 = (void **)((char *)this + 96);
  if (*((char *)this + 119) < 0)
  {
    unint64_t v24 = *((void *)this + 13);
    if (!v24) {
      goto LABEL_88;
    }
    sub_10004FC84(v57, *v23, v24);
  }
  else
  {
    if (!*((unsigned char *)this + 119)) {
      goto LABEL_88;
    }
    *(_OWORD *)uint64_t v57 = *(_OWORD *)v23;
    uint64_t v58 = *((void *)this + 14);
  }
  if (SHIBYTE(v58) < 0)
  {
    sub_10004FC84(&v67, v57[0], (unint64_t)v57[1]);
  }
  else
  {
    long long v67 = *(_OWORD *)v57;
    uint64_t v68 = v58;
  }
  CFMutableArrayRef v66 = 0;
  if (SHIBYTE(v68) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)v67, *((unint64_t *)&v67 + 1));
  }
  else
  {
    long long valuePtr = v67;
    uint64_t v70 = v68;
  }
  CFMutableArrayRef v71 = 0;
  if (ctu::cf::convert_copy())
  {
    CFMutableArrayRef v25 = v66;
    CFMutableArrayRef v66 = v71;
    CFMutableArrayRef v72 = v25;
    sub_1000558F4((const void **)&v72);
  }
  if (SHIBYTE(v70) < 0) {
    operator delete((void *)valuePtr);
  }
  CFMutableArrayRef v65 = v66;
  CFMutableArrayRef v66 = 0;
  sub_1000558F4((const void **)&v66);
  if (SHIBYTE(v68) < 0) {
    operator delete((void *)v67);
  }
  CFDictionaryAddValue(Mutable, @"realm", v65);
  sub_1000558F4((const void **)&v65);
  if (SHIBYTE(v58) < 0) {
    operator delete(v57[0]);
  }
LABEL_88:
  uint64_t v26 = (void **)((char *)this + 120);
  if (*((char *)this + 143) < 0)
  {
    unint64_t v27 = *((void *)this + 16);
    if (!v27) {
      goto LABEL_107;
    }
    sub_10004FC84(v55, *v26, v27);
  }
  else
  {
    if (!*((unsigned char *)this + 143)) {
      goto LABEL_107;
    }
    *(_OWORD *)long long v55 = *(_OWORD *)v26;
    uint64_t v56 = *((void *)this + 17);
  }
  if (SHIBYTE(v56) < 0)
  {
    sub_10004FC84(&v67, v55[0], (unint64_t)v55[1]);
  }
  else
  {
    long long v67 = *(_OWORD *)v55;
    uint64_t v68 = v56;
  }
  CFMutableArrayRef v66 = 0;
  if (SHIBYTE(v68) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)v67, *((unint64_t *)&v67 + 1));
  }
  else
  {
    long long valuePtr = v67;
    uint64_t v70 = v68;
  }
  CFMutableArrayRef v71 = 0;
  if (ctu::cf::convert_copy())
  {
    CFMutableArrayRef v28 = v66;
    CFMutableArrayRef v66 = v71;
    CFMutableArrayRef v72 = v28;
    sub_1000558F4((const void **)&v72);
  }
  if (SHIBYTE(v70) < 0) {
    operator delete((void *)valuePtr);
  }
  CFMutableArrayRef v65 = v66;
  CFMutableArrayRef v66 = 0;
  sub_1000558F4((const void **)&v66);
  if (SHIBYTE(v68) < 0) {
    operator delete((void *)v67);
  }
  CFDictionaryAddValue(Mutable, @"apn", v65);
  sub_1000558F4((const void **)&v65);
  if (SHIBYTE(v56) < 0) {
    operator delete(v55[0]);
  }
LABEL_107:
  uint64_t v29 = *((unsigned int *)this + 36);
  *(void *)&long long v67 = 0;
  *(void *)&long long valuePtr = v29;
  CFNumberRef v30 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v30)
  {
    uint64_t v31 = v67;
    *(void *)&long long v67 = v30;
    *(void *)&long long valuePtr = v31;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFMutableArrayRef v72 = (CFMutableArrayRef)v67;
  *(void *)&long long v67 = 0;
  sub_1000570E8((const void **)&v67);
  CFDictionaryAddValue(Mutable, @"ipVer", v72);
  sub_1000570E8((const void **)&v72);
  long long v32 = (void **)((char *)this + 152);
  if (*((char *)this + 175) < 0)
  {
    unint64_t v33 = *((void *)this + 20);
    if (!v33) {
      goto LABEL_128;
    }
    sub_10004FC84(v53, *v32, v33);
  }
  else
  {
    if (!*((unsigned char *)this + 175)) {
      goto LABEL_128;
    }
    *(_OWORD *)uint64_t v53 = *(_OWORD *)v32;
    uint64_t v54 = *((void *)this + 21);
  }
  if (SHIBYTE(v54) < 0)
  {
    sub_10004FC84(&v67, v53[0], (unint64_t)v53[1]);
  }
  else
  {
    long long v67 = *(_OWORD *)v53;
    uint64_t v68 = v54;
  }
  CFMutableArrayRef v66 = 0;
  if (SHIBYTE(v68) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)v67, *((unint64_t *)&v67 + 1));
  }
  else
  {
    long long valuePtr = v67;
    uint64_t v70 = v68;
  }
  CFMutableArrayRef v71 = 0;
  if (ctu::cf::convert_copy())
  {
    CFMutableArrayRef v34 = v66;
    CFMutableArrayRef v66 = v71;
    CFMutableArrayRef v72 = v34;
    sub_1000558F4((const void **)&v72);
  }
  if (SHIBYTE(v70) < 0) {
    operator delete((void *)valuePtr);
  }
  CFMutableArrayRef v65 = v66;
  CFMutableArrayRef v66 = 0;
  sub_1000558F4((const void **)&v66);
  if (SHIBYTE(v68) < 0) {
    operator delete((void *)v67);
  }
  CFDictionaryAddValue(Mutable, @"password", v65);
  sub_1000558F4((const void **)&v65);
  if (SHIBYTE(v54) < 0) {
    operator delete(v53[0]);
  }
LABEL_128:
  uint64_t v35 = (const void **)&kCFBooleanTrue;
  if (!*((unsigned char *)this + 176)) {
    uint64_t v35 = (const void **)&kCFBooleanFalse;
  }
  CFDictionaryAddValue(Mutable, @"allowNoDNS", *v35);
  long long v36 = (void **)((char *)this + 184);
  if (*((char *)this + 207) < 0)
  {
    unint64_t v37 = *((void *)this + 24);
    if (!v37) {
      goto LABEL_149;
    }
    sub_10004FC84(v51, *v36, v37);
  }
  else
  {
    if (!*((unsigned char *)this + 207)) {
      goto LABEL_149;
    }
    *(_OWORD *)uint64_t v51 = *(_OWORD *)v36;
    uint64_t v52 = *((void *)this + 25);
  }
  if (SHIBYTE(v52) < 0)
  {
    sub_10004FC84(&v67, v51[0], (unint64_t)v51[1]);
  }
  else
  {
    long long v67 = *(_OWORD *)v51;
    uint64_t v68 = v52;
  }
  CFMutableArrayRef v66 = 0;
  if (SHIBYTE(v68) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)v67, *((unint64_t *)&v67 + 1));
  }
  else
  {
    long long valuePtr = v67;
    uint64_t v70 = v68;
  }
  CFMutableArrayRef v71 = 0;
  if (ctu::cf::convert_copy())
  {
    CFMutableArrayRef v38 = v66;
    CFMutableArrayRef v66 = v71;
    CFMutableArrayRef v72 = v38;
    sub_1000558F4((const void **)&v72);
  }
  if (SHIBYTE(v70) < 0) {
    operator delete((void *)valuePtr);
  }
  CFMutableArrayRef v65 = v66;
  CFMutableArrayRef v66 = 0;
  sub_1000558F4((const void **)&v66);
  if (SHIBYTE(v68) < 0) {
    operator delete((void *)v67);
  }
  CFDictionaryAddValue(Mutable, @"mcc", v65);
  sub_1000558F4((const void **)&v65);
  if (SHIBYTE(v52) < 0) {
    operator delete(v51[0]);
  }
LABEL_149:
  long long v39 = (void **)((char *)this + 208);
  if (*((char *)this + 231) < 0)
  {
    unint64_t v40 = *((void *)this + 27);
    if (!v40) {
      goto LABEL_168;
    }
    sub_10004FC84(v49, *v39, v40);
  }
  else
  {
    if (!*((unsigned char *)this + 231)) {
      goto LABEL_168;
    }
    *(_OWORD *)uint64_t v49 = *(_OWORD *)v39;
    uint64_t v50 = *((void *)this + 28);
  }
  if (SHIBYTE(v50) < 0)
  {
    sub_10004FC84(&v67, v49[0], (unint64_t)v49[1]);
  }
  else
  {
    long long v67 = *(_OWORD *)v49;
    uint64_t v68 = v50;
  }
  CFMutableArrayRef v66 = 0;
  if (SHIBYTE(v68) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)v67, *((unint64_t *)&v67 + 1));
  }
  else
  {
    long long valuePtr = v67;
    uint64_t v70 = v68;
  }
  CFMutableArrayRef v71 = 0;
  if (ctu::cf::convert_copy())
  {
    CFMutableArrayRef v41 = v66;
    CFMutableArrayRef v66 = v71;
    CFMutableArrayRef v72 = v41;
    sub_1000558F4((const void **)&v72);
  }
  if (SHIBYTE(v70) < 0) {
    operator delete((void *)valuePtr);
  }
  CFMutableArrayRef v65 = v66;
  CFMutableArrayRef v66 = 0;
  sub_1000558F4((const void **)&v66);
  if (SHIBYTE(v68) < 0) {
    operator delete((void *)v67);
  }
  CFDictionaryAddValue(Mutable, @"isoMcc", v65);
  sub_1000558F4((const void **)&v65);
  if (SHIBYTE(v50) < 0) {
    operator delete(v49[0]);
  }
LABEL_168:
  uint64_t v42 = (void **)((char *)this + 232);
  if (*((char *)this + 255) < 0)
  {
    unint64_t v43 = *((void *)this + 30);
    if (!v43) {
      goto LABEL_187;
    }
    sub_10004FC84(v47, *v42, v43);
  }
  else
  {
    if (!*((unsigned char *)this + 255)) {
      goto LABEL_187;
    }
    *(_OWORD *)uint64_t v47 = *(_OWORD *)v42;
    uint64_t v48 = *((void *)this + 31);
  }
  if (SHIBYTE(v48) < 0)
  {
    sub_10004FC84(&v67, v47[0], (unint64_t)v47[1]);
  }
  else
  {
    long long v67 = *(_OWORD *)v47;
    uint64_t v68 = v48;
  }
  CFMutableArrayRef v66 = 0;
  if (SHIBYTE(v68) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)v67, *((unint64_t *)&v67 + 1));
  }
  else
  {
    long long valuePtr = v67;
    uint64_t v70 = v68;
  }
  CFMutableArrayRef v71 = 0;
  if (ctu::cf::convert_copy())
  {
    CFMutableArrayRef v44 = v66;
    CFMutableArrayRef v66 = v71;
    CFMutableArrayRef v72 = v44;
    sub_1000558F4((const void **)&v72);
  }
  if (SHIBYTE(v70) < 0) {
    operator delete((void *)valuePtr);
  }
  CFMutableArrayRef v45 = v66;
  CFMutableArrayRef v65 = v66;
  CFMutableArrayRef v66 = 0;
  sub_1000558F4((const void **)&v66);
  if (SHIBYTE(v68) < 0) {
    operator delete((void *)v67);
  }
  CFDictionaryAddValue(Mutable, @"mnc", v45);
  sub_1000558F4((const void **)&v65);
  if (SHIBYTE(v48) < 0) {
    operator delete(v47[0]);
  }
LABEL_187:
  *(void *)&long long valuePtr = Mutable;
  return sub_1003AA8C0(a2, (CFTypeRef *)&valuePtr);
}

void sub_1003A7F6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,uint64_t a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  sub_1000558F4((const void **)(v63 - 168));
  if (*(char *)(v63 - 137) < 0) {
    operator delete(*(void **)(v63 - 160));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void IMSInfo::deserialize(IMSInfo *this, CFDictionaryRef theDict)
{
  CFDictionaryRef v2 = theDict;
  CFDictionaryGetValue(theDict, @"imsi");
  uint64_t v56 = 0;
  long long v57 = 0uLL;
  ctu::cf::assign();
  v60[0] = 0;
  *(void *)((char *)v60 + 7) = 0;
  if (*((char *)this + 23) < 0) {
    operator delete(*(void **)this);
  }
  uint64_t v4 = v60[0];
  *(void *)this = 0;
  *((void *)this + 1) = v4;
  *(void *)((char *)this + 15) = *(void *)((char *)v60 + 7);
  *((unsigned char *)this + 23) = 0;
  CFDictionaryGetValue(v2, @"impi");
  uint64_t v56 = 0;
  long long v57 = 0uLL;
  ctu::cf::assign();
  v60[0] = 0;
  *(void *)((char *)v60 + 7) = 0;
  if (*((char *)this + 47) < 0) {
    operator delete(*((void **)this + 3));
  }
  uint64_t v5 = v60[0];
  *((void *)this + 3) = 0;
  *((void *)this + 4) = v5;
  *(void *)((char *)this + 39) = *(void *)((char *)v60 + 7);
  *((unsigned char *)this + 47) = 0;
  CFMutableArrayRef v6 = (void *)((char *)this + 48);
  sub_100047FB8((uint64_t *)this + 6);
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v2, @"impuList");
  CFArrayRef v8 = Value;
  if (Value)
  {
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == CFArrayGetTypeID() && CFArrayGetCount(v8) >= 1)
    {
      CFIndex v10 = 0;
      do
      {
        CFArrayGetValueAtIndex(v8, v10);
        uint64_t v56 = 0;
        long long v57 = 0uLL;
        ctu::cf::assign();
        CFMutableArrayRef v11 = v56;
        v60[0] = v57;
        *(void *)((char *)v60 + 7) = *(void *)((char *)&v57 + 7);
        char v12 = HIBYTE(v57);
        unint64_t v13 = *((void *)this + 7);
        unint64_t v14 = *((void *)this + 8);
        if (v13 >= v14)
        {
          CFDictionaryRef v17 = v2;
          unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - *v6) >> 3);
          unint64_t v19 = v18 + 1;
          if (v18 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_1000D8578();
          }
          unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - *v6) >> 3);
          if (2 * v20 > v19) {
            unint64_t v19 = 2 * v20;
          }
          if (v20 >= 0x555555555555555) {
            unint64_t v21 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v21 = v19;
          }
          uint64_t v59 = (char *)this + 64;
          if (v21) {
            CFMutableArrayRef v22 = (char *)sub_10004812C((uint64_t)this + 64, v21);
          }
          else {
            CFMutableArrayRef v22 = 0;
          }
          CFTypeID v23 = &v22[24 * v18];
          uint64_t v56 = v22;
          *(void *)&long long v57 = v23;
          uint64_t v58 = &v22[24 * v21];
          uint64_t v24 = v60[0];
          *(void *)CFTypeID v23 = v11;
          *((void *)v23 + 1) = v24;
          *(void *)(v23 + 15) = *(void *)((char *)v60 + 7);
          v23[23] = v12;
          *((void *)&v57 + 1) = v23 + 24;
          sub_100048204((uint64_t *)this + 6, &v56);
          unint64_t v16 = *((void *)this + 7);
          sub_100048174((uint64_t)&v56);
          CFDictionaryRef v2 = v17;
        }
        else
        {
          uint64_t v15 = v60[0];
          *(void *)unint64_t v13 = v56;
          *(void *)(v13 + 8) = v15;
          *(void *)(v13 + 15) = *(void *)((char *)v60 + 7);
          *(unsigned char *)(v13 + 23) = v12;
          unint64_t v16 = v13 + 24;
          *((void *)this + 7) = v13 + 24;
        }
        *((void *)this + 7) = v16;
        ++v10;
      }
      while (v10 < CFArrayGetCount(v8));
    }
  }
  CFDictionaryGetValue(v2, @"mdn");
  uint64_t v56 = 0;
  long long v57 = 0uLL;
  ctu::cf::assign();
  CFMutableArrayRef v25 = v56;
  v60[0] = v57;
  *(void *)((char *)v60 + 7) = *(void *)((char *)&v57 + 7);
  char v26 = HIBYTE(v57);
  if (*((char *)this + 95) < 0) {
    operator delete(*((void **)this + 9));
  }
  uint64_t v27 = v60[0];
  *((void *)this + 9) = v25;
  *((void *)this + 10) = v27;
  *(void *)((char *)this + 87) = *(void *)((char *)v60 + 7);
  *((unsigned char *)this + 95) = v26;
  CFDictionaryGetValue(v2, @"realm");
  uint64_t v56 = 0;
  long long v57 = 0uLL;
  ctu::cf::assign();
  CFMutableArrayRef v28 = v56;
  v60[0] = v57;
  *(void *)((char *)v60 + 7) = *(void *)((char *)&v57 + 7);
  char v29 = HIBYTE(v57);
  if (*((char *)this + 119) < 0) {
    operator delete(*((void **)this + 12));
  }
  uint64_t v30 = v60[0];
  *((void *)this + 12) = v28;
  *((void *)this + 13) = v30;
  *(void *)((char *)this + 111) = *(void *)((char *)v60 + 7);
  *((unsigned char *)this + 119) = v29;
  CFDictionaryGetValue(v2, @"apn");
  uint64_t v56 = 0;
  long long v57 = 0uLL;
  ctu::cf::assign();
  uint64_t v31 = v56;
  v60[0] = v57;
  *(void *)((char *)v60 + 7) = *(void *)((char *)&v57 + 7);
  char v32 = HIBYTE(v57);
  if (*((char *)this + 143) < 0) {
    operator delete(*((void **)this + 15));
  }
  uint64_t v33 = v60[0];
  *((void *)this + 15) = v31;
  *((void *)this + 16) = v33;
  *(void *)((char *)this + 135) = *(void *)((char *)v60 + 7);
  *((unsigned char *)this + 143) = v32;
  CFMutableArrayRef v34 = (unsigned int *)CFDictionaryGetValue(v2, @"ipVer");
  uint64_t v35 = v34;
  LODWORD(v56) = 0;
  if (v34 && (CFTypeID v36 = CFGetTypeID(v34), v36 == CFNumberGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&v56, v35, v37);
    int v38 = (int)v56;
  }
  else
  {
    int v38 = 0;
  }
  *((_DWORD *)this + 36) = v38;
  CFDictionaryGetValue(v2, @"password");
  uint64_t v56 = 0;
  long long v57 = 0uLL;
  ctu::cf::assign();
  long long v39 = v56;
  v60[0] = v57;
  *(void *)((char *)v60 + 7) = *(void *)((char *)&v57 + 7);
  char v40 = HIBYTE(v57);
  if (*((char *)this + 175) < 0) {
    operator delete(*((void **)this + 19));
  }
  uint64_t v41 = v60[0];
  *((void *)this + 19) = v39;
  *((void *)this + 20) = v41;
  *(void *)((char *)this + 167) = *(void *)((char *)v60 + 7);
  *((unsigned char *)this + 175) = v40;
  uint64_t v42 = (BOOL *)CFDictionaryGetValue(v2, @"allowNoDNS");
  unint64_t v43 = v42;
  LOBYTE(v56) = 0;
  if (v42 && (CFTypeID v44 = CFGetTypeID(v42), v44 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&v56, v43, v45);
    char v46 = (char)v56;
  }
  else
  {
    char v46 = 0;
  }
  *((unsigned char *)this + 176) = v46;
  CFDictionaryGetValue(v2, @"mcc");
  uint64_t v56 = 0;
  long long v57 = 0uLL;
  ctu::cf::assign();
  uint64_t v47 = v56;
  v60[0] = v57;
  *(void *)((char *)v60 + 7) = *(void *)((char *)&v57 + 7);
  char v48 = HIBYTE(v57);
  if (*((char *)this + 207) < 0) {
    operator delete(*((void **)this + 23));
  }
  uint64_t v49 = v60[0];
  *((void *)this + 23) = v47;
  *((void *)this + 24) = v49;
  *(void *)((char *)this + 199) = *(void *)((char *)v60 + 7);
  *((unsigned char *)this + 207) = v48;
  CFDictionaryGetValue(v2, @"isoMcc");
  uint64_t v56 = 0;
  long long v57 = 0uLL;
  ctu::cf::assign();
  uint64_t v50 = v56;
  v60[0] = v57;
  *(void *)((char *)v60 + 7) = *(void *)((char *)&v57 + 7);
  char v51 = HIBYTE(v57);
  if (*((char *)this + 231) < 0) {
    operator delete(*((void **)this + 26));
  }
  uint64_t v52 = v60[0];
  *((void *)this + 26) = v50;
  *((void *)this + 27) = v52;
  *(void *)((char *)this + 223) = *(void *)((char *)v60 + 7);
  *((unsigned char *)this + 231) = v51;
  CFDictionaryGetValue(v2, @"mnc");
  uint64_t v56 = 0;
  long long v57 = 0uLL;
  ctu::cf::assign();
  uint64_t v53 = v56;
  v60[0] = v57;
  *(void *)((char *)v60 + 7) = *(void *)((char *)&v57 + 7);
  char v54 = HIBYTE(v57);
  if (*((char *)this + 255) < 0) {
    operator delete(*((void **)this + 29));
  }
  uint64_t v55 = v60[0];
  *((void *)this + 29) = v53;
  *((void *)this + 30) = v55;
  *(void *)((char *)this + 247) = *(void *)((char *)v60 + 7);
  *((unsigned char *)this + 255) = v54;
}

void sub_1003A88EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003A8958(uint64_t a1, const __CFDictionary *a2)
{
  if (a2)
  {
    uint64_t v45 = 0;
    *(_OWORD *)std::string __p = 0u;
    long long v44 = 0u;
    *(_OWORD *)uint64_t v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    *(_OWORD *)int v38 = 0u;
    long long v35 = 0u;
    *(_OWORD *)CFTypeID v36 = 0u;
    memset(v34, 0, sizeof(v34));
    sub_1001DDF34(a1, (long long *)v34);
    if ((_BYTE)v45 && SHIBYTE(v44) < 0) {
      operator delete(__p[1]);
    }
    if (LOBYTE(__p[0]) && SHIBYTE(v42) < 0) {
      operator delete(v41[1]);
    }
    if (BYTE8(v39) && SBYTE7(v39) < 0) {
      operator delete(v38[0]);
    }
    if (BYTE8(v37) && SBYTE7(v37) < 0) {
      operator delete(v36[0]);
    }
    if (SHIBYTE(v35) < 0) {
      operator delete(v34[3]);
    }
    if (SHIBYTE(v34[2]) < 0) {
      operator delete(v34[0]);
    }
    CFArrayRef Value = CFDictionaryGetValue(a2, @"displayName");
    if (Value)
    {
      CFTypeID v5 = CFGetTypeID(Value);
      if (v5 == CFStringGetTypeID())
      {
        memset(v34, 0, 24);
        ctu::cf::assign();
        CFMutableArrayRef v6 = v34[0];
        *(void **)&long long v46 = v34[1];
        *(void **)((char *)&v46 + 7) = *(void **)((char *)&v34[1] + 7);
        char v7 = HIBYTE(v34[2]);
        if (*(char *)(a1 + 23) < 0) {
          operator delete(*(void **)a1);
        }
        uint64_t v8 = v46;
        *(void *)a1 = v6;
        *(void *)(a1 + 8) = v8;
        *(void *)(a1 + 15) = *(void *)((char *)&v46 + 7);
        *(unsigned char *)(a1 + 23) = v7;
      }
    }
    CFTypeID v9 = CFDictionaryGetValue(a2, @"sipUserName");
    if (v9)
    {
      CFTypeID v10 = CFGetTypeID(v9);
      if (v10 == CFStringGetTypeID())
      {
        memset(v34, 0, 24);
        ctu::cf::assign();
        CFMutableArrayRef v11 = v34[0];
        *(void **)&long long v46 = v34[1];
        *(void **)((char *)&v46 + 7) = *(void **)((char *)&v34[1] + 7);
        char v12 = HIBYTE(v34[2]);
        if (*(char *)(a1 + 47) < 0) {
          operator delete(*(void **)(a1 + 24));
        }
        uint64_t v13 = v46;
        *(void *)(a1 + 24) = v11;
        *(void *)(a1 + 32) = v13;
        *(void *)(a1 + 39) = *(void *)((char *)&v46 + 7);
        *(unsigned char *)(a1 + 47) = v12;
      }
    }
    unint64_t v14 = CFDictionaryGetValue(a2, @"addressUpdateURL");
    if (v14)
    {
      CFTypeID v15 = CFGetTypeID(v14);
      if (v15 == CFStringGetTypeID())
      {
        memset(v34, 0, 24);
        ctu::cf::assign();
        long long v46 = *(_OWORD *)v34;
        uint64_t v47 = v34[2];
        sub_10008BE4C(a1 + 48, &v46);
        if (SHIBYTE(v47) < 0) {
          operator delete((void *)v46);
        }
      }
    }
    unint64_t v16 = CFDictionaryGetValue(a2, @"addressUpdateToken");
    if (v16)
    {
      CFTypeID v17 = CFGetTypeID(v16);
      if (v17 == CFStringGetTypeID())
      {
        memset(v34, 0, 24);
        ctu::cf::assign();
        long long v46 = *(_OWORD *)v34;
        uint64_t v47 = v34[2];
        sub_10008BE4C(a1 + 80, &v46);
        if (SHIBYTE(v47) < 0) {
          operator delete((void *)v46);
        }
      }
    }
    unint64_t v18 = (int *)CFDictionaryGetValue(a2, @"addressStatus");
    unint64_t v19 = v18;
    if (v18)
    {
      CFTypeID v20 = CFGetTypeID(v18);
      if (v20 == CFNumberGetTypeID())
      {
        LODWORD(v34[0]) = 0;
        ctu::cf::assign((ctu::cf *)v34, v19, v21);
        *(_DWORD *)(a1 + 112) = v34[0];
        *(unsigned char *)(a1 + 116) = 1;
      }
    }
    CFMutableArrayRef v22 = (int *)CFDictionaryGetValue(a2, @"tcStatus");
    CFTypeID v23 = v22;
    if (v22)
    {
      CFTypeID v24 = CFGetTypeID(v22);
      if (v24 == CFNumberGetTypeID())
      {
        LODWORD(v34[0]) = 0;
        ctu::cf::assign((ctu::cf *)v34, v23, v25);
        *(_DWORD *)(a1 + 120) = v34[0];
        *(unsigned char *)(a1 + 124) = 1;
      }
    }
    char v26 = (int *)CFDictionaryGetValue(a2, @"proviStatus");
    uint64_t v27 = v26;
    if (v26)
    {
      CFTypeID v28 = CFGetTypeID(v26);
      if (v28 == CFNumberGetTypeID())
      {
        LODWORD(v34[0]) = 0;
        ctu::cf::assign((ctu::cf *)v34, v27, v29);
        *(_DWORD *)(a1 + 128) = v34[0];
        *(unsigned char *)(a1 + 132) = 1;
      }
    }
    uint64_t v30 = CFDictionaryGetValue(a2, @"address-ref-id");
    if (v30)
    {
      CFTypeID v31 = CFGetTypeID(v30);
      if (v31 == CFStringGetTypeID())
      {
        memset(v34, 0, 24);
        ctu::cf::assign();
        long long v46 = *(_OWORD *)v34;
        uint64_t v47 = v34[2];
        sub_10008BE4C(a1 + 136, &v46);
        if (SHIBYTE(v47) < 0) {
          operator delete((void *)v46);
        }
      }
    }
    char v32 = CFDictionaryGetValue(a2, @"address-ref-id-expiry");
    if (v32)
    {
      CFTypeID v33 = CFGetTypeID(v32);
      if (v33 == CFStringGetTypeID())
      {
        memset(v34, 0, 24);
        ctu::cf::assign();
        long long v46 = *(_OWORD *)v34;
        uint64_t v47 = v34[2];
        sub_10008BE4C(a1 + 168, &v46);
        if (SHIBYTE(v47) < 0) {
          operator delete((void *)v46);
        }
      }
    }
  }
}

void sub_1003A8E18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (*(char *)(v14 - 57) < 0) {
    operator delete(*(void **)(v14 - 80));
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1003A8E80@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  CFMutableDictionaryRef v45 = 0;
  if (*(unsigned char *)(a1 + 200))
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFMutableDictionaryRef v5 = v45;
      CFMutableDictionaryRef v45 = Mutable;
      *(void *)&long long valuePtr = v5;
      sub_10005717C((const void **)&valuePtr);
    }
    CFMutableArrayRef v6 = v45;
    if (*(char *)(a1 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a1, *(void *)(a1 + 8));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a1;
      uint64_t v43 = *(void *)(a1 + 16);
    }
    if (SHIBYTE(v43) < 0)
    {
      sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long __dst = *(_OWORD *)__p;
      uint64_t v48 = v43;
    }
    long long v46 = 0;
    if (SHIBYTE(v48) < 0)
    {
      sub_10004FC84(&valuePtr, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      long long valuePtr = __dst;
      uint64_t v50 = v48;
    }
    char v51 = 0;
    if (ctu::cf::convert_copy())
    {
      char v7 = v46;
      long long v46 = v51;
      uint64_t v52 = v7;
      sub_1000558F4(&v52);
    }
    if (SHIBYTE(v50) < 0) {
      operator delete((void *)valuePtr);
    }
    long long v44 = v46;
    long long v46 = 0;
    sub_1000558F4(&v46);
    if (SHIBYTE(v48) < 0) {
      operator delete((void *)__dst);
    }
    CFDictionaryAddValue(v6, @"displayName", v44);
    sub_1000558F4(&v44);
    if (SHIBYTE(v43) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v8 = v45;
    if (*(char *)(a1 + 47) < 0)
    {
      sub_10004FC84(v40, *(void **)(a1 + 24), *(void *)(a1 + 32));
    }
    else
    {
      *(_OWORD *)long long v40 = *(_OWORD *)(a1 + 24);
      uint64_t v41 = *(void *)(a1 + 40);
    }
    if (SHIBYTE(v41) < 0)
    {
      sub_10004FC84(&__dst, v40[0], (unint64_t)v40[1]);
    }
    else
    {
      long long __dst = *(_OWORD *)v40;
      uint64_t v48 = v41;
    }
    long long v46 = 0;
    if (SHIBYTE(v48) < 0)
    {
      sub_10004FC84(&valuePtr, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      long long valuePtr = __dst;
      uint64_t v50 = v48;
    }
    char v51 = 0;
    if (ctu::cf::convert_copy())
    {
      CFTypeID v9 = v46;
      long long v46 = v51;
      uint64_t v52 = v9;
      sub_1000558F4(&v52);
    }
    if (SHIBYTE(v50) < 0) {
      operator delete((void *)valuePtr);
    }
    long long v44 = v46;
    long long v46 = 0;
    sub_1000558F4(&v46);
    if (SHIBYTE(v48) < 0) {
      operator delete((void *)__dst);
    }
    CFDictionaryAddValue(v8, @"sipUserName", v44);
    sub_1000558F4(&v44);
    if (SHIBYTE(v41) < 0) {
      operator delete(v40[0]);
    }
    if (*(unsigned char *)(a1 + 72))
    {
      CFTypeID v10 = v45;
      if (*(char *)(a1 + 71) < 0)
      {
        sub_10004FC84(v38, *(void **)(a1 + 48), *(void *)(a1 + 56));
      }
      else
      {
        *(_OWORD *)int v38 = *(_OWORD *)(a1 + 48);
        uint64_t v39 = *(void *)(a1 + 64);
      }
      if (SHIBYTE(v39) < 0)
      {
        sub_10004FC84(&__dst, v38[0], (unint64_t)v38[1]);
      }
      else
      {
        long long __dst = *(_OWORD *)v38;
        uint64_t v48 = v39;
      }
      long long v46 = 0;
      if (SHIBYTE(v48) < 0)
      {
        sub_10004FC84(&valuePtr, (void *)__dst, *((unint64_t *)&__dst + 1));
      }
      else
      {
        long long valuePtr = __dst;
        uint64_t v50 = v48;
      }
      char v51 = 0;
      if (ctu::cf::convert_copy())
      {
        CFMutableArrayRef v11 = v46;
        long long v46 = v51;
        uint64_t v52 = v11;
        sub_1000558F4(&v52);
      }
      if (SHIBYTE(v50) < 0) {
        operator delete((void *)valuePtr);
      }
      long long v44 = v46;
      long long v46 = 0;
      sub_1000558F4(&v46);
      if (SHIBYTE(v48) < 0) {
        operator delete((void *)__dst);
      }
      CFDictionaryAddValue(v10, @"addressUpdateURL", v44);
      sub_1000558F4(&v44);
      if (SHIBYTE(v39) < 0) {
        operator delete(v38[0]);
      }
    }
    if (*(unsigned char *)(a1 + 104))
    {
      char v12 = v45;
      if (*(char *)(a1 + 103) < 0)
      {
        sub_10004FC84(v36, *(void **)(a1 + 80), *(void *)(a1 + 88));
      }
      else
      {
        *(_OWORD *)CFTypeID v36 = *(_OWORD *)(a1 + 80);
        uint64_t v37 = *(void *)(a1 + 96);
      }
      if (SHIBYTE(v37) < 0)
      {
        sub_10004FC84(&__dst, v36[0], (unint64_t)v36[1]);
      }
      else
      {
        long long __dst = *(_OWORD *)v36;
        uint64_t v48 = v37;
      }
      long long v46 = 0;
      if (SHIBYTE(v48) < 0)
      {
        sub_10004FC84(&valuePtr, (void *)__dst, *((unint64_t *)&__dst + 1));
      }
      else
      {
        long long valuePtr = __dst;
        uint64_t v50 = v48;
      }
      char v51 = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v13 = v46;
        long long v46 = v51;
        uint64_t v52 = v13;
        sub_1000558F4(&v52);
      }
      if (SHIBYTE(v50) < 0) {
        operator delete((void *)valuePtr);
      }
      long long v44 = v46;
      long long v46 = 0;
      sub_1000558F4(&v46);
      if (SHIBYTE(v48) < 0) {
        operator delete((void *)__dst);
      }
      CFDictionaryAddValue(v12, @"addressUpdateToken", v44);
      sub_1000558F4(&v44);
      if (SHIBYTE(v37) < 0) {
        operator delete(v36[0]);
      }
    }
    if (*(unsigned char *)(a1 + 116))
    {
      uint64_t v14 = v45;
      int v15 = *(_DWORD *)(a1 + 112);
      *(void *)&long long __dst = 0;
      LODWORD(valuePtr) = v15;
      CFNumberRef v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      if (v16)
      {
        uint64_t v17 = __dst;
        *(void *)&long long __dst = v16;
        *(void *)&long long valuePtr = v17;
        sub_1000570E8((const void **)&valuePtr);
      }
      uint64_t v52 = (const void *)__dst;
      *(void *)&long long __dst = 0;
      sub_1000570E8((const void **)&__dst);
      CFDictionaryAddValue(v14, @"addressStatus", v52);
      sub_1000570E8(&v52);
    }
    if (*(unsigned char *)(a1 + 124))
    {
      unint64_t v18 = v45;
      int v19 = *(_DWORD *)(a1 + 120);
      *(void *)&long long __dst = 0;
      LODWORD(valuePtr) = v19;
      CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      if (v20)
      {
        uint64_t v21 = __dst;
        *(void *)&long long __dst = v20;
        *(void *)&long long valuePtr = v21;
        sub_1000570E8((const void **)&valuePtr);
      }
      uint64_t v52 = (const void *)__dst;
      *(void *)&long long __dst = 0;
      sub_1000570E8((const void **)&__dst);
      CFDictionaryAddValue(v18, @"tcStatus", v52);
      sub_1000570E8(&v52);
    }
    if (*(unsigned char *)(a1 + 132))
    {
      CFMutableArrayRef v22 = v45;
      int v23 = *(_DWORD *)(a1 + 128);
      *(void *)&long long __dst = 0;
      LODWORD(valuePtr) = v23;
      CFNumberRef v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      if (v24)
      {
        uint64_t v25 = __dst;
        *(void *)&long long __dst = v24;
        *(void *)&long long valuePtr = v25;
        sub_1000570E8((const void **)&valuePtr);
      }
      uint64_t v52 = (const void *)__dst;
      *(void *)&long long __dst = 0;
      sub_1000570E8((const void **)&__dst);
      CFDictionaryAddValue(v22, @"proviStatus", v52);
      sub_1000570E8(&v52);
    }
    if (*(unsigned char *)(a1 + 160))
    {
      char v26 = v45;
      if (*(char *)(a1 + 159) < 0)
      {
        sub_10004FC84(v34, *(void **)(a1 + 136), *(void *)(a1 + 144));
      }
      else
      {
        *(_OWORD *)CFMutableArrayRef v34 = *(_OWORD *)(a1 + 136);
        uint64_t v35 = *(void *)(a1 + 152);
      }
      if (SHIBYTE(v35) < 0)
      {
        sub_10004FC84(&__dst, v34[0], (unint64_t)v34[1]);
      }
      else
      {
        long long __dst = *(_OWORD *)v34;
        uint64_t v48 = v35;
      }
      long long v46 = 0;
      if (SHIBYTE(v48) < 0)
      {
        sub_10004FC84(&valuePtr, (void *)__dst, *((unint64_t *)&__dst + 1));
      }
      else
      {
        long long valuePtr = __dst;
        uint64_t v50 = v48;
      }
      char v51 = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v27 = v46;
        long long v46 = v51;
        uint64_t v52 = v27;
        sub_1000558F4(&v52);
      }
      if (SHIBYTE(v50) < 0) {
        operator delete((void *)valuePtr);
      }
      long long v44 = v46;
      long long v46 = 0;
      sub_1000558F4(&v46);
      if (SHIBYTE(v48) < 0) {
        operator delete((void *)__dst);
      }
      CFDictionaryAddValue(v26, @"address-ref-id", v44);
      sub_1000558F4(&v44);
      if (SHIBYTE(v35) < 0) {
        operator delete(v34[0]);
      }
    }
    if (*(unsigned char *)(a1 + 192))
    {
      CFTypeID v28 = v45;
      if (*(char *)(a1 + 191) < 0)
      {
        sub_10004FC84(v32, *(void **)(a1 + 168), *(void *)(a1 + 176));
      }
      else
      {
        *(_OWORD *)char v32 = *(_OWORD *)(a1 + 168);
        uint64_t v33 = *(void *)(a1 + 184);
      }
      if (SHIBYTE(v33) < 0)
      {
        sub_10004FC84(&__dst, v32[0], (unint64_t)v32[1]);
      }
      else
      {
        long long __dst = *(_OWORD *)v32;
        uint64_t v48 = v33;
      }
      long long v46 = 0;
      if (SHIBYTE(v48) < 0)
      {
        sub_10004FC84(&valuePtr, (void *)__dst, *((unint64_t *)&__dst + 1));
      }
      else
      {
        long long valuePtr = __dst;
        uint64_t v50 = v48;
      }
      char v51 = 0;
      if (ctu::cf::convert_copy())
      {
        CFNumberRef v29 = v46;
        long long v46 = v51;
        uint64_t v52 = v29;
        sub_1000558F4(&v52);
      }
      if (SHIBYTE(v50) < 0) {
        operator delete((void *)valuePtr);
      }
      uint64_t v30 = v46;
      long long v44 = v46;
      long long v46 = 0;
      sub_1000558F4(&v46);
      if (SHIBYTE(v48) < 0) {
        operator delete((void *)__dst);
      }
      CFDictionaryAddValue(v28, @"address-ref-id-expiry", v30);
      sub_1000558F4(&v44);
      if (SHIBYTE(v33) < 0) {
        operator delete(v32[0]);
      }
    }
  }
  sub_10004EFE4(a2, (CFTypeRef *)&v45);
  return sub_10005717C((const void **)&v45);
}

void sub_1003A9730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  sub_1000558F4((const void **)(v49 - 136));
  if (*(char *)(v49 - 105) < 0) {
    operator delete(*(void **)(v49 - 128));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10005717C((const void **)(v49 - 144));
  _Unwind_Resume(a1);
}

BOOL sub_1003A99B8(uint64_t a1, CFStringRef key, CFTypeRef cf, uint64_t a4, int a5)
{
  if (key)
  {
    CFTypeRef v7 = cf;
    uint64_t v13 = cf;
    if (cf) {
      CFRetain(cf);
    }
    if (a5)
    {
      if (v7) {
        CFTypeID v9 = sub_100080934;
      }
      else {
        CFTypeID v9 = 0;
      }
      if (v9 && *(void *)a1)
      {
        (*(void (**)(const void **__return_ptr))(**(void **)a1 + 56))(&v12);
        CFTypeID v10 = v13;
        uint64_t v13 = v12;
        uint64_t v14 = v10;
        char v12 = 0;
        sub_1000577C4(&v14);
        sub_1000577C4(&v12);
        CFTypeRef v7 = v13;
      }
    }
    CFPreferencesSetValue(key, v7, @"com.apple.commcenter.callservices", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    CFPreferencesSynchronize(@"com.apple.commcenter.callservices", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    sub_1000577C4(&v13);
  }
  return key != 0;
}

void sub_1003A9AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

const void *sub_1003A9B04(uint64_t a1, CFStringRef key, int a3)
{
  uint64_t v13 = 0;
  if (key)
  {
    CFPropertyListRef v5 = CFPreferencesCopyValue(key, @"com.apple.commcenter.callservices", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    CFMutableArrayRef v6 = v13;
    uint64_t v13 = v5;
    uint64_t v14 = v6;
    sub_1000577C4(&v14);
    CFTypeRef v7 = v13;
    if (v13) {
      uint64_t v8 = sub_100080934;
    }
    else {
      uint64_t v8 = 0;
    }
    if (v8) {
      BOOL v9 = a3 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (!v9 && *(void *)a1)
    {
      (*(void (**)(const void **__return_ptr))(**(void **)a1 + 64))(&v12);
      CFTypeID v10 = v13;
      uint64_t v13 = v12;
      uint64_t v14 = v10;
      char v12 = 0;
      sub_1000577C4(&v14);
      sub_1000577C4(&v12);
      CFTypeRef v7 = v13;
    }
  }
  else
  {
    CFTypeRef v7 = 0;
  }
  uint64_t v13 = 0;
  sub_1000577C4(&v13);
  return v7;
}

void sub_1003A9C24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1003A9C3C(uint64_t a1, const __CFString *a2, const void *a3)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v4 = 0;
  sub_1003A99B8(a1, a2, a3, (uint64_t)__p, 0);
  if (SHIBYTE(v4) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1003A9C84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003A9CA0@<X0>(void *a1@<X8>)
{
  pthread_mutex_lock(&stru_101B0A108);
  if (!(void)xmmword_101B0A148) {
    operator new();
  }
  uint64_t v2 = *((void *)&xmmword_101B0A148 + 1);
  *a1 = xmmword_101B0A148;
  a1[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return pthread_mutex_unlock(&stru_101B0A108);
}

void sub_1003A9D64(_Unwind_Exception *a1)
{
}

void sub_1003A9D84()
{
  os_log_t oslog = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "ps.sto");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, (const OsLogContext *)buf);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  CFDictionaryRef v0 = CFPreferencesCopyMultiple(0, @"com.apple.commcenter.callservices", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  CFDictionaryRef theDict = v0;
  if (v0) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  if (v1) {
    CFIndex Count = CFDictionaryGetCount(v0);
  }
  else {
    CFIndex Count = 0;
  }
  uint64_t v3 = oslog;
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315650;
    uint64_t v47 = &unk_10161656E;
    __int16 v48 = 2080;
    uint64_t v49 = &unk_10161656E;
    __int16 v50 = 2048;
    CFIndex v51 = Count;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s| ---- local storage has %zu values", buf, 0x20u);
  }
  if (theDict) {
    uint64_t v4 = sub_100080778;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    keys = 0;
    long long v40 = 0;
    uint64_t v41 = 0;
    sub_10019E8F0(&keys, Count);
    values = 0;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    sub_10004EE3C(&values, Count);
    CFDictionaryGetKeysAndValues(theDict, (const void **)keys, (const void **)values);
    if (Count)
    {
      for (CFIndex i = 0; Count != i; ++i)
      {
        CFTypeID v6 = CFGetTypeID(values[i]);
        if (v6 == CFStringGetTypeID())
        {
          CFTypeRef v7 = oslog;
          if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
          {
            long long v44 = 0uLL;
            uint64_t v45 = 0;
            ctu::cf::assign();
            *(_OWORD *)CFMutableArrayRef v34 = v44;
            uint64_t v35 = v45;
            uint64_t v8 = (void **)v44;
            int v9 = SHIBYTE(v45);
            long long v44 = 0uLL;
            uint64_t v45 = 0;
            ctu::cf::assign();
            CFTypeID v10 = v34;
            if (v9 < 0) {
              CFTypeID v10 = v8;
            }
            *(_OWORD *)std::string __p = v44;
            uint64_t v33 = v45;
            CFMutableArrayRef v11 = (void **)v44;
            if (v45 >= 0) {
              CFMutableArrayRef v11 = __p;
            }
            *(_DWORD *)long long buf = 136316162;
            uint64_t v47 = &unk_10161656E;
            __int16 v48 = 2080;
            uint64_t v49 = &unk_10161656E;
            __int16 v50 = 2048;
            CFIndex v51 = i;
            __int16 v52 = 2080;
            uint64_t v53 = v10;
            __int16 v54 = 2080;
            uint64_t v55 = v11;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%s| %2zu %s \t= %s", buf, 0x34u);
            if (SHIBYTE(v33) < 0) {
              operator delete(__p[0]);
            }
            goto LABEL_40;
          }
        }
        else
        {
          CFTypeID v12 = CFGetTypeID(values[i]);
          if (v12 == CFNumberGetTypeID())
          {
            os_log_t v13 = oslog;
            if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
            {
              long long v44 = 0uLL;
              uint64_t v45 = 0;
              ctu::cf::assign();
              uint64_t v35 = v45;
              *(_OWORD *)CFMutableArrayRef v34 = v44;
              int v14 = SHIBYTE(v45);
              int v15 = (void **)v44;
              CFNumberRef v16 = (int *)values[i];
              LODWORD(v44) = 0;
              ctu::cf::assign((ctu::cf *)&v44, v16, v17);
              unint64_t v18 = v34;
              if (v14 < 0) {
                unint64_t v18 = v15;
              }
              *(_DWORD *)long long buf = 136316162;
              uint64_t v47 = &unk_10161656E;
              __int16 v48 = 2080;
              uint64_t v49 = &unk_10161656E;
              __int16 v50 = 2048;
              CFIndex v51 = i;
              __int16 v52 = 2080;
              uint64_t v53 = v18;
              __int16 v54 = 1024;
              LODWORD(v55) = v44;
              int v19 = v13;
              CFNumberRef v20 = "#I %s%s| %2zu %s \t= %d";
              uint32_t v21 = 48;
              goto LABEL_39;
            }
          }
          else
          {
            CFTypeID v22 = CFGetTypeID(values[i]);
            CFTypeID TypeID = CFBooleanGetTypeID();
            os_log_t v24 = oslog;
            BOOL v25 = os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT);
            if (v22 == TypeID)
            {
              if (v25)
              {
                long long v44 = 0uLL;
                uint64_t v45 = 0;
                ctu::cf::assign();
                uint64_t v35 = v45;
                *(_OWORD *)CFMutableArrayRef v34 = v44;
                int v26 = SHIBYTE(v45);
                uint64_t v27 = (void **)v44;
                int Value = CFBooleanGetValue((CFBooleanRef)values[i]);
                *(_DWORD *)long long buf = 136316162;
                CFNumberRef v29 = v34;
                if (v26 < 0) {
                  CFNumberRef v29 = v27;
                }
                uint64_t v47 = &unk_10161656E;
                uint64_t v30 = "true";
                if (!Value) {
                  uint64_t v30 = "false";
                }
                __int16 v48 = 2080;
                uint64_t v49 = &unk_10161656E;
                __int16 v50 = 2048;
                CFIndex v51 = i;
                __int16 v52 = 2080;
                uint64_t v53 = v29;
                __int16 v54 = 2080;
                uint64_t v55 = (void *)v30;
                int v19 = v24;
                CFNumberRef v20 = "#I %s%s| %2zu %s \t= %s";
                uint32_t v21 = 52;
                goto LABEL_39;
              }
            }
            else if (v25)
            {
              long long v44 = 0uLL;
              uint64_t v45 = 0;
              ctu::cf::assign();
              *(_OWORD *)CFMutableArrayRef v34 = v44;
              uint64_t v35 = v45;
              CFTypeID v31 = (void **)v44;
              if (v45 >= 0) {
                CFTypeID v31 = v34;
              }
              *(_DWORD *)long long buf = 136315906;
              uint64_t v47 = &unk_10161656E;
              __int16 v48 = 2080;
              uint64_t v49 = &unk_10161656E;
              __int16 v50 = 2048;
              CFIndex v51 = i;
              __int16 v52 = 2080;
              uint64_t v53 = v31;
              int v19 = v24;
              CFNumberRef v20 = "#I %s%s| %2zu %s";
              uint32_t v21 = 42;
LABEL_39:
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v20, buf, v21);
LABEL_40:
              if (SHIBYTE(v35) < 0) {
                operator delete(v34[0]);
              }
            }
          }
        }
      }
    }
    if (values)
    {
      uint64_t v37 = values;
      operator delete(values);
    }
    if (keys)
    {
      long long v40 = keys;
      operator delete(keys);
    }
  }
  sub_100057D78((const void **)&theDict);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&oslog);
}

void sub_1003AA30C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,const void *a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (__p) {
    operator delete(__p);
  }
  if (a26) {
    operator delete(a26);
  }
  sub_100057D78(&a29);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&a30);
  _Unwind_Resume(a1);
}

uint64_t sub_1003AA3E8(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

uint64_t sub_1003AA440(uint64_t a1, __n128 *a2)
{
  return a1;
}

__n128 sub_1003AA4D0(uint64_t a1, __n128 *a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  if (a2[1].n128_u8[8])
  {
    __n128 result = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    *(__n128 *)a1 = result;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    a2->n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 56) = 0;
  if (a2[3].n128_u8[8])
  {
    __n128 result = a2[2];
    *(void *)(a1 + 48) = a2[3].n128_u64[0];
    *(__n128 *)(a1 + 32) = result;
    a2[2].n128_u64[1] = 0;
    a2[3].n128_u64[0] = 0;
    a2[2].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 56) = 1;
  }
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 88) = 0;
  if (a2[5].n128_u8[8])
  {
    __n128 result = a2[4];
    *(void *)(a1 + 80) = a2[5].n128_u64[0];
    *(__n128 *)(a1 + 64) = result;
    a2[4].n128_u64[1] = 0;
    a2[5].n128_u64[0] = 0;
    a2[4].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 88) = 1;
  }
  *(unsigned char *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  if (a2[7].n128_u8[8])
  {
    __n128 result = a2[6];
    *(void *)(a1 + 112) = a2[7].n128_u64[0];
    *(__n128 *)(a1 + 96) = result;
    a2[6].n128_u64[1] = 0;
    a2[7].n128_u64[0] = 0;
    a2[6].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 120) = 1;
  }
  *(unsigned char *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 152) = 0;
  if (a2[9].n128_u8[8])
  {
    __n128 result = a2[8];
    *(void *)(a1 + 144) = a2[9].n128_u64[0];
    *(__n128 *)(a1 + 128) = result;
    a2[8].n128_u64[1] = 0;
    a2[9].n128_u64[0] = 0;
    a2[8].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 152) = 1;
  }
  *(unsigned char *)(a1 + 160) = 0;
  *(unsigned char *)(a1 + 184) = 0;
  if (a2[11].n128_u8[8])
  {
    __n128 result = a2[10];
    *(void *)(a1 + 176) = a2[11].n128_u64[0];
    *(__n128 *)(a1 + 160) = result;
    a2[10].n128_u64[1] = 0;
    a2[11].n128_u64[0] = 0;
    a2[10].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 184) = 1;
  }
  *(unsigned char *)(a1 + 192) = 0;
  *(unsigned char *)(a1 + 216) = 0;
  if (a2[13].n128_u8[8])
  {
    __n128 result = a2[12];
    *(void *)(a1 + 208) = a2[13].n128_u64[0];
    *(__n128 *)(a1 + 192) = result;
    a2[12].n128_u64[1] = 0;
    a2[13].n128_u64[0] = 0;
    a2[12].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 216) = 1;
  }
  return result;
}

__n128 sub_1003AA63C(uint64_t a1, __n128 *a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  if (a2[1].n128_u8[8])
  {
    __n128 result = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    *(__n128 *)a1 = result;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    a2->n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 56) = 0;
  if (a2[3].n128_u8[8])
  {
    __n128 result = a2[2];
    *(void *)(a1 + 48) = a2[3].n128_u64[0];
    *(__n128 *)(a1 + 32) = result;
    a2[2].n128_u64[1] = 0;
    a2[3].n128_u64[0] = 0;
    a2[2].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 56) = 1;
  }
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 88) = 0;
  if (a2[5].n128_u8[8])
  {
    __n128 result = a2[4];
    *(void *)(a1 + 80) = a2[5].n128_u64[0];
    *(__n128 *)(a1 + 64) = result;
    a2[4].n128_u64[1] = 0;
    a2[5].n128_u64[0] = 0;
    a2[4].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 88) = 1;
  }
  *(unsigned char *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  if (a2[7].n128_u8[8])
  {
    __n128 result = a2[6];
    *(void *)(a1 + 112) = a2[7].n128_u64[0];
    *(__n128 *)(a1 + 96) = result;
    a2[6].n128_u64[1] = 0;
    a2[7].n128_u64[0] = 0;
    a2[6].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 120) = 1;
  }
  *(unsigned char *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 152) = 0;
  if (a2[9].n128_u8[8])
  {
    __n128 result = a2[8];
    *(void *)(a1 + 144) = a2[9].n128_u64[0];
    *(__n128 *)(a1 + 128) = result;
    a2[8].n128_u64[1] = 0;
    a2[9].n128_u64[0] = 0;
    a2[8].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 152) = 1;
  }
  *(unsigned char *)(a1 + 160) = 0;
  *(unsigned char *)(a1 + 184) = 0;
  if (a2[11].n128_u8[8])
  {
    __n128 result = a2[10];
    *(void *)(a1 + 176) = a2[11].n128_u64[0];
    *(__n128 *)(a1 + 160) = result;
    a2[10].n128_u64[1] = 0;
    a2[11].n128_u64[0] = 0;
    a2[10].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 184) = 1;
  }
  *(unsigned char *)(a1 + 192) = 0;
  *(unsigned char *)(a1 + 216) = 0;
  if (a2[13].n128_u8[8])
  {
    __n128 result = a2[12];
    *(void *)(a1 + 208) = a2[13].n128_u64[0];
    *(__n128 *)(a1 + 192) = result;
    a2[12].n128_u64[1] = 0;
    a2[13].n128_u64[0] = 0;
    a2[12].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 216) = 1;
  }
  *(unsigned char *)(a1 + 224) = 0;
  *(unsigned char *)(a1 + 248) = 0;
  if (a2[15].n128_u8[8])
  {
    __n128 result = a2[14];
    *(void *)(a1 + 240) = a2[15].n128_u64[0];
    *(__n128 *)(a1 + 224) = result;
    a2[14].n128_u64[1] = 0;
    a2[15].n128_u64[0] = 0;
    a2[14].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 248) = 1;
  }
  return result;
}

uint64_t sub_1003AA7DC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 248) && *(char *)(a1 + 247) < 0) {
    operator delete(*(void **)(a1 + 224));
  }
  if (*(unsigned char *)(a1 + 216) && *(char *)(a1 + 215) < 0) {
    operator delete(*(void **)(a1 + 192));
  }
  if (*(unsigned char *)(a1 + 184) && *(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(unsigned char *)(a1 + 152) && *(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(unsigned char *)(a1 + 120) && *(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(unsigned char *)(a1 + 88) && *(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(unsigned char *)(a1 + 24) && *(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_1003AA8C0(void *a1, CFTypeRef *a2)
{
  CFTypeRef v4 = *a2;
  if (*a2 && (CFTypeID v5 = CFGetTypeID(*a2), v5 == CFDictionaryGetTypeID()))
  {
    *a1 = v4;
  }
  else
  {
    *a1 = 0;
    if (*a2) {
      CFRelease(*a2);
    }
  }
  return a1;
}

void sub_1003AA92C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1003AA99C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_1001F20B0((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003AA9C0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1003AA9F8(uint64_t a1)
{
}

uint64_t sub_1003AAA00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1003AAA44()
{
  if ((byte_101B0CD50 & 1) == 0)
  {
    byte_101B0CD50 = 1;
    return __cxa_atexit((void (*)(void *))sub_1003AA3E8, &stru_101B0A108, (void *)&_mh_execute_header);
  }
  return result;
}

void sub_1003AAF80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }

  _Unwind_Resume(a1);
}

void sub_1003AB314(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1003AB9A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }

  _Unwind_Resume(a1);
}

id sub_1003ABAEC(id a1)
{
  if (a1 <= 2) {
    a1 = *(id *)*(&off_1019C3BA8 + (int)a1);
  }
  return a1;
}

void sub_1003ABB30()
{
}

void sub_1003ABB58(uint64_t a1)
{
  *(void *)a1 = off_1019C3BD0;
  uint64_t v4 = *(void *)(a1 + 88);
  uint64_t v2 = (void *)(a1 + 88);
  uint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  uint64_t v5 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = 0;
  if (v5) {
    sub_100206334(a1 + 80, v5);
  }
  uint64_t v6 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = 0;
  if (v6) {
    sub_100206334(a1 + 72, v6);
  }
  CFMutableArrayRef v11 = (void **)(a1 + 48);
  sub_100047F64(&v11);
  uint64_t v7 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v7) {
    sub_100206334(a1 + 40, v7);
  }
  uint64_t v8 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v8) {
    sub_100206334(a1 + 32, v8);
  }
  uint64_t v9 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v9) {
    sub_100206334(a1 + 24, v9);
  }
  sub_100110A40((void ***)(a1 + 16), 0);
  uint64_t v10 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v10) {
    sub_100206334(a1 + 8, v10);
  }
  PB::Base::~Base((PB::Base *)a1);
}

void sub_1003ABC4C(uint64_t a1)
{
  sub_1003ABB58(a1);

  operator delete();
}

uint64_t sub_1003ABC84(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_1019C3BD0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  if (*(void *)(a2 + 16)) {
    operator new();
  }
  if (a1 != a2) {
    sub_10005CA3C(a1 + 48, *(std::string **)(a2 + 48), *(long long **)(a2 + 56), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 56) - *(void *)(a2 + 48)) >> 3));
  }
  if (*(void *)(a2 + 72)) {
    operator new();
  }
  if (*(void *)(a2 + 80)) {
    operator new();
  }
  if (*(void *)(a2 + 40)) {
    operator new();
  }
  if (*(void *)(a2 + 32)) {
    operator new();
  }
  if (*(void *)(a2 + 24)) {
    operator new();
  }
  if (*(void *)(a2 + 88)) {
    operator new();
  }
  char v4 = *(unsigned char *)(a2 + 104);
  if (v4)
  {
    int v5 = *(_DWORD *)(a2 + 96);
    *(unsigned char *)(a1 + 104) |= 1u;
    *(_DWORD *)(a1 + 96) = v5;
    char v4 = *(unsigned char *)(a2 + 104);
  }
  if ((v4 & 2) != 0)
  {
    int v6 = *(_DWORD *)(a2 + 100);
    *(unsigned char *)(a1 + 104) |= 2u;
    *(_DWORD *)(a1 + 100) = v6;
  }
  return a1;
}

uint64_t sub_1003AC0B4(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  if (*(unsigned char *)(a1 + 104)) {
    PB::TextFormatter::format(this, "gsmaSgp22Version", *(_DWORD *)(a1 + 96));
  }
  if (*(void *)(a1 + 8)) {
    PB::TextFormatter::format();
  }
  int v5 = *(const PB::Data **)(a1 + 16);
  if (v5) {
    PB::TextFormatter::format(this, "secondaryCsn", v5);
  }
  if (*(void *)(a1 + 24)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 32)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 40)) {
    PB::TextFormatter::format();
  }
  uint64_t v6 = *(void *)(a1 + 48);
  for (uint64_t i = *(void *)(a1 + 56); v6 != i; v6 += 24)
    PB::TextFormatter::format();
  if (*(void *)(a1 + 72)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 80)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 88)) {
    PB::TextFormatter::format();
  }
  if ((*(unsigned char *)(a1 + 104) & 2) != 0) {
    PB::TextFormatter::format(this, "simAllianceProfileVersion", *(_DWORD *)(a1 + 100));
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_1003AC230(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  uint64_t v59 = (uint64_t *)(a1 + 48);
  uint64_t v8 = a1 + 64;
  uint64_t v9 = a1 + 8;
  while (1)
  {
    uint64_t v10 = *(void *)this;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
      break;
    }
    char v17 = 0;
    unsigned int v18 = 0;
    unint64_t v13 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    do
    {
      if (v3 == v2)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      unint64_t v19 = v2 + 1;
      char v20 = *(unsigned char *)(v10 + v2);
      *((void *)this + 1) = v19;
      v13 |= (unint64_t)(v20 & 0x7F) << v17;
      if ((v20 & 0x80) == 0) {
        goto LABEL_23;
      }
      v17 += 7;
      unint64_t v2 = v19;
      BOOL v16 = v18++ > 8;
    }
    while (!v16);
LABEL_20:
    unsigned __int8 v21 = 0;
    LODWORD(v22) = 0;
LABEL_21:
    uint64_t result = PB::Reader::skip(this, v22, v21, 0);
    if (!result) {
      return result;
    }
LABEL_35:
    unint64_t v2 = *((void *)this + 1);
    unint64_t v3 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v11 = 0;
  unsigned int v12 = 0;
  unint64_t v13 = 0;
  while (1)
  {
    unint64_t v14 = v2 + 1;
    *((void *)this + 1) = v2 + 1;
    char v15 = *(unsigned char *)(v10 + v2);
    v13 |= (unint64_t)(v15 & 0x7F) << v11;
    if ((v15 & 0x80) == 0) {
      break;
    }
    v11 += 7;
    unint64_t v2 = v14;
    BOOL v16 = v12++ > 8;
    if (v16) {
      goto LABEL_20;
    }
  }
LABEL_23:
  unsigned __int8 v21 = v13 & 7;
  if ((v13 & 7) != 4)
  {
    unint64_t v22 = v13 >> 3;
    switch((v13 >> 3))
    {
      case 1u:
        operator new();
      case 2u:
        operator new();
      case 3u:
        uint64_t v58 = v9;
        BOOL v25 = *(void **)(a1 + 56);
        unint64_t v24 = *(void *)(a1 + 64);
        if ((unint64_t)v25 >= v24)
        {
          unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v25 - *v59) >> 3);
          unint64_t v45 = v44 + 1;
          if (v44 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_1000D8578();
          }
          unint64_t v46 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - *v59) >> 3);
          if (2 * v46 > v45) {
            unint64_t v45 = 2 * v46;
          }
          if (v46 >= 0x555555555555555) {
            unint64_t v47 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v47 = v45;
          }
          v60[4] = v8;
          if (v47) {
            __int16 v48 = (char *)sub_10004812C(v8, v47);
          }
          else {
            __int16 v48 = 0;
          }
          long long v57 = &v48[24 * v44];
          v60[0] = v48;
          v60[1] = v57;
          v60[3] = &v48[24 * v47];
          *(void *)long long v57 = 0;
          *((void *)v57 + 1) = 0;
          *((void *)v57 + 2) = 0;
          void v60[2] = v57 + 24;
          sub_100048204(v59, v60);
          char v26 = *(void **)(a1 + 56);
          sub_100048174((uint64_t)v60);
        }
        else
        {
          *BOOL v25 = 0;
          v25[1] = 0;
          _OWORD v25[2] = 0;
          char v26 = v25 + 3;
          *(void *)(a1 + 56) = v25 + 3;
        }
        *(void *)(a1 + 56) = v26;
        PB::Reader::read();
        uint64_t v9 = v58;
        goto LABEL_35;
      case 4u:
        operator new();
      case 5u:
        operator new();
      case 6u:
        operator new();
      case 7u:
        operator new();
      case 8u:
        operator new();
      case 9u:
        operator new();
      case 0xAu:
        *(unsigned char *)(a1 + 104) |= 1u;
        unint64_t v28 = *((void *)this + 1);
        unint64_t v29 = *((void *)this + 2);
        uint64_t v30 = *(void *)this;
        if (v28 <= 0xFFFFFFFFFFFFFFF5 && v28 + 10 <= v29)
        {
          char v31 = 0;
          unsigned int v32 = 0;
          uint64_t v33 = 0;
          do
          {
            unint64_t v34 = v28 + 1;
            *((void *)this + 1) = v28 + 1;
            char v35 = *(unsigned char *)(v30 + v28);
            v33 |= (unint64_t)(v35 & 0x7F) << v31;
            if ((v35 & 0x80) == 0) {
              goto LABEL_83;
            }
            v31 += 7;
            unint64_t v28 = v34;
            BOOL v16 = v32++ > 8;
          }
          while (!v16);
LABEL_68:
          LODWORD(v33) = 0;
          goto LABEL_83;
        }
        char v49 = 0;
        unsigned int v50 = 0;
        uint64_t v33 = 0;
        if (v29 <= v28) {
          unint64_t v29 = *((void *)this + 1);
        }
        while (2)
        {
          if (v29 == v28)
          {
            LODWORD(v33) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v51 = v28 + 1;
            char v52 = *(unsigned char *)(v30 + v28);
            *((void *)this + 1) = v51;
            v33 |= (unint64_t)(v52 & 0x7F) << v49;
            if (v52 < 0)
            {
              v49 += 7;
              unint64_t v28 = v51;
              BOOL v16 = v50++ > 8;
              if (v16) {
                goto LABEL_68;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v33) = 0;
            }
          }
          break;
        }
LABEL_83:
        *(_DWORD *)(a1 + 96) = v33;
        goto LABEL_35;
      case 0xBu:
        *(unsigned char *)(a1 + 104) |= 2u;
        unint64_t v36 = *((void *)this + 1);
        unint64_t v37 = *((void *)this + 2);
        uint64_t v38 = *(void *)this;
        if (v36 <= 0xFFFFFFFFFFFFFFF5 && v36 + 10 <= v37)
        {
          char v39 = 0;
          unsigned int v40 = 0;
          uint64_t v41 = 0;
          do
          {
            unint64_t v42 = v36 + 1;
            *((void *)this + 1) = v36 + 1;
            char v43 = *(unsigned char *)(v38 + v36);
            v41 |= (unint64_t)(v43 & 0x7F) << v39;
            if ((v43 & 0x80) == 0) {
              goto LABEL_86;
            }
            v39 += 7;
            unint64_t v36 = v42;
            BOOL v16 = v40++ > 8;
          }
          while (!v16);
LABEL_75:
          LODWORD(v41) = 0;
          goto LABEL_86;
        }
        char v53 = 0;
        unsigned int v54 = 0;
        uint64_t v41 = 0;
        if (v37 <= v36) {
          unint64_t v37 = *((void *)this + 1);
        }
        break;
      default:
        goto LABEL_21;
    }
    while (1)
    {
      if (v37 == v36)
      {
        LODWORD(v41) = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_86;
      }
      unint64_t v55 = v36 + 1;
      char v56 = *(unsigned char *)(v38 + v36);
      *((void *)this + 1) = v55;
      v41 |= (unint64_t)(v56 & 0x7F) << v53;
      if ((v56 & 0x80) == 0) {
        break;
      }
      v53 += 7;
      unint64_t v36 = v55;
      BOOL v16 = v54++ > 8;
      if (v16) {
        goto LABEL_75;
      }
    }
    if (*((unsigned char *)this + 24)) {
      LODWORD(v41) = 0;
    }
LABEL_86:
    *(_DWORD *)(a1 + 100) = v41;
    goto LABEL_35;
  }
  int v4 = 0;
  return v4 == 0;
}

void sub_1003AC968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100048174((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1003AC9A8(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  if (*(void *)(result + 8)) {
    uint64_t result = PB::Writer::write();
  }
  int v4 = *(const PB::Data **)(v3 + 16);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 2u);
  }
  uint64_t v5 = *(void *)(v3 + 48);
  uint64_t v6 = *(void *)(v3 + 56);
  while (v5 != v6)
  {
    uint64_t result = PB::Writer::write();
    v5 += 24;
  }
  if (*(void *)(v3 + 72)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 80)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 40)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 32)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 24)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 88)) {
    uint64_t result = PB::Writer::write();
  }
  char v7 = *(unsigned char *)(v3 + 104);
  if (v7)
  {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 96), 0xAu);
    char v7 = *(unsigned char *)(v3 + 104);
  }
  if ((v7 & 2) != 0)
  {
    unsigned int v8 = *(_DWORD *)(v3 + 100);
    return PB::Writer::writeVarInt(this, v8, 0xBu);
  }
  return result;
}

uint64_t sub_1003ACAE4(uint64_t a1, char *a2)
{
  int v4 = sub_10035EBCC(a2);
  if (v4)
  {
    *(_DWORD *)(a1 + 20) = v4;
  }
  else if (a2)
  {
    sub_10003ED78((std::string *)(a1 + 24), a2);
  }
  return 1;
}

uint64_t sub_1003ACB30(uint64_t a1, std::string *this)
{
  int v2 = *(_DWORD *)(a1 + 20);
  if ((v2 & 0x80) != 0)
  {
    return sub_10035EA00(v2, this);
  }
  else
  {
    std::string::operator=(this, (const std::string *)(a1 + 24));
    return 1;
  }
}

void sub_1003ACB7C()
{
}

void sub_1003ACBE8()
{
}

void sub_1003ACC80()
{
}

uint64_t sub_1003ACCA4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 20);
  if (v2 >= *(_DWORD *)(a2 + 16)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a2 + 8);
  if ((*(char *)(v3 + v2) & 0x80000000) == 0) {
    return sub_100FEC944(a2, (std::string *)(a1 + 24), 0xFFFFFFFF);
  }
  *(_DWORD *)(a2 + 20) = v2 + 1;
  int v5 = *(char *)(v3 + v2);
  if ((v5 & 0x80000000) == 0) {
    return 0;
  }
  *(_DWORD *)(a1 + 20) = v5 & 0x7F;
  return 1;
}

uint64_t sub_1003ACCFC(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 20);
  if ((v2 & 0x80) != 0)
  {
    std::string::push_back((std::string *)(a2 + 8), v2 | 0x80);
  }
  else
  {
    uint64_t v3 = (unsigned char *)(a1 + 24);
    if (*(char *)(a1 + 47) < 0) {
      uint64_t v3 = *(unsigned char **)v3;
    }
    sub_10078E554(a2, v3);
  }
  return 1;
}

const char *sub_1003ACD4C()
{
  return "constrained";
}

uint64_t sub_1003ACD58(uint64_t a1)
{
  *(void *)a1 = off_1019C3C20;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_1003ACDA8(uint64_t a1)
{
  *(void *)a1 = off_1019C3C20;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

double sub_1003ACE18(unint64_t a1)
{
  double v1 = 0.0;
  if (a1)
  {
    if (a1 < 0xD)
    {
      unint64_t v2 = 1;
LABEL_6:
      double v1 = (double)(2 * vcvtpd_u64_f64(fmax(((double)v2 + -1.0) / 0.7 + 2.04081633 - (double)v2, 0.0)));
      return ceil((v1 + (double)v2 * 2.0) * 2.56) + 2.56;
    }
    unint64_t v2 = (unint64_t)(ceil((double)(a1 - 11) / 17.0) + 1.0);
    if (v2) {
      goto LABEL_6;
    }
  }
  else
  {
    unint64_t v2 = 0;
  }
  return ceil((v1 + (double)v2 * 2.0) * 2.56) + 2.56;
}

void *sub_1003ACEBC(void *a1)
{
  *a1 = off_1019C3EA8;
  unint64_t v2 = (std::__shared_weak_count *)a1[3];
  a1[2] = 0;
  a1[3] = 0;
  if (v2)
  {
    sub_10004D2C8(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[3];
    if (v3) {
      sub_10004D2C8(v3);
    }
  }
  return a1;
}

void sub_1003ACF18()
{
  long long v0 = 0uLL;
  operator new();
}

void sub_1003ACF98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003ACFD0()
{
}

uint64_t sub_1003AD074(uint64_t a1, uint64_t a2, uint64_t a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, "tm.mgr.ism");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &v7);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 8), (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_1019C3CB0;
  *(unsigned char *)(a1 + 32) = 0;
  *(void *)(a1 + 36) = 0xFFFFFFFFLL;
  *(_WORD *)(a1 + 44) = 0;
  *(void *)(a1 + 48) = a2;
  *(void *)(a1 + 56) = a3;
  *(void *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = -1;
  return a1;
}

void sub_1003AD138(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1003AD15C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 16))();
}

uint64_t sub_1003AD184(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 32))();
}

uint64_t sub_1003AD1AC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 48))();
}

uint64_t sub_1003AD1D4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 40))();
}

uint64_t sub_1003AD1FC(uint64_t a1, int a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64));
  if (result != a2)
  {
    if (a2 == 1) {
      operator new();
    }
    if (!a2) {
      operator new();
    }
    uint64_t v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 48);
      int v7 = 136315650;
      uint64_t v8 = v6;
      __int16 v9 = 2080;
      uint64_t v10 = " ";
      __int16 v11 = 2080;
      unsigned int v12 = "kAvailable";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sInternetSupportState changed to: %s", (uint8_t *)&v7, 0x20u);
    }
    return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56));
  }
  return result;
}

uint64_t sub_1003AD404(uint64_t result, int a2)
{
  int v2 = *(unsigned __int8 *)(result + 32);
  if (v2 != a2)
  {
    BOOL v3 = a2;
    uint64_t v4 = result;
    uint64_t v5 = *(NSObject **)(result + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(v4 + 48);
      int v7 = 136315906;
      uint64_t v8 = v6;
      __int16 v9 = 2080;
      uint64_t v10 = " ";
      __int16 v11 = 2080;
      uint64_t v12 = asStringBool(v2 != 0);
      __int16 v13 = 2080;
      uint64_t v14 = asStringBool(v3);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%shandleInternetAvailabilityChanged: %s ==> %s", (uint8_t *)&v7, 0x2Au);
    }
    *(unsigned char *)(v4 + 32) = v3;
    return (*(uint64_t (**)(void, void))(**(void **)(v4 + 64) + 24))(*(void *)(v4 + 64), 0);
  }
  return result;
}

void sub_1003AD530(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 36) != a2)
  {
    uint64_t v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 48);
      int v13 = 136315906;
      uint64_t v14 = v5;
      __int16 v15 = 2080;
      BOOL v16 = " ";
      __int16 v17 = 2080;
      uint64_t v18 = asString();
      __int16 v19 = 2080;
      uint64_t v20 = asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sData mode changed from: %s ==> %s", (uint8_t *)&v13, 0x2Au);
    }
    *(_DWORD *)(a1 + 36) = a2;
    if ((a2 - 1) > 0x10) {
      int v6 = 0;
    }
    else {
      int v6 = dword_101496504[a2 - 1];
    }
    int v7 = *(_DWORD *)(a1 + 40);
    if (v7 != v6)
    {
      uint64_t v8 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        if ((v7 - 1) > 2) {
          __int16 v9 = "kOff";
        }
        else {
          __int16 v9 = off_1019C3FC0[v7 - 1];
        }
        uint64_t v10 = *(void *)(a1 + 48);
        if ((v6 - 1) > 2) {
          __int16 v11 = "kOff";
        }
        else {
          __int16 v11 = off_1019C3FC0[v6 - 1];
        }
        uint64_t v12 = asString();
        int v13 = 136316162;
        uint64_t v14 = v10;
        __int16 v15 = 2080;
        BOOL v16 = " ";
        __int16 v17 = 2080;
        uint64_t v18 = (uint64_t)v9;
        __int16 v19 = 2080;
        uint64_t v20 = (uint64_t)v11;
        __int16 v21 = 2080;
        uint64_t v22 = v12;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%sUnsettled quality: %s ==> %s, dataMode = %s", (uint8_t *)&v13, 0x34u);
      }
      *(_DWORD *)(a1 + 40) = v6;
      (*(void (**)(void, void))(**(void **)(a1 + 64) + 24))(*(void *)(a1 + 64), 0);
    }
  }
}

uint64_t sub_1003AD750(uint64_t a1, BOOL a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 48);
    uint64_t v6 = asStringBool(*(unsigned char *)(a1 + 44));
    int v8 = 136315906;
    uint64_t v9 = v5;
    __int16 v10 = 2080;
    __int16 v11 = " ";
    __int16 v12 = 2080;
    uint64_t v13 = v6;
    __int16 v14 = 2080;
    uint64_t v15 = asStringBool(a2);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sisWrmRecommendedPrivateNw %s ==> %s", (uint8_t *)&v8, 0x2Au);
  }
  *(unsigned char *)(a1 + 44) = a2;
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 64) + 24))(*(void *)(a1 + 64), 1);
}

void sub_1003AD86C(uint64_t a1)
{
  *(unsigned char *)(a1 + 44) = 0;
  int v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 48);
    int v4 = 136315394;
    uint64_t v5 = v3;
    __int16 v6 = 2080;
    int v7 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sresetWrmDataSubRecommendation", (uint8_t *)&v4, 0x16u);
  }
}

uint64_t sub_1003AD924(uint64_t result, int a2)
{
  int v2 = *(unsigned __int8 *)(result + 45);
  if (v2 != a2)
  {
    BOOL v3 = a2;
    uint64_t v4 = result;
    uint64_t v5 = *(NSObject **)(result + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(v4 + 48);
      int v7 = 136315906;
      uint64_t v8 = v6;
      __int16 v9 = 2080;
      __int16 v10 = " ";
      __int16 v11 = 2080;
      uint64_t v12 = asStringBool(v2 != 0);
      __int16 v13 = 2080;
      uint64_t v14 = asStringBool(v3);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sUnsettled isCongested %s ==> %s", (uint8_t *)&v7, 0x2Au);
    }
    *(unsigned char *)(v4 + 45) = v3;
    return (*(uint64_t (**)(void, void))(**(void **)(v4 + 64) + 24))(*(void *)(v4 + 64), 0);
  }
  return result;
}

uint64_t sub_1003ADA50(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 48);
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%shandleServiceStateChanged", (uint8_t *)&v5, 0x16u);
  }
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 64) + 24))(*(void *)(a1 + 64), 0);
}

uint64_t sub_1003ADB30(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 76) != a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(NSObject **)(result + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(v3 + 48);
      int v6 = 136315906;
      uint64_t v7 = v5;
      __int16 v8 = 2080;
      __int16 v9 = " ";
      __int16 v10 = 2080;
      uint64_t v11 = asString();
      __int16 v12 = 2080;
      uint64_t v13 = asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sRat changed from %s ==> %s", (uint8_t *)&v6, 0x2Au);
    }
    *(_DWORD *)(v3 + 76) = a2;
    return (*(uint64_t (**)(void, void))(**(void **)(v3 + 64) + 24))(*(void *)(v3 + 64), 0);
  }
  return result;
}

uint64_t sub_1003ADC58(uint64_t result, int a2)
{
  int v2 = *(unsigned __int8 *)(result + 72);
  if (v2 != a2)
  {
    BOOL v3 = a2;
    uint64_t v4 = result;
    uint64_t v5 = *(NSObject **)(result + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(v4 + 48);
      int v7 = 136315906;
      uint64_t v8 = v6;
      __int16 v9 = 2080;
      __int16 v10 = " ";
      __int16 v11 = 2080;
      uint64_t v12 = asStringBool(v2 != 0);
      __int16 v13 = 2080;
      uint64_t v14 = asStringBool(v3);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%shasActiveCSCall %s ==> %s", (uint8_t *)&v7, 0x2Au);
    }
    *(unsigned char *)(v4 + 72) = v3;
    return (*(uint64_t (**)(void, void))(**(void **)(v4 + 64) + 24))(*(void *)(v4 + 64), 0);
  }
  return result;
}

uint64_t sub_1003ADD84(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 72)) {
    return 0;
  }
  unsigned int v1 = *(_DWORD *)(a1 + 76) + 1;
  BOOL v2 = v1 >= 0xB;
  BOOL v3 = v1 == 11;
  unsigned int v4 = (0x6F6u >> v1) & 1;
  if (!v3 && v2) {
    return 1;
  }
  else {
    return v4;
  }
}

uint64_t sub_1003ADDB8()
{
  return 1;
}

void sub_1003ADDC0(uint64_t a1, char a2)
{
  int v4 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 56) + 32))(*(void *)(*(void *)(a1 + 8) + 56));
  uint64_t v5 = *(void *)(a1 + 8);
  if (v4 == 1) {
    goto LABEL_2;
  }
  if (*(unsigned char *)(v5 + 72))
  {
    unsigned int v6 = *(_DWORD *)(v5 + 76) + 1;
    BOOL v7 = v6 > 0xB;
    int v8 = (1 << v6) & 0x909;
    if (v7 || v8 == 0) {
      goto LABEL_2;
    }
  }
  if (*(unsigned char *)(v5 + 32))
  {
    int v10 = *(_DWORD *)(v5 + 40);
    if (v10 == *(_DWORD *)(a1 + 32)
      && *(unsigned __int8 *)(v5 + 45) == *(unsigned __int8 *)(a1 + 36)
      && *(unsigned __int8 *)(v5 + 44) == *(unsigned __int8 *)(a1 + 37))
    {
      __int16 v11 = *(std::__shared_weak_count **)(a1 + 24);
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = 0;
      if (v11)
      {
        sub_10004D2C8(v11);
      }
      return;
    }
    if (a2)
    {
      if (v10)
      {
        *(_DWORD *)(a1 + 32) = v10;
        *(unsigned char *)(a1 + 36) = *(unsigned char *)(v5 + 45);
        *(unsigned char *)(a1 + 37) = *(unsigned char *)(v5 + 44);
        uint64_t v12 = *(void (**)(void))(**(void **)(v5 + 56) + 40);
        v12();
        return;
      }
LABEL_2:
      sub_1003AD1FC(v5, 0);
      return;
    }
  }
  else if (a2)
  {
    goto LABEL_2;
  }
  (*(void (**)(void))(**(void **)(v5 + 56) + 16))(*(void *)(v5 + 56));
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(*(void *)(a1 + 8) + 56) + 24))(&v15);
  if (!*(void *)(a1 + 16))
  {
    sub_100058DB0(&__p, "ReEvaluationTimer");
    v20[0] = off_1019C3F50;
    v20[1] = a1;
    v20[3] = v20;
    AutoStartTimer::create();
    long long v13 = v19;
    long long v19 = 0uLL;
    uint64_t v14 = *(std::__shared_weak_count **)(a1 + 24);
    *(_OWORD *)(a1 + 16) = v13;
    if (v14)
    {
      sub_10004D2C8(v14);
      if (*((void *)&v19 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v19 + 1));
      }
    }
    sub_10003B34C(v20);
    if (v18 < 0) {
      operator delete(__p);
    }
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
}

void sub_1003AE0B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  sub_10003B34C((void *)(v17 - 56));
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1003AE0F4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t sub_1003AE0FC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 36);
}

uint64_t sub_1003AE104(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 37);
}

uint64_t sub_1003AE10C()
{
  return 0;
}

uint64_t sub_1003AE114(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 56) + 32))(*(void *)(*(void *)(a1 + 8) + 56));
  if (result != 1)
  {
    uint64_t result = *(void *)(a1 + 8);
    if (!*(unsigned char *)(result + 72)
      || ((unsigned int v3 = *(_DWORD *)(result + 76) + 1, v4 = v3 > 0xB, v5 = (1 << v3) & 0x909, !v4) ? (v6 = v5 == 0) : (v6 = 1),
          !v6))
    {
      if (*(unsigned char *)(result + 32) && *(_DWORD *)(result + 40))
      {
        return sub_1003AD1FC(result, 1);
      }
    }
  }
  return result;
}

uint64_t sub_1003AE1C8()
{
  return 0;
}

uint64_t sub_1003AE1D0()
{
  return 1;
}

uint64_t sub_1003AE1D8()
{
  return 0;
}

void *sub_1003AE1E0(void *a1)
{
  uint64_t v2 = a1[8];
  a1[8] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unsigned int v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  return a1;
}

void sub_1003AE248(void *a1)
{
  uint64_t v2 = a1[8];
  a1[8] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unsigned int v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  operator delete();
}

void sub_1003AE2D4(void *a1)
{
  sub_1003ACEBC(a1);

  operator delete();
}

void sub_1003AE310(void *a1)
{
  sub_1003ACEBC(a1);

  operator delete();
}

void sub_1003AE350(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1003AE3D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_1003AE480((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003AE3FC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1003AE434(uint64_t a1)
{
}

uint64_t sub_1003AE43C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1003AE480(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = a2[8];
    a2[8] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    BOOL v4 = (std::__shared_weak_count *)a2[3];
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a2 + 1));
    operator delete();
  }
}

void sub_1003AE514()
{
}

void *sub_1003AE528(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019C3F50;
  result[1] = v3;
  return result;
}

uint64_t sub_1003AE570(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019C3F50;
  a2[1] = v2;
  return result;
}

uint64_t sub_1003AE59C(uint64_t a1)
{
  unsigned int v1 = *(void **)(a1 + 8);
  uint64_t v2 = (std::__shared_weak_count *)v1[3];
  void v1[2] = 0;
  v1[3] = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v1 + 24);

  return v3(v1, 1);
}

uint64_t sub_1003AE604(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003AE644()
{
}

uint64_t *LogWriter::instance(LogWriter *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13D68, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13D68))
  {
    qword_101B13CE0 = (uint64_t)off_1019C3FF8;
    unk_101B13CE8 = 0u;
    unk_101B13CF8 = 0u;
    __cxa_guard_release(&qword_101B13D68);
  }
  return &qword_101B13CE0;
}

void sub_1003AE6CC(uint64_t a1)
{
  *(void *)a1 = off_1019C3FF8;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  LogWriter::~LogWriter((LogWriter *)a1);
}

void sub_1003AE730(uint64_t a1)
{
  sub_1003AE6CC(a1);

  operator delete();
}

void sub_1003AE768(uint64_t a1, char *a2)
{
  uint64_t v3 = (std::string *)(a1 + 16);
  sub_10003ED78((std::string *)(a1 + 16), a2);
  if (*(char *)(a1 + 39) < 0) {
    uint64_t v4 = *(void *)(a1 + 24);
  }
  else {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 39);
  }
  uint64_t v5 = v4 - 1;
  BOOL v6 = v3;
  if ((*(unsigned char *)(a1 + 39) & 0x80) != 0) {
    BOOL v6 = (std::string *)v3->__r_.__value_.__r.__words[0];
  }
  if (v6->__r_.__value_.__s.__data_[v5] != 47)
  {
    std::string::push_back(v3, 47);
  }
}

void sub_1003AE7EC(uint64_t a1, UInt8 *a2, int a3)
{
  CFUUIDRef v5 = CFUUIDCreate(kCFAllocatorDefault);
  CFStringRef v6 = CFUUIDCreateString(kCFAllocatorDefault, v5);
  CFIndex usedBufLen = 0;
  v8.length = CFStringGetLength(v6);
  v8.location = 0;
  CFStringGetBytes(v6, v8, 0xBFFu, 0, 0, a2, (a3 - 1), &usedBufLen);
  a2[usedBufLen] = 0;
  CFRelease(v6);
  CFRelease(v5);
}

BOOL sub_1003AE894(uint64_t a1, const char *a2)
{
  memset(__dst, 0, sizeof(__dst));
  if (a2 && *a2)
  {
    strlcpy((char *)__dst, a2, 0x100uLL);
  }
  else
  {
    memset(&v26, 0, sizeof(v26));
    memset(&v25, 0, sizeof(v25));
    time_t v24 = time(0);
    localtime_r(&v24, &v25);
    int v3 = 0;
    do
    {
      uint64_t v4 = (const char *)(a1 + 16);
      if (*(char *)(a1 + 39) < 0) {
        uint64_t v4 = *(const char **)(a1 + 16);
      }
      snprintf((char *)(a1 + 40), 0x60uLL, "%slog-%d-%2.2d-%2.2d-%2.2d-%2.2d-%2.2d", v4, v25.tm_year + 1900, v25.tm_mon + 1, v25.tm_mday, v25.tm_hour, v25.tm_min, v25.tm_sec);
      strlcpy((char *)__dst, (const char *)(a1 + 40), 0x100uLL);
      if (v3)
      {
        size_t v5 = strlen((const char *)(a1 + 40));
        snprintf((char *)(a1 + 40 + v5), 96 - v5, "-%d", v3);
        strlcpy((char *)__dst, (const char *)(a1 + 40), 0x100uLL);
      }
      strlcat((char *)__dst, ".txt", 0x100uLL);
      ++v3;
    }
    while (!stat((const char *)__dst, &v26));
  }
  CFStringRef v6 = fopen((const char *)__dst, "wb");
  BOOL v7 = v6;
  *(void *)(a1 + 8) = v6;
  if (v6)
  {
    int v8 = fileno(v6);
    if (fcntl(v8, 48, 1) == -1)
    {
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v26, kCtLoggingSystemName, "rm:");
      st_ino = v26.st_ino;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
      if (os_log_type_enabled(st_ino, OS_LOG_TYPE_INFO))
      {
        int v10 = __error();
        __int16 v11 = strerror(*v10);
        dev_t v12 = *__error();
        v26.st_dev = 136315650;
        *(void *)&v26.st_mode = __dst;
        WORD2(v26.st_ino) = 2080;
        *(__darwin_ino64_t *)((char *)&v26.st_ino + 6) = (__darwin_ino64_t)v11;
        HIWORD(v26.st_gid) = 1024;
        v26.st_rdev = v12;
        _os_log_impl((void *)&_mh_execute_header, st_ino, OS_LOG_TYPE_INFO, "Warning: fcntl(%s, , F_NOCACHE, 1) failed: %s (%d)", (uint8_t *)&v26, 0x1Cu);
      }
      long long v13 = __error();
      uint64_t v14 = strerror(*v13);
      uint64_t v15 = __error();
      syslog(4, "Warning: fcntl(%s, F_NOCACHE, 1) failed: %s (%d)", (const char *)__dst, v14, *v15);
    }
  }
  else
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v26, kCtLoggingSystemName, "rm:");
    BOOL v16 = v26.st_ino;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      __int16 v21 = __error();
      uint64_t v22 = strerror(*v21);
      dev_t v23 = *__error();
      v26.st_dev = 136315650;
      *(void *)&v26.st_mode = __dst;
      WORD2(v26.st_ino) = 2080;
      *(__darwin_ino64_t *)((char *)&v26.st_ino + 6) = (__darwin_ino64_t)v22;
      HIWORD(v26.st_gid) = 1024;
      v26.st_rdev = v23;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "fopen(%s) failed: %s (%d)", (uint8_t *)&v26, 0x1Cu);
    }
    uint64_t v17 = __error();
    char v18 = strerror(*v17);
    long long v19 = __error();
    syslog(5, "fopen(%s) failed: %s (%d)", (const char *)__dst, v18, *v19);
  }
  return v7 != 0;
}

FILE *sub_1003AEC50(uint64_t a1)
{
  uint64_t result = *(FILE **)(a1 + 8);
  if (result)
  {
    uint64_t result = (FILE *)fclose(result);
    *(void *)(a1 + 8) = 0;
  }
  return result;
}

uint64_t sub_1003AEC80(uint64_t result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (*(void *)(result + 8)) {
    return vfprintf(*(FILE **)(result + 8), a2, &a9);
  }
  return result;
}

void sub_1003AECB8(uint64_t a1, void *__ptr, size_t __size)
{
  int v3 = *(FILE **)(a1 + 8);
  if (v3)
  {
    if (!fwrite(__ptr, __size, 1uLL, v3))
    {
      uint64_t v4 = __error();
      size_t v5 = strerror(*v4);
      CFStringRef v6 = __error();
      syslog(5, "fwrite() body failed: %s (%d)", v5, *v6);
    }
  }
}

void sub_1003AED28(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!*(void *)(a1 + 8))
  {
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    *(_OWORD *)std::string __str = 0u;
    long long v26 = 0u;
    memset(&v21, 0, sizeof(v21));
    uint64_t v10 = a1 + 40;
    snprintf(__str, 0x60uLL, "%s.txt", (const char *)(a1 + 40));
    if (stat(__str, &v21) == -1)
    {
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "rm:");
      long long v13 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v10;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "couldn't open %s.txt", buf, 0xCu);
      }
    }
    else
    {
      __int16 v11 = fopen(__str, "a");
      dev_t v12 = v11;
      if (v11)
      {
        *(void *)long long buf = &a9;
        vfprintf(v11, a2, &a9);
        fclose(v12);
      }
      else
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "rm:");
        uint64_t v14 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          uint64_t v15 = __error();
          BOOL v16 = strerror(*v15);
          int v17 = *__error();
          *(_DWORD *)long long buf = 136315650;
          *(void *)&uint8_t buf[4] = __str;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v16;
          __int16 v23 = 1024;
          int v24 = v17;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Open last log %s failed: %s (%d)", buf, 0x1Cu);
        }
        char v18 = __error();
        long long v19 = strerror(*v18);
        uint64_t v20 = __error();
        syslog(5, "Open last log %s failed: %s (%d)", __str, v19, *v20);
      }
    }
  }
}

uint64_t sub_1003AEF6C(uint64_t a1)
{
  uint64_t v2 = (const char *)(a1 + 16);
  if (*(char *)(a1 + 39) < 0) {
    uint64_t v2 = *(const char **)v2;
  }
  int v3 = opendir(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  size_t v5 = readdir(v3);
  for (i = 0; v5; size_t v5 = readdir(v4))
  {
    if (v5->d_type != 4)
    {
      if (!strncmp("log", v5->d_name, 3uLL)) {
        uint64_t i = (i + 1);
      }
      else {
        uint64_t i = i;
      }
    }
  }
  closedir(v4);
  return i;
}

void sub_1003AF008()
{
}

void sub_1003AF07C()
{
}

void sub_1003AF0A0(void *a1)
{
  *a1 = off_1019C4070;
  uint64_t v2 = a1[11];
  a1[11] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  CarrierSpaceTestModeManagerInterface::~CarrierSpaceTestModeManagerInterface((CarrierSpaceTestModeManagerInterface *)a1);
}

void sub_1003AF150(void *a1)
{
  sub_1003AF0A0(a1);

  operator delete();
}

uint64_t sub_1003AF188(uint64_t a1, void *a2, NSObject **a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, "carrier.space.test");
  sub_1003AF280((void *)(a1 + 8), a3, &v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
  *(void *)a1 = off_1019C4070;
  *(void *)(a1 + 48) = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + 56) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 80) = 0;
  return a1;
}

void sub_1003AF25C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  CarrierSpaceTestModeManagerInterface::~CarrierSpaceTestModeManagerInterface(v9);
  _Unwind_Resume(a1);
}

void *sub_1003AF280(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  size_t v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_1003AF2E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void sub_1003AF30C(uint64_t a1, char a2)
{
  *(unsigned char *)(a1 + 80) = a2;
  DevicePersistentSaveValue(@"kCarrierSpaceTestModeConfigurationCacheKey", 0);
  int v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 80)) {
      uint64_t v4 = "true";
    }
    else {
      uint64_t v4 = "false";
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Setting test mode : %s", (uint8_t *)&v5, 0xCu);
  }
}

const void **sub_1003AF3D8(uint64_t a1, uint64_t a2, id *a3)
{
  CFDictionaryRef theDict = 0;
  id v6 = *a3;
  BOOL v7 = v6;
  if (!v6) {
    goto LABEL_28;
  }
  uint64_t v8 = kCTCarrierSpaceTestConfigJSONKey;
  __int16 v9 = [v6 objectForKeyedSubscript:kCTCarrierSpaceTestConfigJSONKey];

  if (!v9)
  {
    sub_100058198((const void **)&v32, (const void **)a3);
    sub_1003AF760(&v33, a1, v32);
    CFDictionaryRef v16 = theDict;
    CFDictionaryRef theDict = v33;
    *(void *)long long buf = v16;
    CFDictionaryRef v33 = 0;
    sub_100057D78((const void **)buf);
    sub_100057D78((const void **)&v33);
    sub_100057D78((const void **)&v32);
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    char v18 = ServiceMap;
    if (v19 < 0)
    {
      uint64_t v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        uint64_t v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v19;
    __int16 v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
    if (v23)
    {
      uint64_t v25 = v23[3];
      int v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        char v26 = 0;
        if (!v25) {
          goto LABEL_21;
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    std::mutex::unlock(v18);
    int v24 = 0;
    char v26 = 1;
    if (!v25)
    {
LABEL_21:
      if ((v26 & 1) == 0) {
        sub_10004D2C8(v24);
      }
      sub_1003B0244(a1);
      goto LABEL_24;
    }
LABEL_20:
    (*(void (**)(uint64_t))(*(void *)v25 + 40))(v25);
    goto LABEL_21;
  }
  uint64_t v10 = [v7 objectForKeyedSubscript:v8];
  *(void *)long long buf = v10;
  sub_100282490((const void **)&theDict, (CFTypeRef *)buf);

  int Value = (int *)CFDictionaryGetValue(theDict, @"status");
  dev_t v12 = Value;
  if (Value)
  {
    *(_DWORD *)long long buf = 0;
    CFTypeID v13 = CFGetTypeID(Value);
    if (v13 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)buf, v12, v14);
      int v15 = *(_DWORD *)buf;
    }
    else
    {
      int v15 = 0;
    }
    long long v28 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      long long v29 = sub_100FB56F4(v15);
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v29;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I response status %s", buf, 0xCu);
    }
    goto LABEL_25;
  }
  long long v27 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "status value not present", buf, 2u);
  }
LABEL_24:
  int v15 = 6000;
LABEL_25:
  CFDictionaryRef v31 = theDict;
  if (theDict) {
    CFRetain(theDict);
  }
  sub_1003B0560(a1, a2, (const void **)&v31, v15);
  sub_100057D78((const void **)&v31);
LABEL_28:

  return sub_100057D78((const void **)&theDict);
}

void sub_1003AF6E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v6);
  }

  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1003AF760(void *a1, uint64_t a2, void *a3)
{
  id v4 = [a3 mutableCopy];
  char v5 = [v4 objectForKeyedSubscript:kCTCarrierSpaceTestConfigDataUnitsKey];
  unint64_t v45 = [v4 objectForKeyedSubscript:kCTCarrierSpaceTestConfigDataCapacityKey];
  uint64_t v40 = kCTCarrierSpaceTestConfigDataUsedKey;
  uint64_t v46 = objc_msgSend(v4, "objectForKeyedSubscript:");
  uint64_t v39 = kCTCarrierSpaceTestConfigBillingCycleEndDateKey;
  id v6 = objc_msgSend(v4, "objectForKeyedSubscript:");
  id v44 = objc_alloc_init((Class)NSISO8601DateFormatter);
  BOOL v7 = +[NSDate date];
  uint64_t v42 = [v44 stringFromDate:v7];

  if (v6)
  {
    if (![v6 length])
    {

      id v6 = 0;
    }
    uint64_t v8 = sub_100961BA4(v6);
    __int16 v9 = v8;
    if (v8 && ([v8 timeIntervalSinceNow], v10 < 0.0))
    {
      __int16 v11 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I billing cycle end date expired, reset it", buf, 2u);
      }
    }
    else
    {

      if (v6) {
        goto LABEL_11;
      }
    }
  }
  dev_t v12 = +[NSDate dateWithTimeIntervalSinceNow:2592000.0];
  id v6 = [v44 stringFromDate:v12];

LABEL_11:
  char v43 = v6;
  CFStringRef v13 = (const __CFString *)v46;
  if (!v46) {
    CFStringRef v13 = @"0";
  }
  unint64_t v47 = (__CFString *)v13;
  if (v5 && v45)
  {
    v75[1] = v5;
    v76[0] = @"Domestic Plan -";
    v75[0] = v45;
    CFNumberRef v14 = +[NSArray arrayWithObjects:v75 count:2];
    int v15 = [v14 componentsJoinedByString:@" "];
    v76[1] = v15;
    v76[2] = @" data, unlimited voice and SMS";
    CFDictionaryRef v16 = +[NSArray arrayWithObjects:v76 count:3];
    int v17 = [v16 componentsJoinedByString:@" "];

    v73[0] = @"plan-label";
    v73[1] = @"plan-category";
    v74[0] = v17;
    v74[1] = &off_101AE6358;
    v73[2] = @"current-used-plan";
    v73[3] = @"data-measure-unit";
    v74[2] = &__kCFBooleanTrue;
    v74[3] = v5;
    v73[4] = @"data-capacity";
    void v73[5] = @"data-used";
    v74[4] = v45;
    v74[5] = v47;
    v73[6] = @"voice-minutes-capacity";
    v73[7] = @"voice-minutes-used";
    v74[6] = @"Unlimited";
    v74[7] = @"100";
    v73[8] = @"messages-capacity";
    v73[9] = @"messages-used";
    v74[8] = @"Unlimited";
    v74[9] = @"100";
    v73[10] = @"last-updated-at";
    v74[10] = v42;
    uint64_t v38 = +[NSDictionary dictionaryWithObjects:v74 forKeys:v73 count:11];
    v71[2] = @"current-used-plan";
    v71[3] = @"data-measure-unit";
    v71[0] = @"plan-label";
    v71[1] = @"plan-category";
    v72[2] = &__kCFBooleanFalse;
    v72[3] = @"GB";
    v72[0] = @"International Roaming 2GB";
    v72[1] = &off_101AE6370;
    v71[4] = @"data-capacity";
    v71[5] = @"data-used";
    v72[4] = @"2";
    v72[5] = @"0";
    v71[6] = @"voice-minutes-capacity";
    v71[7] = @"voice-minutes-used";
    v72[6] = @"500";
    v72[7] = @"0";
    v71[8] = @"messages-capacity";
    v71[9] = @"messages-used";
    v72[8] = @"Unlimited";
    v72[9] = @"0";
    v71[10] = @"last-updated-at";
    v72[10] = v42;
    uint64_t v18 = +[NSDictionary dictionaryWithObjects:v72 forKeys:v71 count:11];
    v70[0] = v38;
    v70[1] = v18;
    unint64_t v34 = (void *)v18;
    uint64_t v19 = +[NSArray arrayWithObjects:v70 count:2];
    v68[0] = @"network-usage-label";
    v68[1] = @"device-type";
    v69[0] = @"iPhone";
    v69[1] = &off_101AE6358;
    v68[2] = @"local-device-metrics";
    v68[3] = @"subscription-status";
    v69[2] = &__kCFBooleanTrue;
    v69[3] = @"subscribed";
    v68[4] = @"plan-type";
    v68[5] = @"billing-cycle-ends-date";
    v69[4] = @"postpaid";
    v69[5] = v6;
    v68[6] = @"applicable-plans";
    v69[6] = v19;
    unint64_t v36 = (void *)v19;
    uint64_t v67 = +[NSDictionary dictionaryWithObjects:v69 forKeys:v68 count:7];
    CFDictionaryRef v33 = (void *)v67;
    uint64_t v20 = +[NSArray arrayWithObjects:&v67 count:1];
    CFStringRef v65 = @"account-metrics";
    unsigned int v32 = (void *)v20;
    uint64_t v66 = v20;
    unint64_t v37 = +[NSDictionary dictionaryWithObjects:&v66 forKeys:&v65 count:1];
    v63[0] = @"plan-id";
    v63[1] = @"plan-label";
    v64[0] = @"ABC123DOM1";
    v64[1] = v17;
    v63[2] = @"plan-value";
    void v63[3] = @"plan-subscribed";
    v64[2] = @"USD60";
    v64[3] = @"subscribed";
    v63[4] = @"plan-purchasable";
    v64[4] = &__kCFBooleanFalse;
    CFDictionaryRef v31 = +[NSDictionary dictionaryWithObjects:v64 forKeys:v63 count:5];
    uint64_t v62 = v31;
    uint64_t v21 = +[NSArray arrayWithObjects:&v62 count:1];
    v60[0] = @"plan-category";
    v60[1] = @"plan-group-options";
    v61[0] = &off_101AE6358;
    v61[1] = v21;
    char v35 = (void *)v21;
    unsigned int v22 = +[NSDictionary dictionaryWithObjects:v61 forKeys:v60 count:2];
    v58[0] = @"plan-id";
    v58[1] = @"plan-label";
    v59[0] = @"ABC123INTL1";
    v59[1] = @"International Roaming 2GB";
    v58[2] = @"plan-value";
    v58[3] = @"plan-subscribed";
    v59[2] = @"USD40";
    v59[3] = @"subscribed";
    v58[4] = @"plan-purchasable";
    v59[4] = &__kCFBooleanFalse;
    __int16 v23 = +[NSDictionary dictionaryWithObjects:v59 forKeys:v58 count:5];
    long long v57 = v23;
    int v24 = +[NSArray arrayWithObjects:&v57 count:1];
    v55[0] = @"plan-category";
    v55[1] = @"plan-group-options";
    v56[0] = &off_101AE6370;
    v56[1] = v24;
    uint64_t v25 = +[NSDictionary dictionaryWithObjects:v56 forKeys:v55 count:2];
    v54[0] = v22;
    v54[1] = v25;
    char v26 = +[NSArray arrayWithObjects:v54 count:2];
    CFStringRef v52 = @"plans-list";
    char v53 = v26;
    long long v27 = +[NSDictionary dictionaryWithObjects:&v53 forKeys:&v52 count:1];
    v50[0] = @"response-id";
    v50[1] = @"status";
    v51[0] = &off_101AE6358;
    v51[1] = &off_101AE6388;
    v50[2] = @"network-usage";
    v50[3] = @"carrier-plans";
    v51[2] = v37;
    v51[3] = v27;
    long long v28 = +[NSDictionary dictionaryWithObjects:v51 forKeys:v50 count:4];

    [v4 setObject:v43 forKeyedSubscript:v39];
    [v4 setObject:v47 forKeyedSubscript:v40];
    __int16 v48 = v4;
    if (v4) {
      CFRetain(v4);
    }
    DevicePersistentSaveValue();
    sub_1000577C4(&v48);
    sub_10004EFAC(a1, v28);

    long long v29 = (void *)v42;
  }
  else
  {
    long long v30 = *(NSObject **)(a2 + 40);
    long long v29 = (void *)v42;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "data units and capacity not available to generate getCarrierSpaceUpdatesResult", buf, 2u);
    }
    *a1 = 0;
  }
}

void sub_1003B0050(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1003B0244(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I startPeriodicDataUsageUpdate_sync", buf, 2u);
  }
  CFDictionaryRef theDict = 0;
  DevicePersistentCopyValue((uint64_t *)buf, @"kCarrierSpaceTestModeConfigurationCacheKey", 0);
  sub_10004EFE4(&theDict, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  if (theDict) {
    int v3 = sub_100080778;
  }
  else {
    int v3 = 0;
  }
  if (v3 && !CFDictionaryContainsKey(theDict, kCTCarrierSpaceTestConfigJSONKey))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (v4 && ((*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4) & 1) == 0)
    {
      int v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Test Mode Auto update timer is already running", buf, 2u);
      }
    }
    else
    {
      *(void *)long long buf = 0;
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      char v5 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v5 || (uint64_t v6 = *(void *)(a1 + 8), (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v8 = v7;
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v7);
      __int16 v9 = operator new(0x20uLL);
      void *v9 = off_1019C41C0;
      v9[1] = a1;
      void v9[2] = v6;
      uint64_t v9[3] = v8;
      uint64_t v25 = v9;
      Registry::getTimerService(&v18, *(Registry **)(a1 + 48));
      uint64_t v10 = v18;
      sub_100058DB0(__p, "CarrierSpace TestMode update timer");
      sub_1003B0CB8(v10, (uint64_t)__p, 1, 1800000000, (uint64_t)buf);
      uint64_t v11 = v20;
      uint64_t v20 = 0;
      uint64_t v12 = *(void *)(a1 + 88);
      *(void *)(a1 + 88) = v11;
      if (v12)
      {
        (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
        uint64_t v13 = v20;
        uint64_t v20 = 0;
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
      }
      if (v17 < 0) {
        operator delete(__p[0]);
      }
      if (v19) {
        sub_10004D2C8(v19);
      }
      sub_10003B34C(buf);
    }
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_1003B04E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, const void *a19, uint64_t a20)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  sub_10003B34C(&a20);
  sub_100057D78(&a19);
  _Unwind_Resume(a1);
}

void sub_1003B0560(uint64_t a1, uint64_t a2, const void **a3, int a4)
{
  int v25 = a4;
  if (*a3) {
    uint64_t v4 = sub_100080778;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    BOOL v7 = (std::__shared_weak_count *)operator new(0x20uLL);
    v7->__shared_owners_ = 0;
    v7->__shared_weak_owners_ = 0;
    v7->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4240;
    uint64_t v24 = v7;
    v7[1].__vftable = 0;
    uint64_t v23 = v7 + 1;
    sub_100058140((const void **)&v7[1].__vftable, a3);
    uint64_t v21 = 0;
    unsigned int v22 = 0;
    sub_1003B1590(&v25, (uint64_t *)&v23, &v21);
    uint64_t v8 = *(std::__shared_weak_count **)(a1 + 56);
    uint64_t v18 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    PersonalityIdFromSlotId();
    uint64_t v10 = v21;
    __int16 v9 = v22;
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (SHIBYTE(v20) < 0)
    {
      sub_10004FC84(__dst, v19[0], (unint64_t)v19[1]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v19;
      uint64_t v27 = v20;
    }
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v43 = 0;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    *(_OWORD *)CFDictionaryRef v31 = 0u;
    long long v32 = 0u;
    memset(v30, 0, sizeof(v30));
    sub_10004DE24((uint64_t)v30);
    uint64_t v11 = (void *)HIBYTE(v27);
    if (v27 < 0) {
      uint64_t v11 = __dst[1];
    }
    uint64_t v12 = __dst;
    if (v27 < 0) {
      uint64_t v12 = (void **)__dst[0];
    }
    if (v11) {
      uint64_t v13 = (const char *)v12;
    }
    else {
      uint64_t v13 = "<invalid>";
    }
    size_t v14 = strlen(v13);
    int v15 = sub_10004B96C(v30, (uint64_t)v13, v14);
    CFDictionaryRef v16 = sub_10004B96C(v15, (uint64_t)", ", 2);
    char v17 = sub_10004B96C(v16, (uint64_t)"Complete", 8);
    sub_10004B96C(v17, (uint64_t)", ", 2);
    std::ostream::operator<<();
    sub_10004BC98((uint64_t)v30 + 8, __p);
    sub_1001AA668(&qword_101B14128, (uint64_t *)__p);
    if (v29 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v32) < 0) {
      operator delete(v31[1]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
    if (v9) {
      sub_10004D2C8(v9);
    }
    if (SHIBYTE(v27) < 0) {
      operator delete(__dst[0]);
    }
    *(void *)&v30[0] = v10;
    *((void *)&v30[0] + 1) = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1001C5340((uint64_t)&event::entitlements::get_carrier_space_updates_result, (uint64_t)v19, 3, (uint64_t *)v30);
    if (*((void *)&v30[0] + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v30[0] + 1));
    }
    if (v9) {
      sub_10004D2C8(v9);
    }
    if (SHIBYTE(v20) < 0) {
      operator delete(v19[0]);
    }
    if (v18) {
      sub_10004D2C8(v18);
    }
    if (v22) {
      sub_10004D2C8(v22);
    }
    if (v24) {
      sub_10004D2C8(v24);
    }
  }
}

void sub_1003B08E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32)
{
  if (v32) {
    sub_10004D2C8(v32);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (a20) {
    sub_10004D2C8(a20);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1003B0988(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 80))
  {
    int v2 = 1;
  }
  else
  {
    int v2 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(unsigned char *)(a1 + 80) = v2;
  }
  int v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "true";
    if (!v2) {
      uint64_t v4 = "false";
    }
    int v6 = 136315138;
    BOOL v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Test mode is enabled : %s", (uint8_t *)&v6, 0xCu);
    int v2 = *(unsigned __int8 *)(a1 + 80);
  }
  return v2 != 0;
}

BOOL sub_1003B0A90(uint64_t a1)
{
  uint64_t v8 = 0;
  DevicePersistentCopyValue((uint64_t *)buf, @"kCarrierSpaceTestModeConfigurationCacheKey", 0);
  sub_10004EFE4(&v8, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (v8) {
      int v3 = sub_100080778;
    }
    else {
      int v3 = 0;
    }
    if (v3) {
      uint64_t v4 = "available";
    }
    else {
      uint64_t v4 = "not available";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Test mode config is %s", buf, 0xCu);
  }
  if (v8) {
    char v5 = sub_100080778;
  }
  else {
    char v5 = 0;
  }
  BOOL v6 = v5 != 0;
  sub_100057D78(&v8);
  return v6;
}

void sub_1003B0BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1003B0BD8(uint64_t a1)
{
  unsigned int v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1003B0CB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = a3;
  uint64_t v11 = a4;
  ctu::TimerService::throwIfPeriodIsZero();
  *(_OWORD *)std::string __p = *(_OWORD *)a2;
  uint64_t v9 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  sub_1000F0058((uint64_t)v12, a5);
  (*(void (**)(uint64_t, void **, uint64_t, uint64_t, void, void *))(*(void *)a1 + 48))(a1, __p, v10, v11, 0, v12);
  sub_10003B34C(v12);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1003B0DC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1003B0DF4(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  int v3 = ServiceMap;
  if (v4 < 0)
  {
    char v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (!v8)
  {
    std::mutex::unlock(v3);
    return;
  }
  uint64_t v10 = v8[3];
  uint64_t v9 = (std::__shared_weak_count *)v8[4];
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v3);
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v9);
    if (!v10)
    {
LABEL_26:
      sub_10004D2C8(v9);
      return;
    }
  }
  else
  {
    std::mutex::unlock(v3);
    if (!v10) {
      return;
    }
  }
  CFTypeRef cf = 0;
  DevicePersistentCopyValue((uint64_t *)buf, @"kCarrierSpaceTestModeConfigurationCacheKey", 0);
  sub_10004EFE4(&cf, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  if (cf) {
    uint64_t v11 = sub_100080778;
  }
  else {
    uint64_t v11 = 0;
  }
  if (v11 && (id v12 = [(id)cf mutableCopy], (v13 = v12) != 0))
  {
    size_t v14 = [v12 objectForKeyedSubscript:kCTCarrierSpaceTestConfigDataUnitsKey];
    if (v14)
    {
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v10 + 72))(v10, &v24, &v23);
      int v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v24;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I updated dataUsed %lld", buf, 0xCu);
      }
      sub_100961AFC(v14);
      CTCarrierSpaceConvertDataUnits();
      char v17 = +[NSString stringWithFormat:@"%lf", v16];
      [v13 setObject:v17 forKeyedSubscript:kCTCarrierSpaceTestConfigDataUsedKey];
      *(void *)long long buf = v13;
      sub_100282490(&cf, (CFTypeRef *)buf);
      *(void *)long long buf = 0;
      uint64_t v18 = (void *)cf;
      CFTypeRef v22 = cf;
      if (cf) {
        CFRetain(cf);
      }
      sub_1003AF760(buf, a1, v18);
      sub_100057D78(&v22);
      uint64_t v21 = *(const void **)buf;
      if (*(void *)buf) {
        CFRetain(*(CFTypeRef *)buf);
      }
      sub_1003B0560(a1, 1, &v21, 6000);
      sub_100057D78(&v21);
      sub_100057D78((const void **)buf);
    }
    else
    {
      uint64_t v20 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I data units are not available, bailing out from updating data usage", buf, 2u);
      }
    }

    sub_100057D78(&cf);
    if (v9) {
      goto LABEL_26;
    }
  }
  else
  {
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I config not available, bailing out from updating data usage", buf, 2u);
    }
    sub_100057D78(&cf);
    if (v9) {
      goto LABEL_26;
    }
  }
}

void sub_1003B116C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, char a17, int a18, __int16 a19, char a20,char a21)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003B1240(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1003B130C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1003B13E4);
  __cxa_rethrow();
}

void sub_1003B1334(_Unwind_Exception *a1)
{
}

void sub_1003B134C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1003B1384(uint64_t a1)
{
}

uint64_t sub_1003B13A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1003B13E4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1003B1410(uint64_t **a1)
{
  int v3 = a1;
  uint64_t v1 = **a1;
  char v5 = 0;
  DevicePersistentCopyValue((uint64_t *)&v4, @"kCarrierSpaceTestModeConfigurationCacheKey", 0);
  sub_10004EFE4(&v5, &v4);
  sub_1000577C4(&v4);
  if (v5) {
    int v2 = sub_100080778;
  }
  else {
    int v2 = 0;
  }
  if (v2)
  {
    sub_1003B0244(v1);
    sub_1003B0DF4(v1);
  }
  sub_100057D78(&v5);
  operator delete();
}

void sub_1003B14C4(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  operator delete();
}

void sub_1003B1510(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4240;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1003B1530(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4240;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

const void **sub_1003B1584(uint64_t a1)
{
  return sub_100057D78((const void **)(a1 + 24));
}

void *sub_1003B1590@<X0>(int *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x30uLL);
  uint64_t result = sub_1003B15F4(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1003B15E0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1003B15F4(void *a1, int *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019C4290;
  sub_1003B16D8((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_1003B163C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1003B1650(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4290;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1003B1670(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4290;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1003B16C4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_1003B16D8(uint64_t a1, int *a2, uint64_t *a3)
{
  int v4 = *a2;
  uint64_t v6 = *a3;
  char v5 = (std::__shared_weak_count *)a3[1];
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    *(_DWORD *)a1 = v4;
    *(void *)(a1 + 8) = v6;
    *(void *)(a1 + 16) = v5;
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v5);
  }
  else
  {
    *(_DWORD *)a1 = v4;
    *(void *)(a1 + 8) = v6;
    *(void *)(a1 + 16) = 0;
  }
  return a1;
}

void *sub_1003B1730(void *a1)
{
  *a1 = off_1019C41C0;
  int v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1003B177C(void *a1)
{
  *a1 = off_1019C41C0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1003B17E8(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019C41C0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1003B184C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019C41C0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1003B188C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1003B189C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1003B18DC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        char v5 = *(std::__shared_weak_count **)(v4 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_1003B19EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003B1A2C()
{
}

void sub_1003B1A38(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Carrier space test mode auto update timer has fired", buf, 2u);
  }
  sub_1003B0DF4(v1);
  operator delete();
}

void sub_1003B1AD4()
{
}

void sub_1003B1B00()
{
}

void sub_1003B1B28(void *a1@<X8>)
{
  if (qword_101B0CD60[0] != -1) {
    dispatch_once(qword_101B0CD60, &stru_1019C4318);
  }
  if (byte_101B0CD58)
  {
    uint64_t v2 = operator new(0x28uLL);
    v2[1] = 0;
    void v2[2] = 0;
    void *v2 = off_1019C4348;
    v2[3] = off_1019C42E0;
    void v2[4] = 0;
    id v3 = objc_alloc_init((Class)NPSManager);
    operator new();
  }
  *a1 = 0;
  a1[1] = 0;
}

void sub_1003B1C24(_Unwind_Exception *a1)
{
  NanoPreferencesSyncInterface::~NanoPreferencesSyncInterface(v2);
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v5);
  _Unwind_Resume(a1);
}

void sub_1003B1C50(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = +[NSMutableSet setWithCapacity:(uint64_t)(a3[1] - *a3) >> 3];
  uint64_t v8 = (void *)*a3;
  unsigned int v7 = (void *)a3[1];
  for (i = v6; v8 != v7; uint64_t v6 = i)
    [v6 addObject:*v8++];
  [**(id **)(a1 + 8) synchronizeUserDefaultsDomain:a2 keys:v6];
}

void sub_1003B1CFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1003B1D14(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = +[NSMutableSet setWithCapacity:(uint64_t)(a3[1] - *a3) >> 3];
  uint64_t v8 = (void *)*a3;
  unsigned int v7 = (void *)a3[1];
  for (i = v6; v8 != v7; uint64_t v6 = i)
    [v6 addObject:*v8++];
  [**(id **)(a1 + 8) synchronizeNanoDomain:a2 keys:v6];
}

void sub_1003B1DC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1003B1DD8(id **a1)
{
  *a1 = (id *)off_1019C42E0;
  sub_1003B1ED8(a1 + 1);

  NanoPreferencesSyncInterface::~NanoPreferencesSyncInterface((NanoPreferencesSyncInterface *)a1);
}

void sub_1003B1E2C(id **a1)
{
  *a1 = (id *)off_1019C42E0;
  sub_1003B1ED8(a1 + 1);
  NanoPreferencesSyncInterface::~NanoPreferencesSyncInterface((NanoPreferencesSyncInterface *)a1);

  operator delete();
}

void sub_1003B1E94(id a1)
{
  uint64_t v1 = NSClassFromString(@"NPSManager");
  byte_101B0CD58 = v1 != 0;
}

id **sub_1003B1ED8(id **result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {

    operator delete();
  }
  return result;
}

void sub_1003B1F38(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4348;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1003B1F58(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4348;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1003B1FAC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1003B1FD4(id **a1)
{
  *a1 = (id *)off_1019C42E0;
  sub_1003B1ED8(a1 + 1);

  NanoPreferencesSyncInterface::~NanoPreferencesSyncInterface((NanoPreferencesSyncInterface *)a1);
}

void sub_1003B2028(id **a1)
{
  *a1 = (id *)off_1019C42E0;
  sub_1003B1ED8(a1 + 1);
  NanoPreferencesSyncInterface::~NanoPreferencesSyncInterface((NanoPreferencesSyncInterface *)a1);

  operator delete();
}

void sub_1003B2090(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1003B211C(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  uint64_t v8 = a2;
  id v7 = (id)objc_opt_new();
  uint64_t v9 = &kPhoneServicesActiveKey;
  objc_msgSend(v7, "setIsWifiCallingAvailable:", *((_DWORD *)sub_1003B2574(a3, &kPhoneServicesActiveKey, (uint64_t)&unk_10144E20E, &v9) + 10) != 0);
  uint64_t v9 = &kPhoneServicesVoLTECallingAvailableKey;
  objc_msgSend(v7, "setIsVoLTECallingAvailable:", *((_DWORD *)sub_1003B2574(a3, &kPhoneServicesVoLTECallingAvailableKey, (uint64_t)&unk_10144E20E, &v9) + 10) != 0);
  uint64_t v9 = &kPhoneServicesCSCallingAvailableKey;
  objc_msgSend(v7, "setIsCSCallingAvailable:", *((_DWORD *)sub_1003B2574(a3, &kPhoneServicesCSCallingAvailableKey, (uint64_t)&unk_10144E20E, &v9) + 10) != 0);
  uint64_t v9 = &kIsEmergencyWiFiAllowed;
  objc_msgSend(v7, "setIsEmergencyCallingOnWifiAllowed:", *((_DWORD *)sub_1003B2574(a3, &kIsEmergencyWiFiAllowed, (uint64_t)&unk_10144E20E, &v9) + 10) != 0);
  uint64_t v9 = &kIsEmergencyWiFiCallCapable;
  objc_msgSend(v7, "setIsEmergencyCallingOnWifiAvailable:", *((_DWORD *)sub_1003B2574(a3, &kIsEmergencyWiFiCallCapable, (uint64_t)&unk_10144E20E, &v9) + 10) != 0);
  uint64_t v9 = &kIsEmergencyWiFiNoLimit;
  objc_msgSend(v7, "setIsCarrierSupportsEmergencyCallOnWifiNoLimit:", *((_DWORD *)sub_1003B2574(a3, &kIsEmergencyWiFiNoLimit, (uint64_t)&unk_10144E20E, &v9) + 10) != 0);
  char v5 = *(void ***)(a1 + 8);
  v10[0] = off_1019C4528;
  v10[1] = &v8;
  uint64_t v10[2] = &v7;
  void v10[3] = v10;
  sub_100043ED0((uint64_t)v10, *v5);
  sub_100043E48(v10);
}

void sub_1003B2340(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100043E48((uint64_t *)va);

  _Unwind_Resume(a1);
}

void *sub_1003B236C(void *a1)
{
  *a1 = off_1019C4470;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1003B23B8(void *a1)
{
  *a1 = off_1019C4470;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_1003B2424(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1003B248C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003B24C8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1003B2500(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1003B2530(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t **sub_1003B2574(uint64_t **a1, unint64_t *a2, uint64_t a3, void **a4)
{
  id v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        id v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        id v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x30uLL);
    void v11[4] = **a4;
    *((_DWORD *)v11 + 10) = 0;
    sub_100046C38(a1, (uint64_t)v9, v7, v11);
    return (uint64_t **)v11;
  }
  return v9;
}

void sub_1003B263C()
{
}

__n128 sub_1003B2650(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019C4528;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1003B269C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C4528;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1003B26CC(uint64_t a1, id *a2)
{
  id v4 = *a2;
  id v3 = +[CTXPCPlaceholder cfUuid:**(void **)(a1 + 8)];
  [v4 callCapabilitiesChanged:v3 capabilities:**(void **)(a1 + 16)];
}

void sub_1003B2748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1003B2768(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003B27A8()
{
}

uint64_t sub_1003B27B4(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100054998((void *)a1, 0, a1, 0x16u, (void *)a2);
  if (result)
  {
    if (*(void *)(a1 + 24) != *(void *)(a2 + 24)) {
      return 0;
    }
    char v5 = *(void **)(a1 + 8);
    if (v5 != (void *)(a1 + 16))
    {
      uint64_t v6 = *(void **)(a2 + 8);
      do
      {
        BOOL v7 = *((_DWORD *)v5 + 7) == *((_DWORD *)v6 + 7) && *((_DWORD *)v5 + 8) == *((_DWORD *)v6 + 8);
        if (!v7) {
          return 0;
        }
        unint64_t v8 = (void *)v5[1];
        uint64_t v9 = v5;
        if (v8)
        {
          do
          {
            char v5 = v8;
            unint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            char v5 = (void *)v9[2];
            BOOL v7 = *v5 == (void)v9;
            uint64_t v9 = v5;
          }
          while (!v7);
        }
        unint64_t v10 = (void *)v6[1];
        if (v10)
        {
          do
          {
            uint64_t v11 = v10;
            unint64_t v10 = (void *)*v10;
          }
          while (v10);
        }
        else
        {
          do
          {
            uint64_t v11 = (void *)v6[2];
            BOOL v7 = *v11 == (void)v6;
            uint64_t v6 = v11;
          }
          while (!v7);
        }
        uint64_t v6 = v11;
      }
      while (v5 != (void *)(a1 + 16));
    }
    if (*(void *)(a1 + 48) != *(void *)(a2 + 48)) {
      return 0;
    }
    id v12 = *(void **)(a1 + 32);
    if (v12 != (void *)(a1 + 40))
    {
      uint64_t v13 = *(void **)(a2 + 32);
      while (*((_DWORD *)v12 + 8) == *((_DWORD *)v13 + 8))
      {
        uint64_t result = sub_100CF14C8((uint64_t)(v12 + 5), (uint64_t)(v13 + 5));
        if (!result) {
          return result;
        }
        size_t v14 = (void *)v12[1];
        int v15 = v12;
        if (v14)
        {
          do
          {
            id v12 = v14;
            size_t v14 = (void *)*v14;
          }
          while (v14);
        }
        else
        {
          do
          {
            id v12 = (void *)v15[2];
            BOOL v7 = *v12 == (void)v15;
            int v15 = v12;
          }
          while (!v7);
        }
        uint64_t v16 = (void *)v13[1];
        if (v16)
        {
          do
          {
            char v17 = v16;
            uint64_t v16 = (void *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            char v17 = (void *)v13[2];
            BOOL v7 = *v17 == (void)v13;
            uint64_t v13 = v17;
          }
          while (!v7);
        }
        uint64_t v13 = v17;
        if (v12 == (void *)(a1 + 40)) {
          goto LABEL_37;
        }
      }
      return 0;
    }
LABEL_37:
    if (*(void *)(a1 + 72) != *(void *)(a2 + 72)) {
      return 0;
    }
    uint64_t v18 = *(void **)(a1 + 56);
    if (v18 != (void *)(a1 + 64))
    {
      uint64_t v19 = *(void **)(a2 + 56);
      while (*((_DWORD *)v18 + 7) == *((_DWORD *)v19 + 7) && *((_DWORD *)v18 + 8) == *((_DWORD *)v19 + 8))
      {
        uint64_t v21 = (void *)v18[1];
        CFTypeRef v22 = v18;
        if (v21)
        {
          do
          {
            uint64_t v18 = v21;
            uint64_t v21 = (void *)*v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            uint64_t v18 = (void *)v22[2];
            BOOL v7 = *v18 == (void)v22;
            CFTypeRef v22 = v18;
          }
          while (!v7);
        }
        uint64_t v23 = (void *)v19[1];
        if (v23)
        {
          do
          {
            uint64_t v24 = v23;
            uint64_t v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            uint64_t v24 = (void *)v19[2];
            BOOL v7 = *v24 == (void)v19;
            uint64_t v19 = v24;
          }
          while (!v7);
        }
        uint64_t v19 = v24;
        if (v18 == (void *)(a1 + 64)) {
          goto LABEL_56;
        }
      }
      return 0;
    }
LABEL_56:
    uint64_t result = sub_100054998((void *)(a1 + 80), 0, a1 + 80, 0xDu, (void *)(a2 + 80));
    if (result) {
      return *(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a2 + 88);
    }
  }
  return result;
}

uint64_t sub_1003B2A30@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v69 = 0;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v58 = 0u;
  memset(v56, 0, sizeof(v56));
  long long v55 = 0u;
  sub_10004BD84((uint64_t)&v55);
  id v4 = sub_10004B96C(v56, (uint64_t)"supported:[", 11);
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  char v5 = std::locale::use_facet(&v71, &std::ctype<char>::id);
  unsigned __int8 v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 48);
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  BOOL v7 = std::locale::use_facet(&v70, &std::ctype<char>::id);
  char v8 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 49);
  uint64_t v9 = 0;
  uint64_t v72 = 0x101010101010101 * v6;
  *(void *)long long v73 = v72;
  *(void *)&v73[6] = v72;
  __int16 v74 = 5632;
  uint64_t v10 = 21;
  do
  {
    if ((*(void *)a1 >> v9))
    {
      if (v74 >= 0) {
        uint64_t v11 = &v72;
      }
      else {
        uint64_t v11 = (uint64_t *)v72;
      }
      *((unsigned char *)v11 + v10) = v8;
    }
    ++v9;
    --v10;
  }
  while (v9 != 22);
  if (v74 >= 0) {
    id v12 = &v72;
  }
  else {
    id v12 = (uint64_t *)v72;
  }
  if (v74 >= 0) {
    uint64_t v13 = HIBYTE(v74);
  }
  else {
    uint64_t v13 = *(void *)v73;
  }
  size_t v14 = sub_10004B96C(v4, (uint64_t)v12, v13);
  if (SHIBYTE(v74) < 0) {
    operator delete((void *)v72);
  }
  std::locale::~locale(&v70);
  std::locale::~locale(&v71);
  sub_10004B96C(v14, (uint64_t)"], states:[", 11);
  unsigned int v54 = a2;
  int v15 = *(void **)(a1 + 8);
  if (v15 != (void *)(a1 + 16))
  {
    char v16 = 1;
    do
    {
      if ((v16 & 1) == 0) {
        sub_10004B96C(v56, (uint64_t)", ", 2);
      }
      char v17 = sub_100059954(*((_DWORD *)v15 + 7));
      size_t v18 = strlen(v17);
      uint64_t v19 = sub_10004B96C(v56, (uint64_t)v17, v18);
      uint64_t v20 = sub_10004B96C(v19, (uint64_t)":", 1);
      unsigned int v21 = *((_DWORD *)v15 + 8) - 1;
      CFTypeRef v22 = "???";
      if (v21 <= 5) {
        CFTypeRef v22 = off_1019C45E8[v21];
      }
      size_t v23 = strlen(v22);
      sub_10004B96C(v20, (uint64_t)v22, v23);
      uint64_t v24 = (void *)v15[1];
      if (v24)
      {
        do
        {
          int v25 = v24;
          uint64_t v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          int v25 = (void *)v15[2];
          BOOL v26 = *v25 == (void)v15;
          int v15 = v25;
        }
        while (!v26);
      }
      char v16 = 0;
      int v15 = v25;
    }
    while (v25 != (void *)(a1 + 16));
  }
  sub_10004B96C(v56, (uint64_t)"]", 1);
  if (*(void *)(a1 + 48))
  {
    sub_10004B96C(v56, (uint64_t)", details:[", 11);
    uint64_t v27 = *(void **)(a1 + 32);
    if (v27 != (void *)(a1 + 40))
    {
      char v28 = 1;
      do
      {
        if ((v28 & 1) == 0) {
          sub_10004B96C(v56, (uint64_t)", ", 2);
        }
        char v29 = sub_100059954(*((_DWORD *)v27 + 8));
        size_t v30 = strlen(v29);
        CFDictionaryRef v31 = sub_10004B96C(v56, (uint64_t)v29, v30);
        long long v32 = sub_10004B96C(v31, (uint64_t)": ", 2);
        sub_100CF0BCC(v27 + 5, &v72);
        if (v74 >= 0) {
          long long v33 = &v72;
        }
        else {
          long long v33 = (uint64_t *)v72;
        }
        if (v74 >= 0) {
          uint64_t v34 = HIBYTE(v74);
        }
        else {
          uint64_t v34 = *(void *)v73;
        }
        sub_10004B96C(v32, (uint64_t)v33, v34);
        if (SHIBYTE(v74) < 0) {
          operator delete((void *)v72);
        }
        long long v35 = (void *)v27[1];
        if (v35)
        {
          do
          {
            long long v36 = v35;
            long long v35 = (void *)*v35;
          }
          while (v35);
        }
        else
        {
          do
          {
            long long v36 = (void *)v27[2];
            BOOL v26 = *v36 == (void)v27;
            uint64_t v27 = v36;
          }
          while (!v26);
        }
        char v28 = 0;
        uint64_t v27 = v36;
      }
      while (v36 != (void *)(a1 + 40));
    }
    sub_10004B96C(v56, (uint64_t)"]", 1);
  }
  sub_10004B96C(v56, (uint64_t)", latest:[", 10);
  long long v37 = *(void **)(a1 + 56);
  if (v37 != (void *)(a1 + 64))
  {
    char v38 = 1;
    do
    {
      if ((v38 & 1) == 0) {
        sub_10004B96C(v56, (uint64_t)", ", 2);
      }
      long long v39 = sub_100059954(*((_DWORD *)v37 + 7));
      size_t v40 = strlen(v39);
      long long v41 = sub_10004B96C(v56, (uint64_t)v39, v40);
      long long v42 = sub_10004B96C(v41, (uint64_t)":", 1);
      unsigned int v43 = *((_DWORD *)v37 + 8) - 1;
      id v44 = "???";
      if (v43 <= 5) {
        id v44 = off_1019C45E8[v43];
      }
      size_t v45 = strlen(v44);
      sub_10004B96C(v42, (uint64_t)v44, v45);
      uint64_t v46 = (void *)v37[1];
      if (v46)
      {
        do
        {
          unint64_t v47 = v46;
          uint64_t v46 = (void *)*v46;
        }
        while (v46);
      }
      else
      {
        do
        {
          unint64_t v47 = (void *)v37[2];
          BOOL v26 = *v47 == (void)v37;
          long long v37 = v47;
        }
        while (!v26);
      }
      char v38 = 0;
      long long v37 = v47;
    }
    while (v47 != (void *)(a1 + 64));
  }
  __int16 v48 = sub_10004B96C(v56, (uint64_t)"], tasks: ", 10);
  sub_1003B312C(v48, (void *)(a1 + 80));
  char v49 = sub_10004B96C(v56, (uint64_t)", blocked:", 10);
  if (*(unsigned char *)(a1 + 88)) {
    unsigned int v50 = "yes";
  }
  else {
    unsigned int v50 = "no";
  }
  if (*(unsigned char *)(a1 + 88)) {
    uint64_t v51 = 3;
  }
  else {
    uint64_t v51 = 2;
  }
  sub_10004B96C(v49, (uint64_t)v50, v51);
  sub_10004BC98((uint64_t)v56 + 8, v54);
  *(void *)((char *)&v56[-1]
  *(void *)&v56[0] = v52;
  if (SHIBYTE(v58) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1003B30B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if (*(char *)(v3 - 89) < 0) {
    operator delete(*(void **)(v3 - 112));
  }
  std::locale::~locale((std::locale *)(v3 - 128));
  std::locale::~locale((std::locale *)(v3 - 120));
  sub_10008248C((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_1003B312C(void *a1, void *a2)
{
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
  id v4 = std::locale::use_facet(&v16, &std::ctype<char>::id);
  unsigned __int8 v5 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v4->__vftable[2].~facet_0)(v4, 48);
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
  unsigned __int8 v6 = std::locale::use_facet(&v15, &std::ctype<char>::id);
  char v7 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 49);
  uint64_t v8 = 0;
  HIDWORD(__p) = 0;
  uint64_t v18 = 0xD00000000000000;
  *(void *)((char *)&__p + 5) = 0x101010101010101 * v5;
  *(void *)&long long __p = *(void *)((char *)&__p + 5);
  uint64_t v9 = 12;
  do
  {
    if ((*a2 >> v8))
    {
      if (v18 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = (long long *)__p;
      }
      *((unsigned char *)p_p + v9) = v7;
    }
    ++v8;
    --v9;
  }
  while (v8 != 13);
  if (v18 >= 0) {
    uint64_t v11 = &__p;
  }
  else {
    uint64_t v11 = (long long *)__p;
  }
  if (v18 >= 0) {
    uint64_t v12 = HIBYTE(v18);
  }
  else {
    uint64_t v12 = *((void *)&__p + 1);
  }
  uint64_t v13 = sub_10004B96C(a1, (uint64_t)v11, v12);
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)__p);
  }
  std::locale::~locale(&v15);
  std::locale::~locale(&v16);
  return v13;
}

void sub_1003B32BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, std::locale a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  std::locale::~locale(&a10);
  std::locale::~locale(&a11);
  _Unwind_Resume(a1);
}

uint64_t sub_1003B32FC(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  unsigned __int8 v6 = a2;
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0)
  {
    if (memcmp(*(const void **)a1, a2, *((void *)a1 + 1))) {
      return 0;
    }
  }
  else if (a1[23])
  {
    uint64_t v8 = a1;
    while (*v8 == *a2)
    {
      ++v8;
      ++a2;
      if (!--v2) {
        goto LABEL_16;
      }
    }
    return 0;
  }
LABEL_16:
  uint64_t v9 = a1[47];
  if ((v9 & 0x80u) == 0) {
    uint64_t v10 = a1[47];
  }
  else {
    uint64_t v10 = *((void *)a1 + 4);
  }
  uint64_t v11 = v6[47];
  int v12 = (char)v11;
  if ((v11 & 0x80u) != 0) {
    uint64_t v11 = *((void *)v6 + 4);
  }
  if (v10 != v11) {
    return 0;
  }
  uint64_t v13 = (const void **)(a1 + 24);
  std::locale v16 = (unsigned __int8 *)*((void *)v6 + 3);
  std::locale v15 = v6 + 24;
  size_t v14 = v16;
  if (v12 >= 0) {
    char v17 = v15;
  }
  else {
    char v17 = v14;
  }
  if ((v9 & 0x80) != 0) {
    return memcmp(*v13, v17, *((void *)a1 + 4)) == 0;
  }
  if (!a1[47]) {
    return 1;
  }
  uint64_t v18 = v9 - 1;
  do
  {
    int v20 = *(unsigned __int8 *)v13;
    uint64_t v13 = (const void **)((char *)v13 + 1);
    int v19 = v20;
    int v22 = *v17++;
    int v21 = v22;
    BOOL v24 = v18-- != 0;
    uint64_t result = v19 == v21;
  }
  while (v19 == v21 && v24);
  return result;
}

void sub_1003B3428(uint64_t a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v19 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v19 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v19 = v6;
LABEL_9:
  xpc_release(v5);
  if (*(char *)(a1 + 23) >= 0) {
    char v7 = (const char *)a1;
  }
  else {
    char v7 = *(const char **)a1;
  }
  xpc_object_t v17 = xpc_string_create(v7);
  if (!v17) {
    xpc_object_t v17 = xpc_null_create();
  }
  std::locale v15 = &v19;
  std::locale v16 = "imeiOrUuid";
  sub_100035E70((uint64_t)&v15, &v17, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v17);
  xpc_object_t v17 = 0;
  uint64_t v10 = *(const char **)(a1 + 24);
  uint64_t v9 = a1 + 24;
  uint64_t v8 = v10;
  if (*(char *)(v9 + 23) >= 0) {
    uint64_t v11 = (const char *)v9;
  }
  else {
    uint64_t v11 = v8;
  }
  xpc_object_t v13 = xpc_string_create(v11);
  if (!v13) {
    xpc_object_t v13 = xpc_null_create();
  }
  std::locale v15 = &v19;
  std::locale v16 = "uuid";
  sub_100035E70((uint64_t)&v15, &v13, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_object_t v12 = v19;
  *a2 = v19;
  if (v12) {
    xpc_retain(v12);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v19);
}

void sub_1003B35E0(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  xpc_object_t object = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    xpc_object_t v4 = object;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t object = v4;
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    p_xpc_object_t object = &object;
    char v7 = "imeiOrUuid";
    sub_100048BAC((uint64_t)&p_object, &v8);
    long long __p = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v14) < 0) {
      operator delete(__p);
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(_OWORD *)a1 = v10;
    *(void *)(a1 + 16) = v11;
    xpc_release(v8);
    p_xpc_object_t object = &object;
    char v7 = "uuid";
    sub_100048BAC((uint64_t)&p_object, &v8);
    long long __p = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v14) < 0) {
      operator delete(__p);
    }
    xpc_object_t v5 = (void **)(a1 + 24);
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*v5);
    }
    *(_OWORD *)xpc_object_t v5 = v10;
    *(void *)(a1 + 40) = v11;
    xpc_release(v8);
  }
  xpc_release(object);
}

void sub_1003B3748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  xpc_release(a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1003B37BC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v32 = 0;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v21 = 0u;
  memset(v19, 0, sizeof(v19));
  long long v18 = 0u;
  sub_10004BD84((uint64_t)&v18);
  xpc_object_t v4 = sub_10004B96C(v19, (uint64_t)"imeiOrUuid:", 11);
  int v5 = *(char *)(a1 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = *(void *)a1;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  xpc_object_t v8 = sub_10004B96C(v4, v6, v7);
  uint64_t v9 = sub_10004B96C(v8, (uint64_t)", uuid:", 7);
  uint64_t v12 = *(void *)(a1 + 24);
  uint64_t v11 = a1 + 24;
  uint64_t v10 = v12;
  int v13 = *(char *)(v11 + 23);
  if (v13 >= 0) {
    uint64_t v14 = v11;
  }
  else {
    uint64_t v14 = v10;
  }
  if (v13 >= 0) {
    uint64_t v15 = *(unsigned __int8 *)(v11 + 23);
  }
  else {
    uint64_t v15 = *(void *)(v11 + 8);
  }
  sub_10004B96C(v9, v14, v15);
  sub_10004BC98((uint64_t)v19 + 8, a2);
  *(void *)((char *)&v19[-1]
  *(void *)&v19[0] = v16;
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1003B39B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1003B39C8(uint64_t *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v73 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v73 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v73 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v73 = v6;
LABEL_9:
  xpc_release(v5);
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v8 = v7;
  if (v7)
  {
    object[0] = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    object[0] = v8;
    if (!v8)
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v8 = 0;
      goto LABEL_16;
    }
  }
  if (xpc_get_type(v8) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v9 = xpc_null_create();
LABEL_16:
    object[0] = v9;
    goto LABEL_17;
  }
  xpc_retain(v8);
LABEL_17:
  xpc_release(v8);
  xpc_object_t v86 = xpc_uint64_create(*a1);
  if (!v86) {
    xpc_object_t v86 = xpc_null_create();
  }
  *(void *)&long long value = object;
  *((void *)&value + 1) = "bitset";
  sub_100035E70((uint64_t)&value, &v86, v87);
  xpc_release(v87[0]);
  v87[0] = 0;
  xpc_release(v86);
  xpc_object_t v86 = 0;
  xpc_object_t v71 = object[0];
  if (object[0]) {
    xpc_retain(object[0]);
  }
  else {
    xpc_object_t v71 = xpc_null_create();
  }
  xpc_release(object[0]);
  *(void *)&long long value = &v73;
  *((void *)&value + 1) = "supported";
  sub_100035E70((uint64_t)&value, &v71, &v72);
  xpc_release(v72);
  xpc_object_t v72 = 0;
  xpc_release(v71);
  xpc_object_t v71 = 0;
  sub_1003B4874(&v69, a1 + 1);
  *(void *)&long long value = &v73;
  *((void *)&value + 1) = "states";
  sub_100035E70((uint64_t)&value, &v69, &v70);
  xpc_release(v70);
  xpc_object_t v70 = 0;
  xpc_release(v69);
  xpc_object_t v69 = 0;
  xpc_object_t v10 = xpc_array_create(0, 0);
  if (v10 || (xpc_object_t v10 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v10);
      xpc_object_t v11 = v10;
    }
    else
    {
      xpc_object_t v11 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v11 = xpc_null_create();
    xpc_object_t v10 = 0;
  }
  xpc_release(v10);
  uint64_t v12 = a1;
  int v13 = (uint64_t *)a1[4];
  unsigned int v54 = v12;
  long long v57 = (uint64_t **)(v12 + 5);
  if (v13 == v12 + 5) {
    goto LABEL_141;
  }
  long long v55 = a2;
  xpc_object_t v56 = v11;
  do
  {
    xpc_object_t v14 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v15 = v14;
    if (v14)
    {
      xpc_object_t v76 = v14;
    }
    else
    {
      xpc_object_t v15 = xpc_null_create();
      xpc_object_t v76 = v15;
      if (!v15)
      {
        xpc_object_t v16 = xpc_null_create();
        xpc_object_t v15 = 0;
        goto LABEL_37;
      }
    }
    if (xpc_get_type(v15) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v15);
      goto LABEL_38;
    }
    xpc_object_t v16 = xpc_null_create();
LABEL_37:
    xpc_object_t v76 = v16;
LABEL_38:
    xpc_release(v15);
    int v17 = *((_DWORD *)v13 + 8);
    long long v18 = sub_100059954(v17);
    ctu::rest::detail::write_enum_string_value((uint64_t *)&v74, (ctu::rest::detail *)v17, (uint64_t)v18, v19);
    *(void *)&long long value = &v76;
    *((void *)&value + 1) = "first";
    sub_100035E70((uint64_t)&value, &v74, &v75);
    xpc_release(v75);
    xpc_object_t v75 = 0;
    xpc_release(v74);
    xpc_object_t v74 = 0;
    xpc_object_t v77 = 0;
    xpc_object_t v20 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v21 = v20;
    if (v20)
    {
      xpc_object_t v77 = v20;
    }
    else
    {
      xpc_object_t v21 = xpc_null_create();
      xpc_object_t v77 = v21;
      if (!v21)
      {
        xpc_object_t v22 = xpc_null_create();
        xpc_object_t v21 = 0;
        goto LABEL_45;
      }
    }
    if (xpc_get_type(v21) != (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t v22 = xpc_null_create();
LABEL_45:
      xpc_object_t v77 = v22;
      goto LABEL_46;
    }
    xpc_retain(v21);
LABEL_46:
    xpc_release(v21);
    if (v13[6] == v13[5]) {
      goto LABEL_105;
    }
    xpc_object_t v23 = xpc_array_create(0, 0);
    if (v23 || (xpc_object_t v23 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v23) == (xpc_type_t)&_xpc_type_array)
      {
        xpc_retain(v23);
        xpc_object_t v24 = v23;
      }
      else
      {
        xpc_object_t v24 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v24 = xpc_null_create();
      xpc_object_t v23 = 0;
    }
    xpc_release(v23);
    long long v25 = (int *)v13[5];
    long long v26 = (int *)v13[6];
    while (v25 != v26)
    {
      object[0] = 0;
      xpc_object_t v27 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v28 = v27;
      if (v27)
      {
        object[0] = v27;
      }
      else
      {
        xpc_object_t v28 = xpc_null_create();
        object[0] = v28;
        if (!v28)
        {
          xpc_object_t v29 = xpc_null_create();
          xpc_object_t v28 = 0;
          goto LABEL_62;
        }
      }
      if (xpc_get_type(v28) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v28);
        goto LABEL_63;
      }
      xpc_object_t v29 = xpc_null_create();
LABEL_62:
      object[0] = v29;
LABEL_63:
      xpc_release(v28);
      if (*((unsigned char *)v25 + 4))
      {
        if (*v25) {
          long long v31 = "unmetered";
        }
        else {
          long long v31 = "metered";
        }
        ctu::rest::detail::write_enum_string_value((uint64_t *)&v86, (ctu::rest::detail *)*v25, (uint64_t)v31, v30);
        *(void *)&long long value = object;
        *((void *)&value + 1) = "type";
        sub_100035E70((uint64_t)&value, &v86, v87);
        xpc_release(v87[0]);
        v87[0] = 0;
        xpc_release(v86);
        xpc_object_t v86 = 0;
      }
      if (*((unsigned char *)v25 + 9))
      {
        xpc_object_t v84 = xpc_BOOL_create(*((unsigned char *)v25 + 8));
        if (!v84) {
          xpc_object_t v84 = xpc_null_create();
        }
        *(void *)&long long value = object;
        *((void *)&value + 1) = "experience";
        sub_100035E70((uint64_t)&value, &v84, &v85);
        xpc_release(v85);
        xpc_object_t v85 = 0;
        xpc_release(v84);
        xpc_object_t v84 = 0;
      }
      if (*((unsigned char *)v25 + 16))
      {
        xpc_object_t v82 = xpc_int64_create(v25[3]);
        if (!v82) {
          xpc_object_t v82 = xpc_null_create();
        }
        *(void *)&long long value = object;
        *((void *)&value + 1) = "volumeCapGb";
        sub_100035E70((uint64_t)&value, &v82, &v83);
        xpc_release(v83);
        xpc_object_t v83 = 0;
        xpc_release(v82);
        xpc_object_t v82 = 0;
      }
      if (*((unsigned char *)v25 + 48))
      {
        xpc_object_t v32 = xpc_array_create(0, 0);
        if (v32 || (xpc_object_t v32 = xpc_null_create()) != 0)
        {
          if (xpc_get_type(v32) == (xpc_type_t)&_xpc_type_array)
          {
            xpc_retain(v32);
            xpc_object_t v33 = v32;
          }
          else
          {
            xpc_object_t v33 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v33 = xpc_null_create();
          xpc_object_t v32 = 0;
        }
        xpc_release(v32);
        long long v35 = (int *)*((void *)v25 + 3);
        long long v36 = (int *)*((void *)v25 + 4);
        while (v35 != v36)
        {
          if (*v35) {
            long long v37 = "sub6";
          }
          else {
            long long v37 = "mmw";
          }
          ctu::rest::detail::write_enum_string_value((uint64_t *)&value, (ctu::rest::detail *)*v35, (uint64_t)v37, v34);
          xpc_array_append_value(v33, (xpc_object_t)value);
          xpc_release((xpc_object_t)value);
          ++v35;
        }
        xpc_object_t v80 = v33;
        if (v33) {
          xpc_retain(v33);
        }
        else {
          xpc_object_t v80 = xpc_null_create();
        }
        xpc_release(v33);
        *(void *)&long long value = object;
        *((void *)&value + 1) = "supportedRat";
        sub_100035E70((uint64_t)&value, &v80, &v81);
        xpc_release(v81);
        xpc_object_t v81 = 0;
        xpc_release(v80);
        xpc_object_t v80 = 0;
      }
      if (*((unsigned char *)v25 + 57))
      {
        xpc_object_t v78 = xpc_BOOL_create(*((unsigned char *)v25 + 56));
        if (!v78) {
          xpc_object_t v78 = xpc_null_create();
        }
        *(void *)&long long value = object;
        *((void *)&value + 1) = "saProvisioned";
        sub_100035E70((uint64_t)&value, &v78, &v79);
        xpc_release(v79);
        xpc_object_t v79 = 0;
        xpc_release(v78);
        xpc_object_t v78 = 0;
      }
      xpc_object_t v38 = object[0];
      if (object[0]) {
        xpc_retain(object[0]);
      }
      else {
        xpc_object_t v38 = xpc_null_create();
      }
      xpc_release(object[0]);
      xpc_array_append_value(v24, v38);
      xpc_release(v38);
      v25 += 16;
    }
    xpc_object_t v84 = v24;
    if (v24)
    {
      xpc_retain(v24);
      a2 = v55;
      xpc_object_t v11 = v56;
    }
    else
    {
      a2 = v55;
      xpc_object_t v11 = v56;
      xpc_object_t v84 = xpc_null_create();
    }
    xpc_release(v24);
    *(void *)&long long value = &v77;
    *((void *)&value + 1) = "planProperties";
    sub_100035E70((uint64_t)&value, &v84, &v85);
    xpc_release(v85);
    xpc_object_t v85 = 0;
    xpc_release(v84);
    xpc_object_t v84 = 0;
LABEL_105:
    uint64_t v39 = v13[8];
    if (v39)
    {
      xpc_object_t v40 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v41 = v40;
      if (v40)
      {
        object[0] = v40;
        goto LABEL_109;
      }
      xpc_object_t v41 = xpc_null_create();
      object[0] = v41;
      if (v41)
      {
LABEL_109:
        if (xpc_get_type(v41) != (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_object_t v42 = xpc_null_create();
          goto LABEL_113;
        }
        xpc_retain(v41);
      }
      else
      {
        xpc_object_t v42 = xpc_null_create();
        xpc_object_t v41 = 0;
LABEL_113:
        object[0] = v42;
      }
      xpc_release(v41);
      if (*(unsigned char *)(v39 + 24))
      {
        if (*(char *)(v39 + 23) >= 0) {
          unsigned int v43 = (const char *)v39;
        }
        else {
          unsigned int v43 = *(const char **)v39;
        }
        xpc_object_t v86 = xpc_string_create(v43);
        if (!v86) {
          xpc_object_t v86 = xpc_null_create();
        }
        *(void *)&long long value = object;
        *((void *)&value + 1) = "url";
        sub_100035E70((uint64_t)&value, &v86, v87);
        xpc_release(v87[0]);
        v87[0] = 0;
        xpc_release(v86);
        xpc_object_t v86 = 0;
      }
      xpc_object_t v83 = object[0];
      if (object[0]) {
        xpc_retain(object[0]);
      }
      else {
        xpc_object_t v83 = xpc_null_create();
      }
      xpc_release(object[0]);
      *(void *)&long long value = &v77;
      *((void *)&value + 1) = "altServer";
      sub_100035E70((uint64_t)&value, &v83, object);
      xpc_release(object[0]);
      object[0] = 0;
      xpc_release(v83);
      xpc_object_t v83 = 0;
    }
    if (*((unsigned char *)v13 + 81))
    {
      xpc_object_t v86 = xpc_BOOL_create(*((unsigned char *)v13 + 80));
      if (!v86) {
        xpc_object_t v86 = xpc_null_create();
      }
      *(void *)&long long value = &v77;
      *((void *)&value + 1) = "isPrimary";
      sub_100035E70((uint64_t)&value, &v86, v87);
      xpc_release(v87[0]);
      v87[0] = 0;
      xpc_release(v86);
      xpc_object_t v86 = 0;
    }
    xpc_object_t v82 = v77;
    if (v77) {
      xpc_retain(v77);
    }
    else {
      xpc_object_t v82 = xpc_null_create();
    }
    xpc_release(v77);
    *(void *)&long long value = &v76;
    *((void *)&value + 1) = "second";
    sub_100035E70((uint64_t)&value, &v82, object);
    xpc_release(object[0]);
    object[0] = 0;
    xpc_release(v82);
    xpc_object_t v82 = 0;
    xpc_object_t v44 = v76;
    if (v76) {
      xpc_retain(v76);
    }
    else {
      xpc_object_t v44 = xpc_null_create();
    }
    xpc_release(v76);
    xpc_array_append_value(v11, v44);
    xpc_release(v44);
    size_t v45 = (uint64_t *)v13[1];
    if (v45)
    {
      do
      {
        uint64_t v46 = (uint64_t **)v45;
        size_t v45 = (uint64_t *)*v45;
      }
      while (v45);
    }
    else
    {
      do
      {
        uint64_t v46 = (uint64_t **)v13[2];
        BOOL v47 = *v46 == v13;
        int v13 = (uint64_t *)v46;
      }
      while (!v47);
    }
    int v13 = (uint64_t *)v46;
  }
  while (v46 != v57);
LABEL_141:
  xpc_object_t v67 = v11;
  if (v11)
  {
    xpc_retain(v11);
    __int16 v48 = v54;
  }
  else
  {
    __int16 v48 = v54;
    xpc_object_t v67 = xpc_null_create();
  }
  xpc_release(v11);
  *(void *)&long long value = &v73;
  *((void *)&value + 1) = "details";
  sub_100035E70((uint64_t)&value, &v67, &v68);
  xpc_release(v68);
  xpc_object_t v68 = 0;
  xpc_release(v67);
  xpc_object_t v67 = 0;
  sub_1003B4874(&v65, v48 + 7);
  *(void *)&long long value = &v73;
  *((void *)&value + 1) = "latest_received";
  sub_100035E70((uint64_t)&value, &v65, &v66);
  xpc_release(v66);
  xpc_object_t v66 = 0;
  xpc_release(v65);
  uint64_t v49 = 0;
  xpc_object_t v65 = 0;
  BYTE13(value) = 0;
  HIWORD(value) = 0;
  uint64_t v62 = 0xD00000000000000;
  strcpy((char *)&value, "000000000000");
  uint64_t v50 = 12;
  do
  {
    if ((v48[10] >> v49))
    {
      if (v62 >= 0) {
        p_long long value = &value;
      }
      else {
        p_long long value = (long long *)value;
      }
      *((unsigned char *)p_value + v50) = 49;
    }
    ++v49;
    --v50;
  }
  while (v49 != 13);
  if (v62 >= 0) {
    xpc_object_t v52 = (const char *)&value;
  }
  else {
    xpc_object_t v52 = (const char *)value;
  }
  xpc_object_t v63 = xpc_string_create(v52);
  if (!v63) {
    xpc_object_t v63 = xpc_null_create();
  }
  object[0] = &v73;
  object[1] = "supported_tasks";
  sub_100035E70((uint64_t)object, &v63, &v64);
  xpc_release(v64);
  xpc_object_t v64 = 0;
  xpc_release(v63);
  xpc_object_t v63 = 0;
  if (SHIBYTE(v62) < 0) {
    operator delete((void *)value);
  }
  xpc_object_t v58 = xpc_BOOL_create(*((unsigned char *)v48 + 88));
  if (!v58) {
    xpc_object_t v58 = xpc_null_create();
  }
  *(void *)&long long value = &v73;
  *((void *)&value + 1) = "blocked";
  sub_100035E70((uint64_t)&value, &v58, &v59);
  xpc_release(v59);
  xpc_object_t v59 = 0;
  xpc_release(v58);
  xpc_object_t v58 = 0;
  xpc_object_t v53 = v73;
  *a2 = v73;
  if (v53) {
    xpc_retain(v53);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v73);
}

void sub_1003B4690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t a16, uint64_t a17, xpc_object_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,xpc_object_t object)
{
}

void sub_1003B4874(xpc_object_t *a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  xpc_object_t v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  xpc_object_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v28 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v28 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v28 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = sub_100059954(v11);
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v26, (ctu::rest::detail *)v11, (uint64_t)v12, v13);
      xpc_object_t v24 = &v28;
      long long v25 = "first";
      sub_100035E70((uint64_t)&v24, &v26, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v26);
      xpc_object_t v26 = 0;
      xpc_object_t v15 = (ctu::rest::detail *)*((unsigned int *)v6 + 8);
      xpc_object_t v16 = "???";
      if ((v15 - 1) <= 5) {
        xpc_object_t v16 = off_1019C45E8[(int)v15 - 1];
      }
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v22, v15, (unint64_t)v16, v14);
      xpc_object_t v24 = &v28;
      long long v25 = "second";
      sub_100035E70((uint64_t)&v24, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v17 = v28;
      if (v28) {
        xpc_retain(v28);
      }
      else {
        xpc_object_t v17 = xpc_null_create();
      }
      xpc_release(v28);
      xpc_array_append_value(v4, v17);
      xpc_release(v17);
      long long v18 = (void *)v6[1];
      if (v18)
      {
        do
        {
          xpc_object_t v19 = v18;
          long long v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          xpc_object_t v19 = (void *)v6[2];
          BOOL v20 = *v19 == (void)v6;
          xpc_object_t v6 = v19;
        }
        while (!v20);
      }
      xpc_object_t v6 = v19;
    }
    while (v19 != v5);
  }
  *a1 = v4;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    *a1 = xpc_null_create();
  }
  xpc_release(v4);
}

void sub_1003B4B18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object)
{
  xpc_release(v17);
  xpc_release(v16);
  _Unwind_Resume(a1);
}

void sub_1003B4B74(uint64_t a1, void **a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t object = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    xpc_object_t v4 = object;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t object = v4;
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v97.n128_u64[0] = (unint64_t)&object;
    v97.n128_u64[1] = (unint64_t)"supported";
    sub_100048BAC((uint64_t)&v97, v100);
    xpc_object_t v5 = v100[0];
    v74[0] = v100[0];
    if (v100[0] && xpc_get_type(v100[0]) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v5);
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
      v74[0] = v5;
    }
    if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
    {
      __p[0] = v74;
      __p[1] = "bitset";
      sub_100048BAC((uint64_t)__p, &p_object);
      int v7 = xpc::dyn_cast_or_default((xpc *)&p_object, 0, v6);
      xpc_release(p_object);
      *(void *)a1 = *(void *)&v7 & 0x3FFFFFLL;
      xpc_object_t v5 = v74[0];
    }
    else
    {
      *(void *)a1 &= 0xFFFFFFFFFFC00000;
    }
    xpc_release(v5);
    xpc_release(v100[0]);
    __p[0] = &object;
    __p[1] = "states";
    sub_100048BAC((uint64_t)__p, &v97);
    sub_1003B6010(a1 + 8, (xpc_object_t)v97.n128_u64[0]);
    xpc_release((xpc_object_t)v97.n128_u64[0]);
    v76[0] = &object;
    v76[1] = "details";
    sub_100048BAC((uint64_t)v76, &v77);
    xpc_object_t v8 = v77;
    if (v77 && xpc_get_type(v77) == (xpc_type_t)&_xpc_type_array) {
      xpc_retain(v8);
    }
    else {
      xpc_object_t v8 = xpc_null_create();
    }
    xpc_object_t v70 = (uint64_t **)(a1 + 32);
    sub_1001A297C(a1 + 32, *(void **)(a1 + 40));
    *(void *)(a1 + 32) = a1 + 40;
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
    unint64_t v71 = a1 + 40;
    if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_array)
    {
      __p[0] = v8;
      if (v8) {
        xpc_retain(v8);
      }
      else {
        __p[0] = xpc_null_create();
      }
      sub_100048BF4(&v84, __p, 0);
      xpc_release(__p[0]);
      __p[0] = v8;
      if (v8) {
        xpc_retain(v8);
      }
      else {
        __p[0] = xpc_null_create();
      }
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_array) {
        count = (void *)xpc_array_get_count(v8);
      }
      else {
        count = 0;
      }
      uint64_t v69 = a1;
      sub_100048BF4(v83, __p, count);
      xpc_release(__p[0]);
      xpc_object_t v10 = (uint64_t *)&__p[1];
      int v11 = &__p[3];
      for (id i = v85; ; id i = ++v85)
      {
        if (i == v83[1] && v84 == v83[0])
        {
          xpc_release(v84);
          xpc_release(v84);
          a1 = v69;
          goto LABEL_199;
        }
        xpc_object_t v82 = 0;
        __p[0] = &v84;
        __p[1] = i;
        sub_10003FBDC((uint64_t)__p, &v82);
        if (xpc_get_type(v82) == (xpc_type_t)&_xpc_type_dictionary) {
          break;
        }
LABEL_197:
        xpc_release(v82);
      }
      uint64_t v81 = 0;
      *(_OWORD *)long long __dst = 0u;
      memset(__p, 0, sizeof(__p));
      xpc_object_t v13 = v82;
      if (v82)
      {
        xpc_retain(v82);
        xpc_object_t v88 = v13;
      }
      else
      {
        xpc_object_t v13 = xpc_null_create();
        xpc_object_t v88 = v13;
        if (!v13)
        {
          xpc_object_t v14 = xpc_null_create();
          xpc_object_t v13 = 0;
          goto LABEL_38;
        }
      }
      if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v13);
        xpc_object_t v14 = v13;
        goto LABEL_39;
      }
      xpc_object_t v14 = xpc_null_create();
LABEL_38:
      xpc_object_t v88 = v14;
LABEL_39:
      xpc_object_t v72 = v13;
      if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_dictionary)
      {
        v97.n128_u64[0] = (unint64_t)&v88;
        v97.n128_u64[1] = (unint64_t)"first";
        sub_100048BAC((uint64_t)&v97, v74);
        xpc_type_t type = xpc_get_type(v74[0]);
        if (type == (xpc_type_t)&_xpc_type_string)
        {
          LODWORD(p_object) = __p[0];
          ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&p_object, (int *)v74, v16);
          LODWORD(__p[0]) = p_object;
        }
        else if (type == (xpc_type_t)&_xpc_type_BOOL {
               || type == (xpc_type_t)&_xpc_type_int64
        }
               || type == (xpc_type_t)&_xpc_type_uint64)
        {
          LODWORD(__p[0]) = xpc::dyn_cast_or_default((xpc *)v74, 0, (uint64_t)v16);
        }
        xpc_release(v74[0]);
        v86[0] = &v88;
        v86[1] = "second";
        sub_100048BAC((uint64_t)v86, &v87);
        xpc_object_t v17 = v87;
        xpc_object_t v91 = v87;
        if (v87 && xpc_get_type(v87) == (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_retain(v17);
          xpc_object_t v18 = v91;
        }
        else
        {
          xpc_object_t v18 = xpc_null_create();
          xpc_object_t v91 = v18;
        }
        if (xpc_get_type(v18) == (xpc_type_t)&_xpc_type_dictionary)
        {
          v89[0] = &v91;
          v89[1] = "planProperties";
          sub_100048BAC((uint64_t)v89, &v90);
          xpc_object_t v19 = v90;
          if (v90 && xpc_get_type(v90) == (xpc_type_t)&_xpc_type_array) {
            xpc_retain(v19);
          }
          else {
            xpc_object_t v19 = xpc_null_create();
          }
          sub_1001A145C((uint64_t)v10, (uint64_t)__p[1]);
          xpc_object_t v73 = v19;
          if (xpc_get_type(v19) == (xpc_type_t)&_xpc_type_array)
          {
            v97.n128_u64[0] = (unint64_t)v19;
            if (v19) {
              xpc_retain(v19);
            }
            else {
              v97.n128_u64[0] = (unint64_t)xpc_null_create();
            }
            sub_100048BF4((void **)&v95, (void **)&v97, 0);
            xpc_release((xpc_object_t)v97.n128_u64[0]);
            v97.n128_u64[0] = (unint64_t)v19;
            if (v19) {
              xpc_retain(v19);
            }
            else {
              v97.n128_u64[0] = (unint64_t)xpc_null_create();
            }
            if (xpc_get_type(v19) == (xpc_type_t)&_xpc_type_array) {
              BOOL v20 = (void *)xpc_array_get_count(v19);
            }
            else {
              BOOL v20 = 0;
            }
            sub_100048BF4(v94, (void **)&v97, v20);
            xpc_release((xpc_object_t)v97.n128_u64[0]);
            for (j = v96; j != v94[1] || v95 != v94[0]; j = ++v96)
            {
              v93[0] = &v95;
              v93[1] = j;
              xpc_object_t v22 = __p[2];
              if (__p[2] >= __p[3])
              {
                int64_t v24 = ((char *)__p[2] - (char *)__p[1]) >> 6;
                unint64_t v25 = v24 + 1;
                if ((unint64_t)(v24 + 1) >> 58) {
                  sub_10006A748();
                }
                int64_t v26 = (char *)__p[3] - (char *)__p[1];
                if (((char *)__p[3] - (char *)__p[1]) >> 5 > v25) {
                  unint64_t v25 = v26 >> 5;
                }
                if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFC0) {
                  unint64_t v27 = 0x3FFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v27 = v25;
                }
                long long v99 = v11;
                if (v27) {
                  xpc_object_t v28 = (char *)sub_1001A14BC((uint64_t)v11, v27);
                }
                else {
                  xpc_object_t v28 = 0;
                }
                xpc_object_t v29 = &v28[64 * v24];
                v97.n128_u64[0] = (unint64_t)v28;
                v97.n128_u64[1] = (unint64_t)v29;
                *((void *)&v98 + 1) = &v28[64 * v27];
                *(_OWORD *)xpc_object_t v29 = 0u;
                *((_OWORD *)v29 + 1) = 0u;
                *((_OWORD *)v29 + 2) = 0u;
                *((_OWORD *)v29 + 3) = 0u;
                *(void *)&long long v98 = v29 + 64;
                sub_1003B74AC(v10, &v97);
                xpc_object_t v23 = (char *)__p[2];
                sub_1003B7684((uint64_t)&v97);
              }
              else
              {
                *((_OWORD *)__p[2] + 2) = 0u;
                void v22[3] = 0u;
                xpc_object_t v23 = (char *)(v22 + 4);
                *xpc_object_t v22 = 0u;
                v22[1] = 0u;
              }
              __p[2] = v23;
              sub_1000492E0((uint64_t)v93, &v92);
              xpc_object_t v30 = v92;
              xpc_object_t v102 = v92;
              if (v92 && xpc_get_type(v92) == (xpc_type_t)&_xpc_type_dictionary)
              {
                xpc_retain(v30);
                xpc_object_t v31 = v102;
              }
              else
              {
                xpc_object_t v31 = xpc_null_create();
                xpc_object_t v102 = v31;
              }
              if (xpc_get_type(v31) == (xpc_type_t)&_xpc_type_dictionary)
              {
                v97.n128_u64[0] = (unint64_t)&v102;
                v97.n128_u64[1] = (unint64_t)"type";
                sub_100048BAC((uint64_t)&v97, v74);
                if (xpc_get_type(v74[0]) == (xpc_type_t)&_xpc_type_null)
                {
                  if (*(v23 - 60)) {
                    *(v23 - 60) = 0;
                  }
                }
                else
                {
                  if (!*(v23 - 60))
                  {
                    *((_DWORD *)v23 - 16) = 0;
                    *(v23 - 60) = 1;
                  }
                  xpc_type_t v32 = xpc_get_type(v74[0]);
                  if (v32 == (xpc_type_t)&_xpc_type_string)
                  {
                    LODWORD(p_object) = *((_DWORD *)v23 - 16);
                    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&p_object, (int *)v74, v33);
                    *((_DWORD *)v23 - 16) = p_object;
                  }
                  else if (v32 == (xpc_type_t)&_xpc_type_BOOL {
                         || v32 == (xpc_type_t)&_xpc_type_int64
                  }
                         || v32 == (xpc_type_t)&_xpc_type_uint64)
                  {
                    *((_DWORD *)v23 - 16) = xpc::dyn_cast_or_default((xpc *)v74, 0, (uint64_t)v33);
                  }
                }
                xpc_release(v74[0]);
                v97.n128_u64[0] = (unint64_t)&v102;
                v97.n128_u64[1] = (unint64_t)"experience";
                sub_100048BAC((uint64_t)&v97, v74);
                if (xpc_get_type(v74[0]) == (xpc_type_t)&_xpc_type_null)
                {
                  if (*(v23 - 55)) {
                    *(v23 - 55) = 0;
                  }
                }
                else
                {
                  if (!*(v23 - 55)) {
                    *((_WORD *)v23 - 28) = 256;
                  }
                  *(v23 - 56) = xpc::dyn_cast_or_default((xpc *)v74, 0, v34);
                }
                xpc_release(v74[0]);
                v97.n128_u64[0] = (unint64_t)&v102;
                v97.n128_u64[1] = (unint64_t)"volumeCapGb";
                sub_100048BAC((uint64_t)&v97, v74);
                if (xpc_get_type(v74[0]) == (xpc_type_t)&_xpc_type_null)
                {
                  if (*(v23 - 48)) {
                    *(v23 - 48) = 0;
                  }
                }
                else
                {
                  if (!*(v23 - 48))
                  {
                    *((_DWORD *)v23 - 13) = 0;
                    *(v23 - 48) = 1;
                  }
                  *((_DWORD *)v23 - 13) = xpc::dyn_cast_or_default((xpc *)v74, 0, v35);
                }
                xpc_release(v74[0]);
                long long v36 = v11;
                v100[0] = &v102;
                v100[1] = "supportedRat";
                sub_100048BAC((uint64_t)v100, &v101);
                long long v37 = v10;
                xpc_object_t v38 = (void **)(v23 - 40);
                if (xpc_get_type(v101) == (xpc_type_t)&_xpc_type_null)
                {
                  if (*(v23 - 16))
                  {
                    xpc_object_t v40 = *v38;
                    if (*v38)
                    {
                      *((void *)v23 - 4) = v40;
                      operator delete(v40);
                    }
                    *(v23 - 16) = 0;
                  }
                }
                else
                {
                  if (!*(v23 - 16))
                  {
                    __n128 v97 = 0uLL;
                    *(void *)&long long v98 = 0;
                    sub_100195D74((uint64_t)(v23 - 40), &v97);
                    if (v97.n128_u64[0])
                    {
                      v97.n128_u64[1] = v97.n128_u64[0];
                      operator delete((void *)v97.n128_u64[0]);
                    }
                  }
                  uint64_t v39 = v101;
                  if (v101 && xpc_get_type(v101) == (xpc_type_t)&_xpc_type_array) {
                    xpc_retain(v39);
                  }
                  else {
                    uint64_t v39 = (__n128 *)xpc_null_create();
                  }
                  *((void *)v23 - 4) = *((void *)v23 - 5);
                  if (xpc_get_type(v39) == (xpc_type_t)&_xpc_type_array)
                  {
                    v74[0] = v39;
                    if (v39) {
                      xpc_retain(v39);
                    }
                    else {
                      v74[0] = xpc_null_create();
                    }
                    sub_100048BF4((void **)&v97, v74, 0);
                    xpc_release(v74[0]);
                    p_xpc_object_t object = v39;
                    if (v39) {
                      xpc_retain(v39);
                    }
                    else {
                      p_xpc_object_t object = (__n128 *)xpc_null_create();
                    }
                    if (xpc_get_type(v39) == (xpc_type_t)&_xpc_type_array) {
                      xpc_object_t v41 = (void *)xpc_array_get_count(v39);
                    }
                    else {
                      xpc_object_t v41 = 0;
                    }
                    sub_100048BF4(v74, (void **)&p_object, v41);
                    xpc_release(p_object);
                    for (k = (const char *)v97.n128_u64[1];
                          k != v74[1] || (xpc_object_t)v97.n128_u64[0] != v74[0];
                          k = (const char *)++v97.n128_u64[1])
                    {
                      p_xpc_object_t object = &v97;
                      v105 = k;
                      xpc_object_t v44 = (char *)*((void *)v23 - 4);
                      unint64_t v43 = *((void *)v23 - 3);
                      if ((unint64_t)v44 >= v43)
                      {
                        uint64_t v46 = (char *)*v38;
                        uint64_t v47 = (v44 - (unsigned char *)*v38) >> 2;
                        unint64_t v48 = v47 + 1;
                        if ((unint64_t)(v47 + 1) >> 62) {
                          sub_10006A748();
                        }
                        uint64_t v49 = v43 - (void)v46;
                        if (v49 >> 1 > v48) {
                          unint64_t v48 = v49 >> 1;
                        }
                        if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFFCLL) {
                          unint64_t v50 = 0x3FFFFFFFFFFFFFFFLL;
                        }
                        else {
                          unint64_t v50 = v48;
                        }
                        if (v50)
                        {
                          uint64_t v51 = (char *)sub_10005ECD8((uint64_t)(v23 - 24), v50);
                          uint64_t v46 = (char *)*((void *)v23 - 5);
                          xpc_object_t v44 = (char *)*((void *)v23 - 4);
                        }
                        else
                        {
                          uint64_t v51 = 0;
                        }
                        xpc_object_t v52 = &v51[4 * v47];
                        *(_DWORD *)xpc_object_t v52 = 0;
                        size_t v45 = v52 + 4;
                        while (v44 != v46)
                        {
                          int v53 = *((_DWORD *)v44 - 1);
                          v44 -= 4;
                          *((_DWORD *)v52 - 1) = v53;
                          v52 -= 4;
                        }
                        *((void *)v23 - 5) = v52;
                        *((void *)v23 - 4) = v45;
                        *((void *)v23 - 3) = &v51[4 * v50];
                        if (v46) {
                          operator delete(v46);
                        }
                      }
                      else
                      {
                        *(_DWORD *)xpc_object_t v44 = 0;
                        size_t v45 = v44 + 4;
                      }
                      *((void *)v23 - 4) = v45;
                      sub_1000492E0((uint64_t)&p_object, v103);
                      xpc_type_t v54 = xpc_get_type(*(xpc_object_t *)v103);
                      if (v54 == (xpc_type_t)&_xpc_type_string)
                      {
                        v106[0] = *(v45 - 1);
                        ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v106, v103, v55);
                        *(v45 - 1) = v106[0];
                      }
                      else if (v54 == (xpc_type_t)&_xpc_type_BOOL {
                             || v54 == (xpc_type_t)&_xpc_type_int64
                      }
                             || v54 == (xpc_type_t)&_xpc_type_uint64)
                      {
                        *(v45 - 1) = xpc::dyn_cast_or_default((xpc *)v103, 0, (uint64_t)v55);
                      }
                      xpc_release(*(xpc_object_t *)v103);
                    }
                    xpc_release((xpc_object_t)v97.n128_u64[0]);
                    xpc_release((xpc_object_t)v97.n128_u64[0]);
                  }
                  xpc_release(v39);
                }
                xpc_release(v101);
                v97.n128_u64[0] = (unint64_t)&v102;
                v97.n128_u64[1] = (unint64_t)"saProvisioned";
                sub_100048BAC((uint64_t)&v97, v74);
                xpc_object_t v10 = v37;
                int v11 = v36;
                if (xpc_get_type(v74[0]) == (xpc_type_t)&_xpc_type_null)
                {
                  if (*(v23 - 7)) {
                    *(v23 - 7) = 0;
                  }
                }
                else
                {
                  if (!*(v23 - 7)) {
                    *((_WORD *)v23 - 4) = 256;
                  }
                  *(v23 - 8) = xpc::dyn_cast_or_default((xpc *)v74, 0, v56);
                }
                xpc_release(v74[0]);
                xpc_object_t v13 = v72;
              }
              xpc_release(v102);
              xpc_release(v92);
              xpc_object_t v19 = v73;
            }
            xpc_release(v95);
            xpc_release(v95);
          }
          xpc_release(v19);
          xpc_release(v90);
          v95 = 0;
          v97.n128_u64[0] = (unint64_t)&v91;
          v97.n128_u64[1] = (unint64_t)"altServer";
          sub_100048BAC((uint64_t)&v97, &v95);
          if (xpc_get_type(v95) != (xpc_type_t)&_xpc_type_null)
          {
            __n128 v97 = 0u;
            long long v98 = 0u;
            long long v57 = v95;
            p_xpc_object_t object = v95;
            if (v95 && xpc_get_type(v95) == (xpc_type_t)&_xpc_type_dictionary)
            {
              xpc_retain(v57);
            }
            else
            {
              long long v57 = (__n128 *)xpc_null_create();
              p_xpc_object_t object = v57;
            }
            if (xpc_get_type(v57) == (xpc_type_t)&_xpc_type_dictionary)
            {
              v74[0] = &p_object;
              v74[1] = "url";
              sub_100048BAC((uint64_t)v74, v100);
              sub_10008BD58((uint64_t)&v97, v100);
              xpc_release(v100[0]);
              long long v57 = p_object;
            }
            xpc_release(v57);
            xpc_object_t v58 = (char *)operator new(0x38uLL);
            *((void *)v58 + 1) = 0;
            *((void *)v58 + 2) = 0;
            *(void *)xpc_object_t v58 = off_1019C45A8;
            *(_OWORD *)(v58 + 24) = 0u;
            xpc_object_t v59 = (std::string *)(v58 + 24);
            *(_OWORD *)(v58 + 40) = 0u;
            long long v60 = (std::__shared_weak_count *)__dst[1];
            __dst[0] = v58 + 24;
            __dst[1] = v58;
            if (v60)
            {
              sub_10004D2C8(v60);
              xpc_object_t v59 = (std::string *)__dst[0];
            }
            sub_100179AF8(v59, (const std::string *)&v97);
            if (BYTE8(v98) && SBYTE7(v98) < 0) {
              operator delete((void *)v97.n128_u64[0]);
            }
          }
          v97.n128_u64[0] = (unint64_t)&v91;
          v97.n128_u64[1] = (unint64_t)"isPrimary";
          sub_100048BAC((uint64_t)&v97, v74);
          if (xpc_get_type(v74[0]) == (xpc_type_t)&_xpc_type_null)
          {
            if (BYTE1(v81)) {
              BYTE1(v81) = 0;
            }
          }
          else
          {
            if (!BYTE1(v81)) {
              LOWORD(v81) = 256;
            }
            LOBYTE(v81) = xpc::dyn_cast_or_default((xpc *)v74, 0, v61);
          }
          xpc_release(v74[0]);
          xpc_release(v95);
        }
        xpc_release(v91);
        xpc_release(v87);
        xpc_object_t v14 = v88;
      }
      xpc_release(v14);
      xpc_release(v13);
      int v62 = (int)__p[0];
      xpc_object_t v63 = (uint64_t **)v71;
      while (1)
      {
        xpc_object_t v64 = *v63;
        xpc_object_t v65 = v63;
        if (!*v63) {
          break;
        }
        while (1)
        {
          xpc_object_t v63 = (uint64_t **)v64;
          int v66 = *((_DWORD *)v64 + 8);
          if (v66 > SLODWORD(__p[0])) {
            break;
          }
          if (v66 >= SLODWORD(__p[0])) {
            goto LABEL_194;
          }
          xpc_object_t v64 = v63[1];
          if (!v64)
          {
            xpc_object_t v65 = v63 + 1;
            goto LABEL_193;
          }
        }
      }
LABEL_193:
      *(void *)&long long v98 = 0;
      xpc_object_t v67 = (char *)operator new(0x58uLL);
      v97.n128_u64[1] = v71;
      *((_DWORD *)v67 + 8) = v62;
      *(_OWORD *)(v67 + 40) = *(_OWORD *)&__p[1];
      *((xpc_object_t *)v67 + 7) = __p[3];
      v10[1] = 0;
      uint64_t v10[2] = 0;
      *xpc_object_t v10 = 0;
      *((_OWORD *)v67 + 4) = *(_OWORD *)__dst;
      __dst[0] = 0;
      __dst[1] = 0;
      *((_WORD *)v67 + 40) = v81;
      LOBYTE(v98) = 1;
      sub_100046C38(v70, (uint64_t)v63, v65, (uint64_t *)v67);
      v97.n128_u64[0] = 0;
      sub_1001BF34C((uint64_t)&v97, 0);
LABEL_194:
      if (__dst[1]) {
        sub_10004D2C8((std::__shared_weak_count *)__dst[1]);
      }
      v97.n128_u64[0] = (unint64_t)v10;
      sub_1001A14F4((void ***)&v97);
      goto LABEL_197;
    }
LABEL_199:
    xpc_release(v8);
    xpc_release(v77);
    __p[0] = &object;
    __p[1] = "latest_received";
    sub_100048BAC((uint64_t)__p, &v97);
    sub_1003B6010(a1 + 56, (xpc_object_t)v97.n128_u64[0]);
    xpc_release((xpc_object_t)v97.n128_u64[0]);
    v74[0] = 0;
    v74[1] = 0;
    uint64_t v75 = 0;
    p_xpc_object_t object = (__n128 *)&object;
    v105 = "supported_tasks";
    sub_100048BAC((uint64_t)&p_object, v100);
    memset(__p, 0, 24);
    xpc::dyn_cast_or_default();
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    *(__n128 *)xpc_object_t v74 = v97;
    uint64_t v75 = v98;
    xpc_release(v100[0]);
    sub_1003B77F8((unint64_t *)__p, (uint64_t)v74);
    *(xpc_object_t *)(a1 + 80) = __p[0];
    __p[0] = &object;
    __p[1] = "blocked";
    sub_100048BAC((uint64_t)__p, &v97);
    *(unsigned char *)(a1 + 88) = xpc::dyn_cast_or_default((xpc *)&v97, 0, v68);
    xpc_release((xpc_object_t)v97.n128_u64[0]);
    if (SHIBYTE(v75) < 0) {
      operator delete(v74[0]);
    }
  }
  xpc_release(object);
}

void sub_1003B5B50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t a15, xpc_object_t a16, xpc_object_t __p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,xpc_object_t a26,xpc_object_t a27,xpc_object_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,xpc_object_t a39,xpc_object_t a40,uint64_t a41,xpc_object_t a42,uint64_t a43,uint64_t a44,uint64_t a45,xpc_object_t object,xpc_object_t a47,uint64_t a48,uint64_t a49,xpc_object_t a50)
{
  xpc_release(*(xpc_object_t *)(v50 - 152));
  xpc_release(*(xpc_object_t *)(v50 - 112));
  if (*(unsigned char *)(v50 - 168))
  {
    if (*(char *)(v50 - 169) < 0) {
      operator delete(*(void **)(v50 - 192));
    }
  }
  xpc_release(*(xpc_object_t *)(v50 - 208));
  xpc_release(*(xpc_object_t *)(v50 - 256));
  xpc_release(object);
  xpc_release(a47);
  xpc_release(a15);
  sub_1003B77B0((uint64_t)&a28);
  xpc_release(a39);
  xpc_release(a40);
  xpc_release(a42);
  xpc_release(a11);
  xpc_release(a26);
  xpc_release(a27);
  _Unwind_Resume(a1);
}

void sub_1003B6010(uint64_t a1, xpc_object_t object)
{
  if (object && (xpc_object_t v3 = object, xpc_get_type(object) == (xpc_type_t)&_xpc_type_array)) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  xpc_object_t v4 = (uint64_t **)(a1 + 8);
  sub_1000346F8(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_object_t objecta = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t objecta = xpc_null_create();
    }
    sub_100048BF4(&v22, &objecta, 0);
    xpc_release(objecta);
    xpc_object_t objecta = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t objecta = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v21, &objecta, count);
    xpc_release(objecta);
    for (id i = v23; ; id i = ++v23)
    {
      if (i == v21[1] && v22 == v21[0])
      {
        xpc_release(v22);
        xpc_release(v22);
        goto LABEL_54;
      }
      xpc_object_t v20 = 0;
      xpc_object_t objecta = &v22;
      unint64_t v25 = i;
      sub_10003FBDC((uint64_t)&objecta, &v20);
      if (xpc_get_type(v20) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_52:
      xpc_release(v20);
    }
    xpc_object_t v7 = v20;
    if (v20)
    {
      xpc_retain(v20);
      xpc_object_t v27 = v7;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v27 = v7;
      if (!v7)
      {
        xpc_object_t v8 = xpc_null_create();
        xpc_object_t v7 = 0;
        goto LABEL_26;
      }
    }
    if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v7);
      xpc_object_t v8 = v27;
      goto LABEL_27;
    }
    xpc_object_t v8 = xpc_null_create();
LABEL_26:
    xpc_object_t v27 = v8;
LABEL_27:
    if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t objecta = &v27;
      unint64_t v25 = "first";
      sub_100048BAC((uint64_t)&objecta, &v26);
      xpc_type_t type = xpc_get_type(v26);
      if (type == (xpc_type_t)&_xpc_type_string)
      {
        int v28 = 0;
        ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v28, (int *)&v26, v12);
        int v10 = v28;
      }
      else if (type == (xpc_type_t)&_xpc_type_BOOL {
             || type == (xpc_type_t)&_xpc_type_int64
      }
             || type == (xpc_type_t)&_xpc_type_uint64)
      {
        int v10 = xpc::dyn_cast_or_default((xpc *)&v26, 0, (uint64_t)v12);
      }
      else
      {
        int v10 = 0;
      }
      xpc_release(v26);
      xpc_object_t objecta = &v27;
      unint64_t v25 = "second";
      sub_100048BAC((uint64_t)&objecta, &v26);
      xpc_type_t v13 = xpc_get_type(v26);
      if (v13 == (xpc_type_t)&_xpc_type_string)
      {
        int v28 = 0;
        ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v28, (unsigned int *)&v26, v14);
        int v9 = v28;
      }
      else if (v13 == (xpc_type_t)&_xpc_type_BOOL {
             || v13 == (xpc_type_t)&_xpc_type_int64
      }
             || v13 == (xpc_type_t)&_xpc_type_uint64)
      {
        int v9 = xpc::dyn_cast_or_default((xpc *)&v26, 0, (uint64_t)v14);
      }
      else
      {
        int v9 = 0;
      }
      xpc_release(v26);
    }
    else
    {
      int v9 = 0;
      int v10 = 0;
    }
    xpc_release(v27);
    xpc_release(v7);
    xpc_object_t v15 = *v4;
    xpc_object_t v16 = (uint64_t **)(a1 + 8);
    xpc_object_t v17 = (uint64_t **)(a1 + 8);
    if (*v4)
    {
      while (1)
      {
        while (1)
        {
          xpc_object_t v17 = (uint64_t **)v15;
          int v18 = *((_DWORD *)v15 + 7);
          if (v18 <= v10) {
            break;
          }
          xpc_object_t v15 = *v17;
          xpc_object_t v16 = v17;
          if (!*v17) {
            goto LABEL_51;
          }
        }
        if (v18 >= v10) {
          break;
        }
        xpc_object_t v15 = v17[1];
        if (!v15)
        {
          xpc_object_t v16 = v17 + 1;
          goto LABEL_51;
        }
      }
    }
    else
    {
LABEL_51:
      xpc_object_t v19 = (uint64_t *)operator new(0x28uLL);
      *((_DWORD *)v19 + 7) = v10;
      *((_DWORD *)v19 + 8) = v9;
      sub_100046C38((uint64_t **)a1, (uint64_t)v17, v16, v19);
    }
    goto LABEL_52;
  }
LABEL_54:
  xpc_release(v3);
}

void sub_1003B63F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t a10, uint64_t a11, xpc_object_t a12, uint64_t a13, xpc_object_t object, uint64_t a15, xpc_object_t a16, xpc_object_t a17)
{
  xpc_release(object);
  xpc_release(a12);
  xpc_release(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_1003B64CC(uint64_t a1, void **a2, unsigned int a3)
{
  xpc_object_t v5 = sub_100046F68(a1, a2);
  if ((void **)(a1 + 8) == v5)
  {
    LODWORD(v6) = 0;
    int v7 = 0;
  }
  else
  {
    if (a3 >= 0x16) {
      sub_1000C14F0("bitset test argument out of range");
    }
    uint64_t v6 = ((unint64_t)v5[7] >> a3) & 1;
    int v7 = 1;
  }
  return v6 | (v7 << 8);
}

void sub_1003B6534(int *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v11 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v11 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v11 = v6;
LABEL_9:
  xpc_release(v5);
  if (*((unsigned char *)a1 + 4))
  {
    xpc_object_t v9 = xpc_int64_create(*a1);
    if (!v9) {
      xpc_object_t v9 = xpc_null_create();
    }
    v8[0] = &v11;
    v8[1] = "knownAuthResponseCode";
    sub_100035E70((uint64_t)v8, &v9, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v9);
    xpc_object_t v9 = 0;
  }
  xpc_object_t v7 = v11;
  *a2 = v11;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v11);
}

void sub_1003B667C(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v7 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v7 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v6[0] = &v7;
    v6[1] = "knownAuthResponseCode";
    if (xpc_dictionary_get_value(v3, "knownAuthResponseCode"))
    {
      sub_100048BAC((uint64_t)v6, &object);
      if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_null)
      {
        if (*(unsigned char *)(a1 + 4)) {
          *(unsigned char *)(a1 + 4) = 0;
        }
      }
      else
      {
        if (!*(unsigned char *)(a1 + 4))
        {
          *(_DWORD *)a1 = 0;
          *(unsigned char *)(a1 + 4) = 1;
        }
        *(_DWORD *)a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, v4);
      }
      xpc_release(object);
    }
    xpc_object_t v3 = v7;
  }
  xpc_release(v3);
}

void sub_1003B6788(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
}

uint64_t sub_1003B67CC(void *a1, void *a2)
{
  uint64_t result = sub_100054998(a1, 0, (uint64_t)a1, 0xDu, a2);
  if (result) {
    return sub_100054998(a1 + 1, 0, (uint64_t)(a1 + 1), 0xDu, a2 + 1);
  }
  return result;
}

uint64_t sub_1003B6830@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v13 = 0u;
  memset(v11, 0, sizeof(v11));
  long long v10 = 0u;
  sub_10004BD84((uint64_t)&v10);
  int v4 = sub_10004B96C(v11, (uint64_t)"{ reachable: ", 13);
  xpc_object_t v5 = sub_1003B312C(v4, a1);
  xpc_object_t v6 = sub_10004B96C(v5, (uint64_t)", unreachable: ", 15);
  xpc_object_t v7 = sub_1003B312C(v6, a1 + 1);
  sub_10004B96C(v7, (uint64_t)" }", 2);
  sub_10004BC98((uint64_t)v11 + 8, a2);
  *(void *)((char *)&v11[-1]
  *(void *)&v11[0] = v8;
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1003B6A0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1003B6A20(void *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v26 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v26 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = xpc_null_create();
LABEL_8:
    xpc_object_t v26 = v6;
    goto LABEL_9;
  }
  xpc_retain(v5);
LABEL_9:
  xpc_release(v5);
  uint64_t v7 = 0;
  char v21 = 0;
  __int16 v22 = 0;
  uint64_t v23 = 0xD00000000000000;
  strcpy(__p, "000000000000");
  uint64_t v8 = 12;
  do
  {
    if ((*a1 >> v7))
    {
      if (v23 >= 0) {
        xpc_object_t v9 = __p;
      }
      else {
        xpc_object_t v9 = *(char **)__p;
      }
      v9[v8] = 49;
    }
    ++v7;
    --v8;
  }
  while (v7 != 13);
  if (v23 >= 0) {
    long long v10 = __p;
  }
  else {
    long long v10 = *(char **)__p;
  }
  xpc_object_t object = xpc_string_create(v10);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  long long v18 = &v26;
  long long v19 = "reachable";
  sub_100035E70((uint64_t)&v18, &object, &v25);
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v23) < 0) {
    operator delete(*(void **)__p);
  }
  uint64_t v11 = 0;
  char v21 = 0;
  __int16 v22 = 0;
  uint64_t v23 = 0xD00000000000000;
  strcpy(__p, "000000000000");
  uint64_t v12 = 12;
  do
  {
    if ((a1[1] >> v11))
    {
      if (v23 >= 0) {
        long long v13 = __p;
      }
      else {
        long long v13 = *(char **)__p;
      }
      v13[v12] = 49;
    }
    ++v11;
    --v12;
  }
  while (v11 != 13);
  if (v23 >= 0) {
    long long v14 = __p;
  }
  else {
    long long v14 = *(char **)__p;
  }
  xpc_object_t v16 = xpc_string_create(v14);
  if (!v16) {
    xpc_object_t v16 = xpc_null_create();
  }
  long long v18 = &v26;
  long long v19 = "unreachable";
  sub_100035E70((uint64_t)&v18, &v16, &v17);
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_release(v16);
  xpc_object_t v16 = 0;
  if (SHIBYTE(v23) < 0) {
    operator delete(*(void **)__p);
  }
  xpc_object_t v15 = v26;
  *a2 = v26;
  if (v15) {
    xpc_retain(v15);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v26);
}

void sub_1003B6CB0(void *a1, void **a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t object = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    xpc_object_t v4 = object;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t object = v4;
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v10 = 0;
    p_xpc_object_t object = &object;
    uint64_t v7 = "reachable";
    sub_100048BAC((uint64_t)&p_object, &v8);
    long long v14 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v16) < 0) {
      operator delete(v14);
    }
    *(_OWORD *)long long __p = v12;
    uint64_t v10 = v13;
    xpc_release(v8);
    sub_1003B77F8((unint64_t *)&v14, (uint64_t)__p);
    *a1 = v14;
    int v5 = SHIBYTE(v10);
    if (SHIBYTE(v10) < 0)
    {
      *(unsigned char *)__p[0] = 0;
      __p[1] = 0;
    }
    else
    {
      int v5 = 0;
      LOBYTE(__p[0]) = 0;
      HIBYTE(v10) = 0;
    }
    p_xpc_object_t object = &object;
    uint64_t v7 = "unreachable";
    sub_100048BAC((uint64_t)&p_object, &v8);
    long long v14 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v16) < 0)
    {
      operator delete(v14);
      if ((v5 & 0x80000000) == 0) {
        goto LABEL_13;
      }
    }
    else if ((v5 & 0x80000000) == 0)
    {
      goto LABEL_13;
    }
    operator delete(__p[0]);
LABEL_13:
    *(_OWORD *)long long __p = v12;
    uint64_t v10 = v13;
    xpc_release(v8);
    sub_1003B77F8((unint64_t *)&v14, (uint64_t)__p);
    a1[1] = v14;
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
  }
  xpc_release(object);
}

void sub_1003B6E68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, xpc_object_t object)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_1003B6EFC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v33 = 0;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v22 = 0u;
  memset(v20, 0, sizeof(v20));
  long long v19 = 0u;
  sub_10004BD84((uint64_t)&v19);
  xpc_object_t v4 = sub_10004B96C(v20, (uint64_t)"{ ", 2);
  if (*(_DWORD *)a1) {
    int v5 = "UnknownSubscription";
  }
  else {
    int v5 = "SettingsUpdated";
  }
  if (*(_DWORD *)a1) {
    uint64_t v6 = 19;
  }
  else {
    uint64_t v6 = 15;
  }
  uint64_t v7 = sub_10004B96C(v4, (uint64_t)v5, v6);
  xpc_object_t v8 = sub_10004B96C(v7, (uint64_t)" : ", 3);
  uint64_t v11 = *(const char **)(a1 + 8);
  uint64_t v10 = a1 + 8;
  xpc_object_t v9 = v11;
  uint64_t v12 = *(unsigned __int8 *)(v10 + 23);
  int v13 = (char)v12;
  if ((v12 & 0x80u) != 0) {
    uint64_t v12 = *(void *)(v10 + 8);
  }
  if (v13 >= 0) {
    xpc_object_t v9 = (const char *)v10;
  }
  if (v12) {
    long long v14 = v9;
  }
  else {
    long long v14 = "<invalid>";
  }
  size_t v15 = strlen(v14);
  uint64_t v16 = sub_10004B96C(v8, (uint64_t)v14, v15);
  sub_10004B96C(v16, (uint64_t)" }", 2);
  sub_10004BC98((uint64_t)v20 + 8, a2);
  *(void *)((char *)&v20[-1]
  *(void *)&v20[0] = v17;
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1003B713C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1003B7150(int *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v17 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v17 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v17 = v6;
LABEL_9:
  xpc_release(v5);
  write_rest_value();
  int v13 = &v17;
  long long v14 = "persona";
  sub_100035E70((uint64_t)&v13, &v15, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_object_t v8 = (ctu::rest::detail *)*a1;
  if (v8) {
    xpc_object_t v9 = "UnknownSubscription";
  }
  else {
    xpc_object_t v9 = "SettingsUpdated";
  }
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v11, v8, (uint64_t)v9, v7);
  int v13 = &v17;
  long long v14 = "eventType";
  sub_100035E70((uint64_t)&v13, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v10 = v17;
  *a2 = v17;
  if (v10) {
    xpc_retain(v10);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v17);
}

void sub_1003B72E0(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_1003B72F8(int *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v9 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v9 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = &v9;
    uint64_t v7 = "persona";
    sub_100048BAC((uint64_t)&v6, &object);
    read_rest_value();
    xpc_release(object);
    xpc_object_t v6 = &v9;
    uint64_t v7 = "eventType";
    sub_100048BAC((uint64_t)&v6, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v10 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v10, (int *)&object, v5);
      *a1 = v10;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    xpc_object_t v3 = v9;
  }
  xpc_release(v3);
}

void sub_1003B7458(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, xpc_object_t object)
{
}

uint64_t sub_1003B74AC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1003B7524((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1003B7524(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v12[0] = a1;
  v12[1] = &v13;
  v12[2] = &v14;
  v12[3] = 1;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    do
    {
      long long v8 = *(_OWORD *)(a3 - 64);
      char v9 = *(unsigned char *)(a3 - 48);
      *(unsigned char *)(v7 - 40) = 0;
      *(unsigned char *)(v7 - 48) = v9;
      *(_OWORD *)(v7 - 64) = v8;
      *(unsigned char *)(v7 - 16) = 0;
      if (*(unsigned char *)(a3 - 16))
      {
        *(void *)(v7 - 40) = 0;
        *(void *)(v7 - 32) = 0;
        *(void *)(v7 - 24) = 0;
        *(_OWORD *)(v7 - 40) = *(_OWORD *)(a3 - 40);
        *(void *)(v7 - 24) = *(void *)(a3 - 24);
        *(void *)(a3 - 40) = 0;
        *(void *)(a3 - 32) = 0;
        *(void *)(a3 - 24) = 0;
        *(unsigned char *)(v7 - 16) = 1;
      }
      *(_WORD *)(v7 - 8) = *(_WORD *)(a3 - 8);
      uint64_t v7 = *((void *)&v14 + 1) - 64;
      *((void *)&v14 + 1) -= 64;
      a3 -= 64;
    }
    while (a3 != a5);
    uint64_t v10 = v14;
  }
  sub_1003B75FC((uint64_t)v12);
  return v10;
}

uint64_t sub_1003B75FC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1003B7634(a1);
  }
  return a1;
}

void sub_1003B7634(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(unsigned char *)(v1 + 48))
    {
      xpc_object_t v3 = *(void **)(v1 + 24);
      if (v3)
      {
        *(void *)(v1 + 32) = v3;
        operator delete(v3);
      }
    }
    v1 += 64;
  }
}

uint64_t sub_1003B7684(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1003B76BC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 64;
      *(void *)(a1 + 16) = v2 - 64;
      if (*(unsigned char *)(v2 - 16))
      {
        uint64_t v6 = *(void **)(v2 - 40);
        if (v6)
        {
          *(void *)(v2 - 32) = v6;
          operator delete(v6);
          uint64_t v5 = *(void *)(a1 + 16);
        }
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

void sub_1003B771C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019C45A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1003B773C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019C45A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1003B7790(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
  }
}

uint64_t sub_1003B77B0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_object_t v4 = (void **)(a1 + 8);
  sub_1001A14F4(&v4);
  return a1;
}

unint64_t *sub_1003B77F8(unint64_t *a1, uint64_t a2)
{
  *a1 = 0;
  unint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  int v4 = (char)v3;
  uint64_t v5 = *(char **)a2;
  if ((v3 & 0x80u) != 0) {
    unint64_t v3 = *(void *)(a2 + 8);
  }
  if (v4 >= 0) {
    uint64_t v5 = (char *)a2;
  }
  if (v3)
  {
    uint64_t v6 = v5;
    unint64_t v7 = v3;
    do
    {
      char v8 = *v6++;
      if ((v8 & 0xFE) != 0x30) {
        sub_1003B7950("bitset string ctor has invalid argument");
      }
      --v7;
    }
    while (v7);
  }
  uint64_t v9 = 13;
  if (v3 < 0xD) {
    uint64_t v9 = v3;
  }
  if (!v9)
  {
    unint64_t v20 = 0;
    unint64_t v19 = 0;
    char v21 = 51;
    xpc_object_t v17 = a1;
    goto LABEL_25;
  }
  uint64_t v10 = 0;
  char v11 = 0;
  xpc_object_t v12 = v5 - 1;
  uint64_t v13 = v9;
  do
  {
    uint64_t v14 = v10 & ~(1 << v11);
    v10 |= 1 << v11;
    if (v12[v13] != 49) {
      uint64_t v10 = v14;
    }
    *a1 = v10;
    ++v11;
    --v13;
  }
  while (v13);
  if (v3 <= 0xC)
  {
    uint64_t v15 = 13 - v9;
    uint64_t v16 = 64 - v9 >= (unint64_t)(13 - v9) ? 13 - v9 : 64 - v9;
    *a1 = v10 & ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v9 - v16)) & (-1 << v9));
    xpc_object_t v17 = a1 + 1;
    char v18 = v15 - v16;
    unint64_t v19 = (unint64_t)(v15 - v16) >> 6;
    if ((unint64_t)(v15 - v16) >= 0x40) {
      bzero(a1 + 1, 8 * v19);
    }
    if ((v18 & 0x3F) != 0)
    {
      unint64_t v20 = v17[v19];
      char v21 = 64 - (v18 & 0x3F);
LABEL_25:
      v17[v19] = v20 & ~(0xFFFFFFFFFFFFFFFFLL >> v21);
    }
  }
  return a1;
}

void sub_1003B7950(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1003B79AC(exception, a1);
}

void sub_1003B7998(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_1003B79AC(std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  return result;
}

void sub_1003B79E4(OOSGeofenceFactoryInterface *a1)
{
  OOSGeofenceFactoryInterface::~OOSGeofenceFactoryInterface(a1);

  operator delete();
}

void sub_1003B7A1C(uint64_t *a1@<X1>, NSObject **a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v5 = (std::__shared_weak_count *)a1[1];
  unint64_t v7 = (std::__shared_weak_count *)operator new(0xB8uLL);
  char v8 = v7;
  v7->__shared_owners_ = 0;
  v7->__shared_weak_owners_ = 0;
  v7->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4668;
  uint64_t v9 = &v7[1].__vftable;
  v11[0] = v6;
  v11[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  OOSGeofenceManager::OOSGeofenceManager((uint64_t)&v7[1], v11, a2);
  if (v5) {
    sub_10004D2C8(v5);
  }
  shared_weak_owners = (std::__shared_weak_count *)v8[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v8[1].__shared_owners_ = (uint64_t)v9;
    v8[1].__shared_weak_owners_ = (uint64_t)v8;
    goto LABEL_9;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v8[1].__shared_owners_ = (uint64_t)v9;
    v8[1].__shared_weak_owners_ = (uint64_t)v8;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
LABEL_9:
    sub_10004D2C8(v8);
  }
  *a3 = v9;
  a3[1] = v8;
}

void sub_1003B7B14(_Unwind_Exception *a1)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v4);
  _Unwind_Resume(a1);
}

void sub_1003B7B38(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4668;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1003B7B58(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4668;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1003B7BAC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1003B7BD4(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1003B7CA4(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003B7CD8(uint64_t a1, void *a2, unsigned int a3, NSObject **a4)
{
  char v8 = (void *)(a1 + 8);
  if (a3 > 3) {
    uint64_t v9 = "cm.mdl.1";
  }
  else {
    uint64_t v9 = off_1019C48F0[a3];
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v14, kCtLoggingSystemName, v9);
  void *v8 = 0;
  v8[1] = 0;
  uint64_t v10 = *a4;
  *(void *)(a1 + 24) = *a4;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v15, &v14);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v15);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v15);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v14);
  *(void *)a1 = off_1019C46B8;
  *(void *)(a1 + 48) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 56) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 64) = a3;
  *(_DWORD *)(a1 + 68) = 11;
  *(unsigned char *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 144) = 0;
  *(unsigned char *)(a1 + 168) = 0;
  *(unsigned char *)(a1 + 176) = 0;
  *(unsigned char *)(a1 + 200) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  *(unsigned char *)(a1 + 232) = 0;
  *(unsigned char *)(a1 + 240) = 0;
  *(unsigned char *)(a1 + 264) = 0;
  *(unsigned char *)(a1 + 272) = 0;
  *(unsigned char *)(a1 + 296) = 0;
  *(unsigned char *)(a1 + 304) = 0;
  *(unsigned char *)(a1 + 328) = 0;
  *(unsigned char *)(a1 + 336) = 0;
  *(unsigned char *)(a1 + 360) = 0;
  *(unsigned char *)(a1 + 368) = 0;
  *(unsigned char *)(a1 + 392) = 0;
  *(unsigned char *)(a1 + 400) = 0;
  *(unsigned char *)(a1 + 432) = 0;
  *(unsigned char *)(a1 + 440) = 0;
  *(unsigned char *)(a1 + 472) = 0;
  *(unsigned char *)(a1 + 480) = 0;
  *(unsigned char *)(a1 + 504) = 0;
  *(unsigned char *)(a1 + 512) = 0;
  *(unsigned char *)(a1 + 536) = 0;
  *(unsigned char *)(a1 + 544) = 0;
  *(unsigned char *)(a1 + 568) = 0;
  *(_WORD *)(a1 + 576) = 0;
  xpc_object_t v12 = operator new(0x30uLL);
  *(_OWORD *)((char *)v12 + 8) = 0u;
  v12[2] = 0u;
  *(void *)xpc_object_t v12 = off_1019C48B0;
  *((void *)v12 + 3) = v12 + 2;
  *(void *)(a1 + 584) = (char *)v12 + 24;
  *(void *)(a1 + 592) = v12;
  *(void *)(a1 + 600) = 0;
  *(unsigned char *)(a1 + 608) = 0;
  *(unsigned char *)(a1 + 712) = 0;
  *(unsigned char *)(a1 + 720) = 0;
  *(unsigned char *)(a1 + 792) = 0;
  *(unsigned char *)(a1 + 800) = 0;
  *(unsigned char *)(a1 + 888) = 0;
  *(unsigned char *)(a1 + 896) = 0;
  *(unsigned char *)(a1 + 992) = 0;
  *(unsigned char *)(a1 + 1000) = 0;
  *(unsigned char *)(a1 + 1128) = 0;
  *(unsigned char *)(a1 + 1136) = 0;
  *(unsigned char *)(a1 + 1232) = 0;
  *(unsigned char *)(a1 + 1240) = 0;
  *(unsigned char *)(a1 + 1376) = 0;
  *(_WORD *)(a1 + 1384) = 0;
  *(_OWORD *)(a1 + 1392) = 0u;
  Registry::getNotificationSenderFactory((uint64_t *)&v14, *(Registry **)(a1 + 48));
  (*(void (**)(char *))(*(void *)v14.var0 + 48))(v14.var0);
  if (v14.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v14.var1.fRef);
  }
  return a1;
}

void sub_1003B7F5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  uint64_t v18 = *(void *)(v13 + 1392);
  *(void *)(v13 + 1392) = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  sub_10002B28C(v13 + 1240);
  sub_10002B1A8(v13 + 1136);
  sub_10002B1F4(v13 + 1000);
  sub_10002B1A8(v13 + 896);
  sub_10002B240(v13 + 800);
  if (*(unsigned char *)(v13 + 792) && *(char *)(v13 + 759) < 0) {
    operator delete(*(void **)(v13 + 736));
  }
  sub_10002B2D8(v13 + 608);
  sub_1000440D4((const void **)(v13 + 600));
  unint64_t v19 = *(std::__shared_weak_count **)(v13 + 592);
  if (v19) {
    sub_10004D2C8(v19);
  }
  sub_10003E3AC(v16);
  unint64_t v20 = *(std::__shared_weak_count **)(v13 + 56);
  if (v20) {
    sub_10004D2C8(v20);
  }
  ctu::OsLogLogger::~OsLogLogger(v15);
  sub_100087E88(v14);
  CellMonitorModelInterface::~CellMonitorModelInterface((CellMonitorModelInterface *)v13);
  _Unwind_Resume(a1);
}

void sub_1003B8090(uint64_t a1)
{
  sub_100BB7734(a1);
  uint64_t v5 = _NSConcreteStackBlock;
  uint64_t v6 = 0x40000000;
  unint64_t v7 = sub_1003B8158;
  char v8 = &unk_1019C4740;
  uint64_t v9 = a1;
  uint64_t v2 = os_state_add_handler();
  *(void *)(a1 + 1424) = v2;
  if (!v2)
  {
    unint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Could not add state capture handler", v4, 2u);
    }
  }
}

char *sub_1003B8158(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 16);
  if (v3 != 3)
  {
    uint64_t v13 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(error[0]) = 67109120;
      HIDWORD(error[0]) = v3;
      OsLogContext v14 = "#I Skipping state handler for %d";
      uint64_t v15 = v13;
      uint32_t v16 = 8;
LABEL_16:
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)error, v16);
    }
    return 0;
  }
  int v4 = *(const void **)(v2 + 600);
  if (v4) {
    uint64_t v5 = sub_100289354;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v5)
  {
    xpc_object_t v17 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(error[0]) = 0;
      OsLogContext v14 = "#I No current cells found";
      uint64_t v15 = v17;
      uint32_t v16 = 2;
      goto LABEL_16;
    }
    return 0;
  }
  CFErrorRef err = 0;
  error[0] = 0;
  error[1] = (CFErrorRef)&err;
  CFDataRef Data = CFPropertyListCreateData(0, v4, kCFPropertyListBinaryFormat_v1_0, 0, error);
  CFDataRef theData = Data;
  sub_100128064((const void **)error);
  if (Data) {
    unint64_t v7 = sub_10008324C;
  }
  else {
    unint64_t v7 = 0;
  }
  if (v7)
  {
    size_t Length = CFDataGetLength(Data);
    uint64_t v9 = (char *)malloc_type_calloc(1uLL, Length + 200, 0x477558C3uLL);
    uint64_t v10 = v9;
    *(_DWORD *)uint64_t v9 = 1;
    *((_DWORD *)v9 + 1) = Length;
    uint64_t v11 = *(int *)(v2 + 64);
    if (v11 > 3) {
      xpc_object_t v12 = "CellMonitorModel.1";
    }
    else {
      xpc_object_t v12 = off_1019C4910[v11];
    }
    strlcpy(v9 + 136, v12, 0x40uLL);
    BytePtr = CFDataGetBytePtr(theData);
    memcpy(v10 + 200, BytePtr, Length);
  }
  else
  {
    CFStringRef v24 = CFErrorCopyDescription(err);
    uint64_t v18 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      error[0] = 0;
      error[1] = 0;
      uint64_t v30 = 0;
      ctu::cf::assign();
      *(_OWORD *)long long __p = *(_OWORD *)error;
      uint64_t v23 = v30;
      char v21 = __p;
      if (v30 < 0) {
        char v21 = (void **)error[0];
      }
      *(_DWORD *)long long buf = 136315138;
      long long v28 = v21;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not convert current cells to serialized CF representation: %s", buf, 0xCu);
      if (SHIBYTE(v23) < 0) {
        operator delete(__p[0]);
      }
    }
    sub_1000558F4((const void **)&v24);
    uint64_t v10 = 0;
  }
  sub_100030068((const void **)&theData);
  sub_100127D74((const void **)&err);
  return v10;
}

void sub_1003B83F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, const void *a13, const void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a12);
  sub_100030068(&a13);
  sub_100127D74(&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_1003B8444(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 1424);
  if (result)
  {
    uint64_t result = os_state_remove_handler();
    *(void *)(a1 + 1424) = 0;
  }
  return result;
}

const void **sub_1003B8474(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = 0;
  sub_100068EFC(&v18, 0);
  sub_100057278(&v18, kCTRegistrationLac, *(unsigned __int16 *)(a2 + 74));
  sub_100057278(&v18, kCTRegistrationCellId, *(unsigned __int16 *)(a2 + 76));
  if (*(unsigned char *)(a1 + 72)) {
    CFBooleanRef v4 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v4 = kCFBooleanFalse;
  }
  sub_10005856C(&v18, kCTRegistrationInHomeCountry, v4);
  if (*(unsigned char *)(a1 + 1385)) {
    CFBooleanRef v5 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v5 = kCFBooleanFalse;
  }
  sub_10005856C(&v18, kCTRegistrationIsFemtoCell, v5);
  sub_1000571B0(&v18, (const void **)&v16);
  ctu::cf_to_xpc((uint64_t *)&object, v16, v6);
  xpc_object_t v7 = object;
  if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v7 = xpc_null_create();
  }
  xpc_release(object);
  xpc_object_t object = 0;
  sub_10005717C((const void **)&v16);
  uint64_t v15 = v7;
  if (v7)
  {
    xpc_retain(v7);
    xpc_object_t v8 = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    uint64_t v15 = v8;
  }
  sub_1000066F0((os_log_t *)(a1 + 40), (uint64_t)"GSM cell changed", &v15);
  xpc_release(v8);
  uint64_t v15 = 0;
  uint64_t v9 = *(unsigned int *)(a1 + 64);
  if (v9 == 1)
  {
    xpc_object_t object = v7;
    if (v7)
    {
      xpc_retain(v7);
      xpc_object_t v10 = v7;
    }
    else
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t object = v10;
    }
    uint64_t v11 = (ctu *)xpc_null_create();
    uint32_t v16 = v11;
    sub_1000452AC(43, &object, (xpc_object_t *)&v16);
    xpc_release(v11);
    xpc_release(v10);
    uint64_t v9 = *(unsigned int *)(a1 + 64);
  }
  uint64_t v12 = *(void *)(a1 + 1408);
  xpc_object_t v14 = v7;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v14 = xpc_null_create();
  }
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(*(void *)v12 + 80))(v12, v9, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_release(v7);
  return sub_10005717C(&v18);
}

void sub_1003B86B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, char a12, uint64_t a13, const void *a14)
{
  xpc_release(v16);
  xpc_release(v15);
  xpc_release(v14);
  sub_10005717C(&a14);
  _Unwind_Resume(a1);
}

const void **sub_1003B8760(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = 0;
  sub_100068EFC(&v18, 2);
  sub_100057278(&v18, kCTRegistrationLac, *(unsigned __int16 *)(a2 + 74));
  sub_100057010(&v18, kCTRegistrationCellId, *(_DWORD *)(a2 + 76));
  if (*(unsigned char *)(a1 + 72)) {
    CFBooleanRef v4 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v4 = kCFBooleanFalse;
  }
  sub_10005856C(&v18, kCTRegistrationInHomeCountry, v4);
  if (*(unsigned char *)(a1 + 1385)) {
    CFBooleanRef v5 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v5 = kCFBooleanFalse;
  }
  sub_10005856C(&v18, kCTRegistrationIsFemtoCell, v5);
  sub_1000571B0(&v18, (const void **)&v16);
  ctu::cf_to_xpc((uint64_t *)&object, v16, v6);
  xpc_object_t v7 = object;
  if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v7 = xpc_null_create();
  }
  xpc_release(object);
  xpc_object_t object = 0;
  sub_10005717C((const void **)&v16);
  uint64_t v15 = v7;
  if (v7)
  {
    xpc_retain(v7);
    xpc_object_t v8 = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    uint64_t v15 = v8;
  }
  sub_1000066F0((os_log_t *)(a1 + 40), (uint64_t)"UMTS cell changed", &v15);
  xpc_release(v8);
  uint64_t v15 = 0;
  uint64_t v9 = *(unsigned int *)(a1 + 64);
  if (v9 == 1)
  {
    xpc_object_t object = v7;
    if (v7)
    {
      xpc_retain(v7);
      xpc_object_t v10 = v7;
    }
    else
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t object = v10;
    }
    uint64_t v11 = (ctu *)xpc_null_create();
    uint32_t v16 = v11;
    sub_1000452AC(43, &object, (xpc_object_t *)&v16);
    xpc_release(v11);
    xpc_release(v10);
    uint64_t v9 = *(unsigned int *)(a1 + 64);
  }
  uint64_t v12 = *(void *)(a1 + 1408);
  xpc_object_t v14 = v7;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v14 = xpc_null_create();
  }
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(*(void *)v12 + 80))(v12, v9, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_release(v7);
  return sub_10005717C(&v18);
}

void sub_1003B89A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, char a12, uint64_t a13, const void *a14)
{
  xpc_release(v16);
  xpc_release(v15);
  xpc_release(v14);
  sub_10005717C(&a14);
  _Unwind_Resume(a1);
}

const void **sub_1003B8A4C(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = 0;
  sub_100068EFC(&v18, 9);
  sub_100057278(&v18, kCTRegistrationLac, *(unsigned __int16 *)(a2 + 74));
  sub_100057010(&v18, kCTRegistrationCellId, *(_DWORD *)(a2 + 76));
  if (*(unsigned char *)(a1 + 72)) {
    CFBooleanRef v4 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v4 = kCFBooleanFalse;
  }
  sub_10005856C(&v18, kCTRegistrationInHomeCountry, v4);
  if (*(unsigned char *)(a1 + 1385)) {
    CFBooleanRef v5 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v5 = kCFBooleanFalse;
  }
  sub_10005856C(&v18, kCTRegistrationIsFemtoCell, v5);
  sub_1000571B0(&v18, (const void **)&v16);
  ctu::cf_to_xpc((uint64_t *)&object, v16, v6);
  xpc_object_t v7 = object;
  if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v7 = xpc_null_create();
  }
  xpc_release(object);
  xpc_object_t object = 0;
  sub_10005717C((const void **)&v16);
  uint64_t v15 = v7;
  if (v7)
  {
    xpc_retain(v7);
    xpc_object_t v8 = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    uint64_t v15 = v8;
  }
  sub_1000066F0((os_log_t *)(a1 + 40), (uint64_t)"EVDO cell changed", &v15);
  xpc_release(v8);
  uint64_t v15 = 0;
  uint64_t v9 = *(unsigned int *)(a1 + 64);
  if (v9 == 1)
  {
    xpc_object_t object = v7;
    if (v7)
    {
      xpc_retain(v7);
      xpc_object_t v10 = v7;
    }
    else
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t object = v10;
    }
    uint64_t v11 = (ctu *)xpc_null_create();
    uint32_t v16 = v11;
    sub_1000452AC(43, &object, (xpc_object_t *)&v16);
    xpc_release(v11);
    xpc_release(v10);
    uint64_t v9 = *(unsigned int *)(a1 + 64);
  }
  uint64_t v12 = *(void *)(a1 + 1408);
  xpc_object_t v14 = v7;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v14 = xpc_null_create();
  }
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(*(void *)v12 + 80))(v12, v9, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_release(v7);
  return sub_10005717C(&v18);
}

void sub_1003B8C90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, char a12, uint64_t a13, const void *a14)
{
  xpc_release(v16);
  xpc_release(v15);
  xpc_release(v14);
  sub_10005717C(&a14);
  _Unwind_Resume(a1);
}

const void **sub_1003B8D38(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = 0;
  sub_100068EFC(&v18, 3);
  sub_100057278(&v18, kCTRegistrationC2KSystemId, *(unsigned __int16 *)(a2 + 76));
  sub_100057278(&v18, kCTRegistrationC2KNetworkId, *(unsigned __int16 *)(a2 + 78));
  sub_100057278(&v18, kCTRegistrationC2KBaseId, *(unsigned __int16 *)(a2 + 80));
  sub_100056F3C(&v18, kCTRegistrationC2KBaseLat, *(_DWORD *)(a2 + 84));
  sub_100056F3C(&v18, kCTRegistrationC2KBaseLong, *(_DWORD *)(a2 + 88));
  if (*(unsigned char *)(a1 + 72)) {
    CFBooleanRef v4 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v4 = kCFBooleanFalse;
  }
  sub_10005856C(&v18, kCTRegistrationInHomeCountry, v4);
  if (*(unsigned char *)(a1 + 1385)) {
    CFBooleanRef v5 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v5 = kCFBooleanFalse;
  }
  sub_10005856C(&v18, kCTRegistrationIsFemtoCell, v5);
  sub_1000571B0(&v18, (const void **)&v16);
  ctu::cf_to_xpc((uint64_t *)&object, v16, v6);
  xpc_object_t v7 = object;
  if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v7 = xpc_null_create();
  }
  xpc_release(object);
  xpc_object_t object = 0;
  sub_10005717C((const void **)&v16);
  uint64_t v15 = v7;
  if (v7)
  {
    xpc_retain(v7);
    xpc_object_t v8 = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    uint64_t v15 = v8;
  }
  sub_1000066F0((os_log_t *)(a1 + 40), (uint64_t)"1x cell changed", &v15);
  xpc_release(v8);
  uint64_t v15 = 0;
  uint64_t v9 = *(unsigned int *)(a1 + 64);
  if (v9 == 1)
  {
    xpc_object_t object = v7;
    if (v7)
    {
      xpc_retain(v7);
      xpc_object_t v10 = v7;
    }
    else
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t object = v10;
    }
    uint64_t v11 = (ctu *)xpc_null_create();
    uint32_t v16 = v11;
    sub_1000452AC(43, &object, (xpc_object_t *)&v16);
    xpc_release(v11);
    xpc_release(v10);
    uint64_t v9 = *(unsigned int *)(a1 + 64);
  }
  uint64_t v12 = *(void *)(a1 + 1408);
  xpc_object_t v14 = v7;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v14 = xpc_null_create();
  }
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(*(void *)v12 + 80))(v12, v9, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_release(v7);
  return sub_10005717C(&v18);
}

void sub_1003B8FC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, char a12, uint64_t a13, const void *a14)
{
  xpc_release(v16);
  xpc_release(v15);
  xpc_release(v14);
  sub_10005717C(&a14);
  _Unwind_Resume(a1);
}

const void **sub_1003B906C(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = 0;
  sub_100068EFC(&v18, 10);
  sub_100057010(&v18, kCTRegistrationLac, *(_DWORD *)(a2 + 76));
  sub_1003BA948(&v18, kCTRegistrationCellId, *(const __CFNumber **)(a2 + 80));
  if (*(unsigned char *)(a1 + 72)) {
    CFBooleanRef v4 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v4 = kCFBooleanFalse;
  }
  sub_10005856C(&v18, kCTRegistrationInHomeCountry, v4);
  if (*(unsigned char *)(a1 + 1385)) {
    CFBooleanRef v5 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v5 = kCFBooleanFalse;
  }
  sub_10005856C(&v18, kCTRegistrationIsFemtoCell, v5);
  sub_1000571B0(&v18, (const void **)&v16);
  ctu::cf_to_xpc((uint64_t *)&object, v16, v6);
  xpc_object_t v7 = object;
  if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v7 = xpc_null_create();
  }
  xpc_release(object);
  xpc_object_t object = 0;
  sub_10005717C((const void **)&v16);
  uint64_t v15 = v7;
  if (v7)
  {
    xpc_retain(v7);
    xpc_object_t v8 = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    uint64_t v15 = v8;
  }
  sub_1000066F0((os_log_t *)(a1 + 40), (uint64_t)"NR Cell changed", &v15);
  xpc_release(v8);
  uint64_t v15 = 0;
  uint64_t v9 = *(unsigned int *)(a1 + 64);
  if (v9 == 1)
  {
    xpc_object_t object = v7;
    if (v7)
    {
      xpc_retain(v7);
      xpc_object_t v10 = v7;
    }
    else
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t object = v10;
    }
    uint64_t v11 = (ctu *)xpc_null_create();
    uint32_t v16 = v11;
    sub_1000452AC(43, &object, (xpc_object_t *)&v16);
    xpc_release(v11);
    xpc_release(v10);
    uint64_t v9 = *(unsigned int *)(a1 + 64);
  }
  uint64_t v12 = *(void *)(a1 + 1408);
  xpc_object_t v14 = v7;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v14 = xpc_null_create();
  }
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(*(void *)v12 + 80))(v12, v9, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_release(v7);
  return sub_10005717C(&v18);
}

void sub_1003B92B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, char a12, uint64_t a13, const void *a14)
{
  xpc_release(v16);
  xpc_release(v15);
  xpc_release(v14);
  sub_10005717C(&a14);
  _Unwind_Resume(a1);
}

unint64_t sub_1003B9358(uint64_t a1)
{
  unint64_t v2 = 0;
  switch(*(_DWORD *)(a1 + 68))
  {
    case 0:
      uint64_t v5 = CellInfoUpdate::getCollection<GsmCell>();
      if (!*(unsigned char *)(a1 + 888)) {
        goto LABEL_10;
      }
      uint64_t v6 = a1 + 800;
      goto LABEL_12;
    case 2:
      uint64_t v5 = CellInfoUpdate::getCollection<UmtsCell>();
      if (!*(unsigned char *)(a1 + 992)) {
        goto LABEL_10;
      }
      uint64_t v6 = a1 + 896;
      goto LABEL_12;
    case 7:
    case 8:
      uint64_t v3 = CellInfoUpdate::getCollection<LteCell>();
      if (!*(unsigned char *)(a1 + 1128)) {
        goto LABEL_15;
      }
      uint64_t v4 = a1 + 1000;
      goto LABEL_17;
    case 9:
      uint64_t v5 = CellInfoUpdate::getCollection<TDSCDMACell>();
      if (*(unsigned char *)(a1 + 1232))
      {
        uint64_t v6 = a1 + 1136;
LABEL_12:
        unint64_t v2 = *(unsigned __int16 *)(v6 + 74);
        goto LABEL_19;
      }
LABEL_10:
      if (*(unsigned char *)(v5 + 24))
      {
        uint64_t v6 = *(void *)v5;
        if (*(void *)v5 != *(void *)(v5 + 8)) {
          goto LABEL_12;
        }
      }
      goto LABEL_18;
    case 0xA:
      uint64_t v3 = CellInfoUpdate::getCollection<NrCell>();
      if (*(unsigned char *)(a1 + 1376))
      {
        uint64_t v4 = a1 + 1240;
LABEL_17:
        unint64_t v2 = *(unsigned int *)(v4 + 76);
        goto LABEL_19;
      }
LABEL_15:
      if (*(unsigned char *)(v3 + 24))
      {
        uint64_t v4 = *(void *)v3;
        if (*(void *)v3 != *(void *)(v3 + 8)) {
          goto LABEL_17;
        }
      }
LABEL_18:
      unint64_t v2 = 0;
LABEL_19:
      xpc_object_t v7 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        std::to_string(&v13, v2);
        int v8 = SHIBYTE(v13.__r_.__value_.__r.__words[2]);
        std::string::size_type v9 = v13.__r_.__value_.__r.__words[0];
        uint64_t v10 = asString();
        uint64_t v11 = &v13;
        if (v8 < 0) {
          uint64_t v11 = (std::string *)v9;
        }
        *(_DWORD *)long long buf = 136315394;
        uint64_t v15 = v11;
        __int16 v16 = 2080;
        uint64_t v17 = v10;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Returning Area code: %s, current RAT is set to %s", buf, 0x16u);
        if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v13.__r_.__value_.__l.__data_);
        }
      }
      return v2;
    default:
      goto LABEL_19;
  }
}

void sub_1003B9530(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1003B9580(uint64_t a1)
{
  unint64_t v2 = 0;
  switch(*(_DWORD *)(a1 + 68))
  {
    case 0:
      uint64_t v5 = CellInfoUpdate::getCollection<GsmCell>();
      if (*(unsigned char *)(a1 + 888))
      {
        uint64_t v6 = a1 + 800;
      }
      else
      {
        if (!*(unsigned char *)(v5 + 24)) {
          goto LABEL_26;
        }
        uint64_t v6 = *(void *)v5;
        if (*(void *)v5 == *(void *)(v5 + 8)) {
          goto LABEL_26;
        }
      }
      unint64_t v2 = *(unsigned __int16 *)(v6 + 76);
      goto LABEL_27;
    case 2:
      uint64_t v7 = CellInfoUpdate::getCollection<UmtsCell>();
      if (!*(unsigned char *)(a1 + 992)) {
        goto LABEL_18;
      }
      uint64_t v8 = a1 + 896;
      goto LABEL_20;
    case 7:
    case 8:
      uint64_t v3 = CellInfoUpdate::getCollection<LteCell>();
      if (*(unsigned char *)(a1 + 1128))
      {
        uint64_t v4 = a1 + 1000;
LABEL_4:
        unint64_t v2 = *(unsigned int *)(v4 + 80);
        goto LABEL_27;
      }
      if (*(unsigned char *)(v3 + 24))
      {
        uint64_t v4 = *(void *)v3;
        if (*(void *)v3 != *(void *)(v3 + 8)) {
          goto LABEL_4;
        }
      }
      goto LABEL_26;
    case 9:
      uint64_t v7 = CellInfoUpdate::getCollection<TDSCDMACell>();
      if (*(unsigned char *)(a1 + 1232))
      {
        uint64_t v8 = a1 + 1136;
LABEL_20:
        unint64_t v2 = *(unsigned int *)(v8 + 76);
        goto LABEL_27;
      }
LABEL_18:
      if (*(unsigned char *)(v7 + 24))
      {
        uint64_t v8 = *(void *)v7;
        if (*(void *)v7 != *(void *)(v7 + 8)) {
          goto LABEL_20;
        }
      }
      goto LABEL_26;
    case 0xA:
      uint64_t v9 = CellInfoUpdate::getCollection<NrCell>();
      if (*(unsigned char *)(a1 + 1376))
      {
        uint64_t v10 = a1 + 1240;
LABEL_14:
        unint64_t v2 = *(void *)(v10 + 80);
        goto LABEL_27;
      }
      if (*(unsigned char *)(v9 + 24))
      {
        uint64_t v10 = *(void *)v9;
        if (*(void *)v9 != *(void *)(v9 + 8)) {
          goto LABEL_14;
        }
      }
LABEL_26:
      unint64_t v2 = 0;
LABEL_27:
      uint64_t v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        std::to_string(&v17, v2);
        int v12 = SHIBYTE(v17.__r_.__value_.__r.__words[2]);
        std::string::size_type v13 = v17.__r_.__value_.__r.__words[0];
        uint64_t v14 = asString();
        uint64_t v15 = &v17;
        if (v12 < 0) {
          uint64_t v15 = (std::string *)v13;
        }
        *(_DWORD *)long long buf = 136315394;
        unint64_t v19 = v15;
        __int16 v20 = 2080;
        uint64_t v21 = v14;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Returning Cell ID: %s, current RAT is set to %s", buf, 0x16u);
        if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v17.__r_.__value_.__l.__data_);
        }
      }
      return v2;
    default:
      goto LABEL_27;
  }
}

void sub_1003B978C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003B97DC(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 68);
  if (v2 != 5 && v2 != 3) {
    goto LABEL_11;
  }
  if (*(unsigned char *)(a1 + 712))
  {
    uint64_t v4 = *(unsigned __int16 *)(a1 + 688);
    goto LABEL_14;
  }
  *(_OWORD *)long long __p = 0u;
  long long v13 = 0u;
  uint64_t v5 = CellInfoUpdate::getCollection<Cdma1xCell>();
  sub_100043508((uint64_t)__p, v5);
  if (BYTE8(v13))
  {
    if (__p[0] == __p[1]) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = *((unsigned __int16 *)__p[0] + 40);
    }
    *(void *)long long buf = __p;
    sub_1003A02B8((void ***)buf);
  }
  else
  {
LABEL_11:
    uint64_t v4 = 0;
  }
LABEL_14:
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    std::to_string((std::string *)__p, v4);
    int v7 = SBYTE7(v13);
    uint64_t v8 = (void **)__p[0];
    uint64_t v9 = asString();
    uint64_t v10 = __p;
    if (v7 < 0) {
      uint64_t v10 = v8;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v10;
    __int16 v15 = 2080;
    uint64_t v16 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Returning Base ID: %s, current RAT is set to %s", buf, 0x16u);
    if (SBYTE7(v13) < 0) {
      operator delete(__p[0]);
    }
  }
  return v4;
}

void sub_1003B9944(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003B9994(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 72);
  if (v2 != a2)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = "true";
      if (v2) {
        int v7 = "true";
      }
      else {
        int v7 = "false";
      }
      if (!a2) {
        uint64_t v6 = "false";
      }
      int v8 = 136315394;
      uint64_t v9 = v7;
      __int16 v10 = 2080;
      uint64_t v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I In home country changing from %s to %s", (uint8_t *)&v8, 0x16u);
    }
    *(unsigned char *)(a1 + 72) = a2;
  }
}

void sub_1003B9A78(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 584);
  if (a2[2])
  {
    uint64_t v3 = (int *)(a2 + 1);
    uint64_t v4 = (int *)*a2;
    if ((void *)*a2 != a2 + 1)
    {
      do
      {
        uint64_t v5 = *((void *)v4 + 5);
        uint64_t v12 = 0;
        uint64_t v6 = sub_1003BA42C(v2, &v12, v4 + 8);
        int v7 = (uint64_t *)*v6;
        if (!*v6)
        {
          int v8 = (uint64_t **)v6;
          int v7 = (uint64_t *)operator new(0x30uLL);
          void v7[4] = *((void *)v4 + 4);
          v7[5] = 0;
          sub_100046C38((uint64_t **)v2, v12, v8, v7);
        }
        v7[5] = v5;
        uint64_t v9 = (int *)*((void *)v4 + 1);
        if (v9)
        {
          do
          {
            __int16 v10 = v9;
            uint64_t v9 = *(int **)v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            __int16 v10 = (int *)*((void *)v4 + 2);
            BOOL v11 = *(void *)v10 == (void)v4;
            uint64_t v4 = v10;
          }
          while (!v11);
        }
        uint64_t v4 = v10;
      }
      while (v10 != v3);
    }
  }
  else
  {
    sub_1000346F8(*(void *)(a1 + 584), *(void **)(v2 + 8));
    *(void *)uint64_t v2 = v2 + 8;
    *(void *)(v2 + 16) = 0;
    *(void *)(v2 + 8) = 0;
  }
}

const void **sub_1003B9B7C(uint64_t a1, int a2, MCC *a3, MNC *a4, const __CFNumber *a5, const __CFNumber *a6)
{
  uint64_t v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = asString();
    __int16 v34 = 1024;
    Intint Value = MCC::getIntValue(a3);
    __int16 v36 = 1024;
    int IntegerWidth = MNC::getIntegerWidth(a4);
    __int16 v38 = 1024;
    int v39 = MCC::getIntValue(a4);
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I LASD %s cells detected for %03d-%0.*d", buf, 0x1Eu);
  }
  CFMutableDictionaryRef v32 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v14 = v32;
    CFMutableDictionaryRef v32 = Mutable;
    *(void *)long long buf = v14;
    sub_10005717C((const void **)buf);
  }
  long long v31 = 0;
  __int16 v15 = sub_100879E78(a2);
  sub_100058500(&v31, v15, @"kCTCellMonitorCellTypeDetected");
  unsigned int v16 = MCC::getIntValue(a3);
  sub_100057278(&v31, @"kCTCellMonitorMCC", v16);
  unsigned int v17 = MCC::getIntValue(a4);
  sub_100057278(&v31, @"kCTCellMonitorMNC", v17);
  BOOL v18 = a2 == 10 || a2 == 7;
  unint64_t v19 = kCTCellMonitorTAC;
  if (!v18) {
    unint64_t v19 = kCTCellMonitorLAC;
  }
  sub_1003BA948(&v31, *v19, a5);
  sub_1003BA948(&v31, @"kCTCellMonitorCellId", a6);
  __int16 v20 = (CFTypeRef *)(a1 + 600);
  if (*(void *)(a1 + 600)) {
    uint64_t v21 = sub_100289354;
  }
  else {
    uint64_t v21 = 0;
  }
  if (!v21)
  {
    CFMutableArrayRef v22 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFTypeRef v23 = *v20;
    CFTypeRef *v20 = v22;
    *(void *)long long buf = v23;
    sub_1000440D4((const void **)buf);
  }
  sub_1000585CC(&v31, (CFArrayRef *)(a1 + 600));
  uint64_t v24 = *(unsigned int *)(a1 + 64);
  if (v24 == 1)
  {
    xpc_object_t v25 = xpc_null_create();
    *(void *)long long buf = v25;
    xpc_object_t v26 = xpc_null_create();
    xpc_object_t v30 = v26;
    sub_1000452AC(61, (xpc_object_t *)buf, &v30);
    xpc_release(v26);
    xpc_release(v25);
    uint64_t v24 = *(unsigned int *)(a1 + 64);
  }
  uint64_t v27 = *(void *)(a1 + 1408);
  sub_100044D6C(&v29, v20);
  (*(void (**)(uint64_t, uint64_t, const void **))(*(void *)v27 + 88))(v27, v24, &v29);
  sub_100044D00(&v29);
  sub_10005717C(&v31);
  return sub_10005717C((const void **)&v32);
}

void sub_1003B9E74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  sub_10005717C((const void **)va);
  sub_10005717C((const void **)va1);
  _Unwind_Resume(a1);
}

time_t sub_1003B9EEC(uint64_t a1, unsigned __int16 **a2, unsigned __int8 **a3, unsigned __int16 **a4, unsigned __int16 **a5, unsigned __int16 **a6, unsigned __int16 **a7, unsigned __int16 **a8)
{
  sub_100BB8004(a1, a2, a3, a4, a5, a6, a7, a8);
  time_t result = time(0);
  *(void *)(a1 + 1400) = result;
  return result;
}

uint64_t sub_1003B9F1C(uint64_t a1)
{
  uint64_t v2 = (const ctu::OsLogLogger *)(a1 + 40);
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315138;
    uint64_t v8 = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Current RAT: %s", (uint8_t *)&v7, 0xCu);
    uint64_t v3 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "true";
    if (!*(unsigned char *)(a1 + 72)) {
      uint64_t v4 = "false";
    }
    int v7 = 136315138;
    uint64_t v8 = (uint64_t)v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I In home country: %s", (uint8_t *)&v7, 0xCu);
    uint64_t v3 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 1400);
    int v7 = 134217984;
    uint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Time of last bulk hints: %ld", (uint8_t *)&v7, 0xCu);
  }
  return CellInfoUpdate::dumpState((CellInfoUpdate *)(a1 + 80), v2);
}

void sub_1003BA088(uint64_t a1)
{
  sub_1003BA4A8(a1);

  operator delete();
}

uint64_t sub_1003BA0C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      *(_WORD *)a3 = *(_WORD *)v5;
      MCC::operator=();
      MCC::operator=();
      long long v6 = *(_OWORD *)(v5 + 82);
      *(_OWORD *)(a3 + 72) = *(_OWORD *)(v5 + 72);
      *(_OWORD *)(a3 + 82) = v6;
      a3 += 104;
      v5 += 104;
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t sub_1003BA13C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      *(_WORD *)a3 = *(_WORD *)v5;
      MCC::operator=();
      long long v6 = *(_OWORD *)(v5 + 54);
      *(_OWORD *)(a3 + 40) = *(_OWORD *)(v5 + 40);
      *(_OWORD *)(a3 + 54) = v6;
      a3 += 72;
      v5 += 72;
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t sub_1003BA1AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      *(_WORD *)a3 = *(_WORD *)v5;
      MCC::operator=();
      MCC::operator=();
      int v6 = *(_DWORD *)(v5 + 88);
      *(_OWORD *)(a3 + 72) = *(_OWORD *)(v5 + 72);
      *(_DWORD *)(a3 + 88) = v6;
      a3 += 96;
      v5 += 96;
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t sub_1003BA228(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      *(_WORD *)a3 = *(_WORD *)v5;
      MCC::operator=();
      MCC::operator=();
      *(_OWORD *)(a3 + 72) = *(_OWORD *)(v5 + 72);
      a3 += 88;
      v5 += 88;
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t sub_1003BA29C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      *(_WORD *)a3 = *(_WORD *)v5;
      MCC::operator=();
      MCC::operator=();
      long long v6 = *(_OWORD *)(v5 + 88);
      long long v7 = *(_OWORD *)(v5 + 104);
      long long v8 = *(_OWORD *)(v5 + 116);
      *(_OWORD *)(a3 + 72) = *(_OWORD *)(v5 + 72);
      *(_OWORD *)(a3 + 116) = v8;
      *(_OWORD *)(a3 + 104) = v7;
      *(_OWORD *)(a3 + 88) = v6;
      a3 += 136;
      v5 += 136;
    }
    while (v5 != a2);
  }
  return a3;
}

char *sub_1003BA328(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  long long v7 = result;
  unint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (uint64_t)(v8 - *(void *)result) >> 1)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      sub_10006A748();
    }
    if (v8 <= a4) {
      unint64_t v10 = a4;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v8 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v11 = v10;
    }
    time_t result = sub_1003A115C(v7, v11);
    long long v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_17:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      BOOL v18 = v9;
      unint64_t v19 = __src;
      goto LABEL_19;
    }
    goto LABEL_20;
  }
  uint64_t v12 = (void **)(result + 8);
  CFMutableDictionaryRef v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 1;
  if (v15 >= a4) {
    goto LABEL_17;
  }
  unsigned int v16 = &__src[2 * v15];
  if (v14 != v9)
  {
    time_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    BOOL v18 = v9;
    unint64_t v19 = v16;
LABEL_19:
    time_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_20:
  NSObject *v12 = &v9[v17];
  return result;
}

uint64_t *sub_1003BA42C(uint64_t a1, void *a2, int *a3)
{
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  time_t result = (uint64_t *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    int v6 = *a3;
    int v7 = a3[1];
    while (1)
    {
      unint64_t v8 = v4;
      int v9 = *((_DWORD *)v4 + 8);
      if (v6 == v9)
      {
        int v10 = *((_DWORD *)v8 + 9);
        if (v7 >= v10)
        {
          BOOL v11 = v10 == v7;
          if (v10 >= v7) {
            char v12 = 1;
          }
          else {
            char v12 = -1;
          }
          if (v11) {
            char v12 = 0;
          }
          if ((v12 & 0x80) == 0) {
            goto LABEL_22;
          }
          goto LABEL_19;
        }
LABEL_13:
        uint64_t v4 = (uint64_t *)*v8;
        time_t result = v8;
        if (!*v8) {
          goto LABEL_22;
        }
      }
      else
      {
        if (v6 < v9) {
          goto LABEL_13;
        }
        if (v9 >= v6) {
          char v13 = 1;
        }
        else {
          char v13 = -1;
        }
        if ((v13 & 0x80) == 0) {
          goto LABEL_22;
        }
LABEL_19:
        time_t result = v8 + 1;
        uint64_t v4 = (uint64_t *)v8[1];
        if (!v4) {
          goto LABEL_22;
        }
      }
    }
  }
  unint64_t v8 = result;
LABEL_22:
  *a2 = v8;
  return result;
}

void sub_1003BA4A8(uint64_t a1)
{
  *(void *)a1 = off_1019C46B8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 1416);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(void *)(a1 + 1392);
  *(void *)(a1 + 1392) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  sub_10002B28C(a1 + 1240);
  sub_10002B1A8(a1 + 1136);
  sub_10002B1F4(a1 + 1000);
  sub_10002B1A8(a1 + 896);
  sub_10002B240(a1 + 800);
  if (*(unsigned char *)(a1 + 792) && *(char *)(a1 + 759) < 0) {
    operator delete(*(void **)(a1 + 736));
  }
  sub_10002B2D8(a1 + 608);
  sub_1000440D4((const void **)(a1 + 600));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 592);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10003E3AC(a1 + 80);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  CellMonitorModelInterface::~CellMonitorModelInterface((CellMonitorModelInterface *)a1);
}

void sub_1003BA5B8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1003BA638(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003BA674(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1003BA6AC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1003BA6DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1003BA720(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019C48B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1003BA740(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019C48B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1003BA794(uint64_t a1)
{
}

uint64_t sub_1003BA7A8(uint64_t a1, uint64_t a2)
{
  uint64_t result = MCC::operator==();
  if (result)
  {
    uint64_t result = MCC::operator==();
    if (result) {
      return *(unsigned __int16 *)(a1 + 74) == *(unsigned __int16 *)(a2 + 74)
    }
          && *(unsigned __int16 *)(a1 + 76) == *(unsigned __int16 *)(a2 + 76);
  }
  return result;
}

uint64_t sub_1003BA814(uint64_t a1, uint64_t a2)
{
  uint64_t result = MCC::operator==();
  if (result)
  {
    uint64_t result = MCC::operator==();
    if (result) {
      return *(unsigned __int16 *)(a1 + 74) == *(unsigned __int16 *)(a2 + 74)
    }
          && *(_DWORD *)(a1 + 76) == *(_DWORD *)(a2 + 76);
  }
  return result;
}

BOOL sub_1003BA880(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int16 *)(a1 + 76) == *(unsigned __int16 *)(a2 + 76)
      && *(unsigned __int16 *)(a1 + 78) == *(unsigned __int16 *)(a2 + 78)
      && *(unsigned __int16 *)(a1 + 80) == *(unsigned __int16 *)(a2 + 80)
      && *(_DWORD *)(a1 + 84) == *(_DWORD *)(a2 + 84)
      && *(_DWORD *)(a1 + 88) == *(_DWORD *)(a2 + 88);
}

uint64_t sub_1003BA8DC(uint64_t a1, uint64_t a2)
{
  uint64_t result = MCC::operator==();
  if (result)
  {
    uint64_t result = MCC::operator==();
    if (result) {
      return *(_DWORD *)(a1 + 76) == *(_DWORD *)(a2 + 76) && *(void *)(a1 + 80) == *(void *)(a2 + 80);
    }
  }
  return result;
}

const void **sub_1003BA948(const void **a1, const void *a2, const __CFNumber *a3)
{
  CFNumberRef v11 = 0;
  CFNumberRef valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v5)
  {
    CFNumberRef v6 = v11;
    CFNumberRef v11 = v5;
    CFNumberRef valuePtr = v6;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v7 = v11;
  CFNumberRef v10 = v11;
  CFNumberRef v11 = 0;
  sub_1000570E8((const void **)&v11);
  CFNumberRef v9 = v7;
  if (v7) {
    CFRetain(v7);
  }
  sub_10005711C(a1, a2, (const void **)&v9);
  sub_1000577C4((const void **)&v9);
  return sub_1000570E8((const void **)&v10);
}

void sub_1003BA9F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void sub_1003BB028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v12);
  }

  _Unwind_Resume(a1);
}

void sub_1003BBFDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, uint64_t a13, uint64_t a14, xpc_object_t object, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,xpc_object_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,xpc_object_t a43,char a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,uint64_t a50)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

xpc_object_t *sub_1003BC2B8(xpc_object_t *a1, xpc_object_t object)
{
  *a1 = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    *a1 = xpc_null_create();
  }
  return a1;
}

void sub_1003BCCB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (a23) {
    sub_10004D2C8(a23);
  }
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  if ((a11 & 1) == 0) {
    sub_10004D2C8(v25);
  }

  _Unwind_Resume(a1);
}

void sub_1003BD594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v12);
  }

  _Unwind_Resume(a1);
}

void sub_1003BDE04(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t a6, ...)
{
  va_start(va, a6);

  sub_100057D78((const void **)va);
  if (a3) {
    sub_10004D2C8(a3);
  }
  if (a5) {
    sub_10004D2C8(a5);
  }
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }

  _Unwind_Resume(a1);
}

void sub_1003BE580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1003BE6A8(uint64_t a1)
{
  return a1;
}

void sub_1003BE6D4(uint64_t a1)
{
  operator delete();
}

void *sub_1003BE720(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019C4940;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1003BE778(uint64_t a1, void *a2)
{
  *a2 = off_1019C4940;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1003BE7C0(uint64_t a1)
{
}

void sub_1003BE7C8(id *a1)
{
  operator delete(a1);
}

void sub_1003BE804(uint64_t a1, unsigned __int8 *a2)
{
  id v26 = (id)objc_opt_new();
  [v26 setIsReady:*a2];
  uint64_t v4 = (unsigned __int8 *)*((void *)a2 + 1);
  int v5 = (char)a2[31];
  NSStringEncoding v6 = +[NSString defaultCStringEncoding];
  if (v5 >= 0) {
    CFNumberRef v7 = a2 + 8;
  }
  else {
    CFNumberRef v7 = v4;
  }
  unint64_t v8 = +[NSString stringWithCString:v7 encoding:v6];
  [v26 setImsi:v8];

  CFNumberRef v9 = (unsigned __int8 *)*((void *)a2 + 4);
  int v10 = (char)a2[55];
  NSStringEncoding v11 = +[NSString defaultCStringEncoding];
  if (v10 >= 0) {
    char v12 = a2 + 32;
  }
  else {
    char v12 = v9;
  }
  char v13 = +[NSString stringWithCString:v12 encoding:v11];
  [v26 setPlmn:v13];

  CFMutableDictionaryRef v14 = (unsigned __int8 *)*((void *)a2 + 7);
  int v15 = (char)a2[79];
  NSStringEncoding v16 = +[NSString defaultCStringEncoding];
  if (v15 >= 0) {
    size_t v17 = a2 + 56;
  }
  else {
    size_t v17 = v14;
  }
  BOOL v18 = +[NSString stringWithCString:v17 encoding:v16];
  [v26 setPhoneNumber:v18];

  uint64_t v21 = (unsigned __int8 *)*((void *)a2 + 10);
  unint64_t v19 = a2 + 80;
  __int16 v20 = v21;
  int v22 = (char)v19[23];
  NSStringEncoding v23 = +[NSString defaultCStringEncoding];
  if (v22 >= 0) {
    uint64_t v24 = v19;
  }
  else {
    uint64_t v24 = v20;
  }
  xpc_object_t v25 = +[NSString stringWithCString:v24 encoding:v23];
  [v26 setPhoneNumberOnSIM:v25];

  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_1003BE99C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1003BE9D0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019C49B0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1003BEA10()
{
  return &off_1019C49B0;
}

void *sub_1003BEA1C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void DataConnectionAgentCarrierSpace::setPolicyOverride(DataConnectionAgentCarrierSpace *this)
{
  if (!*((void *)this + 40))
  {
    uint64_t v2 = +[DataConnectionNetworkAgent agentDomain];
    uint64_t v3 = +[DataConnectionNetworkAgentCarrierSpace agentType];
    id v4 = [objc_alloc((Class)NEPathControllerNetworkAgent) initWithAdvisoryAgentDomain:v2 agentType:v3 advisoryMode:3];
    int v5 = (void *)*((void *)this + 40);
    *((void *)this + 40) = v4;

    [*((id *)this + 40) setActive:1];
    [*((id *)this + 40) setVoluntary:0];
    [*((id *)this + 40) setUserActivated:0];
    [*((id *)this + 40) setKernelActivated:0];
    NSStringEncoding v6 = +[NSUUID UUID];
    [*((id *)this + 40) setAgentUUID:v6];

    CFNumberRef v7 = *((void *)this + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v8 = [*((id *)this + 40) agentUUID];
      id v9 = [v8 UUIDString];
      *(_DWORD *)uint64_t v33 = 134217984;
      *(void *)&v33[4] = [v9 UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I created fallback agent : {%publics}", v33, 0xCu);
    }
  }
  if (!*((void *)this + 41))
  {
    id v10 = [objc_alloc((Class)NWNetworkAgentRegistration) initWithNetworkAgentClass:objc_opt_class()];
    NSStringEncoding v11 = (void *)*((void *)this + 41);
    *((void *)this + 41) = v10;

    unsigned int v12 = [*((id *)this + 41) registerNetworkAgent:*((void *)this + 40)];
    char v13 = *((void *)this + 8);
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    if (v12)
    {
      if (!v14) {
        goto LABEL_12;
      }
      *(_WORD *)uint64_t v33 = 0;
      int v15 = "#I registered fallback agent";
    }
    else
    {
      if (!v14) {
        goto LABEL_12;
      }
      *(_WORD *)uint64_t v33 = 0;
      int v15 = "#N fallback agent registration failed";
    }
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v15, v33, 2u);
  }
LABEL_12:
  if (!*((void *)this + 42))
  {
    id v16 = kCTCarrierSpaceConnectionAccountIdentifier;
    size_t v17 = +[NEPolicyCondition accountIdentifier:v16];
    BOOL v18 = [*((id *)this + 40) agentUUID];
    unint64_t v19 = +[NEPolicyResult netAgentUUID:v18];

    id v20 = objc_alloc((Class)NEPolicy);
    __int16 v36 = v17;
    uint64_t v21 = +[NSArray arrayWithObjects:&v36 count:1];
    id v22 = [v20 initWithOrder:10 result:v19 conditions:v21];

    id v23 = objc_alloc_init((Class)NEPolicySession);
    uint64_t v24 = (void *)*((void *)this + 42);
    *((void *)this + 42) = v23;

    [*((id *)this + 42) setPriority:301];
    [*((id *)this + 42) addPolicy:v22];
    if (([*((id *)this + 42) apply] & 1) == 0)
    {
      xpc_object_t v25 = *((void *)this + 8);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v33 = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#N policy apply failed", v33, 2u);
      }
    }
    id v26 = *((void *)this + 8);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      long long v29 = (id *)*((void *)this + 18);
      long long v28 = (id *)((char *)this + 144);
      char v27 = v29;
      if (*((char *)v28 + 23) >= 0) {
        xpc_object_t v30 = v28;
      }
      else {
        xpc_object_t v30 = v27;
      }
      objc_msgSend(v28[24], "description", *(void *)v33);
      id v31 = objc_claimAutoreleasedReturnValue();
      id v32 = [v31 UTF8String];
      *(_DWORD *)uint64_t v33 = 136446466;
      *(void *)&v33[4] = v30;
      __int16 v34 = 2080;
      id v35 = v32;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I registered fallback policy uuid %{public}s, session %s", v33, 0x16u);
    }
  }
}

void sub_1003BEE98(_Unwind_Exception *a1)
{
  NSStringEncoding v6 = v1;

  _Unwind_Resume(a1);
}

uint64_t sub_1003BEF38(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1003BEF68(Registry *a1@<X0>, void *a2@<X8>)
{
  unsigned int v12 = 0;
  char v13 = 0;
  Registry::get((uint64_t *)&v12, a1);
  if (v12)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v12);
    id v4 = ServiceMap;
    if ((v5 & 0x8000000000000000) != 0)
    {
      NSStringEncoding v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v7 = 5381;
      do
      {
        unint64_t v5 = v7;
        unsigned int v8 = *v6++;
        uint64_t v7 = (33 * v7) ^ v8;
      }
      while (v8);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v14 = v5;
    id v9 = sub_10004D37C(&v4[1].__m_.__sig, &v14);
    if (v9)
    {
      uint64_t v11 = v9[3];
      id v10 = (std::__shared_weak_count *)v9[4];
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
    }
    else
    {
      uint64_t v11 = 0;
      id v10 = 0;
    }
    std::mutex::unlock(v4);
    *a2 = v11;
    a2[1] = v10;
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_1003BF058(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void createPlatformPropertyStore(void *a1@<X8>)
{
  memset(&v2, 0, sizeof(v2));
  stat("/Library/Preferences/csidata", &v2);
  *a1 = 0;
  operator new();
}

void sub_1003BF124()
{
}

void sub_1003BF148()
{
  byte_101B13D88 = 1;
  long long v0 = (std::__shared_weak_count *)*((void *)&xmmword_101B0CD80 + 1);
  xmmword_101B0CD80 = 0uLL;
  if (v0) {
    sub_10004D2C8(v0);
  }
  v1[0] = 0;
  v1[1] = 0;
  Registry::get(v1, (Registry *)v0);
  sGetLogGroupName();
  operator new();
}

void sub_1003BF570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ctu::OsLogLogger *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1003BF60C()
{
  if ((byte_101B09D70 & 1) == 0)
  {
    byte_101B09D70 = 1;
    return __cxa_atexit((void (*)(void *))sub_100160564, &stru_101B09D20, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1003BF648()
{
  __cxa_atexit((void (*)(void *))sub_1003BEF38, &xmmword_101B0CD80, (void *)&_mh_execute_header);
  WirelessUserDirectory = (char *)_GetWirelessUserDirectory();
  sub_100058DB0(&v4, WirelessUserDirectory);
  uint64_t v1 = std::string::append(&v4, "/Library/Preferences/csidata", 0x1CuLL);
  long long v2 = *(_OWORD *)&v1->__r_.__value_.__l.__data_;
  unk_101B13D80 = *((void *)&v1->__r_.__value_.__l + 2);
  xmmword_101B13D70 = v2;
  v1->__r_.__value_.__l.__size_ = 0;
  v1->__r_.__value_.__r.__words[2] = 0;
  v1->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v4.__r_.__value_.__l.__data_);
  }
  return __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_101B13D70, (void *)&_mh_execute_header);
}

void sub_1003BF708(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003BF724(uint64_t a1, char *a2, unint64_t a3, char *a4)
{
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_DWORD *)(a1 + 64) = 1065353216;
  *(void *)a1 = off_1019C49D0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  sub_1003BF7D0((unint64_t *)a1, a2, a3);
  if (a4) {
    sub_100CCA5A0(a1, a4);
  }
  return a1;
}

void sub_1003BF7AC(_Unwind_Exception *a1)
{
  std::string v4 = *v2;
  if (*v2)
  {
    v1[10] = v4;
    operator delete(v4);
  }
  sub_100CC9A2C(v1);
  _Unwind_Resume(a1);
}

void sub_1003BF7D0(unint64_t *a1, char *a2, unint64_t a3)
{
  a1[12] = a3;
  NSStringEncoding v6 = a1 + 9;
  sub_1003BF988(a1 + 9, a3 + 1);
  sub_1003C08A4(v6, a2, &a2[a3], a3);
  unsigned int v8 = (unsigned char *)a1[10];
  unint64_t v7 = a1[11];
  if ((unint64_t)v8 >= v7)
  {
    unint64_t v10 = *v6;
    uint64_t v11 = &v8[-*v6];
    unint64_t v12 = (unint64_t)(v11 + 1);
    if ((uint64_t)(v11 + 1) < 0) {
      sub_100205700();
    }
    unint64_t v13 = v7 - v10;
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v14 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v14 = v12;
    }
    if (v14) {
      unint64_t v15 = (unint64_t)operator new(v14);
    }
    else {
      unint64_t v15 = 0;
    }
    id v16 = (char *)(v15 + v14);
    v11[v15] = 0;
    uint64_t v9 = (uint64_t)&v11[v15 + 1];
    if (v8 == (unsigned char *)v10)
    {
      v15 += (unint64_t)v11;
    }
    else
    {
      size_t v17 = &v8[~v10];
      do
      {
        char v18 = *--v8;
        (v17--)[v15] = v18;
      }
      while (v8 != (unsigned char *)v10);
      unsigned int v8 = (unsigned char *)*v6;
    }
    a1[9] = v15;
    a1[10] = v9;
    a1[11] = (unint64_t)v16;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    unsigned char *v8 = 0;
    uint64_t v9 = (uint64_t)(v8 + 1);
  }
  a1[10] = v9;
}

void *sub_1003BF8EC(void *a1)
{
  *a1 = off_1019C49D0;
  long long v2 = (void *)a1[9];
  if (v2)
  {
    a1[10] = v2;
    operator delete(v2);
  }

  return sub_100CC9A2C(a1);
}

void sub_1003BF950(void *a1)
{
  sub_1003BF8EC(a1);

  operator delete();
}

void sub_1003BF988(unint64_t *a1, size_t __sz)
{
  unint64_t v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000) != 0) {
      sub_100205700();
    }
    unint64_t v5 = (char *)a1[1];
    NSStringEncoding v6 = operator new(__sz);
    unint64_t v7 = &v5[(void)v6 - v2];
    unsigned int v8 = v7;
    if (v5 != (char *)v2)
    {
      uint64_t v9 = &v5[~v2];
      do
      {
        char v10 = *--v5;
        (v9--)[(void)v6] = v10;
      }
      while (v5 != (char *)v2);
      unsigned int v8 = v6;
    }
    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2)
    {
      operator delete((void *)v2);
    }
  }
}

uint64_t sub_1003BFA44(const std::string *a1)
{
  uint64_t result = sub_1003BFC4C();
  uint64_t v3 = *(unsigned __int8 *)(result + 23);
  if ((v3 & 0x80u) == 0) {
    uint64_t v4 = *(unsigned __int8 *)(result + 23);
  }
  else {
    uint64_t v4 = *(void *)(result + 8);
  }
  std::string::size_type size = HIBYTE(a1->__r_.__value_.__r.__words[2]);
  int v6 = (char)size;
  if ((size & 0x80u) != 0) {
    std::string::size_type size = a1->__r_.__value_.__l.__size_;
  }
  if (v4 != size) {
    goto LABEL_16;
  }
  if (v6 >= 0) {
    unint64_t v7 = a1;
  }
  else {
    unint64_t v7 = (const std::string *)a1->__r_.__value_.__r.__words[0];
  }
  if ((v3 & 0x80) != 0)
  {
    uint64_t result = memcmp(*(const void **)result, v7, *(void *)(result + 8));
    if (result) {
      goto LABEL_16;
    }
  }
  else if (*(unsigned char *)(result + 23))
  {
    while (*(unsigned __int8 *)result == v7->__r_.__value_.__s.__data_[0])
    {
      ++result;
      unint64_t v7 = (const std::string *)((char *)v7 + 1);
      if (!--v3) {
        return result;
      }
    }
LABEL_16:
    if (qword_101B14178 != -1) {
      dispatch_once(&qword_101B14178, &stru_101A84F28);
    }
    unsigned int v8 = qword_101B14170;
    if (os_log_type_enabled((os_log_t)qword_101B14170, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = sub_1003BFC4C();
      if (*(char *)(v9 + 23) >= 0) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = *(void *)v9;
      }
      if ((a1->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v11 = a1;
      }
      else {
        uint64_t v11 = (const std::string *)a1->__r_.__value_.__r.__words[0];
      }
      int v16 = 136315394;
      uint64_t v17 = v10;
      __int16 v18 = 2080;
      unint64_t v19 = v11;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Old Version: [%s], new version: [%s]", (uint8_t *)&v16, 0x16u);
    }
    unint64_t v12 = (std::string *)sub_1003BFC4C();
    std::string::operator=(v12, a1);
    if (qword_101B14178 != -1) {
      dispatch_once(&qword_101B14178, &stru_101A84F28);
    }
    unint64_t v13 = qword_101B14170;
    if (os_log_type_enabled((os_log_t)qword_101B14170, OS_LOG_TYPE_INFO))
    {
      uint64_t v14 = sub_1003BFC4C();
      if (*(char *)(v14 + 23) >= 0) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = *(void *)v14;
      }
      int v16 = 136315138;
      uint64_t v17 = v15;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "Version now: [%s]", (uint8_t *)&v16, 0xCu);
    }
    sub_1003BFD04();
  }
  return result;
}

uint64_t sub_1003BFC4C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CDA0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0CDA0))
  {
    operator new();
  }
  return qword_101B0CD98;
}

void sub_1003BFCCC()
{
}

void sub_1003BFD04()
{
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  *(_OWORD *)uint64_t v17 = 0u;
  long long v18 = 0u;
  memset(v16, 0, sizeof(v16));
  long long v0 = (const std::string *)sub_1003BFC4C();
  sub_1003C09B4((void (__cdecl ***)(std::istringstream *__hidden))v16, v0, 8);
  uint64_t v15 = 0;
  memset(&__p, 0, sizeof(__p));
  char v30 = 0;
  std::istream::sentry::sentry();
  if (!v30) {
    goto LABEL_23;
  }
  __p.__r_.__value_.__s.__data_[0] = 0;
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
  uint64_t v1 = (const std::ios_base *)((char *)v16 + *(void *)(*(void *)&v16[0] - 24));
  uint64_t width = v1->__width_;
  if (width <= 1) {
    uint64_t v3 = 1;
  }
  else {
    uint64_t v3 = v1->__width_;
  }
  std::ios_base::getloc(v1);
  uint64_t v4 = std::locale::use_facet(&v29, &std::ctype<char>::id);
  std::locale::~locale(&v29);
  uint64_t v5 = 0;
  if (width >= 1) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = 0x7FFFFFFFFFFFFFF7;
  }
  while (1)
  {
    unint64_t v7 = *(void **)((char *)&v16[2] + *(void *)(*(void *)&v16[0] - 24) + 8);
    unsigned int v8 = (unsigned char *)v7[3];
    if (v8 == (unsigned char *)v7[4])
    {
      int v9 = (*(uint64_t (**)(void *))(*v7 + 72))(v7);
      if (v9 == -1)
      {
        int v12 = 2;
LABEL_20:
        uint64_t v13 = *(void *)&v16[0];
        *(void *)((char *)&v16[1] + *(void *)(*(void *)&v16[0] - 24) + 8) = 0;
        if (!v5) {
          v12 |= 4u;
        }
        std::ios_base::clear((std::ios_base *)((char *)v16 + *(void *)(v13 - 24)), *(_DWORD *)((char *)&v16[2] + *(void *)(v13 - 24)) | v12);
LABEL_23:
        std::istream::operator>>();
        operator new();
      }
    }
    else
    {
      LOBYTE(v9) = *v8;
    }
    if ((v9 & 0x80) == 0 && (*((_DWORD *)&v4[1].~facet + v9) & 0x4000) != 0)
    {
      int v12 = 0;
      goto LABEL_20;
    }
    std::string::push_back(&__p, v9);
    uint64_t v10 = *(void **)((char *)&v16[2] + *(void *)(*(void *)&v16[0] - 24) + 8);
    uint64_t v11 = v10[3];
    if (v11 == v10[4]) {
      (*(void (**)(void *))(*v10 + 80))(v10);
    }
    else {
      void v10[3] = v11 + 1;
    }
    if (v6 == ++v5)
    {
      int v12 = 0;
      uint64_t v5 = 1;
      goto LABEL_20;
    }
  }
}

void sub_1003C0448(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16)
{
  std::locale::~locale((std::locale *)(v16 - 80));
  __cxa_begin_catch(a1);
  uint64_t v18 = a16;
  *(_DWORD *)((char *)&a16 + *(void *)(a16 - 24) + 32) |= 1u;
  if ((*((unsigned char *)&a16 + *(void *)(v18 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x1003BFF14);
  }
  __cxa_rethrow();
}

void sub_1003C0548(_Unwind_Exception *a1, void *a2, uint64_t a3, int a4, __int16 a5, char a6, char a7, uint64_t a8, ...)
{
  va_start(va, a8);
  __cxa_end_catch();
  if (a7 < 0) {
    operator delete(a2);
  }
  sub_1003C0B38((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1003C0558()
{
}

uint64_t sub_1003C0580()
{
  uint64_t result = qword_101B0CD90;
  if (!qword_101B0CD90) {
    sub_1003BFD04();
  }
  return result;
}

uint64_t sub_1003C05B0@<X0>(std::string *a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v23 = 0;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  *(_OWORD *)uint64_t v11 = 0u;
  memset(v10, 0, sizeof(v10));
  sub_10004DE24((uint64_t)v10);
  sub_100CCA77C(a1, a2, 0, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v10, (uint64_t)p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_10004BC98((uint64_t)v10 + 8, a3);
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_1003C0760(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

void *sub_1003C0790@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = sub_100CCA3B0(a1, "Content-Type");
  if (!v4)
  {
    unint64_t v7 = "\t** no Content-Type header\n";
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 96) > 0x9Fu) {
    goto LABEL_5;
  }
  uint64_t v5 = *(void *)(v4 + 24);
  if (!v5) {
    goto LABEL_5;
  }
  uint64_t v6 = (const char *)(*(uint64_t (**)(void))(*(void *)v5 + 16))(*(void *)(v4 + 24));
  if (strcmp(v6, "text")) {
    goto LABEL_5;
  }
  uint64_t v9 = sub_100CCA3B0(v5 + 8, "charset");
  uint64_t v10 = (int *)(v9 + 20);
  if (!v9) {
    uint64_t v10 = (int *)&unk_1015989E4;
  }
  int v11 = *v10;
  if (v11)
  {
    if (v11 != 106 && v11 != 3)
    {
LABEL_5:
      unint64_t v7 = "Body content invalid";
LABEL_7:
      return sub_100058DB0(a2, v7);
    }
  }
  long long v13 = *(void **)(a1 + 72);
  size_t v14 = *(unsigned int *)(a1 + 96);

  return sub_1000D95C8(a2, v13, v14);
}

void *sub_1003C08A4(void *result, char *__src, char *a3, unint64_t a4)
{
  unint64_t v7 = result;
  unint64_t v8 = result[2];
  uint64_t v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      sub_100205700();
    }
    uint64_t v10 = 2 * v8;
    if (2 * v8 <= a4) {
      uint64_t v10 = a4;
    }
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    uint64_t result = sub_10022E748(v7, v11);
    uint64_t v9 = (char *)v7[1];
    goto LABEL_17;
  }
  long long v12 = (unsigned char *)result[1];
  size_t v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    size_t v16 = a3 - __src;
    if (v16) {
      uint64_t result = memmove(v9, __src, v16);
    }
    long long v15 = &v9[v16];
    goto LABEL_20;
  }
  size_t v14 = &__src[v13];
  if (v12 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v13);
    uint64_t v9 = (char *)v7[1];
  }
  if (a3 != v14) {
    uint64_t result = memmove(v9, v14, a3 - v14);
  }
  long long v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

void (__cdecl ***sub_1003C09B4(void (__cdecl ***a1)(std::istringstream *__hidden this), const std::string *a2, int a3))(std::istringstream *__hidden this)
{
  uint64_t v6 = (uint64_t)(a1 + 2);
  *a1 = v8;
  *(void *)((char *)*(v8 - 3) + (void)a1) = v7;
  a1[1] = 0;
  uint64_t v9 = (std::ios_base *)((char *)*(*a1 - 3) + (void)a1);
  std::ios_base::init(v9, a1 + 2);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  sub_1003C0C3C(v6, a2, a3 | 8);
  return a1;
}

void sub_1003C0B10(_Unwind_Exception *a1)
{
}

uint64_t sub_1003C0B38(uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  std::streambuf::~streambuf();
  std::istream::~istream();
  std::ios::~ios();
  return a1;
}

uint64_t sub_1003C0C3C(uint64_t a1, const std::string *a2, int a3)
{
  uint64_t v6 = std::streambuf::basic_streambuf();
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_DWORD *)(v6 + 96) = a3;
  std::string::operator=((std::string *)(v6 + 64), a2);
  sub_100146140(a1);
  return a1;
}

void sub_1003C0CB8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 87) < 0) {
    operator delete(*v2);
  }
  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

uint64_t sub_1003C0CE4@<X0>(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = (long long *)(a1 + 8);
  uint64_t v6 = (long long *)(a1 + 40);
  unint64_t v7 = (long long *)(a1 + 72);
  int v8 = *(_DWORD *)(a1 + 32);
  int v15 = *(_DWORD *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 96);
  int v10 = *(unsigned __int8 *)(a1 + 104);
  size_t v11 = (char *)operator new(0x118uLL);
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  *(void *)size_t v11 = off_1019C4AF8;
  long long v12 = v11 + 24;
  uint64_t result = sub_1005812B8((uint64_t)(v11 + 24), a2, v5, v8, v6, v7, v9);
  *((void *)v11 + 3) = off_1019DCD58;
  *((_DWORD *)v11 + 62) = v15;
  v11[252] = v10 != 0;
  *((_OWORD *)v11 + 16) = xmmword_1014970B0;
  v11[272] = 2;
  if (*(unsigned char *)(a1 + 120))
  {
    *((void *)v11 + 33) = *(void *)(a1 + 108);
    v11[272] = *(unsigned char *)(a1 + 116);
  }
  *((_DWORD *)v11 + 65) = *(_DWORD *)(a1 + 124);
  if (*(unsigned char *)(a1 + 132)) {
    uint64_t result = (uint64_t)sub_10050AD48(v12, *(_DWORD *)(a1 + 128));
  }
  *a3 = v12;
  a3[1] = v11;
  return result;
}

void sub_1003C0E38(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1003C0E60()
{
  return 1;
}

uint64_t sub_1003C0E68(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

void sub_1003C0E70(uint64_t a1)
{
  uint64_t v8 = 0;
  long long v6 = 0u;
  long long v7 = 0u;
  uint64_t v1 = *(void *)(a1 + 16);
  int v2 = *(_DWORD *)(a1 + 24) - v1;
  int v3 = *(_DWORD *)(a1 + 8);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v6, "com.apple.telephony", "msg.mms.pdu");
  HIDWORD(v7) = 106;
  LOWORD(v8) = 1;
  BYTE2(v8) = 1;
  HIDWORD(v8) = v3;
  *((void *)&v6 + 1) = v1;
  LODWORD(v7) = v2;
  *(void *)((char *)&v7 + 4) = 0x6A00000000;
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  sub_100FEEFA8();
}

void sub_1003C1058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, ...)
{
  va_start(va, a11);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1003C10EC()
{
  return 2;
}

uint64_t sub_1003C10F4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_1003C10FC(uint64_t a1)
{
  *(void *)a1 = off_1019C4A58;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1003C116C(uint64_t a1)
{
  *(void *)a1 = off_1019C4A58;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

void *sub_1003C11FC(void *a1)
{
  *a1 = off_1019C4AA8;
  int v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1003C1258(void *a1)
{
  *a1 = off_1019C4AA8;
  int v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }

  operator delete();
}

void sub_1003C12D4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4AF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1003C12F4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4AF8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1003C1348(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1003C1370(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  if (*a3) {
    dispatch_retain(*a3);
  }
  sub_1008C416C(&v4);
}

void sub_1003C1410(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (v12) {
    dispatch_release(v12);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003C143C@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = (capabilities::ct *)capabilities::ct::supportsSIMProvisioningAsSignupSource(a1);
  if ((v3 & 1) != 0
    || (uint64_t result = capabilities::ct::supportsSIMProvisioningAsSignupDestination(v3), result))
  {
    *a2 = 0;
    a2[1] = 0;
    operator new();
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void sub_1003C1744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_1003C187C(uint64_t a1)
{
  *(void *)a1 = off_1019C4DF0;
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 104);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 64);
  if (v5) {
    sub_10004D2C8(v5);
  }
  long long v6 = *(NSObject **)(a1 + 48);
  if (v6) {
    dispatch_release(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_1003C1954(uint64_t a1)
{
  sub_1003C187C(a1);

  operator delete();
}

void sub_1003C198C(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1003C1A58(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_1003C1BA4(uint64_t a1)
{
  return *(_DWORD *)(a1 + 168) >> 17 > 2u;
}

void *sub_1003C1BB8(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_1001A1088(result, a4);
    uint64_t result = (void *)sub_1003C1C40((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1003C1C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1002B2AEC(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1003C1C40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_1003C1CC4((char *)(a4 + v7), (long long *)(a2 + v7));
      v7 += 64;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1003C1CA0(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 64;
    do
    {
      sub_1002B2A44(v4 + v2);
      v2 -= 64;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1003C1CC4(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  *((_WORD *)__dst + 12) = *((_WORD *)a2 + 12);
  uint64_t v5 = __dst + 32;
  if (*((char *)a2 + 55) < 0)
  {
    sub_10004FC84(v5, *((void **)a2 + 4), *((void *)a2 + 5));
  }
  else
  {
    long long v6 = a2[2];
    *((void *)__dst + 6) = *((void *)a2 + 6);
    *(_OWORD *)uint64_t v5 = v6;
  }
  int v7 = *((_DWORD *)a2 + 14);
  __dst[60] = *((unsigned char *)a2 + 60);
  *((_DWORD *)__dst + 14) = v7;
  return __dst;
}

void sub_1003C1D58(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003C1D74(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1003C1DCC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1003C1E04(uint64_t a1)
{
}

uint64_t sub_1003C1E20(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1003C1E64(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1003C1E90(ServiceManager::Service *this)
{
  *(void *)this = off_1019C4F48;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1003C1EEC(ServiceManager::Service *this)
{
  *(void *)this = off_1019C4F48;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1003C1F5C@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "CarrierBundleIDSUtility");
}

unsigned char *sub_1003C1F6C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1003C1FAC(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1003C198C(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_1003C198C(v4, 0);
}

uint64_t sub_1003C2030()
{
  return 0;
}

uint64_t sub_1003C2038()
{
  return 1;
}

uint64_t sub_1003C2040()
{
  return 0;
}

void sub_1003C204C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_1003C2130(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 24);
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = *(NSObject **)(v1 + 8);
    if (v3)
    {
      dispatch_group_leave(v3);
      uint64_t v4 = *(NSObject **)(v1 + 8);
      if (v4) {
        dispatch_release(v4);
      }
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1003C219C(uint64_t a1)
{
  uint64_t v16 = a1;
  uint64_t v1 = *(void *)a1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(*(void *)a1 + 72));
  uint64_t v3 = ServiceMap;
  uint64_t v4 = "38CellularPlanIDSServiceManagerInterface";
  if (((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = (const char *)v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  long long v18 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v18);
  if (!v8)
  {
    uint64_t v10 = 0;
    goto LABEL_8;
  }
  uint64_t v10 = v8[3];
  uint64_t v9 = (std::__shared_weak_count *)v8[4];
  if (!v9)
  {
LABEL_8:
    std::mutex::unlock(v3);
    uint64_t v9 = 0;
    char v11 = 1;
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
LABEL_9:
  (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v10 + 16))(buf, v10);
  long long v12 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  size_t v13 = *(std::__shared_weak_count **)(v1 + 104);
  *(_OWORD *)(v1 + 96) = v12;
  if (v13)
  {
    sub_10004D2C8(v13);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (!*(void *)(v1 + 96))
  {
    size_t v14 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#E fIDSService is not found", buf, 2u);
    }
  }
  return sub_1003C2130(&v16);
}

void sub_1003C2314(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  char v4 = v3;
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  sub_1003C2130((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1003C2344(void **a1)
{
  uint64_t v1 = (void *)**a1;
  if (!v1[12]) {
    goto LABEL_20;
  }
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (!v2 || (uint64_t v3 = v1[1], (v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v4);
  uint64_t v20 = 0;
  unsigned int v7 = (capabilities::ct *)capabilities::ct::supportsSIMProvisioningAsSignupSource(v6);
  if (v7)
  {
    uint64_t v8 = 3264;
    uint64_t v20 = 3264;
  }
  else
  {
    uint64_t v8 = 1088;
  }
  if (capabilities::ct::supportsSIMProvisioningAsSignupDestination(v7)) {
    uint64_t v20 = v8;
  }
  uint64_t v9 = v1[12];
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 0x40000000;
  v19[2] = sub_1003C2608;
  v19[3] = &unk_1019C4FB8;
  _OWORD v19[4] = v1;
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 1174405120;
  v17[2] = sub_1003C261C;
  v17[3] = &unk_1019C4FD8;
  void v17[4] = v1;
  void v17[5] = v3;
  long long v18 = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 1174405120;
  void v15[2] = sub_1003C27E0;
  v15[3] = &unk_1019C5008;
  void v15[4] = v1;
  v15[5] = v3;
  uint64_t v16 = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  int v10 = (*(uint64_t (**)(uint64_t, const char *, uint64_t *, void *, void *, void *))(*(void *)v9 + 24))(v9, "CarrierBundleIDSUtility", &v20, v19, v17, v15);
  char v11 = v1[5];
  BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if (v10)
  {
    if (v12)
    {
      *(_WORD *)long long buf = 0;
      size_t v13 = "#I Successfully registered CellularPlanIDSService callbacks";
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v13, buf, 2u);
    }
  }
  else if (v12)
  {
    *(_WORD *)long long buf = 0;
    size_t v13 = "#E Failed to register the CellularPlanIDSService callbacks";
    goto LABEL_14;
  }
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  if (v18) {
    std::__shared_weak_count::__release_weak(v18);
  }
  std::__shared_weak_count::__release_weak(v5);
LABEL_20:
  operator delete();
}

void sub_1003C25AC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  if (a19) {
    std::__shared_weak_count::__release_weak(a19);
  }
  if (a26) {
    std::__shared_weak_count::__release_weak(a26);
  }
  std::__shared_weak_count::__release_weak(v26);
  operator delete();
}

BOOL sub_1003C2608(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 56) >> 17 > 2u;
}

void sub_1003C261C(void *a1, uint64_t *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[5])
      {
        uint64_t v7 = *a2;
        uint64_t v8 = a2[1];
        memset(v10, 0, sizeof(v10));
        sub_1003C1BB8(v10, v7, v8, (v8 - v7) >> 6);
        uint64_t v9 = *(std::__shared_weak_count **)(v5 + 16);
        if (v9)
        {
          if (std::__shared_weak_count::lock(v9)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1003C279C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1003C27B4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1003C27D0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1003C27E0(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[5])
      {
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(v8, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
          void v8[2] = *(void **)(a2 + 16);
        }
        if (*(char *)(a2 + 47) < 0)
        {
          sub_10004FC84(__p, *(void **)(a2 + 24), *(void *)(a2 + 32));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 24);
          __p[2] = *(void **)(a2 + 40);
        }
        __int16 v10 = *(_WORD *)(a2 + 48);
        sub_10002FD9C(&v11, (const void **)(a2 + 56));
        sub_100119B5C(&v12, (const void **)(a2 + 64));
        *(void *)&v13[6] = *(void *)(a2 + 78);
        *(void *)size_t v13 = *(void *)(a2 + 72);
        uint64_t v7 = *(std::__shared_weak_count **)(v5 + 16);
        if (v7)
        {
          if (std::__shared_weak_count::lock(v7)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1003C2A90(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (*(char *)(v17 + 31) < 0) {
    operator delete(*v18);
  }
  sub_10006A6AC(a1);
}

uint64_t *sub_1003C2AE4(void **a1)
{
  uint64_t v1 = *a1;
  BOOL v12 = a1;
  size_t v13 = v1;
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v4 = v1[2];
  if (v2 != v4)
  {
    while (!*(unsigned char *)(v2 + 24))
    {
      v2 += 64;
      if (v2 == v4) {
        goto LABEL_14;
      }
    }
  }
  if (v2 == v4)
  {
LABEL_14:
    __int16 v10 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N No device in proxmity", buf, 2u);
    }
  }
  else
  {
    uint64_t v5 = (void *)(v3 + 112);
    std::string::operator=((std::string *)(v3 + 112), (const std::string *)v2);
    *(_WORD *)(v3 + 136) = *(_WORD *)(v2 + 24);
    std::string::operator=((std::string *)(v3 + 144), (const std::string *)(v2 + 32));
    int v6 = *(_DWORD *)(v2 + 56);
    *(unsigned char *)(v3 + 172) = *(unsigned char *)(v2 + 60);
    *(_DWORD *)(v3 + 168) = v6;
    uint64_t v7 = *(NSObject **)(v3 + 40);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      if (*(char *)(v3 + 135) < 0) {
        uint64_t v5 = (void *)*v5;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Device with ID %s is in proximity", buf, 0xCu);
    }
    if (capabilities::ct::supportsSIMProvisioningAsSignupSource((capabilities::ct *)v8))
    {
      uint64_t v9 = *(std::__shared_weak_count **)(v3 + 16);
      if (v9 && std::__shared_weak_count::lock(v9)) {
        operator new();
      }
      sub_100088B9C();
    }
  }
  sub_1003C2D34((uint64_t *)&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_1003C2D04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1003C2D34(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    uint64_t v2 = (void **)(v1 + 8);
    sub_1002B2AEC(&v2);
    operator delete();
  }
  return result;
}

uint64_t *sub_1003C2D94(capabilities::ct *a1)
{
  uint64_t v1 = *(void *)a1;
  int v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void *)v1;
  if (capabilities::ct::supportsSIMProvisioningAsSignupDestination(a1))
  {
    uint64_t v3 = (long long *)(v1 + 8);
    int v4 = sub_100BCCF58(v1 + 8);
    if (v4)
    {
      if (v4 == 2)
      {
        *(void *)long long buf = v2;
        if (*(char *)(v1 + 31) < 0)
        {
          sub_10004FC84(&buf[8], *(void **)(v1 + 8), *(void *)(v1 + 16));
        }
        else
        {
          long long v6 = *v3;
          uint64_t v18 = *(void *)(v1 + 24);
          *(_OWORD *)&uint8_t buf[8] = v6;
        }
        if (*(char *)(v1 + 55) < 0)
        {
          sub_10004FC84(&__p, *(void **)(v1 + 32), *(void *)(v1 + 40));
        }
        else
        {
          long long v8 = *(_OWORD *)(v1 + 32);
          uint64_t v20 = *(void *)(v1 + 48);
          long long __p = v8;
        }
        __int16 v21 = *(_WORD *)(v1 + 56);
        sub_10002FD9C(&v22, (const void **)(v1 + 64));
        sub_100119B5C(&v23, (const void **)(v1 + 72));
        uint64_t v10 = *(void *)(v1 + 80);
        *(void *)&v24[6] = *(void *)(v1 + 86);
        *(void *)long long v24 = v10;
        char v11 = *(std::__shared_weak_count **)(v2 + 16);
        if (v11 && std::__shared_weak_count::lock(v11)) {
          operator new();
        }
        sub_100088B9C();
      }
      if (v4 == 1)
      {
        *(void *)long long buf = v2;
        if (*(char *)(v1 + 31) < 0)
        {
          sub_10004FC84(&buf[8], *(void **)(v1 + 8), *(void *)(v1 + 16));
        }
        else
        {
          long long v5 = *v3;
          uint64_t v18 = *(void *)(v1 + 24);
          *(_OWORD *)&uint8_t buf[8] = v5;
        }
        if (*(char *)(v1 + 55) < 0)
        {
          sub_10004FC84(&__p, *(void **)(v1 + 32), *(void *)(v1 + 40));
        }
        else
        {
          long long v9 = *(_OWORD *)(v1 + 32);
          uint64_t v20 = *(void *)(v1 + 48);
          long long __p = v9;
        }
        __int16 v21 = *(_WORD *)(v1 + 56);
        sub_10002FD9C(&v22, (const void **)(v1 + 64));
        sub_100119B5C(&v23, (const void **)(v1 + 72));
        uint64_t v12 = *(void *)(v1 + 80);
        *(void *)&v24[6] = *(void *)(v1 + 86);
        *(void *)long long v24 = v12;
        size_t v13 = *(std::__shared_weak_count **)(v2 + 16);
        if (v13)
        {
          if (std::__shared_weak_count::lock(v13)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
    }
    else
    {
      uint64_t v7 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "kUnknown";
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#E Unhandled or Unknown message type %s", buf, 0xCu);
      }
    }
  }
  sub_1003C32EC(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_1003C3278(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a2)
  {
    if (*(char *)(v19 + 31) < 0) {
      operator delete(*v20);
    }
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1003C32EC(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    sub_1000FE824((const void **)(v1 + 72));
    sub_100030068((const void **)(v1 + 64));
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1003C3364(uint64_t *a1)
{
  uint64_t v1 = *a1;
  size_t v45 = a1;
  uint64_t v46 = v1;
  uint64_t v2 = *(void *)v1;
  *(_OWORD *)CFTypeRef cf = 0u;
  *(_OWORD *)int v66 = 0u;
  *(_DWORD *)&v66[20] = 0;
  memset(v64, 0, sizeof(v64));
  v66[8] = 2;
  *(void *)&v66[12] = 0x50000003CLL;
  std::string::operator=(v64, (const std::string *)(v2 + 112));
  std::string::operator=(&v64[1], (const std::string *)(v1 + 32));
  *(_DWORD *)&v66[12] = 30;
  v66[8] = 2;
  LOWORD(cf[0]) = *(_WORD *)(v1 + 56);
  sub_100BCC584((uint64_t)v64);
  CFURLRef v3 = *(const __CFURL **)(v1 + 72);
  if (v3) {
    int v4 = sub_1000FCC20;
  }
  else {
    int v4 = 0;
  }
  if (v4)
  {
    CFStringRef v63 = CFURLCopyFileSystemPath(v3, kCFURLPOSIXPathStyle);
    memset(&buf, 0, sizeof(buf));
    ctu::cf::assign();
    std::string v62 = buf;
    long long v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      long long v6 = &v62;
      if ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v6 = (std::string *)v62.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Received Watch bundle in callback,  %{public}s", (uint8_t *)&buf, 0xCu);
    }
    if (((*(uint64_t (**)(void, std::string *))(**(void **)(v2 + 56) + 88))(*(void *)(v2 + 56), &v62) & 1) == 0)
    {
      std::locale v29 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        char v30 = &v62;
        if ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          char v30 = (std::string *)v62.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v30;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Watch bundle %s does not exist", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v31 = *(void *)(v2 + 96);
      if (SHIBYTE(v64[0].__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&buf, v64[0].__r_.__value_.__l.__data_, v64[0].__r_.__value_.__l.__size_);
      }
      else {
        std::string buf = v64[0];
      }
      if (SHIBYTE(v64[1].__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v70, v64[1].__r_.__value_.__l.__data_, v64[1].__r_.__value_.__l.__size_);
      }
      else {
        std::string v70 = v64[1];
      }
      __int16 v71 = (__int16)cf[0];
      CFTypeRef v72 = cf[1];
      if (cf[1]) {
        CFRetain(cf[1]);
      }
      xpc_object_t v73 = *(const void **)v66;
      if (*(void *)v66) {
        CFRetain(*(CFTypeRef *)v66);
      }
      v74[0] = *(void *)&v66[8];
      *(void *)((char *)v74 + 6) = *(void *)&v66[14];
      (*(void (**)(uint64_t, std::string *, void))(*(void *)v31 + 32))(v31, &buf, 0);
      sub_1000FE824(&v73);
      sub_100030068(&v72);
      if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v70.__r_.__value_.__l.__data_);
      }
      if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_119;
      }
      id v32 = (void *)buf.__r_.__value_.__r.__words[0];
      goto LABEL_118;
    }
    v60[0] = 0;
    v60[1] = 0;
    uint64_t v61 = 0;
    (*(void (**)(void **__return_ptr))(**(void **)(v2 + 56) + 128))(v60);
    v58[0] = 0;
    v58[1] = 0;
    uint64_t v59 = 0;
    (*(void (**)(void **__return_ptr))(**(void **)(v2 + 56) + 120))(v58);
    v56[0] = 0;
    v56[1] = 0;
    int64_t v57 = 0;
    uint64_t v7 = (char *)sub_1003F26A8();
    sub_100058DB0(&v67, v7);
    size_t v8 = strlen(kUserCBDir);
    long long v9 = std::string::append(&v67, kUserCBDir, v8);
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    buf.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    size_t v11 = strlen(kCarrierBundleStaging);
    uint64_t v12 = std::string::append(&buf, kCarrierBundleStaging, v11);
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    int64_t v57 = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)BOOL v56 = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v67.__r_.__value_.__l.__data_);
    }
    char v55 = 0;
    uint64_t v53 = 0;
    xpc_type_t v54 = 0;
    sub_1006D6404("CarrierBundleIDSUtility", &v53);
    uint64_t v51 = v53;
    xpc_object_t v52 = v54;
    if (v54) {
      atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v61 >= 0) {
      size_t v14 = (char *)v60;
    }
    else {
      size_t v14 = (char *)v60[0];
    }
    if (v57 >= 0) {
      int v15 = (char *)v56;
    }
    else {
      int v15 = (char *)v56[0];
    }
    if (v59 >= 0) {
      uint64_t v16 = (char *)v58;
    }
    else {
      uint64_t v16 = (char *)v58[0];
    }
    sub_1006D87BC((uint64_t)&v51, v14, v15, v16, &v55);
    if (v52) {
      sub_10004D2C8(v52);
    }
    if (!v55)
    {
      uint64_t v33 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v34 = v58;
        if (v59 < 0) {
          __int16 v34 = (void **)v58[0];
        }
        id v35 = v60;
        if (v61 < 0) {
          id v35 = (void **)v60[0];
        }
        __int16 v36 = v56;
        if (v57 < 0) {
          __int16 v36 = (void **)v56[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446722;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v34;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v35;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2082;
        v70.__r_.__value_.__r.__words[0] = (std::string::size_type)v36;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#E Failed to copy %{public}s from %{public}s to %{public}s", (uint8_t *)&buf, 0x20u);
      }
      goto LABEL_87;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 72));
    uint64_t v18 = ServiceMap;
    if ((v19 & 0x8000000000000000) != 0)
    {
      uint64_t v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        std::string::size_type v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    buf.__r_.__value_.__r.__words[0] = v19;
    uint64_t v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)&buf);
    if (v23)
    {
      uint64_t v25 = v23[3];
      long long v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        char v26 = 0;
LABEL_78:
        sub_1002055B4((const void **)v56, (const void **)v58, &buf);
        copyURLForPath();
        uint64_t v47 = v2;
        if (SHIBYTE(v59) < 0)
        {
          sub_10004FC84(&__p, v58[0], (unint64_t)v58[1]);
        }
        else
        {
          long long __p = *(_OWORD *)v58;
          uint64_t v49 = v59;
        }
        BOOL v68 = 0;
        long long v37 = operator new(0x28uLL);
        uint64_t v38 = v47;
        *long long v37 = off_1019C5048;
        v37[1] = v38;
        void v37[4] = v49;
        *((_OWORD *)v37 + 1) = __p;
        long long __p = 0uLL;
        uint64_t v49 = 0;
        BOOL v68 = v37;
        (*(void (**)(uint64_t, const void **, std::string *))(*(void *)v25 + 80))(v25, &v50, &v67);
        sub_100060644(&v67);
        if (SHIBYTE(v49) < 0) {
          operator delete((void *)__p);
        }
        sub_1000FE824(&v50);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        if ((v26 & 1) == 0) {
          sub_10004D2C8(v24);
        }
LABEL_87:
        uint64_t v39 = (*(uint64_t (**)(void, std::string *))(**(void **)(v2 + 56) + 112))(*(void *)(v2 + 56), &v62);
        xpc_object_t v40 = *(NSObject **)(v2 + 40);
        if (v39 && os_log_type_enabled(*(os_log_t *)(v2 + 40), OS_LOG_TYPE_DEFAULT))
        {
          xpc_object_t v41 = &v62;
          if ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            xpc_object_t v41 = (std::string *)v62.__r_.__value_.__r.__words[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v41;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#E Unable to remove ipcc file at %{public}s ", (uint8_t *)&buf, 0xCu);
          xpc_object_t v40 = *(NSObject **)(v2 + 40);
        }
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          xpc_object_t v42 = v64;
          if ((v64[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            xpc_object_t v42 = (std::string *)v64[0].__r_.__value_.__r.__words[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v42;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = LOWORD(cf[0]);
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I Sending the BundleInfo response message to %s, using the message type: %u", (uint8_t *)&buf, 0x12u);
        }
        uint64_t v43 = *(void *)(v2 + 96);
        if (SHIBYTE(v64[0].__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&buf, v64[0].__r_.__value_.__l.__data_, v64[0].__r_.__value_.__l.__size_);
        }
        else {
          std::string buf = v64[0];
        }
        if (SHIBYTE(v64[1].__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v70, v64[1].__r_.__value_.__l.__data_, v64[1].__r_.__value_.__l.__size_);
        }
        else {
          std::string v70 = v64[1];
        }
        __int16 v71 = (__int16)cf[0];
        CFTypeRef v72 = cf[1];
        if (cf[1]) {
          CFRetain(cf[1]);
        }
        xpc_object_t v73 = *(const void **)v66;
        if (*(void *)v66) {
          CFRetain(*(CFTypeRef *)v66);
        }
        v74[0] = *(void *)&v66[8];
        *(void *)((char *)v74 + 6) = *(void *)&v66[14];
        (*(void (**)(uint64_t, std::string *, void))(*(void *)v43 + 32))(v43, &buf, 0);
        sub_1000FE824(&v73);
        sub_100030068(&v72);
        if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v70.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        if (v54) {
          sub_10004D2C8(v54);
        }
        if (SHIBYTE(v57) < 0) {
          operator delete(v56[0]);
        }
        if (SHIBYTE(v59) < 0) {
          operator delete(v58[0]);
        }
        if ((SHIBYTE(v61) & 0x80000000) == 0) {
          goto LABEL_119;
        }
        id v32 = v60[0];
LABEL_118:
        operator delete(v32);
LABEL_119:
        if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v62.__r_.__value_.__l.__data_);
        }
        sub_1000558F4((const void **)&v63);
        goto LABEL_122;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    std::mutex::unlock(v18);
    long long v24 = 0;
    char v26 = 1;
    goto LABEL_78;
  }
  long long v27 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#E Received a null resource IPCC url", (uint8_t *)&buf, 2u);
  }
  uint64_t v28 = *(void *)(v2 + 96);
  if (SHIBYTE(v64[0].__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&buf, v64[0].__r_.__value_.__l.__data_, v64[0].__r_.__value_.__l.__size_);
  }
  else {
    std::string buf = v64[0];
  }
  if (SHIBYTE(v64[1].__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v70, v64[1].__r_.__value_.__l.__data_, v64[1].__r_.__value_.__l.__size_);
  }
  else {
    std::string v70 = v64[1];
  }
  __int16 v71 = (__int16)cf[0];
  CFTypeRef v72 = cf[1];
  if (cf[1]) {
    CFRetain(cf[1]);
  }
  xpc_object_t v73 = *(const void **)v66;
  if (*(void *)v66) {
    CFRetain(*(CFTypeRef *)v66);
  }
  v74[0] = *(void *)&v66[8];
  *(void *)((char *)v74 + 6) = *(void *)&v66[14];
  (*(void (**)(uint64_t, std::string *, void))(*(void *)v28 + 32))(v28, &buf, 0);
  sub_1000FE824(&v73);
  sub_100030068(&v72);
  if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v70.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
LABEL_122:
  sub_1000FE824((const void **)v66);
  sub_100030068(&cf[1]);
  if (SHIBYTE(v64[1].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v64[1].__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v64[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v64[0].__r_.__value_.__l.__data_);
  }
  sub_1003C32EC(&v46);
  return sub_100046B58((uint64_t *)&v45);
}

void sub_1003C3E38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, const void *a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,const void *a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61,uint64_t a62,uint64_t a63)
{
  sub_1000FE824(&a18);
  if (*(char *)(v67 - 169) < 0) {
    operator delete(*(void **)(v67 - 192));
  }
  if ((v66 & 1) == 0) {
    sub_10004D2C8(v65);
  }
  if (a22) {
    sub_10004D2C8(a22);
  }
  if (a29 < 0) {
    operator delete(__p);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  sub_1000558F4(&a49);
  sub_1000FE824(&a64);
  sub_100030068(v64);
  if (a61 < 0) {
    operator delete(a56);
  }
  if (a55 < 0) {
    operator delete(a50);
  }
  sub_1003C32EC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1003C40AC(uint64_t a1)
{
  *(void *)a1 = off_1019C5048;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1003C40FC(uint64_t a1)
{
  *(void *)a1 = off_1019C5048;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_1003C416C(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_1019C5048;
  v2[1] = v3;
  int v4 = v2 + 2;
  if (*(char *)(a1 + 39) < 0)
  {
    sub_10004FC84(v4, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)int v4 = *(_OWORD *)(a1 + 16);
    void v2[4] = *(void *)(a1 + 32);
  }
  return v2;
}

void sub_1003C41E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_1003C41F8(char *result, void *a2)
{
  uint64_t v2 = *((void *)result + 1);
  *a2 = off_1019C5048;
  a2[1] = v2;
  uint64_t v3 = a2 + 2;
  if (result[39] < 0) {
    return (char *)sub_10004FC84(v3, *((void **)result + 2), *((void *)result + 3));
  }
  long long v4 = *((_OWORD *)result + 1);
  a2[4] = *((void *)result + 4);
  *(_OWORD *)uint64_t v3 = v4;
  return result;
}

void sub_1003C4248(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
}

void sub_1003C425C(void **__p)
{
  if (*((char *)__p + 39) < 0) {
    operator delete(__p[2]);
  }

  operator delete(__p);
}

void sub_1003C42A0(uint64_t a1, unsigned char *a2)
{
  if (!*a2)
  {
    uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 16);
      uint64_t v5 = a1 + 16;
      uint64_t v4 = v6;
      if (*(char *)(v5 + 23) >= 0) {
        uint64_t v4 = v5;
      }
      int v7 = 136446210;
      uint64_t v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N failed to install bundle: %{public}s", (uint8_t *)&v7, 0xCu);
    }
  }
}

uint64_t sub_1003C4358(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003C4398()
{
}

uint64_t *sub_1003C43A4(capabilities::ct *a1)
{
  uint64_t v1 = *(void *)a1;
  unsigned int v22 = a1;
  uint64_t v23 = v1;
  uint64_t v2 = *(void *)v1;
  if (capabilities::ct::supportsSIMProvisioningAsSignupDestination(a1))
  {
    uint64_t v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#E Sending IPCC to companion is not a supported operation", buf, 2u);
    }
    goto LABEL_54;
  }
  if (!*(void *)(v2 + 96)) {
    goto LABEL_54;
  }
  *(_OWORD *)CFTypeRef cf = 0u;
  *(_OWORD *)id v35 = 0u;
  *(_DWORD *)&v35[20] = 0;
  memset(v33, 0, sizeof(v33));
  *(_OWORD *)std::string buf = 0u;
  v35[8] = 2;
  *(void *)&v35[12] = 0x50000003CLL;
  int v4 = *(unsigned __int8 *)(v2 + 172);
  if (v4 == 1)
  {
    __int16 v5 = 6;
  }
  else
  {
    if (v4 != 2)
    {
      uint64_t v20 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long __dst = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#E Unknown paired mode, cannot send the IPCC to the watch", __dst, 2u);
      }
      goto LABEL_50;
    }
    __int16 v5 = 10;
  }
  LOWORD(cf[0]) = v5;
  CFStringRef v31 = 0;
  uint64_t v6 = (const char *)(v1 + 8);
  if (*(char *)(v1 + 31) < 0) {
    uint64_t v6 = *(const char **)v6;
  }
  CFStringRef v31 = CFStringCreateWithCString(kCFAllocatorDefault, v6, 0x8000100u);
  CFURLRef v7 = CFURLCreateWithFileSystemPath(0, v31, kCFURLPOSIXPathStyle, 0);
  CFURLRef v30 = v7;
  if (v31) {
    uint64_t v8 = sub_1000810B8;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8 && (v7 ? (long long v9 = sub_1000FCC20) : (long long v9 = 0), v9))
  {
    long long v10 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      memset(__dst, 0, sizeof(__dst));
      ctu::cf::assign();
      *(_OWORD *)long long __p = 0u;
      uint64_t v25 = 0;
      *(_DWORD *)uint64_t v43 = 136446210;
      xpc_object_t v44 = __p;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Found bundle URL :%{public}s", v43, 0xCu);
      if (SHIBYTE(v25) < 0) {
        operator delete(__p[0]);
      }
    }
    std::string::operator=((std::string *)buf, (const std::string *)(v2 + 112));
    sub_1003C4D24((const void **)v35, (const void **)&v30);
    *(_DWORD *)&v35[12] = 30;
    v35[8] = 2;
    sub_100BCC584((uint64_t)buf);
    size_t v11 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = sub_1005050C0(LOWORD(cf[0]));
      long long v13 = *(uint8_t **)buf;
      if (SHIBYTE(v33[0]) >= 0) {
        long long v13 = buf;
      }
      *(_DWORD *)long long __dst = 136315394;
      *(void *)&__dst[4] = v13;
      *(_WORD *)&__dst[12] = 2080;
      *(void *)&__dst[14] = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Sending the request to %s, using the message type: %s", __dst, 0x16u);
    }
    size_t v14 = *(std::__shared_weak_count **)(v2 + 16);
    if (!v14 || (uint64_t v15 = *(void *)(v2 + 8), (v16 = std::__shared_weak_count::lock(v14)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v17 = v16;
    atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v16);
    uint64_t v18 = *(void *)(v2 + 96);
    if (SHIBYTE(v33[0]) < 0)
    {
      sub_10004FC84(__dst, *(void **)buf, *(unint64_t *)&buf[8]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)buf;
      *(void **)&_OWORD __dst[16] = v33[0];
    }
    if (SHIBYTE(v33[3]) < 0)
    {
      sub_10004FC84(&v37, v33[1], (unint64_t)v33[2]);
    }
    else
    {
      long long v37 = *(_OWORD *)&v33[1];
      uint64_t v38 = v33[3];
    }
    __int16 v39 = (__int16)cf[0];
    CFTypeRef v40 = cf[1];
    if (cf[1]) {
      CFRetain(cf[1]);
    }
    xpc_object_t v41 = *(const void **)v35;
    if (*(void *)v35) {
      CFRetain(*(CFTypeRef *)v35);
    }
    v42[0] = *(void *)&v35[8];
    *(void *)((char *)v42 + 6) = *(void *)&v35[14];
    __p[0] = _NSConcreteStackBlock;
    __p[1] = (void *)1174405120;
    uint64_t v25 = sub_1003C49F8;
    char v26 = &unk_1019C50B8;
    uint64_t v27 = v2;
    uint64_t v28 = v15;
    std::locale v29 = v17;
    atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    (*(void (**)(uint64_t, uint8_t *, void **))(*(void *)v18 + 32))(v18, __dst, __p);
    sub_1000FE824(&v41);
    sub_100030068(&v40);
    if (SHIBYTE(v38) < 0) {
      operator delete((void *)v37);
    }
    if ((char)__dst[23] < 0) {
      operator delete(*(void **)__dst);
    }
    if (v29) {
      std::__shared_weak_count::__release_weak(v29);
    }
    std::__shared_weak_count::__release_weak(v17);
  }
  else
  {
    std::string::size_type v19 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long __dst = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#E Invalid bundle path, cannot send the IPCC to the watch", __dst, 2u);
    }
  }
  sub_1000FE824((const void **)&v30);
  sub_1000558F4((const void **)&v31);
LABEL_50:
  sub_1000FE824((const void **)v35);
  sub_100030068(&cf[1]);
  if (SHIBYTE(v33[3]) < 0) {
    operator delete(v33[1]);
  }
  if (SHIBYTE(v33[0]) < 0) {
    operator delete(*(void **)buf);
  }
LABEL_54:
  sub_1001102C4(&v23);
  return sub_100046B58((uint64_t *)&v22);
}

void sub_1003C48F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, const void *a19, const void *a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (a44 < 0) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v51);
  sub_1000FE824(&a19);
  sub_1000558F4(&a20);
  sub_1000FE824((const void **)&a35);
  sub_100030068(v50);
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  sub_1001102C4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_1003C49F8(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      CFURLRef v7 = v6;
      if (a1[5])
      {
        int v8 = *a2;
        if (v8 == 2)
        {
          long long v9 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            int v10 = a2[8];
            *(_DWORD *)std::string buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v10;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#E Received an IDS error [%d]", buf, 8u);
          }
        }
        else
        {
          long long v21 = 0u;
          memset(v22, 0, sizeof(v22));
          memset(v20, 0, sizeof(v20));
          *(_OWORD *)std::string buf = 0u;
          if (v8 != 1)
          {
            exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
            ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
          }
          if ((char)a2[31] < 0)
          {
            sub_10004FC84(buf, *((void **)a2 + 1), *((void *)a2 + 2));
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)(a2 + 8);
            v20[0] = *((void **)a2 + 3);
          }
          if ((char)a2[55] < 0)
          {
            sub_10004FC84(&v20[1], *((void **)a2 + 4), *((void *)a2 + 5));
          }
          else
          {
            *(_OWORD *)&v20[1] = *((_OWORD *)a2 + 2);
            v20[3] = *((void **)a2 + 6);
          }
          LOWORD(v21) = *((_WORD *)a2 + 28);
          sub_10002FD9C((const void **)&v21 + 1, (const void **)a2 + 8);
          sub_100119B5C((const void **)v22, (const void **)a2 + 9);
          *(void *)&uint8_t v22[8] = *((void *)a2 + 10);
          *(void *)&v22[14] = *(void *)(a2 + 86);
          uint64_t v11 = *(void *)(v5 + 96);
          if (SHIBYTE(v20[3]) < 0)
          {
            sub_10004FC84(__p, v20[1], (unint64_t)v20[2]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)&v20[1];
            uint64_t v16 = v20[3];
          }
          (*(void (**)(uint64_t, void **))(*(void *)v11 + 40))(v11, __p);
          if (SHIBYTE(v16) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v12 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            if (SHIBYTE(v20[3]) >= 0) {
              long long v13 = &v20[1];
            }
            else {
              long long v13 = (void **)v20[1];
            }
            *(_DWORD *)uint64_t v17 = 136446210;
            uint64_t v18 = v13;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Received response from = %{public}s", v17, 0xCu);
          }
          sub_1000FE824((const void **)v22);
          sub_100030068((const void **)&v21 + 1);
          if (SHIBYTE(v20[3]) < 0) {
            operator delete(v20[1]);
          }
          if (SHIBYTE(v20[0]) < 0) {
            operator delete(*(void **)buf);
          }
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1003C4CC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  sub_1003C1D74((uint64_t)&__p);
  sub_10004D2C8(v23);
  _Unwind_Resume(a1);
}

const void **sub_1003C4D24(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    uint64_t v5 = 0;
    sub_100119B5C(&v5, a2);
    uint64_t v3 = *a1;
    *a1 = v5;
    uint64_t v5 = v3;
    sub_1000FE824(&v5);
  }
  return a1;
}

void sub_1003C4D7C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  if (!*(void *)(v1 + 96)) {
    goto LABEL_43;
  }
  unsigned int v2 = *(_DWORD *)(v1 + 168);
  if (HIWORD(v2) <= 6u && ((v2 & 0xFFFF0000) != 0x60000 || (*(_DWORD *)(v1 + 168) & 0xFF00) == 0))
  {
    int v4 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E Paired watchos version is not compatible with the RemoteBundleInfo request", buf, 2u);
    }
LABEL_43:
    operator delete();
  }
  *(_OWORD *)CFTypeRef cf = 0u;
  *(_OWORD *)long long v21 = 0u;
  *(_DWORD *)&v21[20] = 0;
  memset(v19, 0, sizeof(v19));
  *(_OWORD *)std::string buf = 0u;
  unsigned char v21[8] = 2;
  *(void *)&unsigned char v21[12] = 0x50000003CLL;
  int v5 = *(unsigned __int8 *)(v1 + 172);
  if (v5 == 1)
  {
    __int16 v6 = 6;
  }
  else
  {
    if (v5 != 2)
    {
      uint64_t v15 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long __dst = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E Unknown paired mode, cannot send the RemoteBundleInfo request to the watch", __dst, 2u);
      }
      goto LABEL_39;
    }
    __int16 v6 = 10;
  }
  LOWORD(cf[0]) = v6;
  std::string::operator=((std::string *)buf, (const std::string *)(v1 + 112));
  *(_DWORD *)&unsigned char v21[12] = 30;
  unsigned char v21[8] = 2;
  sub_100BCC828((uint64_t)buf);
  CFURLRef v7 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = sub_1005050C0(LOWORD(cf[0]));
    long long v9 = *(uint8_t **)buf;
    if (SHIBYTE(v19[0]) >= 0) {
      long long v9 = buf;
    }
    *(_DWORD *)long long __dst = 136315394;
    *(void *)&__dst[4] = v9;
    *(_WORD *)&__dst[12] = 2080;
    *(void *)&__dst[14] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Sending the BundleInfo request message to %s, using the message type: %s", __dst, 0x16u);
  }
  int v10 = *(std::__shared_weak_count **)(v1 + 16);
  if (!v10 || (uint64_t v11 = *(void *)(v1 + 8), (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
    sub_100088B9C();
  }
  long long v13 = v12;
  atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  uint64_t v14 = *(void *)(v1 + 96);
  if (SHIBYTE(v19[0]) < 0)
  {
    sub_10004FC84(__dst, *(void **)buf, *(unint64_t *)&buf[8]);
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)buf;
    *(void **)&_OWORD __dst[16] = v19[0];
  }
  if (SHIBYTE(v19[3]) < 0)
  {
    sub_10004FC84(&__p, v19[1], (unint64_t)v19[2]);
  }
  else
  {
    long long __p = *(_OWORD *)&v19[1];
    long long v24 = v19[3];
  }
  __int16 v25 = (__int16)cf[0];
  CFTypeRef v26 = cf[1];
  if (cf[1]) {
    CFRetain(cf[1]);
  }
  uint64_t v27 = *(const void **)v21;
  if (*(void *)v21) {
    CFRetain(*(CFTypeRef *)v21);
  }
  v28[0] = *(void *)&v21[8];
  *(void *)((char *)v28 + 6) = *(void *)&v21[14];
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 1174405120;
  v16[2] = sub_1003C5258;
  void v16[3] = &unk_1019C50E8;
  v16[4] = v1;
  _OWORD v16[5] = v11;
  uint64_t v17 = v13;
  atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  (*(void (**)(uint64_t, unsigned char *, void *))(*(void *)v14 + 32))(v14, __dst, v16);
  sub_1000FE824(&v27);
  sub_100030068(&v26);
  if (SHIBYTE(v24) < 0) {
    operator delete((void *)__p);
  }
  if ((__dst[23] & 0x80000000) != 0) {
    operator delete(*(void **)__dst);
  }
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  std::__shared_weak_count::__release_weak(v13);
LABEL_39:
  sub_1000FE824((const void **)v21);
  sub_100030068(&cf[1]);
  if (SHIBYTE(v19[3]) < 0) {
    operator delete(v19[1]);
  }
  if (SHIBYTE(v19[0]) < 0) {
    operator delete(*(void **)buf);
  }
  goto LABEL_43;
}

void sub_1003C5184(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a40 < 0) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v47);
  sub_1000FE824((const void **)&a31);
  sub_100030068(v46);
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  operator delete();
}

void sub_1003C5258(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    __int16 v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[5])
      {
        sub_1003C5AEC((uint64_t)&v8, a2);
        CFURLRef v7 = *(std::__shared_weak_count **)(v5 + 16);
        if (v7)
        {
          if (std::__shared_weak_count::lock(v7)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1003C53B0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_1003C53C8(unsigned char *a1, void **a2)
{
  int v4 = *(unsigned __int8 *)a2;
  if (v4 == 2)
  {
    if (*a1 != 2)
    {
      sub_1003C55AC((uint64_t)a1);
      *a1 = 2;
    }
    a1[8] = *((unsigned char *)a2 + 8);
  }
  else if (v4 == 1)
  {
    sub_1003C543C((uint64_t)a1, a2 + 1);
  }
  return a1;
}

void sub_1003C543C(uint64_t a1, void **a2)
{
  if (*(unsigned char *)a1 == 1)
  {
    int v4 = (void **)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v4);
    }
    long long v5 = *(_OWORD *)a2;
    *(void *)(a1 + 24) = a2[2];
    *(_OWORD *)int v4 = v5;
    *((unsigned char *)a2 + 23) = 0;
    *(unsigned char *)a2 = 0;
    __int16 v6 = (void **)(a1 + 32);
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*v6);
    }
    long long v7 = *(_OWORD *)(a2 + 3);
    *(void *)(a1 + 48) = a2[5];
    *(_OWORD *)__int16 v6 = v7;
    *((unsigned char *)a2 + 47) = 0;
    *((unsigned char *)a2 + 24) = 0;
    *(_WORD *)(a1 + 56) = *((_WORD *)a2 + 24);
    if (v4 != a2)
    {
      uint64_t v8 = *(const void **)(a1 + 64);
      *(void *)(a1 + 64) = 0;
      long long v13 = v8;
      *(void *)(a1 + 64) = a2[7];
      a2[7] = 0;
      sub_100030068(&v13);
      long long v9 = *(const void **)(a1 + 72);
      *(void *)(a1 + 72) = 0;
      long long v13 = v9;
      *(void *)(a1 + 72) = a2[8];
      a2[8] = 0;
      sub_1000FE824(&v13);
    }
  }
  else
  {
    sub_1003C55AC(a1);
    *(unsigned char *)a1 = 1;
    long long v10 = *(_OWORD *)a2;
    *(void *)(a1 + 24) = a2[2];
    *(_OWORD *)(a1 + 8) = v10;
    a2[1] = 0;
    a2[2] = 0;
    *a2 = 0;
    long long v11 = *(_OWORD *)(a2 + 3);
    *(void *)(a1 + 48) = a2[5];
    *(_OWORD *)(a1 + 32) = v11;
    a2[4] = 0;
    a2[5] = 0;
    a2[3] = 0;
    *(_WORD *)(a1 + 56) = *((_WORD *)a2 + 24);
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 64) = a2[7];
    a2[7] = 0;
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 72) = a2[8];
    a2[8] = 0;
  }
  uint64_t v12 = a2[9];
  *(void *)(a1 + 86) = *(void **)((char *)a2 + 78);
  *(void *)(a1 + 80) = v12;
}

void sub_1003C55AC(uint64_t a1)
{
  if (*(unsigned char *)a1 == 1)
  {
    sub_1000FE824((const void **)(a1 + 72));
    sub_100030068((const void **)(a1 + 64));
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
  }
  *(unsigned char *)a1 = 0;
}

uint64_t *sub_1003C560C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v16 = a1;
  uint64_t v17 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(unsigned __int8 *)(v1 + 8);
  if (v3 == 2)
  {
    int v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(unsigned __int8 *)(v1 + 16);
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E Received an IDS error [%d]", buf, 8u);
    }
  }
  else
  {
    long long v24 = 0u;
    memset(v25, 0, sizeof(v25));
    memset(v23, 0, sizeof(v23));
    *(_OWORD *)std::string buf = 0u;
    if (v3 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    if (*(char *)(v1 + 39) < 0)
    {
      sub_10004FC84(buf, *(void **)(v1 + 16), *(void *)(v1 + 24));
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)(v1 + 16);
      v23[0] = *(void **)(v1 + 32);
    }
    if (*(char *)(v1 + 63) < 0)
    {
      sub_10004FC84(&v23[1], *(void **)(v1 + 40), *(void *)(v1 + 48));
    }
    else
    {
      *(_OWORD *)&v23[1] = *(_OWORD *)(v1 + 40);
      void v23[3] = *(void **)(v1 + 56);
    }
    LOWORD(v24) = *(_WORD *)(v1 + 64);
    sub_10002FD9C((const void **)&v24 + 1, (const void **)(v1 + 72));
    sub_100119B5C((const void **)v25, (const void **)(v1 + 80));
    *(void *)&v25[8] = *(void *)(v1 + 88);
    *(void *)&v25[14] = *(void *)(v1 + 94);
    __p[0] = 0;
    sub_100BCCA60((uint64_t)buf, __p);
    CFDictionaryRef v6 = (const __CFDictionary *)__p[0];
    if (__p[0]) {
      long long v7 = sub_100080778;
    }
    else {
      long long v7 = 0;
    }
    uint64_t v8 = *(NSObject **)(v2 + 40);
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if (v7)
    {
      if (v9)
      {
        *(_WORD *)long long v21 = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I RemotebundleInfo received. Saving to Preferences", v21, 2u);
        CFDictionaryRef v6 = (const __CFDictionary *)__p[0];
      }
      *(void *)long long v21 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v6);
      long long v10 = (const char *)(v2 + 112);
      if (*(char *)(v2 + 135) < 0) {
        long long v10 = *(const char **)v10;
      }
      CFStringRef v20 = CFStringCreateWithCString(kCFAllocatorDefault, v10, 0x600u);
      sub_10010F3F0(*(__CFDictionary **)v21, @"DeviceUUID", (uint64_t)v20);
      DevicePersistentSaveValue(@"kRemoteCarrierBundleInfo", *(const void **)v21);
      sub_1000558F4((const void **)&v20);
      sub_10005717C((const void **)v21);
    }
    else if (v9)
    {
      *(_WORD *)long long v21 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E Received null remote bundle dictionary", v21, 2u);
    }
    sub_100057D78((const void **)__p);
    uint64_t v11 = *(void *)(v2 + 96);
    if (SHIBYTE(v23[3]) < 0)
    {
      sub_10004FC84(__p, v23[1], (unint64_t)v23[2]);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)&v23[1];
      std::string::size_type v19 = v23[3];
    }
    (*(void (**)(uint64_t, void **))(*(void *)v11 + 40))(v11, __p);
    if (SHIBYTE(v19) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v12 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      if (SHIBYTE(v23[3]) >= 0) {
        long long v13 = &v23[1];
      }
      else {
        long long v13 = (void **)v23[1];
      }
      *(_DWORD *)long long v21 = 136446210;
      *(void *)&void v21[4] = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Received response from = %{public}s", v21, 0xCu);
    }
    sub_1000FE824((const void **)v25);
    sub_100030068((const void **)&v24 + 1);
    if (SHIBYTE(v23[3]) < 0) {
      operator delete(v23[1]);
    }
    if (SHIBYTE(v23[0]) < 0) {
      operator delete(*(void **)buf);
    }
  }
  sub_1003C5A9C(&v17);
  return sub_100046B58((uint64_t *)&v16);
}

void sub_1003C59E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  sub_1003C5A9C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1003C5A9C(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    sub_1003C55AC(v1 + 8);
    operator delete();
  }
  return result;
}

uint64_t sub_1003C5AEC(uint64_t a1, unsigned __int8 *a2)
{
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  sub_1003C5B38((unsigned char *)a1, a2);
  return a1;
}

void sub_1003C5B24(_Unwind_Exception *a1)
{
  sub_1003C55AC(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_1003C5B38(unsigned char *a1, unsigned __int8 *a2)
{
  int v4 = *a2;
  if (v4 == 2)
  {
    if (*a1 != 2)
    {
      sub_1003C55AC((uint64_t)a1);
      *a1 = 2;
    }
    a1[8] = a2[8];
  }
  else if (v4 == 1)
  {
    sub_1003C5BA8((uint64_t)a1, (std::string *)(a2 + 8));
  }
  return a1;
}

const void **sub_1003C5BA8(uint64_t a1, std::string *__str)
{
  if (*(unsigned char *)a1 == 1)
  {
    std::string::operator=((std::string *)(a1 + 8), __str);
    std::string::operator=((std::string *)(a1 + 32), __str + 1);
    *(_WORD *)(a1 + 56) = __str[2].__r_.__value_.__l.__data_;
    sub_1003C5CD0((const void **)(a1 + 64), (const void **)&__str[2].__r_.__value_.__l.__size_);
    uint64_t result = sub_1003C4D24((const void **)(a1 + 72), (const void **)&__str[2].__r_.__value_.__r.__words[2]);
  }
  else
  {
    sub_1003C55AC(a1);
    *(unsigned char *)a1 = 1;
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84((unsigned char *)(a1 + 8), __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
    }
    else
    {
      long long v5 = *(_OWORD *)&__str->__r_.__value_.__l.__data_;
      *(void *)(a1 + 24) = *((void *)&__str->__r_.__value_.__l + 2);
      *(_OWORD *)(a1 + 8) = v5;
    }
    CFDictionaryRef v6 = (unsigned char *)(a1 + 32);
    if (SHIBYTE(__str[1].__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(v6, __str[1].__r_.__value_.__l.__data_, __str[1].__r_.__value_.__l.__size_);
    }
    else
    {
      long long v7 = *(_OWORD *)&__str[1].__r_.__value_.__l.__data_;
      *(void *)(a1 + 48) = *((void *)&__str[1].__r_.__value_.__l + 2);
      *(_OWORD *)CFDictionaryRef v6 = v7;
    }
    *(_WORD *)(a1 + 56) = __str[2].__r_.__value_.__l.__data_;
    sub_10002FD9C((const void **)(a1 + 64), (const void **)&__str[2].__r_.__value_.__l.__size_);
    uint64_t result = sub_100119B5C((const void **)(a1 + 72), (const void **)&__str[2].__r_.__value_.__r.__words[2]);
  }
  std::string::pointer data = __str[3].__r_.__value_.__l.__data_;
  *(void *)(a1 + 86) = *(std::string::size_type *)((char *)__str[3].__r_.__value_.__r.__words + 6);
  *(void *)(a1 + 80) = data;
  return result;
}

void sub_1003C5CB4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1003C5CD0(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    long long v5 = 0;
    sub_10002FD9C(&v5, a2);
    int v3 = *a1;
    *a1 = v5;
    long long v5 = v3;
    sub_100030068(&v5);
  }
  return a1;
}

uint64_t *sub_1003C5D28(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(void *)(*(void *)v1 + 96))
  {
    *(_OWORD *)uint64_t v23 = 0u;
    *(_OWORD *)long long v24 = 0u;
    *(_DWORD *)&v24[20] = 0;
    memset(v22, 0, sizeof(v22));
    unsigned char v24[8] = 2;
    *(void *)&v24[12] = 0x50000003CLL;
    std::string::operator=(v22, (const std::string *)(v2 + 112));
    std::string::operator=(&v22[1], (const std::string *)(v1 + 32));
    *(_DWORD *)&v24[12] = 30;
    unsigned char v24[8] = 2;
    LOWORD(v23[0]) = *(_WORD *)(v1 + 56);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFMutableDictionaryRef v20 = Mutable;
    CFTypeRef cf = Mutable;
    uint64_t v19 = v2;
    if (Mutable) {
      CFRetain(Mutable);
    }
    sub_1003C627C(&v19, 4, 1);
    subscriber::makeSimSlotRange();
    std::string::size_type size = buf.__r_.__value_.__l.__size_;
    long long v5 = (unsigned int *)buf.__r_.__value_.__r.__words[0];
    if (buf.__r_.__value_.__r.__words[0] != buf.__r_.__value_.__l.__size_)
    {
      CFDictionaryRef v6 = (uint64_t (*)(void))buf.__r_.__value_.__r.__words[2];
      while ((v6(*v5) & 1) == 0)
      {
        if (++v5 == (unsigned int *)size)
        {
          long long v5 = (unsigned int *)size;
          break;
        }
      }
      std::string::size_type v7 = buf.__r_.__value_.__l.__size_;
LABEL_10:
      while (v5 != (unsigned int *)v7)
      {
        uint64_t v8 = *v5;
        sub_1003C627C(&v19, 1, v8);
        sub_1003C627C(&v19, 2, v8);
        BOOL v9 = v5 + 1;
        long long v5 = (unsigned int *)size;
        if (v9 != (unsigned int *)size)
        {
          long long v5 = v9;
          while ((v6(*v5) & 1) == 0)
          {
            if (++v5 == (unsigned int *)size)
            {
              long long v5 = (unsigned int *)size;
              goto LABEL_10;
            }
          }
        }
      }
    }
    CFTypeRef v17 = cf;
    if (cf)
    {
      CFRetain(cf);
      CFTypeRef v26 = v17;
      CFRetain(v17);
    }
    else
    {
      CFTypeRef v26 = 0;
    }
    __int16 v25 = 0;
    buf.__r_.__value_.__r.__words[0] = 0;
    sub_10004EFE4(&buf, &v26);
    if (buf.__r_.__value_.__r.__words[0]) {
      long long v10 = sub_100080778;
    }
    else {
      long long v10 = 0;
    }
    if (v10) {
      sub_100058140(&v25, (const void **)&buf.__r_.__value_.__l.__data_);
    }
    sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
    uint64_t v18 = v25;
    __int16 v25 = 0;
    sub_100057D78(&v25);
    sub_10005717C(&v26);
    sub_100BCC930((uint64_t)v22, (uint64_t *)&v18);
    sub_100057D78(&v18);
    sub_10005717C(&v17);
    uint64_t v11 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = v22;
      if ((v22[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v12 = (std::string *)v22[0].__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = LOWORD(v23[0]);
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Sending the BundleInfo response message to %s, using the message type: %u", (uint8_t *)&buf, 0x12u);
    }
    uint64_t v13 = *(void *)(v2 + 96);
    if (SHIBYTE(v22[0].__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&buf, v22[0].__r_.__value_.__l.__data_, v22[0].__r_.__value_.__l.__size_);
    }
    else {
      std::string buf = v22[0];
    }
    if (SHIBYTE(v22[1].__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__p, v22[1].__r_.__value_.__l.__data_, v22[1].__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v22[1];
    }
    __int16 v29 = (__int16)v23[0];
    CFTypeRef v30 = v23[1];
    if (v23[1]) {
      CFRetain(v23[1]);
    }
    CFStringRef v31 = *(const void **)v24;
    if (*(void *)v24) {
      CFRetain(*(CFTypeRef *)v24);
    }
    v32[0] = *(void *)&v24[8];
    *(void *)((char *)v32 + 6) = *(void *)&v24[14];
    (*(void (**)(uint64_t, std::string *, void))(*(void *)v13 + 32))(v13, &buf, 0);
    sub_1000FE824(&v31);
    sub_100030068(&v30);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    sub_10005717C((const void **)&v20);
    sub_10005717C(&cf);
    sub_1000FE824((const void **)v24);
    sub_100030068(&v23[1]);
    if (SHIBYTE(v22[1].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v22[1].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v22[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v22[0].__r_.__value_.__l.__data_);
    }
  }
  sub_1003C32EC(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_1003C6170(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,const void *a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40,int a41,__int16 a42,char a43,char a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a50 < 0) {
    operator delete(__p);
  }
  sub_10005717C(v57);
  sub_10005717C(&a21);
  sub_1000FE824((const void **)&a36);
  sub_100030068(v56);
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  sub_1003C32EC(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_1003C627C(void *a1, uint64_t a2, uint64_t a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(*a1 + 72));
  std::string::size_type v7 = ServiceMap;
  if (v8 < 0)
  {
    BOOL v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unsigned int v22 = (void *)v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v22);
  if (!v12)
  {
    std::mutex::unlock(v7);
    return;
  }
  uint64_t v14 = v12[3];
  uint64_t v13 = (std::__shared_weak_count *)v12[4];
  if (v13)
  {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v7);
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v13);
    if (!v14)
    {
LABEL_19:
      sub_10004D2C8(v13);
      return;
    }
  }
  else
  {
    std::mutex::unlock(v7);
    if (!v14) {
      return;
    }
  }
  CFMutableDictionaryRef v20 = 0;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v14 + 72))(&v20, v14, a2, a3);
  if (v20) {
    uint64_t v15 = sub_100080778;
  }
  else {
    uint64_t v15 = 0;
  }
  if (v15)
  {
    uint64_t v16 = (const __CFString **)asString();
    CFTypeRef v17 = v20;
    uint64_t v18 = (__CFDictionary *)a1[1];
    unsigned int v22 = 0;
    ctu::cf::convert_copy((ctu::cf *)&v22, v16, (const char *)0x8000100, kCFAllocatorDefault, v19);
    key = v22;
    unsigned int v22 = v17;
    if (v17)
    {
      CFRetain(v17);
      if (key) {
        CFDictionaryAddValue(v18, key, v17);
      }
    }
    sub_10010F494((const void **)&v22);
    sub_10010F494((const void **)&key);
  }
  sub_100057D78((const void **)&v20);
  if (v13) {
    goto LABEL_19;
  }
}

void sub_1003C643C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  int v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  CFDictionaryRef v6 = va_arg(va2, const void *);
  sub_10010F494((const void **)va2);
  sub_10010F494((const void **)va1);
  sub_100057D78((const void **)va);
  if (v2) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1003C648C@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  int v3 = (capabilities::ct *)capabilities::ct::supportsP2PAsPhone(a1);
  if ((v3 & 1) != 0 || (uint64_t result = capabilities::ct::supportsP2PAsGizmo(v3), result)) {
    operator new();
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void sub_1003C6568(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003C659C(uint64_t a1, void *a2, NSObject **a3)
{
  CFDictionaryRef v6 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v17, kCtLoggingSystemName, "set.sync");
  *CFDictionaryRef v6 = 0;
  v6[1] = 0;
  std::string::size_type v7 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v7) {
    dispatch_retain(v7);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v18, &v17);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v18);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v18);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v17);
  *(void *)a1 = off_1019C5128;
  *(void *)(a1 + 48) = *a2;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 56) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "CompanionPhoneNumberSyncHandler");
  BOOL v9 = *a3;
  dispatch_object_t v14 = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  v13[1] = 0;
  ctu::RestModule::RestModule();
  if (v14) {
    dispatch_release(v14);
  }
  if (v16 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 80) = a1 + 88;
  *(void *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  uint64_t v10 = *(NSObject **)(a1 + 24);
  v13[0] = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  v11.fObj.fObj = (dispatch_object_s *)v13;
  NotifySubscription::NotifySubscription((NotifySubscription *)(a1 + 248), "com.apple.commcenter.CompanionPhoneNumberChangedNotification", v11);
  if (v13[0]) {
    dispatch_release(v13[0]);
  }
  return a1;
}

void sub_1003C675C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, dispatch_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  __int16 v25 = *(std::__shared_weak_count **)(v19 + 240);
  if (v25) {
    sub_10004D2C8(v25);
  }
  CFTypeRef v26 = *(std::__shared_weak_count **)(v19 + 224);
  if (v26) {
    sub_10004D2C8(v26);
  }
  sub_1003C8134(v23);
  sub_100087ED0(v22, *(void **)(v19 + 88));
  uint64_t v27 = *(std::__shared_weak_count **)(v19 + 72);
  if (v27) {
    sub_10004D2C8(v27);
  }
  uint64_t v28 = *(std::__shared_weak_count **)(v19 + 56);
  if (v28) {
    sub_10004D2C8(v28);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  CompanionPhoneNumberSyncInterface::~CompanionPhoneNumberSyncInterface((CompanionPhoneNumberSyncInterface *)v19);
  _Unwind_Resume(a1);
}

void sub_1003C6838(capabilities::ct *a1, void *a2)
{
  if (capabilities::ct::supportsP2PAsGizmo(a1))
  {
    *(_OWORD *)std::string __p = 0u;
    long long v13 = 0u;
    sub_1003C6A14((uint64_t)__p, (uint64_t)a1);
    if (BYTE8(v13))
    {
      if ((SBYTE7(v13) & 0x80u) == 0) {
        int v4 = __p;
      }
      else {
        int v4 = (void **)__p[0];
      }
      xpc_object_t v6 = xpc_string_create((const char *)v4);
      if (!v6) {
        xpc_object_t v6 = xpc_null_create();
      }
      *(void *)std::string buf = *a2;
      BOOL v9 = "kSettingsModelNumber";
      sub_100035E70((uint64_t)buf, &v6, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v6);
      xpc_object_t v6 = 0;
      if (BYTE8(v13))
      {
        if (SBYTE7(v13) < 0) {
          operator delete(__p[0]);
        }
      }
    }
    else
    {
      long long v5 = *((void *)a1 + 5);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Missing companion phone number", buf, 2u);
      }
      xpc_object_t v10 = xpc_int64_create(35);
      if (!v10) {
        xpc_object_t v10 = xpc_null_create();
      }
      *(void *)std::string buf = *a2;
      BOOL v9 = "kPosixError";
      sub_100035E70((uint64_t)buf, &v10, &v11);
      xpc_release(v11);
      xpc_object_t v11 = 0;
      xpc_release(v10);
    }
  }
  else
  {
    xpc_object_t v14 = xpc_int64_create(1);
    if (!v14) {
      xpc_object_t v14 = xpc_null_create();
    }
    __p[0] = *(void **)a2;
    __p[1] = "kPosixError";
    sub_100035E70((uint64_t)__p, &v14, &v15);
    xpc_release(v15);
    xpc_object_t v15 = 0;
    xpc_release(v14);
  }
}

const void **sub_1003C6A14(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(const void ***)(a2 + 216);
  if (result)
  {
    uint64_t v12 = 0;
    (*((void (**)(const void **__return_ptr))*result + 2))(&v12);
    if (v12) {
      long long v5 = sub_100080934;
    }
    else {
      long long v5 = 0;
    }
    if (v5)
    {
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v11 = 0;
      if (ctu::cf::assign())
      {
        *(_OWORD *)a1 = *(_OWORD *)__p;
        *(void *)(a1 + 16) = v11;
        *(unsigned char *)(a1 + 24) = 1;
      }
      else
      {
        uint64_t v8 = *(NSObject **)(a2 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          long long v13 = 0uLL;
          uint64_t v14 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string buf = v13;
          uint64_t v16 = v14;
          BOOL v9 = buf;
          if (v14 < 0) {
            BOOL v9 = (uint8_t *)v13;
          }
          *(_DWORD *)OsLogContext v17 = 136315138;
          uint64_t v18 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Could not assign key '%s' value to a CFType for copying", v17, 0xCu);
          if (SHIBYTE(v16) < 0) {
            operator delete(*(void **)buf);
          }
        }
        *(unsigned char *)a1 = 0;
        *(unsigned char *)(a1 + 24) = 0;
        if (SHIBYTE(v11) < 0) {
          operator delete(__p[0]);
        }
      }
    }
    else
    {
      xpc_object_t v6 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        long long v13 = 0uLL;
        uint64_t v14 = 0;
        ctu::cf::assign();
        *(_OWORD *)std::string __p = v13;
        uint64_t v11 = v14;
        std::string::size_type v7 = __p;
        if (v14 < 0) {
          std::string::size_type v7 = (void **)v13;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N Could not convert key '%s' value to a CFType for copying", buf, 0xCu);
        if (SHIBYTE(v11) < 0) {
          operator delete(__p[0]);
        }
      }
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 24) = 0;
    }
    return sub_1000577C4(&v12);
  }
  else
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  return result;
}

void sub_1003C6C60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_1000577C4(&a16);
  _Unwind_Resume(a1);
}

void sub_1003C6CB8(uint64_t a1)
{
  Registry::getMobileHelper((uint64_t *)&handler, *(Registry **)(a1 + 48));
  long long v2 = handler;
  long long handler = 0uLL;
  int v3 = *(std::__shared_weak_count **)(a1 + 224);
  *(_OWORD *)(a1 + 216) = v2;
  if (v3)
  {
    sub_10004D2C8(v3);
    if (*((void *)&handler + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&handler + 1));
    }
  }
  Registry::createRestModuleOneTimeUseConnection(&v19, *(Registry **)(a1 + 48));
  ctu::RestModule::connect();
  int v4 = (capabilities::ct *)v20;
  if (v20) {
    sub_10004D2C8(v20);
  }
  long long v5 = (capabilities::ct *)capabilities::ct::supportsP2PAsPhone(v4);
  if (v5)
  {
    sub_100058DB0(__p, "/cc/props/phone_numbers");
    xpc_object_t v6 = operator new(0x28uLL);
    *xpc_object_t v6 = off_1019C5270;
    v6[1] = a1 + 80;
    void v6[2] = a1;
    void v6[3] = sub_1003C712C;
    v6[4] = 0;
    __int16 v25 = v6;
    ctu::RestModule::observeProperty();
    sub_10003F600(&handler);
    if (v22 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/events/nearby_device_changed");
    std::string::size_type v7 = operator new(0x20uLL);
    void *v7 = off_1019C52F0;
    v7[1] = a1;
    v7[2] = sub_1003C7454;
    void v7[3] = 0;
    __int16 v25 = v7;
    ctu::RestModule::observeEvent();
    uint64_t v8 = (capabilities::ct *)sub_10003F600(&handler);
    if (v22 < 0) {
      operator delete(__p[0]);
    }
    long long v5 = (capabilities::ct *)capabilities::ct::supportsGemini(v8);
    if (v5)
    {
      sub_100058DB0(__p, "/cc/props/cellular_plan_remotesubscription_info");
      BOOL v9 = operator new(0x28uLL);
      void *v9 = off_1019C5370;
      v9[1] = a1 + 104;
      void v9[2] = a1;
      uint64_t v9[3] = sub_1003C75B0;
      v9[4] = 0;
      __int16 v25 = v9;
      ctu::RestModule::observeProperty();
      long long v5 = (capabilities::ct *)sub_10003F600(&handler);
      if (v22 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  if (capabilities::ct::supportsP2PAsGizmo(v5))
  {
    xpc_object_t v10 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v10 || (uint64_t v11 = *(std::__shared_weak_count_vtbl **)(a1 + 8), (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
      sub_100088B9C();
    }
    long long v13 = v12;
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    p_shared_weak_owners = &v12->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v12);
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    NotifySubscription::cancel((NotifySubscription *)(a1 + 248));
    xpc_object_t v15 = (std::__shared_weak_count *)operator new(0x38uLL);
    v15->__shared_weak_owners_ = 0;
    v15->__shared_owners_ = 0;
    v15->__vftable = (std::__shared_weak_count_vtbl *)off_1019C5420;
    v15[1].__vftable = v11;
    v15[1].__shared_owners_ = (uint64_t)v13;
    v15[1].__shared_weak_owners_ = (uint64_t)sub_1003C77D8;
    v15[2].__vftable = 0;
    uint64_t v16 = *(const char **)(a1 + 248);
    OsLogContext v17 = *(NSObject **)(a1 + 256);
    *(void *)&long long handler = _NSConcreteStackBlock;
    *((void *)&handler + 1) = 1174405120;
    long long v24 = sub_1003C8D38;
    __int16 v25 = &unk_1019C53E0;
    CFTypeRef v26 = v15 + 1;
    uint64_t v27 = v15;
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    notify_register_dispatch(v16, (int *)(a1 + 264), v17, &handler);
    if (v27) {
      sub_10004D2C8(v27);
    }
    sub_10004D2C8(v15);
    std::__shared_weak_count::__release_weak(v13);
    sub_10004D2C8(v13);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v18 = operator new(0x20uLL);
  *uint64_t v18 = off_1019C5470;
  v18[1] = a1;
  v18[2] = sub_1003C78D4;
  v18[3] = 0;
  __int16 v25 = v18;
  ctu::RestModule::observeEvent();
  sub_10003F600(&handler);
  if (v22 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1003C7094(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1003C712C(uint64_t a1, uint64_t a2)
{
  uint64_t v32 = 0;
  *(_OWORD *)CFTypeRef v30 = 0u;
  long long v31 = 0u;
  long long v29 = 0u;
  memset(v28, 0, sizeof(v28));
  int v4 = sub_1003C7B68(a1);
  int v5 = v4;
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v7 = a2 + 8;
  uint64_t v6 = v8;
  if (v8)
  {
    uint64_t v9 = v7;
    do
    {
      int v10 = *(_DWORD *)(v6 + 32);
      BOOL v11 = v10 < v4;
      if (v10 >= v4) {
        uint64_t v12 = (uint64_t *)v6;
      }
      else {
        uint64_t v12 = (uint64_t *)(v6 + 8);
      }
      if (!v11) {
        uint64_t v9 = v6;
      }
      uint64_t v6 = *v12;
    }
    while (*v12);
    if (v9 != v7 && v4 >= *(_DWORD *)(v9 + 32))
    {
      std::string::operator=((std::string *)v28, (const std::string *)(v9 + 40));
      std::string::operator=((std::string *)&v28[24], (const std::string *)(v9 + 64));
      LODWORD(v30[0]) = *(_DWORD *)(v9 + 88);
      std::string::operator=((std::string *)&v30[1], (const std::string *)(v9 + 96));
      LOBYTE(v32) = *(unsigned char *)(v9 + 120);
    }
  }
  uint64_t v13 = *(void *)(a1 + 88);
  uint64_t v27 = 0;
  *(_OWORD *)__int16 v25 = 0u;
  long long v26 = 0u;
  long long v24 = 0u;
  memset(v23, 0, sizeof(v23));
  if (v13)
  {
    uint64_t v14 = a1 + 88;
    do
    {
      int v15 = *(_DWORD *)(v13 + 32);
      BOOL v16 = v15 < v5;
      if (v15 >= v5) {
        OsLogContext v17 = (uint64_t *)v13;
      }
      else {
        OsLogContext v17 = (uint64_t *)(v13 + 8);
      }
      if (!v16) {
        uint64_t v14 = v13;
      }
      uint64_t v13 = *v17;
    }
    while (*v17);
    if (v14 != a1 + 88 && v5 >= *(_DWORD *)(v14 + 32))
    {
      std::string::operator=((std::string *)v23, (const std::string *)(v14 + 40));
      std::string::operator=((std::string *)&v23[24], (const std::string *)(v14 + 64));
      LODWORD(v25[0]) = *(_DWORD *)(v14 + 88);
      std::string::operator=((std::string *)&v25[1], (const std::string *)(v14 + 96));
      LOBYTE(v27) = *(unsigned char *)(v14 + 120);
    }
  }
  if ((rest::operator==() & 1) == 0)
  {
    uint64_t v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = *(unsigned char **)v23;
      if (v23[23] >= 0) {
        uint64_t v19 = v23;
      }
      if ((_BYTE)v27) {
        CFMutableDictionaryRef v20 = "true";
      }
      else {
        CFMutableDictionaryRef v20 = "false";
      }
      *(_DWORD *)std::string buf = 136315394;
      __int16 v34 = v19;
      __int16 v35 = 2080;
      __int16 v36 = v20;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Phone number changed to '%s' with read attempted %s", buf, 0x16u);
    }
    if ((v23[23] & 0x80000000) != 0)
    {
      sub_10004FC84(__p, *(void **)v23, *(unint64_t *)&v23[8]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v23;
      uint64_t v22 = *(void *)&v23[16];
    }
    sub_1003C7C54((os_log_t *)(a1 + 40), (uint64_t *)(a1 + 216), (uint64_t *)(a1 + 232), (uint64_t)__p);
    if (SHIBYTE(v22) < 0) {
      operator delete(__p[0]);
    }
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(v25[1]);
  }
  if (SHIBYTE(v24) < 0) {
    operator delete(*(void **)&v23[24]);
  }
  if ((v23[23] & 0x80000000) != 0) {
    operator delete(*(void **)v23);
  }
  if (SHIBYTE(v31) < 0) {
    operator delete(v30[1]);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(*(void **)&v28[24]);
  }
  if ((v28[23] & 0x80000000) != 0) {
    operator delete(*(void **)v28);
  }
}

void sub_1003C7410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10019693C((uint64_t)&a16);
  sub_10019693C((uint64_t)&a28);
  _Unwind_Resume(a1);
}

void sub_1003C7454(uint64_t a1, uint64_t *a2)
{
  if (*((unsigned char *)a2 + 24))
  {
    uint64_t v3 = *(void *)(a1 + 232);
    if (v3)
    {
      int v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) >= 0) {
          uint64_t v6 = a2;
        }
        else {
          uint64_t v6 = (uint64_t *)*a2;
        }
        LODWORD(__p) = 136315138;
        *(void *)((char *)&__p + 4) = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Device with ID '%s' is in proximity, will sync preferences", (uint8_t *)&__p, 0xCu);
        uint64_t v3 = *(void *)(a1 + 232);
      }
      uint64_t v7 = operator new(8uLL);
      uint64_t v8 = kCommCenterSharedSettingsBundleId;
      *(void *)&long long __p = v7;
      void *v7 = @"CompanionPhoneNumber";
      int v10 = v7 + 1;
      *((void *)&__p + 1) = v7 + 1;
      (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)v3 + 16))(v3, v8, &__p);
      if ((void)__p)
      {
        *((void *)&__p + 1) = __p;
        operator delete((void *)__p);
      }
    }
  }
}

void sub_1003C758C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003C75B0(uint64_t a1)
{
  int v2 = sub_1003C7B68(a1);
  uint64_t v3 = *(void *)(a1 + 88);
  uint64_t v17 = 0;
  *(_OWORD *)int v15 = 0u;
  long long v16 = 0u;
  long long v14 = 0u;
  memset(v13, 0, sizeof(v13));
  if (v3)
  {
    uint64_t v4 = a1 + 88;
    do
    {
      int v5 = *(_DWORD *)(v3 + 32);
      BOOL v6 = v5 < v2;
      if (v5 >= v2) {
        uint64_t v7 = (uint64_t *)v3;
      }
      else {
        uint64_t v7 = (uint64_t *)(v3 + 8);
      }
      if (!v6) {
        uint64_t v4 = v3;
      }
      uint64_t v3 = *v7;
    }
    while (*v7);
    if (v4 != a1 + 88 && v2 >= *(_DWORD *)(v4 + 32))
    {
      std::string::operator=((std::string *)v13, (const std::string *)(v4 + 40));
      std::string::operator=((std::string *)&v13[24], (const std::string *)(v4 + 64));
      LODWORD(v15[0]) = *(_DWORD *)(v4 + 88);
      std::string::operator=((std::string *)&v15[1], (const std::string *)(v4 + 96));
      LOBYTE(v17) = *(unsigned char *)(v4 + 120);
    }
  }
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = subscriber::asString();
    int v10 = v13;
    if (v13[23] < 0) {
      int v10 = *(unsigned char **)v13;
    }
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v19 = v9;
    __int16 v20 = 2080;
    long long v21 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Remote (%s) plan changed changed, phone number is now '%s'", buf, 0x16u);
  }
  if ((v13[23] & 0x80000000) != 0)
  {
    sub_10004FC84(__p, *(void **)v13, *(unint64_t *)&v13[8]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v13;
    uint64_t v12 = *(void *)&v13[16];
  }
  sub_1003C7C54((os_log_t *)(a1 + 40), (uint64_t *)(a1 + 216), (uint64_t *)(a1 + 232), (uint64_t)__p);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(v15[1]);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(*(void **)&v13[24]);
  }
  if ((v13[23] & 0x80000000) != 0) {
    operator delete(*(void **)v13);
  }
}

void sub_1003C77A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
}

void sub_1003C77D8(uint64_t a1)
{
  *(_OWORD *)long long __p = 0u;
  long long v5 = 0u;
  sub_1003C6A14((uint64_t)__p, a1);
  if (BYTE8(v5))
  {
    int v2 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_6;
    }
    uint64_t v3 = __p;
    if (SBYTE7(v5) < 0) {
      uint64_t v3 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Got companion phone number: '%s'", buf, 0xCu);
    if (BYTE8(v5))
    {
LABEL_6:
      if (SBYTE7(v5) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

unsigned char *sub_1003C78D4(uint64_t a1)
{
  uint64_t result = (unsigned char *)capabilities::ct::supportsP2PAsPhone((capabilities::ct *)a1);
  if (result)
  {
    memset(v10, 0, sizeof(v10));
    if (*(unsigned char *)(a1 + 104) && (sub_1003C8068((uint64_t)v10, (long long *)(a1 + 112)), LOBYTE(v10[0])))
    {
      uint64_t v3 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = 136315138;
        uint64_t v9 = subscriber::asString();
        uint64_t v4 = "#I Remote plan: %s";
        long long v5 = v3;
        uint32_t v6 = 12;
LABEL_8:
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)&v8, v6);
      }
    }
    else
    {
      uint64_t v7 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v8) = 0;
        uint64_t v4 = "#I No remote plan found";
        long long v5 = v7;
        uint32_t v6 = 2;
        goto LABEL_8;
      }
    }
    return sub_1003C8134(v10);
  }
  return result;
}

void sub_1003C79F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1003C8134(va);
  _Unwind_Resume(a1);
}

void sub_1003C7A10(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    long long v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v14 = v4;
  int v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v14);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_13;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
  if (!v10) {
    goto LABEL_13;
  }
LABEL_10:
  (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v10 + 16))(&v14, v10);
  long long v12 = v14;
  long long v14 = 0uLL;
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 240);
  *(_OWORD *)(a1 + 232) = v12;
  if (v13)
  {
    sub_10004D2C8(v13);
    if (*((void *)&v14 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v14 + 1));
    }
  }
LABEL_13:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_1003C7B44(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003C7B60(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 64));
}

uint64_t sub_1003C7B68(uint64_t a1)
{
  if (!capabilities::ct::supportsGemini((capabilities::ct *)a1)) {
    return 1;
  }
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  if (*(unsigned char *)(a1 + 104) && (sub_1003C8068((uint64_t)v6, (long long *)(a1 + 112)), LOBYTE(v6[0])))
  {
    uint64_t v2 = DWORD2(v7);
  }
  else
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Missing remote plan subscription", v5, 2u);
    }
    uint64_t v2 = 1;
  }
  sub_1003C8134(v6);
  return v2;
}

const void **sub_1003C7C54(os_log_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  long long v21 = 0;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(v19, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v19 = *(_OWORD *)a4;
    __int16 v20 = *(void **)(a4 + 16);
  }
  if (SHIBYTE(v20) < 0)
  {
    sub_10004FC84(__dst, v19[0], (unint64_t)v19[1]);
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)v19;
    long long v24 = v20;
  }
  uint64_t v22 = 0;
  if (SHIBYTE(v24) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    long long v26 = v24;
  }
  uint64_t v27 = 0;
  if (ctu::cf::convert_copy())
  {
    long long v7 = v22;
    uint64_t v22 = v27;
    *(void *)std::string buf = v7;
    sub_1000558F4((const void **)buf);
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(__p[0]);
  }
  long long v21 = v22;
  uint64_t v22 = 0;
  sub_1000558F4(&v22);
  if (SHIBYTE(v24) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v19[0]);
  }
  if (v21) {
    int v8 = sub_1000810B8;
  }
  else {
    int v8 = 0;
  }
  if (v8)
  {
    uint64_t v9 = *a2;
    uint64_t v10 = kCommCenterSharedSettingsBundleId;
    if ((*(uint64_t (**)(uint64_t, void, const __CFString *))(*(void *)v9 + 24))(v9, kCommCenterSharedSettingsBundleId, @"CompanionPhoneNumber"))
    {
      uint64_t v11 = *a3;
      if (v11)
      {
        long long v12 = operator new(8uLL);
        __p[0] = v12;
        void *v12 = @"CompanionPhoneNumber";
        __p[1] = v12 + 1;
        long long v26 = v12 + 1;
        (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v11 + 16))(v11, v10, __p);
        uint64_t v13 = __p[0];
        if (__p[0])
        {
          __p[1] = __p[0];
LABEL_36:
          operator delete(v13);
          return sub_1000558F4(&v21);
        }
      }
      return sub_1000558F4(&v21);
    }
    long long v14 = *a1;
    if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT)) {
      return sub_1000558F4(&v21);
    }
    __p[0] = 0;
    __p[1] = 0;
    long long v26 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long __dst = *(_OWORD *)__p;
    long long v24 = v26;
    uint64_t v17 = __dst;
    if (SHIBYTE(v26) < 0) {
      uint64_t v17 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v17;
    long long v16 = "#N Could not save key '%s' value to shared settings";
  }
  else
  {
    long long v14 = *a1;
    if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT)) {
      return sub_1000558F4(&v21);
    }
    __p[0] = 0;
    __p[1] = 0;
    long long v26 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long __dst = *(_OWORD *)__p;
    long long v24 = v26;
    int v15 = __dst;
    if (SHIBYTE(v26) < 0) {
      int v15 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v15;
    long long v16 = "#N Could not convert key '%s' value to a CFType for saving";
  }
  _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v16, buf, 0xCu);
  if (SHIBYTE(v24) < 0)
  {
    uint64_t v13 = __dst[0];
    goto LABEL_36;
  }
  return sub_1000558F4(&v21);
}

void sub_1003C7F8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a16);
  _Unwind_Resume(a1);
}

void sub_1003C8030(uint64_t a1)
{
  sub_1003C8244(a1);

  operator delete();
}

uint64_t sub_1003C8068(uint64_t a1, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *(void *)(a1 + 24) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + 8) = v4;
  }
  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 6);
  sub_100311E70(a1 + 40, (uint64_t)(a2 + 2));
  uint64_t result = sub_100311E70(a1 + 72, (uint64_t)(a2 + 4));
  *(_DWORD *)(a1 + 104) = *((_DWORD *)a2 + 24);
  *(unsigned char *)a1 = 1;
  return result;
}

void sub_1003C80F4(_Unwind_Exception *exception_object)
{
  if (*v3)
  {
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    *uint64_t v3 = 0;
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_1003C8134(unsigned char *a1)
{
  if (*a1) {
    sub_1003C816C((uint64_t)a1);
  }
  return a1;
}

void sub_1003C816C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    if (*(char *)(a1 + 103) < 0) {
      operator delete(*(void **)(a1 + 80));
    }
    *(unsigned char *)(a1 + 72) = 0;
  }
  if (*(unsigned char *)(a1 + 40))
  {
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    *(unsigned char *)(a1 + 40) = 0;
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  *(unsigned char *)a1 = 0;
}

uint64_t sub_1003C81D8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    if (*(char *)(a1 + 95) < 0) {
      operator delete(*(void **)(a1 + 72));
    }
    *(unsigned char *)(a1 + 64) = 0;
  }
  if (*(unsigned char *)(a1 + 32))
  {
    if (*(char *)(a1 + 63) < 0) {
      operator delete(*(void **)(a1 + 40));
    }
    *(unsigned char *)(a1 + 32) = 0;
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1003C8244(uint64_t a1)
{
  *(void *)a1 = off_1019C5128;
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 248));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 240);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 224);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1003C8134((unsigned char *)(a1 + 104));
  sub_100087ED0(a1 + 80, *(void **)(a1 + 88));
  long long v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4) {
    sub_10004D2C8(v4);
  }
  long long v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  CompanionPhoneNumberSyncInterface::~CompanionPhoneNumberSyncInterface((CompanionPhoneNumberSyncInterface *)a1);
}

void sub_1003C82F0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1003C83BC(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1003C8494);
  __cxa_rethrow();
}

void sub_1003C83E4(_Unwind_Exception *a1)
{
}

void sub_1003C83FC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1003C8434(uint64_t a1)
{
}

uint64_t sub_1003C8450(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1003C8494(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1003C84C4()
{
}

__n128 sub_1003C84D8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019C5270;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1003C852C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C5270;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1003C8564(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  long long v4 = v3 + 1;
  long long v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    *uint64_t v3 = v4;
    *long long v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008B2E4((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087ED0((uint64_t)&v9, v10);
}

void sub_1003C8624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1003C863C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003C867C()
{
}

void sub_1003C868C()
{
}

__n128 sub_1003C86A0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019C52F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1003C86F4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C52F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1003C872C(void *a1)
{
  *(_OWORD *)long long __p = 0u;
  long long v6 = 0u;
  rest::read_rest_value();
  uint64_t v2 = (void (*)(void *, void **))a1[2];
  uint64_t v3 = a1[3];
  long long v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, void **))(*v4 + v2);
  }
  v2(v4, __p);
  if (SBYTE7(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1003C87C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003C87DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003C881C()
{
}

void sub_1003C882C()
{
}

__n128 sub_1003C8840(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019C5370;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1003C8894(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C5370;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

unsigned char *sub_1003C88CC(void *a1, cellplan::RemoteSimSubscriptionInfo *a2)
{
  uint64_t v3 = a1[1];
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  memset(v11, 0, sizeof(v11));
  if (*(unsigned char *)v3)
  {
    long long v4 = *(_OWORD *)(v3 + 8);
    *((void *)&v11[1] + 1) = *(void *)(v3 + 24);
    *(_OWORD *)((char *)v11 + 8) = v4;
    *(void *)(v3 + 16) = 0;
    *(void *)(v3 + 24) = 0;
    *(void *)(v3 + 8) = 0;
    LODWORD(v12) = *(_DWORD *)(v3 + 32);
    if (*(unsigned char *)(v3 + 40))
    {
      long long v5 = *(_OWORD *)(v3 + 48);
      *(void *)&long long v14 = *(void *)(v3 + 64);
      long long v13 = v5;
      *(void *)(v3 + 56) = 0;
      *(void *)(v3 + 64) = 0;
      *(void *)(v3 + 48) = 0;
      BYTE8(v12) = 1;
    }
    BYTE8(v14) = 0;
    if (*(unsigned char *)(v3 + 72))
    {
      long long v6 = *(_OWORD *)(v3 + 80);
      *(void *)&long long v16 = *(void *)(v3 + 96);
      long long v15 = v6;
      *(void *)(v3 + 88) = 0;
      *(void *)(v3 + 96) = 0;
      *(void *)(v3 + 80) = 0;
      BYTE8(v14) = 1;
    }
    DWORD2(v16) = *(_DWORD *)(v3 + 104);
    LOBYTE(v11[0]) = 1;
  }
  sub_1003C8A7C((unsigned char *)v3, a2);
  uint64_t v7 = (void (*)(void *, _OWORD *))a1[3];
  uint64_t v8 = a1[4];
  uint64_t v9 = (void *)(a1[2] + (v8 >> 1));
  if (v8) {
    uint64_t v7 = *(void (**)(void *, _OWORD *))(*v9 + v7);
  }
  v7(v9, v11);
  return sub_1003C8134(v11);
}

void sub_1003C8A1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t sub_1003C8A30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003C8A70()
{
}

void sub_1003C8A7C(unsigned char *a1, cellplan::RemoteSimSubscriptionInfo *a2)
{
  if (xpc_get_type(*(xpc_object_t *)a2) == (xpc_type_t)&_xpc_type_null)
  {
    sub_1003C8C7C(a1);
  }
  else
  {
    if (!*a1)
    {
      char v8 = 0;
      char v11 = 0;
      int v14 = 0;
      uint64_t v6 = 0;
      long long v5 = 0uLL;
      int v7 = 0;
      sub_1003C8CA0((uint64_t)a1, &v5);
      if (v11)
      {
        if (v13 < 0) {
          operator delete(__p);
        }
        char v11 = 0;
      }
      if (v8)
      {
        if (v10 < 0) {
          operator delete(v9);
        }
        char v8 = 0;
      }
      if (SHIBYTE(v6) < 0) {
        operator delete((void *)v5);
      }
      if (!*a1) {
        __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
      }
    }
    cellplan::read_rest_value((cellplan *)(a1 + 8), a2, v4);
  }
}

void sub_1003C8BD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1003C8BF0(uint64_t result, long long *a2)
{
  long long v2 = *a2;
  *(void *)(result + 24) = *((void *)a2 + 2);
  *(_OWORD *)(result + 8) = v2;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(result + 32) = *((_DWORD *)a2 + 6);
  *(unsigned char *)(result + 40) = 0;
  if (*((unsigned char *)a2 + 32))
  {
    long long v3 = *(long long *)((char *)a2 + 40);
    *(void *)(result + 64) = *((void *)a2 + 7);
    *(_OWORD *)(result + 48) = v3;
    *((void *)a2 + 6) = 0;
    *((void *)a2 + 7) = 0;
    *((void *)a2 + 5) = 0;
    *(unsigned char *)(result + 40) = 1;
  }
  *(unsigned char *)(result + 72) = 0;
  if (*((unsigned char *)a2 + 64))
  {
    long long v4 = *(long long *)((char *)a2 + 72);
    *(void *)(result + 96) = *((void *)a2 + 11);
    *(_OWORD *)(result + 80) = v4;
    *((void *)a2 + 10) = 0;
    *((void *)a2 + 11) = 0;
    *((void *)a2 + 9) = 0;
    *(unsigned char *)(result + 72) = 1;
  }
  *(_DWORD *)(result + 104) = *((_DWORD *)a2 + 24);
  *(unsigned char *)__n128 result = 1;
  return result;
}

void sub_1003C8C7C(unsigned char *a1)
{
  if (*a1) {
    sub_1003C816C((uint64_t)a1);
  }
}

void sub_1003C8CA0(uint64_t a1, long long *a2)
{
  if (*(unsigned char *)a1) {
    sub_1003C8CB0(a1, a2);
  }
  else {
    sub_1003C8BF0(a1, a2);
  }
}

void sub_1003C8CB0(uint64_t a1, long long *a2)
{
  uint64_t v4 = a1 + 8;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)v4);
  }
  long long v5 = *a2;
  *(void *)(v4 + 16) = *((void *)a2 + 2);
  *(_OWORD *)uint64_t v4 = v5;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 6);
  sub_1003464A0(a1 + 40, (uint64_t)(a2 + 2));
  sub_1003464A0(a1 + 72, (uint64_t)(a2 + 4));
  *(_DWORD *)(a1 + 104) = *((_DWORD *)a2 + 24);
}

void sub_1003C8D38(uint64_t a1, uint64_t a2)
{
  long long v2 = *(void **)(a1 + 32);
  long long v3 = (std::__shared_weak_count *)v2[1];
  if (v3)
  {
    long long v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (*v2)
      {
        int v7 = (void (*)(void *, uint64_t))v2[2];
        uint64_t v8 = v2[3];
        uint64_t v9 = (void *)(*v2 + (v8 >> 1));
        if (v8) {
          int v7 = *(void (**)(void *, uint64_t))(*v9 + v7);
        }
        v7(v9, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1003C8DEC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1003C8E00(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1003C8E1C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1003C8E2C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019C5420;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1003C8E4C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019C5420;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1003C8EA0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1003C8EB8()
{
}

__n128 sub_1003C8ECC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019C5470;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1003C8F20(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019C5470;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1003C8F58(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  long long v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1003C8FA0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003C8FE0()
{
}

void sub_1003C8FEC()
{
}

void sub_1003C9028(BasebandControllerFactoryInterface *a1)
{
  BasebandControllerFactoryInterface::~BasebandControllerFactoryInterface(a1);

  operator delete();
}

void sub_1003C9108(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1003C9280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1003C92C0(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  if (v2 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    long long v3 = [(NSError *)v2 localizedDescription];
    int v4 = 138412290;
    long long v5 = v3;
    _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "displayNotification error: %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1003C9384(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1003C93A8(uint64_t a1, uint64_t a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CDA8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0CDA8))
  {
    __cxa_atexit((void (*)(void *))sub_1003C9EA4, &qword_101B0CDB8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0CDA8);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1003C9ED4;
  block[3] = &unk_1019A1BF8;
  block[4] = a1;
  if (qword_101B0CDB0 != -1) {
    dispatch_once(&qword_101B0CDB0, block);
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v10 = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v10 = *(void *)(a2 + 16);
  }
  int v7 = 0;
  uint64_t v8 = 0;
  sub_100370CC0(a1, @"NETWORK_SLICING_DISCOVERED_MSG");
  int v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int buf = 136315394;
    uint64_t buf_4 = v5;
    __int16 buf_12 = 2080;
    buf_14 = " ";
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "#E %s%sdisplayNotification message is empty", (uint8_t *)&buf, 0x16u);
  }
  sub_1000558F4(&v7);

  sub_1000558F4(&v8);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void sub_1003C9D84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  sub_1000558F4(&a17);
  sub_1000558F4(&a18);
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1003C9EA4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1003C9ED4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = operator new(0x28uLL);
  v2[1] = 0;
  void v2[2] = 0;
  void *v2 = off_1019C5550;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v6, kCtLoggingSystemName, "ps.slc.ntfy");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, &v6);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v2 + 3), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v6);
  void v2[4] = 0;
  long long v3 = [[NRSlicingNotificationManagerImpl alloc] initWithQueue:*(void *)(v1 + 24)];
  int v4 = (void *)v2[4];
  void v2[4] = v3;

  uint64_t v5 = (std::__shared_weak_count *)qword_101B0CDC0;
  qword_101B0CDB8 = (uint64_t)(v2 + 3);
  qword_101B0CDC0 = (uint64_t)v2;
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_1003C9FB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  std::__shared_weak_count::~__shared_weak_count(v2);
  operator delete(v4);
  _Unwind_Resume(a1);
}

void sub_1003CA004(unint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  int v4 = +[NSMutableData dataWithLength:32];
  sub_100058DB0(&v17, "Category:");
  std::to_string(&__p, a1);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v7 = std::string::append(&v17, (const std::string::value_type *)p_p, size);
  long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  std::string::size_type v19 = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)uint64_t v18 = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v17.__r_.__value_.__l.__data_);
  }
  CC_LONG v9 = HIBYTE(v19);
  char v11 = (void **)v18[0];
  CC_LONG v10 = (CC_LONG)v18[1];
  id v12 = v4;
  char v13 = (unsigned __int8 *)[v12 bytes];
  if ((v9 & 0x80u) == 0) {
    int v14 = v18;
  }
  else {
    int v14 = v11;
  }
  if ((v9 & 0x80u) == 0) {
    CC_LONG v15 = v9;
  }
  else {
    CC_LONG v15 = v10;
  }
  CC_SHA256(v14, v15, v13);
  *a2 = [v12 base64EncodedStringWithOptions:0];
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[0]);
  }
}

void sub_1003CA12C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1003CA184(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019C5550;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1003CA1A4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019C5550;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1003CA1F8(uint64_t a1)
{
  uint64_t v1 = (ctu::OsLogLogger *)(a1 + 24);

  ctu::OsLogLogger::~OsLogLogger(v1);
}

void sub_1003CA238(uint64_t a1, void *a2)
{
  *a2 = 0;
  sub_100A27244();
}

void sub_1003CA290(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003CA2AC(DesenseFactoryInterface *a1)
{
  DesenseFactoryInterface::~DesenseFactoryInterface(a1);

  operator delete();
}

void sub_1003CA2E4(void *a1, void *a2)
{
}

void sub_1003CA468(_Unwind_Exception *a1)
{
  if (*(unsigned char *)(v1 + 184)) {
    sub_10012577C(v6);
  }
  sub_1000346F8(v5, *v7);
  sub_1003CA4C8(v4);
  sub_1003CA4C8(v3);
  sub_10012577C(v2);
  sub_1002B4928((void *)v1);
  _Unwind_Resume(a1);
}

void sub_1003CA4C8(ctu::OsLogLogger *this)
{
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }

  ctu::OsLogLogger::~OsLogLogger(this);
}

uint64_t sub_1003CA50C(uint64_t a1)
{
  *(void *)a1 = off_1019C55E0;
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BC8FAC((CFUUIDRef *)(a1 + 64), __p);
    long long v3 = v8 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int buf = 136446210;
    CC_LONG v10 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [Destroyed] ID: %{public}s", buf, 0xCu);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }
  if (*(unsigned char *)(a1 + 184)) {
    sub_10012577C((const void **)(a1 + 168));
  }
  sub_1000346F8(a1 + 136, *(void **)(a1 + 144));
  int v4 = *(void **)(a1 + 112);
  if (v4)
  {
    *(void *)(a1 + 120) = v4;
    operator delete(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 104));
  uint64_t v5 = *(void **)(a1 + 80);
  if (v5)
  {
    *(void *)(a1 + 88) = v5;
    operator delete(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 72));
  sub_10012577C((const void **)(a1 + 64));
  sub_1002B4928((void *)a1);
  return a1;
}

void sub_1003CA660(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1003CA670(uint64_t a1)
{
  sub_1003CA50C(a1);

  operator delete();
}

uint64_t sub_1003CA6A8()
{
  return 1;
}

void sub_1003CA6B0(uint64_t a1, int a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 161);
  if (*(unsigned char *)(a1 + 161)) {
    int v4 = (*(unsigned char *)(a1 + 160) + 1) & 0xF;
  }
  if (v4 == a2)
  {
    uint64_t v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 67109120;
      v6[1] = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Token marked as used: %hhu", (uint8_t *)v6, 8u);
    }
    *(_WORD *)(a1 + 160) = a2 | 0x100;
  }
}

ctu::OsLogLogger *sub_1003CA77C(ctu::OsLogLogger *a1, char *a2)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, a2);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v5, &v4);
  ctu::OsLogLogger::OsLogLogger(a1, (const ctu::OsLogLogger *)v5);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v5);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
  *((void *)a1 + 1) = 0;
  *((void *)a1 + 2) = 0;
  *((void *)a1 + 3) = 0;
  return a1;
}

void sub_1003CA7F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1003CA814(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16) - v3;
  if (v4)
  {
    unint64_t v2 = v4 >> 4;
    uint64_t v4 = v3 + 8;
    unint64_t v5 = 1;
    while (*(void *)(v4 - 8) != a2)
    {
      ++v5;
      v4 += 16;
      if (v5 > v2)
      {
        LODWORD(v4) = 0;
        goto LABEL_6;
      }
    }
    LOWORD(v2) = *(unsigned __int8 *)v4;
    LODWORD(v4) = 1;
  }
  else
  {
LABEL_6:
    LOBYTE(v5) = 0;
  }
  return (unsigned __int16)(v5 | (unsigned __int16)((_WORD)v2 << 8)) | (v4 << 16);
}

unint64_t sub_1003CA86C(uint64_t a1, unsigned int a2)
{
  if (a2 && (uint64_t v2 = *(void *)(a1 + 8), a2 <= (unint64_t)((*(void *)(a1 + 16) - v2) >> 4)))
  {
    uint64_t v4 = *(void *)(v2 + 16 * (a2 - 1));
    unint64_t v3 = v4 & 0xFFFFFFFFFFFFFF00;
    uint64_t v4 = v4;
  }
  else
  {
    unint64_t v3 = 0;
    uint64_t v4 = 0;
  }
  return v4 | v3;
}

uint64_t sub_1003CA8B4(NSObject **a1, unint64_t a2)
{
  if (HIBYTE(a2)) {
    goto LABEL_4;
  }
  unsigned int v5 = sub_1003CA814((uint64_t)a1, a2);
  if ((v5 & 0xFFFFFF) >= 0x10000)
  {
    LOBYTE(v10) = v5;
    __int16 v2 = v5 >> 8;
LABEL_23:
    int v9 = 1;
    return (unsigned __int16)(v10 | (unsigned __int16)(v2 << 8)) | (v9 << 16);
  }
  uint64_t v7 = a1[1];
  OsLogContext v6 = a1[2];
  uint64_t v8 = (char *)v6 - (char *)v7;
  if ((unint64_t)((char *)v6 - (char *)v7) <= 0x60)
  {
    unint64_t v11 = (unint64_t)a1[3];
    if ((unint64_t)v6 >= v11)
    {
      uint64_t v13 = v8 >> 4;
      uint64_t v14 = v11 - (void)v7;
      if (v14 >> 3 <= (unint64_t)((v8 >> 4) + 1)) {
        uint64_t v15 = v13 + 1;
      }
      else {
        uint64_t v15 = v14 >> 3;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v16 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v15;
      }
      if (v16 >> 60) {
        sub_10006A7CC();
      }
      std::string v17 = (char *)operator new(16 * v16);
      uint64_t v18 = &v17[16 * v13];
      *(void *)uint64_t v18 = a2;
      unsigned char v18[8] = 0;
      id v12 = (v18 + 16);
      if (v6 != v7)
      {
        do
        {
          Class isa = v6[-2].isa;
          v6 -= 2;
          char v20 = (char)v6[1].isa;
          *((void *)v18 - 2) = isa;
          v18 -= 16;
          unsigned char v18[8] = v20;
        }
        while (v6 != v7);
        OsLogContext v6 = v7;
      }
      a1[1] = v18;
      a1[2] = v12;
      a1[3] = &v17[16 * v16];
      if (v6) {
        operator delete(v6);
      }
    }
    else
    {
      v6->Class isa = (Class)a2;
      LOBYTE(v6[1].isa) = 0;
      id v12 = v6 + 2;
    }
    a1[2] = v12;
    uint64_t v22 = a1;
    long long v21 = *a1;
    unint64_t v23 = (char *)v12 - (char *)v22[1];
    unint64_t v10 = v23 >> 4;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      v25[0] = 67109376;
      v25[1] = (v23 >> 4);
      __int16 v26 = 2048;
      unint64_t v27 = a2;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I [Assigned] index: %hhu, short handle %llu, confirmed: false", (uint8_t *)v25, 0x12u);
    }
    __int16 v2 = 0;
    goto LABEL_23;
  }
LABEL_4:
  int v9 = 0;
  LOBYTE(v10) = 0;
  return (unsigned __int16)(v10 | (unsigned __int16)(v2 << 8)) | (v9 << 16);
}

void sub_1003CAA78(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1003CA814(a1, a2);
  if ((v3 & 0xFFFFFF) >= 0x10000 && (v3 & 0xFF00) == 0)
  {
    sub_1003CAAD4(a1, v3);
  }
}

void sub_1003CAAD4(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (a2 <= (unint64_t)((*(void *)(a1 + 16) - v4) >> 4))
    {
      unsigned int v5 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = *(void *)(v4 + 16 * (a2 - 1));
        v7[0] = 67109376;
        v7[1] = a2;
        __int16 v8 = 2048;
        uint64_t v9 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [Confirmed] index: %hhu, short handle: %llu, confirmed: true", (uint8_t *)v7, 0x12u);
        uint64_t v4 = *(void *)(a1 + 8);
      }
      *(unsigned char *)(v4 + 16 * (a2 - 1) + 8) = 1;
    }
  }
}

uint64_t sub_1003CABCC(uint64_t result, uint64_t a2)
{
  if (*(void *)(a2 + 24))
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 8);
    if (*(void *)(result + 16) != v3)
    {
      uint64_t v5 = 0;
      unint64_t v6 = 1;
      do
      {
        __n128 result = sub_1003CAC3C(a2, v6++, *(void *)(v3 + v5));
        uint64_t v3 = *(void *)(v2 + 8);
        v5 += 16;
      }
      while (v6 <= (*(void *)(v2 + 16) - v3) >> 4);
    }
  }
  return result;
}

uint64_t sub_1003CAC3C(uint64_t a1, char a2, uint64_t a3)
{
  char v6 = a2;
  uint64_t v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *, uint64_t *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void sub_1003CAC98(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Mark all handles as unconfirmed", buf, 2u);
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4 != v3)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 1;
    do
    {
      uint64_t v7 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = *(void *)(v3 + v5);
        unint64_t v9 = v6 - 1;
        *(_DWORD *)int buf = 134218240;
        unint64_t v11 = v6;
        __int16 v12 = 2048;
        uint64_t v13 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [Unconfirmed] index: %zu, short handle: %llu, confirmed: false", buf, 0x16u);
        uint64_t v3 = *(void *)(a1 + 8);
        uint64_t v4 = *(void *)(a1 + 16);
      }
      else
      {
        unint64_t v9 = v6 - 1;
      }
      *(unsigned char *)(v3 + 16 * v9 + 8) = 0;
      ++v6;
      v5 += 16;
    }
    while (v6 <= (v4 - v3) >> 4);
  }
}

void sub_1003CADF0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 != v2)
  {
    uint64_t v4 = 0;
    unint64_t v5 = 1;
    do
    {
      unint64_t v6 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(void *)(v2 + v4);
        uint64_t v8 = "true";
        if (!*(unsigned char *)(v2 + v4 + 8)) {
          uint64_t v8 = "false";
        }
        *(_DWORD *)int buf = 134218498;
        unint64_t v10 = v5;
        __int16 v11 = 2048;
        uint64_t v12 = v7;
        __int16 v13 = 2080;
        uint64_t v14 = v8;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [d] Index: %zu, short handle: %llu, confirmed: %s", buf, 0x20u);
        uint64_t v2 = *(void *)(a1 + 8);
        uint64_t v1 = *(void *)(a1 + 16);
      }
      ++v5;
      v4 += 16;
    }
    while (v5 <= (v1 - v2) >> 4);
  }
}

uint64_t sub_1003CAF24(uint64_t a1, const void **a2, int a3)
{
  uint64_t v4 = *a2;
  if (*a2) {
    unint64_t v5 = sub_100136254;
  }
  else {
    unint64_t v5 = 0;
  }
  if (!v5) {
    return 0;
  }
  unint64_t v6 = *(const void **)(a1 + 64);
  if (!(v6 ? sub_100136254 : 0)) {
    return 0;
  }
  uint64_t result = CFEqual(v4, v6);
  if (!result) {
    return result;
  }
  if (*(unsigned char *)(a1 + 193) && *(unsigned __int8 *)(a1 + 192) == a3) {
    return 0;
  }
  unint64_t v10 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    v11[0] = 67109120;
    v11[1] = a3;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [CarrierPigeonStartMessage] Attempted, token: %hhu", (uint8_t *)v11, 8u);
  }
  *(_WORD *)(a1 + 192) = a3 | 0x100;
  sub_1003CA6B0(a1, a3);
  return 1;
}

uint64_t sub_1003CB048(uint64_t a1, const void **a2, int a3)
{
  uint64_t v4 = *a2;
  if (*a2) {
    unint64_t v5 = sub_100136254;
  }
  else {
    unint64_t v5 = 0;
  }
  if (!v5) {
    return 0;
  }
  unint64_t v6 = *(const void **)(a1 + 64);
  if (!(v6 ? sub_100136254 : 0)) {
    return 0;
  }
  uint64_t result = CFEqual(v4, v6);
  if (!result) {
    return result;
  }
  if (*(unsigned char *)(a1 + 195) && *(unsigned __int8 *)(a1 + 194) == a3) {
    return 0;
  }
  unint64_t v10 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    v11[0] = 67109120;
    v11[1] = a3;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [CarrierPigeonStartMessage] Acked, token: %hhu", (uint8_t *)v11, 8u);
  }
  *(_WORD *)(a1 + 194) = a3 | 0x100;
  return 1;
}

BOOL sub_1003CB160(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BC8FAC((CFUUIDRef *)a2, __p);
    unint64_t v5 = v35 >= 0 ? __p : *(unsigned char **)__p;
    int v6 = *(unsigned __int8 *)(a2 + 8);
    int v7 = *(unsigned __int16 *)(a2 + 10);
    *(_DWORD *)int buf = 136446722;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&unsigned char buf[12] = 1024;
    int v37 = v6;
    __int16 v38 = 1024;
    int v39 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [CarrierPigeonSummary] Received with LLC ID: %{public}s, token: %hhu, sequenceNumber: %hu", buf, 0x18u);
    if (v35 < 0) {
      operator delete(*(void **)__p);
    }
  }
  if (*(void *)a2) {
    uint64_t v8 = sub_100136254;
  }
  else {
    uint64_t v8 = 0;
  }
  if (!v8
    || ((unint64_t v9 = *(const void **)(a1 + 64)) != 0 ? (v10 = sub_100136254) : (v10 = 0),
        !v10 || !CFEqual(*(CFTypeRef *)a2, v9)))
  {
    long long v21 = *(NSObject **)(a1 + 8);
    BOOL result = os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
    if (result)
    {
      sub_100BC8FAC((CFUUIDRef *)(a1 + 64), buf);
      if (v39 >= 0) {
        __int16 v26 = buf;
      }
      else {
        __int16 v26 = *(unsigned char **)buf;
      }
      *(_DWORD *)std::string __p = 136446210;
      *(void *)&xpc_object_t __p[4] = v26;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "[CarrierPigeonSummary][Ignore] Expected LLC ID: %{public}s", __p, 0xCu);
      if (SHIBYTE(v39) < 0) {
        operator delete(*(void **)buf);
      }
      return 0;
    }
    return result;
  }
  if (!*(unsigned char *)(a1 + 193))
  {
    uint64_t v33 = *(NSObject **)(a1 + 8);
    BOOL result = os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "[CarrierPigeonSummary][Ignore] No last attempted start token yet, but received CarrierPigeonSummary", buf, 2u);
      return 0;
    }
    return result;
  }
  int v11 = *(unsigned __int8 *)(a2 + 8);
  int v12 = *(unsigned __int8 *)(a1 + 192);
  if (v11 != v12)
  {
    uint64_t v22 = *(NSObject **)(a1 + 8);
    BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v23) {
      return result;
    }
    *(_DWORD *)int buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v11;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v12;
    uint64_t v18 = "#I [CarrierPigeonSummary][Ignore] Reason: Summary has stale token: %hhu, latest token: %hhu";
    std::string::size_type v19 = v22;
    goto LABEL_27;
  }
  if (!*(unsigned char *)(a1 + 184))
  {
    long long v24 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      __int16 v25 = "#I [CarrierPigeonSummary][Process] Reason: This is first CarrierPigeonSummary";
LABEL_39:
      unint64_t v27 = v24;
      uint32_t v28 = 2;
LABEL_40:
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v25, buf, v28);
    }
LABEL_41:
    long long v29 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I [CarrierPigeonSummary] Updated last received summary ID", buf, 2u);
    }
    CFTypeRef v30 = (const void **)(a1 + 168);
    if (*(unsigned char *)(a1 + 184))
    {
      sub_100224390(v30, (const void **)a2);
      int v31 = *(_DWORD *)(a2 + 8);
    }
    else
    {
      sub_10012A394(v30, (const void **)a2);
      int v31 = *(_DWORD *)(a2 + 8);
      *(unsigned char *)(a1 + 184) = 1;
    }
    *(_DWORD *)(a1 + 176) = v31;
    return 1;
  }
  if (*(unsigned __int8 *)(a1 + 176) != v11)
  {
    long long v24 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      __int16 v25 = "#I [CarrierPigeonSummary][Process] Reason: Previous CarrierPigeonSummary is not relevant anymore and has old token";
      goto LABEL_39;
    }
    goto LABEL_41;
  }
  unsigned int v13 = *(unsigned __int16 *)(a1 + 178);
  unsigned int v14 = *(unsigned __int16 *)(a2 + 10);
  if (v13 != v14)
  {
    uint64_t v32 = *(NSObject **)(a1 + 8);
    BOOL result = os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
    if (v13 <= v14)
    {
      if (v14 - v13 < 0x1000)
      {
        if (!result) {
          goto LABEL_41;
        }
        *(_DWORD *)int buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v11;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v13;
        __int16 v25 = "#I [CarrierPigeonSummary][Process] Reason: Newer summary (not a wrap-around case). Last summary token: %hh"
              "u, sequenceNumber: %hu";
LABEL_54:
        unint64_t v27 = v32;
        uint32_t v28 = 14;
        goto LABEL_40;
      }
      if (!result) {
        return result;
      }
      *(_DWORD *)int buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v11;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v13;
      uint64_t v18 = "#I [CarrierPigeonSummary][Ignore] Reason: Stale summary (wrap-around case). Last summary token: %hhu, sequenceNumber: %hu";
    }
    else
    {
      if (v13 - v14 > 0xFFF)
      {
        if (!result) {
          goto LABEL_41;
        }
        *(_DWORD *)int buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v11;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v13;
        __int16 v25 = "#I [CarrierPigeonSummary][Process] Reason: Newer summary (wrap-around case). Last summary token: %hhu, seq"
              "uenceNumber: %hu";
        goto LABEL_54;
      }
      if (!result) {
        return result;
      }
      *(_DWORD *)int buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v11;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v13;
      uint64_t v18 = "#I [CarrierPigeonSummary][Ignore] Reason: Stale summary (not a wrap-around case). Last summary token: %hhu, "
            "sequenceNumber: %hu";
    }
    std::string::size_type v19 = v32;
LABEL_27:
    uint32_t v20 = 14;
    goto LABEL_28;
  }
  uint64_t v15 = *(NSObject **)(a1 + 8);
  BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
  BOOL result = 0;
  if (v16)
  {
    *(_WORD *)int buf = 0;
    uint64_t v18 = "#I [CarrierPigeonSummary][Ignore] Reason: Duplicate";
    std::string::size_type v19 = v15;
    uint32_t v20 = 2;
LABEL_28:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, buf, v20);
    return 0;
  }
  return result;
}

void sub_1003CB63C(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 196) != a2)
  {
    uint64_t v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v5 = "no";
      if (a2) {
        unint64_t v5 = "yes";
      }
      int v6 = 136315138;
      int v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [LLCRegistered] %s", (uint8_t *)&v6, 0xCu);
    }
    *(unsigned char *)(a1 + 196) = a2;
  }
}

void sub_1003CB70C(uint64_t a1)
{
  sub_1002B486C(a1);
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BC8FAC((CFUUIDRef *)(a1 + 64), &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = p_p;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ID: %{public}s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    sub_10026CCB8((unsigned __int8 *)(a1 + 160), &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v4 = &__p;
    }
    else {
      uint64_t v4 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)int buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] CarrierPigeonToken: %s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    sub_10026CCB8((unsigned __int8 *)(a1 + 192), &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v5 = &__p;
    }
    else {
      unint64_t v5 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)int buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] LastAttemptedCarrierPigeonStartToken: %s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    sub_10026CCB8((unsigned __int8 *)(a1 + 194), &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v6 = &__p;
    }
    else {
      int v6 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)int buf = 136315138;
    *(void *)&uint8_t buf[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] LastAckedCarrierPigeonStartToken: %s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 196)) {
      int v7 = "true";
    }
    else {
      int v7 = "false";
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] IsLLCRegistered: %s", (uint8_t *)&__p, 0xCu);
  }
  sub_1003CADF0(a1 + 72);
  sub_1003CADF0(a1 + 104);
  uint64_t v8 = *(void **)(a1 + 136);
  if (v8 != (void *)(a1 + 144))
  {
    do
    {
      unint64_t v9 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v10 = v8[4];
        LODWORD(__p.__r_.__value_.__l.__data_) = 134217984;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [d] [InvalidateShortHandleIndicesErrorTimestamp] %llu", (uint8_t *)&__p, 0xCu);
      }
      int v11 = (void *)v8[1];
      if (v11)
      {
        do
        {
          int v12 = v11;
          int v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          int v12 = (void *)v8[2];
          BOOL v13 = *v12 == (void)v8;
          uint64_t v8 = v12;
        }
        while (!v13);
      }
      uint64_t v8 = v12;
    }
    while (v12 != (void *)(a1 + 144));
  }
  if (*(unsigned char *)(a1 + 184))
  {
    unsigned int v14 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      sub_100BC8FAC((CFUUIDRef *)(a1 + 168), buf);
      if (v19 >= 0) {
        uint64_t v15 = buf;
      }
      else {
        uint64_t v15 = *(unsigned char **)buf;
      }
      int v16 = *(unsigned __int8 *)(a1 + 176);
      int v17 = *(unsigned __int16 *)(a1 + 178);
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446722;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v15;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v16;
      WORD1(__p.__r_.__value_.__r.__words[2]) = 1024;
      HIDWORD(__p.__r_.__value_.__r.__words[2]) = v17;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I [d] [LastReceivedCarrierPigeonSummaryId] [LLC ID: %{public}s, token: %hhu, sequence: %hu]", (uint8_t *)&__p, 0x18u);
      if (v19 < 0) {
        operator delete(*(void **)buf);
      }
    }
  }
}

uint64_t sub_1003CBB0C(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 392);
  sub_10030FEEC(&v3);
  uint64_t v3 = (void **)(a1 + 368);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 359) < 0) {
    operator delete(*(void **)(a1 + 336));
  }
  if (*(char *)(a1 + 327) < 0) {
    operator delete(*(void **)(a1 + 304));
  }
  if (*(char *)(a1 + 295) < 0) {
    operator delete(*(void **)(a1 + 272));
  }
  if (*(char *)(a1 + 247) < 0) {
    operator delete(*(void **)(a1 + 224));
  }
  return sub_1000C584C(a1);
}

void sub_1003CBB9C(uint64_t a1, os_log_t *a2, char a3, uint64_t a4)
{
  if (!sub_10004D710()) {
    goto LABEL_12;
  }
  uint64_t v8 = *(void *)(a4 + 32);
  if (*(void *)(a4 + 40) == v8 || !*(unsigned char *)(v8 + 80)) {
    goto LABEL_12;
  }
  BOOL v23 = *(_DWORD *)v8 != 1;
  uint64_t v9 = sub_100365D74();
  sub_100058DB0(__p, "EnablePlanSelection");
  sub_1002260B0(v9, __p, &v23);
  if (SBYTE7(v25) < 0) {
    operator delete(__p[0]);
  }
  std::string::size_type v10 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    if (v23) {
      int v11 = "Enabled";
    }
    else {
      int v11 = "Disabled";
    }
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = (void *)v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Auto Selection %s.", (uint8_t *)__p, 0xCu);
  }
  if (!v23)
  {
    uint64_t v28 = 0;
    memset(v27, 0, sizeof(v27));
    long long v25 = 0u;
    *(_OWORD *)__int16 v26 = 0u;
    *(_OWORD *)std::string __p = 0u;
    DWORD2(v25) = 3;
    uint64_t v12 = *(void *)(a4 + 32);
    uint64_t v13 = *(void *)(a4 + 40);
    if (v13 == v12) {
      sub_10015B728();
    }
    if (!*(unsigned char *)(v12 + 80)) {
      sub_10016C840();
    }
    uint64_t v15 = *(void *)(v12 + 56);
    uint64_t v14 = *(void *)(v12 + 64);
    if (v15 == v14)
    {
      int v19 = 0;
      int v18 = 1;
      DWORD2(v25) = 1;
LABEL_25:
      *(_OWORD *)a1 = *(_OWORD *)__p;
      *(void *)(a1 + 16) = v25;
      __p[0] = 0;
      __p[1] = 0;
      *(_DWORD *)(a1 + 24) = v18;
      *(_OWORD *)(a1 + 32) = *(_OWORD *)v26;
      *(void **)(a1 + 48) = v27[0];
      v26[0] = 0;
      v26[1] = 0;
      v27[0] = 0;
      *(_OWORD *)(a1 + 56) = *(_OWORD *)&v27[1];
      *(void **)(a1 + 72) = v27[3];
      *(void *)&long long v25 = 0;
      memset(&v27[1], 0, 24);
LABEL_26:
      *(_DWORD *)(a1 + 80) = v19;
      *(unsigned char *)(a1 + 88) = 1;
    }
    else
    {
      while (!*(unsigned char *)(v15 + 89))
      {
        v15 += 216;
        if (v15 == v14)
        {
          int v16 = *a2;
          if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v22 = 0;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I No plan active, activate the first one in list", v22, 2u);
            uint64_t v12 = *(void *)(a4 + 32);
            uint64_t v13 = *(void *)(a4 + 40);
          }
          if (v13 == v12) {
            sub_10015B728();
          }
          uint64_t v17 = *(void *)(v12 + 56);
          if (*(void *)(v12 + 64) == v17) {
            sub_10015B728();
          }
          std::string::operator=((std::string *)__p, (const std::string *)(v17 + 16));
          int v18 = DWORD2(v25);
          int v19 = v28;
          goto LABEL_25;
        }
      }
      uint32_t v20 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v22 = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I List already active - leave it", v22, 2u);
      }
      if ((a3 & 1) == 0)
      {
        std::string::operator=((std::string *)__p, (const std::string *)(v15 + 16));
        *(_OWORD *)a1 = *(_OWORD *)__p;
        *(void *)(a1 + 16) = v25;
        __p[0] = 0;
        __p[1] = 0;
        *(_DWORD *)(a1 + 24) = DWORD2(v25);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)v26;
        *(void **)(a1 + 48) = v27[0];
        v26[0] = 0;
        v26[1] = 0;
        v27[0] = 0;
        long long v21 = *(_OWORD *)&v27[1];
        *(void **)(a1 + 72) = v27[3];
        *(_OWORD *)(a1 + 56) = v21;
        *(void *)&long long v25 = 0;
        memset(&v27[1], 0, 24);
        int v19 = v28;
        goto LABEL_26;
      }
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 88) = 0;
      if (SHIBYTE(v27[3]) < 0) {
        operator delete(v27[1]);
      }
    }
    if (SHIBYTE(v27[0]) < 0) {
      operator delete(v26[0]);
    }
    if (SBYTE7(v25) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
LABEL_12:
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 88) = 0;
  }
}

void sub_1003CBF2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

uint64_t sub_1003CBF68(uint64_t a1, NSObject **a2, uint64_t a3, void *a4, void *a5)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v19, kCtLoggingSystemName, "cp.r.list");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::string::size_type v10 = *a2;
  *(void *)(a1 + 24) = *a2;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v17, &v19);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&v17);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v17);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
  *(void *)a1 = off_101A57320;
  int v11 = (capabilities::ct *)(***(void *(****)(long long *__return_ptr))a3)(&v16);
  long long v17 = v16;
  long long v16 = 0uLL;
  v18[0] = off_101999E18;
  v18[1] = sub_1003CC498;
  v18[3] = v18;
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v11) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  sub_10008863C(v18);
  if (*((void *)&v17 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v17 + 1));
  }
  if (*((void *)&v16 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v16 + 1));
  }
  *(void *)a1 = off_1019C5638;
  *(void *)(a1 + 56) = *a5;
  uint64_t v12 = a5[1];
  *(void *)(a1 + 64) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = *(void *)a3;
  uint64_t v13 = *(void *)(a3 + 8);
  *(void *)(a1 + 80) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 88) = *a4;
  uint64_t v14 = a4[1];
  *(void *)(a1 + 96) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 136) = 1065353216;
  *(unsigned char *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  *(unsigned char *)(a1 + 400) = 0;
  *(unsigned char *)(a1 + 408) = 0;
  *(void *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 168) = 0u;
  *(unsigned char *)(a1 + 184) = 0;
  *(unsigned char *)(a1 + 416) = 1;
  *(_DWORD *)(a1 + 512) = 0;
  *(_WORD *)(a1 + 508) = 0;
  *(_OWORD *)(a1 + 476) = 0u;
  *(_OWORD *)(a1 + 492) = 0u;
  *(unsigned char *)(a1 + 608) = 0;
  *(unsigned char *)(a1 + 640) = 0;
  *(unsigned char *)(a1 + 680) = 0;
  *(unsigned char *)(a1 + 576) = 0;
  *(void *)(a1 + 568) = 0;
  *(_OWORD *)(a1 + 552) = 0u;
  *(void *)(a1 + 664) = 0;
  *(_OWORD *)(a1 + 648) = 0u;
  *(unsigned char *)(a1 + 672) = 0;
  *(_DWORD *)(a1 + 752) = 0;
  *(void *)(a1 + 704) = 0;
  *(_OWORD *)(a1 + 688) = 0u;
  *(unsigned char *)(a1 + 712) = 0;
  *(_OWORD *)(a1 + 716) = 0u;
  *(_OWORD *)(a1 + 732) = 0u;
  *(_WORD *)(a1 + 748) = 0;
  *(void *)(a1 + 776) = 0;
  *(_OWORD *)(a1 + 760) = 0u;
  *(unsigned char *)(a1 + 472) = 0;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(unsigned char *)(a1 + 544) = 0;
  *(void *)(a1 + 536) = 0;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_DWORD *)(a1 + 784) = 1;
  *(unsigned char *)(a1 + 792) = 0;
  *(unsigned char *)(a1 + 848) = 0;
  *(unsigned char *)(a1 + 880) = 0;
  *(_OWORD *)(a1 + 984) = 0u;
  *(void *)(a1 + 904) = 0;
  *(_DWORD *)(a1 + 912) = 0;
  *(_OWORD *)(a1 + 888) = 0u;
  *(_OWORD *)(a1 + 920) = 0u;
  *(_OWORD *)(a1 + 936) = 0u;
  *(_OWORD *)(a1 + 952) = 0u;
  *(_DWORD *)(a1 + 968) = 0;
  *(void *)(a1 + 976) = a1 + 984;
  *(void *)(a1 + 1016) = 0;
  *(void *)(a1 + 1008) = 0;
  *(void *)(a1 + 1000) = a1 + 1008;
  *(void *)(a1 + 1040) = 0;
  *(void *)(a1 + 1032) = 0;
  *(void *)(a1 + 1024) = a1 + 1032;
  *(void *)(a1 + 1064) = 0;
  *(void *)(a1 + 1056) = 0;
  *(void *)(a1 + 1048) = a1 + 1056;
  *(void *)(a1 + 1088) = 0;
  *(void *)(a1 + 1080) = 0;
  *(void *)(a1 + 1072) = a1 + 1080;
  *(void *)(a1 + 1112) = 0;
  *(void *)(a1 + 1104) = 0;
  *(void *)(a1 + 1096) = a1 + 1104;
  *(void *)(a1 + 1136) = 0;
  *(void *)(a1 + 1128) = 0;
  *(void *)(a1 + 1120) = a1 + 1128;
  return a1;
}

void sub_1003CC3C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

const char *sub_1003CC498(int a1)
{
  uint64_t v1 = "cp.r.list.?";
  if (a1 == 2) {
    uint64_t v1 = "cp.r.list.2";
  }
  if (a1 == 1) {
    return "cp.r.list.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_1003CC4C4(uint64_t a1)
{
  *(void *)a1 = off_1019C5638;
  sub_1003DDD98(*(char **)(a1 + 1128));
  sub_1003DDCEC(a1 + 1096, *(void **)(a1 + 1104));
  sub_1003DDC94(*(char **)(a1 + 1080));
  sub_1000886C0(a1 + 1048, *(char **)(a1 + 1056));
  sub_100030EE0(a1 + 1024, *(char **)(a1 + 1032));
  sub_1003DDBD8(*(void **)(a1 + 1008));
  sub_1003DDBD8(*(void **)(a1 + 984));
  if (*(char *)(a1 + 967) < 0) {
    operator delete(*(void **)(a1 + 944));
  }
  if (*(char *)(a1 + 943) < 0) {
    operator delete(*(void **)(a1 + 920));
  }
  if (*(char *)(a1 + 911) < 0) {
    operator delete(*(void **)(a1 + 888));
  }
  if (*(unsigned char *)(a1 + 848))
  {
    if (*(char *)(a1 + 879) < 0) {
      operator delete(*(void **)(a1 + 856));
    }
    *(unsigned char *)(a1 + 848) = 0;
  }
  if (*(unsigned char *)(a1 + 792))
  {
    if (*(char *)(a1 + 839) < 0) {
      operator delete(*(void **)(a1 + 816));
    }
    *(unsigned char *)(a1 + 792) = 0;
  }
  std::string::size_type v10 = (void **)(a1 + 760);
  sub_10008A88C(&v10);
  sub_1003DAC14(a1 + 544);
  std::string::size_type v10 = (void **)(a1 + 520);
  sub_1003DACB8(&v10);
  std::string::size_type v10 = (void **)(a1 + 480);
  sub_1000C56F4(&v10);
  if (*(char *)(a1 + 471) < 0) {
    operator delete(*(void **)(a1 + 448));
  }
  if (*(char *)(a1 + 447) < 0) {
    operator delete(*(void **)(a1 + 424));
  }
  if (*(unsigned char *)(a1 + 400)) {
    sub_1000C584C(a1 + 184);
  }
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  uint64_t v2 = *(void **)(a1 + 120);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_1003DDB48((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (v4) {
    operator delete(v4);
  }
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 96);
  if (v5) {
    sub_10004D2C8(v5);
  }
  int v6 = *(std::__shared_weak_count **)(a1 + 80);
  if (v6) {
    sub_10004D2C8(v6);
  }
  int v7 = *(std::__shared_weak_count **)(a1 + 64);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_1003CC6D4(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 32);
  sub_1000C56F4(&v3);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1003CC720(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 248)) {
    sub_1000C584C(a1 + 32);
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1003CC768(uint64_t a1)
{
  sub_1003CC4C4(a1);

  operator delete();
}

void sub_1003CC7A0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(_DWORD *)a3) {
    return;
  }
  uint64_t v3 = a3;
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  int v6 = (void *)(a1 + 1128);
  uint64_t v7 = *(void *)(a1 + 1128);
  int v8 = *(_DWORD *)a2;
  if (v7)
  {
    uint64_t v9 = a1 + 1128;
    do
    {
      int v10 = *(_DWORD *)(v7 + 32);
      BOOL v11 = v10 < v8;
      if (v10 >= v8) {
        uint64_t v12 = (uint64_t *)v7;
      }
      else {
        uint64_t v12 = (uint64_t *)(v7 + 8);
      }
      if (!v11) {
        uint64_t v9 = v7;
      }
      uint64_t v7 = *v12;
    }
    while (*v12);
    if ((void *)v9 != v6 && v8 >= *(_DWORD *)(v9 + 32))
    {
      *(void *)&long long v187 = 0;
      long long v185 = 0u;
      long long __p = 0u;
      memset(v184, 0, sizeof(v184));
      std::string::operator=((std::string *)v184, (const std::string *)(a2 + 72));
      uint64_t v13 = v4;
      LOWORD(__src) = 1543;
      unint64_t v14 = v187;
      uint64_t v15 = (char *)__p;
      if ((void)v187 - (void)__p >= 2uLL)
      {
        uint64_t v19 = *((void *)&__p + 1) - __p;
        if (*((void *)&__p + 1) - (void)__p <= 1uLL)
        {
          if (*((void *)&__p + 1) != (void)__p)
          {
            memcpy((void *)__p, &__src, *((void *)&__p + 1) - __p);
            uint64_t v15 = (char *)*((void *)&__p + 1);
          }
          memcpy(v15, (char *)&__src + v19, 2 - v19);
          *((void *)&__p + 1) = &v15[2 - v19];
          uint64_t v5 = a1;
          uint64_t v4 = v13;
          goto LABEL_28;
        }
        *(_WORD *)long long __p = __src;
        *((void *)&__p + 1) = v15 + 2;
        uint64_t v5 = a1;
      }
      else
      {
        if ((void)__p)
        {
          *((void *)&__p + 1) = __p;
          operator delete((void *)__p);
          unint64_t v14 = 0;
          long long __p = 0uLL;
          *(void *)&long long v187 = 0;
        }
        uint64_t v5 = a1;
        uint64_t v16 = 2 * v14;
        if (2 * v14 <= 2) {
          uint64_t v16 = 2;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v17 = v16;
        }
        sub_10005C9F8(&__p, v17);
        uint64_t v18 = *((void *)&__p + 1);
        **((_WORD **)&__p + 1) = __src;
        *((void *)&__p + 1) = v18 + 2;
      }
      uint64_t v4 = v13;
LABEL_28:
      (*(void (**)(void, unsigned char *, uint64_t))(**(void **)(v5 + 88) + 120))(*(void *)(v5 + 88), v184, 1);
      if ((void)__p)
      {
        *((void *)&__p + 1) = __p;
        operator delete((void *)__p);
      }
      if (SHIBYTE(v185) < 0) {
        operator delete(*(void **)&v184[24]);
      }
      if ((v184[23] & 0x80000000) != 0) {
        operator delete(*(void **)v184);
      }
      int v8 = *(_DWORD *)v4;
    }
  }
  uint64_t v20 = *(void *)(v5 + 1056);
  int v163 = v8;
  if (!v20) {
    goto LABEL_348;
  }
  uint64_t v21 = v5 + 1056;
  do
  {
    int v22 = *(_DWORD *)(v20 + 32);
    BOOL v23 = v22 < v8;
    if (v22 >= v8) {
      long long v24 = (uint64_t *)v20;
    }
    else {
      long long v24 = (uint64_t *)(v20 + 8);
    }
    if (!v23) {
      uint64_t v21 = v20;
    }
    uint64_t v20 = *v24;
  }
  while (*v24);
  if (v21 == v5 + 1056 || *(_DWORD *)(v21 + 32) > v8) {
    goto LABEL_348;
  }
  v155 = v6;
  uint64_t v156 = v4;
  uint64_t v25 = (uint64_t)(v3 + 1);
  uint64_t v175 = 0;
  unint64_t v176 = 0;
  unint64_t v177 = 0;
  v158 = v3;
  uint64_t v26 = v3[9];
  uint64_t v27 = v3[10];
  if (v26 != v27)
  {
    uint64_t v28 = v26 + 80;
    while (1)
    {
      *(void *)&long long v195 = 0;
      long long v193 = 0u;
      long long v194 = 0u;
      long long v191 = 0u;
      long long v192 = 0u;
      long long v189 = 0u;
      long long v190 = 0u;
      long long v187 = 0u;
      long long v188 = 0u;
      long long v185 = 0u;
      long long __p = 0u;
      memset(v184, 0, sizeof(v184));
      sub_100311E70((uint64_t)v213, v25);
      sub_100311E70((uint64_t)v210, (uint64_t)(v158 + 5));
      sub_100CCDA64((ctu *)(v28 - 80), (const std::string *)(v21 + 40), (unint64_t)v213, (uint64_t)v210, (uint64_t)v184);
      if (v210[0])
      {
        if (v212 < 0) {
          operator delete(v211);
        }
        v210[0] = 0;
      }
      if (v213[0])
      {
        if (v215 < 0) {
          operator delete(v214);
        }
        v213[0] = 0;
      }
      if ((_BYTE)v195) {
        break;
      }
      int v31 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        uint64_t v32 = v28;
        if (*(char *)(v28 + 23) < 0) {
          uint64_t v32 = *(void *)v28;
        }
        LODWORD(__src) = 136315138;
        *(void *)((char *)&__src + 4) = v32;
        _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Failed to persist from PairedInfo (%s)", (uint8_t *)&__src, 0xCu);
        goto LABEL_64;
      }
LABEL_79:
      uint64_t v33 = v28 + 64;
      v28 += 144;
      if (v33 == v27) {
        goto LABEL_80;
      }
    }
    sub_1003D688C(v5, v163, v28 - 80, (uint64_t)v184);
    unint64_t v29 = v176;
    if (v176 >= v177)
    {
      uint64_t v30 = sub_1003DBC84(&v175, (uint64_t)v184);
    }
    else
    {
      sub_10023FB90(v176, (uint64_t)v184);
      uint64_t v30 = v29 + 192;
    }
    unint64_t v176 = v30;
LABEL_64:
    if ((_BYTE)v195)
    {
      if (SBYTE7(v194) < 0) {
        operator delete((void *)v193);
      }
      if (SHIBYTE(v192) < 0) {
        operator delete(*((void **)&v191 + 1));
      }
      if (SBYTE7(v191) < 0) {
        operator delete((void *)v190);
      }
      if (SHIBYTE(v189) < 0) {
        operator delete(*((void **)&v188 + 1));
      }
      if (SBYTE7(v188) < 0) {
        operator delete((void *)v187);
      }
      if (SBYTE7(__p) < 0) {
        operator delete((void *)v185);
      }
      if ((v184[31] & 0x80000000) != 0) {
        operator delete(*(void **)&v184[8]);
      }
    }
    goto LABEL_79;
  }
LABEL_80:
  uint64_t v34 = v158[12];
  uint64_t v35 = v158[13];
  if (v34 != v35)
  {
    __int16 v36 = (uint64_t *)(v34 + 40);
    while (1)
    {
      *(void *)&long long v195 = 0;
      long long v193 = 0u;
      long long v194 = 0u;
      long long v191 = 0u;
      long long v192 = 0u;
      long long v189 = 0u;
      long long v190 = 0u;
      long long v187 = 0u;
      long long v188 = 0u;
      long long v185 = 0u;
      long long __p = 0u;
      memset(v184, 0, sizeof(v184));
      if (*(char *)(v21 + 63) < 0) {
        sub_10004FC84(&__dst, *(void **)(v21 + 40), *(void *)(v21 + 48));
      }
      else {
        std::string __dst = *(std::string *)(v21 + 40);
      }
      char v174 = 1;
      sub_100311E70((uint64_t)v207, v25);
      sub_100311E70((uint64_t)v204, (uint64_t)(v158 + 5));
      sub_100CCDD68((ctu *)(v36 - 5), &__dst, (unint64_t)v207, (uint64_t)v204, (uint64_t)v184);
      if (v204[0])
      {
        if (v206 < 0) {
          operator delete(v205);
        }
        v204[0] = 0;
      }
      if (v207[0])
      {
        if (v209 < 0) {
          operator delete(v208);
        }
        v207[0] = 0;
      }
      if (v174 && SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if ((_BYTE)v195) {
        break;
      }
      int v39 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        CFTypeRef v40 = v36;
        if (*((char *)v36 + 23) < 0) {
          CFTypeRef v40 = (uint64_t *)*v36;
        }
        LODWORD(__src) = 136315138;
        *(void *)((char *)&__src + 4) = v40;
        _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Failed to persist from StateInfo: (%s)", (uint8_t *)&__src, 0xCu);
        goto LABEL_105;
      }
LABEL_120:
      xpc_object_t v41 = v36 + 16;
      v36 += 21;
      if (v41 == (uint64_t *)v35) {
        goto LABEL_121;
      }
    }
    sub_1003D688C(v5, v163, (uint64_t)(v36 - 5), (uint64_t)v184);
    unint64_t v37 = v176;
    if (v176 >= v177)
    {
      uint64_t v38 = sub_1003DBC84(&v175, (uint64_t)v184);
    }
    else
    {
      sub_10023FB90(v176, (uint64_t)v184);
      uint64_t v38 = v37 + 192;
    }
    unint64_t v176 = v38;
LABEL_105:
    if ((_BYTE)v195)
    {
      if (SBYTE7(v194) < 0) {
        operator delete((void *)v193);
      }
      if (SHIBYTE(v192) < 0) {
        operator delete(*((void **)&v191 + 1));
      }
      if (SBYTE7(v191) < 0) {
        operator delete((void *)v190);
      }
      if (SHIBYTE(v189) < 0) {
        operator delete(*((void **)&v188 + 1));
      }
      if (SBYTE7(v188) < 0) {
        operator delete((void *)v187);
      }
      if (SBYTE7(__p) < 0) {
        operator delete((void *)v185);
      }
      if ((v184[31] & 0x80000000) != 0) {
        operator delete(*(void **)&v184[8]);
      }
    }
    goto LABEL_120;
  }
LABEL_121:
  (*(void (**)(long long *__return_ptr))(**(void **)(v5 + 72) + 640))(&__src);
  (*(void (**)(unsigned char *__return_ptr))(*(void *)__src + 24))(v184);
  uint64_t v3 = v158;
  char v42 = v184[0];
  if ((v184[31] & 0x80000000) != 0) {
    operator delete(*(void **)&v184[8]);
  }
  if (*((void *)&__src + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&__src + 1));
  }
  if ((v42 & 2) == 0)
  {
    long long __src = 0uLL;
    uint64_t v182 = 0;
    sub_1003D6C50((uint64_t)&__src, v21 + 40, (void *)(v5 + 1096));
    uint64_t v157 = *((void *)&__src + 1);
    uint64_t v43 = __src;
    if ((void)__src == *((void *)&__src + 1)) {
      goto LABEL_198;
    }
    while (1)
    {
      uint64_t v45 = v175;
      unint64_t v44 = v176;
      uint64_t v46 = (std::string *)(v43 + 32);
      if (*(char *)(v43 + 55) < 0)
      {
        sub_10004FC84(v171, *(void **)(v43 + 32), *(void *)(v43 + 40));
      }
      else
      {
        *(_OWORD *)v171 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
        uint64_t v172 = *(void *)(v43 + 48);
      }
      char v47 = HIBYTE(v172);
      if (v45 == v44)
      {
        int v67 = 1;
        goto LABEL_172;
      }
      v160 = (std::string *)(v43 + 32);
      uint64_t v161 = v43;
      char v159 = HIBYTE(v172);
      unint64_t v48 = v172 >= 0 ? (char *)HIBYTE(v172) : (char *)v171[1];
      uint64_t v49 = v172 >= 0 ? v171 : (void **)v171[0];
      uint64_t v50 = &v48[(void)v49];
      while (1)
      {
        uint64_t v51 = (char ***)(v45 + 32);
        unint64_t v52 = *(unsigned __int8 *)(v45 + 55);
        if (*(char *)(v45 + 55) < 0) {
          break;
        }
        int64_t v53 = *(unsigned __int8 *)(v45 + 55);
        if ((unint64_t)v48 >= v52) {
          goto LABEL_151;
        }
        int64_t v53 = *(unsigned __int8 *)(v45 + 55);
        if (!v48) {
          goto LABEL_170;
        }
LABEL_144:
        if (v53 >= (uint64_t)v48)
        {
          xpc_type_t v54 = (char *)v51 + v53;
          int v55 = *(char *)v49;
          BOOL v56 = v51;
          do
          {
            if (v53 - (void)v48 == -1) {
              break;
            }
            int64_t v57 = (char *)memchr(v56, v55, v53 - (void)v48 + 1);
            if (!v57) {
              break;
            }
            xpc_object_t v58 = v57;
            if (!memcmp(v57, v49, (size_t)v48))
            {
              if (v58 == v54) {
                break;
              }
              int64_t v66 = v58 - (char *)v51;
              goto LABEL_166;
            }
            BOOL v56 = (char ***)(v58 + 1);
            int64_t v53 = v54 - (v58 + 1);
          }
          while (v53 >= (uint64_t)v48);
        }
LABEL_167:
        v45 += 192;
        if (v45 == v44)
        {
          int v67 = 1;
          goto LABEL_171;
        }
      }
      int64_t v53 = *(void *)(v45 + 40);
      if ((unint64_t)v48 < v53) {
        break;
      }
LABEL_151:
      if ((v52 & 0x80u) == 0) {
        uint64_t v59 = (char **)(v45 + 32);
      }
      else {
        uint64_t v59 = *v51;
      }
      if (v53)
      {
        if ((uint64_t)v48 >= v53)
        {
          int v60 = *(char *)v59;
          uint64_t v61 = v48;
          std::string v62 = v49;
          while (1)
          {
            CFStringRef v63 = &v61[-v53];
            if (v63 == (char *)-1) {
              break;
            }
            xpc_object_t v64 = (char *)memchr(v62, v60, (size_t)(v63 + 1));
            if (!v64) {
              break;
            }
            xpc_object_t v65 = v64;
            if (!memcmp(v64, v59, v53))
            {
              if (v65 != v50)
              {
                int64_t v66 = v65 - (char *)v49;
LABEL_166:
                if (v66 != -1) {
                  goto LABEL_170;
                }
              }
              goto LABEL_167;
            }
            std::string v62 = (void **)(v65 + 1);
            uint64_t v61 = (char *)(v50 - (v65 + 1));
            if ((uint64_t)v61 < v53) {
              goto LABEL_167;
            }
          }
        }
        goto LABEL_167;
      }
LABEL_170:
      int v67 = 0;
LABEL_171:
      uint64_t v3 = v158;
      char v47 = v159;
      uint64_t v46 = v160;
      uint64_t v43 = v161;
LABEL_172:
      uint64_t v5 = a1;
      if (v47 < 0)
      {
        operator delete(v171[0]);
        if (!v67) {
          goto LABEL_197;
        }
      }
      else if (!v67)
      {
        goto LABEL_197;
      }
      BOOL v68 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(v43 + 55) < 0) {
          uint64_t v46 = (std::string *)v46->__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)v184 = 136315138;
        *(void *)&v184[4] = v46;
        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I Profile (%s) missing from response, no longer present", v184, 0xCu);
      }
      long long v193 = 0u;
      long long v194 = 0u;
      long long v191 = 0u;
      long long v192 = 0u;
      long long v189 = 0u;
      long long v190 = 0u;
      long long v187 = 0u;
      long long v188 = 0u;
      long long v185 = 0u;
      long long __p = 0u;
      memset(v184, 0, sizeof(v184));
      sub_10023FB90((uint64_t)v184, v43);
      BYTE9(v194) = 0;
      unint64_t v69 = v176;
      if (v176 >= v177)
      {
        uint64_t v70 = sub_1003DBC84(&v175, (uint64_t)v184);
      }
      else
      {
        sub_10023FB90(v176, (uint64_t)v184);
        uint64_t v70 = v69 + 192;
      }
      unint64_t v176 = v70;
      if (SBYTE7(v194) < 0) {
        operator delete((void *)v193);
      }
      if (SHIBYTE(v192) < 0) {
        operator delete(*((void **)&v191 + 1));
      }
      if (SBYTE7(v191) < 0) {
        operator delete((void *)v190);
      }
      if (SHIBYTE(v189) < 0) {
        operator delete(*((void **)&v188 + 1));
      }
      if (SBYTE7(v188) < 0) {
        operator delete((void *)v187);
      }
      if (SBYTE7(__p) < 0) {
        operator delete((void *)v185);
      }
      if ((v184[31] & 0x80000000) != 0) {
        operator delete(*(void **)&v184[8]);
      }
LABEL_197:
      v43 += 192;
      if (v43 == v157)
      {
LABEL_198:
        *(void *)v184 = &__src;
        sub_10023FDC8((void ***)v184);
        goto LABEL_199;
      }
    }
    uint64_t v51 = (char ***)*v51;
    if (!v48) {
      goto LABEL_170;
    }
    goto LABEL_144;
  }
LABEL_199:
  __int16 v71 = *(std::__shared_weak_count **)(v5 + 64);
  int v8 = v163;
  if (v71)
  {
    CFTypeRef v72 = std::__shared_weak_count::lock(v71);
    if (v72)
    {
      xpc_object_t v73 = v72;
      uint64_t v74 = *(void *)(v5 + 56);
      if (!v74) {
        goto LABEL_259;
      }
      uint64_t v75 = *v155;
      if (!*v155) {
        goto LABEL_259;
      }
      xpc_object_t v76 = v155;
      do
      {
        int v77 = *(_DWORD *)(v75 + 32);
        BOOL v78 = v77 < v163;
        if (v77 >= v163) {
          xpc_object_t v79 = (uint64_t *)v75;
        }
        else {
          xpc_object_t v79 = (uint64_t *)(v75 + 8);
        }
        if (!v78) {
          xpc_object_t v76 = (void *)v75;
        }
        uint64_t v75 = *v79;
      }
      while (*v79);
      if (v76 == v155 || *((_DWORD *)v76 + 8) > v163) {
        goto LABEL_259;
      }
      uint64_t v81 = v175;
      unint64_t v80 = v176;
      xpc_object_t v82 = (long long *)v76[5];
      if (*((char *)v82 + 23) < 0)
      {
        sub_10004FC84(&__src, *(void **)v82, *((void *)v82 + 1));
      }
      else
      {
        long long v83 = *v82;
        uint64_t v182 = *((void *)v82 + 2);
        long long __src = v83;
      }
      char v84 = HIBYTE(v182);
      if (v81 != v80)
      {
        if (v182 >= 0) {
          uint64_t v85 = HIBYTE(v182);
        }
        else {
          uint64_t v85 = *((void *)&__src + 1);
        }
        if (v182 >= 0) {
          p_src = &__src;
        }
        else {
          p_src = (long long *)__src;
        }
        do
        {
          uint64_t v87 = *(unsigned __int8 *)(v81 + 31);
          if ((v87 & 0x80u) == 0) {
            uint64_t v88 = *(unsigned __int8 *)(v81 + 31);
          }
          else {
            uint64_t v88 = *(void *)(v81 + 16);
          }
          if (v88 == v85)
          {
            if ((v87 & 0x80) != 0)
            {
              if (!memcmp(*(const void **)(v81 + 8), p_src, *(void *)(v81 + 16))) {
                goto LABEL_235;
              }
            }
            else
            {
              if (!*(unsigned char *)(v81 + 31)) {
                goto LABEL_235;
              }
              uint64_t v89 = 0;
              while (*(unsigned __int8 *)(v81 + v89 + 8) == *((unsigned __int8 *)p_src + v89))
              {
                if (v87 == ++v89) {
                  goto LABEL_235;
                }
              }
            }
          }
          v81 += 192;
        }
        while (v81 != v80);
        uint64_t v81 = v80;
      }
LABEL_235:
      if (v84 < 0) {
        operator delete((void *)__src);
      }
      long long v201 = 0uLL;
      sub_100CCD2E8();
      unint64_t v90 = v176;
      uint64_t v5 = a1;
      if (v81 == v176)
      {
        xpc_object_t v92 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
        {
          v93 = (uint64_t **)v76[5];
          if (*((char *)v93 + 23) < 0) {
            v93 = (uint64_t **)*v93;
          }
          *(_DWORD *)v184 = 136315138;
          *(void *)&v184[4] = v93;
          _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "#I Pending subscription (%s) missing from response", v184, 0xCu);
        }
        (*(void (**)(uint64_t, long long *))(*(void *)v74 + 56))(v74, &v201);
        uint64_t v91 = 0;
      }
      else
      {
        if ((*(unsigned char *)(v81 + 56) & 0xFE) != 2)
        {
LABEL_258:
          int v8 = v163;
          uint64_t v3 = v158;
LABEL_259:
          sub_10004D2C8(v73);
          goto LABEL_260;
        }
        uint64_t v91 = *(unsigned __int8 *)(v81 + 57);
      }
      memset(v199, 0, 24);
      v169[0] = 0;
      (*(void (**)(void **__return_ptr))(**(void **)(a1 + 72) + 128))(v169);
      if (v169[0]) {
        v94 = sub_1000810B8;
      }
      else {
        v94 = 0;
      }
      if (v94)
      {
        memset(v184, 0, 24);
        ctu::cf::assign();
        v199[0] = *(_OWORD *)v184;
        *(void *)((char *)v199 + 15) = *(void *)&v184[15];
        BYTE7(v199[1]) = v184[23];
      }
      sub_1000558F4((const void **)v169);
      if (!v91)
      {
        if (RemoteVinylInfo::isMatchingDevice())
        {
          uint64_t v91 = 1;
        }
        else if (cellplan::isPairedRemoteDevice())
        {
          uint64_t v91 = 2;
        }
        else
        {
          uint64_t v91 = 0;
        }
      }
      (*(void (**)(uint64_t, _OWORD *, uint64_t, void, BOOL))(*(void *)v74 + 104))(v74, v199, v91, *(unsigned __int8 *)(v76[5] + 24), v81 != v90);
      if (SBYTE7(v199[1]) < 0) {
        operator delete(*(void **)&v199[0]);
      }
      goto LABEL_258;
    }
  }
LABEL_260:
  int v95 = sub_1003D6DB0(v5);
  sub_1003DE614((uint64_t **)(v5 + 1120), v8);
  (*(void (**)(void, uint64_t *, uint64_t))(**(void **)(v5 + 88) + 112))(*(void *)(v5 + 88), &v175, 1);
  uint64_t v96 = *(std::__shared_weak_count **)(v5 + 64);
  if (v96)
  {
    __n128 v97 = std::__shared_weak_count::lock(v96);
    if (v97)
    {
      long long v98 = v97;
      uint64_t v99 = *(void *)(v5 + 56);
      if (v99) {
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v99 + 72))(v99, &v175);
      }
      sub_10004D2C8(v98);
    }
  }
  sub_1003CFFC0(v5, v175, v176);
  if (v95 && (sub_1003D6DB0(v5) & 1) == 0)
  {
    memset(v203, 0, sizeof(v203));
    long long v201 = 0u;
    long long v202 = 0u;
    sub_1003D2230(&v201, v5);
    uint64_t v162 = v203[1];
    uint64_t v101 = v203[0];
    if (v203[0] == v203[1]) {
      goto LABEL_344;
    }
    while (1)
    {
      ctu::hex((uint64_t *)v169, (ctu *)(v101 + 16), (const void *)0x10, v100);
      uint64_t v103 = v175;
      unint64_t v102 = v176;
      while (1)
      {
        if (v103 == v102)
        {
          char v122 = 0;
          goto LABEL_338;
        }
        uint64_t v104 = *(unsigned __int8 *)(v103 + 31);
        unint64_t v100 = *(void *)(v103 + 16);
        if ((v104 & 0x80u) == 0) {
          v105 = (void *)*(unsigned __int8 *)(v103 + 31);
        }
        else {
          v105 = *(void **)(v103 + 16);
        }
        unint64_t v106 = v170;
        if ((v170 & 0x80u) != 0) {
          unint64_t v106 = (unint64_t)v169[1];
        }
        if (v105 != (void *)v106) {
          goto LABEL_323;
        }
        v107 = (v170 & 0x80u) == 0 ? v169 : (void **)v169[0];
        if ((v104 & 0x80) != 0) {
          break;
        }
        if (!*(unsigned char *)(v103 + 31)) {
          goto LABEL_291;
        }
        uint64_t v108 = 0;
        uint64_t v109 = v104 - 1;
        do
        {
          BOOL v110 = *(unsigned __int8 *)(v103 + v108 + 8) == *((unsigned __int8 *)v107 + v108);
          BOOL v111 = *(unsigned __int8 *)(v103 + v108 + 8) != *((unsigned __int8 *)v107 + v108) || v109 == v108;
          ++v108;
        }
        while (!v111);
        if (v110) {
          goto LABEL_291;
        }
LABEL_323:
        v103 += 192;
      }
      if (memcmp(*(const void **)(v103 + 8), v107, v100)) {
        goto LABEL_323;
      }
LABEL_291:
      if (*(unsigned char *)(v103 + 185)) {
        BOOL v112 = *(unsigned char *)(v103 + 56) == 5;
      }
      else {
        BOOL v112 = 1;
      }
      if (v112) {
        goto LABEL_323;
      }
      if (!*(unsigned char *)(v101 + 80)) {
        goto LABEL_325;
      }
      uint64_t v113 = *(void *)(v101 + 56);
      uint64_t v114 = *(void *)(v101 + 64);
      if (*(char *)(v103 + 55) < 0)
      {
        sub_10004FC84(v167, *(void **)(v103 + 32), *(void *)(v103 + 40));
      }
      else
      {
        *(_OWORD *)v167 = *(_OWORD *)(v103 + 32);
        uint64_t v168 = *(void *)(v103 + 48);
      }
      char v115 = HIBYTE(v168);
      if (v113 == v114)
      {
LABEL_318:
        int v121 = 1;
        if ((v115 & 0x80) == 0) {
          goto LABEL_322;
        }
LABEL_319:
        operator delete(v167[0]);
        uint64_t v5 = a1;
        if ((v121 & 1) == 0) {
          goto LABEL_323;
        }
        goto LABEL_325;
      }
      if (v168 >= 0) {
        v116 = (void *)HIBYTE(v168);
      }
      else {
        v116 = v167[1];
      }
      if (v168 >= 0) {
        v117 = v167;
      }
      else {
        v117 = (void **)v167[0];
      }
      while (2)
      {
        uint64_t v118 = *(unsigned __int8 *)(v113 + 39);
        unint64_t v100 = *(void *)(v113 + 24);
        if ((v118 & 0x80u) == 0) {
          v119 = (void *)*(unsigned __int8 *)(v113 + 39);
        }
        else {
          v119 = *(void **)(v113 + 24);
        }
        if (v119 != v116) {
          goto LABEL_317;
        }
        if ((v118 & 0x80) == 0)
        {
          if (!*(unsigned char *)(v113 + 39)) {
            break;
          }
          uint64_t v120 = 0;
          while (*(unsigned __int8 *)(v113 + v120 + 16) == *((unsigned __int8 *)v117 + v120))
          {
            if (v118 == ++v120) {
              goto LABEL_321;
            }
          }
          goto LABEL_317;
        }
        if (memcmp(*(const void **)(v113 + 16), v117, v100))
        {
LABEL_317:
          v113 += 216;
          if (v113 == v114) {
            goto LABEL_318;
          }
          continue;
        }
        break;
      }
LABEL_321:
      int v121 = 0;
      if (v115 < 0) {
        goto LABEL_319;
      }
LABEL_322:
      uint64_t v5 = a1;
      if (!v121) {
        goto LABEL_323;
      }
LABEL_325:
      v123 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
      {
        v124 = (void *)(v103 + 32);
        if (*(char *)(v103 + 55) < 0) {
          v124 = (void *)*v124;
        }
        *(_DWORD *)v184 = 136315138;
        *(void *)&v184[4] = v124;
        _os_log_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_DEFAULT, "#I Missing profile with ICCID (%s) - assuming activating", v184, 0xCu);
      }
      uint64_t v200 = 0;
      memset(v199, 0, sizeof(v199));
      std::string::operator=((std::string *)&v199[1], (const std::string *)(v103 + 32));
      uint64_t v166 = 0;
      long long v165 = 0uLL;
      sub_1000C5AB4((uint64_t)&__src, (uint64_t)v199);
      char v183 = 1;
      sub_1003DB514((uint64_t)v184, v163, &v165, (uint64_t)&__src, 0);
      sub_1003D0708(v5, 1, (uint64_t)v184);
      if (v198) {
        sub_1000C584C((uint64_t)&v185);
      }
      if ((v184[31] & 0x80000000) != 0) {
        operator delete(*(void **)&v184[8]);
      }
      if (v183) {
        sub_1000C584C((uint64_t)&__src);
      }
      if (SHIBYTE(v166) < 0) {
        operator delete((void *)v165);
      }
      sub_1000C584C((uint64_t)v199);
      char v122 = 1;
LABEL_338:
      if ((char)v170 < 0) {
        operator delete(v169[0]);
      }
      v101 += 88;
      if (v101 == v162) {
        char v125 = 1;
      }
      else {
        char v125 = v122;
      }
      if (v125)
      {
LABEL_344:
        *(void *)v184 = v203;
        sub_1000C56F4((void ***)v184);
        if (SBYTE7(v202) < 0) {
          operator delete((void *)v201);
        }
        int v8 = v163;
        uint64_t v3 = v158;
        break;
      }
    }
  }
  *(void *)v184 = &v175;
  sub_10023FDC8((void ***)v184);
  uint64_t v4 = v156;
LABEL_348:
  uint64_t v126 = *(unsigned __int8 *)(v4 + 95);
  if ((v126 & 0x80u) != 0) {
    uint64_t v126 = *(void *)(v4 + 80);
  }
  if (v8 && v126)
  {
    v127 = sub_1003DDE88((void *)(v5 + 104), (unsigned __int8 *)(v4 + 72));
    if (v127
      && (v129 = *((void *)v127 + 13), uint64_t v128 = *((void *)v127 + 14), v130 = v3[9], v128 - v129 == v3[10] - v130))
    {
      if (v129 == v128)
      {
        int v133 = 0;
      }
      else
      {
        do
        {
          int v131 = cellplan::RemotePlanSubscriptionPairedDeviceInfo::operator==();
          v129 += 144;
          v130 += 144;
          if (v129 == v128) {
            char v132 = 0;
          }
          else {
            char v132 = v131;
          }
        }
        while ((v132 & 1) != 0);
        int v133 = v131 ^ 1;
      }
    }
    else
    {
      int v133 = 1;
    }
    *(void *)v184 = v4 + 72;
    v136 = sub_1003DDF8C(v5 + 104, (unsigned __int8 *)(v4 + 72), (long long **)v184);
    sub_1003DC1E4((uint64_t)(v136 + 40), (uint64_t)(v3 + 1));
    sub_1003DC1E4((uint64_t)(v136 + 72), (uint64_t)(v3 + 5));
    if (v136 + 40 != (unsigned __int8 *)(v3 + 1))
    {
      sub_1003DAD3C((uint64_t)(v136 + 104), v3[9], v3[10], 0x8E38E38E38E38E39 * ((v3[10] - v3[9]) >> 4));
      sub_1003DAFDC((uint64_t)(v136 + 128), v3[12], v3[13], 0xCF3CF3CF3CF3CF3DLL * ((v3[13] - v3[12]) >> 3));
    }
    v137 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v138 = subscriber::asString();
      *(_DWORD *)v184 = 136315394;
      *(void *)&v184[4] = v138;
      *(_WORD *)&v184[12] = 1024;
      *(_DWORD *)&v184[14] = v133;
      _os_log_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_DEFAULT, "#I got subscription of slot %s, secondaryPlanDidUpdate:%d", v184, 0x12u);
    }
    if (v133)
    {
      uint64_t v139 = *(void *)(a1 + 984);
      if (!v139) {
        goto LABEL_402;
      }
      uint64_t v140 = a1 + 984;
      do
      {
        int v141 = *(_DWORD *)(v139 + 32);
        BOOL v142 = v141 < v163;
        if (v141 >= v163) {
          v143 = (uint64_t *)v139;
        }
        else {
          v143 = (uint64_t *)(v139 + 8);
        }
        if (!v142) {
          uint64_t v140 = v139;
        }
        uint64_t v139 = *v143;
      }
      while (*v143);
      if (v140 == a1 + 984 || v163 < *(_DWORD *)(v140 + 32) || *(_DWORD *)(v140 + 64) != 3) {
        goto LABEL_402;
      }
      uint64_t v144 = v3[9];
      uint64_t v145 = v3[10];
      if (v144 != v145)
      {
        uint64_t v146 = *(unsigned __int8 *)(v140 + 63);
        int v147 = (char)v146;
        v148 = (const void **)(v140 + 40);
        uint64_t v149 = *(void *)(v140 + 48);
        if ((v146 & 0x80u) == 0) {
          uint64_t v150 = v146;
        }
        else {
          uint64_t v150 = v149;
        }
        while (1)
        {
          uint64_t v151 = *(unsigned __int8 *)(v144 + 103);
          if ((v151 & 0x80u) == 0) {
            uint64_t v152 = *(unsigned __int8 *)(v144 + 103);
          }
          else {
            uint64_t v152 = *(void *)(v144 + 88);
          }
          if (v152 == v150)
          {
            if (v147 >= 0) {
              v153 = (unsigned __int8 *)v148;
            }
            else {
              v153 = (unsigned __int8 *)*v148;
            }
            if ((v151 & 0x80) != 0)
            {
              if (!memcmp(*(const void **)(v144 + 80), v153, *(void *)(v144 + 88)))
              {
LABEL_397:
                if (*(unsigned char *)(v144 + 104) == 2) {
                  break;
                }
              }
            }
            else
            {
              if (!*(unsigned char *)(v144 + 103)) {
                goto LABEL_397;
              }
              uint64_t v154 = 0;
              while (*(unsigned __int8 *)(v144 + v154 + 80) == v153[v154])
              {
                if (v151 == ++v154) {
                  goto LABEL_397;
                }
              }
            }
          }
          v144 += 144;
          if (v144 == v145) {
            goto LABEL_402;
          }
        }
      }
      if (v144 == v145)
      {
LABEL_402:
        if (sub_1003CE02C(a1, v163))
        {
          v178[0] = 0;
          sub_1003CF080(a1, v178);
          if (v178[0])
          {
            if (v180 < 0) {
              operator delete(v179);
            }
            v178[0] = 0;
          }
        }
      }
    }
    long long v196 = 0u;
    long long v197 = 0u;
    long long v194 = 0u;
    long long v195 = 0u;
    long long v192 = 0u;
    long long v193 = 0u;
    long long v190 = 0u;
    long long v191 = 0u;
    long long v188 = 0u;
    long long v189 = 0u;
    long long __p = 0u;
    long long v187 = 0u;
    long long v185 = 0u;
    memset(v184, 0, sizeof(v184));
    sub_1003CFC78(a1, v163, (uint64_t)v184);
    if (BYTE8(v197))
    {
      (*(void (**)(void, unsigned char *))(**(void **)(a1 + 88) + 56))(*(void *)(a1 + 88), v184);
      if (BYTE8(v197)) {
        sub_10023F898((uint64_t)v184);
      }
    }
  }
  else
  {
    v134 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v134, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v135 = subscriber::asString();
      *(_DWORD *)v184 = 136315138;
      *(void *)&v184[4] = v135;
      _os_log_impl((void *)&_mh_execute_header, v134, OS_LOG_TYPE_DEFAULT, "#E Cannot find iccid for %s, don't update subscriptions", v184, 0xCu);
    }
  }
}

void sub_1003CDD50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  sub_10004D2C8(v42);
  STACK[0x330] = (unint64_t)&a42;
  sub_10023FDC8((void ***)&STACK[0x330]);
  _Unwind_Resume(a1);
}

void sub_1003CDFD0()
{
}

uint64_t sub_1003CDFD8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1003CE02C(uint64_t a1, uint64_t a2)
{
  int v91 = a2;
  uint64_t v88 = 0;
  uint64_t v89 = 0;
  uint64_t v90 = 0;
  sub_100311ED8(&v88, *(void *)(a1 + 480), *(void *)(a1 + 488), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a1 + 488) - *(void *)(a1 + 480)) >> 3));
  long long v115 = 0u;
  long long v116 = 0u;
  long long v113 = 0u;
  long long v114 = 0u;
  long long v111 = 0u;
  long long v112 = 0u;
  long long v109 = 0u;
  long long v110 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v106 = 0u;
  sub_100CCD910(a2, (_DWORD **)(a1 + 760), (char *)&v106);
  uint64_t v4 = *(void *)(a1 + 480);
  if (*(void *)(a1 + 488) == v4 || *(_DWORD *)(v4 + 12) != 3)
  {
    int v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I CSN missing", buf, 2u);
    }
    BOOL v11 = (void **)(a1 + 888);
    if (*(char *)(a1 + 911) < 0) {
      operator delete(*v11);
    }
    uint64_t v12 = (void **)(a1 + 920);
    *BOOL v11 = 0;
    *(void *)(a1 + 896) = 0;
    *(_DWORD *)(a1 + 912) = 0;
    *(void *)(a1 + 904) = 0;
    if (*(char *)(a1 + 943) < 0) {
      operator delete(*v12);
    }
    uint64_t v13 = a1 + 944;
    uint64_t *v12 = 0;
    *(void *)(a1 + 928) = 0;
    *(void *)(a1 + 936) = 0;
    if (*(char *)(a1 + 967) < 0) {
      operator delete(*(void **)v13);
    }
    uint64_t v9 = 0;
    *(void *)uint64_t v13 = 0;
    *(void *)(v13 + 8) = 0;
    *(_DWORD *)(v13 + 24) = 0;
    *(void *)(v13 + 16) = 0;
    goto LABEL_23;
  }
  if (!(_BYTE)v106) {
    goto LABEL_22;
  }
  if (v107 == 8)
  {
    memset(buf, 0, 28);
    long long v97 = 0u;
    memset(v98, 0, sizeof(v98));
    LODWORD(v99) = 0;
    uint64_t v5 = sub_1003DE85C((uint64_t **)(a1 + 976), a2, &v91);
    int v6 = (void **)(v5 + 5);
    if (*((char *)v5 + 63) < 0) {
      operator delete(*v6);
    }
    *(_OWORD *)int v6 = *(_OWORD *)buf;
    v5[7] = *(uint64_t **)&buf[16];
    *((_DWORD *)v5 + 16) = 0;
    uint64_t v7 = (void **)(v5 + 9);
    if (*((char *)v5 + 95) < 0) {
      operator delete(*v7);
    }
    *(_OWORD *)uint64_t v7 = v97;
    v5[11] = *(uint64_t **)&v98[0];
    int v8 = (void **)(v5 + 12);
    if (*((char *)v5 + 119) < 0) {
      operator delete(*v8);
    }
    uint64_t v9 = 0;
    *(_OWORD *)int v8 = *(_OWORD *)((char *)v98 + 8);
    v5[14] = (uint64_t *)*((void *)&v98[1] + 1);
    *((_DWORD *)v5 + 30) = 0;
    goto LABEL_23;
  }
  if (subscriber::isSimAbsent())
  {
LABEL_22:
    uint64_t v9 = 0;
    goto LABEL_23;
  }
  if (!(_BYTE)v106) {
    __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
  }
  if ((subscriber::isSimReady() & 1) == 0)
  {
    uint64_t v16 = *(NSObject **)(a1 + 40);
    uint64_t v9 = 0;
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_23;
    }
    uint64_t v17 = subscriber::asString();
    *(_DWORD *)int buf = 136315138;
    *(void *)&uint8_t buf[4] = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I SIM %s not settled", buf, 0xCu);
    goto LABEL_22;
  }
  if (*(unsigned char *)(a1 + 792))
  {
    sub_1002EF958((uint64_t)buf);
    if (sub_1003D5918(a1 + 800, (uint64_t)buf))
    {
      int v15 = 1;
    }
    else
    {
      if (!*(unsigned char *)(a1 + 792)) {
        __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
      }
      if (*(char *)(a1 + 911) < 0)
      {
        sub_10004FC84(&__p, *(void **)(a1 + 888), *(void *)(a1 + 896));
      }
      else
      {
        long long __p = *(_OWORD *)(a1 + 888);
        uint64_t v94 = *(void *)(a1 + 904);
      }
      char v95 = 1;
      int v15 = sub_1003D5918(a1 + 800, (uint64_t)v92);
      if (SHIBYTE(v94) < 0) {
        operator delete((void *)__p);
      }
    }
    if (SBYTE7(v97) < 0) {
      operator delete(*(void **)&buf[16]);
    }
    if (v15)
    {
      uint64_t v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Deleting profile", buf, 2u);
      }
      *((_DWORD *)sub_1003DE85C((uint64_t **)(a1 + 976), a2, &v91) + 16) = 1;
      goto LABEL_122;
    }
  }
  if (v89 == v88 || !*(unsigned char *)(v88 + 80))
  {
    uint64_t v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I No profiles on remote device", buf, 2u);
    }
    memset(buf, 0, 28);
    long long v97 = 0u;
    memset(v98, 0, sizeof(v98));
    LODWORD(v99) = 0;
    uint64_t v21 = sub_1003DE85C((uint64_t **)(a1 + 976), a2, &v91);
    sub_1003D7A34((uint64_t)(v21 + 5), (long long *)buf);
    sub_1003785AC((uint64_t)buf);
    goto LABEL_22;
  }
  uint64_t v19 = sub_1003DE85C((uint64_t **)(a1 + 976), a2, &v91);
  if (*((char *)v19 + 63) < 0)
  {
    *(unsigned char *)void v19[5] = 0;
    void v19[6] = 0;
  }
  else
  {
    *((unsigned char *)v19 + 40) = 0;
    *((unsigned char *)v19 + 63) = 0;
  }
  uint64_t v75 = (uint64_t **)(a1 + 976);
  *((_DWORD *)sub_1003DE85C((uint64_t **)(a1 + 976), a2, &v91) + 16) = 1;
  uint64_t v23 = *(void *)(v88 + 56);
  uint64_t v22 = *(void *)(v88 + 64);
  if (v23 == v22) {
    goto LABEL_122;
  }
  uint64_t v24 = a1 + 1096;
  uint64_t v25 = (void **)(a1 + 1104);
  uint64_t v77 = *(void *)(v88 + 64);
  while (1)
  {
    uint64_t v26 = sub_100046F68(v24, (void **)(v23 + 16));
    uint64_t v27 = v26;
    if (v25 == v26) {
      break;
    }
    if (*((unsigned char *)v26 + 113) != 2 && !(*((char *)v26 + 143) < 0 ? v26[16] : (void *)*((unsigned __int8 *)v26 + 143))) {
      break;
    }
    if (!(_BYTE)v106) {
      __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
    }
    uint64_t v29 = *((unsigned __int8 *)v26 + 143);
    if ((v29 & 0x80u) == 0) {
      uint64_t v30 = (void *)*((unsigned __int8 *)v26 + 143);
    }
    else {
      uint64_t v30 = v26[16];
    }
    int v31 = (void *)BYTE7(v112);
    if (SBYTE7(v112) < 0) {
      int v31 = (void *)*((void *)&v111 + 1);
    }
    if (v30 != v31) {
      goto LABEL_121;
    }
    uint64_t v32 = (const void **)(v26 + 15);
    if ((SBYTE7(v112) & 0x80u) == 0) {
      uint64_t v33 = (unsigned __int8 *)&v111;
    }
    else {
      uint64_t v33 = (unsigned __int8 *)v111;
    }
    if ((v29 & 0x80) != 0)
    {
      if (memcmp(*v32, v33, (size_t)v26[16])) {
        goto LABEL_121;
      }
    }
    else if (*((unsigned char *)v26 + 143))
    {
      while (*(unsigned __int8 *)v32 == *v33)
      {
        uint64_t v32 = (const void **)((char *)v32 + 1);
        ++v33;
        if (!--v29) {
          goto LABEL_86;
        }
      }
      goto LABEL_121;
    }
LABEL_86:
    if (sub_1003D31E8(a1, (uint64_t)(v27 + 7), 0))
    {
      unsigned int v71 = *((unsigned __int8 *)v27 + 112) - 1;
      if (v71 > 6) {
        int v72 = 0;
      }
      else {
        int v72 = dword_10149857C[(char)v71];
      }
      int v73 = v91;
      *((_DWORD *)sub_1003DE85C(v75, v91, &v91) + 16) = v72;
      uint64_t v74 = sub_1003DE85C(v75, v73, &v91);
      std::string::operator=((std::string *)(v74 + 5), (const std::string *)(v23 + 16));
      goto LABEL_122;
    }
LABEL_121:
    v23 += 216;
    if (v23 == v22) {
      goto LABEL_122;
    }
  }
  uint64_t v34 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I No subscription details", buf, 2u);
  }
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 72) + 640))(v92);
  int v35 = v91;
  (*(void (**)(uint8_t *__return_ptr))(*(void *)v92[0] + 24))(buf);
  uint8_t v36 = buf[0];
  if ((char)buf[31] < 0) {
    operator delete(*(void **)&buf[8]);
  }
  if (v92[1]) {
    sub_10004D2C8((std::__shared_weak_count *)v92[1]);
  }
  if ((v36 & 2) == 0) {
    goto LABEL_121;
  }
  uint64_t v85 = 0;
  xpc_object_t v86 = 0;
  uint64_t v87 = 0;
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 72) + 640))(buf);
  (*(void (**)(std::__shared_weak_count **__return_ptr))(**(void **)buf + 32))(&v85);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  unint64_t v37 = v85;
  uint64_t v38 = v86;
  if (*(char *)(v23 + 39) < 0)
  {
    sub_10004FC84(__dst, *(void **)(v23 + 16), *(void *)(v23 + 24));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)(v23 + 16);
    uint64_t v84 = *(void *)(v23 + 32);
  }
  xpc_object_t v76 = (std::string *)(v23 + 16);
  char v39 = HIBYTE(v84);
  if (v37 == v38)
  {
    char v48 = 0;
  }
  else
  {
    if (v84 >= 0) {
      CFTypeRef v40 = __dst;
    }
    else {
      CFTypeRef v40 = (void **)__dst[0];
    }
    if (v84 >= 0) {
      xpc_object_t v41 = (void *)HIBYTE(v84);
    }
    else {
      xpc_object_t v41 = __dst[1];
    }
    do
    {
      int shared_weak_owners_high = SHIBYTE(v37->__shared_weak_owners_);
      if (shared_weak_owners_high >= 0) {
        size_t shared_owners = HIBYTE(v37->__shared_weak_owners_);
      }
      else {
        size_t shared_owners = v37->__shared_owners_;
      }
      if (shared_owners == -1) {
        sub_1000C14D8();
      }
      unint64_t v44 = v37 + 1;
      if ((unint64_t)v41 >= shared_owners) {
        size_t v45 = shared_owners;
      }
      else {
        size_t v45 = (size_t)v41;
      }
      if (shared_weak_owners_high >= 0) {
        uint64_t v46 = v37;
      }
      else {
        uint64_t v46 = v37->__vftable;
      }
      BOOL v47 = memcmp(v40, v46, v45) || shared_owners > (unint64_t)v41;
      char v48 = !v47;
      if (!v47) {
        break;
      }
      ++v37;
    }
    while (v44 != v38);
  }
  if (v39 < 0) {
    operator delete(__dst[0]);
  }
  if ((v48 & 1) == 0)
  {
    *(void *)int buf = &v85;
    sub_100047F64((void ***)buf);
    uint64_t v22 = v77;
    uint64_t v24 = a1 + 1096;
    uint64_t v25 = (void **)(a1 + 1104);
    goto LABEL_121;
  }
  uint64_t v61 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v62 = v23 + 16;
    if (*(char *)(v23 + 39) < 0) {
      std::string::size_type v62 = v76->__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)int buf = 136315138;
    *(void *)&uint8_t buf[4] = v62;
    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I Matching ICCID prefix for (%s)", buf, 0xCu);
  }
  *((_DWORD *)sub_1003DE85C(v75, v35, &v91) + 16) = 3;
  CFStringRef v63 = sub_1003DE85C(v75, v35, &v91);
  std::string::operator=((std::string *)(v63 + 5), v76);
  long long v104 = 0u;
  long long v105 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v99 = 0u;
  long long v97 = 0u;
  memset(v98, 0, sizeof(v98));
  memset(buf, 0, sizeof(buf));
  BYTE9(v105) = 1;
  *(void *)int buf = CFAbsoluteTimeGetCurrent();
  std::string::operator=((std::string *)&v97, v76);
  if (!(_BYTE)v106) {
    __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
  }
  std::string::operator=((std::string *)&v98[1], (const std::string *)&v111);
  WORD4(v98[0]) = 258;
  ctu::hex((uint64_t *)v92, (ctu *)(v88 + 16), (const void *)0x10, v64);
  if ((char)buf[31] < 0) {
    operator delete(*(void **)&buf[8]);
  }
  *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)v92;
  *(void *)&unsigned char buf[24] = __p;
  uint64_t v81 = (Registry *)(v23 + 16);
  xpc_object_t v65 = sub_1003DF1C0((uint64_t **)(a1 + 1096), (void **)&v76->__r_.__value_.__l.__data_, (uint64_t)&unk_10144E20E, (long long **)&v81);
  sub_1003D7AF8((uint64_t)(v65 + 7), (uint64_t)buf);
  uint64_t v66 = *(void *)(a1 + 88);
  sub_10023FB90((uint64_t)v92, (uint64_t)buf);
  sub_1003D7B84(&v81, (uint64_t)v92, 1uLL);
  (*(void (**)(uint64_t, Registry **, uint64_t))(*(void *)v66 + 112))(v66, &v81, 1);
  *(void *)&long long v79 = &v81;
  sub_10023FDC8((void ***)&v79);
  sub_1000C62D8((uint64_t)v92);
  int v67 = *(std::__shared_weak_count **)(a1 + 64);
  if (v67)
  {
    BOOL v68 = std::__shared_weak_count::lock(v67);
    if (v68)
    {
      unint64_t v69 = v68;
      uint64_t v70 = *(void *)(a1 + 56);
      if (v70)
      {
        sub_10023FB90((uint64_t)v92, (uint64_t)buf);
        sub_1003D7B84(&v81, (uint64_t)v92, 1uLL);
        (*(void (**)(uint64_t, Registry **))(*(void *)v70 + 72))(v70, &v81);
        *(void *)&long long v79 = &v81;
        sub_10023FDC8((void ***)&v79);
        sub_1000C62D8((uint64_t)v92);
      }
      sub_10004D2C8(v69);
    }
  }
  sub_1000C62D8((uint64_t)buf);
  *(void *)int buf = &v85;
  sub_100047F64((void ***)buf);
LABEL_122:
  uint64_t v49 = (uint64_t **)(a1 + 976);
  int v50 = v91;
  if (*((_DWORD *)sub_1003DE85C((uint64_t **)(a1 + 976), v91, &v91) + 16) == 1)
  {
    uint64_t v51 = sub_1003DE85C((uint64_t **)(a1 + 976), v50, &v91);
    if (*((char *)v51 + 63) < 0)
    {
      *(unsigned char *)v51[5] = 0;
      v51[6] = 0;
    }
    else
    {
      *((unsigned char *)v51 + 40) = 0;
      *((unsigned char *)v51 + 63) = 0;
    }
    if (sub_10004D710())
    {
      long long v99 = 0u;
      long long v97 = 0u;
      memset(v98, 0, sizeof(v98));
      memset(buf, 0, sizeof(buf));
      sub_1003D236C(v80, (long long *)(a1 + 448));
      sub_1003CBB9C((uint64_t)buf, (os_log_t *)(a1 + 40), 0, (uint64_t)v80);
      sub_1003CC6D4((uint64_t)v80);
      if (BYTE8(v99))
      {
        int v60 = sub_1003DE85C((uint64_t **)(a1 + 976), v50, &v91);
        sub_1003D312C((uint64_t)(v60 + 5), (uint64_t)buf);
      }
      sub_1003DB934((uint64_t)buf);
    }
    uint64_t v9 = 1;
  }
  else
  {
    subscriber::generateUuidStrFromSlotId();
    memset(buf, 0, 24);
    ctu::cf::assign();
    unint64_t v52 = *(uint64_t **)buf;
    v92[0] = *(void **)&buf[8];
    *(void **)((char *)v92 + 7) = *(void **)&buf[15];
    uint8_t v53 = buf[23];
    xpc_type_t v54 = sub_1003DE85C((uint64_t **)(a1 + 976), v50, &v91);
    int v55 = v54;
    if (*((char *)v54 + 95) < 0) {
      operator delete(v54[9]);
    }
    BOOL v56 = (uint64_t *)v92[0];
    v55[9] = v52;
    v55[10] = v56;
    *(uint64_t **)((char *)v55 + 87) = *(uint64_t **)((char *)v92 + 7);
    *((unsigned char *)v55 + 95) = v53;
    sub_1000558F4((const void **)&v85);
    (***(void (****)(Registry **__return_ptr))(a1 + 72))(&v81);
    sub_1003D59E4(v81, &v85);
    int64_t v57 = v85;
    (***(void (****)(long long *__return_ptr))(a1 + 72))(&v78);
    long long v79 = v78;
    long long v78 = 0uLL;
    PersonalityIdFromSlotId();
    ((void (*)(uint8_t *__return_ptr, std::__shared_weak_count *, void **))v57->__vftable[4].~__shared_weak_count_0)(buf, v57, v92);
    xpc_object_t v58 = sub_1003DE85C((uint64_t **)(a1 + 976), v50, &v91);
    uint64_t v59 = v58 + 12;
    if (*((char *)v58 + 119) < 0) {
      operator delete(*v59);
    }
    *(_OWORD *)uint64_t v59 = v98[0];
    v59[2] = *(uint64_t **)&v98[1];
    BYTE7(v98[1]) = 0;
    LOBYTE(v98[0]) = 0;
    sub_1001A7138((uint64_t)buf);
    if (SBYTE7(__p) < 0) {
      operator delete(v92[0]);
    }
    if (*((void *)&v79 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v79 + 1));
    }
    if (*((void *)&v78 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v78 + 1));
    }
    if (v86) {
      sub_10004D2C8(v86);
    }
    if (v82) {
      sub_10004D2C8(v82);
    }
    uint64_t v9 = 1;
    *((_DWORD *)sub_1003DE85C(v49, v50, &v91) + 30) = 1;
  }
LABEL_23:
  sub_1003DD210(&v106);
  *(void *)int buf = &v88;
  sub_1000C56F4((void ***)buf);
  return v9;
}

void sub_1003CEE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_10023FDC8((void ***)&a21);
  sub_1000C62D8((uint64_t)&a45);
  sub_10004D2C8(v69);
  sub_1000C62D8((uint64_t)&a69);
  a69 = (uint64_t)&a38;
  sub_100047F64((void ***)&a69);
  sub_1003DD210(&STACK[0x2A0]);
  a45 = &a41;
  sub_1000C56F4((void ***)&a45);
  _Unwind_Resume(a1);
}

void sub_1003CF080(uint64_t a1, unsigned char *a2)
{
  uint64_t v82 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v81 = 0u;
  *(_OWORD *)long long v79 = 0u;
  memset(__str, 0, sizeof(__str));
  *(_DWORD *)&__str[24] = 1;
  if (*a2) {
    sub_1003DC1E4(a1 + 848, (uint64_t)a2);
  }
  uint64_t v77 = (uint64_t **)(a1 + 976);
  uint64_t v3 = *(uint64_t **)(a1 + 976);
  uint64_t v4 = (uint64_t *)(a1 + 984);
  if (v3 != (uint64_t *)(a1 + 984))
  {
    do
    {
      uint64_t v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = subscriber::asString();
        uint64_t v7 = v3 + 5;
        if (*((char *)v3 + 63) < 0) {
          uint64_t v7 = (void *)*v7;
        }
        int v8 = *((_DWORD *)v3 + 16);
        *(_DWORD *)int buf = 136315650;
        *(void *)&uint8_t buf[4] = v6;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&unsigned char buf[14] = v7;
        *(_WORD *)&unsigned char buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = v8;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Selectable: slot %s, iccid:%s, status:%d", buf, 0x1Cu);
      }
      if (*(unsigned char *)(a1 + 848))
      {
        uint64_t v9 = *(unsigned __int8 *)(a1 + 879);
        if ((v9 & 0x80u) == 0) {
          uint64_t v10 = *(unsigned __int8 *)(a1 + 879);
        }
        else {
          uint64_t v10 = *(void *)(a1 + 864);
        }
        int v11 = *((char *)v3 + 63);
        uint64_t v12 = *((unsigned __int8 *)v3 + 63);
        uint64_t v13 = v3[6];
        if (v11 >= 0) {
          uint64_t v13 = *((unsigned __int8 *)v3 + 63);
        }
        if (v10 == v13)
        {
          if (v11 >= 0) {
            unint64_t v14 = (unsigned __int8 *)(v3 + 5);
          }
          else {
            unint64_t v14 = (unsigned __int8 *)v3[5];
          }
          if ((v9 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)(a1 + 856), v14, *(void *)(a1 + 864)))
            {
LABEL_45:
              std::string::operator=((std::string *)__str, (const std::string *)(v3 + 5));
              *(_DWORD *)&__str[24] = *((_DWORD *)v3 + 16);
              std::string::operator=((std::string *)v79, (const std::string *)v3 + 3);
              std::string::operator=((std::string *)&__p[1], (const std::string *)v3 + 4);
              LODWORD(v82) = *((_DWORD *)v3 + 30);
              break;
            }
          }
          else
          {
            if (!*(unsigned char *)(a1 + 879)) {
              goto LABEL_45;
            }
            int v15 = (unsigned __int8 *)(a1 + 856);
            while (*v15 == *v14)
            {
              ++v15;
              ++v14;
              if (!--v9) {
                goto LABEL_45;
              }
            }
          }
        }
      }
      else
      {
        uint64_t v12 = *((unsigned __int8 *)v3 + 63);
      }
      if ((v12 & 0x80) != 0)
      {
        if (v3[6])
        {
LABEL_30:
          uint64_t v16 = __str[23];
          if (__str[23] < 0) {
            uint64_t v16 = *(void *)&__str[8];
          }
          if (!v16 || *(_DWORD *)&__str[24] == 4 && (v3[8] & 0xFFFFFFFE) == 2)
          {
            std::string::operator=((std::string *)__str, (const std::string *)(v3 + 5));
            *(_DWORD *)&__str[24] = *((_DWORD *)v3 + 16);
            std::string::operator=((std::string *)v79, (const std::string *)v3 + 3);
            std::string::operator=((std::string *)&__p[1], (const std::string *)v3 + 4);
            uint64_t v17 = (uint64_t **)v3;
          }
          else
          {
            uint64_t v17 = sub_1003DE85C(v77, *(_DWORD *)(a1 + 784), (_DWORD *)(a1 + 784));
            std::string::operator=((std::string *)__str, (const std::string *)(v17 + 5));
            *(_DWORD *)&__str[24] = *((_DWORD *)v17 + 16);
            std::string::operator=((std::string *)v79, (const std::string *)v17 + 3);
            std::string::operator=((std::string *)&__p[1], (const std::string *)v17 + 4);
          }
          LODWORD(v82) = *((_DWORD *)v17 + 30);
        }
      }
      else if (v12)
      {
        goto LABEL_30;
      }
      uint64_t v18 = (uint64_t *)v3[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          uint64_t v18 = (uint64_t *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (uint64_t *)v3[2];
          BOOL v20 = *v19 == (void)v3;
          uint64_t v3 = v19;
        }
        while (!v20);
      }
      uint64_t v3 = v19;
    }
    while (v19 != v4);
  }
  uint64_t v21 = (const void **)(a1 + 888);
  if (cellplan::operator!=())
  {
    uint64_t v22 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = (const void *)(a1 + 888);
      if (*(char *)(a1 + 911) < 0) {
        uint64_t v23 = *v21;
      }
      int v24 = __str[23];
      uint64_t v25 = *(unsigned char **)__str;
      uint64_t v26 = cellplan::asString();
      uint64_t v27 = __str;
      *(_DWORD *)int buf = 136315650;
      if (v24 < 0) {
        uint64_t v27 = v25;
      }
      *(void *)&uint8_t buf[4] = v23;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&unsigned char buf[14] = v27;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = v26;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I New active plan set from (%s) to (%s) - %s", buf, 0x20u);
    }
    std::string::operator=((std::string *)(a1 + 888), (const std::string *)__str);
    *(_DWORD *)(a1 + 912) = *(_DWORD *)&__str[24];
    std::string::operator=((std::string *)(a1 + 920), (const std::string *)v79);
    std::string::operator=((std::string *)(a1 + 944), (const std::string *)&__p[1]);
    *(_DWORD *)(a1 + 968) = v82;
    *(unsigned char *)(a1 + 416) = 1;
  }
  uint64_t v28 = (uint64_t **)(a1 + 1000);
  if (*(void *)(a1 + 992) != *(void *)(a1 + 1016)) {
    goto LABEL_71;
  }
  uint64_t v29 = *v77;
  if (*v77 != v4)
  {
    uint64_t v30 = *v28;
    while (*((_DWORD *)v29 + 8) == *((_DWORD *)v30 + 8) && cellplan::operator==())
    {
      int v31 = (uint64_t *)v29[1];
      uint64_t v32 = v29;
      if (v31)
      {
        do
        {
          uint64_t v29 = v31;
          int v31 = (uint64_t *)*v31;
        }
        while (v31);
      }
      else
      {
        do
        {
          uint64_t v29 = (uint64_t *)v32[2];
          BOOL v20 = *v29 == (void)v32;
          uint64_t v32 = v29;
        }
        while (!v20);
      }
      uint64_t v33 = (uint64_t *)v30[1];
      if (v33)
      {
        do
        {
          uint64_t v34 = v33;
          uint64_t v33 = (uint64_t *)*v33;
        }
        while (v33);
      }
      else
      {
        do
        {
          uint64_t v34 = (uint64_t *)v30[2];
          BOOL v20 = *v34 == (void)v30;
          uint64_t v30 = v34;
        }
        while (!v20);
      }
      uint64_t v30 = v34;
      if (v29 == v4) {
        goto LABEL_74;
      }
    }
LABEL_71:
    int v35 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I fSelectableRemotePlanInfo changed", buf, 2u);
    }
    *(unsigned char *)(a1 + 416) = 1;
  }
LABEL_74:
  uint64_t v36 = *(void *)(a1 + 760);
  uint64_t v37 = *(void *)(a1 + 768);
  while (v36 != v37)
  {
    if ((subscriber::isSimSettled() & 1) == 0) {
      goto LABEL_87;
    }
    v36 += 168;
  }
  if (!*(unsigned char *)(a1 + 472)
    || (uint64_t v38 = *(void *)(a1 + 480), v38 == *(void *)(a1 + 488))
    || *(_DWORD *)(a1 + 504) != 1)
  {
LABEL_87:
    *(unsigned char *)(a1 + 416) = 1;
    goto LABEL_88;
  }
  if (!*(unsigned char *)(a1 + 416)) {
    goto LABEL_88;
  }
  memset(&v86, 0, sizeof(v86));
  memset(buf, 0, 32);
  sub_1000C5E38((uint64_t)buf, v38 + 56);
  if (buf[24])
  {
    uint64_t v39 = *(void *)buf;
    if (*(void *)buf != *(void *)&buf[8])
    {
      while (!*(unsigned char *)(v39 + 89))
      {
        v39 += 216;
        if (v39 == *(void *)&buf[8]) {
          goto LABEL_97;
        }
      }
    }
    if (v39 == *(void *)&buf[8] || (std::string::operator=(&v86, (const std::string *)(v39 + 16)), buf[24]))
    {
LABEL_97:
      uint64_t v87 = buf;
      sub_1000C57C8((void ***)&v87);
    }
  }
  std::string::size_type size = HIBYTE(v86.__r_.__value_.__r.__words[2]);
  if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v86.__r_.__value_.__l.__size_;
  }
  if (!size) {
    goto LABEL_116;
  }
  uint64_t v41 = *(unsigned __int8 *)(a1 + 911);
  if ((v41 & 0x80u) == 0) {
    uint64_t v42 = *(unsigned __int8 *)(a1 + 911);
  }
  else {
    uint64_t v42 = *(void *)(a1 + 896);
  }
  if (v42 == size)
  {
    if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v43 = &v86;
    }
    else {
      uint64_t v43 = (std::string *)v86.__r_.__value_.__r.__words[0];
    }
    if ((v41 & 0x80) == 0)
    {
      if (*(unsigned char *)(a1 + 911))
      {
        unint64_t v44 = (unsigned __int8 *)(a1 + 888);
        while (*v44 == v43->__r_.__value_.__s.__data_[0])
        {
          ++v44;
          uint64_t v43 = (std::string *)((char *)v43 + 1);
          if (!--v41) {
            goto LABEL_116;
          }
        }
        goto LABEL_115;
      }
LABEL_116:
      char v45 = 0;
      goto LABEL_117;
    }
    if (!memcmp(*v21, v43, *(void *)(a1 + 896))) {
      goto LABEL_116;
    }
  }
LABEL_115:
  char v45 = 1;
LABEL_117:
  *(unsigned char *)(a1 + 880) = v45;
  uint64_t v83 = 0;
  uint64_t v84 = 0;
  unint64_t v85 = 0;
  uint64_t v46 = *(uint64_t **)(a1 + 976);
  if (v46 != v4)
  {
    do
    {
      *(_OWORD *)int v91 = 0u;
      long long v92 = 0u;
      memset(buf, 0, sizeof(buf));
      *(_DWORD *)int buf = *((_DWORD *)v46 + 8);
      sub_10037AA60((char *)&buf[8], (long long *)(v46 + 5));
      uint64_t v47 = buf[31];
      if ((buf[31] & 0x80u) != 0) {
        uint64_t v47 = *(void *)&buf[16];
      }
      if (v47)
      {
        if ((*(_DWORD *)&buf[32] | 4) == 4) {
          *(_DWORD *)&uint8_t buf[32] = 1;
        }
        char v48 = v84;
        if ((unint64_t)v84 >= v85)
        {
          int v50 = (unsigned char *)sub_1003DBFB0(&v83, (long long *)&buf[8]);
        }
        else
        {
          if ((char)buf[31] < 0)
          {
            sub_10004FC84(v84, *(void **)&buf[8], *(unint64_t *)&buf[16]);
          }
          else
          {
            long long v49 = *(_OWORD *)&buf[8];
            *((void *)v84 + 2) = *(void *)&buf[24];
            *(_OWORD *)char v48 = v49;
          }
          *((_DWORD *)v48 + 6) = *(_DWORD *)&buf[32];
          if ((char)buf[63] < 0)
          {
            sub_10004FC84(v48 + 32, *(void **)&buf[40], *(unint64_t *)&buf[48]);
          }
          else
          {
            long long v51 = *(_OWORD *)&buf[40];
            *((void *)v48 + 6) = *(void *)&buf[56];
            *((_OWORD *)v48 + 2) = v51;
          }
          unint64_t v52 = v48 + 56;
          if (SBYTE7(v92) < 0)
          {
            sub_10004FC84(v52, v91[0], (unint64_t)v91[1]);
          }
          else
          {
            long long v53 = *(_OWORD *)v91;
            *((void *)v48 + 9) = v92;
            *(_OWORD *)unint64_t v52 = v53;
          }
          *((_DWORD *)v48 + 20) = DWORD2(v92);
          int v50 = v48 + 88;
        }
        uint64_t v84 = v50;
      }
      if (SBYTE7(v92) < 0) {
        operator delete(v91[0]);
      }
      if ((char)buf[63] < 0) {
        operator delete(*(void **)&buf[40]);
      }
      if ((char)buf[31] < 0) {
        operator delete(*(void **)&buf[8]);
      }
      xpc_type_t v54 = (uint64_t *)v46[1];
      if (v54)
      {
        do
        {
          int v55 = v54;
          xpc_type_t v54 = (uint64_t *)*v54;
        }
        while (v54);
      }
      else
      {
        do
        {
          int v55 = (uint64_t *)v46[2];
          BOOL v20 = *v55 == (void)v46;
          uint64_t v46 = v55;
        }
        while (!v20);
      }
      uint64_t v46 = v55;
    }
    while (v55 != v4);
  }
  BOOL v56 = *(std::__shared_weak_count **)(a1 + 64);
  if (v56)
  {
    int64_t v57 = std::__shared_weak_count::lock(v56);
    if (v57)
    {
      xpc_object_t v58 = v57;
      uint64_t v59 = *(void *)(a1 + 56);
      if (v59)
      {
        uint64_t v60 = *(void *)(a1 + 480);
        if (*(void *)(a1 + 488) == v60) {
          sub_10015B728();
        }
        *(void *)int buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = sub_1003D31D4;
        *(void *)&unsigned char buf[24] = &unk_1019C5768;
        *(void *)&uint8_t buf[32] = a1;
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *, uint8_t *))(*(void *)v59 + 16))(v59, v60 + 16, a1 + 888, &v83, buf);
        uint64_t v61 = *(uint64_t **)(a1 + 976);
        if (*(void *)(a1 + 1016))
        {
          uint64_t v62 = *(void *)(a1 + 1000);
          CFStringRef v63 = (uint64_t **)(a1 + 1008);
          *(void *)(a1 + 1000) = a1 + 1008;
          *(void *)(*(void *)(a1 + 1008) + 16) = 0;
          *(void *)(a1 + 1008) = 0;
          *(void *)(a1 + 1016) = 0;
          if (*(void *)(v62 + 8)) {
            unint64_t v64 = *(uint64_t **)(v62 + 8);
          }
          else {
            unint64_t v64 = (uint64_t *)v62;
          }
          uint64_t v87 = (uint8_t *)(a1 + 1000);
          uint64_t v88 = v64;
          uint64_t v89 = v64;
          if (v64)
          {
            uint64_t v88 = sub_1000EA590((uint64_t)v64);
            if (v61 == v4)
            {
              unint64_t v69 = (uint64_t *)(a1 + 984);
            }
            else
            {
              do
              {
                *((_DWORD *)v64 + 8) = *((_DWORD *)v61 + 8);
                std::string::operator=((std::string *)(v64 + 5), (const std::string *)(v61 + 5));
                *((_DWORD *)v64 + 16) = *((_DWORD *)v61 + 16);
                std::string::operator=((std::string *)v64 + 3, (const std::string *)v61 + 3);
                std::string::operator=((std::string *)v64 + 4, (const std::string *)v61 + 4);
                *((_DWORD *)v64 + 30) = *((_DWORD *)v61 + 30);
                xpc_object_t v65 = *v63;
                uint64_t v66 = (uint64_t **)(a1 + 1008);
                int v67 = (uint64_t **)(a1 + 1008);
                if (*v63)
                {
                  do
                  {
                    while (1)
                    {
                      uint64_t v66 = (uint64_t **)v65;
                      if (*((_DWORD *)v89 + 8) >= *((_DWORD *)v65 + 8)) {
                        break;
                      }
                      xpc_object_t v65 = (uint64_t *)*v65;
                      int v67 = v66;
                      if (!*v66) {
                        goto LABEL_164;
                      }
                    }
                    xpc_object_t v65 = (uint64_t *)v65[1];
                  }
                  while (v65);
                  int v67 = v66 + 1;
                }
LABEL_164:
                sub_100046C38((uint64_t **)(a1 + 1000), (uint64_t)v66, v67, v89);
                unint64_t v64 = v88;
                uint64_t v89 = v88;
                if (v88) {
                  uint64_t v88 = sub_1000EA590((uint64_t)v88);
                }
                BOOL v68 = (uint64_t *)v61[1];
                if (v68)
                {
                  do
                  {
                    unint64_t v69 = v68;
                    BOOL v68 = (uint64_t *)*v68;
                  }
                  while (v68);
                }
                else
                {
                  do
                  {
                    unint64_t v69 = (uint64_t *)v61[2];
                    BOOL v20 = *v69 == (void)v61;
                    uint64_t v61 = v69;
                  }
                  while (!v20);
                }
                if (!v64) {
                  break;
                }
                uint64_t v61 = v69;
              }
              while (v69 != v4);
            }
          }
          else
          {
            unint64_t v69 = v61;
          }
          sub_1003DE7B4((uint64_t)&v87);
          uint64_t v61 = v69;
        }
        if (v61 != v4)
        {
          uint64_t v70 = (uint64_t *)(a1 + 1008);
          do
          {
            uint64_t v89 = 0;
            unsigned int v71 = operator new(0x80uLL);
            uint64_t v87 = (uint8_t *)v71;
            uint64_t v88 = v70;
            *((_DWORD *)v71 + 8) = *((_DWORD *)v61 + 8);
            sub_10037AA60((char *)v71 + 40, (long long *)(v61 + 5));
            LOBYTE(v89) = 1;
            uint64_t v72 = *v70;
            int v73 = (uint64_t **)v70;
            uint64_t v74 = (uint64_t **)v70;
            if (*v70)
            {
              do
              {
                while (1)
                {
                  int v73 = (uint64_t **)v72;
                  if (*((_DWORD *)v71 + 8) >= *(_DWORD *)(v72 + 32)) {
                    break;
                  }
                  uint64_t v72 = *(void *)v72;
                  uint64_t v74 = v73;
                  if (!*v73) {
                    goto LABEL_185;
                  }
                }
                uint64_t v72 = *(void *)(v72 + 8);
              }
              while (v72);
              uint64_t v74 = v73 + 1;
            }
LABEL_185:
            sub_100046C38(v28, (uint64_t)v73, v74, (uint64_t *)v71);
            uint64_t v87 = 0;
            sub_1003DE804((uint64_t)&v87);
            uint64_t v75 = (uint64_t *)v61[1];
            if (v75)
            {
              do
              {
                xpc_object_t v76 = v75;
                uint64_t v75 = (uint64_t *)*v75;
              }
              while (v75);
            }
            else
            {
              do
              {
                xpc_object_t v76 = (uint64_t *)v61[2];
                BOOL v20 = *v76 == (void)v61;
                uint64_t v61 = v76;
              }
              while (!v20);
            }
            uint64_t v61 = v76;
          }
          while (v76 != v4);
        }
      }
      sub_10004D2C8(v58);
    }
  }
  uint64_t v87 = (uint8_t *)&v83;
  sub_10037AB58((void ***)&v87);
  if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v86.__r_.__value_.__l.__data_);
  }
LABEL_88:
  if (SHIBYTE(v81) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(v79[0]);
  }
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
}

void sub_1003CFB80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,char *a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,char a41)
{
  if (a41)
  {
    a35 = &a38;
    sub_1000C57C8((void ***)&a35);
  }
  if (a33 < 0) {
    operator delete(__p);
  }
  sub_1003785AC((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_1003CFC78@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 208) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  memset(v17, 0, sizeof(v17));
  long long v16 = 0u;
  memset(v15, 0, sizeof(v15));
  sub_1003D5AAC((uint64_t)v15, *(_DWORD **)(a1 + 760), *(_DWORD **)(a1 + 768), a2);
  if (BYTE8(v19))
  {
    memset(&__str, 0, sizeof(__str));
    if (SHIBYTE(v15[3].__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__str, v15[3].__r_.__value_.__l.__data_, v15[3].__r_.__value_.__l.__size_);
    }
    else {
      std::string __str = v15[3];
    }
    std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    char v6 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
    }
    if (size)
    {
      uint64_t v24 = 0;
      long long v23 = 0u;
      memset(v22, 0, sizeof(v22));
      memset(v21, 0, sizeof(v21));
      memset(v20, 0, sizeof(v20));
      std::string::operator=(v20, &__str);
      *(_OWORD *)long long __p = 0u;
      long long v13 = 0u;
      *(_OWORD *)int v11 = 0u;
      sub_100E63EA4((uint64_t)v11);
      std::string::operator=(&v20[1], (const std::string *)v11);
      std::string::operator=(v21, (const std::string *)&__p[1]);
      std::string::operator=(&v21[1], (const std::string *)((char *)v17 + 8));
      std::string::operator=((std::string *)v22, (const std::string *)&v18);
      uint64_t v7 = sub_1003DF000((void *)(a1 + 104), (unsigned __int8 *)&__str);
      if (v7)
      {
        int v8 = (uint64_t *)v7;
        uint64_t v9 = v7 + 40;
        sub_1003DC1E4((uint64_t)&v22[24], (uint64_t)(v7 + 40));
        sub_1003DC1E4((uint64_t)&v22[56], (uint64_t)(v8 + 9));
        if (&v22[24] != v9)
        {
          sub_1003DAD3C((uint64_t)&v22[88], v8[13], v8[14], 0x8E38E38E38E38E39 * ((v8[14] - v8[13]) >> 4));
          sub_1003DAFDC((uint64_t)&v23, v8[16], v8[17], 0xCF3CF3CF3CF3CF3DLL * ((v8[17] - v8[16]) >> 3));
        }
      }
      sub_1003D5B34((std::string *)a3, v20);
      if (SHIBYTE(v13) < 0) {
        operator delete(__p[1]);
      }
      if (SHIBYTE(__p[0]) < 0) {
        operator delete(v11[0]);
      }
      sub_10023F898((uint64_t)v20);
      char v6 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    }
    if (v6 < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
  return sub_100397998((uint64_t)v15);
}

void sub_1003CFEF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  sub_100397998((uint64_t)&a22);
  if (*(unsigned char *)(v44 + 232)) {
    sub_10023F898(v44);
  }
  _Unwind_Resume(a1);
}

void sub_1003CFF58(uint64_t a1, uint64_t *a2)
{
  (*(void (**)(void, uint64_t *, void))(**(void **)(a1 + 88) + 112))(*(void *)(a1 + 88), a2, 0);
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];

  sub_1003CFFC0(a1, v4, v5);
}

void sub_1003CFFC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    int v50 = (uint64_t **)(a1 + 1096);
    char v6 = (unsigned __int8 *)(a1 + 424);
    uint64_t v7 = (uint64_t **)(a1 + 1128);
    do
    {
      if ((*(unsigned char *)(v4 + 56) & 0xFE) == 6)
      {
        int v8 = *(int **)(a1 + 760);
        uint64_t v9 = *(int **)(a1 + 768);
        if (*(char *)(v4 + 87) < 0)
        {
          sub_10004FC84(__p, *(void **)(v4 + 64), *(void *)(v4 + 72));
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)(v4 + 64);
          uint64_t v55 = *(void *)(v4 + 80);
        }
        char v10 = HIBYTE(v55);
        if (v8 != v9)
        {
          if (v55 >= 0) {
            int v11 = (void *)HIBYTE(v55);
          }
          else {
            int v11 = __p[1];
          }
          if (v55 >= 0) {
            uint64_t v12 = __p;
          }
          else {
            uint64_t v12 = (void **)__p[0];
          }
          do
          {
            uint64_t v13 = *((unsigned __int8 *)v8 + 95);
            if ((v13 & 0x80u) == 0) {
              unint64_t v14 = (void *)*((unsigned __int8 *)v8 + 95);
            }
            else {
              unint64_t v14 = (void *)*((void *)v8 + 10);
            }
            if (v14 == v11)
            {
              if ((v13 & 0x80) != 0)
              {
                if (!memcmp(*((const void **)v8 + 9), v12, *((void *)v8 + 10))) {
                  goto LABEL_27;
                }
              }
              else
              {
                if (!*((unsigned char *)v8 + 95)) {
                  goto LABEL_27;
                }
                uint64_t v15 = 0;
                while (*((unsigned __int8 *)v8 + v15 + 72) == *((unsigned __int8 *)v12 + v15))
                {
                  if (v13 == ++v15) {
                    goto LABEL_27;
                  }
                }
              }
            }
            v8 += 42;
          }
          while (v8 != v9);
          int v8 = v9;
        }
LABEL_27:
        if (v10 < 0) {
          operator delete(__p[0]);
        }
        if (v8 != *(int **)(a1 + 768))
        {
          long long v16 = *v7;
          uint64_t v17 = v7;
          long long v18 = (char *)v7;
          if (*v7)
          {
            int v19 = *v8;
            while (1)
            {
              while (1)
              {
                long long v18 = (char *)v16;
                int v20 = *((_DWORD *)v16 + 8);
                if (v20 <= v19) {
                  break;
                }
                long long v16 = *(uint64_t **)v18;
                uint64_t v17 = (uint64_t **)v18;
                if (!*(void *)v18) {
                  goto LABEL_38;
                }
              }
              if (v20 >= v19) {
                break;
              }
              long long v16 = (uint64_t *)*((void *)v18 + 1);
              if (!v16)
              {
                uint64_t v17 = (uint64_t **)(v18 + 8);
                goto LABEL_38;
              }
            }
          }
          else
          {
LABEL_38:
            uint64_t v21 = v18;
            long long v18 = (char *)operator new(0x40uLL);
            *((_DWORD *)v18 + 8) = *v8;
            *((void *)v18 + 6) = 0;
            *((void *)v18 + 7) = 0;
            *((void *)v18 + 5) = 0;
            *(void *)long long v18 = 0;
            *((void *)v18 + 1) = 0;
            *((void *)v18 + 2) = v21;
            char *v17 = (uint64_t *)v18;
            uint64_t v22 = **(void **)(a1 + 1120);
            long long v23 = (uint64_t *)v18;
            if (v22)
            {
              *(void *)(a1 + 1120) = v22;
              long long v23 = *v17;
            }
            sub_100046C90(*(uint64_t **)(a1 + 1128), v23);
            ++*(void *)(a1 + 1136);
          }
          if (*(char *)(v4 + 31) < 0)
          {
            sub_10004FC84(__dst, *(void **)(v4 + 8), *(void *)(v4 + 16));
          }
          else
          {
            *(_OWORD *)std::string __dst = *(_OWORD *)(v4 + 8);
            uint64_t v52 = *(void *)(v4 + 24);
          }
          char v24 = *(unsigned char *)(v4 + 56);
          char v53 = v24;
          unint64_t v25 = *((void *)v18 + 7);
          unint64_t v26 = *((void *)v18 + 6);
          if (v26 >= v25)
          {
            uint64_t v28 = *((void *)v18 + 5);
            uint64_t v29 = (uint64_t)(v26 - v28) >> 5;
            unint64_t v30 = v29 + 1;
            if ((unint64_t)(v29 + 1) >> 59) {
              sub_10006A748();
            }
            uint64_t v31 = v25 - v28;
            if (v31 >> 4 > v30) {
              unint64_t v30 = v31 >> 4;
            }
            if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v32 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v32 = v30;
            }
            uint64_t v59 = v18 + 56;
            if (v32 >> 59) {
              sub_10006A7CC();
            }
            uint64_t v33 = (long long *)operator new(32 * v32);
            uint64_t v34 = &v33[2 * v29];
            BOOL v56 = v33;
            v57.i64[0] = (uint64_t)v34;
            int v35 = &v33[2 * v32];
            *((void *)v34 + 2) = v52;
            long long *v34 = *(_OWORD *)__dst;
            __dst[0] = 0;
            __dst[1] = 0;
            uint64_t v52 = 0;
            *((unsigned char *)v34 + 24) = v24;
            uint64_t v36 = v34 + 2;
            v57.i64[1] = (uint64_t)(v34 + 2);
            xpc_object_t v58 = v35;
            uint64_t v38 = *((void *)v18 + 5);
            unint64_t v37 = *((void *)v18 + 6);
            if (v37 == v38)
            {
              int64x2_t v40 = vdupq_n_s64(v37);
            }
            else
            {
              do
              {
                long long v39 = *(_OWORD *)(v37 - 32);
                *((void *)v34 - 2) = *(void *)(v37 - 16);
                *(v34 - 2) = v39;
                *(void *)(v37 - 24) = 0;
                *(void *)(v37 - 16) = 0;
                *(void *)(v37 - 32) = 0;
                *((unsigned char *)v34 - 8) = *(unsigned char *)(v37 - 8);
                v34 -= 2;
                v37 -= 32;
              }
              while (v37 != v38);
              int64x2_t v40 = *(int64x2_t *)(v18 + 40);
              uint64_t v36 = (long long *)v57.i64[1];
              int v35 = v58;
            }
            *((void *)v18 + 5) = v34;
            *((void *)v18 + 6) = v36;
            int64x2_t v57 = v40;
            uint64_t v41 = (long long *)*((void *)v18 + 7);
            *((void *)v18 + 7) = v35;
            xpc_object_t v58 = v41;
            BOOL v56 = (long long *)v40.i64[0];
            sub_1000F5AA0((uint64_t)&v56);
            int v42 = SHIBYTE(v52);
            *((void *)v18 + 6) = v36;
            if (v42 < 0) {
              operator delete(__dst[0]);
            }
          }
          else
          {
            long long v27 = *(_OWORD *)__dst;
            *(void *)(v26 + 16) = v52;
            *(_OWORD *)unint64_t v26 = v27;
            __dst[1] = 0;
            uint64_t v52 = 0;
            __dst[0] = 0;
            *(unsigned char *)(v26 + 24) = v53;
            *((void *)v18 + 6) = v26 + 32;
          }
        }
      }
      if (*(char *)(v4 + 55) < 0)
      {
        if (!*(void *)(v4 + 40)) {
          goto LABEL_83;
        }
      }
      else if (!*(unsigned char *)(v4 + 55))
      {
        goto LABEL_83;
      }
      BOOL v56 = (long long *)(v4 + 32);
      uint64_t v43 = sub_1003DF1C0(v50, (void **)(v4 + 32), (uint64_t)&unk_10144E20E, &v56);
      CellularPlanEntitlementSubscriptionDetails::merge((CellularPlanEntitlementSubscriptionDetails *)(v43 + 7), (const CellularPlanEntitlementSubscriptionDetails *)v4);
      uint64_t v44 = *(unsigned __int8 *)(v4 + 55);
      if ((v44 & 0x80u) == 0) {
        uint64_t v45 = *(unsigned __int8 *)(v4 + 55);
      }
      else {
        uint64_t v45 = *(void *)(v4 + 40);
      }
      uint64_t v46 = *(unsigned __int8 *)(a1 + 447);
      int v47 = (char)v46;
      if ((v46 & 0x80u) != 0) {
        uint64_t v46 = *(void *)(a1 + 432);
      }
      if (v45 != v46) {
        goto LABEL_83;
      }
      if (v47 >= 0) {
        char v48 = v6;
      }
      else {
        char v48 = *(unsigned __int8 **)v6;
      }
      if ((v44 & 0x80) == 0)
      {
        if (*(unsigned char *)(v4 + 55))
        {
          uint64_t v49 = 0;
          while (*(unsigned __int8 *)(v4 + v49 + 32) == v48[v49])
          {
            if (v44 == ++v49) {
              goto LABEL_79;
            }
          }
          goto LABEL_83;
        }
LABEL_79:
        if (*(unsigned char *)(v4 + 56) == 2)
        {
          sub_1003D2420(a1, (uint64_t)v6);
          if (*(char *)(a1 + 447) < 0)
          {
            **(unsigned char **)(a1 + 424) = 0;
            *(void *)(a1 + 432) = 0;
          }
          else
          {
            *(unsigned char *)(a1 + 424) = 0;
            *(unsigned char *)(a1 + 447) = 0;
          }
        }
        goto LABEL_83;
      }
      if (!memcmp(*(const void **)(v4 + 32), v48, *(void *)(v4 + 40))) {
        goto LABEL_79;
      }
LABEL_83:
      v4 += 192;
    }
    while (v4 != a3);
  }
}

void sub_1003D044C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003D0470(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 448;
  std::string::operator=((std::string *)(a1 + 448), (const std::string *)a2);
  uint64_t v5 = *(void *)(a2 + 24);
  *(void *)(a1 + 472) = v5;
  if (v4 == a2)
  {
    LODWORD(v5) = v5;
  }
  else
  {
    sub_1003DB294(a1 + 480, *(void *)(a2 + 32), *(void *)(a2 + 40), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3));
    LODWORD(v5) = *(unsigned __int8 *)(a1 + 472);
  }
  uint64_t v6 = *(void *)(a2 + 56);
  *(_DWORD *)(a1 + 512) = *(_DWORD *)(a2 + 64);
  *(void *)(a1 + 504) = v6;
  if (!v5)
  {
    *(unsigned char *)(a1 + 880) = 0;
    v16[0] = 0;
    sub_1003D0654(a1, (uint64_t)v16);
    if (v16[0])
    {
      if (v18 < 0) {
        operator delete(v17);
      }
      v16[0] = 0;
    }
    int v7 = *(_DWORD *)(a1 + 152);
    uint64_t v9 = 0;
    long long v8 = 0uLL;
    v10[0] = 0;
    char v11 = 0;
    sub_1003DB514((uint64_t)v12, v7, &v8, (uint64_t)v10, 0);
    sub_1003D0708(a1, 0, (uint64_t)v12);
    if (v15[216]) {
      sub_1000C584C((uint64_t)v15);
    }
    if (v14 < 0) {
      operator delete(__p);
    }
    if (v11) {
      sub_1000C584C((uint64_t)v10);
    }
    if (SHIBYTE(v9) < 0) {
      operator delete((void *)v8);
    }
  }
  sub_1003D09F0(a1, *(void *)(a2 + 32), *(void *)(a2 + 40));
  sub_1003D1554(a1);
}

void sub_1003D05F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,int a43,__int16 a44,char a45,char a46)
{
  if (a42) {
    sub_1000C584C((uint64_t)&a15);
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1003D0654(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (unsigned char *)(a1 + 792);
  if (*(unsigned char *)(a1 + 792))
  {
    if (*(unsigned char *)a2)
    {
      *(_OWORD *)(a1 + 800) = *(_OWORD *)(a2 + 8);
      std::string::operator=((std::string *)(a1 + 816), (const std::string *)(a2 + 24));
      *(unsigned char *)(a1 + 840) = *(unsigned char *)(a2 + 48);
    }
    else
    {
      if (*(char *)(a1 + 839) < 0) {
        operator delete(*(void **)(a1 + 816));
      }
      *uint64_t v4 = 0;
    }
  }
  else if (*(unsigned char *)a2)
  {
    sub_1003DBF48(a1 + 792, a2 + 8);
  }
  if (!*(unsigned char *)(a1 + 544))
  {
    sub_1003D1554(a1);
  }
}

void sub_1003D0708(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      int v7 = "true";
    }
    else {
      int v7 = "false";
    }
    uint64_t v8 = subscriber::asString();
    if (*(unsigned char *)(a3 + 256)) {
      uint64_t v9 = "true";
    }
    else {
      uint64_t v9 = "false";
    }
    *(_DWORD *)int buf = 136315650;
    uint64_t v22 = v7;
    __int16 v23 = 2080;
    *(void *)char v24 = v8;
    *(_WORD *)&unsigned char v24[8] = 2080;
    unint64_t v25 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Update profile placeholder, create:%s, local slot: %s, transfer: %s", buf, 0x20u);
  }
  *(unsigned char *)(a1 + 144) = a2;
  *(_DWORD *)(a1 + 152) = *(_DWORD *)a3;
  std::string::operator=((std::string *)(a1 + 160), (const std::string *)(a3 + 8));
  char v10 = (_OWORD *)(a1 + 184);
  if (*(unsigned __int8 *)(a1 + 400) == *(unsigned __int8 *)(a3 + 248))
  {
    if (*(unsigned char *)(a1 + 400))
    {
      *char v10 = *(_OWORD *)(a3 + 32);
      std::string::operator=((std::string *)(a1 + 200), (const std::string *)(a3 + 48));
      std::string::operator=((std::string *)(a1 + 224), (const std::string *)(a3 + 72));
      std::string::operator=((std::string *)(a1 + 248), (const std::string *)(a3 + 96));
      *(_DWORD *)(a1 + 272) = *(_DWORD *)(a3 + 120);
      std::string::operator=((std::string *)(a1 + 280), (const std::string *)(a3 + 128));
      std::string::operator=((std::string *)(a1 + 304), (const std::string *)(a3 + 152));
      std::string::operator=((std::string *)(a1 + 328), (const std::string *)(a3 + 176));
      std::string::operator=((std::string *)(a1 + 352), (const std::string *)(a3 + 200));
      std::string::operator=((std::string *)(a1 + 376), (const std::string *)(a3 + 224));
    }
  }
  else if (*(unsigned char *)(a1 + 400))
  {
    sub_1000C584C((uint64_t)v10);
    *(unsigned char *)(a1 + 400) = 0;
  }
  else
  {
    sub_1000C5AB4((uint64_t)v10, a3 + 32);
    *(unsigned char *)(a1 + 400) = 1;
  }
  *(unsigned char *)(a1 + 408) = *(unsigned char *)(a3 + 256);
  sub_1003DABB4(buf, a3 + 32);
  if (v27)
  {
    sub_1003D2230(&__p, a1);
    RemoteVinylInfo::findProfile();
    int v11 = v20;
    if (v20) {
      sub_1000C584C((uint64_t)v18);
    }
    uint64_t v17 = (void **)&v16;
    sub_1000C56F4(&v17);
    if (v15 < 0) {
      operator delete(__p);
    }
    if (v11)
    {
      uint64_t v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        if (v26 >= 0) {
          uint64_t v13 = &v24[2];
        }
        else {
          uint64_t v13 = *(unsigned char **)&v24[2];
        }
        *(_DWORD *)char v18 = 136315138;
        int v19 = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Found iccid (%s) - placeholder not needed", v18, 0xCu);
      }
      *(unsigned char *)(a1 + 144) = 0;
    }
    if (v27) {
      sub_1000C584C((uint64_t)buf);
    }
  }
}

void sub_1003D09BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (LOBYTE(STACK[0x208])) {
    sub_1000C584C((uint64_t)&a47);
  }
  _Unwind_Resume(a1);
}

void sub_1003D09F0(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = a1;
  unint64_t v128 = 0;
  uint64_t v127 = 0;
  unint64_t v129 = 0;
  if (a2 == a3)
  {
    uint64_t v79 = 0;
    uint64_t v78 = 0;
    goto LABEL_198;
  }
  uint64_t v85 = a1 + 1080;
  uint64_t v86 = a1 + 184;
  uint64_t v4 = a2;
  uint64_t v5 = (void *)(a1 + 1104);
  uint64_t v80 = a1 + 1072;
  do
  {
    if (*(unsigned char *)(v4 + 80))
    {
      memset(&v126, 0, sizeof(v126));
      ctu::hex((uint64_t *)&v126, (ctu *)(v4 + 16), (const void *)0x10, a3);
      uint64_t v6 = sub_1003DE594(v80, v4 + 16);
      uint64_t v7 = *(void *)(v4 + 56);
      uint64_t v82 = v4;
      uint64_t v88 = *(void *)(v4 + 64);
      if (v7 != v88)
      {
        uint64_t v8 = v6;
        uint64_t v83 = (ctu *)(v4 + 16);
        uint64_t v84 = (uint64_t)(v6 + 6);
        uint64_t v87 = v6;
        do
        {
          if ((void *)v85 == v8) {
            goto LABEL_56;
          }
          __p[1] = 0;
          __p[0] = 0;
          *(void *)&long long v131 = 0;
          sub_100CD7084(v7 + 16, (uint64_t)__p);
          uint64_t v10 = v8[6];
          uint64_t v9 = v8[7];
          if (SBYTE7(v131) < 0)
          {
            sub_10004FC84(__n, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)size_t __n = *(_OWORD *)__p;
            uint64_t v125 = v131;
          }
          if (v10 != v9)
          {
            uint64_t v11 = v7;
            uint64_t v12 = v9;
            uint64_t v13 = HIBYTE(v125);
            size_t v14 = __n[1];
            char v15 = (const void *)__n[0];
            if (v125 >= 0) {
              size_t v16 = HIBYTE(v125);
            }
            else {
              size_t v16 = __n[1];
            }
            while (1)
            {
              uint64_t v17 = *(unsigned __int8 *)(v10 + 95);
              int v18 = (char)v17;
              if ((v17 & 0x80u) != 0) {
                uint64_t v17 = *(void *)(v10 + 80);
              }
              if (v16 == v17)
              {
                if (v18 >= 0) {
                  int v19 = (unsigned __int8 *)(v10 + 72);
                }
                else {
                  int v19 = *(unsigned __int8 **)(v10 + 72);
                }
                if ((v13 & 0x80) == 0)
                {
                  if (!v13) {
                    break;
                  }
                  unsigned __int8 v20 = __n;
                  uint64_t v21 = v13;
                  while (*(unsigned __int8 *)v20 == *v19)
                  {
                    unsigned __int8 v20 = (size_t *)((char *)v20 + 1);
                    ++v19;
                    if (!--v21) {
                      goto LABEL_29;
                    }
                  }
                  goto LABEL_27;
                }
                if (!memcmp(v15, v19, v14)) {
                  break;
                }
              }
LABEL_27:
              v10 += 312;
              if (v10 == v9)
              {
                uint64_t v8 = v87;
                uint64_t v7 = v11;
                uint64_t v3 = a1;
                goto LABEL_52;
              }
            }
LABEL_29:
            uint64_t v8 = v87;
            uint64_t v7 = v11;
            uint64_t v3 = a1;
            if (v10 == v9) {
              goto LABEL_52;
            }
            uint64_t v22 = v10 + 312;
            if (v10 + 312 != v9)
            {
              uint64_t v12 = v10;
              while (1)
              {
                uint64_t v23 = v10;
                uint64_t v10 = v22;
                uint64_t v24 = HIBYTE(v125);
                if (v125 >= 0) {
                  size_t v25 = HIBYTE(v125);
                }
                else {
                  size_t v25 = __n[1];
                }
                uint64_t v26 = *(unsigned __int8 *)(v23 + 407);
                int v27 = (char)v26;
                if ((v26 & 0x80u) != 0) {
                  uint64_t v26 = *(void *)(v23 + 392);
                }
                if (v25 != v26) {
                  goto LABEL_48;
                }
                uint64_t v28 = (unsigned __int8 *)(v23 + 384);
                uint64_t v29 = *(unsigned __int8 **)(v23 + 384);
                if (v27 >= 0) {
                  unint64_t v30 = v28;
                }
                else {
                  unint64_t v30 = v29;
                }
                if (v125 < 0)
                {
                  if (memcmp((const void *)__n[0], v30, __n[1])) {
                    goto LABEL_48;
                  }
                }
                else if (HIBYTE(v125))
                {
                  uint64_t v31 = __n;
                  while (*(unsigned __int8 *)v31 == *v30)
                  {
                    uint64_t v31 = (size_t *)((char *)v31 + 1);
                    ++v30;
                    if (!--v24) {
                      goto LABEL_49;
                    }
                  }
LABEL_48:
                  sub_10031016C(v12, (long long *)v10);
                  v12 += 312;
                }
LABEL_49:
                uint64_t v22 = v10 + 312;
                if (v10 + 312 == v9) {
                  goto LABEL_52;
                }
              }
            }
          }
          uint64_t v12 = v10;
LABEL_52:
          sub_100301910(v84, v12, (long long *)v8[7]);
          if (SHIBYTE(v125) < 0) {
            operator delete((void *)__n[0]);
          }
          if (SBYTE7(v131) < 0) {
            operator delete(__p[0]);
          }
LABEL_56:
          if (!*(unsigned char *)(v3 + 144)) {
            goto LABEL_89;
          }
          sub_1003DABB4(__p, v86);
          if (!BYTE8(v143)) {
            goto LABEL_89;
          }
          sub_1003DABB4(v147, v86);
          if (SHIBYTE(v149) >= 0) {
            unint64_t v32 = (void *)HIBYTE(v149);
          }
          else {
            unint64_t v32 = __s1[1];
          }
          uint64_t v33 = (void *)*(unsigned __int8 *)(v7 + 39);
          int v34 = (char)v33;
          if ((char)v33 < 0) {
            uint64_t v33 = *(void **)(v7 + 24);
          }
          if (v32 == v33)
          {
            if (v34 >= 0) {
              int v35 = (unsigned __int8 *)(v7 + 16);
            }
            else {
              int v35 = *(unsigned __int8 **)(v7 + 16);
            }
            if ((HIBYTE(v149) & 0x80) != 0)
            {
              BOOL v44 = memcmp(__s1[0], v35, (size_t)__s1[1]) == 0;
            }
            else if (HIBYTE(v149))
            {
              uint64_t v36 = HIBYTE(v149) - 1;
              unint64_t v37 = __s1;
              do
              {
                int v39 = *(unsigned __int8 *)v37;
                unint64_t v37 = (void **)((char *)v37 + 1);
                int v38 = v39;
                int v41 = *v35++;
                int v40 = v41;
                BOOL v43 = v36-- != 0;
                BOOL v44 = v38 == v40;
              }
              while (v38 == v40 && v43);
            }
            else
            {
              BOOL v44 = 1;
            }
          }
          else
          {
            BOOL v44 = 0;
          }
          if (v150) {
            sub_1000C584C((uint64_t)v147);
          }
          if (BYTE8(v143))
          {
            sub_1000C584C((uint64_t)__p);
            if (!v44) {
              goto LABEL_89;
            }
          }
          else if (!v44)
          {
            goto LABEL_89;
          }
          uint64_t v146 = 0;
          long long v144 = 0u;
          long long v145 = 0u;
          long long v142 = 0u;
          long long v143 = 0u;
          *(_OWORD *)uint64_t v140 = 0u;
          long long v141 = 0u;
          *(_OWORD *)uint64_t v138 = 0u;
          long long v139 = 0u;
          long long v136 = 0u;
          *(_OWORD *)v137 = 0u;
          *(_OWORD *)v134 = 0u;
          *(_OWORD *)uint64_t v135 = 0u;
          *(_OWORD *)char v132 = 0u;
          long long v133 = 0u;
          *(_OWORD *)long long __p = 0u;
          long long v131 = 0u;
          sub_1003D0708(v3, 0, (uint64_t)__p);
          if (BYTE8(v145)) {
            sub_1000C584C((uint64_t)v132);
          }
          if (SHIBYTE(v131) < 0) {
            operator delete(__p[1]);
          }
LABEL_89:
          uint64_t v45 = *(void **)(v3 + 1096);
          uint64_t v46 = (const std::string *)(v7 + 16);
          if (*(char *)(v7 + 39) < 0)
          {
            sub_10004FC84(__dst, *(void **)(v7 + 16), *(void *)(v7 + 24));
          }
          else
          {
            *(_OWORD *)std::string __dst = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
            uint64_t v123 = *(void *)(v7 + 32);
          }
          char v47 = HIBYTE(v123);
          char v48 = v5;
          if (v45 != v5)
          {
            uint64_t v89 = (const std::string *)(v7 + 16);
            uint64_t v90 = v7;
            if (v123 >= 0) {
              uint64_t v49 = __dst;
            }
            else {
              uint64_t v49 = (void **)__dst[0];
            }
            if (v123 >= 0) {
              int v50 = (char *)HIBYTE(v123);
            }
            else {
              int v50 = (char *)__dst[1];
            }
            long long v51 = &v50[(void)v49];
            char v48 = v45;
            do
            {
              int v52 = *((char *)v48 + 55);
              if (v52 >= 0) {
                int64_t v53 = *((unsigned __int8 *)v48 + 55);
              }
              else {
                int64_t v53 = v48[5];
              }
              if ((unint64_t)v53 >= 0x13)
              {
                xpc_type_t v54 = v52 >= 0 ? (char *)(v48 + 4) : (char *)v48[4];
                if ((uint64_t)v50 >= v53)
                {
                  int v58 = *v54;
                  uint64_t v59 = v50;
                  uint64_t v60 = v49;
                  do
                  {
                    uint64_t v61 = &v59[-v53];
                    if (v61 == (char *)-1) {
                      break;
                    }
                    uint64_t v62 = (char *)memchr(v60, v58, (size_t)(v61 + 1));
                    if (!v62) {
                      break;
                    }
                    CFStringRef v63 = v62;
                    if (!memcmp(v62, v54, v53))
                    {
                      if (v63 == v51 || v63 - (char *)v49 == -1) {
                        break;
                      }
                      goto LABEL_123;
                    }
                    uint64_t v60 = (void **)(v63 + 1);
                    uint64_t v59 = (char *)(v51 - (v63 + 1));
                  }
                  while ((uint64_t)v59 >= v53);
                }
              }
              uint64_t v55 = (void *)v48[1];
              if (v55)
              {
                do
                {
                  BOOL v56 = v55;
                  uint64_t v55 = (void *)*v55;
                }
                while (v55);
              }
              else
              {
                do
                {
                  BOOL v56 = (void *)v48[2];
                  BOOL v57 = *v56 == (void)v48;
                  char v48 = v56;
                }
                while (!v57);
              }
              char v48 = v56;
            }
            while (v56 != v5);
            char v48 = v5;
LABEL_123:
            uint64_t v8 = v87;
            uint64_t v46 = v89;
            uint64_t v7 = v90;
          }
          if (v47 < 0) {
            operator delete(__dst[0]);
          }
          if (v48 == v5)
          {
            *(void *)&long long v142 = 0;
            *(_OWORD *)uint64_t v140 = 0u;
            long long v141 = 0u;
            *(_OWORD *)uint64_t v138 = 0u;
            long long v139 = 0u;
            long long v136 = 0u;
            *(_OWORD *)v137 = 0u;
            *(_OWORD *)v134 = 0u;
            *(_OWORD *)uint64_t v135 = 0u;
            *(_OWORD *)char v132 = 0u;
            long long v133 = 0u;
            *(_OWORD *)long long __p = 0u;
            long long v131 = 0u;
            uint64_t v3 = a1;
            (*(void (**)(void **__return_ptr))(**(void **)(a1 + 88) + 80))(__p);
            if ((_BYTE)v142)
            {
              sub_10023FB90((uint64_t)v92, (uint64_t)__p);
              sub_1003DA754(a1, &v126, v46, (uint64_t)v92);
              if (v106 < 0) {
                operator delete(v105);
              }
              if (v104 < 0) {
                operator delete(v103);
              }
              if (v102 < 0) {
                operator delete(v101);
              }
              if (v100 < 0) {
                operator delete(v99);
              }
              if (v98 < 0) {
                operator delete(v97);
              }
              if (v96 < 0) {
                operator delete(v95);
              }
              if (v94 < 0) {
                operator delete(v93);
              }
              unint64_t v65 = v128;
              if (v128 >= v129)
              {
                uint64_t v66 = sub_1003DBC84(&v127, (uint64_t)__p);
              }
              else
              {
                sub_10023FB90(v128, (uint64_t)__p);
                uint64_t v66 = v65 + 192;
              }
              unint64_t v128 = v66;
            }
            else
            {
              unint64_t v68 = v128;
              if (v128 >= v129)
              {
                unint64_t v70 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v128 - v127) >> 6);
                unint64_t v71 = v70 + 1;
                if (v70 + 1 > 0x155555555555555) {
                  sub_10006A748();
                }
                if (0x5555555555555556 * ((uint64_t)(v129 - v127) >> 6) > v71) {
                  unint64_t v71 = 0x5555555555555556 * ((uint64_t)(v129 - v127) >> 6);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v129 - v127) >> 6) >= 0xAAAAAAAAAAAAAALL) {
                  unint64_t v72 = 0x155555555555555;
                }
                else {
                  unint64_t v72 = v71;
                }
                uint64_t v149 = &v129;
                int v73 = (char *)sub_10034036C((uint64_t)&v129, v72);
                uint64_t v74 = &v73[192 * v70];
                v147[0] = v73;
                v147[1] = v74;
                __s1[1] = &v73[192 * v75];
                *(_OWORD *)uint64_t v74 = 0u;
                *((_OWORD *)v74 + 1) = 0u;
                *((_OWORD *)v74 + 2) = 0u;
                *((_OWORD *)v74 + 3) = 0u;
                *((_OWORD *)v74 + 4) = 0u;
                *((_OWORD *)v74 + 5) = 0u;
                *((_OWORD *)v74 + 6) = 0u;
                *((_OWORD *)v74 + 7) = 0u;
                *((_OWORD *)v74 + 8) = 0u;
                *((_OWORD *)v74 + 9) = 0u;
                *((_OWORD *)v74 + 10) = 0u;
                *((_OWORD *)v74 + 11) = 0u;
                v74[185] = 1;
                __s1[0] = v74 + 192;
                sub_1003DBD8C(&v127, v147);
                unint64_t v69 = v128;
                sub_1003DBEF8((uint64_t)v147);
              }
              else
              {
                *(_OWORD *)(v128 + 160) = 0u;
                *(_OWORD *)(v68 + 176) = 0u;
                *(_OWORD *)(v68 + 128) = 0u;
                *(_OWORD *)(v68 + 144) = 0u;
                *(_OWORD *)(v68 + 96) = 0u;
                *(_OWORD *)(v68 + 112) = 0u;
                *(_OWORD *)(v68 + 64) = 0u;
                *(_OWORD *)(v68 + 80) = 0u;
                *(_OWORD *)(v68 + 32) = 0u;
                *(_OWORD *)(v68 + 48) = 0u;
                *(_OWORD *)unint64_t v68 = 0u;
                *(_OWORD *)(v68 + 16) = 0u;
                unint64_t v69 = v68 + 192;
                *(unsigned char *)(v68 + 185) = 1;
              }
              unint64_t v128 = v69;
              ctu::hex((uint64_t *)v147, v83, (const void *)0x10, v64);
              xpc_object_t v76 = (void **)(v69 - 184);
              if (*(char *)(v69 - 161) < 0) {
                operator delete(*v76);
              }
              long long v77 = *(_OWORD *)v147;
              *(void **)(v69 - 168) = __s1[0];
              *(_OWORD *)xpc_object_t v76 = v77;
              *(void *)(v69 - 192) = 0;
              std::string::operator=((std::string *)(v69 - 160), v46);
              *(_OWORD *)int v147 = 0u;
              *(_OWORD *)__s1 = 0u;
              sub_1003DA29C((uint64_t)v147, a1, v7);
              *(unsigned char *)(v69 - 135) = v147[0];
              *(unsigned char *)(v69 - 136) = BYTE1(v147[0]);
              std::string::operator=((std::string *)(v69 - 128), (const std::string *)&v147[1]);
              if (SHIBYTE(__s1[1]) < 0) {
                operator delete(v147[1]);
              }
            }
            if (!(_BYTE)v142) {
              goto LABEL_191;
            }
            if (SBYTE7(v141) < 0) {
              operator delete(v140[0]);
            }
            if (SHIBYTE(v139) < 0) {
              operator delete(v138[1]);
            }
            if (SHIBYTE(v138[0]) < 0) {
              operator delete(v137[0]);
            }
            if (SHIBYTE(v136) < 0) {
              operator delete(v135[1]);
            }
            if (SHIBYTE(v135[0]) < 0) {
              operator delete(v134[0]);
            }
            if (SBYTE7(v133) < 0) {
              operator delete(v132[0]);
            }
          }
          else
          {
            uint64_t v3 = a1;
            if (*((double *)v48 + 7) != 0.0)
            {
              sub_10023FB90((uint64_t)v107, (uint64_t)(v48 + 7));
              sub_1003DA754(a1, &v126, v46, (uint64_t)v107);
              if (v121 < 0) {
                operator delete(v120);
              }
              if (v119 < 0) {
                operator delete(v118);
              }
              if (v117 < 0) {
                operator delete(v116);
              }
              if (v115 < 0) {
                operator delete(v114);
              }
              if (v113 < 0) {
                operator delete(v112);
              }
              if (v111 < 0) {
                operator delete(v110);
              }
              if ((v109 & 0x80000000) == 0) {
                goto LABEL_191;
              }
              int v67 = v108;
              goto LABEL_190;
            }
            *(_OWORD *)long long __p = 0u;
            long long v131 = 0u;
            sub_1003DA29C((uint64_t)__p, a1, v7);
            *((unsigned char *)v48 + 113) = __p[0];
            *((unsigned char *)v48 + 112) = BYTE1(__p[0]);
            std::string::operator=((std::string *)v48 + 5, (const std::string *)&__p[1]);
          }
          if (SHIBYTE(v131) < 0)
          {
            int v67 = __p[1];
LABEL_190:
            operator delete(v67);
          }
LABEL_191:
          v7 += 216;
        }
        while (v7 != v88);
      }
      if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v126.__r_.__value_.__l.__data_);
      }
      uint64_t v4 = v82;
    }
    v4 += 88;
  }
  while (v4 != a3);
  uint64_t v78 = v127;
  uint64_t v79 = v128;
LABEL_198:
  sub_1003CFFC0(v3, v78, v79);
  __p[0] = &v127;
  sub_10023FDC8((void ***)__p);
}

void sub_1003D1428(_Unwind_Exception *a1)
{
  STACK[0x280] = (unint64_t)&STACK[0x268];
  sub_10023FDC8((void ***)&STACK[0x280]);
  _Unwind_Resume(a1);
}

void sub_1003D1554(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 760);
  uint64_t v2 = *(unsigned int **)(a1 + 768);
  if (v1 != v2)
  {
    int v4 = 0;
    do
    {
      unsigned int v5 = *v1;
      v1 += 42;
      v4 |= sub_1003CE02C(a1, v5);
    }
    while (v1 != v2);
    if (v4)
    {
      v6[0] = 0;
      sub_1003CF080(a1, v6);
      if (v6[0])
      {
        if (v8 < 0) {
          operator delete(__p);
        }
      }
    }
  }
}

void sub_1003D1608(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a10)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1003D162C(uint64_t a1, _OWORD *a2, const std::string **a3)
{
  unsigned int v5 = (uint64_t **)(a1 + 1072);
  uint64_t v6 = sub_1003DE478((uint64_t **)(a1 + 1072), (uint64_t)a2, a2);
  uint64_t v8 = *((void *)v6 + 6);
  for (uint64_t i = *((void *)v6 + 7); i != v8; sub_1000C643C(i))
    i -= 312;
  *((void *)v6 + 7) = v8;
  uint64_t v9 = *a3;
  uint64_t v10 = a3[1];
  if (*a3 != v10)
  {
    do
    {
      uint64_t v11 = (uint64_t *)sub_1003DE478(v5, (uint64_t)a2, a2);
      unint64_t v12 = v11[7];
      unint64_t v13 = v11[8];
      if (v12 >= v13)
      {
        uint64_t v15 = v11[6];
        uint64_t v16 = 0x6F96F96F96F96F97 * ((uint64_t)(v12 - v15) >> 3);
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) > 0xD20D20D20D20D2) {
          sub_10006A748();
        }
        unint64_t v18 = 0x6F96F96F96F96F97 * ((uint64_t)(v13 - v15) >> 3);
        if (2 * v18 > v17) {
          unint64_t v17 = 2 * v18;
        }
        if (v18 >= 0x69069069069069) {
          unint64_t v19 = 0xD20D20D20D20D2;
        }
        else {
          unint64_t v19 = v17;
        }
        void v22[4] = v11 + 8;
        if (v19) {
          unsigned __int8 v20 = (char *)sub_10030C27C((uint64_t)(v11 + 8), v19);
        }
        else {
          unsigned __int8 v20 = 0;
        }
        uint64_t v21 = &v20[312 * v16];
        v22[0] = v20;
        v22[1] = v21;
        void v22[3] = &v20[312 * v19];
        *((_OWORD *)v21 + 2) = 0u;
        *((_OWORD *)v21 + 3) = 0u;
        *((_OWORD *)v21 + 4) = 0u;
        *((_OWORD *)v21 + 5) = 0u;
        *((_OWORD *)v21 + 6) = 0u;
        *((_OWORD *)v21 + 7) = 0u;
        *((_OWORD *)v21 + 8) = 0u;
        *((_OWORD *)v21 + 9) = 0u;
        *((_OWORD *)v21 + 10) = 0u;
        *((_OWORD *)v21 + 11) = 0u;
        *((_OWORD *)v21 + 12) = 0u;
        *((_OWORD *)v21 + 13) = 0u;
        *((_OWORD *)v21 + 14) = 0u;
        *((_OWORD *)v21 + 15) = 0u;
        *((_OWORD *)v21 + 16) = 0u;
        *((_OWORD *)v21 + 17) = 0u;
        *((_OWORD *)v21 + 18) = 0u;
        *((void *)v21 + 38) = 0;
        *(_OWORD *)uint64_t v21 = 0u;
        *((_OWORD *)v21 + 1) = 0u;
        std::string v22[2] = v21 + 312;
        sub_10030F708(v11 + 6, v22);
        uint64_t v14 = v11[7];
        sub_10030F890((uint64_t)v22);
      }
      else
      {
        *(void *)(v12 + 304) = 0;
        *(_OWORD *)(v12 + 272) = 0u;
        *(_OWORD *)(v12 + 288) = 0u;
        *(_OWORD *)(v12 + 240) = 0u;
        *(_OWORD *)(v12 + 256) = 0u;
        *(_OWORD *)(v12 + 208) = 0u;
        *(_OWORD *)(v12 + 224) = 0u;
        *(_OWORD *)(v12 + 176) = 0u;
        *(_OWORD *)(v12 + 192) = 0u;
        *(_OWORD *)(v12 + 144) = 0u;
        *(_OWORD *)(v12 + 160) = 0u;
        *(_OWORD *)(v12 + 112) = 0u;
        *(_OWORD *)(v12 + 128) = 0u;
        *(_OWORD *)(v12 + 80) = 0u;
        *(_OWORD *)(v12 + 96) = 0u;
        *(_OWORD *)(v12 + 48) = 0u;
        *(_OWORD *)(v12 + 64) = 0u;
        *(_OWORD *)(v12 + 16) = 0u;
        *(_OWORD *)(v12 + 32) = 0u;
        *(_OWORD *)unint64_t v12 = 0u;
        uint64_t v14 = v12 + 312;
        v11[7] = v12 + 312;
      }
      v11[7] = v14;
      std::string::operator=((std::string *)(v14 - 240), v9 + 3);
      std::string::operator=((std::string *)(v14 - 264), v9 + 2);
      std::string::operator=((std::string *)(v14 - 288), v9 + 1);
      std::string::operator=((std::string *)(v14 - 312), v9);
      v9 += 13;
    }
    while (v9 != v10);
  }
}

void sub_1003D184C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10030F890((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1003D1860(uint64_t a1, _OWORD *a2, long long *a3)
{
  uint64_t v6 = (uint64_t **)(a1 + 1072);
  if ((void *)(a1 + 1080) != sub_1003DE594(a1 + 1072, (uint64_t)a2))
  {
    uint64_t v7 = sub_1003DE478(v6, (uint64_t)a2, a2);
    uint64_t v8 = *((void *)sub_1003DE478(v6, (uint64_t)a2, a2) + 6);
    uint64_t v9 = (long long *)*((void *)sub_1003DE478(v6, (uint64_t)a2, a2) + 7);
    uint64_t v12 = a1;
    if (*((char *)a3 + 23) < 0)
    {
      sub_10004FC84(&__p, *(void **)a3, *((void *)a3 + 1));
    }
    else
    {
      long long __p = *a3;
      uint64_t v14 = *((void *)a3 + 2);
    }
    if ((long long *)v8 != v9)
    {
      while ((sub_1003DB5A4(&v12, v8) & 1) == 0)
      {
        v8 += 312;
        if ((long long *)v8 == v9)
        {
          uint64_t v8 = (uint64_t)v9;
          goto LABEL_15;
        }
      }
      if ((long long *)v8 != v9)
      {
        for (uint64_t i = (long long *)(v8 + 312); i != v9; uint64_t i = (long long *)((char *)i + 312))
        {
          if ((sub_1003DB5A4(&v12, (uint64_t)i) & 1) == 0)
          {
            sub_10031016C(v8, i);
            v8 += 312;
          }
        }
      }
    }
LABEL_15:
    uint64_t v11 = sub_1003DE478(v6, (uint64_t)a2, a2);
    sub_100301910((uint64_t)(v7 + 48), v8, *((long long **)v11 + 7));
    if (SHIBYTE(v14) < 0) {
      operator delete((void *)__p);
    }
  }
}

void sub_1003D19C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1003D19EC@<X0>(void *result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (!result[136] || (result = sub_1003DE594((uint64_t)(result + 134), a2), uint64_t v4 = result[6], v5 = result[7], v4 == v5))
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    return sub_10030C19C(a3, v4, v5, 0x6F96F96F96F96F97 * ((v5 - v4) >> 3));
  }
  return result;
}

uint64_t sub_1003D1A74(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  while (v4 != v5)
  {
    uint64_t v6 = *(void *)(a1 + 520);
    uint64_t v7 = *(void *)(a1 + 528);
    if (v6 == v7)
    {
      uint64_t v8 = *(void *)(a1 + 520);
    }
    else
    {
      while ((cellplan::RemoteProvisioningDeviceInfo::operator==() & 1) == 0)
      {
        v6 += 216;
        if (v6 == v7)
        {
          uint64_t v6 = v7;
          break;
        }
      }
      uint64_t v8 = v6;
      uint64_t v6 = *(void *)(a1 + 528);
    }
    if (v8 == v6) {
      sub_1003D09F0(a1, *(void *)(v4 + 176), *(void *)(v4 + 184));
    }
    v4 += 216;
  }
  uint64_t v9 = (void **)(a1 + 520);
  if ((uint64_t *)(a1 + 520) != a2)
  {
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    unint64_t v12 = 0x84BDA12F684BDA13 * ((v10 - v11) >> 3);
    uint64_t v13 = *(void *)(a1 + 536);
    uint64_t v14 = *(void *)(a1 + 520);
    if (0x84BDA12F684BDA13 * ((v13 - v14) >> 3) >= v12)
    {
      if (0x84BDA12F684BDA13 * ((*(void *)(a1 + 528) - v14) >> 3) >= v12)
      {
        uint64_t v23 = sub_1003DB870(v11, v10, *(void *)(a1 + 520));
        for (uint64_t i = *(void *)(a1 + 528); i != v23; uint64_t i = sub_1003DAC14(i - 216))
          ;
        goto LABEL_31;
      }
      uint64_t v24 = v11 + 8 * ((*(void *)(a1 + 528) - v14) >> 3);
      sub_1003DB870(v11, v24, *(void *)(a1 + 520));
      uint64_t v22 = sub_1003DB6B4(v24, v10, *(void *)(a1 + 528));
    }
    else
    {
      if (v14)
      {
        uint64_t v15 = *(void *)(a1 + 528);
        uint64_t v16 = *(void **)(a1 + 520);
        if (v15 != v14)
        {
          do
            uint64_t v15 = sub_1003DAC14(v15 - 216);
          while (v15 != v14);
          uint64_t v16 = *v9;
        }
        *(void *)(a1 + 528) = v14;
        operator delete(v16);
        uint64_t v13 = 0;
        long long *v9 = 0;
        *(void *)(a1 + 528) = 0;
        *(void *)(a1 + 536) = 0;
      }
      if (v12 > 0x12F684BDA12F684) {
        goto LABEL_104;
      }
      unint64_t v17 = 0x84BDA12F684BDA13 * (v13 >> 3);
      uint64_t v18 = 2 * v17;
      if (2 * v17 <= v12) {
        uint64_t v18 = 0x84BDA12F684BDA13 * ((v10 - v11) >> 3);
      }
      unint64_t v19 = v17 >= 0x97B425ED097B42 ? 0x12F684BDA12F684 : v18;
      if (v19 > 0x12F684BDA12F684) {
LABEL_104:
      }
        sub_10006A748();
      unsigned __int8 v20 = (char *)sub_1000C5FD0(a1 + 536, v19);
      *(void *)(a1 + 520) = v20;
      *(void *)(a1 + 528) = v20;
      *(void *)(a1 + 536) = &v20[216 * v21];
      uint64_t v22 = sub_1003DB6B4(v11, v10, (uint64_t)v20);
    }
    uint64_t v23 = v22;
LABEL_31:
    *(void *)(a1 + 528) = v23;
    goto LABEL_32;
  }
  uint64_t v23 = *(void *)(a1 + 528);
LABEL_32:
  size_t v25 = (const std::string *)*v9;
  memset(v52, 0, sizeof(v52));
  *(_OWORD *)int64_t v53 = 0u;
  long long v54 = 0u;
  *(_OWORD *)uint64_t v55 = 0u;
  long long v56 = 0u;
  *(_OWORD *)BOOL v57 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  *(void *)&long long v64 = 0;
  while (1)
  {
    if (v25 == (const std::string *)v23) {
      goto LABEL_40;
    }
    if (v25->__r_.__value_.__s.__data_[0]) {
      break;
    }
    v25 += 9;
  }
  if (v25 == (const std::string *)v23)
  {
LABEL_40:
    char v27 = 0;
    goto LABEL_41;
  }
  v52[0] = v25->__r_.__value_.__s.__data_[0];
  cellplan::RemoteDeviceIdentifiers::operator=();
  std::string::operator=((std::string *)__p, v25 + 6);
  *((void *)&v61 + 1) = v25[7].__r_.__value_.__l.__data_;
  if (v25 != (const std::string *)v52) {
    sub_1003DB294((uint64_t)&v62, v25[7].__r_.__value_.__l.__size_, v25[7].__r_.__value_.__r.__words[2], 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v25[7].__r_.__value_.__r.__words[2] - v25[7].__r_.__value_.__l.__size_) >> 3));
  }
  std::string::size_type size = v25[8].__r_.__value_.__l.__size_;
  LODWORD(v64) = v25[8].__r_.__value_.__r.__words[2];
  *((void *)&v63 + 1) = size;
  char v27 = v52[0];
LABEL_41:
  *(unsigned char *)(a1 + 544) = v27;
  cellplan::RemoteDeviceIdentifiers::operator=();
  uint64_t v28 = (void **)(a1 + 688);
  if (*(char *)(a1 + 711) < 0) {
    operator delete(*v28);
  }
  *(_OWORD *)uint64_t v28 = *(_OWORD *)__p;
  *(void *)(a1 + 704) = v61;
  BYTE7(v61) = 0;
  LOBYTE(__p[0]) = 0;
  *(void *)(a1 + 712) = *((void *)&v61 + 1);
  sub_1003DB434((void **)(a1 + 720));
  *(_OWORD *)(a1 + 720) = v62;
  *(void *)(a1 + 736) = v63;
  *(void *)&long long v63 = 0;
  long long v62 = 0uLL;
  *(void *)(a1 + 744) = *((void *)&v63 + 1);
  *(_DWORD *)(a1 + 752) = v64;
  __dst[0] = &v62;
  sub_1000C56F4((void ***)__dst);
  if (SBYTE7(v61) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v58) < 0) {
    operator delete(v57[1]);
  }
  if (LOBYTE(v55[0]))
  {
    if (SHIBYTE(v56) < 0) {
      operator delete(v55[1]);
    }
    LOBYTE(v55[0]) = 0;
  }
  if (LOBYTE(v53[0]))
  {
    if (SHIBYTE(v54) < 0) {
      operator delete(v53[1]);
    }
    LOBYTE(v53[0]) = 0;
  }
  if ((v52[31] & 0x80000000) != 0) {
    operator delete(*(void **)&v52[8]);
  }
  uint64_t v29 = *(void *)(a1 + 720);
  if (v29 != *(void *)(a1 + 728) && *(unsigned char *)(v29 + 80))
  {
    memset(v52, 0, 24);
    uint64_t v30 = *(void *)(v29 + 56);
    uint64_t v31 = *(void *)(v29 + 64);
    if (v30 == v31)
    {
LABEL_70:
      uint64_t v34 = v52[23];
      if (v52[23] < 0) {
        uint64_t v34 = *(void *)&v52[8];
      }
      if (v34) {
        sub_1003D2420(a1, (uint64_t)v52);
      }
    }
    else
    {
      while (!*(unsigned char *)(v30 + 89))
      {
        unint64_t v32 = sub_100046F68(a1 + 1096, (void **)(v30 + 16));
        uint64_t v33 = v32;
        if ((void **)(a1 + 1104) != v32 && sub_1003D31E8(a1, (uint64_t)(v32 + 7), 0) && *((unsigned char *)v33 + 112) == 2)
        {
          if ((v52[23] & 0x80000000) != 0)
          {
            if (*(void *)&v52[8])
            {
              **(unsigned char **)int v52 = 0;
              *(void *)&v52[8] = 0;
              goto LABEL_70;
            }
          }
          else if (v52[23])
          {
            v52[0] = 0;
            v52[23] = 0;
            goto LABEL_70;
          }
          std::string::operator=((std::string *)v52, (const std::string *)(v30 + 16));
        }
        v30 += 216;
        if (v30 == v31) {
          goto LABEL_70;
        }
      }
    }
    if ((v52[23] & 0x80000000) != 0) {
      operator delete(*(void **)v52);
    }
  }
  if (*(unsigned char *)(a1 + 880))
  {
    uint64_t v49 = 0;
    memset(v48, 0, sizeof(v48));
    *(_OWORD *)std::string __dst = 0u;
    long long v47 = 0u;
    sub_1003D2230(__dst, a1);
    long long v63 = 0u;
    long long v64 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v59 = 0u;
    *(_OWORD *)long long __p = 0u;
    *(_OWORD *)BOOL v57 = 0u;
    long long v58 = 0u;
    *(_OWORD *)uint64_t v55 = 0u;
    long long v56 = 0u;
    *(_OWORD *)int64_t v53 = 0u;
    long long v54 = 0u;
    int v35 = (void *)(a1 + 888);
    memset(v52, 0, sizeof(v52));
    sGetProfileDetails();
    if (BYTE8(v64))
    {
      if (BYTE9(v56)) {
        *(unsigned char *)(a1 + 880) = 0;
      }
    }
    else
    {
      uint64_t v36 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        *(unsigned char *)(a1 + 880) = 0;
LABEL_83:
        *(void *)int v52 = v48;
        sub_1000C56F4((void ***)v52);
        if (SBYTE7(v47) < 0) {
          operator delete(__dst[0]);
        }
        goto LABEL_85;
      }
      if (*(char *)(a1 + 911) < 0) {
        int v35 = (void *)*v35;
      }
      *(_DWORD *)int buf = 136315138;
      long long v51 = v35;
      _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Vinyl does not have selecting ICCID - clearing (%s)", buf, 0xCu);
      int v40 = BYTE8(v64);
      *(unsigned char *)(a1 + 880) = 0;
      if (!v40) {
        goto LABEL_83;
      }
    }
    sub_1000C584C((uint64_t)v52);
    goto LABEL_83;
  }
LABEL_85:
  *(_OWORD *)uint64_t v55 = 0u;
  long long v56 = 0u;
  *(_OWORD *)int64_t v53 = 0u;
  long long v54 = 0u;
  memset(v52, 0, sizeof(v52));
  if (*(char *)(a1 + 711) < 0)
  {
    sub_10004FC84(v41, *(void **)(a1 + 688), *(void *)(a1 + 696));
  }
  else
  {
    *(_OWORD *)int v41 = *(_OWORD *)v28;
    uint64_t v42 = *(void *)(a1 + 704);
  }
  uint64_t v43 = *(void *)(a1 + 712);
  memset(v44, 0, 24);
  sub_100311ED8(v44, *(void *)(a1 + 720), *(void *)(a1 + 728), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a1 + 728) - *(void *)(a1 + 720)) >> 3));
  v44[3] = *(void *)(a1 + 744);
  int v45 = *(_DWORD *)(a1 + 752);
  sub_1003CBB9C((uint64_t)v52, (os_log_t *)(a1 + 40), 1, (uint64_t)v41);
  __dst[0] = v44;
  sub_1000C56F4((void ***)__dst);
  if (SHIBYTE(v42) < 0) {
    operator delete(v41[0]);
  }
  if (BYTE8(v56))
  {
    uint64_t v37 = v52[23];
    if (v52[23] < 0) {
      uint64_t v37 = *(void *)&v52[8];
    }
    if (v37) {
      sub_1003D2420(a1, (uint64_t)v52);
    }
  }
  return sub_1003DB934((uint64_t)v52);
}

void sub_1003D219C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1003D2230(unsigned char *__dst, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 544))
  {
    if (*(char *)(a2 + 711) < 0)
    {
      sub_10004FC84(__dst, *(void **)(a2 + 688), *(void *)(a2 + 696));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)(a2 + 688);
      *((void *)__dst + 2) = *(void *)(a2 + 704);
    }
    uint64_t v4 = *(void *)(a2 + 712);
    *((void *)__dst + 4) = 0;
    *((void *)__dst + 3) = v4;
    *((void *)__dst + 5) = 0;
    *((void *)__dst + 6) = 0;
    BOOL result = sub_100311ED8((void *)__dst + 4, *(void *)(a2 + 720), *(void *)(a2 + 728), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a2 + 728) - *(void *)(a2 + 720)) >> 3));
    *((void *)__dst + 7) = *(void *)(a2 + 744);
    int v6 = *(_DWORD *)(a2 + 752);
  }
  else
  {
    if (*(char *)(a2 + 471) < 0)
    {
      sub_10004FC84(__dst, *(void **)(a2 + 448), *(void *)(a2 + 456));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)(a2 + 448);
      *((void *)__dst + 2) = *(void *)(a2 + 464);
    }
    *((void *)__dst + 4) = 0;
    uint64_t v7 = *(void *)(a2 + 480);
    *((void *)__dst + 3) = *(void *)(a2 + 472);
    *((void *)__dst + 5) = 0;
    *((void *)__dst + 6) = 0;
    BOOL result = sub_100311ED8((void *)__dst + 4, v7, *(void *)(a2 + 488), 0x2E8BA2E8BA2E8BA3 * ((*(void *)(a2 + 488) - v7) >> 3));
    *((void *)__dst + 7) = *(void *)(a2 + 504);
    int v6 = *(_DWORD *)(a2 + 512);
  }
  *((_DWORD *)__dst + 16) = v6;
  return result;
}

void sub_1003D234C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1003D236C(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    void __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  uint64_t v5 = *((void *)a2 + 3);
  __dst[4] = 0;
  void __dst[3] = v5;
  __dst[5] = 0;
  __dst[6] = 0;
  sub_100311ED8(__dst + 4, *((void *)a2 + 4), *((void *)a2 + 5), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((void *)a2 + 5) - *((void *)a2 + 4)) >> 3));
  uint64_t v6 = *((void *)a2 + 7);
  *((_DWORD *)__dst + 16) = *((_DWORD *)a2 + 16);
  __dst[7] = v6;
  return __dst;
}

void sub_1003D2404(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1003D2420(uint64_t a1, uint64_t a2)
{
  long long v4 = sub_100046F68(a1 + 1096, (void **)a2);
  if ((void **)(a1 + 1104) == v4)
  {
    unint64_t v12 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v13 = (void *)a2;
    }
    else {
      uint64_t v13 = *(void **)a2;
    }
    LODWORD(buf[0]) = 136315138;
    *(void *)((char *)buf + 4) = v13;
    uint64_t v9 = "No details for (%s), failing selection";
    uint64_t v10 = v12;
    uint32_t v11 = 12;
    goto LABEL_14;
  }
  uint64_t v5 = v4;
  if (*((unsigned char *)v4 + 112) == 5 || *((unsigned char *)v4 + 113) == 1)
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v8 = (void *)a2;
    }
    else {
      uint64_t v8 = *(void **)a2;
    }
    LODWORD(buf[0]) = 136315650;
    *(void *)((char *)buf + 4) = v8;
    WORD6(buf[0]) = 2080;
    *(void *)((char *)buf + 14) = asString();
    WORD3(buf[1]) = 2080;
    *((void *)&buf[1] + 1) = asString();
    uint64_t v9 = "(%s) not selectable: %s - %s";
    uint64_t v10 = v6;
    uint32_t v11 = 32;
LABEL_14:
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v9, (uint8_t *)buf, v11);
    return 0;
  }
  cellplan::findProfile();
  memset(__dst, 0, sizeof(__dst));
  memset(buf, 0, sizeof(buf));
  ctu::parse_hex();
  if (*((void *)&buf[0] + 1) != *(void *)&buf[0]) {
    memmove(__dst, *(const void **)&buf[0], *((void *)&buf[0] + 1) - *(void *)&buf[0]);
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 64);
  if (v14)
  {
    uint64_t v15 = std::__shared_weak_count::lock(v14);
    if (v15)
    {
      uint64_t v16 = v15;
      uint64_t v17 = *(void *)(a1 + 56);
      if (v17)
      {
        uint64_t v18 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a2 + 23) >= 0) {
            unint64_t v19 = (void *)a2;
          }
          else {
            unint64_t v19 = *(void **)a2;
          }
          *(_DWORD *)char v27 = 136315138;
          *(void *)&void v27[4] = v19;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Activating: (%s)", v27, 0xCu);
        }
        *(unsigned char *)(a1 + 880) = 1;
        *(void *)char v27 = __dst;
        unsigned __int8 v20 = (std::string *)sub_1003DE940((uint64_t **)(a1 + 1024), (uint64_t)__dst, (uint64_t)&unk_10144E20E, (_OWORD **)v27);
        std::string::operator=(v20 + 2, (const std::string *)a2);
        *(void *)uint64_t v22 = a1;
        *(_OWORD *)&uint8_t v22[8] = *(_OWORD *)__dst;
        if (*((char *)v5 + 111) < 0)
        {
          sub_10004FC84(&__p, v5[11], (unint64_t)v5[12]);
        }
        else
        {
          long long __p = *(_OWORD *)(v5 + 11);
          uint64_t v24 = v5[13];
        }
        uint64_t v26 = 0;
        uint64_t v21 = (char *)operator new(0x38uLL);
        *(void *)uint64_t v21 = off_1019C58B0;
        *((void *)v21 + 3) = *(void *)&v22[16];
        *(_OWORD *)(v21 + 8) = *(_OWORD *)v22;
        *((void *)v21 + 6) = v24;
        *((_OWORD *)v21 + 2) = __p;
        long long __p = 0uLL;
        uint64_t v24 = 0;
        uint64_t v26 = v21;
        (*(void (**)(uint64_t, uint8_t *, uint64_t, void *))(*(void *)v17 + 80))(v17, __dst, a2, v25);
        sub_100060644(v25);
        if (SHIBYTE(v24) < 0) {
          operator delete((void *)__p);
        }
      }
      sub_10004D2C8(v16);
    }
  }
  if (*(void *)&buf[0])
  {
    *((void *)&buf[0] + 1) = *(void *)&buf[0];
    operator delete(*(void **)&buf[0]);
  }
  return 1;
}

void sub_1003D2834(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29)
{
  sub_100060644(&a20);
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v29);
  if (a28)
  {
    a29 = (uint64_t)a28;
    operator delete(a28);
  }
  _Unwind_Resume(a1);
}

void sub_1003D2888(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = a1 + 760;
  if ((uint64_t *)v2 != a2) {
    sub_1003DB990(v2, *a2, a2[1], 0xCF3CF3CF3CF3CF3DLL * ((a2[1] - *a2) >> 3));
  }
  uint64_t v3 = *(void *)(a1 + 760);
  uint64_t v4 = *(void *)(a1 + 768);
  if (v3 == v4) {
    goto LABEL_125;
  }
  uint64_t v5 = (uint64_t **)(a1 + 1048);
  uint64_t v6 = (uint64_t *)(a1 + 1056);
  uint64_t v7 = (void *)(a1 + 104);
  uint64_t v38 = *(void *)(a1 + 768);
  do
  {
    if (*(char *)(v3 + 95) < 0)
    {
      if (!*(void *)(v3 + 80))
      {
LABEL_10:
        sub_1003DE614((uint64_t **)(a1 + 1120), *(_DWORD *)v3);
        goto LABEL_40;
      }
    }
    else if (!*(unsigned char *)(v3 + 95))
    {
      goto LABEL_10;
    }
    if (subscriber::isPhySimDisabled())
    {
      sub_1003DE708((uint64_t)v5, (int *)v3);
      goto LABEL_39;
    }
    uint64_t v8 = *v5;
    if (*v5 == v6) {
      goto LABEL_38;
    }
    int v9 = *(_DWORD *)v3;
    while (1)
    {
      if (*((_DWORD *)v8 + 8) == v9) {
        goto LABEL_29;
      }
      uint64_t v10 = *((unsigned __int8 *)v8 + 63);
      if ((v10 & 0x80u) == 0) {
        uint64_t v11 = *((unsigned __int8 *)v8 + 63);
      }
      else {
        uint64_t v11 = v8[6];
      }
      uint64_t v12 = *(unsigned __int8 *)(v3 + 95);
      int v13 = (char)v12;
      if ((v12 & 0x80u) != 0) {
        uint64_t v12 = *(void *)(v3 + 80);
      }
      if (v11 != v12) {
        goto LABEL_29;
      }
      uint64_t v14 = (const void **)(v8 + 5);
      uint64_t v15 = v13 >= 0 ? (unsigned __int8 *)(v3 + 72) : *(unsigned __int8 **)(v3 + 72);
      if ((v10 & 0x80) != 0) {
        break;
      }
      if (!*((unsigned char *)v8 + 63)) {
        goto LABEL_36;
      }
      while (*(unsigned __int8 *)v14 == *v15)
      {
        uint64_t v14 = (const void **)((char *)v14 + 1);
        ++v15;
        if (!--v10) {
          goto LABEL_36;
        }
      }
LABEL_29:
      uint64_t v16 = (uint64_t *)v8[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          uint64_t v16 = (uint64_t *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v17 = (uint64_t *)v8[2];
          BOOL v18 = *v17 == (void)v8;
          uint64_t v8 = v17;
        }
        while (!v18);
      }
      uint64_t v8 = v17;
      if (v17 == v6) {
        goto LABEL_38;
      }
    }
    if (memcmp(*v14, v15, v8[6])) {
      goto LABEL_29;
    }
LABEL_36:
    if (v8 != v6) {
      sub_1003DE770(v5, (uint64_t)v8);
    }
LABEL_38:
    *(void *)&v68[0] = v3;
    unint64_t v19 = sub_10008CC40(v5, (int *)v3, (uint64_t)&unk_10144E20E, (_DWORD **)v68);
    std::string::operator=((std::string *)(v19 + 5), (const std::string *)(v3 + 72));
LABEL_39:
    if (!sub_1003DDE88(v7, (unsigned __int8 *)(v3 + 72)))
    {
      long long v75 = 0u;
      long long v76 = 0u;
      long long v73 = 0u;
      long long v74 = 0u;
      long long v71 = 0u;
      *(_OWORD *)unint64_t v72 = 0u;
      long long v69 = 0u;
      *(_OWORD *)long long __src = 0u;
      memset(v68, 0, sizeof(v68));
      (*(void (**)(_OWORD *__return_ptr))(**(void **)(a1 + 88) + 48))(v68);
      if (BYTE8(v76))
      {
        *(void *)int buf = v3 + 72;
        unsigned __int8 v20 = sub_1003DDF8C((uint64_t)v7, (unsigned __int8 *)(v3 + 72), (long long **)buf);
        sub_1003DC1E4((uint64_t)(v20 + 40), (uint64_t)&v69 + 8);
        sub_1003DC1E4((uint64_t)(v20 + 72), (uint64_t)&v71 + 8);
        if (v20 + 40 != (unsigned __int8 *)((char *)&v69 + 8))
        {
          sub_1003DAD3C((uint64_t)(v20 + 104), *((uint64_t *)&v73 + 1), v74, 0x8E38E38E38E38E39 * ((uint64_t)(v74 - *((void *)&v73 + 1)) >> 4));
          sub_1003DAFDC((uint64_t)(v20 + 128), v75, *((uint64_t *)&v75 + 1), 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*((void *)&v75 + 1) - v75) >> 3));
        }
        uint64_t v46 = 0;
        uint64_t v47 = 0;
        uint64_t v48 = 0;
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 88) + 96))(&v46);
        uint64_t v43 = 0;
        unint64_t v44 = 0;
        unint64_t v45 = 0;
        uint64_t v21 = *((void *)&v73 + 1);
        uint64_t v22 = v74;
        if (*((void *)&v73 + 1) != (void)v74)
        {
          while (1)
          {
            uint64_t v23 = v46;
            uint64_t v24 = v47;
            size_t v25 = (_OWORD *)(v21 + 80);
            if (*(char *)(v21 + 103) < 0)
            {
              sub_10004FC84(__p, *(void **)(v21 + 80), *(void *)(v21 + 88));
            }
            else
            {
              *(_OWORD *)long long __p = *v25;
              uint64_t v42 = *(void *)(v21 + 96);
            }
            char v26 = HIBYTE(v42);
            if (v23 != v24)
            {
              if (v42 >= 0) {
                char v27 = (void *)HIBYTE(v42);
              }
              else {
                char v27 = __p[1];
              }
              if (v42 >= 0) {
                uint64_t v28 = __p;
              }
              else {
                uint64_t v28 = (void **)__p[0];
              }
              do
              {
                uint64_t v29 = *(unsigned __int8 *)(v23 + 55);
                if ((v29 & 0x80u) == 0) {
                  uint64_t v30 = (void *)*(unsigned __int8 *)(v23 + 55);
                }
                else {
                  uint64_t v30 = *(void **)(v23 + 40);
                }
                if (v30 == v27)
                {
                  if ((v29 & 0x80) != 0)
                  {
                    if (!memcmp(*(const void **)(v23 + 32), v28, *(void *)(v23 + 40))) {
                      goto LABEL_69;
                    }
                  }
                  else
                  {
                    if (!*(unsigned char *)(v23 + 55)) {
                      goto LABEL_69;
                    }
                    uint64_t v31 = 0;
                    while (*(unsigned __int8 *)(v23 + v31 + 32) == *((unsigned __int8 *)v28 + v31))
                    {
                      if (v29 == ++v31) {
                        goto LABEL_69;
                      }
                    }
                  }
                }
                v23 += 192;
              }
              while (v23 != v24);
              uint64_t v23 = v24;
            }
LABEL_69:
            if (v26 < 0) {
              operator delete(__p[0]);
            }
            if (v23 != v47) {
              goto LABEL_72;
            }
            unint64_t v32 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              if (*(char *)(v21 + 103) < 0) {
                size_t v25 = *(_OWORD **)v25;
              }
              *(_DWORD *)int buf = 136315138;
              *(void *)&uint8_t buf[4] = v25;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Missing ICCID in (%s) persistent details", buf, 0xCu);
            }
            uint64_t v67 = 0;
            *(_OWORD *)unint64_t v65 = 0u;
            long long v66 = 0u;
            *(_OWORD *)long long v63 = 0u;
            long long v64 = 0u;
            long long v61 = 0u;
            *(_OWORD *)long long v62 = 0u;
            *(_OWORD *)long long v59 = 0u;
            *(_OWORD *)uint64_t v60 = 0u;
            *(_OWORD *)BOOL v57 = 0u;
            long long v58 = 0u;
            *(_OWORD *)int buf = 0u;
            long long v56 = 0u;
            v52[0] = 0;
            if (BYTE8(v69))
            {
              if (SBYTE7(v71) < 0)
              {
                sub_10004FC84(&v53, __src[0], (unint64_t)__src[1]);
              }
              else
              {
                long long v53 = *(_OWORD *)__src;
                uint64_t v54 = v71;
              }
              v52[0] = 1;
            }
            v49[0] = 0;
            if (BYTE8(v71))
            {
              if (SBYTE7(v73) < 0)
              {
                sub_10004FC84(&v50, v72[0], (unint64_t)v72[1]);
              }
              else
              {
                long long v50 = *(_OWORD *)v72;
                uint64_t v51 = v73;
              }
              v49[0] = 1;
            }
            sub_100CCDA64((ctu *)v21, (const std::string *)(v3 + 72), (unint64_t)v52, (uint64_t)v49, (uint64_t)buf);
            if (v49[0])
            {
              if (SHIBYTE(v51) < 0) {
                operator delete((void *)v50);
              }
              v49[0] = 0;
            }
            if (v52[0])
            {
              if (SHIBYTE(v54) < 0) {
                operator delete((void *)v53);
              }
              v52[0] = 0;
            }
            if ((_BYTE)v67) {
              break;
            }
            int v35 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)int v40 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Could not decode details", v40, 2u);
              goto LABEL_103;
            }
LABEL_72:
            v21 += 144;
            if (v21 == v22)
            {
              if (v43 != v44)
              {
                (*(void (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 88) + 112))(*(void *)(a1 + 88), &v43, 1);
                sub_1003CFFC0(a1, v43, v44);
              }
              goto LABEL_120;
            }
          }
          unint64_t v33 = v44;
          if (v44 >= v45)
          {
            uint64_t v34 = sub_1003DBC84(&v43, (uint64_t)buf);
          }
          else
          {
            sub_10023FB90(v44, (uint64_t)buf);
            uint64_t v34 = v33 + 192;
          }
          unint64_t v44 = v34;
LABEL_103:
          if ((_BYTE)v67)
          {
            if (SBYTE7(v66) < 0) {
              operator delete(v65[0]);
            }
            if (SHIBYTE(v64) < 0) {
              operator delete(v63[1]);
            }
            if (SHIBYTE(v63[0]) < 0) {
              operator delete(v62[0]);
            }
            if (SHIBYTE(v61) < 0) {
              operator delete(v60[1]);
            }
            if (SHIBYTE(v60[0]) < 0) {
              operator delete(v59[0]);
            }
            if (SBYTE7(v58) < 0) {
              operator delete(v57[0]);
            }
            if (SHIBYTE(v56) < 0) {
              operator delete(*(void **)&buf[8]);
            }
          }
          goto LABEL_72;
        }
LABEL_120:
        *(void *)int buf = &v43;
        sub_10023FDC8((void ***)buf);
        *(void *)int buf = &v46;
        sub_10023FDC8((void ***)buf);
        uint64_t v5 = (uint64_t **)(a1 + 1048);
        uint64_t v4 = v38;
        uint64_t v7 = (void *)(a1 + 104);
        uint64_t v6 = (uint64_t *)(a1 + 1056);
        if (BYTE8(v76)) {
          sub_10023F898((uint64_t)v68);
        }
      }
    }
LABEL_40:
    v3 += 168;
  }
  while (v3 != v4);
  uint64_t v36 = *(void *)(a1 + 760);
  uint64_t v37 = *(void *)(a1 + 768);
  while (v36 != v37)
  {
    if ((subscriber::isSimSettled() & 1) == 0) {
      return;
    }
    v36 += 168;
  }
LABEL_125:
  sub_1003D1554(a1);
}

void sub_1003D305C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  a45 = (uint64_t)&a31;
  sub_10023FDC8((void ***)&a45);
  a45 = (uint64_t)&a34;
  sub_10023FDC8((void ***)&a45);
  if (LOBYTE(STACK[0x2D8])) {
    sub_10023F898((uint64_t)&a71);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1003D3120(uint64_t result, _DWORD *a2)
{
  *(_DWORD *)(result + 784) = *a2;
  return result;
}

uint64_t sub_1003D312C(uint64_t a1, uint64_t a2)
{
  std::string::operator=((std::string *)a1, (const std::string *)a2);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  std::string::operator=((std::string *)(a1 + 32), (const std::string *)(a2 + 32));
  std::string::operator=((std::string *)(a1 + 56), (const std::string *)(a2 + 56));
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  return a1;
}

uint64_t sub_1003D3180(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_1003D31D4(uint64_t result, char a2)
{
  uint64_t v2 = *(void *)(result + 32);
  *(unsigned char *)(v2 + 416) = a2 ^ 1;
  *(unsigned char *)(v2 + 880) = 0;
  return result;
}

BOOL sub_1003D31E8(uint64_t a1, uint64_t a2, int a3)
{
  if (*(unsigned char *)(a2 + 56) == 5) {
    return 0;
  }
  int v5 = *(unsigned __int8 *)(a2 + 57);
  if (*(unsigned char *)(a1 + 544))
  {
    if (v5 == 1) {
      return 0;
    }
    BOOL v6 = sub_10004D710();
    BOOL v7 = 1;
    if (v6)
    {
      LOBYTE(__dst[0]) = 1;
      uint64_t v8 = sub_100365D74();
      sub_100058DB0(__p, "EnablePlanSelection");
      sub_1002260B0(v8, __p, (BOOL *)__dst);
      if (SHIBYTE(v68) < 0) {
        operator delete(__p[0]);
      }
      int v9 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        if (LOBYTE(__dst[0])) {
          uint64_t v10 = "Enabled";
        }
        else {
          uint64_t v10 = "Disabled";
        }
        LODWORD(__p[0]) = 136315138;
        *(void **)((char *)__p + 4) = (void *)v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Auto Selection is %s.", (uint8_t *)__p, 0xCu);
      }
      BOOL v7 = LOBYTE(__dst[0]) != 0;
    }
    BOOL result = 1;
    if (v7 && *(unsigned __int8 *)(a2 + 56) <= 1u)
    {
      uint64_t v12 = *(unsigned int **)(a1 + 760);
      int v13 = *(unsigned int **)(a1 + 768);
      if (v12 != v13)
      {
        BOOL v57 = *(unsigned int **)(a1 + 768);
        while (1)
        {
          uint64_t v14 = *v12;
          (*(void (**)(void **__return_ptr))(**(void **)(a1 + 72) + 640))(__p);
          int v15 = (*(uint64_t (**)(void *, uint64_t))(*(void *)__p[0] + 8))(__p[0], v14);
          if (__p[1]) {
            sub_10004D2C8((std::__shared_weak_count *)__p[1]);
          }
          if (v15)
          {
            uint64_t v62 = 0;
            uint64_t v63 = 0;
            uint64_t v64 = 0;
            (*(void (**)(void **__return_ptr))(**(void **)(a1 + 72) + 640))(__p);
            (*(void (**)(uint64_t *__return_ptr))(*(void *)__p[0] + 32))(&v62);
            if (__p[1]) {
              sub_10004D2C8((std::__shared_weak_count *)__p[1]);
            }
            uint64_t v16 = v62;
            uint64_t v17 = v63;
            if (*(char *)(a2 + 55) < 0)
            {
              sub_10004FC84(__dst, *(void **)(a2 + 32), *(void *)(a2 + 40));
            }
            else
            {
              *(_OWORD *)std::string __dst = *(_OWORD *)(a2 + 32);
              uint64_t v66 = *(void *)(a2 + 48);
            }
            if (v16 == v17)
            {
              int v27 = 0;
            }
            else
            {
              uint64_t v18 = v16 + 24;
              do
              {
                if (*(char *)(v18 - 1) < 0)
                {
                  sub_10004FC84(__p, *(void **)(v18 - 24), *(void *)(v18 - 16));
                }
                else
                {
                  long long v19 = *(_OWORD *)(v18 - 24);
                  uint64_t v68 = *(void *)(v18 - 8);
                  *(_OWORD *)long long __p = v19;
                }
                int v20 = SHIBYTE(v68);
                uint64_t v21 = __p[0];
                if (v68 >= 0) {
                  unint64_t v22 = HIBYTE(v68);
                }
                else {
                  unint64_t v22 = (unint64_t)__p[1];
                }
                if (SHIBYTE(v66) < 0)
                {
                  if (v22 == -1) {
LABEL_141:
                  }
                    sub_1000C14D8();
                  uint64_t v24 = (void **)__dst[0];
                  if (__dst[1] >= (void *)v22) {
                    size_t v23 = v22;
                  }
                  else {
                    size_t v23 = (size_t)__dst[1];
                  }
                }
                else
                {
                  if (v22 == -1) {
                    goto LABEL_141;
                  }
                  if (HIBYTE(v66) >= v22) {
                    size_t v23 = v22;
                  }
                  else {
                    size_t v23 = HIBYTE(v66);
                  }
                  uint64_t v24 = __dst;
                }
                if (v68 >= 0) {
                  size_t v25 = __p;
                }
                else {
                  size_t v25 = (void **)__p[0];
                }
                BOOL v26 = !memcmp(v24, v25, v23) && v23 == v22;
                int v27 = v26;
                if (v20 < 0) {
                  operator delete(v21);
                }
                if (v18 == v17) {
                  char v28 = 1;
                }
                else {
                  char v28 = v27;
                }
                v18 += 24;
              }
              while ((v28 & 1) == 0);
              int v13 = v57;
            }
            if (SHIBYTE(v66) < 0) {
              operator delete(__dst[0]);
            }
            if (v27)
            {
              uint64_t v38 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
              {
                int v39 = (void *)(a2 + 32);
                if (*(char *)(a2 + 55) < 0) {
                  int v39 = *(void **)(a2 + 32);
                }
                LODWORD(__p[0]) = 136315138;
                *(void **)((char *)__p + 4) = v39;
                _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I marking linked plan(%s) not selectable", (uint8_t *)__p, 0xCu);
              }
              __p[0] = &v62;
              sub_100047F64((void ***)__p);
              return 0;
            }
            __p[0] = &v62;
            sub_100047F64((void ***)__p);
          }
          v12 += 42;
          if (v12 == v13) {
            return 1;
          }
        }
      }
    }
    return result;
  }
  if (v5 != 1 || *(unsigned char *)(a2 + 185) == 0) {
    return 0;
  }
  uint64_t v31 = *(unsigned __int8 *)(a2 + 87);
  int v32 = (char)v31;
  unint64_t v33 = *(void *)(a2 + 72);
  if ((v31 & 0x80u) != 0) {
    uint64_t v31 = *(void *)(a2 + 72);
  }
  if (!v31) {
    return 0;
  }
  uint64_t v34 = (void **)(a2 + 64);
  if (a3)
  {
    uint64_t v35 = *(void *)(a1 + 760);
    uint64_t v36 = *(void *)(a1 + 768);
    if (v32 < 0)
    {
      sub_10004FC84(&v60, *v34, v33);
    }
    else
    {
      long long v60 = *(_OWORD *)v34;
      uint64_t v61 = *(void *)(a2 + 80);
    }
    if (v35 == v36)
    {
LABEL_103:
      char v45 = 1;
      goto LABEL_104;
    }
    while (1)
    {
      uint64_t v40 = *(unsigned __int8 *)(v35 + 95);
      if ((v40 & 0x80u) == 0) {
        uint64_t v41 = *(unsigned __int8 *)(v35 + 95);
      }
      else {
        uint64_t v41 = *(void *)(v35 + 80);
      }
      uint64_t v42 = HIBYTE(v61);
      if (v61 < 0) {
        uint64_t v42 = *((void *)&v60 + 1);
      }
      if (v41 != v42) {
        goto LABEL_102;
      }
      if (v61 >= 0) {
        uint64_t v43 = &v60;
      }
      else {
        uint64_t v43 = (long long *)v60;
      }
      if ((v40 & 0x80) != 0)
      {
        if (memcmp(*(const void **)(v35 + 72), v43, *(void *)(v35 + 80))) {
          goto LABEL_102;
        }
      }
      else if (*(unsigned char *)(v35 + 95))
      {
        uint64_t v44 = 0;
        while (*(unsigned __int8 *)(v35 + v44 + 72) == *((unsigned __int8 *)v43 + v44))
        {
          if (v40 == ++v44) {
            goto LABEL_101;
          }
        }
        goto LABEL_102;
      }
LABEL_101:
      if (!subscriber::isSimAbsent())
      {
        char v45 = 0;
LABEL_104:
        if (SHIBYTE(v61) < 0)
        {
          uint64_t v46 = (void *)v60;
          goto LABEL_135;
        }
        return (v45 & 1) == 0;
      }
LABEL_102:
      v35 += 168;
      if (v35 == v36) {
        goto LABEL_103;
      }
    }
  }
  uint64_t v37 = *(void **)(a1 + 1048);
  if (v32 < 0)
  {
    sub_10004FC84(v58, *v34, v33);
  }
  else
  {
    *(_OWORD *)long long v58 = *(_OWORD *)v34;
    uint64_t v59 = *(void *)(a2 + 80);
  }
  uint64_t v47 = (void *)(a1 + 1056);
  char v48 = HIBYTE(v59);
  if (v37 == (void *)(a1 + 1056))
  {
LABEL_131:
    char v45 = 1;
    goto LABEL_133;
  }
  if (v59 >= 0) {
    uint64_t v49 = (void *)HIBYTE(v59);
  }
  else {
    uint64_t v49 = v58[1];
  }
  if (v59 >= 0) {
    long long v50 = v58;
  }
  else {
    long long v50 = (void **)v58[0];
  }
  while (1)
  {
    uint64_t v51 = *((unsigned __int8 *)v37 + 63);
    if ((v51 & 0x80u) == 0) {
      int v52 = (void *)*((unsigned __int8 *)v37 + 63);
    }
    else {
      int v52 = (void *)v37[6];
    }
    if (v52 != v49) {
      goto LABEL_125;
    }
    long long v53 = (const void **)(v37 + 5);
    if ((v51 & 0x80) != 0) {
      break;
    }
    if (!*((unsigned char *)v37 + 63)) {
      goto LABEL_132;
    }
    uint64_t v54 = v50;
    while (*(unsigned __int8 *)v53 == *(unsigned __int8 *)v54)
    {
      long long v53 = (const void **)((char *)v53 + 1);
      uint64_t v54 = (void **)((char *)v54 + 1);
      if (!--v51) {
        goto LABEL_132;
      }
    }
LABEL_125:
    uint64_t v55 = (void *)v37[1];
    if (v55)
    {
      do
      {
        long long v56 = v55;
        uint64_t v55 = (void *)*v55;
      }
      while (v55);
    }
    else
    {
      do
      {
        long long v56 = (void *)v37[2];
        BOOL v26 = *v56 == (void)v37;
        uint64_t v37 = v56;
      }
      while (!v26);
    }
    uint64_t v37 = v56;
    if (v56 == v47) {
      goto LABEL_131;
    }
  }
  if (memcmp(*v53, v50, v37[6])) {
    goto LABEL_125;
  }
LABEL_132:
  char v45 = 0;
LABEL_133:
  if (v48 < 0)
  {
    uint64_t v46 = v58[0];
LABEL_135:
    operator delete(v46);
  }
  return (v45 & 1) == 0;
}