void sub_10045647C(void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;
  uint64_t vars8;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 280;
        sub_100456500(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100456500(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 272))
  {
    v3 = (void **)(a1 + 248);
    sub_100155494(&v3);
  }
  if (*(unsigned char *)(a1 + 240) && *(char *)(a1 + 239) < 0) {
    operator delete(*(void **)(a1 + 216));
  }
  if (*(unsigned char *)(a1 + 208) && *(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  return sub_1004563E8(a1);
}

uint64_t sub_100456578(uint64_t a1)
{
  (*(void (**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(v3);
  sub_100456604(*(void *)(a1 + 32), (uint64_t)v3);
  return sub_100455FA0((uint64_t)v3);
}

void sub_1004565F8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100456604(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 760) == *(unsigned __int8 *)(a2 + 760))
  {
    if (!*(unsigned char *)(a1 + 760)) {
      return;
    }
    v4 = (long long *)(a2 + 8);
    *(_DWORD *)a1 = *(_DWORD *)a2;
    v5 = (void **)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v5);
    }
    long long v6 = *v4;
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)v5 = v6;
    *(unsigned char *)(a2 + 31) = 0;
    *(unsigned char *)(a2 + 8) = 0;
    v7 = (void **)(a1 + 32);
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*v7);
    }
    long long v8 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)v7 = v8;
    *(unsigned char *)(a2 + 55) = 0;
    *(unsigned char *)(a2 + 32) = 0;
    *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
    sub_100179A54(a1 + 64, (__n128 *)(a2 + 64));
    v9 = (void **)(a1 + 96);
    if (*(char *)(a1 + 119) < 0) {
      operator delete(*v9);
    }
    long long v10 = *(_OWORD *)(a2 + 96);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    *(_OWORD *)v9 = v10;
    *(unsigned char *)(a2 + 119) = 0;
    *(unsigned char *)(a2 + 96) = 0;
    v11 = (void **)(a1 + 120);
    if (*(char *)(a1 + 143) < 0) {
      operator delete(*v11);
    }
    long long v12 = *(_OWORD *)(a2 + 120);
    *(void *)(a1 + 136) = *(void *)(a2 + 136);
    *(_OWORD *)v11 = v12;
    *(unsigned char *)(a2 + 143) = 0;
    *(unsigned char *)(a2 + 120) = 0;
    uint64_t v13 = *(unsigned int *)(a1 + 752);
    uint64_t v14 = *(unsigned int *)(a2 + 752);
    if (v13 == -1)
    {
      if (v14 == -1) {
        return;
      }
    }
    else if (v14 == -1)
    {
      ((void (*)(void ***, uint64_t))off_1019CD400[v13])(&v15, a1 + 152);
      *(_DWORD *)(a1 + 752) = -1;
      return;
    }
    v15 = (void **)(a1 + 152);
    ((void (*)(void ***))off_1019CD468[v14])(&v15);
  }
  else if (*(unsigned char *)(a1 + 760))
  {
    sub_100456034(a1 + 152);
    if (*(char *)(a1 + 143) < 0) {
      operator delete(*(void **)(a1 + 120));
    }
    if (*(char *)(a1 + 119) < 0) {
      operator delete(*(void **)(a1 + 96));
    }
    if (*(unsigned char *)(a1 + 88))
    {
      v15 = (void **)(a1 + 64);
      sub_100047F64(&v15);
    }
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
    *(unsigned char *)(a1 + 760) = 0;
  }
  else
  {
    sub_100458A3C(a1, a2);
    *(unsigned char *)(a1 + 760) = 1;
  }
}

double sub_100456814(__n128 **a1, uint64_t a2, uint64_t a3)
{
  v4 = *a1;
  if (v4[37].n128_u32[2])
  {
    sub_100456F40(v4, a3);
  }
  else
  {
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    long long v7 = *(_OWORD *)a3;
    *(void *)(a2 + 16) = *(void *)(a3 + 16);
    *(_OWORD *)a2 = v7;
    *(unsigned char *)(a3 + 23) = 0;
    *(unsigned char *)a3 = 0;
    sub_100456D8C(a2 + 24, (__n128 *)(a3 + 24));
    *(void *)&double result = sub_100456E9C(a2 + 56, (__n128 *)(a3 + 56)).n128_u64[0];
  }
  return result;
}

void sub_1004568A8(uint64_t *a1, uint64_t a2, uint64_t a3)
{
}

void sub_1004568B0(__n128 **a1, __n128 *a2, __n128 *a3)
{
  v4 = *a1;
  if (v4[37].n128_u32[2] == 2)
  {
    *a2 = *a3;
    sub_100179CB0((uint64_t)&a2[1], a3 + 1);
    sub_100456D8C((uint64_t)&a2[3], a3 + 3);
    sub_100456E9C((uint64_t)&a2[5], a3 + 5);
  }
  else
  {
    sub_1004577C0(v4, a3);
  }
}

void sub_100456938(uint64_t *a1, uint64_t a2, uint64_t a3)
{
}

void sub_100456940(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(v4 + 600) == 4)
  {
    sub_100457B6C(a2, a3);
    sub_100456D8C(a2 + 248, (__n128 *)(a3 + 248));
    sub_100456E9C(a2 + 280, (__n128 *)(a3 + 280));
  }
  else
  {
    sub_100457E3C(v4, a3);
  }
}

void sub_1004569BC(uint64_t *a1, uint64_t a2, uint64_t a3)
{
}

double sub_1004569C4(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(v4 + 600) == 6)
  {
    *(_OWORD *)a2 = *(_OWORD *)a3;
    sub_100179CB0(a2 + 16, (__n128 *)(a3 + 16));
    long long v6 = (void **)(a2 + 48);
    if (*(unsigned __int8 *)(a2 + 224) == *(unsigned __int8 *)(a3 + 224))
    {
      if (*(unsigned char *)(a2 + 224))
      {
        if (*(char *)(a2 + 71) < 0) {
          operator delete(*v6);
        }
        long long v7 = *(_OWORD *)(a3 + 48);
        *(void *)(a2 + 64) = *(void *)(a3 + 64);
        *(_OWORD *)long long v6 = v7;
        *(unsigned char *)(a3 + 71) = 0;
        *(unsigned char *)(a3 + 48) = 0;
        long long v8 = (void **)(a2 + 72);
        if (*(char *)(a2 + 95) < 0) {
          operator delete(*v8);
        }
        long long v9 = *(_OWORD *)(a3 + 72);
        *(void *)(a2 + 88) = *(void *)(a3 + 88);
        *(_OWORD *)long long v8 = v9;
        *(unsigned char *)(a3 + 95) = 0;
        *(unsigned char *)(a3 + 72) = 0;
        *(void *)(a2 + 96) = *(void *)(a3 + 96);
        sub_100179CB0(a2 + 104, (__n128 *)(a3 + 104));
        sub_100179CB0(a2 + 136, (__n128 *)(a3 + 136));
        long long v10 = *(_OWORD *)(a3 + 168);
        *(_DWORD *)(a2 + 184) = *(_DWORD *)(a3 + 184);
        *(_OWORD *)(a2 + 168) = v10;
        sub_100179CB0(a2 + 192, (__n128 *)(a3 + 192));
      }
    }
    else
    {
      uint64_t v12 = a2 + 48;
      if (*(unsigned char *)(a2 + 224))
      {
        sub_10045840C(v12);
      }
      else
      {
        sub_1004584A0(v12, (long long *)(a3 + 48));
        *(unsigned char *)(a2 + 224) = 1;
      }
    }
    uint64_t v13 = (void **)(a2 + 232);
    uint64_t v14 = (long long *)(a3 + 232);
    if (*(unsigned __int8 *)(a2 + 256) == *(unsigned __int8 *)(a3 + 256))
    {
      if (*(unsigned char *)(a2 + 256))
      {
        if (*(char *)(a2 + 255) < 0) {
          operator delete(*v13);
        }
        long long v15 = *v14;
        *(void *)(a2 + 248) = *(void *)(a3 + 248);
        *(_OWORD *)uint64_t v13 = v15;
        *(unsigned char *)(a3 + 255) = 0;
        *(unsigned char *)(a3 + 232) = 0;
      }
    }
    else if (*(unsigned char *)(a2 + 256))
    {
      if (*(char *)(a2 + 255) < 0) {
        operator delete(*v13);
      }
      *(unsigned char *)(a2 + 256) = 0;
    }
    else
    {
      long long v16 = *v14;
      *(void *)(a2 + 248) = *(void *)(a3 + 248);
      *(_OWORD *)uint64_t v13 = v16;
      *(void *)(a3 + 240) = 0;
      *(void *)(a3 + 248) = 0;
      *(void *)uint64_t v14 = 0;
      *(unsigned char *)(a2 + 256) = 1;
    }
    v17 = (void **)(a2 + 264);
    v18 = (long long *)(a3 + 264);
    if (*(unsigned __int8 *)(a2 + 288) == *(unsigned __int8 *)(a3 + 288))
    {
      if (*(unsigned char *)(a2 + 288))
      {
        if (*(char *)(a2 + 287) < 0) {
          operator delete(*v17);
        }
        long long v19 = *v18;
        *(void *)(a2 + 280) = *(void *)(a3 + 280);
        *(_OWORD *)v17 = v19;
        *(unsigned char *)(a3 + 287) = 0;
        *(unsigned char *)(a3 + 264) = 0;
      }
    }
    else if (*(unsigned char *)(a2 + 288))
    {
      if (*(char *)(a2 + 287) < 0) {
        operator delete(*v17);
      }
      *(unsigned char *)(a2 + 288) = 0;
    }
    else
    {
      long long v20 = *v18;
      *(void *)(a2 + 280) = *(void *)(a3 + 280);
      *(_OWORD *)v17 = v20;
      *(void *)(a3 + 272) = 0;
      *(void *)(a3 + 280) = 0;
      *(void *)v18 = 0;
      *(unsigned char *)(a2 + 288) = 1;
    }
    sub_100456D8C(a2 + 296, (__n128 *)(a3 + 296));
    *(void *)&double result = sub_100456D8C(a2 + 328, (__n128 *)(a3 + 328)).n128_u64[0];
  }
  else
  {
    sub_100458588(v4, a3);
  }
  return result;
}

void sub_100456C44(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(v4 + 600) == 7)
  {
    long long v6 = *(_OWORD *)a3;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 16);
    *(_OWORD *)a2 = v6;
    sub_100179CB0(a2 + 24, (__n128 *)(a3 + 24));
    sub_100458764((void **)(a2 + 56));
    *(_OWORD *)(a2 + 56) = *(_OWORD *)(a3 + 56);
    *(void *)(a2 + 72) = *(void *)(a3 + 72);
    *(void *)(a3 + 56) = 0;
    *(void *)(a3 + 64) = 0;
    *(void *)(a3 + 72) = 0;
    sub_100456D8C(a2 + 80, (__n128 *)(a3 + 80));
  }
  else
  {
    sub_1004587CC(v4, (long long *)a3);
  }
}

uint64_t sub_100456CEC(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 600);
  if (v5 == -1) {
    goto LABEL_7;
  }
  if (v5 != 8)
  {
    ((void (*)(char *, uint64_t))off_1019CD400[v5])(&v7, v4);
LABEL_7:
    *(_DWORD *)(v4 + 600) = -1;
    uint64_t result = sub_1004588E0(v4, a3);
    *(_DWORD *)(v4 + 600) = 8;
    return result;
  }

  return sub_1004570E8(a2, a3);
}

__n128 sub_100456D8C(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(unsigned char *)(a1 + 24))
    {
      sub_100456E30((void **)a1);
      __n128 result = *a2;
      *(__n128 *)a1 = *a2;
      *(void *)(a1 + 16) = a2[1].n128_u64[0];
      a2->n128_u64[0] = 0;
      a2->n128_u64[1] = 0;
      a2[1].n128_u64[0] = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v5 = (void **)a1;
    sub_100155494(&v5);
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    __n128 result = *a2;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

void sub_100456E30(void **a1)
{
  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        uint64_t v5 = v3 - 232;
        sub_10015551C((uint64_t)(v3 - 224));
        v3 = v5;
      }
      while (v5 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

__n128 sub_100456E9C(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(unsigned char *)(a1 + 24))
    {
      sub_1001FA6F0((void **)a1);
      __n128 result = *a2;
      *(__n128 *)a1 = *a2;
      *(void *)(a1 + 16) = a2[1].n128_u64[0];
      a2->n128_u64[0] = 0;
      a2->n128_u64[1] = 0;
      a2[1].n128_u64[0] = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v5 = (void **)a1;
    sub_100155410(&v5);
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    __n128 result = *a2;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

void sub_100456F40(__n128 *a1, uint64_t a2)
{
  uint64_t v4 = a1[37].n128_u32[2];
  if (v4 != -1) {
    ((void (*)(char *, __n128 *))off_1019CD400[v4])(&v5, a1);
  }
  a1[37].n128_u32[2] = -1;
  sub_100456FAC(a1, a2);
  a1[37].n128_u32[2] = 0;
}

__n128 sub_100456FAC(__n128 *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  a1[1].n128_u64[0] = *(void *)(a2 + 16);
  *a1 = result;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  a1[1].n128_u8[8] = 0;
  a1[3].n128_u8[0] = 0;
  if (*(unsigned char *)(a2 + 48))
  {
    a1[1].n128_u64[1] = 0;
    a1[2].n128_u64[0] = 0;
    a1[2].n128_u64[1] = 0;
    __n128 result = *(__n128 *)(a2 + 24);
    *(__n128 *)((char *)a1 + 24) = result;
    a1[2].n128_u64[1] = *(void *)(a2 + 40);
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    a1[3].n128_u8[0] = 1;
  }
  a1[3].n128_u8[8] = 0;
  a1[5].n128_u8[0] = 0;
  if (*(unsigned char *)(a2 + 80))
  {
    a1[3].n128_u64[1] = 0;
    a1[4].n128_u64[0] = 0;
    a1[4].n128_u64[1] = 0;
    __n128 result = *(__n128 *)(a2 + 56);
    *(__n128 *)((char *)a1 + 56) = result;
    a1[4].n128_u64[1] = *(void *)(a2 + 72);
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = 0;
    a1[5].n128_u8[0] = 1;
  }
  return result;
}

void sub_100457040(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 600) == 1)
  {
    sub_1004570E8(a2, a3);
    char v5 = (void **)(a2 + 320);
    if (*(char *)(a2 + 343) < 0) {
      operator delete(*v5);
    }
    long long v6 = *(_OWORD *)(a3 + 320);
    *(void *)(a2 + 336) = *(void *)(a3 + 336);
    *(_OWORD *)char v5 = v6;
    *(unsigned char *)(a3 + 343) = 0;
    *(unsigned char *)(a3 + 320) = 0;
    sub_100456E9C(a2 + 344, (__n128 *)(a3 + 344));
  }
  else
  {
    sub_100457534(a1, a3);
  }
}

uint64_t sub_1004570E8(uint64_t a1, uint64_t a2)
{
  sub_10005CBB4((uint64_t *)a1);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  sub_1002B2B70((uint64_t *)(a1 + 24));
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v4 = (void **)(a1 + 48);
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*v4);
  }
  long long v5 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)uint64_t v4 = v5;
  *(unsigned char *)(a2 + 71) = 0;
  *(unsigned char *)(a2 + 48) = 0;
  long long v6 = (void **)(a1 + 72);
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*v6);
  }
  long long v7 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)long long v6 = v7;
  *(unsigned char *)(a2 + 95) = 0;
  *(unsigned char *)(a2 + 72) = 0;
  sub_100457218(a1 + 96, (long long *)(a2 + 96));
  sub_100179CB0(a1 + 176, (__n128 *)(a2 + 176));
  sub_1004573B4(a1 + 208, (long long *)(a2 + 208));
  long long v8 = (void **)(a1 + 288);
  if (*(char *)(a1 + 311) < 0) {
    operator delete(*v8);
  }
  long long v9 = *(_OWORD *)(a2 + 288);
  *(void *)(a1 + 304) = *(void *)(a2 + 304);
  *(_OWORD *)long long v8 = v9;
  *(unsigned char *)(a2 + 311) = 0;
  *(unsigned char *)(a2 + 288) = 0;
  *(_DWORD *)(a1 + 312) = *(_DWORD *)(a2 + 312);
  return a1;
}

__n128 sub_100457218(uint64_t a1, long long *a2)
{
  if (*(unsigned __int8 *)(a1 + 72) == *((unsigned __int8 *)a2 + 72))
  {
    if (*(unsigned char *)(a1 + 72))
    {
      if (*(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
      long long v4 = *a2;
      *(void *)(a1 + 16) = *((void *)a2 + 2);
      *(_OWORD *)a1 = v4;
      *((unsigned char *)a2 + 23) = 0;
      *(unsigned char *)a2 = 0;
      long long v5 = (void **)(a1 + 24);
      if (*(char *)(a1 + 47) < 0) {
        operator delete(*v5);
      }
      long long v6 = *(long long *)((char *)a2 + 24);
      *(void *)(a1 + 40) = *((void *)a2 + 5);
      *(_OWORD *)long long v5 = v6;
      *((unsigned char *)a2 + 47) = 0;
      *((unsigned char *)a2 + 24) = 0;
      long long v7 = (void **)(a1 + 48);
      if (*(char *)(a1 + 71) < 0) {
        operator delete(*v7);
      }
      __n128 result = (__n128)a2[3];
      *(void *)(a1 + 64) = *((void *)a2 + 8);
      *(__n128 *)long long v7 = result;
      *((unsigned char *)a2 + 71) = 0;
      *((unsigned char *)a2 + 48) = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 72))
  {
    sub_100457358(a1);
  }
  else
  {
    long long v9 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v9;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v10 = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(a1 + 24) = v10;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    __n128 result = (__n128)a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *(__n128 *)(a1 + 48) = result;
    *((void *)a2 + 7) = 0;
    *((void *)a2 + 8) = 0;
    *((void *)a2 + 6) = 0;
    *(unsigned char *)(a1 + 72) = 1;
  }
  return result;
}

void sub_100457358(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(unsigned char *)(a1 + 72) = 0;
  }
}

__n128 sub_1004573B4(uint64_t a1, long long *a2)
{
  if (*(unsigned __int8 *)(a1 + 72) == *((unsigned __int8 *)a2 + 72))
  {
    if (*(unsigned char *)(a1 + 72))
    {
      if (*(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
      long long v4 = *a2;
      *(void *)(a1 + 16) = *((void *)a2 + 2);
      *(_OWORD *)a1 = v4;
      *((unsigned char *)a2 + 23) = 0;
      *(unsigned char *)a2 = 0;
      sub_10005C9A4(a1 + 24, (__n128 *)((char *)a2 + 24));
      long long v5 = (void **)(a1 + 48);
      if (*(char *)(a1 + 71) < 0) {
        operator delete(*v5);
      }
      __n128 result = (__n128)a2[3];
      *(void *)(a1 + 64) = *((void *)a2 + 8);
      *(__n128 *)long long v5 = result;
      *((unsigned char *)a2 + 71) = 0;
      *((unsigned char *)a2 + 48) = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 72))
  {
    sub_1004574D8(a1);
  }
  else
  {
    long long v7 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v7;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    *(_OWORD *)(a1 + 24) = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *((void *)a2 + 3) = 0;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    __n128 result = (__n128)a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *(__n128 *)(a1 + 48) = result;
    *((void *)a2 + 7) = 0;
    *((void *)a2 + 8) = 0;
    *((void *)a2 + 6) = 0;
    *(unsigned char *)(a1 + 72) = 1;
  }
  return result;
}

void sub_1004574D8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    v2 = *(void **)(a1 + 24);
    if (v2)
    {
      *(void *)(a1 + 32) = v2;
      operator delete(v2);
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(unsigned char *)(a1 + 72) = 0;
  }
}

uint64_t sub_100457534(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 600);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_1019CD400[v4])(&v6, a1);
  }
  *(_DWORD *)(a1 + 600) = -1;
  uint64_t result = sub_1004575A4(a1, a2);
  *(_DWORD *)(a1 + 600) = 1;
  return result;
}

uint64_t sub_1004575A4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  long long v4 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v4;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 48) = 0;
  long long v5 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v5;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 72) = 0;
  *(unsigned char *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 168) = 0;
  if (*(unsigned char *)(a2 + 168))
  {
    long long v6 = *(_OWORD *)(a2 + 96);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    *(_OWORD *)(a1 + 96) = v6;
    *(void *)(a2 + 104) = 0;
    *(void *)(a2 + 112) = 0;
    *(void *)(a2 + 96) = 0;
    long long v7 = *(_OWORD *)(a2 + 120);
    *(void *)(a1 + 136) = *(void *)(a2 + 136);
    *(_OWORD *)(a1 + 120) = v7;
    *(void *)(a2 + 128) = 0;
    *(void *)(a2 + 136) = 0;
    *(void *)(a2 + 120) = 0;
    long long v8 = *(_OWORD *)(a2 + 144);
    *(void *)(a1 + 160) = *(void *)(a2 + 160);
    *(_OWORD *)(a1 + 144) = v8;
    *(void *)(a2 + 152) = 0;
    *(void *)(a2 + 160) = 0;
    *(void *)(a2 + 144) = 0;
    *(unsigned char *)(a1 + 168) = 1;
  }
  *(unsigned char *)(a1 + 176) = 0;
  *(unsigned char *)(a1 + 200) = 0;
  if (*(unsigned char *)(a2 + 200))
  {
    long long v9 = *(_OWORD *)(a2 + 176);
    *(void *)(a1 + 192) = *(void *)(a2 + 192);
    *(_OWORD *)(a1 + 176) = v9;
    *(void *)(a2 + 184) = 0;
    *(void *)(a2 + 192) = 0;
    *(void *)(a2 + 176) = 0;
    *(unsigned char *)(a1 + 200) = 1;
  }
  sub_100457754((__n128 *)(a1 + 208), a2 + 208);
  long long v10 = *(_OWORD *)(a2 + 288);
  *(void *)(a1 + 304) = *(void *)(a2 + 304);
  *(_OWORD *)(a1 + 288) = v10;
  *(void *)(a2 + 288) = 0;
  *(void *)(a2 + 296) = 0;
  *(void *)(a2 + 304) = 0;
  *(_DWORD *)(a1 + 312) = *(_DWORD *)(a2 + 312);
  long long v11 = *(_OWORD *)(a2 + 320);
  *(void *)(a1 + 336) = *(void *)(a2 + 336);
  *(_OWORD *)(a1 + 320) = v11;
  *(void *)(a2 + 328) = 0;
  *(void *)(a2 + 336) = 0;
  *(void *)(a2 + 320) = 0;
  *(unsigned char *)(a1 + 344) = 0;
  *(unsigned char *)(a1 + 368) = 0;
  if (*(unsigned char *)(a2 + 368))
  {
    *(void *)(a1 + 344) = 0;
    *(void *)(a1 + 352) = 0;
    *(void *)(a1 + 360) = 0;
    uint64_t v12 = *(void *)(a2 + 352);
    *(void *)(a1 + 344) = *(void *)(a2 + 344);
    *(void *)(a1 + 352) = v12;
    *(void *)(a1 + 360) = *(void *)(a2 + 360);
    *(void *)(a2 + 344) = 0;
    *(void *)(a2 + 352) = 0;
    *(void *)(a2 + 360) = 0;
    *(unsigned char *)(a1 + 368) = 1;
  }
  return a1;
}

__n128 sub_100457754(__n128 *a1, uint64_t a2)
{
  a1->n128_u8[0] = 0;
  a1[4].n128_u8[8] = 0;
  if (*(unsigned char *)(a2 + 72))
  {
    __n128 v2 = *(__n128 *)a2;
    a1[1].n128_u64[0] = *(void *)(a2 + 16);
    *a1 = v2;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(void *)a2 = 0;
    a1[1].n128_u64[1] = 0;
    a1[2].n128_u64[0] = 0;
    a1[2].n128_u64[1] = 0;
    *(__n128 *)((char *)a1 + 24) = *(__n128 *)(a2 + 24);
    a1[2].n128_u64[1] = *(void *)(a2 + 40);
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    __n128 result = *(__n128 *)(a2 + 48);
    a1[4].n128_u64[0] = *(void *)(a2 + 64);
    a1[3] = result;
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 48) = 0;
    a1[4].n128_u8[8] = 1;
  }
  return result;
}

void sub_1004577C0(__n128 *a1, __n128 *a2)
{
  uint64_t v4 = a1[37].n128_u32[2];
  if (v4 != -1) {
    ((void (*)(char *, __n128 *))off_1019CD400[v4])(&v5, a1);
  }
  a1[37].n128_u32[2] = -1;
  sub_100457830(a1, a2);
  a1[37].n128_u32[2] = 2;
}

__n128 sub_100457830(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  a1[1].n128_u8[0] = 0;
  a1[2].n128_u8[8] = 0;
  if (a2[2].n128_u8[8])
  {
    __n128 result = a2[1];
    a1[2].n128_u64[0] = a2[2].n128_u64[0];
    a1[1] = result;
    a2[1].n128_u64[1] = 0;
    a2[2].n128_u64[0] = 0;
    a2[1].n128_u64[0] = 0;
    a1[2].n128_u8[8] = 1;
  }
  a1[3].n128_u8[0] = 0;
  a1[4].n128_u8[8] = 0;
  if (a2[4].n128_u8[8])
  {
    a1[3].n128_u64[0] = 0;
    a1[3].n128_u64[1] = 0;
    a1[4].n128_u64[0] = 0;
    __n128 result = a2[3];
    a1[3] = result;
    a1[4].n128_u64[0] = a2[4].n128_u64[0];
    a2[3].n128_u64[0] = 0;
    a2[3].n128_u64[1] = 0;
    a2[4].n128_u64[0] = 0;
    a1[4].n128_u8[8] = 1;
  }
  a1[5].n128_u8[0] = 0;
  a1[6].n128_u8[8] = 0;
  if (a2[6].n128_u8[8])
  {
    a1[5].n128_u64[0] = 0;
    a1[5].n128_u64[1] = 0;
    a1[6].n128_u64[0] = 0;
    __n128 result = a2[5];
    a1[5] = result;
    a1[6].n128_u64[0] = a2[6].n128_u64[0];
    a2[5].n128_u64[0] = 0;
    a2[5].n128_u64[1] = 0;
    a2[6].n128_u64[0] = 0;
    a1[6].n128_u8[8] = 1;
  }
  return result;
}

void sub_1004578E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 600) == 3)
  {
    sub_1004570E8(a2, a3);
    *(_OWORD *)(a2 + 320) = *(_OWORD *)(a3 + 320);
    sub_100456E9C(a2 + 336, (__n128 *)(a3 + 336));
  }
  else
  {
    sub_10045795C(a1, a3);
  }
}

uint64_t sub_10045795C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 600);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_1019CD400[v4])(&v6, a1);
  }
  *(_DWORD *)(a1 + 600) = -1;
  uint64_t result = sub_1004579CC(a1, a2);
  *(_DWORD *)(a1 + 600) = 3;
  return result;
}

uint64_t sub_1004579CC(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  long long v4 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v4;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 48) = 0;
  long long v5 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v5;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 72) = 0;
  *(unsigned char *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 168) = 0;
  if (*(unsigned char *)(a2 + 168))
  {
    long long v6 = *(_OWORD *)(a2 + 96);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    *(_OWORD *)(a1 + 96) = v6;
    *(void *)(a2 + 104) = 0;
    *(void *)(a2 + 112) = 0;
    *(void *)(a2 + 96) = 0;
    long long v7 = *(_OWORD *)(a2 + 120);
    *(void *)(a1 + 136) = *(void *)(a2 + 136);
    *(_OWORD *)(a1 + 120) = v7;
    *(void *)(a2 + 128) = 0;
    *(void *)(a2 + 136) = 0;
    *(void *)(a2 + 120) = 0;
    long long v8 = *(_OWORD *)(a2 + 144);
    *(void *)(a1 + 160) = *(void *)(a2 + 160);
    *(_OWORD *)(a1 + 144) = v8;
    *(void *)(a2 + 152) = 0;
    *(void *)(a2 + 160) = 0;
    *(void *)(a2 + 144) = 0;
    *(unsigned char *)(a1 + 168) = 1;
  }
  *(unsigned char *)(a1 + 176) = 0;
  *(unsigned char *)(a1 + 200) = 0;
  if (*(unsigned char *)(a2 + 200))
  {
    long long v9 = *(_OWORD *)(a2 + 176);
    *(void *)(a1 + 192) = *(void *)(a2 + 192);
    *(_OWORD *)(a1 + 176) = v9;
    *(void *)(a2 + 184) = 0;
    *(void *)(a2 + 192) = 0;
    *(void *)(a2 + 176) = 0;
    *(unsigned char *)(a1 + 200) = 1;
  }
  sub_100457754((__n128 *)(a1 + 208), a2 + 208);
  long long v10 = *(_OWORD *)(a2 + 288);
  *(void *)(a1 + 304) = *(void *)(a2 + 304);
  *(_OWORD *)(a1 + 288) = v10;
  *(void *)(a2 + 288) = 0;
  *(void *)(a2 + 296) = 0;
  *(void *)(a2 + 304) = 0;
  *(_DWORD *)(a1 + 312) = *(_DWORD *)(a2 + 312);
  *(_OWORD *)(a1 + 320) = *(_OWORD *)(a2 + 320);
  *(unsigned char *)(a1 + 336) = 0;
  *(unsigned char *)(a1 + 360) = 0;
  if (*(unsigned char *)(a2 + 360))
  {
    *(void *)(a1 + 336) = 0;
    *(void *)(a1 + 344) = 0;
    *(void *)(a1 + 352) = 0;
    *(_OWORD *)(a1 + 336) = *(_OWORD *)(a2 + 336);
    *(void *)(a1 + 352) = *(void *)(a2 + 352);
    *(void *)(a2 + 336) = 0;
    *(void *)(a2 + 344) = 0;
    *(void *)(a2 + 352) = 0;
    *(unsigned char *)(a1 + 360) = 1;
  }
  return a1;
}

uint64_t sub_100457B6C(uint64_t a1, uint64_t a2)
{
  sub_100457C88(a1, a2);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  long long v4 = (void **)(a1 + 96);
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*v4);
  }
  long long v5 = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(_OWORD *)long long v4 = v5;
  *(unsigned char *)(a2 + 119) = 0;
  *(unsigned char *)(a2 + 96) = 0;
  long long v6 = (void **)(a1 + 120);
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*v6);
  }
  long long v7 = *(_OWORD *)(a2 + 120);
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  *(_OWORD *)long long v6 = v7;
  *(unsigned char *)(a2 + 143) = 0;
  *(unsigned char *)(a2 + 120) = 0;
  long long v8 = (void **)(a1 + 144);
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*v8);
  }
  long long v9 = *(_OWORD *)(a2 + 144);
  *(void *)(a1 + 160) = *(void *)(a2 + 160);
  *(_OWORD *)long long v8 = v9;
  *(unsigned char *)(a2 + 167) = 0;
  *(unsigned char *)(a2 + 144) = 0;
  long long v10 = (void **)(a1 + 168);
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*v10);
  }
  long long v11 = *(_OWORD *)(a2 + 168);
  *(void *)(a1 + 184) = *(void *)(a2 + 184);
  *(_OWORD *)long long v10 = v11;
  *(unsigned char *)(a2 + 191) = 0;
  *(unsigned char *)(a2 + 168) = 0;
  long long v12 = *(_OWORD *)(a2 + 192);
  *(unsigned char *)(a1 + 208) = *(unsigned char *)(a2 + 208);
  *(_OWORD *)(a1 + 192) = v12;
  sub_100456E9C(a1 + 216, (__n128 *)(a2 + 216));
  return a1;
}

__n128 sub_100457C88(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 80) == *(unsigned __int8 *)(a2 + 80))
  {
    if (*(unsigned char *)(a1 + 80))
    {
      long long v4 = (long long *)(a2 + 8);
      *(void *)a1 = *(void *)a2;
      long long v5 = (void **)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        operator delete(*v5);
      }
      long long v6 = *v4;
      *(void *)(a1 + 24) = *(void *)(a2 + 24);
      *(_OWORD *)long long v5 = v6;
      *(unsigned char *)(a2 + 31) = 0;
      *(unsigned char *)(a2 + 8) = 0;
      long long v7 = (void **)(a1 + 32);
      if (*(char *)(a1 + 55) < 0) {
        operator delete(*v7);
      }
      long long v8 = *(_OWORD *)(a2 + 32);
      *(void *)(a1 + 48) = *(void *)(a2 + 48);
      *(_OWORD *)long long v7 = v8;
      *(unsigned char *)(a2 + 55) = 0;
      *(unsigned char *)(a2 + 32) = 0;
      long long v9 = (void **)(a1 + 56);
      if (*(char *)(a1 + 79) < 0) {
        operator delete(*v9);
      }
      __n128 result = *(__n128 *)(a2 + 56);
      *(void *)(a1 + 72) = *(void *)(a2 + 72);
      *(__n128 *)long long v9 = result;
      *(unsigned char *)(a2 + 79) = 0;
      *(unsigned char *)(a2 + 56) = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 80))
  {
    sub_100457DE0(a1);
  }
  else
  {
    *(void *)a1 = *(void *)a2;
    long long v11 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v11;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 8) = 0;
    long long v12 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v12;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 32) = 0;
    __n128 result = *(__n128 *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(__n128 *)(a1 + 56) = result;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = 0;
    *(void *)(a2 + 56) = 0;
    *(unsigned char *)(a1 + 80) = 1;
  }
  return result;
}

void sub_100457DE0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 80))
  {
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
    *(unsigned char *)(a1 + 80) = 0;
  }
}

uint64_t sub_100457E3C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 600);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_1019CD400[v4])(&v6, a1);
  }
  *(_DWORD *)(a1 + 600) = -1;
  uint64_t result = sub_100457EAC(a1, a2);
  *(_DWORD *)(a1 + 600) = 4;
  return result;
}

uint64_t sub_100457EAC(uint64_t result, uint64_t a2)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 80) = 0;
  if (*(unsigned char *)(a2 + 80))
  {
    *(void *)uint64_t result = *(void *)a2;
    long long v2 = *(_OWORD *)(a2 + 8);
    *(void *)(result + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(result + 8) = v2;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 8) = 0;
    long long v3 = *(_OWORD *)(a2 + 32);
    *(void *)(result + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(result + 32) = v3;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 32) = 0;
    long long v4 = *(_OWORD *)(a2 + 56);
    *(void *)(result + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(result + 56) = v4;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = 0;
    *(void *)(a2 + 56) = 0;
    *(unsigned char *)(result + 80) = 1;
  }
  *(void *)(result + 88) = *(void *)(a2 + 88);
  long long v5 = *(_OWORD *)(a2 + 96);
  *(void *)(result + 112) = *(void *)(a2 + 112);
  *(_OWORD *)(result + 96) = v5;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 96) = 0;
  long long v6 = *(_OWORD *)(a2 + 120);
  *(void *)(result + 136) = *(void *)(a2 + 136);
  *(_OWORD *)(result + 120) = v6;
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 120) = 0;
  long long v7 = *(_OWORD *)(a2 + 144);
  *(void *)(result + 160) = *(void *)(a2 + 160);
  *(_OWORD *)(result + 144) = v7;
  *(void *)(a2 + 152) = 0;
  *(void *)(a2 + 160) = 0;
  *(void *)(a2 + 144) = 0;
  long long v8 = *(_OWORD *)(a2 + 168);
  *(void *)(result + 184) = *(void *)(a2 + 184);
  *(_OWORD *)(result + 168) = v8;
  *(void *)(a2 + 168) = 0;
  *(void *)(a2 + 176) = 0;
  *(void *)(a2 + 184) = 0;
  long long v9 = *(_OWORD *)(a2 + 192);
  char v10 = *(unsigned char *)(a2 + 208);
  *(unsigned char *)(result + 216) = 0;
  *(unsigned char *)(result + 208) = v10;
  *(_OWORD *)(result + 192) = v9;
  *(unsigned char *)(result + 240) = 0;
  if (*(unsigned char *)(a2 + 240))
  {
    *(void *)(result + 216) = 0;
    *(void *)(result + 224) = 0;
    *(void *)(result + 232) = 0;
    *(_OWORD *)(result + 216) = *(_OWORD *)(a2 + 216);
    *(void *)(result + 232) = *(void *)(a2 + 232);
    *(void *)(a2 + 216) = 0;
    *(void *)(a2 + 224) = 0;
    *(void *)(a2 + 232) = 0;
    *(unsigned char *)(result + 240) = 1;
  }
  *(unsigned char *)(result + 248) = 0;
  *(unsigned char *)(result + 272) = 0;
  if (*(unsigned char *)(a2 + 272))
  {
    *(void *)(result + 248) = 0;
    *(void *)(result + 256) = 0;
    *(void *)(result + 264) = 0;
    *(_OWORD *)(result + 248) = *(_OWORD *)(a2 + 248);
    *(void *)(result + 264) = *(void *)(a2 + 264);
    *(void *)(a2 + 248) = 0;
    *(void *)(a2 + 256) = 0;
    *(void *)(a2 + 264) = 0;
    *(unsigned char *)(result + 272) = 1;
  }
  *(unsigned char *)(result + 280) = 0;
  *(unsigned char *)(result + 304) = 0;
  if (*(unsigned char *)(a2 + 304))
  {
    *(void *)(result + 280) = 0;
    *(void *)(result + 288) = 0;
    *(void *)(result + 296) = 0;
    uint64_t v11 = *(void *)(a2 + 288);
    *(void *)(result + 280) = *(void *)(a2 + 280);
    *(void *)(result + 288) = v11;
    *(void *)(result + 296) = *(void *)(a2 + 296);
    *(void *)(a2 + 280) = 0;
    *(void *)(a2 + 288) = 0;
    *(void *)(a2 + 296) = 0;
    *(unsigned char *)(result + 304) = 1;
  }
  return result;
}

void sub_100458044(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 600) == 5)
  {
    sub_1004570E8(a2, a3);
    sub_100457B6C(a2 + 320, a3 + 320);
    sub_100456E9C(a2 + 568, (__n128 *)(a3 + 568));
  }
  else
  {
    sub_1004580BC(a1, a3);
  }
}

uint64_t sub_1004580BC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 600);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_1019CD400[v4])(&v6, a1);
  }
  *(_DWORD *)(a1 + 600) = -1;
  uint64_t result = sub_10045812C(a1, a2);
  *(_DWORD *)(a1 + 600) = 5;
  return result;
}

uint64_t sub_10045812C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  long long v4 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v4;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 48) = 0;
  long long v5 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v5;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 72) = 0;
  *(unsigned char *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 168) = 0;
  if (*(unsigned char *)(a2 + 168))
  {
    long long v6 = *(_OWORD *)(a2 + 96);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    *(_OWORD *)(a1 + 96) = v6;
    *(void *)(a2 + 104) = 0;
    *(void *)(a2 + 112) = 0;
    *(void *)(a2 + 96) = 0;
    long long v7 = *(_OWORD *)(a2 + 120);
    *(void *)(a1 + 136) = *(void *)(a2 + 136);
    *(_OWORD *)(a1 + 120) = v7;
    *(void *)(a2 + 128) = 0;
    *(void *)(a2 + 136) = 0;
    *(void *)(a2 + 120) = 0;
    long long v8 = *(_OWORD *)(a2 + 144);
    *(void *)(a1 + 160) = *(void *)(a2 + 160);
    *(_OWORD *)(a1 + 144) = v8;
    *(void *)(a2 + 152) = 0;
    *(void *)(a2 + 160) = 0;
    *(void *)(a2 + 144) = 0;
    *(unsigned char *)(a1 + 168) = 1;
  }
  *(unsigned char *)(a1 + 176) = 0;
  *(unsigned char *)(a1 + 200) = 0;
  if (*(unsigned char *)(a2 + 200))
  {
    long long v9 = *(_OWORD *)(a2 + 176);
    *(void *)(a1 + 192) = *(void *)(a2 + 192);
    *(_OWORD *)(a1 + 176) = v9;
    *(void *)(a2 + 184) = 0;
    *(void *)(a2 + 192) = 0;
    *(void *)(a2 + 176) = 0;
    *(unsigned char *)(a1 + 200) = 1;
  }
  sub_100457754((__n128 *)(a1 + 208), a2 + 208);
  long long v10 = *(_OWORD *)(a2 + 288);
  *(void *)(a1 + 304) = *(void *)(a2 + 304);
  *(_OWORD *)(a1 + 288) = v10;
  *(void *)(a2 + 296) = 0;
  *(void *)(a2 + 304) = 0;
  *(void *)(a2 + 288) = 0;
  *(_DWORD *)(a1 + 312) = *(_DWORD *)(a2 + 312);
  *(unsigned char *)(a1 + 320) = 0;
  *(unsigned char *)(a1 + 400) = 0;
  if (*(unsigned char *)(a2 + 400))
  {
    *(void *)(a1 + 320) = *(void *)(a2 + 320);
    long long v11 = *(_OWORD *)(a2 + 328);
    *(void *)(a1 + 344) = *(void *)(a2 + 344);
    *(_OWORD *)(a1 + 328) = v11;
    *(void *)(a2 + 336) = 0;
    *(void *)(a2 + 344) = 0;
    *(void *)(a2 + 328) = 0;
    long long v12 = *(_OWORD *)(a2 + 352);
    *(void *)(a1 + 368) = *(void *)(a2 + 368);
    *(_OWORD *)(a1 + 352) = v12;
    *(void *)(a2 + 360) = 0;
    *(void *)(a2 + 368) = 0;
    *(void *)(a2 + 352) = 0;
    long long v13 = *(_OWORD *)(a2 + 376);
    *(void *)(a1 + 392) = *(void *)(a2 + 392);
    *(_OWORD *)(a1 + 376) = v13;
    *(void *)(a2 + 384) = 0;
    *(void *)(a2 + 392) = 0;
    *(void *)(a2 + 376) = 0;
    *(unsigned char *)(a1 + 400) = 1;
  }
  *(void *)(a1 + 408) = *(void *)(a2 + 408);
  long long v14 = *(_OWORD *)(a2 + 416);
  *(void *)(a1 + 432) = *(void *)(a2 + 432);
  *(_OWORD *)(a1 + 416) = v14;
  *(void *)(a2 + 424) = 0;
  *(void *)(a2 + 432) = 0;
  *(void *)(a2 + 416) = 0;
  long long v15 = *(_OWORD *)(a2 + 440);
  *(void *)(a1 + 456) = *(void *)(a2 + 456);
  *(_OWORD *)(a1 + 440) = v15;
  *(void *)(a2 + 448) = 0;
  *(void *)(a2 + 456) = 0;
  *(void *)(a2 + 440) = 0;
  long long v16 = *(_OWORD *)(a2 + 464);
  *(void *)(a1 + 480) = *(void *)(a2 + 480);
  *(_OWORD *)(a1 + 464) = v16;
  *(void *)(a2 + 472) = 0;
  *(void *)(a2 + 480) = 0;
  *(void *)(a2 + 464) = 0;
  long long v17 = *(_OWORD *)(a2 + 488);
  *(void *)(a1 + 504) = *(void *)(a2 + 504);
  *(_OWORD *)(a1 + 488) = v17;
  *(void *)(a2 + 488) = 0;
  *(void *)(a2 + 496) = 0;
  *(void *)(a2 + 504) = 0;
  long long v18 = *(_OWORD *)(a2 + 512);
  *(unsigned char *)(a1 + 528) = *(unsigned char *)(a2 + 528);
  *(_OWORD *)(a1 + 512) = v18;
  *(unsigned char *)(a1 + 536) = 0;
  *(unsigned char *)(a1 + 560) = 0;
  if (*(unsigned char *)(a2 + 560))
  {
    *(void *)(a1 + 536) = 0;
    *(void *)(a1 + 544) = 0;
    *(void *)(a1 + 552) = 0;
    *(void *)(a1 + 536) = *(void *)(a2 + 536);
    *(void *)(a1 + 544) = *(void *)(a2 + 544);
    *(void *)(a1 + 552) = *(void *)(a2 + 552);
    *(void *)(a2 + 544) = 0;
    *(void *)(a2 + 536) = 0;
    *(void *)(a2 + 552) = 0;
    *(unsigned char *)(a1 + 560) = 1;
  }
  *(unsigned char *)(a1 + 568) = 0;
  *(unsigned char *)(a1 + 592) = 0;
  if (*(unsigned char *)(a2 + 592))
  {
    *(void *)(a1 + 584) = 0;
    *(_OWORD *)(a1 + 568) = 0u;
    *(void *)(a1 + 568) = *(void *)(a2 + 568);
    *(void *)(a1 + 576) = *(void *)(a2 + 576);
    *(void *)(a1 + 584) = *(void *)(a2 + 584);
    *(void *)(a2 + 584) = 0;
    *(_OWORD *)(a2 + 568) = 0u;
    *(unsigned char *)(a1 + 592) = 1;
  }
  return a1;
}

void sub_10045840C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 176))
  {
    if (*(unsigned char *)(a1 + 168) && *(char *)(a1 + 167) < 0) {
      operator delete(*(void **)(a1 + 144));
    }
    if (*(unsigned char *)(a1 + 112) && *(char *)(a1 + 111) < 0) {
      operator delete(*(void **)(a1 + 88));
    }
    if (*(unsigned char *)(a1 + 80) && *(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(unsigned char *)(a1 + 176) = 0;
  }
}

__n128 sub_1004584A0(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v2;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  long long v3 = *(long long *)((char *)a2 + 24);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *(_OWORD *)(a1 + 24) = v3;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v4 = *((void *)a2 + 6);
  *(unsigned char *)(a1 + 56) = 0;
  *(void *)(a1 + 48) = v4;
  *(unsigned char *)(a1 + 80) = 0;
  if (*((unsigned char *)a2 + 80))
  {
    long long v5 = *(long long *)((char *)a2 + 56);
    *(void *)(a1 + 72) = *((void *)a2 + 9);
    *(_OWORD *)(a1 + 56) = v5;
    *((void *)a2 + 8) = 0;
    *((void *)a2 + 9) = 0;
    *((void *)a2 + 7) = 0;
    *(unsigned char *)(a1 + 80) = 1;
  }
  *(unsigned char *)(a1 + 88) = 0;
  *(unsigned char *)(a1 + 112) = 0;
  if (*((unsigned char *)a2 + 112))
  {
    long long v6 = *(long long *)((char *)a2 + 88);
    *(void *)(a1 + 104) = *((void *)a2 + 13);
    *(_OWORD *)(a1 + 88) = v6;
    *((void *)a2 + 12) = 0;
    *((void *)a2 + 13) = 0;
    *((void *)a2 + 11) = 0;
    *(unsigned char *)(a1 + 112) = 1;
  }
  __n128 result = *(__n128 *)((char *)a2 + 120);
  int v8 = *((_DWORD *)a2 + 34);
  *(unsigned char *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 136) = v8;
  *(__n128 *)(a1 + 120) = result;
  *(unsigned char *)(a1 + 168) = 0;
  if (*((unsigned char *)a2 + 168))
  {
    __n128 result = (__n128)a2[9];
    *(void *)(a1 + 160) = *((void *)a2 + 20);
    *(__n128 *)(a1 + 144) = result;
    *((void *)a2 + 19) = 0;
    *((void *)a2 + 20) = 0;
    *((void *)a2 + 18) = 0;
    *(unsigned char *)(a1 + 168) = 1;
  }
  return result;
}

uint64_t sub_100458588(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 600);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_1019CD400[v4])(&v6, a1);
  }
  *(_DWORD *)(a1 + 600) = -1;
  uint64_t result = sub_1004585F8(a1, a2);
  *(_DWORD *)(a1 + 600) = 6;
  return result;
}

uint64_t sub_1004585F8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(unsigned char *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 40) = 0;
  if (*(unsigned char *)(a2 + 40))
  {
    long long v4 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = v4;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 16) = 0;
    *(unsigned char *)(a1 + 40) = 1;
  }
  *(unsigned char *)(a1 + 48) = 0;
  uint64_t v5 = a1 + 48;
  *(unsigned char *)(a1 + 224) = 0;
  if (*(unsigned char *)(a2 + 224))
  {
    sub_1004584A0(v5, (long long *)(a2 + 48));
    *(unsigned char *)(a1 + 224) = 1;
  }
  *(unsigned char *)(a1 + 232) = 0;
  *(unsigned char *)(a1 + 256) = 0;
  if (*(unsigned char *)(a2 + 256))
  {
    long long v6 = *(_OWORD *)(a2 + 232);
    *(void *)(a1 + 248) = *(void *)(a2 + 248);
    *(_OWORD *)(a1 + 232) = v6;
    *(void *)(a2 + 240) = 0;
    *(void *)(a2 + 248) = 0;
    *(void *)(a2 + 232) = 0;
    *(unsigned char *)(a1 + 256) = 1;
  }
  *(unsigned char *)(a1 + 264) = 0;
  *(unsigned char *)(a1 + 288) = 0;
  if (*(unsigned char *)(a2 + 288))
  {
    long long v7 = *(_OWORD *)(a2 + 264);
    *(void *)(a1 + 280) = *(void *)(a2 + 280);
    *(_OWORD *)(a1 + 264) = v7;
    *(void *)(a2 + 272) = 0;
    *(void *)(a2 + 280) = 0;
    *(void *)(a2 + 264) = 0;
    *(unsigned char *)(a1 + 288) = 1;
  }
  *(unsigned char *)(a1 + 296) = 0;
  *(unsigned char *)(a1 + 320) = 0;
  if (*(unsigned char *)(a2 + 320))
  {
    *(void *)(a1 + 296) = 0;
    *(void *)(a1 + 304) = 0;
    *(void *)(a1 + 312) = 0;
    uint64_t v8 = *(void *)(a2 + 304);
    *(void *)(a1 + 296) = *(void *)(a2 + 296);
    *(void *)(a1 + 304) = v8;
    *(void *)(a1 + 312) = *(void *)(a2 + 312);
    *(void *)(a2 + 296) = 0;
    *(void *)(a2 + 304) = 0;
    *(void *)(a2 + 312) = 0;
    *(unsigned char *)(a1 + 320) = 1;
  }
  *(unsigned char *)(a1 + 328) = 0;
  *(unsigned char *)(a1 + 352) = 0;
  if (*(unsigned char *)(a2 + 352))
  {
    *(void *)(a1 + 328) = 0;
    *(void *)(a1 + 336) = 0;
    *(void *)(a1 + 344) = 0;
    uint64_t v9 = *(void *)(a2 + 336);
    *(void *)(a1 + 328) = *(void *)(a2 + 328);
    *(void *)(a1 + 336) = v9;
    *(void *)(a1 + 344) = *(void *)(a2 + 344);
    *(void *)(a2 + 328) = 0;
    *(void *)(a2 + 336) = 0;
    *(void *)(a2 + 344) = 0;
    *(unsigned char *)(a1 + 352) = 1;
  }
  return a1;
}

void sub_100458764(void **a1)
{
  v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    long long v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 280;
        sub_100456500(v3);
      }
      while ((void *)v3 != v1);
      long long v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_1004587CC(uint64_t a1, long long *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 600);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_1019CD400[v4])(&v5, a1);
  }
  *(_DWORD *)(a1 + 600) = -1;
  sub_10045883C(a1, a2);
  *(_DWORD *)(a1 + 600) = 7;
}

__n128 sub_10045883C(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  *(_DWORD *)(a1 + 16) = *((_DWORD *)a2 + 4);
  *(_OWORD *)a1 = v2;
  *(unsigned char *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  if (*((unsigned char *)a2 + 48))
  {
    long long v3 = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(a1 + 24) = v3;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    *(unsigned char *)(a1 + 48) = 1;
  }
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  __n128 result = *(__n128 *)((char *)a2 + 56);
  *(__n128 *)(a1 + 56) = result;
  *(void *)(a1 + 72) = *((void *)a2 + 9);
  *((void *)a2 + 7) = 0;
  *((void *)a2 + 8) = 0;
  *((void *)a2 + 9) = 0;
  *(unsigned char *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 104) = 0;
  if (*((unsigned char *)a2 + 104))
  {
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0;
    __n128 result = (__n128)a2[5];
    *(__n128 *)(a1 + 80) = result;
    *(void *)(a1 + 96) = *((void *)a2 + 12);
    *((void *)a2 + 10) = 0;
    *((void *)a2 + 11) = 0;
    *((void *)a2 + 12) = 0;
    *(unsigned char *)(a1 + 104) = 1;
  }
  return result;
}

uint64_t sub_1004588E0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  long long v4 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v4;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 48) = 0;
  long long v5 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v5;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 72) = 0;
  *(unsigned char *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 168) = 0;
  if (*(unsigned char *)(a2 + 168))
  {
    long long v6 = *(_OWORD *)(a2 + 96);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    *(_OWORD *)(a1 + 96) = v6;
    *(void *)(a2 + 104) = 0;
    *(void *)(a2 + 112) = 0;
    *(void *)(a2 + 96) = 0;
    long long v7 = *(_OWORD *)(a2 + 120);
    *(void *)(a1 + 136) = *(void *)(a2 + 136);
    *(_OWORD *)(a1 + 120) = v7;
    *(void *)(a2 + 128) = 0;
    *(void *)(a2 + 136) = 0;
    *(void *)(a2 + 120) = 0;
    long long v8 = *(_OWORD *)(a2 + 144);
    *(void *)(a1 + 160) = *(void *)(a2 + 160);
    *(_OWORD *)(a1 + 144) = v8;
    *(void *)(a2 + 152) = 0;
    *(void *)(a2 + 160) = 0;
    *(void *)(a2 + 144) = 0;
    *(unsigned char *)(a1 + 168) = 1;
  }
  *(unsigned char *)(a1 + 176) = 0;
  *(unsigned char *)(a1 + 200) = 0;
  if (*(unsigned char *)(a2 + 200))
  {
    long long v9 = *(_OWORD *)(a2 + 176);
    *(void *)(a1 + 192) = *(void *)(a2 + 192);
    *(_OWORD *)(a1 + 176) = v9;
    *(void *)(a2 + 184) = 0;
    *(void *)(a2 + 192) = 0;
    *(void *)(a2 + 176) = 0;
    *(unsigned char *)(a1 + 200) = 1;
  }
  sub_100457754((__n128 *)(a1 + 208), a2 + 208);
  long long v10 = *(_OWORD *)(a2 + 288);
  *(void *)(a1 + 304) = *(void *)(a2 + 304);
  *(_OWORD *)(a1 + 288) = v10;
  *(void *)(a2 + 288) = 0;
  *(void *)(a2 + 296) = 0;
  *(void *)(a2 + 304) = 0;
  *(_DWORD *)(a1 + 312) = *(_DWORD *)(a2 + 312);
  return a1;
}

uint64_t sub_100458A3C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  long long v3 = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v3;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  long long v4 = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = v4;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 32) = 0;
  char v5 = *(unsigned char *)(a2 + 56);
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 56) = v5;
  *(unsigned char *)(a1 + 88) = 0;
  if (*(unsigned char *)(a2 + 88))
  {
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = 0;
    *(void *)(a2 + 80) = 0;
    *(unsigned char *)(a1 + 88) = 1;
  }
  long long v6 = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(_OWORD *)(a1 + 96) = v6;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 96) = 0;
  long long v7 = *(_OWORD *)(a2 + 120);
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v7;
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 120) = 0;
  sub_100458B18(a1 + 152, a2 + 152);
  return a1;
}

uint64_t sub_100458B18(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 600) = -1;
  sub_100458B50(a1, a2);
  return a1;
}

uint64_t sub_100458B50(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 600);
  if (v4 != -1) {
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_1019CD400[v4])(&v7, result);
  }
  *(_DWORD *)(v3 + 600) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 600);
  if (v5 != -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_1019CD4B0[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 600) = v5;
  }
  return result;
}

double sub_100458BE0(uint64_t a1, __n128 *a2, uint64_t a3)
{
  *(void *)&double result = sub_100456FAC(a2, a3).n128_u64[0];
  return result;
}

uint64_t sub_100458BEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1004575A4(a2, a3);
}

double sub_100458BF8(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(void *)&double result = sub_100457830(a2, a3).n128_u64[0];
  return result;
}

uint64_t sub_100458C04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1004579CC(a2, a3);
}

uint64_t sub_100458C10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100457EAC(a2, a3);
}

uint64_t sub_100458C1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_10045812C(a2, a3);
}

uint64_t sub_100458C28(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1004585F8(a2, a3);
}

double sub_100458C34(uint64_t a1, uint64_t a2, long long *a3)
{
  *(void *)&double result = sub_10045883C(a2, a3).n128_u64[0];
  return result;
}

uint64_t sub_100458C40(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1004588E0(a2, a3);
}

uint64_t sub_100458C4C(uint64_t a1)
{
  (*(void (**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(v3);
  sub_100456604(*(void *)(a1 + 32), (uint64_t)v3);
  return sub_100455FA0((uint64_t)v3);
}

void sub_100458CCC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100458CD8(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(unsigned int **)(a1 + 40);
  uint64_t v4 = *((void *)v3 + 1);
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), *v3);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [retrieve-all-messages] start...", (uint8_t *)&v8, 2u);
  }
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  (*(void (**)(void, void))(**(void **)(v4 + 152) + 96))(*(void *)(v4 + 152), *v3);
  char v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), *v3);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a2 + 24)) {
      char v7 = "OK";
    }
    else {
      char v7 = "EMPTY";
    }
    int v8 = 136315138;
    long long v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [retrieve-all-messages] status: %s", (uint8_t *)&v8, 0xCu);
  }
}

void sub_100458E6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (*(unsigned char *)(v9 + 24))
  {
    a9 = v9;
    sub_100047F64((void ***)&a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_100458E94(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v2);
  sub_100179A54(*(void *)(a1 + 32), &v2);
  if (v3)
  {
    uint64_t v4 = &v2;
    sub_100047F64((void ***)&v4);
  }
}

void sub_100458EF8(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v2);
  sub_100179A54(*(void *)(a1 + 32), &v2);
  if (v3)
  {
    uint64_t v4 = &v2;
    sub_100047F64((void ***)&v4);
  }
}

uint64_t sub_100458F5C(uint64_t a1)
{
  v1 = *(void **)(a1 + 40);
  uint64_t v2 = v1[1];
  char v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)v1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v1[3] - v1[2]) >> 3);
    int v9 = 134217984;
    unint64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [acknowledge-messages] start list: %zu", (uint8_t *)&v9, 0xCu);
  }
  uint64_t v5 = (*(uint64_t (**)(void, void, void *))(**(void **)(v2 + 152) + 104))(*(void *)(v2 + 152), *(unsigned int *)v1, v1 + 2);
  char v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)v1);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if ((v5 & 0xFF00000000) != 0) {
      char v7 = (const char *)Lazuli::asString();
    }
    else {
      char v7 = "OK";
    }
    int v9 = 136315138;
    unint64_t v10 = (unint64_t)v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [acknowledge-messages] status: %s", (uint8_t *)&v9, 0xCu);
  }
  return v5;
}

uint64_t sub_100459110(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  uint64_t v3 = *(void *)(a1 + 32);
  *(_DWORD *)uint64_t v3 = result;
  *(unsigned char *)(v3 + 4) = BYTE4(result);
  return result;
}

uint64_t sub_100459154(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  uint64_t v3 = *(void *)(a1 + 32);
  *(_DWORD *)uint64_t v3 = result;
  *(unsigned char *)(v3 + 4) = BYTE4(result);
  return result;
}

uint64_t sub_100459198(uint64_t a1)
{
  v1 = *(unsigned int **)(a1 + 40);
  uint64_t v2 = *((void *)v1 + 1);
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    sub_100459370(__p, (uint64_t)(v1 + 38));
    unint64_t v4 = v10 >= 0 ? __p : *(unsigned char **)__p;
    *(_DWORD *)buf = 136446210;
    long long v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [send-composing-indicator] start indicator: %{public}s", buf, 0xCu);
    if (v10 < 0) {
      operator delete(*(void **)__p);
    }
  }
  uint64_t v5 = (*(uint64_t (**)(void, void, unsigned int *, unsigned int *, unsigned int *))(**(void **)(v2 + 152)
                                                                                                 + 112))(*(void *)(v2 + 152), *v1, v1 + 4, v1 + 32, v1 + 38);
  char v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if ((v5 & 0xFF00000000) != 0) {
      char v7 = (const char *)Lazuli::asString();
    }
    else {
      char v7 = "OK";
    }
    *(_DWORD *)__p = 136315138;
    *(void *)&__p[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [send-composing-indicator] status: %s", __p, 0xCu);
  }
  return v5;
}

uint64_t sub_100459370(void *a1, uint64_t a2)
{
  uint64_t v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  *(_OWORD *)long long v18 = 0u;
  long long v19 = 0u;
  memset(v17, 0, sizeof(v17));
  long long v16 = 0u;
  sub_10004BD84((uint64_t)&v16);
  unint64_t v4 = sub_10004B96C(v17, (uint64_t)"refreshTime: ", 13);
  if (*(unsigned char *)(a2 + 8)) {
    std::to_string(&__p, *(void *)a2);
  }
  else {
    sub_100058DB0(&__p, "(null)");
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v4, (uint64_t)p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_10004B96C(v17, (uint64_t)", active: ", 10);
  std::ostream::operator<<();
  char v7 = sub_10004B96C(v17, (uint64_t)", lastActive: ", 14);
  if (*(unsigned char *)(a2 + 48))
  {
    if (*(char *)(a2 + 47) < 0) {
      sub_10004FC84(&__p, *(void **)(a2 + 24), *(void *)(a2 + 32));
    }
    else {
      std::string __p = *(std::string *)(a2 + 24);
    }
  }
  else
  {
    sub_100058DB0(&__p, "(null)");
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v8 = &__p;
  }
  else {
    int v8 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v9 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v9 = __p.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v7, (uint64_t)v8, v9);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  char v10 = sub_10004B96C(v17, (uint64_t)", contentType: ", 15);
  if (*(unsigned char *)(a2 + 80))
  {
    if (*(char *)(a2 + 79) < 0) {
      sub_10004FC84(&__p, *(void **)(a2 + 56), *(void *)(a2 + 64));
    }
    else {
      std::string __p = *(std::string *)(a2 + 56);
    }
  }
  else
  {
    sub_100058DB0(&__p, "(null)");
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v11 = &__p;
  }
  else {
    long long v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v12 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v12 = __p.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v10, (uint64_t)v11, v12);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_10004BC98((uint64_t)v17 + 8, a1);
  *(void *)((char *)&v17[-1]
  *(void *)&v17[0] = v13;
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1004596C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
}

uint64_t sub_100459700(uint64_t a1)
{
  v1 = *(unsigned int **)(a1 + 40);
  uint64_t v2 = *((void *)v1 + 22);
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v4 = (const char *)(v1 + 2);
    if (*((char *)v1 + 31) < 0) {
      unint64_t v4 = *(const char **)v4;
    }
    uint64_t v5 = v1 + 30;
    if (*((char *)v1 + 143) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    uint64_t v6 = Lazuli::asString();
    char v7 = v1 + 38;
    if (*((char *)v1 + 175) < 0) {
      char v7 = (void *)*v7;
    }
    int v12 = 136381443;
    xpc_object_t v13 = v4;
    __int16 v14 = 2082;
    long long v15 = v5;
    __int16 v16 = 2080;
    uint64_t v17 = v6;
    __int16 v18 = 2082;
    long long v19 = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [send-disposition] start destination: %{private}s, messageID: %{public}s, type-> %s, for: %{public}s", (uint8_t *)&v12, 0x2Au);
  }
  uint64_t v8 = (*(uint64_t (**)(void, void, unsigned int *, unsigned int *, unsigned int *))(**(void **)(v2 + 152)
                                                                                                 + 120))(*(void *)(v2 + 152), *v1, v1 + 2, v1 + 30, v1 + 36);
  std::string::size_type v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if ((v8 & 0xFF00000000) != 0) {
      char v10 = (const char *)Lazuli::asString();
    }
    else {
      char v10 = "OK";
    }
    int v12 = 136315138;
    xpc_object_t v13 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [send-disposition] status: %s", (uint8_t *)&v12, 0xCu);
  }
  return v8;
}

uint64_t sub_100459904(uint64_t a1)
{
  v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *(unsigned int *)v1[1]);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = v1[2];
    uint64_t v5 = (const char *)v4;
    if (*(char *)(v4 + 23) < 0) {
      uint64_t v5 = *(const char **)v4;
    }
    uint64_t v6 = (uint64_t *)v1[3];
    if (*((char *)v6 + 23) < 0) {
      uint64_t v6 = (uint64_t *)*v6;
    }
    char v7 = "YES";
    if (!*(unsigned char *)(v1[4] + 80)) {
      char v7 = "NO";
    }
    uint64_t v8 = (void *)(v4 + 88);
    if (*(char *)(v4 + 111) < 0) {
      uint64_t v8 = (void *)*v8;
    }
    int v13 = 136381443;
    __int16 v14 = v5;
    __int16 v15 = 2082;
    __int16 v16 = v6;
    __int16 v17 = 2080;
    __int16 v18 = v7;
    __int16 v19 = 2082;
    long long v20 = v8;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [send-text] start destination: %{private}s, messageID: %{public}s, metaData: %s, conversationID: %{public}s", (uint8_t *)&v13, 0x2Au);
  }
  uint64_t v9 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t))(**(void **)(v2 + 152) + 80))(*(void *)(v2 + 152), *(unsigned int *)v1[1], v1[2], v1[3], v1[4]);
  char v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)v1[1]);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    if ((v9 & 0xFF00000000) != 0) {
      long long v11 = (const char *)Lazuli::asString();
    }
    else {
      long long v11 = "OK";
    }
    int v13 = 136315138;
    __int16 v14 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [send-text] status: %s", (uint8_t *)&v13, 0xCu);
  }
  return v9;
}

uint64_t sub_100459B1C(uint64_t a1)
{
  v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  BOOL v3 = sub_10044DBD0(*(void *)(*v1 + 120));
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (const char *)(v1 + 2);
    if (*((char *)v1 + 39) < 0) {
      uint64_t v5 = *(const char **)v5;
    }
    uint64_t v6 = v1 + 16;
    if (*((char *)v1 + 151) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    int v7 = *((unsigned __int8 *)v1 + 256);
    int v14 = 136381443;
    if (v7) {
      uint64_t v8 = "true";
    }
    else {
      uint64_t v8 = "false";
    }
    __int16 v15 = v5;
    __int16 v16 = 2082;
    if (v3) {
      uint64_t v9 = "true";
    }
    else {
      uint64_t v9 = "false";
    }
    __int16 v17 = v6;
    __int16 v18 = 2080;
    __int16 v19 = v8;
    __int16 v20 = 2080;
    long long v21 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [send-geo] start destination: %{private}s, messageID: %{public}s, metaData: %s, useGeoSms: %s", (uint8_t *)&v14, 0x2Au);
  }
  uint64_t v10 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *, uint64_t *, BOOL))(**(void **)(v2 + 152)
                                                                                           + 128))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 16, v1 + 19, v3);
  long long v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if ((v10 & 0xFF00000000) != 0) {
      int v12 = (const char *)Lazuli::asString();
    }
    else {
      int v12 = "OK";
    }
    int v14 = 136315138;
    __int16 v15 = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [send-geo] status: %s", (uint8_t *)&v14, 0xCu);
  }
  return v10;
}

uint64_t sub_100459D38(uint64_t a1)
{
  v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  BOOL v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (const char *)(v1 + 2);
    if (*((char *)v1 + 39) < 0) {
      uint64_t v4 = *(const char **)v4;
    }
    uint64_t v5 = v1 + 16;
    if (*((char *)v1 + 151) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    int v6 = *((unsigned __int8 *)v1 + 456);
    int v12 = 136381187;
    if (v6) {
      int v7 = "YES";
    }
    else {
      int v7 = "NO";
    }
    int v13 = v4;
    __int16 v14 = 2082;
    __int16 v15 = v5;
    __int16 v16 = 2080;
    __int16 v17 = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [send-file] start destination: %{private}s, messageID: %{public}s, metaData: %s", (uint8_t *)&v12, 0x20u);
  }
  uint64_t v8 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *, uint64_t *))(**(void **)(v2 + 152) + 136))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 16, v1 + 19);
  uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if ((v8 & 0xFF00000000) != 0) {
      uint64_t v10 = (const char *)Lazuli::asString();
    }
    else {
      uint64_t v10 = "OK";
    }
    int v12 = 136315138;
    int v13 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [send-file] status: %s", (uint8_t *)&v12, 0xCu);
  }
  return v8;
}

uint64_t sub_100459F30(uint64_t a1)
{
  v1 = *(unsigned int **)(a1 + 40);
  uint64_t v2 = *((void *)v1 + 15);
  BOOL v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (const char *)(v1 + 2);
    if (*((char *)v1 + 31) < 0) {
      uint64_t v4 = *(const char **)v4;
    }
    uint64_t v5 = v1 + 32;
    if (*((char *)v1 + 151) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    int v10 = 136380931;
    long long v11 = v4;
    __int16 v12 = 2081;
    int v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [discover-capabilities] start destination: %{private}s, operationID: %{private}s", (uint8_t *)&v10, 0x16u);
  }
  uint64_t v6 = (*(uint64_t (**)(void, void, unsigned int *, unsigned int *))(**(void **)(v2 + 184) + 64))(*(void *)(v2 + 184), *v1, v1 + 2, v1 + 32);
  int v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if ((v6 & 0xFF00000000) != 0) {
      uint64_t v8 = (const char *)Lazuli::asString();
    }
    else {
      uint64_t v8 = "OK";
    }
    int v10 = 136315138;
    long long v11 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [discover-capabilities] status: %s", (uint8_t *)&v10, 0xCu);
  }
  return v6;
}

uint64_t sub_10045A0FC(uint64_t a1)
{
  v1 = *(unsigned int **)(a1 + 40);
  uint64_t v2 = *((void *)v1 + 16);
  BOOL v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (const char *)(v1 + 2);
    if (*((char *)v1 + 31) < 0) {
      uint64_t v4 = *(const char **)v4;
    }
    uint64_t v5 = Lazuli::asString();
    uint64_t v6 = v1 + 34;
    if (*((char *)v1 + 159) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    int v11 = 136381187;
    __int16 v12 = v4;
    __int16 v13 = 2082;
    uint64_t v14 = v5;
    __int16 v15 = 2081;
    __int16 v16 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [fetch-remote-capabilities] start destination: %{private}s, options: %{public}s, operationID: %{private}s", (uint8_t *)&v11, 0x20u);
  }
  uint64_t v7 = (*(uint64_t (**)(void, void, unsigned int *, unsigned int *, unsigned int *))(**(void **)(v2 + 184)
                                                                                                 + 72))(*(void *)(v2 + 184), *v1, v1 + 2, v1 + 30, v1 + 34);
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if ((v7 & 0xFF00000000) != 0) {
      uint64_t v9 = (const char *)Lazuli::asString();
    }
    else {
      uint64_t v9 = "OK";
    }
    int v11 = 136315138;
    __int16 v12 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [fetch-remote-capabilities] status: %s", (uint8_t *)&v11, 0xCu);
  }
  return v7;
}

void sub_10045A2E0(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  BOOL v3 = *(unsigned int **)(a1 + 40);
  uint64_t v4 = *((void *)v3 + 15);
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), *v3);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = (const char *)(v3 + 2);
    if (*((char *)v3 + 31) < 0) {
      uint64_t v6 = *(const char **)v6;
    }
    int v9 = 136380675;
    int v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [read-cached-capabilities] start destination: %{private}s", (uint8_t *)&v9, 0xCu);
  }
  *(void *)(a2 + 208) = 0;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  (*(void (**)(void, void, unsigned int *))(**(void **)(v4 + 184) + 112))(*(void *)(v4 + 184), *v3, v3 + 2);
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), *v3);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a2 + 208)) {
      uint64_t v8 = "OK";
    }
    else {
      uint64_t v8 = "(nil)";
    }
    int v9 = 136315138;
    int v10 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [read-cached-capabilities] status: %s", (uint8_t *)&v9, 0xCu);
  }
}

void sub_10045A4B0(_Unwind_Exception *a1)
{
  sub_1001794B8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10045A4CC(uint64_t a1)
{
  (*(void (**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(v3);
  sub_10045A520(*(void *)(a1 + 32), (uint64_t)v3);
  return sub_1001794B8((uint64_t)v3);
}

void sub_10045A520(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 208) == *(unsigned __int8 *)(a2 + 208))
  {
    if (*(unsigned char *)(a1 + 208))
    {
      sub_100179B9C(a1, (long long *)a2);
    }
  }
  else if (*(unsigned char *)(a1 + 208))
  {
    if (*(unsigned char *)(a1 + 184))
    {
      BOOL v3 = (void **)(a1 + 160);
      sub_100047F64(&v3);
    }
    if (*(unsigned char *)(a1 + 144) && *(char *)(a1 + 143) < 0) {
      operator delete(*(void **)(a1 + 120));
    }
    if (*(char *)(a1 + 111) < 0) {
      operator delete(*(void **)(a1 + 88));
    }
    if (*(unsigned char *)(a1 + 80))
    {
      BOOL v3 = (void **)(a1 + 56);
      sub_100047F64(&v3);
    }
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(unsigned char *)(a1 + 208) = 0;
  }
  else
  {
    sub_10045A614(a1, (long long *)a2);
    *(unsigned char *)(a1 + 208) = 1;
  }
}

__n128 sub_10045A614(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v2;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  long long v3 = *(long long *)((char *)a2 + 24);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *(_OWORD *)(a1 + 24) = v3;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 3) = 0;
  char v4 = *((unsigned char *)a2 + 48);
  *(unsigned char *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 48) = v4;
  *(unsigned char *)(a1 + 80) = 0;
  if (*((unsigned char *)a2 + 80))
  {
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
    *(_OWORD *)(a1 + 56) = *(long long *)((char *)a2 + 56);
    *(void *)(a1 + 72) = *((void *)a2 + 9);
    *((void *)a2 + 7) = 0;
    *((void *)a2 + 8) = 0;
    *((void *)a2 + 9) = 0;
    *(unsigned char *)(a1 + 80) = 1;
  }
  long long v5 = *(long long *)((char *)a2 + 88);
  *(void *)(a1 + 104) = *((void *)a2 + 13);
  *(_OWORD *)(a1 + 88) = v5;
  *((void *)a2 + 12) = 0;
  *((void *)a2 + 13) = 0;
  *((void *)a2 + 11) = 0;
  int v6 = *((_DWORD *)a2 + 28);
  __int16 v7 = *((_WORD *)a2 + 58);
  *(unsigned char *)(a1 + 120) = 0;
  *(_WORD *)(a1 + 116) = v7;
  *(_DWORD *)(a1 + 112) = v6;
  *(unsigned char *)(a1 + 144) = 0;
  if (*((unsigned char *)a2 + 144))
  {
    long long v8 = *(long long *)((char *)a2 + 120);
    *(void *)(a1 + 136) = *((void *)a2 + 17);
    *(_OWORD *)(a1 + 120) = v8;
    *((void *)a2 + 16) = 0;
    *((void *)a2 + 17) = 0;
    *((void *)a2 + 15) = 0;
    *(unsigned char *)(a1 + 144) = 1;
  }
  uint64_t v9 = *((void *)a2 + 19);
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)(a1 + 152) = v9;
  *(unsigned char *)(a1 + 184) = 0;
  if (*((unsigned char *)a2 + 184))
  {
    *(void *)(a1 + 160) = 0;
    *(void *)(a1 + 168) = 0;
    *(void *)(a1 + 176) = 0;
    *(_OWORD *)(a1 + 160) = a2[10];
    *(void *)(a1 + 176) = *((void *)a2 + 22);
    *((void *)a2 + 20) = 0;
    *((void *)a2 + 21) = 0;
    *((void *)a2 + 22) = 0;
    *(unsigned char *)(a1 + 184) = 1;
  }
  __n128 result = (__n128)a2[12];
  *(__n128 *)(a1 + 192) = result;
  return result;
}

uint64_t sub_10045A734(uint64_t a1)
{
  (*(void (**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(v3);
  sub_10045A520(*(void *)(a1 + 32), (uint64_t)v3);
  return sub_1001794B8((uint64_t)v3);
}

uint64_t sub_10045A788(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  long long v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    char v4 = (const char *)(v1 + 2);
    if (*((char *)v1 + 39) < 0) {
      char v4 = *(const char **)v4;
    }
    long long v5 = v1 + 16;
    if (*((char *)v1 + 151) < 0) {
      long long v5 = (void *)*v5;
    }
    int v10 = 136380931;
    int v11 = v4;
    __int16 v12 = 2082;
    __int16 v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [send-response-for-reply] start destination: %{private}s, messageID: %{public}s", (uint8_t *)&v10, 0x16u);
  }
  uint64_t v6 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *, uint64_t *))(**(void **)(v2 + 152) + 152))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 16, v1 + 19);
  __int16 v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if ((v6 & 0xFF00000000) != 0) {
      long long v8 = (const char *)Lazuli::asString();
    }
    else {
      long long v8 = "OK";
    }
    int v10 = 136315138;
    int v11 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [send-response-for-reply] status: %s", (uint8_t *)&v10, 0xCu);
  }
  return v6;
}

uint64_t sub_10045A958(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 40);
  uint64_t v2 = *((void *)v1 + 18);
  long long v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    char v4 = (const char *)(v1 + 2);
    if (*((char *)v1 + 31) < 0) {
      char v4 = *(const char **)v4;
    }
    long long v5 = v1 + 30;
    if (*((char *)v1 + 143) < 0) {
      long long v5 = (void *)*v5;
    }
    int v10 = 136380931;
    int v11 = v4;
    __int16 v12 = 2081;
    __int16 v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [fetch-chatbot-render-information] start destination: %{private}s, operationID: %{private}s", (uint8_t *)&v10, 0x16u);
  }
  uint64_t v6 = (*(uint64_t (**)(void, void, unsigned int *, unsigned int *))(**(void **)(v2 + 168) + 64))(*(void *)(v2 + 168), *v1, v1 + 2, v1 + 30);
  __int16 v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if ((v6 & 0xFF00000000) != 0) {
      long long v8 = (const char *)Lazuli::asString();
    }
    else {
      long long v8 = "OK";
    }
    int v10 = 136315138;
    int v11 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [fetch-chatbot-render-information] status: %s", (uint8_t *)&v10, 0xCu);
  }
  return v6;
}

void sub_10045AB24(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  long long v3 = *(unsigned int **)(a1 + 40);
  uint64_t v4 = *((void *)v3 + 15);
  long long v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), *v3);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = v3 + 2;
    if (*((char *)v3 + 31) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    int v10 = 136380675;
    int v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [read-cached-chatbot-render-information] start destination: %{private}s", (uint8_t *)&v10, 0xCu);
  }
  bzero(a2, 0x2C0uLL);
  (*(void (**)(void, void, unsigned int *))(**(void **)(v4 + 168) + 72))(*(void *)(v4 + 168), *v3, v3 + 2);
  __int16 v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), *v3);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = Lazuli::asString();
    uint64_t v9 = "(valid)";
    if (!a2[688]) {
      uint64_t v9 = "(nil)";
    }
    int v10 = 136315394;
    int v11 = (void *)v8;
    __int16 v12 = 2080;
    __int16 v13 = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [read-cached-chatbot-render-information] status: %s cache: %s", (uint8_t *)&v10, 0x16u);
  }
}

void sub_10045ACF0(_Unwind_Exception *a1)
{
  sub_1001FA0E0(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10045AD10(uint64_t a1)
{
  (*(void (**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(v4);
  uint64_t v2 = *(void *)(a1 + 32);
  sub_10045AD70(v2, (uint64_t)v4);
  *(_DWORD *)(v2 + 696) = v5;
  return sub_1001FA0E0((uint64_t)v4);
}

__n128 sub_10045AD70(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 688) == *(unsigned __int8 *)(a2 + 688))
  {
    if (*(unsigned char *)(a1 + 688))
    {
      sub_10045AFC4((unsigned char *)a1, a2);
      sub_10045B6CC(a1 + 568, (__n128 *)(a2 + 568));
      *(unsigned char *)(a1 + 600) = *(unsigned char *)(a2 + 600);
      uint64_t v4 = (void **)(a1 + 608);
      if (*(char *)(a1 + 631) < 0) {
        operator delete(*v4);
      }
      long long v5 = *(_OWORD *)(a2 + 608);
      *(void *)(a1 + 624) = *(void *)(a2 + 624);
      *(_OWORD *)uint64_t v4 = v5;
      *(unsigned char *)(a2 + 631) = 0;
      *(unsigned char *)(a2 + 608) = 0;
      uint64_t v6 = (void **)(a1 + 632);
      if (*(char *)(a1 + 655) < 0) {
        operator delete(*v6);
      }
      __n128 result = *(__n128 *)(a2 + 632);
      *(void *)(a1 + 648) = *(void *)(a2 + 648);
      *(__n128 *)uint64_t v6 = result;
      *(unsigned char *)(a2 + 655) = 0;
      *(unsigned char *)(a2 + 632) = 0;
      uint64_t v8 = (void **)(a1 + 656);
      uint64_t v9 = (__n128 *)(a2 + 656);
      if (*(unsigned __int8 *)(a1 + 680) == *(unsigned __int8 *)(a2 + 680))
      {
        if (*(unsigned char *)(a1 + 680))
        {
          if (*(char *)(a1 + 679) < 0) {
            operator delete(*v8);
          }
          __n128 result = *v9;
          *(void *)(a1 + 672) = *(void *)(a2 + 672);
          *(__n128 *)uint64_t v8 = result;
          *(unsigned char *)(a2 + 679) = 0;
          *(unsigned char *)(a2 + 656) = 0;
        }
      }
      else if (*(unsigned char *)(a1 + 680))
      {
        if (*(char *)(a1 + 679) < 0) {
          operator delete(*v8);
        }
        *(unsigned char *)(a1 + 680) = 0;
      }
      else
      {
        __n128 result = *v9;
        *(void *)(a1 + 672) = *(void *)(a2 + 672);
        *(__n128 *)uint64_t v8 = result;
        *(void *)(a2 + 664) = 0;
        *(void *)(a2 + 672) = 0;
        v9->n128_u64[0] = 0;
        *(unsigned char *)(a1 + 680) = 1;
      }
    }
  }
  else if (*(unsigned char *)(a1 + 688))
  {
    sub_1001FA228(a1);
  }
  else
  {
    sub_10045B770(a1, a2);
    *(unsigned char *)(a1 + 568) = 0;
    *(unsigned char *)(a1 + 592) = 0;
    if (*(unsigned char *)(a2 + 592))
    {
      *(void *)(a1 + 584) = 0;
      *(_OWORD *)(a1 + 568) = 0u;
      *(void *)(a1 + 568) = *(void *)(a2 + 568);
      *(void *)(a1 + 576) = *(void *)(a2 + 576);
      *(void *)(a1 + 584) = *(void *)(a2 + 584);
      *(void *)(a2 + 584) = 0;
      *(_OWORD *)(a2 + 568) = 0u;
      *(unsigned char *)(a1 + 592) = 1;
    }
    *(unsigned char *)(a1 + 600) = *(unsigned char *)(a2 + 600);
    long long v10 = *(_OWORD *)(a2 + 608);
    *(void *)(a1 + 624) = *(void *)(a2 + 624);
    *(_OWORD *)(a1 + 608) = v10;
    *(void *)(a2 + 624) = 0;
    *(void *)(a2 + 616) = 0;
    *(void *)(a2 + 608) = 0;
    __n128 result = *(__n128 *)(a2 + 632);
    *(void *)(a1 + 648) = *(void *)(a2 + 648);
    *(__n128 *)(a1 + 632) = result;
    *(void *)(a2 + 648) = 0;
    *(void *)(a2 + 640) = 0;
    *(void *)(a2 + 632) = 0;
    *(unsigned char *)(a1 + 656) = 0;
    *(unsigned char *)(a1 + 680) = 0;
    if (*(unsigned char *)(a2 + 680))
    {
      __n128 result = *(__n128 *)(a2 + 656);
      *(void *)(a1 + 672) = *(void *)(a2 + 672);
      *(__n128 *)(a1 + 656) = result;
      *(void *)(a2 + 672) = 0;
      *(void *)(a2 + 664) = 0;
      *(void *)(a2 + 656) = 0;
      *(unsigned char *)(a1 + 680) = 1;
    }
    *(unsigned char *)(a1 + 688) = 1;
  }
  return result;
}

unsigned char *sub_10045AFC4(unsigned char *a1, uint64_t a2)
{
  return a1;
}

void sub_10045B084(unsigned char *a1, uint64_t a2)
{
  if (a1[272] == *(unsigned char *)(a2 + 272))
  {
    if (a1[272])
    {
      sub_10045B0EC((uint64_t)a1, a2);
    }
  }
  else if (a1[272])
  {
    sub_1001FA2B4((uint64_t)a1);
  }
  else
  {
    sub_10045B4BC(a1, a2);
    *(unsigned char *)(v2 + 272) = 1;
  }
}

uint64_t sub_10045B0EC(uint64_t a1, uint64_t a2)
{
  return a1;
}

__n128 sub_10045B16C(uint64_t a1, long long *a2)
{
  if (*(unsigned __int8 *)(a1 + 96) == *((unsigned __int8 *)a2 + 96))
  {
    if (*(unsigned char *)(a1 + 96))
    {
      if (*(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
      long long v4 = *a2;
      *(void *)(a1 + 16) = *((void *)a2 + 2);
      *(_OWORD *)a1 = v4;
      *((unsigned char *)a2 + 23) = 0;
      *(unsigned char *)a2 = 0;
      long long v5 = (void **)(a1 + 24);
      if (*(char *)(a1 + 47) < 0) {
        operator delete(*v5);
      }
      long long v6 = *(long long *)((char *)a2 + 24);
      *(void *)(a1 + 40) = *((void *)a2 + 5);
      *(_OWORD *)long long v5 = v6;
      *((unsigned char *)a2 + 47) = 0;
      *((unsigned char *)a2 + 24) = 0;
      __int16 v7 = (void **)(a1 + 48);
      if (*(char *)(a1 + 71) < 0) {
        operator delete(*v7);
      }
      long long v8 = a2[3];
      *(void *)(a1 + 64) = *((void *)a2 + 8);
      *(_OWORD *)__int16 v7 = v8;
      *((unsigned char *)a2 + 71) = 0;
      *((unsigned char *)a2 + 48) = 0;
      sub_1001FA3CC((uint64_t *)(a1 + 72));
      __n128 result = *(__n128 *)((char *)a2 + 72);
      *(__n128 *)(a1 + 72) = result;
      *(void *)(a1 + 88) = *((void *)a2 + 11);
      *((void *)a2 + 9) = 0;
      *((void *)a2 + 10) = 0;
      *((void *)a2 + 11) = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 96))
  {
    sub_1001FA358(a1);
  }
  else
  {
    long long v10 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v10;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v11 = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(a1 + 24) = v11;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    long long v12 = a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *(_OWORD *)(a1 + 48) = v12;
    *((void *)a2 + 7) = 0;
    *((void *)a2 + 8) = 0;
    *((void *)a2 + 6) = 0;
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
    __n128 result = *(__n128 *)((char *)a2 + 72);
    *(__n128 *)(a1 + 72) = result;
    *(void *)(a1 + 88) = *((void *)a2 + 11);
    *((void *)a2 + 9) = 0;
    *((void *)a2 + 10) = 0;
    *((void *)a2 + 11) = 0;
    *(unsigned char *)(a1 + 96) = 1;
  }
  return result;
}

__n128 sub_10045B2EC(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(unsigned char *)(a1 + 24))
    {
      sub_1001FA468((void **)a1);
      __n128 result = *a2;
      *(__n128 *)a1 = *a2;
      *(void *)(a1 + 16) = a2[1].n128_u64[0];
      a2->n128_u64[0] = 0;
      a2->n128_u64[1] = 0;
      a2[1].n128_u64[0] = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    long long v5 = (void **)a1;
    sub_1001F80D0(&v5);
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    __n128 result = *a2;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

__n128 sub_10045B390(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(unsigned char *)(a1 + 24))
    {
      sub_1001FA3CC((uint64_t *)a1);
      __n128 result = *a2;
      *(__n128 *)a1 = *a2;
      *(void *)(a1 + 16) = a2[1].n128_u64[0];
      a2->n128_u64[0] = 0;
      a2->n128_u64[1] = 0;
      a2[1].n128_u64[0] = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    long long v5 = (void **)a1;
    sub_1001F7B70(&v5);
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    __n128 result = *a2;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

void sub_10045B434(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 32) == a2[2].n128_u8[0])
  {
    if (*(unsigned char *)(a1 + 32)) {
      sub_100179CB0(a1, a2);
    }
  }
  else if (*(unsigned char *)(a1 + 32))
  {
    sub_1001FA6AC(a1);
  }
  else
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 24) = 0;
    if (a2[1].n128_u8[8])
    {
      __n128 v2 = *a2;
      *(void *)(a1 + 16) = a2[1].n128_u64[0];
      *(__n128 *)a1 = v2;
      a2->n128_u64[1] = 0;
      a2[1].n128_u64[0] = 0;
      a2->n128_u64[0] = 0;
      *(unsigned char *)(a1 + 24) = 1;
    }
    *(unsigned char *)(a1 + 32) = 1;
  }
}

__n128 sub_10045B4BC(unsigned char *a1, uint64_t a2)
{
  long long v3 = sub_10045B61C(a1, (long long *)a2);
  v3[104] = 0;
  v3[128] = 0;
  if (*(unsigned char *)(a2 + 128))
  {
    *((void *)v3 + 13) = 0;
    *((void *)v3 + 14) = 0;
    *((void *)v3 + 15) = 0;
    __n128 result = *(__n128 *)(a2 + 104);
    *(__n128 *)(v3 + 104) = result;
    *((void *)v3 + 15) = *(void *)(a2 + 120);
    *(void *)(a2 + 104) = 0;
    *(void *)(a2 + 112) = 0;
    *(void *)(a2 + 120) = 0;
    v3[128] = 1;
  }
  v3[136] = 0;
  v3[160] = 0;
  if (*(unsigned char *)(a2 + 160))
  {
    *((void *)v3 + 17) = 0;
    *((void *)v3 + 18) = 0;
    *((void *)v3 + 19) = 0;
    __n128 result = *(__n128 *)(a2 + 136);
    *(__n128 *)(v3 + 136) = result;
    *((void *)v3 + 19) = *(void *)(a2 + 152);
    *(void *)(a2 + 136) = 0;
    *(void *)(a2 + 144) = 0;
    *(void *)(a2 + 152) = 0;
    v3[160] = 1;
  }
  v3[168] = 0;
  v3[200] = 0;
  if (*(unsigned char *)(a2 + 200))
  {
    v3[192] = 0;
    if (*(unsigned char *)(a2 + 192))
    {
      __n128 result = *(__n128 *)(a2 + 168);
      *((void *)v3 + 23) = *(void *)(a2 + 184);
      *(__n128 *)(v3 + 168) = result;
      *(void *)(a2 + 176) = 0;
      *(void *)(a2 + 184) = 0;
      *(void *)(a2 + 168) = 0;
      v3[192] = 1;
    }
    v3[200] = 1;
  }
  v3[208] = 0;
  v3[232] = 0;
  if (*(unsigned char *)(a2 + 232))
  {
    *((void *)v3 + 26) = 0;
    *((void *)v3 + 27) = 0;
    *((void *)v3 + 28) = 0;
    __n128 result = *(__n128 *)(a2 + 208);
    *((__n128 *)v3 + 13) = result;
    *((void *)v3 + 28) = *(void *)(a2 + 224);
    *(void *)(a2 + 208) = 0;
    *(void *)(a2 + 216) = 0;
    *(void *)(a2 + 224) = 0;
    v3[232] = 1;
  }
  v3[240] = 0;
  v3[264] = 0;
  if (*(unsigned char *)(a2 + 264))
  {
    *((void *)v3 + 30) = 0;
    *((void *)v3 + 31) = 0;
    *((void *)v3 + 32) = 0;
    __n128 result = *(__n128 *)(a2 + 240);
    *((__n128 *)v3 + 15) = result;
    *((void *)v3 + 32) = *(void *)(a2 + 256);
    *(void *)(a2 + 240) = 0;
    *(void *)(a2 + 248) = 0;
    *(void *)(a2 + 256) = 0;
    v3[264] = 1;
  }
  return result;
}

unsigned char *sub_10045B61C(unsigned char *a1, long long *a2)
{
  *a1 = 0;
  a1[96] = 0;
  sub_10045B650((uint64_t)a1, a2);
  return a1;
}

__n128 sub_10045B650(uint64_t a1, long long *a2)
{
  if (*((unsigned char *)a2 + 96))
  {
    long long v2 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v2;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v3 = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(a1 + 24) = v3;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    long long v4 = a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *(_OWORD *)(a1 + 48) = v4;
    *((void *)a2 + 7) = 0;
    *((void *)a2 + 8) = 0;
    *((void *)a2 + 6) = 0;
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
    __n128 result = *(__n128 *)((char *)a2 + 72);
    *(__n128 *)(a1 + 72) = result;
    *(void *)(a1 + 88) = *((void *)a2 + 11);
    *((void *)a2 + 9) = 0;
    *((void *)a2 + 10) = 0;
    *((void *)a2 + 11) = 0;
    *(unsigned char *)(a1 + 96) = 1;
  }
  return result;
}

__n128 sub_10045B6CC(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(unsigned char *)(a1 + 24))
    {
      sub_1001FA7BC((void **)a1);
      __n128 result = *a2;
      *(__n128 *)a1 = *a2;
      *(void *)(a1 + 16) = a2[1].n128_u64[0];
      a2->n128_u64[0] = 0;
      a2->n128_u64[1] = 0;
      a2[1].n128_u64[0] = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    long long v5 = (void **)a1;
    sub_1001F9EFC(&v5);
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    __n128 result = *a2;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

double sub_10045B770(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 272) = 0;
  if (*(unsigned char *)(a2 + 272))
  {
    v3.n128_u64[0] = sub_10045B4BC((unsigned char *)a1, a2).n128_u64[0];
    *(unsigned char *)(a1 + 272) = 1;
  }
  *(unsigned char *)(a1 + 280) = 0;
  *(unsigned char *)(a1 + 304) = 0;
  if (*(unsigned char *)(a2 + 304))
  {
    __n128 v3 = *(__n128 *)(a2 + 280);
    *(void *)(a1 + 296) = *(void *)(a2 + 296);
    *(__n128 *)(a1 + 280) = v3;
    *(void *)(a2 + 288) = 0;
    *(void *)(a2 + 296) = 0;
    *(void *)(a2 + 280) = 0;
    *(unsigned char *)(a1 + 304) = 1;
  }
  *(unsigned char *)(a1 + 312) = 0;
  *(unsigned char *)(a1 + 336) = 0;
  if (*(unsigned char *)(a2 + 336))
  {
    __n128 v3 = *(__n128 *)(a2 + 312);
    *(void *)(a1 + 328) = *(void *)(a2 + 328);
    *(__n128 *)(a1 + 312) = v3;
    *(void *)(a2 + 320) = 0;
    *(void *)(a2 + 328) = 0;
    *(void *)(a2 + 312) = 0;
    *(unsigned char *)(a1 + 336) = 1;
  }
  *(unsigned char *)(a1 + 344) = 0;
  *(unsigned char *)(a1 + 368) = 0;
  if (*(unsigned char *)(a2 + 368))
  {
    __n128 v3 = *(__n128 *)(a2 + 344);
    *(void *)(a1 + 360) = *(void *)(a2 + 360);
    *(__n128 *)(a1 + 344) = v3;
    *(void *)(a2 + 352) = 0;
    *(void *)(a2 + 360) = 0;
    *(void *)(a2 + 344) = 0;
    *(unsigned char *)(a1 + 368) = 1;
  }
  *(unsigned char *)(a1 + 376) = 0;
  *(unsigned char *)(a1 + 400) = 0;
  if (*(unsigned char *)(a2 + 400))
  {
    __n128 v3 = *(__n128 *)(a2 + 376);
    *(void *)(a1 + 392) = *(void *)(a2 + 392);
    *(__n128 *)(a1 + 376) = v3;
    *(void *)(a2 + 384) = 0;
    *(void *)(a2 + 392) = 0;
    *(void *)(a2 + 376) = 0;
    *(unsigned char *)(a1 + 400) = 1;
  }
  *(unsigned char *)(a1 + 408) = 0;
  *(unsigned char *)(a1 + 432) = 0;
  if (*(unsigned char *)(a2 + 432))
  {
    __n128 v3 = *(__n128 *)(a2 + 408);
    *(void *)(a1 + 424) = *(void *)(a2 + 424);
    *(__n128 *)(a1 + 408) = v3;
    *(void *)(a2 + 416) = 0;
    *(void *)(a2 + 424) = 0;
    *(void *)(a2 + 408) = 0;
    *(unsigned char *)(a1 + 432) = 1;
  }
  *(unsigned char *)(a1 + 440) = 0;
  *(unsigned char *)(a1 + 464) = 0;
  if (*(unsigned char *)(a2 + 464))
  {
    __n128 v3 = *(__n128 *)(a2 + 440);
    *(void *)(a1 + 456) = *(void *)(a2 + 456);
    *(__n128 *)(a1 + 440) = v3;
    *(void *)(a2 + 448) = 0;
    *(void *)(a2 + 456) = 0;
    *(void *)(a2 + 440) = 0;
    *(unsigned char *)(a1 + 464) = 1;
  }
  *(unsigned char *)(a1 + 472) = 0;
  *(unsigned char *)(a1 + 496) = 0;
  if (*(unsigned char *)(a2 + 496))
  {
    __n128 v3 = *(__n128 *)(a2 + 472);
    *(void *)(a1 + 488) = *(void *)(a2 + 488);
    *(__n128 *)(a1 + 472) = v3;
    *(void *)(a2 + 480) = 0;
    *(void *)(a2 + 488) = 0;
    *(void *)(a2 + 472) = 0;
    *(unsigned char *)(a1 + 496) = 1;
  }
  *(unsigned char *)(a1 + 504) = 0;
  *(unsigned char *)(a1 + 528) = 0;
  if (*(unsigned char *)(a2 + 528))
  {
    __n128 v3 = *(__n128 *)(a2 + 504);
    *(void *)(a1 + 520) = *(void *)(a2 + 520);
    *(__n128 *)(a1 + 504) = v3;
    *(void *)(a2 + 520) = 0;
    *(void *)(a2 + 504) = 0;
    *(void *)(a2 + 512) = 0;
    *(unsigned char *)(a1 + 528) = 1;
  }
  *(unsigned char *)(a1 + 536) = 0;
  *(unsigned char *)(a1 + 560) = 0;
  if (*(unsigned char *)(a2 + 560))
  {
    *(void *)(a1 + 552) = 0;
    v3.n128_u64[0] = 0;
    *(_OWORD *)(a1 + 536) = 0u;
    *(void *)(a1 + 536) = *(void *)(a2 + 536);
    *(void *)(a1 + 544) = *(void *)(a2 + 544);
    *(void *)(a1 + 552) = *(void *)(a2 + 552);
    *(void *)(a2 + 552) = 0;
    *(_OWORD *)(a2 + 536) = 0u;
    *(unsigned char *)(a1 + 560) = 1;
  }
  return v3.n128_f64[0];
}

uint64_t sub_10045B9BC(uint64_t a1)
{
  (*(void (**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(v4);
  uint64_t v2 = *(void *)(a1 + 32);
  sub_10045AD70(v2, (uint64_t)v4);
  *(_DWORD *)(v2 + 696) = v5;
  return sub_1001FA0E0((uint64_t)v4);
}

uint64_t sub_10045BA1C(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 40);
  uint64_t v2 = (void **)*((void *)v1 + 24);
  __n128 v3 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *v1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = v1 + 4;
    if (*((char *)v1 + 39) < 0) {
      long long v4 = (void *)*v4;
    }
    *(_DWORD *)buf = 136380931;
    *(void *)&uint8_t buf[4] = v4;
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = Lazuli::asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [report-spam] destination uri: %{private}s, spam type: %{public}s", buf, 0x16u);
  }
  long long v35 = 0u;
  memset(v36, 0, sizeof(v36));
  long long v33 = 0u;
  long long v34 = 0u;
  *(_OWORD *)v31 = 0u;
  long long v32 = 0u;
  long long v30 = 0u;
  memset(buf, 0, sizeof(buf));
  (*(void (**)(uint8_t *__return_ptr))(*v2[15] + 96))(buf);
  *(_OWORD *)__int16 v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  *(_OWORD *)__int16 v17 = 0u;
  *(_OWORD *)uint64_t v14 = 0u;
  long long v15 = 0u;
  *(_OWORD *)long long v12 = 0u;
  long long v13 = 0u;
  sub_1004548F8((uint64_t)v12, (uint64_t)(v1 + 2));
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  *(_OWORD *)std::string __p = 0u;
  *(_OWORD *)long long v24 = 0u;
  sub_100453DF4((uint64_t)v24, (long long *)&buf[16]);
  if (BYTE8(v28))
  {
    if ((_BYTE)v28)
    {
      uint64_t v5 = HIBYTE(v27);
      if (v27 < 0) {
        uint64_t v5 = v27;
      }
      if (v5)
      {
        sub_100179AF8((std::string *)v14, (const std::string *)&__p[1]);
        long long v6 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *v1);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          if (!BYTE8(v15)) {
            sub_10016C840();
          }
          if ((SBYTE7(v15) & 0x80u) == 0) {
            __int16 v7 = v14;
          }
          else {
            __int16 v7 = (void **)v14[0];
          }
          *(_DWORD *)long long v22 = 136446210;
          long long v23 = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [report-spam] updated spam reporting uri to: %{public}s", v22, 0xCu);
        }
      }
    }
    if (BYTE8(v28) && (_BYTE)v28 && SHIBYTE(v27) < 0) {
      operator delete(__p[1]);
    }
  }
  uint64_t v8 = (*(uint64_t (**)(void *, void, void **, unsigned int *))(*v2[19] + 168))(v2[19], *v1, v12, v1 + 42);
  uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *v1);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if ((v8 & 0xFF00000000) != 0) {
      long long v10 = (const char *)Lazuli::asString();
    }
    else {
      long long v10 = "OK";
    }
    *(_DWORD *)long long v24 = 136315138;
    *(void *)&v24[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [report-spam] status: %s", v24, 0xCu);
  }
  if (BYTE8(v21) && SBYTE7(v21) < 0) {
    operator delete(v20[0]);
  }
  if ((_BYTE)v19 && SHIBYTE(v18) < 0) {
    operator delete(v17[1]);
  }
  *(void *)long long v24 = &v16;
  sub_100047F64((void ***)v24);
  if (BYTE8(v15) && SBYTE7(v15) < 0) {
    operator delete(v14[0]);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[1]);
  }
  sub_10039BE98((uint64_t)&v36[14] + 8);
  sub_10039BEEC((uint64_t)v36 + 8);
  if (BYTE8(v33) && (_BYTE)v33 && SHIBYTE(v32) < 0) {
    operator delete(v31[1]);
  }
  return v8;
}

void sub_10045BE30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *__p,uint64_t a49,int a50,__int16 a51,char a52,char a53,char a54,int a55,__int16 a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if ((_BYTE)a56 && a54 && a53 < 0) {
    operator delete(__p);
  }
  if (a40 && a39 < 0) {
    operator delete(a34);
  }
  if (a32 && a31 < 0) {
    operator delete(a26);
  }
  a43 = (uint64_t)&a23;
  sub_100047F64((void ***)&a43);
  if (a22 && a21 < 0) {
    operator delete(a16);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  sub_10039BE98((uint64_t)&STACK[0x268]);
  sub_10039BEEC((uint64_t)&a73);
  if ((_BYTE)a72 && a70 && a69 < 0) {
    operator delete(a64);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10045BF28(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  __n128 v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = (const char *)(v1 + 2);
    if (*((char *)v1 + 39) < 0) {
      long long v4 = *(const char **)v4;
    }
    uint64_t v5 = v1 + 16;
    if (*((char *)v1 + 151) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    int v10 = 136380931;
    long long v11 = v4;
    __int16 v12 = 2082;
    long long v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [send-response-for-action] start destination: %{private}s, messageID: %{public}s", (uint8_t *)&v10, 0x16u);
  }
  uint64_t v6 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *, uint64_t *))(**(void **)(v2 + 152) + 160))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 16, v1 + 19);
  __int16 v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if ((v6 & 0xFF00000000) != 0) {
      uint64_t v8 = (const char *)Lazuli::asString();
    }
    else {
      uint64_t v8 = "OK";
    }
    int v10 = 136315138;
    long long v11 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [send-response-for-action] status: %s", (uint8_t *)&v10, 0xCu);
  }
  return v6;
}

uint64_t sub_10045C0F8(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  __n128 v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = (const char *)(v1 + 2);
    if (*((char *)v1 + 39) < 0) {
      long long v4 = *(const char **)v4;
    }
    uint64_t v5 = v1 + 16;
    if (*((char *)v1 + 151) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    int v10 = 136380931;
    long long v11 = v4;
    __int16 v12 = 2082;
    long long v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [send-device-settings] start destination: %{private}s, messageID: %{public}s", (uint8_t *)&v10, 0x16u);
  }
  uint64_t v6 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *, uint64_t *))(**(void **)(v2 + 152) + 176))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 16, v1 + 19);
  __int16 v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if ((v6 & 0xFF00000000) != 0) {
      uint64_t v8 = (const char *)Lazuli::asString();
    }
    else {
      uint64_t v8 = "OK";
    }
    int v10 = 136315138;
    long long v11 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [send-device-settings] status: %s", (uint8_t *)&v10, 0xCu);
  }
  return v6;
}

uint64_t sub_10045C2C8(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  __n128 v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = (const char *)(v1 + 2);
    if (*((char *)v1 + 39) < 0) {
      long long v4 = *(const char **)v4;
    }
    uint64_t v5 = v1 + 16;
    if (*((char *)v1 + 151) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    int v10 = 136380931;
    long long v11 = v4;
    __int16 v12 = 2082;
    long long v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [send-device-action] start destination: %{private}s, messageID: %{public}s", (uint8_t *)&v10, 0x16u);
  }
  uint64_t v6 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *, uint64_t *))(**(void **)(v2 + 152) + 184))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 16, v1 + 19);
  __int16 v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if ((v6 & 0xFF00000000) != 0) {
      uint64_t v8 = (const char *)Lazuli::asString();
    }
    else {
      uint64_t v8 = "OK";
    }
    int v10 = 136315138;
    long long v11 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [send-device-action] status: %s", (uint8_t *)&v10, 0xCu);
  }
  return v6;
}

uint64_t sub_10045C498(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  __n128 v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = (const char *)(v1 + 2);
    if (*((char *)v1 + 39) < 0) {
      long long v4 = *(const char **)v4;
    }
    uint64_t v5 = v1 + 16;
    if (*((char *)v1 + 151) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    uint64_t v6 = v1 + 19;
    if (*((char *)v1 + 175) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    int v11 = 136381187;
    __int16 v12 = v4;
    __int16 v13 = 2082;
    uint64_t v14 = v5;
    __int16 v15 = 2082;
    long long v16 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [revoke] start destination: %{private}s, for messageID: %{public}s, with ID: %{public}s", (uint8_t *)&v11, 0x20u);
  }
  uint64_t v7 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *))(**(void **)(v2 + 152) + 144))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 19);
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if ((v7 & 0xFF00000000) != 0) {
      uint64_t v9 = (const char *)Lazuli::asString();
    }
    else {
      uint64_t v9 = "OK";
    }
    int v11 = 136315138;
    __int16 v12 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [revoke] status: %s", (uint8_t *)&v11, 0xCu);
  }
  return v7;
}

uint64_t sub_10045C67C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  __n128 v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = (const char *)(v1 + 5);
    if (*((char *)v1 + 63) < 0) {
      long long v4 = *(const char **)v4;
    }
    uint64_t v5 = v1 + 11;
    if (*((char *)v1 + 111) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    sub_100459370(__p, (uint64_t)(v1 + 14));
    if (v14 >= 0) {
      uint64_t v6 = __p;
    }
    else {
      uint64_t v6 = (void **)__p[0];
    }
    *(_DWORD *)buf = 136381187;
    long long v16 = v4;
    __int16 v17 = 2082;
    long long v18 = v5;
    __int16 v19 = 2082;
    __int16 v20 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [send-group-composing] start destination: %{private}s, messageID: %{public}s info: %{public}s", buf, 0x20u);
    if (v14 < 0) {
      operator delete(__p[0]);
    }
  }
  unsigned int v8 = *((_DWORD *)v1 + 2);
  uint64_t v7 = (unsigned int *)(v1 + 1);
  uint64_t v9 = (*(uint64_t (**)(void, void, unsigned int *, unsigned int *, unsigned int *))(**(void **)(v2 + 152)
                                                                                                 + 192))(*(void *)(v2 + 152), v8, v7 + 2, v7 + 20, v7 + 26);
  int v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v7);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    if ((v9 & 0xFF00000000) != 0) {
      int v11 = (const char *)Lazuli::asString();
    }
    else {
      int v11 = "OK";
    }
    *(_DWORD *)buf = 136315138;
    long long v16 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [send-group-composing] status: %s", buf, 0xCu);
  }
  return v9;
}

uint64_t sub_10045C890(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  __n128 v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = (const char *)(v1 + 5);
    if (*((char *)v1 + 63) < 0) {
      long long v4 = *(const char **)v4;
    }
    uint64_t v5 = v1 + 11;
    if (*((char *)v1 + 111) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    int v6 = *((unsigned __int8 *)v1 + 192);
    int v12 = 136381187;
    if (v6) {
      uint64_t v7 = "YES";
    }
    else {
      uint64_t v7 = "NO";
    }
    __int16 v13 = v4;
    __int16 v14 = 2082;
    __int16 v15 = v5;
    __int16 v16 = 2080;
    __int16 v17 = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [send-group-text] start destination: %{private}s, messageID: %{public}s, metaData: %s", (uint8_t *)&v12, 0x20u);
  }
  uint64_t v8 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *, uint64_t *))(**(void **)(v2 + 152) + 200))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 11, v1 + 14);
  uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if ((v8 & 0xFF00000000) != 0) {
      int v10 = (const char *)Lazuli::asString();
    }
    else {
      int v10 = "OK";
    }
    int v12 = 136315138;
    __int16 v13 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [send-group-text] status: %s", (uint8_t *)&v12, 0xCu);
  }
  return v8;
}

uint64_t sub_10045CA88(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  BOOL v3 = sub_10044DBD0(*(void *)(*v1 + 120));
  long long v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (const char *)(v1 + 5);
    if (*((char *)v1 + 63) < 0) {
      uint64_t v5 = *(const char **)v5;
    }
    int v6 = v1 + 11;
    if (*((char *)v1 + 111) < 0) {
      int v6 = (void *)*v6;
    }
    int v7 = *((unsigned __int8 *)v1 + 216);
    int v14 = 136381443;
    if (v7) {
      uint64_t v8 = "true";
    }
    else {
      uint64_t v8 = "false";
    }
    __int16 v15 = v5;
    __int16 v16 = 2082;
    if (v3) {
      uint64_t v9 = "true";
    }
    else {
      uint64_t v9 = "false";
    }
    __int16 v17 = v6;
    __int16 v18 = 2080;
    __int16 v19 = v8;
    __int16 v20 = 2080;
    long long v21 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [send-group-geolocation] start destination: %{private}s, messageID: %{public}s, metaData: %s, useGeoSms: %s", (uint8_t *)&v14, 0x2Au);
  }
  uint64_t v10 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *, uint64_t *, BOOL))(**(void **)(v2 + 152)
                                                                                           + 216))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 11, v1 + 14, v3);
  int v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if ((v10 & 0xFF00000000) != 0) {
      int v12 = (const char *)Lazuli::asString();
    }
    else {
      int v12 = "OK";
    }
    int v14 = 136315138;
    __int16 v15 = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [send-group-geolocation] status: %s", (uint8_t *)&v14, 0xCu);
  }
  return v10;
}

uint64_t sub_10045CCA4(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  BOOL v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = (const char *)(v1 + 5);
    if (*((char *)v1 + 63) < 0) {
      long long v4 = *(const char **)v4;
    }
    uint64_t v5 = v1 + 11;
    if (*((char *)v1 + 111) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    int v6 = *((unsigned __int8 *)v1 + 416);
    int v12 = 136381187;
    if (v6) {
      int v7 = "YES";
    }
    else {
      int v7 = "NO";
    }
    __int16 v13 = v4;
    __int16 v14 = 2082;
    __int16 v15 = v5;
    __int16 v16 = 2080;
    __int16 v17 = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [send-group-file] start destination: %{private}s, messageID: %{public}s, metaData: %s", (uint8_t *)&v12, 0x20u);
  }
  uint64_t v8 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *, uint64_t *))(**(void **)(v2 + 152) + 224))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 11, v1 + 14);
  uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if ((v8 & 0xFF00000000) != 0) {
      uint64_t v10 = (const char *)Lazuli::asString();
    }
    else {
      uint64_t v10 = "OK";
    }
    int v12 = 136315138;
    __int16 v13 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [send-group-file] status: %s", (uint8_t *)&v12, 0xCu);
  }
  return v8;
}

uint64_t sub_10045CE9C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  BOOL v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = (const char *)(v1 + 5);
    if (*((char *)v1 + 63) < 0) {
      long long v4 = *(const char **)v4;
    }
    uint64_t v5 = v1 + 11;
    if (*((char *)v1 + 111) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    uint64_t v6 = Lazuli::asString();
    int v7 = v1 + 29;
    if (*((char *)v1 + 255) < 0) {
      int v7 = (void *)*v7;
    }
    int v12 = 136381443;
    __int16 v13 = v4;
    __int16 v14 = 2082;
    __int16 v15 = v5;
    __int16 v16 = 2082;
    uint64_t v17 = v6;
    __int16 v18 = 2082;
    __int16 v19 = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [send-group-disposition] start destination: %{private}s, messageID: %{public}s, ntf: %{public}s, for: %{public}s", (uint8_t *)&v12, 0x2Au);
  }
  uint64_t v8 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *, uint64_t *, uint64_t *))(**(void **)(v2 + 152)
                                                                                             + 208))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 14, v1 + 11, v1 + 28);
  uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if ((v8 & 0xFF00000000) != 0) {
      uint64_t v10 = (const char *)Lazuli::asString();
    }
    else {
      uint64_t v10 = "OK";
    }
    int v12 = 136315138;
    __int16 v13 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [send-group-disposition] status: %s", (uint8_t *)&v12, 0xCu);
  }
  return v8;
}

uint64_t sub_10045D0A0(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  BOOL v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), v1[2]);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [create-group-chat] start...", (uint8_t *)&v8, 2u);
  }
  uint64_t v4 = (*(uint64_t (**)(void, void, unsigned int *, unsigned int *))(**(void **)(v2 + 152) + 232))(*(void *)(v2 + 152), v1[2], v1 + 4, v1 + 84);
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if ((v4 & 0xFF00000000) != 0) {
      uint64_t v6 = (const char *)Lazuli::asString();
    }
    else {
      uint64_t v6 = "OK";
    }
    int v8 = 136315138;
    uint64_t v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [create-group-chat] status: %s", (uint8_t *)&v8, 0xCu);
  }
  return v4;
}

uint64_t sub_10045D234(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  BOOL v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (const char *)(v1 + 5);
    if (*((char *)v1 + 63) < 0) {
      uint64_t v4 = *(const char **)v4;
    }
    uint64_t v5 = (v1[15] - v1[14]) >> 5;
    uint64_t v6 = v1 + 17;
    if (*((char *)v1 + 159) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    int v11 = 136381187;
    int v12 = v4;
    __int16 v13 = 2048;
    uint64_t v14 = v5;
    __int16 v15 = 2082;
    __int16 v16 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [add-group-participants] start destination: %{private}s, count: %zu, operationID: %{public}s", (uint8_t *)&v11, 0x20u);
  }
  uint64_t v7 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *, uint64_t *))(**(void **)(v2 + 152) + 240))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 11, v1 + 17);
  int v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if ((v7 & 0xFF00000000) != 0) {
      uint64_t v9 = (const char *)Lazuli::asString();
    }
    else {
      uint64_t v9 = "OK";
    }
    int v11 = 136315138;
    int v12 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [add-group-participants] status: %s", (uint8_t *)&v11, 0xCu);
  }
  return v7;
}

uint64_t sub_10045D41C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  BOOL v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (const char *)(v1 + 5);
    if (*((char *)v1 + 63) < 0) {
      uint64_t v4 = *(const char **)v4;
    }
    uint64_t v5 = (v1[15] - v1[14]) >> 5;
    uint64_t v6 = v1 + 17;
    if (*((char *)v1 + 159) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    int v11 = 136381187;
    int v12 = v4;
    __int16 v13 = 2048;
    uint64_t v14 = v5;
    __int16 v15 = 2082;
    __int16 v16 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [remove-group-participants] start destination: %{private}s, count: %zu, operationID: %{public}s", (uint8_t *)&v11, 0x20u);
  }
  uint64_t v7 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *, uint64_t *))(**(void **)(v2 + 152) + 248))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 11, v1 + 17);
  int v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if ((v7 & 0xFF00000000) != 0) {
      uint64_t v9 = (const char *)Lazuli::asString();
    }
    else {
      uint64_t v9 = "OK";
    }
    int v11 = 136315138;
    int v12 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [remove-group-participants] status: %s", (uint8_t *)&v11, 0xCu);
  }
  return v7;
}

uint64_t sub_10045D604(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  BOOL v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (const char *)(v1 + 5);
    if (*((char *)v1 + 63) < 0) {
      uint64_t v4 = *(const char **)v4;
    }
    uint64_t v5 = v1 + 11;
    if (*((char *)v1 + 111) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    uint64_t v6 = v1 + 14;
    if (*((char *)v1 + 135) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    int v11 = 136381443;
    int v12 = v4;
    __int16 v13 = 2160;
    uint64_t v14 = 1752392040;
    __int16 v15 = 2085;
    __int16 v16 = v5;
    __int16 v17 = 2082;
    __int16 v18 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [change-group-subject] start destination: %{private}s, subject: %{sensitive, mask.hash}s, operationID: %{public}s", (uint8_t *)&v11, 0x2Au);
  }
  uint64_t v7 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *, uint64_t *))(**(void **)(v2 + 152) + 256))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 11, v1 + 14);
  int v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if ((v7 & 0xFF00000000) != 0) {
      uint64_t v9 = (const char *)Lazuli::asString();
    }
    else {
      uint64_t v9 = "OK";
    }
    int v11 = 136315138;
    int v12 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [change-group-subject] status: %s", (uint8_t *)&v11, 0xCu);
  }
  return v7;
}

uint64_t sub_10045D80C(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  BOOL v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), v1[2]);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [change-group-icon] start...", (uint8_t *)&v8, 2u);
  }
  uint64_t v4 = (*(uint64_t (**)(void, void, unsigned int *, unsigned int *, unsigned int *))(**(void **)(v2 + 152)
                                                                                                 + 264))(*(void *)(v2 + 152), v1[2], v1 + 4, v1 + 22, v1 + 40);
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if ((v4 & 0xFF00000000) != 0) {
      uint64_t v6 = (const char *)Lazuli::asString();
    }
    else {
      uint64_t v6 = "OK";
    }
    int v8 = 136315138;
    uint64_t v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [change-group-icon] status: %s", (uint8_t *)&v8, 0xCu);
  }
  return v4;
}

uint64_t sub_10045D9AC(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  BOOL v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (const char *)(v1 + 5);
    if (*((char *)v1 + 63) < 0) {
      uint64_t v4 = *(const char **)v4;
    }
    uint64_t v5 = v1 + 11;
    if (*((char *)v1 + 111) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    int v10 = 136380931;
    int v11 = v4;
    __int16 v12 = 2082;
    __int16 v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [exit-group-chat] start destination: %{private}s, operationID: %{public}s", (uint8_t *)&v10, 0x16u);
  }
  uint64_t v6 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *))(**(void **)(v2 + 152) + 272))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2, v1 + 11);
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if ((v6 & 0xFF00000000) != 0) {
      int v8 = (const char *)Lazuli::asString();
    }
    else {
      int v8 = "OK";
    }
    int v10 = 136315138;
    int v11 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [exit-group-chat] status: %s", (uint8_t *)&v10, 0xCu);
  }
  return v6;
}

void sub_10045DB80(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  BOOL v3 = *(uint64_t **)(a1 + 40);
  uint64_t v4 = *v3;
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v3 + 48) + 16))(*(void *)(*v3 + 48), *((unsigned int *)v3 + 2));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = v3 + 2;
    if (*((char *)v3 + 39) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    int v11 = 141558275;
    uint64_t v12 = 1752392040;
    __int16 v13 = 2085;
    uint64_t v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [decode-deep-link] start destination: %{sensitive, mask.hash}s", (uint8_t *)&v11, 0x16u);
  }
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  unsigned int v8 = *((_DWORD *)v3 + 2);
  uint64_t v7 = (unsigned int *)(v3 + 1);
  (*(void (**)(void, void, unsigned int *))(**(void **)(v4 + 168) + 80))(*(void *)(v4 + 168), v8, v7 + 2);
  uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), *v7);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a2 + 32)) {
      int v10 = "OK";
    }
    else {
      int v10 = "failed";
    }
    int v11 = 136315138;
    uint64_t v12 = (uint64_t)v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [decode-deep-link] status: %s", (uint8_t *)&v11, 0xCu);
  }
}

void sub_10045DD4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (*(unsigned char *)(v9 + 32))
  {
    if (*(unsigned char *)(v9 + 24))
    {
      a9 = v9;
      sub_100155494((void ***)&a9);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_10045DD7C(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v3);
  sub_10045DDEC(*(void *)(a1 + 32), &v3);
  if (v5) {
    BOOL v2 = v4 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2)
  {
    uint64_t v6 = &v3;
    sub_100155494((void ***)&v6);
  }
}

void sub_10045DDEC(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 32) == a2[2].n128_u8[0])
  {
    if (*(unsigned char *)(a1 + 32))
    {
      sub_100456D8C(a1, a2);
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 32))
    {
      char v3 = *(unsigned char *)(a1 + 24);
      if (v3)
      {
        char v4 = (void **)a1;
        sub_100155494(&v4);
        char v3 = 0;
      }
    }
    else
    {
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 24) = 0;
      char v3 = 1;
      if (a2[1].n128_u8[8])
      {
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 16) = 0;
        *(__n128 *)a1 = *a2;
        *(void *)(a1 + 16) = a2[1].n128_u64[0];
        a2->n128_u64[0] = 0;
        a2->n128_u64[1] = 0;
        a2[1].n128_u64[0] = 0;
        *(unsigned char *)(a1 + 24) = 1;
      }
    }
    *(unsigned char *)(a1 + 32) = v3;
  }
}

void sub_10045DEA8(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v3);
  sub_10045DDEC(*(void *)(a1 + 32), &v3);
  if (v5) {
    BOOL v2 = v4 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2)
  {
    uint64_t v6 = &v3;
    sub_100155494((void ***)&v6);
  }
}

uint64_t sub_10045DF18(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  __n128 v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    char v4 = v1 + 2;
    if (*((char *)v1 + 39) < 0) {
      char v4 = (void *)*v4;
    }
    *(_DWORD *)buf = 136380675;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [delete-chat] start destination: %{private}s", buf, 0xCu);
  }
  uint64_t v5 = (*(uint64_t (**)(void, void, uint64_t *))(**(void **)(v2 + 152) + 280))(*(void *)(v2 + 152), *((unsigned int *)v1 + 2), v1 + 2);
  uint64_t v6 = *(void *)(v2 + 184);
  uint64_t v7 = *((unsigned int *)v1 + 2);
  if (*((char *)v1 + 39) < 0)
  {
    sub_10004FC84(buf, (void *)v1[2], v1[3]);
  }
  else
  {
    *(_OWORD *)buf = *((_OWORD *)v1 + 1);
    uint64_t v13 = v1[4];
  }
  char v18 = 0;
  char v19 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  std::string __p = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v14 = 0;
  char v17 = 0;
  (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v6 + 120))(v6, v7, buf);
  if (SHIBYTE(v22) < 0) {
    operator delete(__p);
  }
  if (v19)
  {
    int v11 = (void **)&v18;
    sub_100047F64(&v11);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(v14);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(*(void **)buf);
  }
  unsigned int v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = "failed";
    if ((v5 & 0xFF00000000) == 0) {
      uint64_t v9 = "OK";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [delete-chat] status: %s", buf, 0xCu);
  }
  return v5;
}

void sub_10045E1A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a27) {
    sub_100047F64((void ***)&a10);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_10045E1F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(*(void *)v1 + 104);
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  if (*(char *)(v1 + 39) < 0)
  {
    sub_10004FC84(__p, *(void **)(v1 + 16), *(void *)(v1 + 24));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(v1 + 16);
    uint64_t v5 = *(void *)(v1 + 32);
  }
  (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v2 + 64))(v2, v3, __p);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10045E294(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10045E2B0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 40) + 104) + 72))(*(void *)(**(void **)(a1 + 40) + 104), *(unsigned int *)(*(void *)(a1 + 40) + 8));
}

void sub_10045E2E4(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&__p);
  sub_100179CB0(*(void *)(a1 + 32), &__p);
  if (v4)
  {
    if (v3 < 0) {
      operator delete((void *)__p.n128_u64[0]);
    }
  }
}

void sub_10045E34C(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&__p);
  sub_100179CB0(*(void *)(a1 + 32), &__p);
  if (v4)
  {
    if (v3 < 0) {
      operator delete((void *)__p.n128_u64[0]);
    }
  }
}

uint64_t sub_10045E3B4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 40) + 120) + 72))(*(void *)(**(void **)(a1 + 40) + 120), **(unsigned int **)(*(void *)(a1 + 40) + 8));
}

uint64_t sub_10045E3E8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10045E424(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10045E460(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(**(void **)(a1 + 40) + 120) + 80))(*(void *)(**(void **)(a1 + 40) + 120), **(unsigned int **)(*(void *)(a1 + 40) + 8), *(void *)(*(void *)(a1 + 40) + 16));
}

uint64_t sub_10045E498(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(**(void **)(a1 + 40) + 120) + 88))(*(void *)(**(void **)(a1 + 40) + 120), **(unsigned int **)(*(void *)(a1 + 40) + 8), *(void *)(*(void *)(a1 + 40) + 16));
}

uint64_t *sub_10045E4D0(unsigned int **a1)
{
  uint64_t v1 = *a1;
  char v3 = a1;
  char v4 = v1;
  (*(void (**)(void, void, unsigned int *))(**(void **)(*((void *)v1 + 4) + 184) + 144))(*(void *)(*((void *)v1 + 4) + 184), *v1, v1 + 2);
  sub_10045E55C((uint64_t *)&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_10045E540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10045E55C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_10045E5B4(unsigned int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)(*(void *)v1 + 152);
  uint64_t v3 = v1[2];
  sub_100CC85C0(__dst, (uint64_t)(v1 + 4));
  sub_100CC8650(__p, (uint64_t)(v1 + 10));
  (*(void (**)(uint64_t, uint64_t, void **, void **))(*(void *)v2 + 72))(v2, v3, __dst, __p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  if (v10 < 0) {
    operator delete(__dst[0]);
  }
  sub_10045E6BC((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10045E670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  sub_10045E6BC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10045E6BC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_10045E724(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 40);
  return (*(uint64_t (**)(void, void, unsigned int *, unsigned int *, unsigned int *))(**(void **)(*(void *)v1 + 152) + 288))(*(void *)(*(void *)v1 + 152), v1[2], v1 + 4, v1 + 10, v1 + 16);
}

uint64_t sub_10045E76C(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 40);
  return (*(uint64_t (**)(void, void, unsigned int *, unsigned int *, unsigned int *))(**(void **)(*(void *)v1 + 152) + 296))(*(void *)(*(void *)v1 + 152), v1[2], v1 + 4, v1 + 10, v1 + 16);
}

uint64_t sub_10045E7B4(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 40);
  return (*(uint64_t (**)(void, void, unsigned int *, unsigned int *, unsigned int *))(**(void **)(*(void *)v1 + 152) + 304))(*(void *)(*(void *)v1 + 152), v1[2], v1 + 4, v1 + 10, v1 + 16);
}

uint64_t sub_10045E7FC(uint64_t a1, NSObject **a2, void *a3, void *a4, char *a5, long long *a6)
{
  int v11 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v17, kCtLoggingSystemName, a5);
  sub_10045E950(v11, a2, &v17);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v17);
  *(void *)a1 = off_1019CDBE0;
  *(void *)(a1 + 48) = *a3;
  uint64_t v12 = a3[1];
  *(void *)(a1 + 56) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = (unsigned char *)(a1 + 64);
  if (*((char *)a6 + 23) < 0)
  {
    sub_10004FC84(v13, *(void **)a6, *((void *)a6 + 1));
  }
  else
  {
    long long v14 = *a6;
    *(void *)(a1 + 80) = *((void *)a6 + 2);
    *(_OWORD *)uint64_t v13 = v14;
  }
  *(void *)(a1 + 88) = *a4;
  uint64_t v15 = a4[1];
  *(void *)(a1 + 96) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 16), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(void *)(a1 + 144) = 0;
  return a1;
}

void sub_10045E910(_Unwind_Exception *a1)
{
  char v4 = (std::__shared_weak_count *)v1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  CellularPlanProvisioningMonitorModeInterface::~CellularPlanProvisioningMonitorModeInterface((CellularPlanProvisioningMonitorModeInterface *)v1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 5));
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void *sub_10045E950(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_10045E9B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

CellularPlanProvisioningMonitorModeInterface *sub_10045E9DC(CellularPlanProvisioningMonitorModeInterface *this)
{
  *(void *)this = off_1019CDBE0;
  uint64_t v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    *((void *)this + 16) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *((void *)this + 14);
  *((void *)this + 14) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  char v4 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  if (*((char *)this + 87) < 0) {
    operator delete(*((void **)this + 8));
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v5) {
    sub_10004D2C8(v5);
  }
  CellularPlanProvisioningMonitorModeInterface::~CellularPlanProvisioningMonitorModeInterface(this);
  ctu::OsLogLogger::~OsLogLogger((CellularPlanProvisioningMonitorModeInterface *)((char *)this + 40));
  sub_100087E88((void *)this + 1);
  return this;
}

void sub_10045EAA8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 104))
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Operation is already started", v5, 2u);
    }
  }
  else
  {
    char v4 = (char *)(a1 + 120);
    if (a1 + 120 != a2) {
      sub_10015C6C8(v4, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
    }
    *(void *)(a1 + 144) = *(void *)(a1 + 120);
  }
}

BOOL sub_10045EB40(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 104);
  uint64_t v3 = *(NSObject **)(a1 + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Monitor mode already running", buf, 2u);
    }
  }
  else
  {
    if (v4)
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Monitor Mode Start", v6, 2u);
    }
    *(unsigned char *)(a1 + 104) = 1;
    (*(void (**)(uint64_t))(*(void *)a1 + 64))(a1);
  }
  return v2 == 0;
}

void sub_10045EC1C(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 104)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    int v6 = 136315138;
    uint64_t v7 = (uint64_t)v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Started: %s", (uint8_t *)&v6, 0xCu);
    int v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 112)) {
      BOOL v4 = "true";
    }
    else {
      BOOL v4 = "false";
    }
    int v6 = 136315138;
    uint64_t v7 = (uint64_t)v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Running: %s", (uint8_t *)&v6, 0xCu);
    int v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (uint64_t)(*(void *)(a1 + 128) - *(void *)(a1 + 120)) >> 3;
    int v6 = 134217984;
    uint64_t v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Number of Backoff: [%lu]", (uint8_t *)&v6, 0xCu);
  }
}

void sub_10045ED88(void *a1, unsigned __int16 a2)
{
  if ((a2 & 0xFF00) != 0 && (_BYTE)a2) {
    a1[16] = a1[15];
  }
  uint64_t v4 = a1[14];
  if (v4)
  {
    a1[14] = 0;
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[12];
  if (v5)
  {
    int v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = a1[11];
      if (v8) {
        (*(void (**)(uint64_t, void, void *, void *))(*(void *)v8 + 16))(v8, a2, a1 + 8, a1);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10045EE6C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10045EE80(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 72))();
}

uint64_t sub_10045EEA4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 80))();
}

void sub_10045EEC8(uint64_t a1, unsigned __int16 a2)
{
  if ((a2 & 0xFF00) != 0 && (_BYTE)a2)
  {
    uint64_t v4 = *(void (**)(void))(*(void *)a1 + 40);
    v4();
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 120);
    uint64_t v5 = *(void *)(a1 + 128);
    uint64_t v7 = v5 - v6;
    if (v5 == v6 || *(void *)(a1 + 144) == v5)
    {
      OsLogContext v17 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = v7 >> 3;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I No more backoff times (Total: %lu)", buf, 0xCu);
      }
      (*(void (**)(uint64_t, void))(*(void *)a1 + 40))(a1, a2);
    }
    else
    {
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      Registry::getTimerService(&v21, *(Registry **)(a1 + 48));
      uint64_t v8 = *(NSObject **)(a1 + 40);
      if (v21)
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Action failed, backing off", buf, 2u);
        }
        sub_10003E168(buf, (void *)(a1 + 8));
        uint64_t v9 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8])
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
          sub_10004D2C8(v9);
        }
        uint64_t v10 = v21;
        sub_100058DB0(v18, "Provisioning Monitor Mode");
        uint64_t v11 = **(void **)(a1 + 144);
        sub_10003E168(buf, (void *)(a1 + 8));
        long long v12 = *(_OWORD *)buf;
        if (*(void *)&buf[8])
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
          sub_10004D2C8(*((std::__shared_weak_count **)&v12 + 1));
        }
        *(_OWORD *)__n128 __p = *(_OWORD *)v18;
        uint64_t v24 = v19;
        v18[0] = 0;
        v18[1] = 0;
        uint64_t v19 = 0;
        long long v26 = 0;
        uint64_t v13 = operator new(0x20uLL);
        *uint64_t v13 = off_1019CDCF0;
        v13[1] = a1;
        *((_OWORD *)v13 + 1) = v12;
        long long v26 = v13;
        (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, void, uint64_t, void, uint8_t *))(*(void *)v10 + 40))(&v20, v10, __p, 0, 1000000 * v11, 0, buf);
        sub_10003B34C(buf);
        if (SHIBYTE(v24) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v14 = v20;
        uint64_t v20 = 0;
        uint64_t v15 = *(void *)(a1 + 112);
        *(void *)(a1 + 112) = v14;
        if (v15)
        {
          (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
          uint64_t v16 = v20;
          uint64_t v20 = 0;
          if (v16) {
            (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
          }
        }
        if (SHIBYTE(v19) < 0) {
          operator delete(v18[0]);
        }
        *(void *)(a1 + 144) += 8;
        if (v9) {
          std::__shared_weak_count::__release_weak(v9);
        }
      }
      else
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No timer service", buf, 2u);
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 256);
      }
      if (v22) {
        sub_10004D2C8(v22);
      }
    }
  }
}

void sub_10045F2AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10045F330(void *a1)
{
  *a1 = off_1019CDCF0;
  int v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10045F37C(void *a1)
{
  *a1 = off_1019CDCF0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10045F3E8(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019CDCF0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10045F44C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019CDCF0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10045F48C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10045F49C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10045F4DC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[2])
      {
        v5[0] = 0;
        v5[1] = 0;
        sub_10003E168(v5, (void *)(v3 + 8));
        operator new();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_10045F5E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10045F628()
{
}

void sub_10045F634(void **a1)
{
  uint64_t v1 = (void *)**a1;
  uint64_t v2 = v1[14];
  v1[14] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  (*(void (**)(void *))(*v1 + 64))(v1);
  operator delete();
}

void sub_10045F6DC()
{
}

uint64_t sub_10045F708@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t v33 = 0;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  memset(v20, 0, sizeof(v20));
  long long v19 = 0u;
  sub_10004BD84((uint64_t)&v19);
  sub_10004B96C(v20, (uint64_t)"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<resource-lists xmlns=\"urn:ietf:params:xml:ns:resource-lists\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:cp=\"urn:ietf:params:xml:ns:copyControl\">\n\t<list>\n", 210);
  if (*a1 != a1[1])
  {
    sub_10004B96C(v20, (uint64_t)"\t\t<entry uri=\"", 14);
    sub_100CC79E8();
  }
  sub_10004B96C(v20, (uint64_t)"  </list>\n</resource-lists>", 27);
  OsLogContext v17 = 0;
  uint64_t v18 = 0;
  __n128 __p = &v17;
  sub_100058DB0(v12, "Content-Disposition");
  if (SHIBYTE(v13) < 0)
  {
    sub_10004FC84(__dst, v12[0], (unint64_t)v12[1]);
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)v12;
    uint64_t v15 = v13;
  }
  sub_100058DB0(&v10, "recipient-list");
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v11, v10.__r_.__value_.__l.__data_, v10.__r_.__value_.__l.__size_);
  }
  else {
    std::string v11 = v10;
  }
  sub_1010E707C((uint64_t)&__p, __dst, &v11);
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[0]);
  }
  sub_10004BC98((uint64_t)&v20[1], __dst);
  sub_100CC8650(a2, (uint64_t)__dst);
  sub_100058DB0(v12, "application/resource-lists+xml");
  sub_100CC8934(a2 + 5, (uint64_t)v12);
  uint64_t v5 = __p;
  uint64_t v4 = v17;
  a2[11] = v17;
  uint64_t v6 = a2 + 11;
  a2[10] = v5;
  uint64_t v7 = v18;
  a2[12] = v18;
  if (v7)
  {
    v4[2] = v6;
    __n128 __p = &v17;
    OsLogContext v17 = 0;
    uint64_t v18 = 0;
  }
  else
  {
    a2[10] = v6;
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[0]);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__dst[0]);
  }
  sub_10010C0E0((uint64_t)&__p, v17);
  *(void *)((char *)&v20[-2]
  v20[0] = v8;
  if (SHIBYTE(v22) < 0) {
    operator delete(*((void **)&v21 + 1));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10045FAE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,void *a35,int a36,__int16 a37,char a38,char a39,char a40)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  sub_10010C0E0((uint64_t)&a34, a35);
  sub_10008248C((uint64_t)&a40);
  _Unwind_Resume(a1);
}

void sub_10045FBD0()
{
  long long v0 = 0uLL;
  operator new();
}

void *sub_10045FC60(void *a1)
{
  *a1 = off_1019CDD70;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10045FCAC(void *a1)
{
  *a1 = off_1019CDD70;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_10045FD18(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 8);
  v4[0] = off_1019CDE58;
  v4[3] = v4;
  sub_100043ED0((uint64_t)v4, *v1);
  return sub_100043E48(v4);
}

void sub_10045FDB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_10045FDD0(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 8);
  v4[0] = off_1019CDED8;
  v4[3] = v4;
  sub_100043ED0((uint64_t)v4, *v1);
  return sub_100043E48(v4);
}

void sub_10045FE6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_10045FE88(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 8);
  v4[0] = off_1019CDF58;
  v4[3] = v4;
  sub_100043ED0((uint64_t)v4, *v1);
  return sub_100043E48(v4);
}

void sub_10045FF24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_10045FF40(uint64_t a1, char a2)
{
  char v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_1019CDFD8;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_10045FFE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100460000(uint64_t a1, uint64_t a2, char a3)
{
  char v6 = a3;
  uint64_t v3 = *(void ***)(a1 + 8);
  uint64_t v7 = a2;
  v8[0] = off_1019CE058;
  v8[1] = &v7;
  v8[2] = &v6;
  v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_1004600AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1004600C8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v5 = a2;
  v6[0] = off_1019CE0D8;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_10046016C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100460188(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v5 = a2;
  v6[0] = off_1019CE158;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_10046022C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100460248(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1004602B0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 64))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004602EC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100460324(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 64))();
  }
  return result;
}

uint64_t sub_100460354(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10046039C()
{
}

void *sub_1004603B0()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1019CDE58;
  return result;
}

void sub_1004603E8(uint64_t a1, void *a2)
{
  *a2 = off_1019CDE58;
}

id sub_100460410(uint64_t a1, id *a2)
{
  return [*a2 stewieSupportChanged];
}

uint64_t sub_100460418(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100460458()
{
}

void sub_100460468()
{
}

void *sub_10046047C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1019CDED8;
  return result;
}

void sub_1004604B4(uint64_t a1, void *a2)
{
  *a2 = off_1019CDED8;
}

id sub_1004604DC(uint64_t a1, id *a2)
{
  return [*a2 transportKeysChanged];
}

uint64_t sub_1004604E4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100460524()
{
}

void sub_100460534()
{
}

void *sub_100460548()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1019CDF58;
  return result;
}

void sub_100460580(uint64_t a1, void *a2)
{
  *a2 = off_1019CDF58;
}

id sub_1004605A8(uint64_t a1, id *a2)
{
  return [*a2 satelliteMsgCfgChanged];
}

uint64_t sub_1004605B0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1004605F0()
{
}

void sub_100460600()
{
}

void *sub_100460614(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1019CDFD8;
  result[1] = v3;
  return result;
}

uint64_t sub_10046065C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019CDFD8;
  a2[1] = v2;
  return result;
}

id sub_100460688(uint64_t a1, id *a2)
{
  return [*a2 dedicatedBearerSupportChanged:**(unsigned __int8 **)(a1 + 8)];
}

uint64_t sub_10046069C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004606DC()
{
}

void sub_1004606EC()
{
}

__n128 sub_100460700(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019CE058;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10046074C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019CE058;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

id sub_10046077C(uint64_t a1, id *a2)
{
  return [*a2 dedicatedBearerAdded:**(void **)(a1 + 8) success:**(unsigned __int8 **)(a1 + 16)];
}

uint64_t sub_100460794(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004607D4()
{
}

void sub_1004607E4()
{
}

void *sub_1004607F8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019CE0D8;
  result[1] = v3;
  return result;
}

uint64_t sub_100460840(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019CE0D8;
  a2[1] = v2;
  return result;
}

id sub_10046086C(uint64_t a1, id *a2)
{
  return [*a2 dedicatedBearedRemoved:**(void **)(a1 + 8)];
}

uint64_t sub_100460880(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004608C0()
{
}

void sub_1004608D0()
{
}

void *sub_1004608E4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019CE158;
  result[1] = v3;
  return result;
}

uint64_t sub_10046092C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019CE158;
  a2[1] = v2;
  return result;
}

void sub_100460958(uint64_t a1, id *a2)
{
  id v5 = *a2;
  if (**(void **)(a1 + 8))
  {
    uint64_t v3 = objc_opt_new();
    [v3 setBitRateMaxUL:***(void ***)(a1 + 8)];
    [v3 setBitRateMaxDL:*(void *)(**(void **)(a1 + 8) + 8)];
    [v3 setBitRateGuaranteedUL:*(void *)(**(void **)(a1 + 8) + 16)];
    uint64_t v4 = v3;
    [v3 setBitRateGuaranteedDL:*(void *)(**(void **)(a1 + 8) + 24)];
  }
  else
  {
    uint64_t v4 = 0;
  }
  [v5 qoSLinkCharacteristicsChanged:v4];
}

void sub_100460A3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100460A54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100460A94()
{
}

void sub_100460AA0()
{
}

void sub_100460B84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object)
{
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v13) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100460BC4(uint64_t a1, void *a2, const char *a3, NSObject **a4, unsigned int a5, void *a6)
{
  int v9 = (int)a3;
  long long v12 = (void *)(a1 + 8);
  int v13 = (const char *)kCtLoggingSystemName;
  uint64_t v14 = sub_100460CEC(a3, a5);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v19, v13, v14);
  sub_100460D90(v12, a4, &v19);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
  *(void *)a1 = off_1019CE1D8;
  *(void *)(a1 + 48) = *a2;
  uint64_t v15 = a2[1];
  *(void *)(a1 + 56) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 64) = v9;
  uint64_t v16 = *a4;
  *(void *)(a1 + 72) = *a4;
  if (v16) {
    dispatch_retain(v16);
  }
  *(_DWORD *)(a1 + 80) = a5;
  *(void *)(a1 + 88) = *a6;
  uint64_t v17 = a6[1];
  *(void *)(a1 + 96) = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 104) = 0;
  return a1;
}

void sub_100460CD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

const char *sub_100460CEC(const char *result, unsigned int a2)
{
  switch((int)result)
  {
    case 0:
    case 3:
      if (a2 <= 9)
      {
        uint64_t v2 = off_1019CE380;
        goto LABEL_8;
      }
      __n128 result = "DATA.BBContextTrafficBlocker.X:N:";
      break;
    case 1:
      if (a2 < 0xA)
      {
        uint64_t v2 = off_1019CE2E0;
        goto LABEL_8;
      }
      __n128 result = "DATA.BBContextTrafficBlocker.1:N:";
      break;
    case 2:
      if (a2 >= 0xA)
      {
        __n128 result = "DATA.BBContextTrafficBlocker.2:N:";
      }
      else
      {
        uint64_t v2 = off_1019CE330;
LABEL_8:
        __n128 result = v2[a2];
      }
      break;
    default:
      return result;
  }
  return result;
}

void *sub_100460D90(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  id v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_100460DF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void *sub_100460E1C(void *a1)
{
  *a1 = off_1019CE1D8;
  uint64_t v2 = (std::__shared_weak_count *)a1[12];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[9];
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_100460E98(void *a1)
{
  sub_100460E1C(a1);

  operator delete();
}

uint64_t sub_100460ED0(uint64_t a1, char a2, unsigned char *a3, int a4)
{
  int v7 = *(_DWORD *)(a1 + 104);
  if (a2)
  {
    int v8 = v7 & ~a4;
    int v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = asStringBool(1);
      int v11 = *(_DWORD *)(a1 + 104);
      int v18 = 136316162;
      OsLogContext v19 = "enableOutgoingTraffic";
      __int16 v20 = 2080;
      uint64_t v21 = v10;
      __int16 v22 = 1024;
      int v23 = a4;
      __int16 v24 = 1024;
      int v25 = v11;
      __int16 v26 = 1024;
      int v27 = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s: enable traffic = %s, mask = %d, old mask = %d, new mask = %d", (uint8_t *)&v18, 0x28u);
    }
    *(_DWORD *)(a1 + 104) = v8;
    if (!v8)
    {
      long long v12 = *(uint64_t (**)(void))(**(void **)(a1 + 88) + 72);
      return v12();
    }
  }
  else
  {
    int v13 = v7 | a4;
    uint64_t v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = asStringBool(0);
      int v16 = *(_DWORD *)(a1 + 104);
      int v18 = 136316162;
      OsLogContext v19 = "enableOutgoingTraffic";
      __int16 v20 = 2080;
      uint64_t v21 = v15;
      __int16 v22 = 1024;
      int v23 = a4;
      __int16 v24 = 1024;
      int v25 = v16;
      __int16 v26 = 1024;
      int v27 = v13;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: enable traffic = %s, mask = %d, old mask = %d, new mask = %d", (uint8_t *)&v18, 0x28u);
    }
    *(_DWORD *)(a1 + 104) = v13;
    if (v13)
    {
      long long v12 = *(uint64_t (**)(void))(**(void **)(a1 + 88) + 72);
      return v12();
    }
  }
  uint64_t result = 0;
  *a3 = 1;
  return result;
}

void sub_1004610C8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100461194(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10046126C);
  __cxa_rethrow();
}

void sub_1004611BC(_Unwind_Exception *a1)
{
}

void sub_1004611D4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10046120C(uint64_t a1)
{
}

uint64_t sub_100461228(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10046126C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100461298(uint64_t a1, Registry **a2)
{
  *sub_100BA4AB8((void *)a1, "cu.policy.wifi", a2) = &off_1019CE3E0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *a2);
  char v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v7;
  int v11 = sub_10004D37C(&v6[1].__m_.__sig, &v17);
  if (v11)
  {
    uint64_t v13 = v11[3];
    long long v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  long long v12 = 0;
  char v14 = 1;
LABEL_9:
  char v15 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 72))(v13);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  *(unsigned char *)(a1 + 56) = v15;
  return a1;
}

void sub_1004613D8(_Unwind_Exception *a1)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  sub_100461404(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100461404(uint64_t a1)
{
  *(void *)a1 = off_101A42B98;
  sub_10005CD2C(a1 + 32, *(char **)(a1 + 40));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  return a1;
}

void sub_100461460(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 16));
  char v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    id v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v19 = v4;
  int v8 = sub_10004D37C(&v3[1].__m_.__sig, &v19);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(uint64_t **__return_ptr, uint64_t))(*(void *)v10 + 48))(&v16, v10);
  uint64_t v13 = *(char **)(a1 + 40);
  long long v12 = (void *)(a1 + 40);
  sub_10005CD2C((uint64_t)(v12 - 1), v13);
  uint64_t v14 = v17;
  *(v12 - 1) = v16;
  *long long v12 = v14;
  uint64_t v15 = v18;
  v12[1] = v18;
  if (v15)
  {
    *(void *)(v14 + 16) = v12;
    int v16 = &v17;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v14 = 0;
  }
  else
  {
    *(v12 - 1) = v12;
  }
  sub_10005CD2C((uint64_t)&v16, (char *)v14);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_1004615B4(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004615D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 16));
  uint64_t v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v7;
  char v11 = sub_10004D37C(&v6[1].__m_.__sig, &v15);
  if (v11)
  {
    uint64_t v13 = v11[3];
    long long v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  long long v12 = 0;
  char v14 = 1;
LABEL_9:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, a2, a3);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_1004616E8(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100461704(uint64_t a1@<X0>, char *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 56))
  {
    sub_100058DB0(v5, "WLAN_DATA_IS_TURNED_OFF_FOR_APP_NAME");
    sub_100058DB0(__p, "YOU_CAN_TURN_ON_WLAN_DATA_FOR_THIS_APP_IN_SETTINGS");
  }
  else
  {
    sub_100058DB0(v5, "WIFI_DATA_IS_TURNED_OFF_FOR_APP_NAME");
    sub_100058DB0(__p, "YOU_CAN_TURN_ON_WIFI_DATA_FOR_THIS_APP_IN_SETTINGS");
  }
  sub_100461830(a2, (long long *)v5, (long long *)__p);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_1004617B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004617F8(uint64_t a1)
{
  sub_100461404(a1);

  operator delete();
}

char *sub_100461830(char *__dst, long long *a2, long long *a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__dst = v5;
  }
  char v6 = __dst + 24;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(v6, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v7 = *a3;
    *((void *)__dst + 5) = *((void *)a3 + 2);
    *(_OWORD *)char v6 = v7;
  }
  return __dst;
}

void sub_1004618AC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004618C8()
{
}

void sub_100461950(uint64_t a1, uint64_t a2)
{
  char v2 = *(void ***)(a1 + 8);
  sub_1000E72F4(v5, a2);
  long long v7 = 0;
  char v3 = operator new(0x20uLL);
  void *v3 = off_1019CE4F8;
  sub_1000E72F4(v3 + 1, (uint64_t)v5);
  long long v7 = v3;
  sub_100043ED0((uint64_t)v6, *v2);
  sub_100043E48(v6);
  sub_10005CD2C((uint64_t)v5, (char *)v5[1]);
}

void sub_100461A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char *a10, uint64_t a11, uint64_t a12)
{
}

void sub_100461A58(uint64_t a1, uint64_t a2)
{
  char v2 = *(void ***)(a1 + 8);
  sub_1000C6BDC(v5, a2);
  long long v7 = 0;
  char v3 = operator new(0x20uLL);
  void *v3 = off_1019CE578;
  sub_1000C6BDC(v3 + 1, (uint64_t)v5);
  long long v7 = v3;
  sub_100043ED0((uint64_t)v6, *v2);
  sub_100043E48(v6);
  sub_10005CD2C((uint64_t)v5, (char *)v5[1]);
}

void sub_100461B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char *a10, uint64_t a11, uint64_t a12)
{
}

void sub_100461B60(CTXPCDataUsagePolicyNotificationInterface *this)
{
  *(void *)this = off_1019CE438;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CTXPCDataUsagePolicyNotificationInterface::~CTXPCDataUsagePolicyNotificationInterface(this);
}

void sub_100461BBC(CTXPCDataUsagePolicyNotificationInterface *this)
{
  *(void *)this = off_1019CE438;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CTXPCDataUsagePolicyNotificationInterface::~CTXPCDataUsagePolicyNotificationInterface(this);

  operator delete();
}

void sub_100461C2C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100461C94(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100461CD0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100461D08(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100461D38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100461D7C(uint64_t a1)
{
  *(void *)a1 = off_1019CE4F8;
  sub_10005CD2C(a1 + 8, *(char **)(a1 + 16));
  return a1;
}

void sub_100461DC4(uint64_t a1)
{
  *(void *)a1 = off_1019CE4F8;
  sub_10005CD2C(a1 + 8, *(char **)(a1 + 16));

  operator delete();
}

void *sub_100461E2C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  char v2 = operator new(0x20uLL);
  void *v2 = off_1019CE4F8;
  sub_1000E72F4(v2 + 1, v1);
  return v2;
}

void sub_100461E80(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100461E94(uint64_t a1, void *a2)
{
  *a2 = off_1019CE4F8;
  return sub_1000E72F4(a2 + 1, a1 + 8);
}

void sub_100461EC0(uint64_t a1)
{
}

void sub_100461ED0(char **a1)
{
  sub_10005CD2C((uint64_t)(a1 + 1), a1[2]);

  operator delete(a1);
}

void sub_100461F10(uint64_t a1, id *a2)
{
  sub_1000E72F4(v6, a1 + 8);
  char v3 = sub_100495780(v6);
  sub_10005CD2C((uint64_t)v6, (char *)v6[1]);
  if (v3)
  {
    char v4 = [v3 policies];
    id v5 = [v4 count];

    if (v5) {
      [*a2 appDataUsagePolicyChange:v3];
    }
  }
}

void sub_100461F9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100461FCC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10046200C()
{
}

uint64_t sub_100462018(uint64_t a1)
{
  *(void *)a1 = off_1019CE578;
  sub_10005CD2C(a1 + 8, *(char **)(a1 + 16));
  return a1;
}

void sub_100462060(uint64_t a1)
{
  *(void *)a1 = off_1019CE578;
  sub_10005CD2C(a1 + 8, *(char **)(a1 + 16));

  operator delete();
}

void *sub_1004620C8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  char v2 = operator new(0x20uLL);
  void *v2 = off_1019CE578;
  sub_1000C6BDC(v2 + 1, v1);
  return v2;
}

void sub_10046211C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100462130(uint64_t a1, void *a2)
{
  *a2 = off_1019CE578;
  return sub_1000C6BDC(a2 + 1, a1 + 8);
}

void sub_10046215C(uint64_t a1)
{
}

void sub_10046216C(char **a1)
{
  sub_10005CD2C((uint64_t)(a1 + 1), a1[2]);

  operator delete(a1);
}

void sub_1004621AC(uint64_t a1, id *a2)
{
  sub_1000C6BDC(v4, a1 + 8);
  char v3 = sub_100495418(v4);
  sub_10005CD2C((uint64_t)v4, (char *)v4[1]);
  if ([v3 count]) {
    [*a2 appDataUsagePolicyRemoved:v3];
  }
}

void sub_100462218(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_10046223C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10046227C()
{
}

void stewie::ServiceAtLocation::create(void *a1@<X0>, void *a2@<X1>, os_log_t *a3@<X4>, void *a4@<X8>)
{
  if (!*a1)
  {
    id v5 = *a3;
    if (!os_log_type_enabled(*a3, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    *(_WORD *)buf = 0;
    char v6 = "targetInstantAtLocationCache must be provided";
LABEL_9:
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v6, buf, 2u);
    goto LABEL_7;
  }
  if (*a2)
  {
    *(void *)buf = 0;
    uint64_t v8 = 0;
    operator new();
  }
  id v5 = *a3;
  if (os_log_type_enabled(*a3, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    char v6 = "anchorageAtLocation must be provided";
    goto LABEL_9;
  }
LABEL_7:
  *a4 = 0;
  a4[1] = 0;
}

void sub_100462570(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_weak(v1);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004625F4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16))();
}

void sub_10046261C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  char v6 = 0;
  long long v7 = 0;
  (*(void (**)(stewie::TargetInstant **__return_ptr))(**(void **)(a1 + 24) + 32))(&v6);
  if (v6)
  {
    (*(void (**)(stewie::TargetInstant *, uint64_t))(*(void *)v6 + 16))(v6, a2);
  }
  else
  {
    id v5 = stewie::TargetInstant::invalidInstance(0);
    *(_OWORD *)a3 = *v5;
    *(void *)(a3 + 16) = *((void *)v5 + 2);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1004626D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1004626EC(uint64_t a1, uint64_t a2, uint64_t a3, double *a4)
{
  if (a3 & 0xFF00000000) != 0 && (sub_100462770(a1, a3, a2, (uint64_t)a4)) {
    return a3;
  }
  uint64_t v9 = *(void *)(a1 + 72);

  return stewie::ServiceSearch::getOptimalTarget(v9, a2, a4);
}

uint64_t sub_100462770(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v13 = 0;
  char v14 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 24) + 32))(&v13);
  if (v13
    && (long long v11 = 0uLL,
        uint64_t v12 = 0,
        ((*(uint64_t (**)(uint64_t, uint64_t, long long *))(*(void *)v13 + 24))(v13, a3, &v11) & 1) != 0)
    && ((uint64_t v8 = *(void *)(a1 + 56)) == 0
     || (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 16))(v8, a2, a3))
    && (*(unsigned int (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 40) + 24))(*(void *)(a1 + 40), a2, a3))
  {
    *(_OWORD *)a4 = v11;
    *(void *)(a4 + 16) = v12;
    uint64_t v9 = 1;
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  return v9;
}

void sub_1004628B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004628CC(uint64_t a1@<X0>, unint64_t *a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v7 = *a2;
  if (*a2 >= *a3)
  {
    unint64_t v15 = *(NSObject **)(a1 + 16);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v16 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "getServiceWindow - invalid time interval", v16, 2u);
    }
    *(_OWORD *)a5 = *(_OWORD *)a4;
    *(unsigned char *)(a5 + 16) = *(unsigned char *)(a4 + 16);
    *(_OWORD *)(a5 + 24) = *(_OWORD *)(a4 + 24);
  }
  else
  {
    uint64_t v8 = *(void *)(a4 + 8);
    if (*(void *)a4) {
      BOOL v9 = v8 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9
      || (unint64_t v10 = *(void *)(a4 + 24)) == 0
      || ((v11 = *(void *)(a4 + 32), v7 <= v11) ? (BOOL v12 = v7 > v10) : (BOOL v12 = 1),
          !v12 ? (BOOL v13 = v11 == 0) : (BOOL v13 = 1),
          v13))
    {
      uint64_t v14 = *(void *)(a1 + 72);
      stewie::ServiceSearch::getServiceWindow(v14, a2, a3, a5);
    }
    else
    {
      *(void *)a5 = *(void *)a4;
      *(void *)(a5 + 8) = v8;
      *(unsigned char *)(a5 + 16) = *(unsigned char *)(a4 + 16);
      *(void *)(a5 + 24) = v10;
      *(void *)(a5 + 32) = v11;
    }
  }
}

void sub_1004629D4(uint64_t a1@<X0>, unint64_t *a2@<X1>, unint64_t *a3@<X2>, void *a4@<X3>, unint64_t *a5@<X8>)
{
}

uint64_t sub_1004629DC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 24))();
}

uint64_t sub_100462A04(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 24))();
}

uint64_t sub_100462A2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100462770(a1 - 8, a2, a3, a4);
}

void sub_100462A34(uint64_t a1)
{
  char v2 = (os_log_t *)(a1 + 16);
  char v3 = *(NSObject **)(a1 + 16);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [d] ************************************************", buf, 2u);
    char v3 = *v2;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [d] * ConnectionAssistant::ServiceAtLocation state *", buf, 2u);
    char v3 = *v2;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [d] ************************************************", buf, 2u);
  }
  uint64_t v33 = 0;
  long long v34 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 24) + 24))(&v33);
  uint64_t v4 = v33;
  id v5 = *(NSObject **)(a1 + 16);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (!v4)
  {
    if (!v6) {
      goto LABEL_30;
    }
    *(_WORD *)buf = 0;
    __int16 v22 = "#I [d] Targets not set";
    goto LABEL_29;
  }
  if (v6)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [d] Targets [", buf, 2u);
    uint64_t v4 = v33;
  }
  unint64_t v7 = *(void **)(v4 + 16);
  if (v7 != (void *)(v4 + 24))
  {
    do
    {
      uint64_t v8 = (int *)v7[5];
      int v9 = *((unsigned __int8 *)v8 + 12);
      unint64_t v10 = *v2;
      BOOL v11 = os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT);
      if (v9)
      {
        if (v11)
        {
          int v12 = *v8;
          BOOL v13 = "true";
          if (!*((unsigned char *)v8 + 4)) {
            BOOL v13 = "false";
          }
          int v14 = v8[2];
          *(_DWORD *)buf = 67109634;
          int v36 = v12;
          __int16 v37 = 2082;
          v38 = v13;
          __int16 v39 = 1024;
          int v40 = v14;
          unint64_t v15 = v10;
          int v16 = "#I [d]      targetID: %d, isShadow: %{public}s, pairedTargetID: %d";
          uint32_t v17 = 24;
          goto LABEL_18;
        }
      }
      else if (v11)
      {
        int v18 = *v8;
        *(_DWORD *)buf = 67109120;
        int v36 = v18;
        unint64_t v15 = v10;
        int v16 = "#I [d]      targetID: %d";
        uint32_t v17 = 8;
LABEL_18:
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v16, buf, v17);
      }
      unint64_t v19 = (void *)v7[1];
      if (v19)
      {
        do
        {
          __int16 v20 = v19;
          unint64_t v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          __int16 v20 = (void *)v7[2];
          BOOL v21 = *v20 == (void)v7;
          unint64_t v7 = v20;
        }
        while (!v21);
      }
      unint64_t v7 = v20;
    }
    while (v20 != (void *)(v33 + 24));
  }
  id v5 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    __int16 v22 = "#I [d] ]";
LABEL_29:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v22, buf, 2u);
  }
LABEL_30:
  uint64_t v23 = *(void *)(a1 + 24);
  if (v23)
  {
    (*(void (**)(uint64_t))(*(void *)v23 + 40))(v23);
  }
  else
  {
    __int16 v24 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I [d] TargetInstantAtLocationCache not set", buf, 2u);
    }
  }
  uint64_t v25 = *(void *)(a1 + 40);
  if (v25)
  {
    (*(void (**)(uint64_t))(*(void *)v25 + 32))(v25);
  }
  else
  {
    __int16 v26 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I [d] AnchorageAtLocation not set", buf, 2u);
    }
  }
  uint64_t v27 = *(void *)(a1 + 56);
  long long v28 = *(NSObject **)(a1 + 16);
  BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
  if (!v27)
  {
    if (!v29) {
      goto LABEL_46;
    }
    *(_WORD *)buf = 0;
    long long v31 = "#I [d] Service schedule is not set";
    long long v32 = v28;
    goto LABEL_45;
  }
  if (v29)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I [d] Service schedule [", buf, 2u);
    uint64_t v27 = *(void *)(a1 + 56);
  }
  (*(void (**)(uint64_t, os_log_t *))(*(void *)v27 + 24))(v27, v2);
  long long v30 = *v2;
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    long long v31 = "#I [d] ]";
    long long v32 = v30;
LABEL_45:
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v31, buf, 2u);
  }
LABEL_46:
  if (v34) {
    sub_10004D2C8(v34);
  }
}

void sub_100462F18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
}

void *sub_100462F38(void *a1)
{
  *a1 = off_1019CE5F8;
  a1[1] = off_1019CE658;
  char v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  char v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4) {
    sub_10004D2C8(v4);
  }
  id v5 = (std::__shared_weak_count *)a1[4];
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 2));
  return a1;
}

void sub_100462FD0(void *a1)
{
  *a1 = off_1019CE5F8;
  a1[1] = off_1019CE658;
  char v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  char v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4) {
    sub_10004D2C8(v4);
  }
  id v5 = (std::__shared_weak_count *)a1[4];
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 2));

  operator delete();
}

void sub_100463088(void *a1)
{
  *(a1 - 1) = off_1019CE5F8;
  *a1 = off_1019CE658;
  char v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  char v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[5];
  if (v4) {
    sub_10004D2C8(v4);
  }
  id v5 = (std::__shared_weak_count *)a1[3];
  if (v5) {
    sub_10004D2C8(v5);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
}

void sub_100463128(void *a1)
{
  *(a1 - 1) = off_1019CE5F8;
  *a1 = off_1019CE658;
  char v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  char v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[5];
  if (v4) {
    sub_10004D2C8(v4);
  }
  id v5 = (std::__shared_weak_count *)a1[3];
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  operator delete();
}

void sub_1004631E4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10046321C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10046324C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100463290(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (*a1)
    {
      do
      {
        uint64_t v3 = *(void *)(v2 + 16);
        if (*(void *)v2) {
          free(*(void **)v2);
        }
        free((void *)v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    free(a1);
  }
}

uint64_t sub_1004632FC(uint64_t *a1, char a2, unsigned int a3, const void *a4, unsigned int a5, int a6)
{
  if (!a1 || !a4 && a5 || a4 && !a5) {
    return 1;
  }
  unsigned int v13 = a5 + 16;
  int v14 = malloc_type_malloc(a5 + 16, 0x9AB8F4D0uLL);
  if (!v14) {
    return 2;
  }
  unint64_t v15 = v14;
  if (a3 > 0x1E)
  {
    uint64_t v18 = 0;
    uint64_t v39 = 0;
    do
    {
      *((unsigned char *)&v39 + v18++) = a3 & 0x7F;
      BOOL v19 = a3 > 0x7F;
      a3 >>= 7;
    }
    while (v19);
    int v20 = (int)v14;
    if (v13 <= v18) {
      goto LABEL_19;
    }
    *int v14 = (a2 << 6) | (32 * (a6 != 0)) | 0x1F;
    uint32_t v17 = v14 + 1;
    if (v18 >= 2)
    {
      uint64_t v21 = v18 - 1;
      do
        *v17++ = *((unsigned char *)&v39 + v21--) | 0x80;
      while (v21);
    }
    char v16 = v39;
  }
  else
  {
    if (!v13)
    {
LABEL_39:
      free(v14);
      return 3;
    }
    char v16 = (a2 << 6) | (32 * (a6 != 0)) | a3;
    uint32_t v17 = v14;
  }
  *uint32_t v17 = v16;
  int v20 = v17 + 1;
LABEL_19:
  int v22 = v20 - v14;
  if (v20 == v14) {
    goto LABEL_39;
  }
  uint64_t v23 = &v14[v22];
  if (a5 > 0x7E)
  {
    uint64_t v25 = 0;
    unsigned int v26 = v13 - v22;
    uint64_t v39 = 0;
    unsigned int v27 = a5;
    do
    {
      *((unsigned char *)&v39 + v25++) = v27;
      BOOL v19 = v27 > 0xFF;
      v27 >>= 8;
    }
    while (v19);
    LODWORD(v24) = v23;
    if (v26 > v25)
    {
      *uint64_t v23 = v25 | 0x80;
      __int16 v24 = v23 + 1;
      if (v25)
      {
        do
          *v24++ = *((unsigned char *)&v39 + --v25);
        while (v25);
      }
    }
  }
  else
  {
    LODWORD(v24) = v14 + v22;
    if (v13 != v22)
    {
      *uint64_t v23 = a5;
      LODWORD(v24) = v23 + 1;
    }
  }
  if (v24 == v23) {
    goto LABEL_39;
  }
  int v28 = (int)v24;
  if (a5)
  {
    memcpy(&v23[v24 - v23], a4, a5);
    v28 += a5;
  }
  BOOL v29 = malloc_type_calloc(0x18uLL, 1uLL, 0xDDEA35D5uLL);
  if (!v29)
  {
    free(v15);
    return 2;
  }
  long long v30 = v29;
  unsigned int v31 = v28 - v15;
  *(void *)BOOL v29 = v15;
  v29[2] = v28 - v15;
  uint64_t v32 = *a1;
  if (*a1)
  {
    if (*((_DWORD *)a1 + 3))
    {
      unsigned int v33 = *(_DWORD *)(v32 + 8);
      if (v31 >= v33) {
        size_t v34 = v33;
      }
      else {
        size_t v34 = v31;
      }
      if (memcmp(v15, *(const void **)v32, v34) < 0) {
        goto LABEL_38;
      }
      for (uint64_t i = *(void *)(v32 + 16); i; uint64_t i = *(void *)(i + 16))
      {
        unsigned int v37 = *(_DWORD *)(i + 8);
        if (v37 >= v31) {
          size_t v38 = v31;
        }
        else {
          size_t v38 = v37;
        }
        if ((memcmp(*(const void **)i, v15, v38) & 0x80000000) == 0) {
          break;
        }
        uint64_t v32 = i;
      }
    }
    else
    {
      for (uint64_t j = *(void *)(v32 + 16); j; uint64_t j = *(void *)(j + 16))
        uint64_t v32 = j;
      uint64_t i = 0;
    }
    *(void *)(v32 + 16) = v30;
    *((void *)v30 + 2) = i;
    goto LABEL_52;
  }
LABEL_38:
  *((void *)v30 + 2) = v32;
  *a1 = (uint64_t)v30;
LABEL_52:
  uint64_t result = 0;
  *((_DWORD *)a1 + 2) += v31;
  return result;
}

uint64_t sub_1004635EC(uint64_t *a1, char a2, unsigned int a3, unsigned int a4)
{
  uint64_t v4 = 0;
  unsigned int v8 = bswap32(a4);
  char v9 = 0;
  unsigned int v10 = v8;
  while (!*((unsigned char *)&v8 + v4))
  {
    if (++v4 == 4)
    {
      int v5 = 0;
      goto LABEL_6;
    }
  }
  int v5 = ((unint64_t)*((unsigned __int8 *)&v8 + v4) >> 7) - v4 + 4;
LABEL_6:
  if (v5 <= 1) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = v5;
  }
  return sub_1004632FC(a1, a2, a3, (char *)&vars0 - v6, v6, 0);
}

uint64_t sub_100463664(uint64_t *a1, void *a2, unsigned int *a3)
{
  if (!a1) {
    return 1;
  }
  unsigned int v6 = *((_DWORD *)a1 + 2);
  unint64_t v7 = (char *)malloc_type_malloc(v6, 0xF25E8A66uLL);
  if (!v7) {
    return 2;
  }
  unsigned int v8 = v7;
  uint64_t v9 = *a1;
  if (*a1)
  {
    unsigned int v10 = v7;
    do
    {
      memcpy(v10, *(const void **)v9, *(unsigned int *)(v9 + 8));
      v10 += *(unsigned int *)(v9 + 8);
      uint64_t v9 = *(void *)(v9 + 16);
    }
    while (v9);
  }
  if (a3) {
    *a3 = v6;
  }
  if (a2)
  {
    uint64_t result = 0;
    *a2 = v8;
  }
  else
  {
    free(v8);
    return 0;
  }
  return result;
}

uint64_t sub_100463720(uint64_t *a1, uint64_t *a2, char a3, unsigned int a4)
{
  uint64_t v9 = 0;
  uint64_t v4 = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    unsigned int v10 = 0;
    uint64_t v4 = sub_100463664(a1, &v9, &v10);
    if (!v4) {
      uint64_t v4 = sub_1004632FC(a2, a3, a4, v9, v10, 1);
    }
    if (v9) {
      free(v9);
    }
  }
  return v4;
}

double sub_1004637B0@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 96) = 0u;
  uint64_t v4 = a2 + 96;
  *(_OWORD *)(a2 + 144) = 0u;
  uint64_t v5 = a2 + 144;
  *(_OWORD *)(a2 + 192) = 0u;
  uint64_t v6 = a2 + 192;
  *(void *)(a2 + 240) = 0;
  uint64_t v7 = a2 + 168;
  *(_OWORD *)(a2 + 208) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_DWORD *)(a2 + 192) = -1;
  uint64_t v11 = a2 + 120;
  uint64_t v12 = *(void *)(a1 + 16);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  sub_100464AE4((void *)(a1 + 24), "", &v14);
  if (*(char *)(a1 + 79) < 0)
  {
    sub_10004FC84(&v16, *(void **)(a1 + 56), *(void *)(a1 + 64));
  }
  else
  {
    long long v16 = *(_OWORD *)(a1 + 56);
    uint64_t v17 = *(void *)(a1 + 72);
  }
  if (*(char *)(a1 + 103) < 0)
  {
    sub_10004FC84(&v18, *(void **)(a1 + 80), *(void *)(a1 + 88));
  }
  else
  {
    long long v18 = *(_OWORD *)(a1 + 80);
    uint64_t v19 = *(void *)(a1 + 96);
  }
  if (*(char *)(a1 + 127) < 0)
  {
    sub_10004FC84(&v20, *(void **)(a1 + 104), *(void *)(a1 + 112));
  }
  else
  {
    long long v20 = *(_OWORD *)(a1 + 104);
    uint64_t v21 = *(void *)(a1 + 120);
  }
  if (*(unsigned char *)(a1 + 8))
  {
    int v8 = *(_DWORD *)(a1 + 4);
    if (v8) {
      int v9 = v8 != 2;
    }
    else {
      int v9 = -1;
    }
  }
  else
  {
    int v9 = -1;
  }
  LODWORD(v22) = v9;
  *((void *)&v22 + 1) = *(void *)(a1 + 128);
  char v23 = *(unsigned char *)(a1 + 136);
  *(void *)(a2 + 88) = v12;
  *(_OWORD *)uint64_t v4 = v14;
  *(void *)(v4 + 16) = v15;
  *(_OWORD *)uint64_t v11 = v16;
  *(void *)(v11 + 16) = v17;
  *(void *)(v5 + 16) = v19;
  *(_OWORD *)uint64_t v5 = v18;
  *(_OWORD *)uint64_t v7 = v20;
  *(void *)(v7 + 16) = v21;
  double result = *(double *)&v22;
  *(_OWORD *)uint64_t v6 = v22;
  *(unsigned char *)(v6 + 16) = v23;
  if (*(unsigned char *)(a1 + 288))
  {
    uint64_t v13 = *(void *)(a1 + 160);
    if (*(char *)(a1 + 223) < 0)
    {
      sub_10004FC84(&v14, *(void **)(a1 + 200), *(void *)(a1 + 208));
    }
    else
    {
      long long v14 = *(_OWORD *)(a1 + 200);
      uint64_t v15 = *(void *)(a1 + 216);
    }
    if (*(char *)(a1 + 247) < 0)
    {
      sub_10004FC84(&v16, *(void **)(a1 + 224), *(void *)(a1 + 232));
    }
    else
    {
      long long v16 = *(_OWORD *)(a1 + 224);
      uint64_t v17 = *(void *)(a1 + 240);
    }
    if (*(char *)(a1 + 271) < 0)
    {
      sub_10004FC84(&v18, *(void **)(a1 + 248), *(void *)(a1 + 256));
    }
    else
    {
      long long v18 = *(_OWORD *)(a1 + 248);
      uint64_t v19 = *(void *)(a1 + 264);
    }
    *(void *)a2 = v13;
    *(_OWORD *)(a2 + 8) = v14;
    *(void *)(a2 + 24) = v15;
    *(_OWORD *)(a2 + 32) = v16;
    *(void *)(a2 + 48) = v17;
    double result = *(double *)&v18;
    *(_OWORD *)(a2 + 56) = v18;
    *(void *)(a2 + 72) = v19;
    *(unsigned char *)(a2 + 80) = 1;
  }
  return result;
}

void sub_100463A84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  if (v29[191] < 0) {
    operator delete(*v32);
  }
  if (v29[167] < 0) {
    operator delete(*v31);
  }
  if (v29[143] < 0) {
    operator delete(*a10);
  }
  if (v29[119] < 0) {
    operator delete(*v30);
  }
  sub_10045468C((uint64_t)v29);
  _Unwind_Resume(a1);
}

void sub_100463B30(uint64_t a1@<X1>, void *a2@<X8>)
{
  long long v120 = 0uLL;
  __n128 __p = 0;
  if (*(unsigned char *)(a1 + 80))
  {
    memset(&v112, 0, sizeof(v112));
    long long v123 = 0u;
    long long v124 = 0u;
    long long v122 = 0u;
    *(void *)&long long v125 = (char *)&v122 + 2;
    *((void *)&v125 + 1) = (char *)&v124 + 10;
    v121.__r_.__value_.__r.__words[0] = *(void *)a1;
    v121.__r_.__value_.__l.__size_ = (std::string::size_type)&v124 + 10;
    v121.__r_.__value_.__s.__data_[16] = 48;
    HIDWORD(v121.__r_.__value_.__r.__words[2]) = 48;
    *(void *)&long long v125 = sub_100464B1C((uint64_t)&v121);
    *((void *)&v125 + 1) = (char *)&v124 + 10;
    sub_10006E5EC(&v112, (std::string::value_type *)v125, (std::string::value_type *)&v124 + 10, (std::string::size_type)&v124 - v125 + 10);
    uint64_t v4 = std::string::insert(&v112, 0, "\n  <file-info type=\"thumbnail\">\n    <file-size>", 0x2FuLL);
    long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v113.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v113.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    uint64_t v6 = std::string::append(&v113, "</file-size>\n    <content-type>", 0x1FuLL);
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v141.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v141.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    int v8 = *(char *)(a1 + 31);
    if (v8 >= 0) {
      int v9 = (const std::string::value_type *)(a1 + 8);
    }
    else {
      int v9 = *(const std::string::value_type **)(a1 + 8);
    }
    if (v8 >= 0) {
      std::string::size_type v10 = *(unsigned __int8 *)(a1 + 31);
    }
    else {
      std::string::size_type v10 = *(void *)(a1 + 16);
    }
    uint64_t v11 = std::string::append(&v141, v9, v10);
    long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v114.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v114.__r_.__value_.__l.__data_ = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    uint64_t v13 = std::string::append(&v114, "</content-type>\n    <data url=\"", 0x1FuLL);
    long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v115.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v115.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    int v15 = *(char *)(a1 + 55);
    if (v15 >= 0) {
      long long v16 = (const std::string::value_type *)(a1 + 32);
    }
    else {
      long long v16 = *(const std::string::value_type **)(a1 + 32);
    }
    if (v15 >= 0) {
      std::string::size_type v17 = *(unsigned __int8 *)(a1 + 55);
    }
    else {
      std::string::size_type v17 = *(void *)(a1 + 40);
    }
    long long v18 = std::string::append(&v115, v16, v17);
    long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v116.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v116.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    long long v20 = std::string::append(&v116, "\" until=\"", 9uLL);
    long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v117.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v117.__r_.__value_.__l.__data_ = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    int v22 = *(char *)(a1 + 79);
    if (v22 >= 0) {
      char v23 = (const std::string::value_type *)(a1 + 56);
    }
    else {
      char v23 = *(const std::string::value_type **)(a1 + 56);
    }
    if (v22 >= 0) {
      std::string::size_type v24 = *(unsigned __int8 *)(a1 + 79);
    }
    else {
      std::string::size_type v24 = *(void *)(a1 + 64);
    }
    uint64_t v25 = std::string::append(&v117, v23, v24);
    long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    __dst.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    unsigned int v27 = std::string::append(&__dst, "\"/>\n  </file-info>", 0x12uLL);
    int v28 = (void *)v27->__r_.__value_.__r.__words[0];
    v140.__r_.__value_.__r.__words[0] = v27->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v140.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v27->__r_.__value_.__r.__words[1] + 7);
    char v29 = HIBYTE(v27->__r_.__value_.__r.__words[2]);
    v27->__r_.__value_.__l.__size_ = 0;
    v27->__r_.__value_.__r.__words[2] = 0;
    v27->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v120) < 0) {
      operator delete(__p);
    }
    __n128 __p = v28;
    *(void *)&long long v120 = v140.__r_.__value_.__r.__words[0];
    *(void *)((char *)&v120 + 7) = *(std::string::size_type *)((char *)v140.__r_.__value_.__r.__words + 7);
    HIBYTE(v120) = v29;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v117.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v116.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v115.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v114.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v141.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v141.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v113.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v113.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v112.__r_.__value_.__l.__data_);
    }
  }
  memset(&__dst, 0, sizeof(__dst));
  int v30 = *(_DWORD *)(a1 + 192);
  if (v30)
  {
    if (v30 != 1) {
      goto LABEL_43;
    }
    unsigned int v31 = " file-disposition=\"render\"";
    size_t v32 = 26;
  }
  else
  {
    unsigned int v31 = " file-disposition=\"attachment\"";
    size_t v32 = 30;
  }
  sub_10003ECB8(&__dst, v31, v32);
LABEL_43:
  memset(&v117, 0, sizeof(v117));
  memset(&v116, 0, sizeof(v116));
  if (*(unsigned char *)(a1 + 208))
  {
    sub_10003ECB8(&v117, " xmlns:am=\"urn:gsma:params:xml:ns:rcs:rcs:rram\"", 0x2FuLL);
    memset(&v114, 0, sizeof(v114));
    long long v123 = 0u;
    long long v124 = 0u;
    long long v122 = 0u;
    *(void *)&long long v125 = (char *)&v122 + 2;
    *((void *)&v125 + 1) = (char *)&v124 + 10;
    v121.__r_.__value_.__r.__words[0] = *(void *)(a1 + 200);
    v121.__r_.__value_.__l.__size_ = (std::string::size_type)&v124 + 10;
    v121.__r_.__value_.__s.__data_[16] = 48;
    HIDWORD(v121.__r_.__value_.__r.__words[2]) = 48;
    *(void *)&long long v125 = sub_100464B1C((uint64_t)&v121);
    *((void *)&v125 + 1) = (char *)&v124 + 10;
    sub_10006E5EC(&v114, (std::string::value_type *)v125, (std::string::value_type *)&v124 + 10, (std::string::size_type)&v124 - v125 + 10);
    unsigned int v33 = std::string::insert(&v114, 0, "\n   <am:playing-length>", 0x17uLL);
    long long v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
    v115.__r_.__value_.__r.__words[2] = v33->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v115.__r_.__value_.__l.__data_ = v34;
    v33->__r_.__value_.__l.__size_ = 0;
    v33->__r_.__value_.__r.__words[2] = 0;
    v33->__r_.__value_.__r.__words[0] = 0;
    long long v35 = std::string::append(&v115, "</am:playing-length>", 0x14uLL);
    std::string::size_type v36 = v35->__r_.__value_.__r.__words[0];
    v141.__r_.__value_.__r.__words[0] = v35->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v141.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v35->__r_.__value_.__r.__words[1] + 7);
    char v37 = HIBYTE(v35->__r_.__value_.__r.__words[2]);
    v35->__r_.__value_.__l.__size_ = 0;
    v35->__r_.__value_.__r.__words[2] = 0;
    v35->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v116.__r_.__value_.__l.__data_);
    }
    v116.__r_.__value_.__r.__words[0] = v36;
    v116.__r_.__value_.__l.__size_ = v141.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&v116.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v141.__r_.__value_.__r.__words + 7);
    *((unsigned char *)&v116.__r_.__value_.__s + 23) = v37;
    if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v115.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v114.__r_.__value_.__l.__data_);
    }
  }
  memset(&v115, 0, sizeof(v115));
  sub_100564870((uint64_t *)(a1 + 96), &v115);
  memset(&v114, 0, sizeof(v114));
  std::operator+<char>();
  size_t v38 = std::string::append(&v99, ">", 1uLL);
  long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
  v100.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v100.__r_.__value_.__l.__data_ = v39;
  v38->__r_.__value_.__l.__size_ = 0;
  v38->__r_.__value_.__r.__words[2] = 0;
  v38->__r_.__value_.__r.__words[0] = 0;
  if (v120 >= 0) {
    p_p = (const std::string::value_type *)&__p;
  }
  else {
    p_p = (const std::string::value_type *)__p;
  }
  if (v120 >= 0) {
    std::string::size_type v41 = HIBYTE(v120);
  }
  else {
    std::string::size_type v41 = v120;
  }
  v42 = std::string::append(&v100, p_p, v41);
  long long v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
  v101.__r_.__value_.__r.__words[2] = v42->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v101.__r_.__value_.__l.__data_ = v43;
  v42->__r_.__value_.__l.__size_ = 0;
  v42->__r_.__value_.__r.__words[2] = 0;
  v42->__r_.__value_.__r.__words[0] = 0;
  v44 = std::string::append(&v101, "\n  <file-info type=\"file\"", 0x19uLL);
  long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
  v102.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v102.__r_.__value_.__l.__data_ = v45;
  v44->__r_.__value_.__l.__size_ = 0;
  v44->__r_.__value_.__r.__words[2] = 0;
  v44->__r_.__value_.__r.__words[0] = 0;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_dst = &__dst;
  }
  else {
    p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __dst.__r_.__value_.__l.__size_;
  }
  v48 = std::string::append(&v102, (const std::string::value_type *)p_dst, size);
  long long v49 = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
  v103.__r_.__value_.__r.__words[2] = v48->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v103.__r_.__value_.__l.__data_ = v49;
  v48->__r_.__value_.__l.__size_ = 0;
  v48->__r_.__value_.__r.__words[2] = 0;
  v48->__r_.__value_.__r.__words[0] = 0;
  v50 = std::string::append(&v103, ">\n   <file-size>", 0x10uLL);
  long long v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
  v104.__r_.__value_.__r.__words[2] = v50->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v104.__r_.__value_.__l.__data_ = v51;
  v50->__r_.__value_.__l.__size_ = 0;
  v50->__r_.__value_.__r.__words[2] = 0;
  v50->__r_.__value_.__r.__words[0] = 0;
  memset(&v98, 0, sizeof(v98));
  long long v123 = 0u;
  long long v124 = 0u;
  long long v122 = 0u;
  *(void *)&long long v125 = (char *)&v122 + 2;
  *((void *)&v125 + 1) = (char *)&v124 + 10;
  v121.__r_.__value_.__r.__words[0] = *(void *)(a1 + 88);
  v121.__r_.__value_.__l.__size_ = (std::string::size_type)&v124 + 10;
  v121.__r_.__value_.__s.__data_[16] = 48;
  HIDWORD(v121.__r_.__value_.__r.__words[2]) = 48;
  *(void *)&long long v125 = sub_100464B1C((uint64_t)&v121);
  *((void *)&v125 + 1) = (char *)&v124 + 10;
  sub_10006E5EC(&v98, (std::string::value_type *)v125, (std::string::value_type *)&v124 + 10, (std::string::size_type)&v124 - v125 + 10);
  if ((v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    v52 = &v98;
  }
  else {
    v52 = (std::string *)v98.__r_.__value_.__r.__words[0];
  }
  if ((v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v53 = HIBYTE(v98.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v53 = v98.__r_.__value_.__l.__size_;
  }
  v54 = std::string::append(&v104, (const std::string::value_type *)v52, v53);
  long long v55 = *(_OWORD *)&v54->__r_.__value_.__l.__data_;
  v105.__r_.__value_.__r.__words[2] = v54->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v105.__r_.__value_.__l.__data_ = v55;
  v54->__r_.__value_.__l.__size_ = 0;
  v54->__r_.__value_.__r.__words[2] = 0;
  v54->__r_.__value_.__r.__words[0] = 0;
  v56 = std::string::append(&v105, "</file-size>\n   <file-name>", 0x1BuLL);
  long long v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
  v106.__r_.__value_.__r.__words[2] = v56->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v106.__r_.__value_.__l.__data_ = v57;
  v56->__r_.__value_.__l.__size_ = 0;
  v56->__r_.__value_.__r.__words[2] = 0;
  v56->__r_.__value_.__r.__words[0] = 0;
  if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    v58 = &v115;
  }
  else {
    v58 = (std::string *)v115.__r_.__value_.__r.__words[0];
  }
  if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v59 = HIBYTE(v115.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v59 = v115.__r_.__value_.__l.__size_;
  }
  v60 = std::string::append(&v106, (const std::string::value_type *)v58, v59);
  long long v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
  v107.__r_.__value_.__r.__words[2] = v60->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v107.__r_.__value_.__l.__data_ = v61;
  v60->__r_.__value_.__l.__size_ = 0;
  v60->__r_.__value_.__r.__words[2] = 0;
  v60->__r_.__value_.__r.__words[0] = 0;
  v62 = std::string::append(&v107, "</file-name>\n   <content-type>", 0x1EuLL);
  long long v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
  v108.__r_.__value_.__r.__words[2] = v62->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v108.__r_.__value_.__l.__data_ = v63;
  v62->__r_.__value_.__l.__size_ = 0;
  v62->__r_.__value_.__r.__words[2] = 0;
  v62->__r_.__value_.__r.__words[0] = 0;
  int v64 = *(char *)(a1 + 143);
  if (v64 >= 0) {
    v65 = (const std::string::value_type *)(a1 + 120);
  }
  else {
    v65 = *(const std::string::value_type **)(a1 + 120);
  }
  if (v64 >= 0) {
    std::string::size_type v66 = *(unsigned __int8 *)(a1 + 143);
  }
  else {
    std::string::size_type v66 = *(void *)(a1 + 128);
  }
  v67 = std::string::append(&v108, v65, v66);
  long long v68 = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
  v109.__r_.__value_.__r.__words[2] = v67->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v109.__r_.__value_.__l.__data_ = v68;
  v67->__r_.__value_.__l.__size_ = 0;
  v67->__r_.__value_.__r.__words[2] = 0;
  v67->__r_.__value_.__r.__words[0] = 0;
  v69 = std::string::append(&v109, "</content-type>\n   <data url=\"", 0x1EuLL);
  long long v70 = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
  v110.__r_.__value_.__r.__words[2] = v69->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v110.__r_.__value_.__l.__data_ = v70;
  v69->__r_.__value_.__l.__size_ = 0;
  v69->__r_.__value_.__r.__words[2] = 0;
  v69->__r_.__value_.__r.__words[0] = 0;
  int v71 = *(char *)(a1 + 167);
  if (v71 >= 0) {
    v72 = (const std::string::value_type *)(a1 + 144);
  }
  else {
    v72 = *(const std::string::value_type **)(a1 + 144);
  }
  if (v71 >= 0) {
    std::string::size_type v73 = *(unsigned __int8 *)(a1 + 167);
  }
  else {
    std::string::size_type v73 = *(void *)(a1 + 152);
  }
  v74 = std::string::append(&v110, v72, v73);
  long long v75 = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
  v111.__r_.__value_.__r.__words[2] = v74->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v75;
  v74->__r_.__value_.__l.__size_ = 0;
  v74->__r_.__value_.__r.__words[2] = 0;
  v74->__r_.__value_.__r.__words[0] = 0;
  v76 = std::string::append(&v111, "\" until=\"", 9uLL);
  long long v77 = *(_OWORD *)&v76->__r_.__value_.__l.__data_;
  v140.__r_.__value_.__r.__words[2] = v76->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v77;
  v76->__r_.__value_.__l.__size_ = 0;
  v76->__r_.__value_.__r.__words[2] = 0;
  v76->__r_.__value_.__r.__words[0] = 0;
  v80 = *(const std::string::value_type **)(a1 + 168);
  uint64_t v79 = a1 + 168;
  v78 = v80;
  int v81 = *(char *)(v79 + 23);
  if (v81 >= 0) {
    v82 = (const std::string::value_type *)v79;
  }
  else {
    v82 = v78;
  }
  if (v81 >= 0) {
    std::string::size_type v83 = *(unsigned __int8 *)(v79 + 23);
  }
  else {
    std::string::size_type v83 = *(void *)(v79 + 8);
  }
  v84 = std::string::append(&v140, v82, v83);
  long long v85 = *(_OWORD *)&v84->__r_.__value_.__l.__data_;
  v112.__r_.__value_.__r.__words[2] = v84->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v112.__r_.__value_.__l.__data_ = v85;
  v84->__r_.__value_.__l.__size_ = 0;
  v84->__r_.__value_.__r.__words[2] = 0;
  v84->__r_.__value_.__r.__words[0] = 0;
  v86 = std::string::append(&v112, "\"/>", 3uLL);
  long long v87 = *(_OWORD *)&v86->__r_.__value_.__l.__data_;
  v113.__r_.__value_.__r.__words[2] = v86->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v113.__r_.__value_.__l.__data_ = v87;
  v86->__r_.__value_.__l.__size_ = 0;
  v86->__r_.__value_.__r.__words[2] = 0;
  v86->__r_.__value_.__r.__words[0] = 0;
  if ((v116.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    v88 = &v116;
  }
  else {
    v88 = (std::string *)v116.__r_.__value_.__r.__words[0];
  }
  if ((v116.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v89 = HIBYTE(v116.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v89 = v116.__r_.__value_.__l.__size_;
  }
  v90 = std::string::append(&v113, (const std::string::value_type *)v88, v89);
  long long v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
  v141.__r_.__value_.__r.__words[2] = v90->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v141.__r_.__value_.__l.__data_ = v91;
  v90->__r_.__value_.__l.__size_ = 0;
  v90->__r_.__value_.__r.__words[2] = 0;
  v90->__r_.__value_.__r.__words[0] = 0;
  v92 = std::string::append(&v141, "\n </file-info>\n</file>", 0x16uLL);
  long long v93 = *(_OWORD *)&v92->__r_.__value_.__l.__data_;
  v114.__r_.__value_.__r.__words[2] = v92->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v114.__r_.__value_.__l.__data_ = v93;
  v92->__r_.__value_.__l.__size_ = 0;
  v92->__r_.__value_.__r.__words[2] = 0;
  v92->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v141.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v141.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v113.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v113.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v112.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v140.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v140.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v111.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v110.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v109.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v108.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v107.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v107.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v106.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v105.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v98.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v104.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v103.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v102.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v101.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v100.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v100.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v99.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v99.__r_.__value_.__l.__data_);
  }
  uint64_t v139 = 0;
  long long v137 = 0u;
  long long v138 = 0u;
  long long v135 = 0u;
  long long v136 = 0u;
  long long v133 = 0u;
  long long v134 = 0u;
  long long v131 = 0u;
  long long v132 = 0u;
  long long v129 = 0u;
  long long v130 = 0u;
  *(_OWORD *)v127 = 0u;
  long long v128 = 0u;
  long long v125 = 0u;
  long long v126 = 0u;
  long long v123 = 0u;
  long long v124 = 0u;
  long long v122 = 0u;
  sub_10004BD84((uint64_t)&v122);
  sub_1000BE8E8((uint64_t)&v122, "Content-Type", off_101A8C260);
  if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v94 = HIBYTE(v114.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v94 = v114.__r_.__value_.__l.__size_;
  }
  std::to_string(&v121, v94);
  sub_1000BE9C4((uint64_t)&v122, "Content-Length", &v121);
  if (SHIBYTE(v121.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v121.__r_.__value_.__l.__data_);
  }
  sub_10004B96C(&v123, (uint64_t)"\r\n", 2);
  if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    v95 = &v114;
  }
  else {
    v95 = (std::string *)v114.__r_.__value_.__r.__words[0];
  }
  if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v96 = HIBYTE(v114.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v96 = v114.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(&v123, (uint64_t)v95, v96);
  sub_10004BC98((uint64_t)&v123 + 8, &v121);
  sub_100CC8650(a2, (uint64_t)&v121);
  if (SHIBYTE(v121.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v121.__r_.__value_.__l.__data_);
  }
  *(void *)((char *)&v122
  *(void *)&long long v123 = v97;
  if (SHIBYTE(v128) < 0) {
    operator delete(v127[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v114.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v115.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v116.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v117.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v120) < 0) {
    operator delete(__p);
  }
}

void sub_100464790(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,uint64_t a58,void *a59,uint64_t a60,uint64_t a61,uint64_t a62,void *a63)
{
  if (SLOBYTE(STACK[0x227]) < 0) {
    operator delete((void *)STACK[0x210]);
  }
  if (SLOBYTE(STACK[0x207]) < 0) {
    operator delete(a71);
  }
  if (SLOBYTE(STACK[0x247]) < 0) {
    operator delete((void *)STACK[0x230]);
  }
  if (SLOBYTE(STACK[0x267]) < 0) {
    operator delete((void *)STACK[0x250]);
  }
  if (SLOBYTE(STACK[0x287]) < 0) {
    operator delete((void *)STACK[0x270]);
  }
  if (SLOBYTE(STACK[0x2A7]) < 0) {
    operator delete((void *)STACK[0x290]);
  }
  _Unwind_Resume(a1);
}

void *sub_100464AE4@<X0>(void *result@<X0>, char *a2@<X1>, void *a3@<X8>)
{
  if (!*((unsigned char *)result + 24)) {
    return sub_100058DB0(a3, a2);
  }
  if (*((char *)result + 23) < 0) {
    return sub_10004FC84(a3, (void *)*result, result[1]);
  }
  *(_OWORD *)a3 = *(_OWORD *)result;
  a3[2] = result[2];
  return result;
}

uint64_t sub_100464B1C(uint64_t a1)
{
  v28.__locale_ = 0;
  std::locale::locale(&v28);
  uint64_t v2 = std::locale::classic();
  if (std::locale::operator==(&v28, v2))
  {
    unint64_t v3 = *(void *)a1;
    do
    {
      uint64_t v4 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = v4 - 1;
      *(unsigned char *)(v4 - 1) = *(_DWORD *)(a1 + 20)
                         + v3
                         - 10 * (((v3 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64) >> 3);
      unint64_t v5 = *(void *)a1;
      unint64_t v3 = *(void *)a1 / 0xAuLL;
      *(void *)a1 = v3;
    }
    while (v5 > 9);
    uint64_t v6 = *(void *)(a1 + 8);
    goto LABEL_28;
  }
  long long v7 = std::locale::use_facet(&v28, &std::numpunct<char>::id);
  __n128 __p = 0;
  unint64_t v26 = 0;
  uint64_t v27 = 0;
  ((void (*)(void **__return_ptr))v7->__vftable[1].__on_zero_shared)(&__p);
  if (SHIBYTE(v27) < 0)
  {
    unint64_t v8 = v26;
    if (!v26) {
      goto LABEL_24;
    }
    p_p = (char *)__p;
  }
  else
  {
    unint64_t v8 = HIBYTE(v27);
    if (!HIBYTE(v27)) {
      goto LABEL_24;
    }
    p_p = (char *)&__p;
  }
  if (*p_p > 0)
  {
    char v10 = ((uint64_t (*)(const std::locale::facet *))v7->__vftable[1].~facet_0)(v7);
    uint64_t v11 = 0;
    long long v12 = __p;
    if (v27 >= 0) {
      long long v12 = &__p;
    }
    uint64_t v13 = (uint64_t *)(a1 + 8);
    LOBYTE(v14) = *v12;
    char v15 = *v12;
    do
    {
      if (!v15)
      {
        if (++v11 < v8)
        {
          long long v16 = v27 >= 0 ? &__p : (void **)__p;
          int v14 = *((char *)v16 + v11);
          if (v14 < 1) {
            LOBYTE(v14) = 127;
          }
        }
        std::string::size_type v17 = (unsigned char *)(*v13 - 1);
        *uint64_t v13 = (uint64_t)v17;
        *std::string::size_type v17 = v10;
        char v15 = v14;
      }
      --v15;
      unint64_t v19 = *(void *)a1;
      uint64_t v18 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = v18 - 1;
      *(unsigned char *)(v18 - 1) = *(_DWORD *)(a1 + 20)
                          + v19
                          - 10 * (((v19 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64) >> 3);
      unint64_t v20 = *(void *)a1;
      *(void *)a1 /= 0xAuLL;
    }
    while (v20 > 9);
    goto LABEL_26;
  }
LABEL_24:
  uint64_t v13 = (uint64_t *)(a1 + 8);
  unint64_t v21 = *(void *)a1;
  do
  {
    uint64_t v22 = *(void *)(a1 + 8);
    *(void *)(a1 + 8) = v22 - 1;
    *(unsigned char *)(v22 - 1) = *(_DWORD *)(a1 + 20)
                        + v21
                        - 10 * (((v21 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64) >> 3);
    unint64_t v23 = *(void *)a1;
    unint64_t v21 = *(void *)a1 / 0xAuLL;
    *(void *)a1 = v21;
  }
  while (v23 > 9);
LABEL_26:
  uint64_t v6 = *v13;
  if (SHIBYTE(v27) < 0) {
    operator delete(__p);
  }
LABEL_28:
  std::locale::~locale(&v28);
  return v6;
}

void sub_100464D88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::locale::~locale(&a15);
  _Unwind_Resume(a1);
}

void sub_100464DBC()
{
  uint64_t v0 = 0;
  MMSFactory::create(&v0);
}

void sub_100464E78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8))(a9);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100464EC0()
{
  uint64_t v0 = 0;
  MMSFactory::create(&v0);
}

void sub_100465050(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 8))(a11);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100465184(uint64_t a1, dispatch_object_t *a2, uint64_t a3)
{
  unint64_t v5 = (std::__shared_weak_count *)operator new(0xB8uLL);
  v5->__shared_owners_ = 0;
  v5->__shared_weak_owners_ = 0;
  v5->__vftable = (std::__shared_weak_count_vtbl *)off_1019CE7C0;
  uint64_t v6 = v5 + 1;
  CTParserClient::CTParserClient();
  shared_weak_owners = (std::__shared_weak_count *)v5[1].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1) {
      goto LABEL_6;
    }
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v5[1].__shared_owners_ = (uint64_t)v6;
    v5[1].__shared_weak_owners_ = (uint64_t)v5;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  else
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v5[1].__shared_owners_ = (uint64_t)v6;
    v5[1].__shared_weak_owners_ = (uint64_t)v5;
  }
  sub_10004D2C8(v5);
LABEL_6:
  if (*a2) {
    dispatch_retain(*a2);
  }
  uint64_t v8 = *(void *)(a3 + 8);
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  sms::Controller::create(&v9);
}

void sub_1004652E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13, dispatch_object_t object)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  if (object) {
    dispatch_release(object);
  }
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

void sub_100465330(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  if (*a3) {
    dispatch_retain(*a3);
  }
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  TerminalRegistrationController::create(&v5);
}

void sub_1004653C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, dispatch_object_t object)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004653EC(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a2 + 8);
  long long v5 = (capabilities::ct *)(a1 + 8);
  uint64_t v6 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100BED114(v5, &v7);
  *a3 = v7;
  long long v7 = 0uLL;
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_100465454(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100465470(MessageCenterModelFactoryInterface *this)
{
  *(void *)this = off_1019CE758;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  MessageCenterModelFactoryInterface::~MessageCenterModelFactoryInterface(this);
}

void sub_1004654CC(MessageCenterModelFactoryInterface *this)
{
  *(void *)this = off_1019CE758;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  MessageCenterModelFactoryInterface::~MessageCenterModelFactoryInterface(this);

  operator delete();
}

void sub_10046553C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019CE7C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10046555C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019CE7C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004655B0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1004655D8(void **a1)
{
  *a1 = off_1019CE810;
  uint64_t v2 = a1 + 1;
  sub_100465E6C(&v2);
  PB::Base::~Base((PB::Base *)a1);
}

void sub_100465634(void **a1)
{
  *a1 = off_1019CE810;
  uint64_t v2 = a1 + 1;
  sub_100465E6C(&v2);
  PB::Base::~Base((PB::Base *)a1);
  operator delete();
}

void sub_1004656A4()
{
}

void sub_1004657A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004660D8((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1004657EC(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  char v5 = *(unsigned char *)(a1 + 40);
  if (v5)
  {
    PB::TextFormatter::format(this, "error", *(_DWORD *)(a1 + 32));
    char v5 = *(unsigned char *)(a1 + 40);
  }
  if ((v5 & 2) != 0) {
    PB::TextFormatter::format(this, "pendingInstallStatus", *(_DWORD *)(a1 + 36));
  }
  uint64_t v6 = *(uint64_t **)(a1 + 8);
  long long v7 = *(uint64_t **)(a1 + 16);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, this, "slotInfo");
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_1004658BC(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v13 = *(unsigned char *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v2 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_19;
        }
      }
LABEL_26:
      unsigned __int8 v19 = v11 & 7;
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v20 = v11 >> 3;
      if ((v11 >> 3) == 4)
      {
        *(unsigned char *)(a1 + 40) |= 2u;
        unint64_t v23 = *((void *)this + 1);
        unint64_t v24 = *((void *)this + 2);
        uint64_t v25 = *(void *)this;
        if (v23 > 0xFFFFFFFFFFFFFFF5 || v23 + 10 > v24)
        {
          char v39 = 0;
          unsigned int v40 = 0;
          uint64_t v28 = 0;
          if (v24 <= v23) {
            unint64_t v24 = *((void *)this + 1);
          }
          while (1)
          {
            if (v24 == v23)
            {
              LODWORD(v28) = 0;
              *((unsigned char *)this + 24) = 1;
              goto LABEL_63;
            }
            unint64_t v41 = v23 + 1;
            char v42 = *(unsigned char *)(v25 + v23);
            *((void *)this + 1) = v41;
            v28 |= (unint64_t)(v42 & 0x7F) << v39;
            if ((v42 & 0x80) == 0) {
              break;
            }
            v39 += 7;
            unint64_t v23 = v41;
            BOOL v14 = v40++ > 8;
            if (v14)
            {
LABEL_51:
              LODWORD(v28) = 0;
              goto LABEL_63;
            }
          }
          if (*((unsigned char *)this + 24)) {
            LODWORD(v28) = 0;
          }
        }
        else
        {
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v28 = 0;
          while (1)
          {
            unint64_t v29 = v23 + 1;
            *((void *)this + 1) = v23 + 1;
            char v30 = *(unsigned char *)(v25 + v23);
            v28 |= (unint64_t)(v30 & 0x7F) << v26;
            if ((v30 & 0x80) == 0) {
              break;
            }
            v26 += 7;
            unint64_t v23 = v29;
            BOOL v14 = v27++ > 8;
            if (v14) {
              goto LABEL_51;
            }
          }
        }
LABEL_63:
        *(_DWORD *)(a1 + 36) = v28;
      }
      else if (v20 == 3)
      {
        *(unsigned char *)(a1 + 40) |= 1u;
        unint64_t v31 = *((void *)this + 1);
        unint64_t v32 = *((void *)this + 2);
        uint64_t v33 = *(void *)this;
        if (v31 > 0xFFFFFFFFFFFFFFF5 || v31 + 10 > v32)
        {
          char v43 = 0;
          unsigned int v44 = 0;
          uint64_t v36 = 0;
          if (v32 <= v31) {
            unint64_t v32 = *((void *)this + 1);
          }
          while (1)
          {
            if (v32 == v31)
            {
              LODWORD(v36) = 0;
              *((unsigned char *)this + 24) = 1;
              goto LABEL_66;
            }
            unint64_t v45 = v31 + 1;
            char v46 = *(unsigned char *)(v33 + v31);
            *((void *)this + 1) = v45;
            v36 |= (unint64_t)(v46 & 0x7F) << v43;
            if ((v46 & 0x80) == 0) {
              break;
            }
            v43 += 7;
            unint64_t v31 = v45;
            BOOL v14 = v44++ > 8;
            if (v14)
            {
LABEL_58:
              LODWORD(v36) = 0;
              goto LABEL_66;
            }
          }
          if (*((unsigned char *)this + 24)) {
            LODWORD(v36) = 0;
          }
        }
        else
        {
          char v34 = 0;
          unsigned int v35 = 0;
          uint64_t v36 = 0;
          while (1)
          {
            unint64_t v37 = v31 + 1;
            *((void *)this + 1) = v31 + 1;
            char v38 = *(unsigned char *)(v33 + v31);
            v36 |= (unint64_t)(v38 & 0x7F) << v34;
            if ((v38 & 0x80) == 0) {
              break;
            }
            v34 += 7;
            unint64_t v31 = v37;
            BOOL v14 = v35++ > 8;
            if (v14) {
              goto LABEL_58;
            }
          }
        }
LABEL_66:
        *(_DWORD *)(a1 + 32) = v36;
      }
      else
      {
        if (v20 == 1) {
          sub_100465C64();
        }
LABEL_20:
        uint64_t result = PB::Reader::skip(this, v20, v19, 0);
        if (!result) {
          return result;
        }
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || v4 != 0) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_26;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
      if (v14)
      {
LABEL_19:
        unsigned __int8 v19 = 0;
        LODWORD(v20) = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

void sub_100465C64()
{
}

void sub_100465D90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004660D8((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100465DD4(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Base ***)(result + 8);
  char v5 = *(const PB::Base ***)(result + 16);
  while (v4 != v5)
  {
    uint64_t v6 = *v4++;
    uint64_t result = PB::Writer::writeSubmessage(this, v6, 1u);
  }
  char v7 = *(unsigned char *)(v3 + 40);
  if (v7)
  {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 32), 3u);
    char v7 = *(unsigned char *)(v3 + 40);
  }
  if ((v7 & 2) != 0)
  {
    unsigned int v8 = *(_DWORD *)(v3 + 36);
    return PB::Writer::writeVarInt(this, v8, 4u);
  }
  return result;
}

void sub_100465E6C(void ***a1)
{
  unint64_t v2 = *a1;
  if (*v2)
  {
    sub_100465EC0(v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void *sub_100465EC0(void *result)
{
  uint64_t v1 = result;
  unint64_t v2 = (void *)*result;
  uint64_t v3 = (void *)result[1];
  while (v3 != v2)
  {
    int v4 = (void *)*--v3;
    uint64_t result = v4;
    void *v3 = 0;
    if (v4) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  v1[1] = v2;
  return result;
}

uint64_t sub_100465F2C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100465FA4((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100465FA4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v13[0] = a1;
  v13[1] = &v14;
  v13[2] = &v15;
  v13[3] = 1;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    char v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v15 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v15;
  }
  sub_100466038((uint64_t)v13);
  return v11;
}

uint64_t sub_100466038(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100466070((void *)a1);
  }
  return a1;
}

void *sub_100466070(void *result)
{
  uint64_t v1 = *(void ***)(result[2] + 8);
  unint64_t v2 = *(void ***)(result[1] + 8);
  while (v1 != v2)
  {
    uint64_t result = *v1;
    void *v1 = 0;
    if (result) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
    ++v1;
  }
  return result;
}

void **sub_1004660D8(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void *sub_100466110(void *result, uint64_t a2)
{
  uint64_t v2 = result[2];
  if (v2 != a2)
  {
    int v4 = result;
    do
    {
      v4[2] = v2 - 8;
      uint64_t result = *(void **)(v2 - 8);
      *(void *)(v2 - 8) = 0;
      if (result) {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      }
      uint64_t v2 = v4[2];
    }
    while (v2 != a2);
  }
  return result;
}

uint64_t *sub_100466184@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  if (*(char *)(a1 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)a2, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    *(void *)(a2 + 16) = *(void *)(a1 + 16);
  }

  return sub_100356BF4((uint64_t *)a2);
}

void sub_1004661E8(PB::Base *this)
{
  *(void *)this = &off_1019CE890;
  uint64_t v4 = *((void *)this + 8);
  uint64_t v2 = (void *)((char *)this + 64);
  uint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  uint64_t v5 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v5) {
    sub_100206334((uint64_t)this + 56, v5);
  }
  uint64_t v6 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v6) {
    sub_100206334((uint64_t)this + 48, v6);
  }
  uint64_t v7 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v7) {
    sub_100206334((uint64_t)this + 40, v7);
  }
  uint64_t v8 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v8) {
    sub_100206334((uint64_t)this + 32, v8);
  }
  uint64_t v9 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v9) {
    sub_100206334((uint64_t)this + 24, v9);
  }
  uint64_t v10 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v10) {
    sub_100206334((uint64_t)this + 16, v10);
  }

  PB::Base::~Base(this);
}

void sub_1004662C4(PB::Base *a1)
{
  sub_1004661E8(a1);

  operator delete();
}

uint64_t sub_1004662FC(uint64_t result, uint64_t a2)
{
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(void *)uint64_t result = &off_1019CE890;
  *(void *)(result + 64) = 0;
  *(_DWORD *)(result + 88) = 0;
  if (*(void *)(a2 + 64)) {
    operator new();
  }
  if (*(void *)(a2 + 40)) {
    operator new();
  }
  if (*(void *)(a2 + 32)) {
    operator new();
  }
  if ((*(unsigned char *)(a2 + 88) & 8) != 0)
  {
    int v2 = *(_DWORD *)(a2 + 80);
    *(unsigned char *)(result + 88) |= 8u;
    *(_DWORD *)(result + 80) = v2;
  }
  if (*(void *)(a2 + 56)) {
    operator new();
  }
  char v3 = *(unsigned char *)(a2 + 88);
  if ((v3 & 2) != 0)
  {
    int v5 = *(_DWORD *)(a2 + 72);
    *(unsigned char *)(result + 88) |= 2u;
    *(_DWORD *)(result + 72) = v5;
    char v3 = *(unsigned char *)(a2 + 88);
    if ((v3 & 0x10) == 0)
    {
LABEL_13:
      if ((v3 & 4) == 0) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
  }
  else if ((*(unsigned char *)(a2 + 88) & 0x10) == 0)
  {
    goto LABEL_13;
  }
  char v6 = *(unsigned char *)(a2 + 84);
  *(unsigned char *)(result + 88) |= 0x10u;
  *(unsigned char *)(result + 84) = v6;
  if ((*(unsigned char *)(a2 + 88) & 4) != 0)
  {
LABEL_14:
    int v4 = *(_DWORD *)(a2 + 76);
    *(unsigned char *)(result + 88) |= 4u;
    *(_DWORD *)(result + 76) = v4;
  }
LABEL_15:
  if (*(void *)(a2 + 48)) {
    operator new();
  }
  if (*(void *)(a2 + 16)) {
    operator new();
  }
  if (*(void *)(a2 + 24)) {
    operator new();
  }
  char v7 = *(unsigned char *)(a2 + 88);
  if ((v7 & 0x20) != 0)
  {
    char v8 = *(unsigned char *)(a2 + 85);
    *(unsigned char *)(result + 88) |= 0x20u;
    *(unsigned char *)(result + 85) = v8;
    char v7 = *(unsigned char *)(a2 + 88);
  }
  if (v7)
  {
    uint64_t v9 = *(void *)(a2 + 8);
    *(unsigned char *)(result + 88) |= 1u;
    *(void *)(result + 8) = v9;
  }
  return result;
}

uint64_t sub_10046672C(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  char v5 = *(unsigned char *)(a1 + 88);
  if ((v5 & 2) != 0)
  {
    PB::TextFormatter::format(this, "addOnFlowType", *(_DWORD *)(a1 + 72));
    char v5 = *(unsigned char *)(a1 + 88);
  }
  if (v5) {
    PB::TextFormatter::format(this, "additionalTransferInfo", *(void *)(a1 + 8));
  }
  if (*(void *)(a1 + 16)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 24)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 32)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 40)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 48)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 56)) {
    PB::TextFormatter::format();
  }
  char v6 = *(unsigned char *)(a1 + 88);
  if ((v6 & 0x10) != 0)
  {
    PB::TextFormatter::format(this, "isDataActive", *(unsigned char *)(a1 + 84));
    char v6 = *(unsigned char *)(a1 + 88);
    if ((v6 & 0x20) == 0)
    {
LABEL_19:
      if ((v6 & 4) == 0) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }
  }
  else if ((*(unsigned char *)(a1 + 88) & 0x20) == 0)
  {
    goto LABEL_19;
  }
  PB::TextFormatter::format(this, "isPrimaryAccountHolder", *(unsigned char *)(a1 + 85));
  if ((*(unsigned char *)(a1 + 88) & 4) != 0) {
LABEL_20:
  }
    PB::TextFormatter::format(this, "sourceTransferError", *(_DWORD *)(a1 + 76));
LABEL_21:
  if (*(void *)(a1 + 64)) {
    PB::TextFormatter::format();
  }
  if ((*(unsigned char *)(a1 + 88) & 8) != 0) {
    PB::TextFormatter::format(this, "transferType", *(_DWORD *)(a1 + 80));
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_1004668CC(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)this;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
      break;
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    do
    {
      if (v3 == v2)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_22;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
    }
    while (!v14);
LABEL_19:
    unsigned __int8 v19 = 0;
    LODWORD(v20) = 0;
LABEL_20:
    uint64_t result = PB::Reader::skip(this, v20, v19, 0);
    if (!result) {
      return result;
    }
LABEL_54:
    unint64_t v2 = *((void *)this + 1);
    unint64_t v3 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v9 = 0;
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = v2 + 1;
    *((void *)this + 1) = v2 + 1;
    char v13 = *(unsigned char *)(v8 + v2);
    v11 |= (unint64_t)(v13 & 0x7F) << v9;
    if ((v13 & 0x80) == 0) {
      break;
    }
    v9 += 7;
    unint64_t v2 = v12;
    BOOL v14 = v10++ > 8;
    if (v14) {
      goto LABEL_19;
    }
  }
LABEL_22:
  unsigned __int8 v19 = v11 & 7;
  if ((v11 & 7) != 4)
  {
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 2u:
        operator new();
      case 3u:
        operator new();
      case 4u:
        operator new();
      case 5u:
        *(unsigned char *)(a1 + 88) |= 8u;
        unint64_t v22 = *((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        uint64_t v24 = *(void *)this;
        if (v22 <= 0xFFFFFFFFFFFFFFF5 && v22 + 10 <= v23)
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          do
          {
            unint64_t v28 = v22 + 1;
            *((void *)this + 1) = v22 + 1;
            char v29 = *(unsigned char *)(v24 + v22);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0) {
              goto LABEL_103;
            }
            v25 += 7;
            unint64_t v22 = v28;
            BOOL v14 = v26++ > 8;
          }
          while (!v14);
LABEL_74:
          LODWORD(v27) = 0;
          goto LABEL_103;
        }
        char v63 = 0;
        unsigned int v64 = 0;
        uint64_t v27 = 0;
        if (v23 <= v22) {
          unint64_t v23 = *((void *)this + 1);
        }
        while (2)
        {
          if (v23 == v22)
          {
            LODWORD(v27) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v65 = v22 + 1;
            char v66 = *(unsigned char *)(v24 + v22);
            *((void *)this + 1) = v65;
            v27 |= (unint64_t)(v66 & 0x7F) << v63;
            if (v66 < 0)
            {
              v63 += 7;
              unint64_t v22 = v65;
              BOOL v14 = v64++ > 8;
              if (v14) {
                goto LABEL_74;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v27) = 0;
            }
          }
          break;
        }
LABEL_103:
        *(_DWORD *)(a1 + 80) = v27;
        goto LABEL_54;
      case 6u:
        operator new();
      case 7u:
        *(unsigned char *)(a1 + 88) |= 2u;
        unint64_t v30 = *((void *)this + 1);
        unint64_t v31 = *((void *)this + 2);
        uint64_t v32 = *(void *)this;
        if (v30 <= 0xFFFFFFFFFFFFFFF5 && v30 + 10 <= v31)
        {
          char v33 = 0;
          unsigned int v34 = 0;
          uint64_t v35 = 0;
          do
          {
            unint64_t v36 = v30 + 1;
            *((void *)this + 1) = v30 + 1;
            char v37 = *(unsigned char *)(v32 + v30);
            v35 |= (unint64_t)(v37 & 0x7F) << v33;
            if ((v37 & 0x80) == 0) {
              goto LABEL_107;
            }
            v33 += 7;
            unint64_t v30 = v36;
            BOOL v14 = v34++ > 8;
          }
          while (!v14);
LABEL_81:
          LODWORD(v35) = 0;
          goto LABEL_107;
        }
        char v67 = 0;
        unsigned int v68 = 0;
        uint64_t v35 = 0;
        if (v31 <= v30) {
          unint64_t v31 = *((void *)this + 1);
        }
        while (2)
        {
          if (v31 == v30)
          {
            LODWORD(v35) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v69 = v30 + 1;
            char v70 = *(unsigned char *)(v32 + v30);
            *((void *)this + 1) = v69;
            v35 |= (unint64_t)(v70 & 0x7F) << v67;
            if (v70 < 0)
            {
              v67 += 7;
              unint64_t v30 = v69;
              BOOL v14 = v68++ > 8;
              if (v14) {
                goto LABEL_81;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v35) = 0;
            }
          }
          break;
        }
LABEL_107:
        *(_DWORD *)(a1 + 72) = v35;
        goto LABEL_54;
      case 8u:
        *(unsigned char *)(a1 + 88) |= 0x10u;
        unint64_t v38 = *((void *)this + 1);
        if (v38 >= *((void *)this + 2))
        {
          BOOL v41 = 0;
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          unint64_t v39 = v38 + 1;
          int v40 = *(unsigned __int8 *)(*(void *)this + v38);
          *((void *)this + 1) = v39;
          BOOL v41 = v40 != 0;
        }
        *(unsigned char *)(a1 + 84) = v41;
        goto LABEL_54;
      case 9u:
        *(unsigned char *)(a1 + 88) |= 4u;
        unint64_t v42 = *((void *)this + 1);
        unint64_t v43 = *((void *)this + 2);
        uint64_t v44 = *(void *)this;
        if (v42 <= 0xFFFFFFFFFFFFFFF5 && v42 + 10 <= v43)
        {
          char v45 = 0;
          unsigned int v46 = 0;
          uint64_t v47 = 0;
          do
          {
            unint64_t v48 = v42 + 1;
            *((void *)this + 1) = v42 + 1;
            char v49 = *(unsigned char *)(v44 + v42);
            v47 |= (unint64_t)(v49 & 0x7F) << v45;
            if ((v49 & 0x80) == 0) {
              goto LABEL_111;
            }
            v45 += 7;
            unint64_t v42 = v48;
            BOOL v14 = v46++ > 8;
          }
          while (!v14);
LABEL_90:
          LODWORD(v47) = 0;
          goto LABEL_111;
        }
        char v71 = 0;
        unsigned int v72 = 0;
        uint64_t v47 = 0;
        if (v43 <= v42) {
          unint64_t v43 = *((void *)this + 1);
        }
        while (2)
        {
          if (v43 == v42)
          {
            LODWORD(v47) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v73 = v42 + 1;
            char v74 = *(unsigned char *)(v44 + v42);
            *((void *)this + 1) = v73;
            v47 |= (unint64_t)(v74 & 0x7F) << v71;
            if (v74 < 0)
            {
              v71 += 7;
              unint64_t v42 = v73;
              BOOL v14 = v72++ > 8;
              if (v14) {
                goto LABEL_90;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v47) = 0;
            }
          }
          break;
        }
LABEL_111:
        *(_DWORD *)(a1 + 76) = v47;
        goto LABEL_54;
      case 0xAu:
        operator new();
      case 0xBu:
        operator new();
      case 0xCu:
        operator new();
      case 0xDu:
        *(unsigned char *)(a1 + 88) |= 0x20u;
        unint64_t v51 = *((void *)this + 1);
        if (v51 >= *((void *)this + 2))
        {
          BOOL v54 = 0;
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          unint64_t v52 = v51 + 1;
          int v53 = *(unsigned __int8 *)(*(void *)this + v51);
          *((void *)this + 1) = v52;
          BOOL v54 = v53 != 0;
        }
        *(unsigned char *)(a1 + 85) = v54;
        goto LABEL_54;
      case 0xEu:
        *(unsigned char *)(a1 + 88) |= 1u;
        unint64_t v55 = *((void *)this + 1);
        unint64_t v56 = *((void *)this + 2);
        uint64_t v57 = *(void *)this;
        if (v55 <= 0xFFFFFFFFFFFFFFF5 && v55 + 10 <= v56)
        {
          char v58 = 0;
          unsigned int v59 = 0;
          uint64_t v60 = 0;
          do
          {
            unint64_t v61 = v55 + 1;
            *((void *)this + 1) = v55 + 1;
            char v62 = *(unsigned char *)(v57 + v55);
            v60 |= (unint64_t)(v62 & 0x7F) << v58;
            if ((v62 & 0x80) == 0) {
              goto LABEL_115;
            }
            v58 += 7;
            unint64_t v55 = v61;
            BOOL v14 = v59++ > 8;
          }
          while (!v14);
LABEL_99:
          uint64_t v60 = 0;
          goto LABEL_115;
        }
        char v75 = 0;
        unsigned int v76 = 0;
        uint64_t v60 = 0;
        if (v56 <= v55) {
          unint64_t v56 = *((void *)this + 1);
        }
        break;
      default:
        goto LABEL_20;
    }
    while (1)
    {
      if (v56 == v55)
      {
        uint64_t v60 = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_115;
      }
      unint64_t v77 = v55 + 1;
      char v78 = *(unsigned char *)(v57 + v55);
      *((void *)this + 1) = v77;
      v60 |= (unint64_t)(v78 & 0x7F) << v75;
      if ((v78 & 0x80) == 0) {
        break;
      }
      v75 += 7;
      unint64_t v55 = v77;
      BOOL v14 = v76++ > 8;
      if (v14) {
        goto LABEL_99;
      }
    }
    if (*((unsigned char *)this + 24)) {
      uint64_t v60 = 0;
    }
LABEL_115:
    *(void *)(a1 + 8) = v60;
    goto LABEL_54;
  }
  int v4 = 0;
  return v4 == 0;
}

uint64_t sub_10046711C(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  if (*(void *)(result + 64)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 40)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 32)) {
    uint64_t result = PB::Writer::write();
  }
  if ((*(unsigned char *)(v3 + 88) & 8) != 0) {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 80), 5u);
  }
  if (*(void *)(v3 + 56)) {
    uint64_t result = PB::Writer::write();
  }
  char v4 = *(unsigned char *)(v3 + 88);
  if ((v4 & 2) != 0)
  {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 72), 7u);
    char v4 = *(unsigned char *)(v3 + 88);
    if ((v4 & 0x10) == 0)
    {
LABEL_13:
      if ((v4 & 4) == 0) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
  }
  else if ((*(unsigned char *)(v3 + 88) & 0x10) == 0)
  {
    goto LABEL_13;
  }
  uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 84), 8u);
  if ((*(unsigned char *)(v3 + 88) & 4) != 0) {
LABEL_14:
  }
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 76), 9u);
LABEL_15:
  if (*(void *)(v3 + 48)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 16)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 24)) {
    uint64_t result = PB::Writer::write();
  }
  char v5 = *(unsigned char *)(v3 + 88);
  if ((v5 & 0x20) != 0)
  {
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 85), 0xDu);
    char v5 = *(unsigned char *)(v3 + 88);
  }
  if (v5)
  {
    unint64_t v6 = *(void *)(v3 + 8);
    return PB::Writer::writeVarInt(this, v6, 0xEu);
  }
  return result;
}

void sub_100467284(DaemonFactory *a1)
{
  DaemonFactory::~DaemonFactory(a1);

  operator delete();
}

void sub_1004672BC(void *a1@<X8>)
{
}

uint64_t sub_1004672C4()
{
  return CommandDriversFactory::create();
}

void sub_1004672CC(uint64_t *a1@<X1>, void *a2@<X8>)
{
  uint64_t v3 = *a1;
  unint64_t v2 = (std::__shared_weak_count *)a1[1];
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *a2 = off_1019CE9B8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    a2[3] = a2;
    sub_10004D2C8(v2);
  }
  else
  {
    a2[3] = a2;
  }
}

void sub_100467324(void *a1@<X8>)
{
}

void sub_10046732C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100BEB578();
}

void sub_10046737C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100467394(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ServiceManager::create(a2, a3);
}

void sub_1004673A0(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1006B4C9C(a2);
}

void sub_1004673F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100467408(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100C62948(a2);
}

void sub_100467458(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100467470(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1008BF510(&v3);
}

void sub_1004674D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004674EC(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x30uLL);
  sub_100467550(v2);
  *a1 = v2 + 3;
  a1[1] = v2;

  sub_1000B3BC8((uint64_t)a1, v2 + 4, (uint64_t)(v2 + 3));
}

void sub_10046753C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100467550(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019CE968;
  DaemonFactory::DaemonFactory((DaemonFactory *)(a1 + 3));
  a1[3] = off_1019CE8E0;
  return a1;
}

void sub_1004675B4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1004675C8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019CE968;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004675E8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019CE968;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10046763C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 80))();
}

void *sub_100467664(void *a1)
{
  *a1 = off_1019CE9B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1004676B0(void *a1)
{
  *a1 = off_1019CE9B8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_10046771C(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_1019CE9B8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100467778(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019CE9B8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1004677B0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1004677C0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

uint64_t sub_100467800(uint64_t a1)
{
  return ctu::RestDispatchListener::createConnector(*(ctu::RestDispatchListener **)(*(void *)(a1 + 8) + 40));
}

uint64_t sub_10046780C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10046784C()
{
}

void sub_100467858()
{
}

void sub_1004678F8()
{
}

uint64_t sub_10046791C(void *a1)
{
  *a1 = off_1019CEA48;
  uint64_t v2 = a1[29];
  a1[29] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  return sub_1007F84D0((uint64_t)a1);
}

void sub_1004679A0(void *a1)
{
  sub_10046791C(a1);

  operator delete();
}

uint64_t sub_1004679D8(uint64_t a1)
{
  uint64_t result = sub_1007FADB8(a1);
  if (result) {
    return *(void *)(a1 + 112) || *(void *)(a1 + 128) != 0;
  }
  return result;
}

void sub_100467A1C(void *a1)
{
  sub_1007F7F5C((uint64_t)a1);
  sub_10003E168(&buf, a1 + 1);
  uint64_t v2 = *(std::__shared_weak_count **)&buf_4[4];
  if (*(void *)&buf_4[4])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf_4[4] + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
  }
  char v3 = sub_1007F89C4((uint64_t)a1);
  int v4 = sub_1007F82A8(0, v3);
  char v5 = a1[5];
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      int buf = 136315394;
      *(void *)buf_4 = "";
      *(_WORD *)&buf_4[8] = 2080;
      *(void *)&buf_4[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sUsing IDS for Thumper settings sync!", (uint8_t *)&buf, 0x16u);
    }
    uint64_t v7 = a1[7];
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    sub_100830298();
  }
  if (v6)
  {
    int buf = 136315394;
    *(void *)buf_4 = "";
    *(_WORD *)&buf_4[8] = 2080;
    *(void *)&buf_4[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sUsing iCloud-KVS for Thumper sync", (uint8_t *)&buf, 0x16u);
  }
  uint64_t v8 = a1[7];
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100830298();
}

void sub_100468410(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,std::__shared_weak_count *a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,std::__shared_weak_count *a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a14) {
    std::__shared_weak_count::__release_weak(a14);
  }
  if (v64) {
    sub_10004D2C8(v64);
  }
  if (a23) {
    std::__shared_weak_count::__release_weak(a23);
  }
  char v67 = *(std::__shared_weak_count **)(v65 - 104);
  if (v67) {
    sub_10004D2C8(v67);
  }
  if (v63) {
    std::__shared_weak_count::__release_weak(v63);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100468668(uint64_t a1, const __CFString *a2)
{
  return sub_1007FD558(*(void *)(a1 + 32), a2);
}

void sub_100468670(uint64_t a1, uint64_t a2)
{
  char v3 = *(void **)(a1 + 32);
  int v4 = (uint64_t *)v3[14];
  char v5 = *(uint64_t **)a2;
  if ((v4 != 0) == (v5 != 0))
  {
    if (!v5 || (sub_100469780(v4, v5) & 1) != 0) {
      return;
    }
    char v5 = *(uint64_t **)a2;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (std::__shared_weak_count *)v3[15];
  v3[14] = v5;
  v3[15] = v6;
  if (v7) {
    sub_10004D2C8(v7);
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_1004687D4;
  v9[3] = &unk_1019CEAD8;
  v9[4] = v3;
  uint64_t v12 = 0;
  char v13 = 0;
  sub_10003E168(&v12, v3 + 1);
  uint64_t v8 = v3[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100469AE8;
  block[3] = &unk_1019CED28;
  block[5] = v12;
  unint64_t v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v9;
  dispatch_async(v8, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_1004687D4(uint64_t a1)
{
}

BOOL sub_1004687DC(uint64_t a1, const __CFString *a2)
{
  char v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v3) {
    return 0;
  }
  char v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  if (*(void *)(a1 + 32)) {
    BOOL v7 = CFStringHasPrefix(a2, @"secret.") == 1;
  }
  else {
    BOOL v7 = 0;
  }
  sub_10004D2C8(v6);
  return v7;
}

void sub_100468858(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10046886C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100468888(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void *sub_100468898(void *a1, uint64_t *a2)
{
  sub_100469B24((uint64_t *)&v6, a2);
  char v3 = (std::__shared_weak_count *)a1[1];
  long long v4 = v6;
  *(void *)&long long v6 = *a1;
  *((void *)&v6 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

BOOL sub_1004688E4(uint64_t a1, const __CFString *a2)
{
  char v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v3) {
    return 0;
  }
  char v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return 0;
  }
  long long v6 = v5;
  BOOL v7 = *(void *)(a1 + 32) && !CFStringHasPrefix(a2, @"secret.") && CFStringHasPrefix(a2, @"message.") == 0;
  sub_10004D2C8(v6);
  return v7;
}

void sub_100468974(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

BOOL sub_100468988(uint64_t a1, const __CFString *a2)
{
  char v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v3) {
    return 0;
  }
  char v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return 0;
  }
  long long v6 = v5;
  if (*(void *)(a1 + 32)) {
    BOOL v7 = CFStringHasPrefix(a2, @"message.") == 1;
  }
  else {
    BOOL v7 = 0;
  }
  sub_10004D2C8(v6);
  return v7;
}

void sub_100468A04(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

BOOL sub_100468A18(id a1, __CFString *a2, void *a3)
{
  return 0;
}

void sub_100468A20(uint64_t a1, uint64_t a2)
{
  char v3 = *(void **)(a1 + 32);
  long long v4 = (uint64_t *)v3[16];
  char v5 = *(uint64_t **)a2;
  if ((v4 != 0) == (v5 != 0))
  {
    if (!v5 || (sub_100469780(v4, v5) & 1) != 0) {
      return;
    }
    char v5 = *(uint64_t **)a2;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v7 = (std::__shared_weak_count *)v3[17];
  v3[16] = v5;
  v3[17] = v6;
  if (v7) {
    sub_10004D2C8(v7);
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_100468B84;
  v9[3] = &unk_1019CEBE8;
  v9[4] = v3;
  uint64_t v12 = 0;
  char v13 = 0;
  sub_10003E168(&v12, v3 + 1);
  uint64_t v8 = v3[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100469AE8;
  block[3] = &unk_1019CED28;
  block[5] = v12;
  unint64_t v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v9;
  dispatch_async(v8, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_100468B84(uint64_t a1)
{
}

BOOL sub_100468B8C(uint64_t a1, const __CFString *a2)
{
  char v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v3) {
    return 0;
  }
  char v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  if (*(void *)(a1 + 32)) {
    BOOL v7 = CFStringHasPrefix(a2, @"secret.") == 1;
  }
  else {
    BOOL v7 = 0;
  }
  sub_10004D2C8(v6);
  return v7;
}

void sub_100468C08(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

BOOL sub_100468C1C(uint64_t a1, const __CFString *a2)
{
  char v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v3) {
    return 0;
  }
  char v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  if (*(void *)(a1 + 32)) {
    BOOL v7 = CFStringHasPrefix(a2, @"message.") == 1;
  }
  else {
    BOOL v7 = 0;
  }
  sub_10004D2C8(v6);
  return v7;
}

void sub_100468C98(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100468CAC(void *a1)
{
  sub_1007F85F4(a1);
  uint64_t result = a1[29];
  if (result)
  {
    uint64_t v3 = a1[3];
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = sub_100468D54;
    uint64_t v4[3] = &unk_1019CEC88;
    void v4[4] = a1;
    return (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(void *)result + 64))(result, v3, v4);
  }
  return result;
}

void sub_100468D54(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    int v2 = 136315394;
    uint64_t v3 = "";
    __int16 v4 = 2080;
    char v5 = "";
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I %s%smessage received via remote IDS ignored", (uint8_t *)&v2, 0x16u);
  }
}

const void **sub_100468E04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(unsigned __int8 *)(a3 + 23);
    BOOL v8 = (v7 & 0x80u) != 0;
    char v9 = *(const char **)a3;
    if ((v7 & 0x80u) != 0) {
      uint64_t v7 = *(void *)(a3 + 8);
    }
    if (!v8) {
      char v9 = (const char *)a3;
    }
    if (v7) {
      unsigned int v10 = v9;
    }
    else {
      unsigned int v10 = "<invalid>";
    }
    *(_DWORD *)int buf = 136315650;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "";
    *(_WORD *)&buf[22] = 2080;
    unint64_t v31 = v10;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sRequesting individual secret for account '%s'", buf, 0x20u);
  }
  CFMutableDictionaryRef theDict = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v12 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    *(void *)int buf = v12;
    sub_10005717C((const void **)buf);
  }
  CFDictionaryAddValue(theDict, @"cmd", @"requestIndividualSecret");
  char v13 = (const void *)sub_1007FA824((void *)a1);
  CFDictionaryAddValue(theDict, @"sender", v13);
  CFMutableDictionaryRef v23 = 0;
  CFMutableDictionaryRef v14 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v14)
  {
    CFMutableDictionaryRef v15 = v23;
    CFMutableDictionaryRef v23 = v14;
    *(void *)int buf = v15;
    sub_10005717C((const void **)buf);
  }
  unsigned int v16 = v23;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v20, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)unint64_t v20 = *(_OWORD *)a3;
    uint64_t v21 = *(void *)(a3 + 16);
  }
  if (SHIBYTE(v21) < 0)
  {
    sub_10004FC84(__p, v20[0], (unint64_t)v20[1]);
  }
  else
  {
    *(_OWORD *)__n128 __p = *(_OWORD *)v20;
    uint64_t v27 = v21;
  }
  char v25 = 0;
  if (SHIBYTE(v27) < 0)
  {
    sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)int buf = *(_OWORD *)__p;
    *(void *)&uint8_t buf[16] = v27;
  }
  unint64_t v28 = 0;
  if (ctu::cf::convert_copy())
  {
    unint64_t v17 = v25;
    char v25 = v28;
    char v29 = v17;
    sub_1000558F4(&v29);
  }
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  char v18 = v25;
  unint64_t v22 = v25;
  char v25 = 0;
  sub_1000558F4(&v25);
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  CFDictionaryAddValue(v16, @"account", v18);
  sub_1000558F4(&v22);
  if (SHIBYTE(v21) < 0) {
    operator delete(v20[0]);
  }
  CFDictionaryAddValue(theDict, @"value", v23);
  (*(void (**)(void, uint64_t, const __CFString *, CFMutableDictionaryRef))(**(void **)(a1 + 168) + 48))(*(void *)(a1 + 168), a2, @"message.", theDict);
  sub_10005717C((const void **)&v23);
  return sub_10005717C((const void **)&theDict);
}

void sub_100469124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, const void *a19, const void *a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_10005717C(&a18);
  sub_10005717C(&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_1004691AC(uint64_t a1, const __CFArray *a2)
{
  if (a2)
  {
    CFDictionaryRef theDict = 0;
    sub_1007F7D50(&theDict);
    if (theDict) {
      __int16 v4 = sub_100080778;
    }
    else {
      __int16 v4 = 0;
    }
    if (v4)
    {
      CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
      int Count = CFArrayGetCount(a2);
      if (Count >= 1)
      {
        CFIndex v6 = 0;
        uint64_t v7 = Count;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(a2, v6);
          CFDictionaryRemoveValue(MutableCopy, ValueAtIndex);
          ++v6;
        }
        while (v7 != v6);
      }
      int v9 = CFDictionaryGetCount(MutableCopy);
      keys = 0;
      char v18 = 0;
      uint64_t v19 = 0;
      sub_10019E8F0(&keys, v9);
      CFDictionaryGetKeysAndValues(MutableCopy, (const void **)keys, 0);
      unsigned int v10 = keys;
      unint64_t v11 = v18;
      if (keys != v18)
      {
        do
        {
          sub_1003A9CA0(buf);
          sub_1003A9C3C(*(uint64_t *)buf, (const __CFString *)*v10, 0);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          CFMutableDictionaryRef v12 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            long long v22 = 0uLL;
            uint64_t v23 = 0;
            ctu::cf::assign();
            *(_OWORD *)__n128 __p = v22;
            uint64_t v16 = v23;
            char v13 = (void **)v22;
            if (v23 >= 0) {
              char v13 = __p;
            }
            *(_DWORD *)int buf = 136315650;
            *(void *)&uint8_t buf[4] = "";
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "";
            __int16 v25 = 2080;
            unsigned int v26 = v13;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%slocal record %s dropped on full sync", buf, 0x20u);
            if (SHIBYTE(v16) < 0) {
              operator delete(__p[0]);
            }
          }
          ++v10;
        }
        while (v10 != v11);
        unsigned int v10 = keys;
      }
      if (v10)
      {
        char v18 = v10;
        operator delete(v10);
      }
      sub_10005717C((const void **)&MutableCopy);
    }
    sub_100057D78((const void **)&theDict);
  }
  return sub_1007FE1A0(a1);
}

void sub_1004693FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, const void *a18, const void *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10005717C(&a18);
  sub_100057D78(&a19);
  _Unwind_Resume(a1);
}

void sub_10046947C(uint64_t a1@<X0>, __CFDictionary **a2@<X8>)
{
  *a2 = 0;
  sub_100802FA4(a1, a2);
  __int16 v4 = *a2;
  if (*a2) {
    char v5 = sub_1000C06D0;
  }
  else {
    char v5 = 0;
  }
  if (v5)
  {
    int v6 = capabilities::ct::supportsThumperService(v3);
    uint64_t v7 = (const void **)&kCFBooleanFalse;
    if (v6) {
      uint64_t v7 = (const void **)&kCFBooleanTrue;
    }
    CFDictionaryAddValue(v4, kPSThumperCalling, *v7);
    value = 0;
    getAssociatedID(&value);
    if (value) {
      BOOL v8 = sub_1000810B8;
    }
    else {
      BOOL v8 = 0;
    }
    if (v8) {
      CFDictionaryAddValue(*a2, kPSAssociatedAccountID, value);
    }
    sub_1000558F4((const void **)&value);
  }
}

void sub_100469548(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  sub_10005717C(v2);
  _Unwind_Resume(a1);
}

void sub_100469570(uint64_t a1, CFStringRef theString1, uint64_t a3, const void *a4)
{
  if (CFStringCompare(theString1, @"individualSecret", 0))
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v22 = 136315650;
    uint64_t v23 = "";
    __int16 v24 = 2080;
    __int16 v25 = "";
    __int16 v26 = 2112;
    CFStringRef v27 = theString1;
    BOOL v8 = "#I %s%sMessage cmd is not recognized: %@";
    int v9 = v7;
    uint32_t v10 = 32;
LABEL_21:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v22, v10);
    return;
  }
  if (!a4 || (CFTypeID v11 = CFGetTypeID(a4), v11 != CFDataGetTypeID()))
  {
    uint64_t v21 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v22 = 136315394;
    uint64_t v23 = "";
    __int16 v24 = 2080;
    __int16 v25 = "";
    BOOL v8 = "#I %s%sMessage 'individualSecret' is of invalid format";
    int v9 = v21;
    uint32_t v10 = 22;
    goto LABEL_21;
  }
  CFMutableDictionaryRef v12 = *(void **)(a1 + 72);
  char v13 = (void *)(a1 + 80);
  if (v12 != v13)
  {
    do
    {
      CFMutableDictionaryRef v14 = (std::__shared_weak_count *)v12[6];
      if (v14)
      {
        CFMutableDictionaryRef v15 = std::__shared_weak_count::lock(v14);
        if (v15)
        {
          uint64_t v16 = v15;
          uint64_t v17 = v12[5];
          if (v17) {
            (*(void (**)(uint64_t, const void *))(*(void *)v17 + 88))(v17, a4);
          }
          sub_10004D2C8(v16);
        }
      }
      char v18 = (void *)v12[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          char v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v12[2];
          BOOL v20 = *v19 == (void)v12;
          CFMutableDictionaryRef v12 = v19;
        }
        while (!v20);
      }
      CFMutableDictionaryRef v12 = v19;
    }
    while (v19 != v13);
  }
}

void sub_100469764(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100469780(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1];
  if (v2 - *a1 == a2[1] - *a2)
  {
    if (v2 == *a1) {
      return 1;
    }
    uint64_t v5 = 0;
    while (1)
    {
      uint64_t v6 = *a2;
      uint64_t v7 = a2[1];
      if (*a2 == v7) {
        break;
      }
      while (CFStringCompare(*(CFStringRef *)(*a1 + 24 * v5), *(CFStringRef *)v6, 0))
      {
        v6 += 24;
        if (v6 == v7)
        {
          uint64_t v6 = v7;
          break;
        }
      }
      if (v6 == a2[1]) {
        break;
      }
      uint64_t v8 = *a1;
      CFStringRef v9 = *(const __CFString **)(*a1 + 24 * v5);
      uint32_t v10 = v9 ? sub_1000810B8 : 0;
      CFTypeID v11 = *(void *)v6 ? sub_1000810B8 : 0;
      if ((v10 == 0) == (v11 != 0) || v10 && CFStringCompare(v9, *(CFStringRef *)v6, 0)) {
        break;
      }
      CFStringRef v12 = *(const __CFString **)(v8 + 24 * v5 + 8);
      char v13 = v12 ? sub_1000810B8 : 0;
      CFStringRef v14 = *(const __CFString **)(v6 + 8);
      CFMutableDictionaryRef v15 = v14 ? sub_1000810B8 : 0;
      if ((v13 == 0) == (v15 != 0)
        || v13 && CFStringCompare(v12, v14, 0)
        || *(unsigned __int8 *)(v8 + 24 * v5 + 16) != *(unsigned __int8 *)(v6 + 16))
      {
        break;
      }
      if (++v5 >= 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3)) {
        return 1;
      }
    }
  }
  return 0;
}

void sub_100469918(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1004699E4(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100469ABC);
  __cxa_rethrow();
}

void sub_100469A0C(_Unwind_Exception *a1)
{
}

void sub_100469A24(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100469A5C(uint64_t a1)
{
}

uint64_t sub_100469A78(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100469ABC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100469AE8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100469AF8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100469B14(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t *sub_100469B24(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *uint64_t result = *a2;
  if (v2) {
    operator new();
  }
  result[1] = 0;
  *a2 = 0;
  return result;
}

void sub_100469BA8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100469BE0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100469C10(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

void emergency::CallManager::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10046A164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, ctu::OsLogLogger *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, dispatch_object_t object, dispatch_object_t a17, dispatch_object_t a18, dispatch_object_t a19, void *__p,std::__shared_weak_count *a21,int a22,__int16 a23,char a24,char a25)
{
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 8))(a14);
  }
  if (a21) {
    sub_10004D2C8(a21);
  }
  sub_10004D2C8(v25);
  _Unwind_Resume(a1);
}

void sub_10046A3CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v5);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  JUMPOUT(0x10046A370);
}

void sub_10046A3FC()
{
}

uint64_t sub_10046A404(uint64_t a1)
{
  *(void *)a1 = off_1019CEDC8;
  *(void *)(a1 + 48) = off_1019CEF10;
  uint64_t v2 = *(void *)(a1 + 640);
  *(void *)(a1 + 640) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 632);
  *(void *)(a1 + 632) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 624);
  *(void *)(a1 + 624) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void **)(a1 + 600);
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(a1 + 576);
  if (v6)
  {
    *(void *)(a1 + 584) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *(void **)(a1 + 528);
  if (v7)
  {
    *(void *)(a1 + 536) = v7;
    operator delete(v7);
  }
  uint64_t v8 = *(void **)(a1 + 488);
  if (v8)
  {
    *(void *)(a1 + 496) = v8;
    operator delete(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 464);
  if (v9) {
    sub_10004D2C8(v9);
  }
  char v18 = (void **)(a1 + 432);
  sub_1004716FC(&v18);
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 424);
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 408);
  if (v11) {
    sub_10004D2C8(v11);
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 392);
  if (v12) {
    sub_10004D2C8(v12);
  }
  char v13 = *(std::__shared_weak_count **)(a1 + 376);
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_1004717D0((void *)(a1 + 328));
  EmergencyMode::~EmergencyMode((EmergencyMode *)(a1 + 304));
  sub_100471678((void *)(a1 + 272));
  EmergencyMode::~EmergencyMode((EmergencyMode *)(a1 + 252));
  sub_1000346F8(a1 + 216, *(void **)(a1 + 224));
  sub_10005CD2C(a1 + 192, *(char **)(a1 + 200));
  sub_10005CD2C(a1 + 168, *(char **)(a1 + 176));
  char v18 = (void **)(a1 + 136);
  sub_10008A88C(&v18);
  CFStringRef v14 = *(std::__shared_weak_count **)(a1 + 112);
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_100160A84((atomic_uint **)(a1 + 80));
  CFMutableDictionaryRef v15 = *(std::__shared_weak_count **)(a1 + 72);
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v16 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v16) {
    sub_100471E24(v16);
  }
  EmergencyManagerInterface::~EmergencyManagerInterface((EmergencyManagerInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_10046A62C(uint64_t a1)
{
  return sub_10046A404(a1 - 48);
}

void sub_10046A634(uint64_t a1)
{
  sub_10046A404(a1);

  operator delete();
}

void sub_10046A66C(uint64_t a1)
{
  sub_10046A404(a1 - 48);

  operator delete();
}

void sub_10046A6A8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  uint64_t v5 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10046A7E8(uint64_t a1, uint64_t a2, char a3, char a4, int a5)
{
  memset(__p, 0, sizeof(__p));
  sub_10035D43C(__p, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  char v11 = a3;
  int v12 = a5;
  char v13 = a4;
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 16);
  if (v9)
  {
    if (std::__shared_weak_count::lock(v9)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10046A94C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10046AA2C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10046AB0C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10046ABEC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10046ACE0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10046ADD4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10046AEB4(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      uint64_t v6 = v5;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v5);
    }
    else
    {
      uint64_t v6 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10046B0A8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10046B0C4(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100478BC0;
  void v5[3] = &unk_1019CFA88;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10005ACE4;
    uint64_t v10 = &unk_1019CFAC8;
    char v11 = &v13;
    int v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_100059F80;
    uint64_t v10 = &unk_1019CFAA8;
    char v11 = &v13;
    int v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

BOOL sub_10046B1F4(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100478C1C;
  void v5[3] = &unk_1019CFAE8;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10005ACE4;
    uint64_t v10 = &unk_1019CFAC8;
    char v11 = &v13;
    int v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_100059F80;
    uint64_t v10 = &unk_1019CFAA8;
    char v11 = &v13;
    int v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

uint64_t sub_10046B324(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100478C54;
  void v5[3] = &unk_1019CFB08;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    unsigned int v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_100478CC0;
    uint64_t v10 = &unk_1019CFB48;
    char v11 = &v13;
    int v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    unsigned int v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_100478C84;
    uint64_t v10 = &unk_1019CFB28;
    char v11 = &v13;
    int v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13;
}

void sub_10046B44C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6[0] = a1;
  v6[1] = a2;
  v6[2] = a3;
  uint64_t v6[3] = a4;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100478CFC;
  block[3] = &unk_1019CFB68;
  block[4] = a1 + 8;
  block[5] = v6;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8)) {
    dispatch_async_and_wait(v4, block);
  }
  else {
    dispatch_sync(v4, block);
  }
}

void sub_10046B4D8(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100478E0C;
  void v5[3] = &unk_1019CFB88;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_100478EA0;
    uint64_t v10 = &unk_1019CFBC8;
    char v11 = a2;
    int v12 = &v6;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_100478E34;
    uint64_t v10 = &unk_1019CFBA8;
    char v11 = a2;
    int v12 = &v6;
    dispatch_sync(v2, &block);
  }
}

void sub_10046B5FC(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100478F0C;
  void v5[3] = &unk_1019CFBE8;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_100478EA0;
    uint64_t v10 = &unk_1019CFBC8;
    char v11 = a2;
    int v12 = &v6;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_100478E34;
    uint64_t v10 = &unk_1019CFBA8;
    char v11 = a2;
    int v12 = &v6;
    dispatch_sync(v2, &block);
  }
}

uint64_t sub_10046B720(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I call connected", buf, 2u);
  }
  sub_10046B79C(a1);
  return sub_100478F30(*(void *)(a1 + 56), (uint64_t)&v4, 1);
}

void sub_10046B79C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 624);
  if (v1)
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)char v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Cancel Tlte timer", v4, 2u);
      uint64_t v1 = *(void *)(a1 + 624);
      *(void *)(a1 + 624) = 0;
      if (!v1) {
        return;
      }
    }
    else
    {
      *(void *)(a1 + 624) = 0;
    }
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

void sub_10046B84C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I call in progress", v3, 2u);
  }
  sub_10046B79C(a1);
}

void sub_10046B8B8(uint64_t a1, uint64_t a2, char a3)
{
  int v5 = *(_DWORD *)(a1 + 124);
  int v6 = *(unsigned __int8 *)(a1 + 128);
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (v6) {
      uint64_t v8 = "Entered";
    }
    else {
      uint64_t v8 = "Exited";
    }
    int v14 = 136315394;
    uint64_t v15 = (uint64_t)v8;
    __int16 v16 = 2080;
    uint64_t v17 = EmCallTypeAsString();
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s EEM as %s", (uint8_t *)&v14, 0x16u);
  }
  if (v6) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = (a3 & 1) == 0;
  }
  if (!v9)
  {
    uint64_t v10 = *(void *)(a1 + 520);
    if (v10 && (*(unsigned int (**)(uint64_t))(*(void *)v10 + 72))(v10) != v5)
    {
      char v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        uint64_t v12 = EmCallTypeAsString();
        uint64_t v13 = (*(uint64_t (**)(void))(**(void **)(a1 + 520) + 56))(*(void *)(a1 + 520));
        int v14 = 136315394;
        uint64_t v15 = v12;
        __int16 v16 = 2080;
        uint64_t v17 = v13;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "!! EEM exit call type %s doesn't match current call agent %s", (uint8_t *)&v14, 0x16u);
      }
    }
    sub_100479318(*(void *)(a1 + 56), (uint64_t)&v14, 1);
  }
}

uint64_t sub_10046BA7C(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 40);
  *(void *)(a2 + 16) = *(void *)(result + 32);
  int v3 = *(_DWORD *)(result + 40);
  *(_DWORD *)(a2 + 40) = v2 | 0x12;
  *(_DWORD *)(a2 + 32) = v3;
  return result;
}

void *sub_10046BAA0(void *result)
{
  uint64_t v1 = (uint64_t)result;
  if (*((unsigned char *)result + 128))
  {
    int v2 = *((_DWORD *)result + 31);
    if (v2 != 1)
    {
      int v3 = result[5];
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I still in SIP EEM, exit first.", buf, 2u);
        int v2 = *(_DWORD *)(v1 + 124);
      }
      uint64_t result = sub_1013FEFC8(*(void **)(v1 + 416), *(_DWORD *)(v1 + 512), 0, v2);
    }
  }
  if (*(void *)(v1 + 520))
  {
    char v4 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I clear current agent", v5, 2u);
    }
    sub_10046B79C(v1);
    uint64_t result = (void *)(*(uint64_t (**)(void))(**(void **)(v1 + 520) + 24))(*(void *)(v1 + 520));
  }
  *(void *)(v1 + 520) = 0;
  return result;
}

void sub_10046BBB0(uint64_t a1)
{
  *(void *)(a1 + 552) = 0;
  *(void *)(a1 + 536) = *(void *)(a1 + 528);
  *(unsigned char *)(a1 + 560) = 0;
  int v2 = *(void **)(a1 + 432);
  int v3 = *(void **)(a1 + 440);
  while (v2 != v3)
  {
    int v5 = (void **)*v2++;
    char v4 = v5;
    (*(void (**)(void *))(*v5[3] + 32))(v5[3]);
    (*(void (**)(void *))(*v4[5] + 32))(v4[5]);
    (*(void (**)(void *))(*v4[1] + 32))(v4[1]);
    (*(void (**)(void *))(*v4[7] + 32))(v4[7]);
    (*(void (**)(void *))(*v4[9] + 32))(v4[9]);
    (*(void (**)(void *))(*v4[11] + 32))(v4[11]);
  }
  unint64_t v6 = *(void *)(a1 + 608);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 600);
    int v8 = 0;
    sub_10019E478((uint64_t)&v7, v6);
  }
}

uint64_t sub_10046BD10(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 400) + 24))(*(void *)(a1 + 400));
  sub_10046BAA0((void *)a1);
  sub_10046BBB0(a1);
  sub_10046BDA8(a1);
  *(void *)(a1 + 496) = *(void *)(a1 + 488);
  *(void *)(a1 + 512) = 0;
  v3[0] = 1;
  v3[1] = a1 + 328;
  *(_DWORD *)(a1 + 360) = 0;
  uint64_t result = sub_1004779B4((uint64_t)v3);
  *(void *)(a1 + 584) = *(void *)(a1 + 576);
  return result;
}

void *sub_10046BDA8(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Resetting emergency mode..", v4, 2u);
  }
  v5[0] = off_1019CFC58;
  v5[1] = a1;
  void v5[3] = v5;
  sub_10046BE84(a1, (uint64_t)v5);
  return sub_10047575C(v5);
}

void sub_10046BE70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10047575C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_10046BE84(uint64_t a1, uint64_t a2)
{
  v7[0] = 0;
  v7[1] = 0;
  int v8 = 0;
  long long v5 = *(_OWORD *)(a1 + 304);
  int v6 = *(_DWORD *)(a1 + 320);
  if (!a2) {
    sub_10007B600();
  }
  (*(void (**)(void *__return_ptr, uint64_t, long long *))(*(void *)a2 + 48))(v7, a2, &v5);
  EmergencyMode::~EmergencyMode((EmergencyMode *)&v5);
  if (operator!=())
  {
    EmergencyMode::operator=();
    uint64_t v3 = *(void *)(a1 + 296);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, a1 + 304);
    }
  }
  char v4 = 0;
  UuidFromSlotIdEx();
  sub_10012577C(&v4);
  EmergencyMode::~EmergencyMode((EmergencyMode *)v7);
}

void sub_10046C3B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  char v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va2, 0);
  sub_10012577C((const void **)va);
  EmergencyMode::~EmergencyMode((EmergencyMode *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_10046C48C(uint64_t a1)
{
  sub_10046C564(a1);
  if (*(void *)(a1 + 488) == *(void *)(a1 + 496))
  {
    if (isActive()) {
      (*(void (**)(void))(**(void **)(a1 + 400) + 24))(*(void *)(a1 + 400));
    }
    sub_10046BDA8(a1);
  }
  else
  {
    int v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v4[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I In Emergency Mode for call, do nothing for T911", (uint8_t *)v4, 2u);
    }
  }
  v4[0] = 1;
  v4[1] = a1 + 328;
  *(void *)(a1 + 360) = kDefaultT911Preferences;
  return sub_1004779B4((uint64_t)v4);
}

void sub_10046C564(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 632);
  if (v1)
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)char v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Cancel T911 timer", v4, 2u);
      uint64_t v1 = *(void *)(a1 + 632);
      *(void *)(a1 + 632) = 0;
      if (!v1) {
        return;
      }
    }
    else
    {
      *(void *)(a1 + 632) = 0;
    }
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

void sub_10046C614(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      char v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        uint64_t v6 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Tlte timer expired", buf, 2u);
        }
        uint64_t v7 = *(void *)(v5 + 624);
        *(void *)(v5 + 624) = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        }
        uint64_t v8 = *(void *)(v5 + 520);
        if (v8)
        {
          char v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 48))(v8);
          uint64_t v10 = **(void **)(v5 + 520);
          if (v9)
          {
            if ((*(unsigned int (**)(void))(v10 + 72))() != 1)
            {
              char v11 = *(void **)(v5 + 416);
              int v12 = *(_DWORD *)(v5 + 512);
              int v13 = (*(uint64_t (**)(void))(**(void **)(v5 + 520) + 72))(*(void *)(v5 + 520));
              sub_1013FEFC8(v11, v12, 0, v13);
            }
          }
          else
          {
            (*(void (**)(void))(v10 + 24))();
            sub_100475334(*(void *)(v5 + 56), (uint64_t)&v15, 1);
          }
        }
        else
        {
          int v14 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)__int16 v16 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "call disconnected while not in Emergency mode? Need to check", v16, 2u);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10046C814(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10046C828(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10046C844(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10046C854(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      char v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        int v6 = *(_DWORD *)(a1 + 48);
        uint64_t v7 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Emergency Intent timer expired", buf, 2u);
        }
        if (*(_DWORD *)(v5 + 312) == 2)
        {
          *(void *)int buf = off_1019CFCD8;
          int v10 = v6;
          char v11 = buf;
          sub_10046BE84(v5, (uint64_t)buf);
          sub_10047575C(buf);
          v8[0] = 1;
          v8[1] = v5 + 328;
          *(void *)(v5 + 360) = kDefaultT911Preferences;
          sub_1004779B4((uint64_t)v8);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10046C9B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10047575C((uint64_t *)va);
  sub_10004D2C8(v3);
  _Unwind_Resume(a1);
}

void sub_10046C9D4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      char v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        int v6 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I T911 timer expired", v7, 2u);
        }
        sub_10046C48C(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10046CA8C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10046CAA0(uint64_t a1)
{
  uint64_t v2 = sub_10046CD1C(*(char **)(a1 + 488), *(char **)(a1 + 496), 1);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  uint64_t v23 = 0;
  CFTypeRef cf = 0;
  uint64_t v22 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)__p);
  if (v10)
  {
    uint64_t v12 = v10[3];
    char v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  char v11 = 0;
  char v13 = 1;
LABEL_10:
  PersonalityIdFromSlotIdEx();
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(void *)v12 + 40))(&v22, v12, __p);
  if ((v21 & 0x80000000) == 0)
  {
    if (v13) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  operator delete(__p[0]);
  if ((v13 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v11);
LABEL_13:
  if (v22)
  {
    (*(void (**)(const void **__return_ptr))(*(void *)v22 + 40))(&v19);
    CFTypeRef v14 = cf;
    CFTypeRef cf = v19;
    uint64_t v19 = 0;
    __p[0] = (void *)v14;
    sub_1000577C4((const void **)__p);
    sub_1000577C4(&v19);
  }
  char v15 = (BOOL *)cf;
  LOBYTE(__p[0]) = 0;
  if (cf)
  {
    CFTypeID v16 = CFGetTypeID(cf);
    if (v16 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)__p, v15, v17);
      LODWORD(v15) = LOBYTE(__p[0]);
    }
    else
    {
      LODWORD(v15) = 0;
    }
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
  sub_1000577C4(&cf);
  if (!v15) {
    return 0;
  }
  return v3;
}

void sub_10046CCC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, std::__shared_weak_count *a18, const void *a19)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  sub_1000577C4(&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_10046CD1C(char *a1, char *a2, int a3)
{
  uint64_t v3 = a2 - a1;
  if (a2 == a1)
  {
    if (v3 != 4) {
      return 0;
    }
    uint64_t v8 = 4;
    uint64_t v5 = 1;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v5 = v3 >> 2;
    uint64_t v6 = a1;
    do
    {
      int v7 = *(_DWORD *)v6;
      v6 += 4;
      if (!v7) {
        ++v4;
      }
    }
    while (v6 != a2);
    if (v5 - v4 != 1) {
      return 0;
    }
    uint64_t v8 = 0;
    while (*(_DWORD *)&a1[v8] != a3)
    {
      v8 += 4;
      if (&a1[v8] == a2)
      {
        uint64_t v8 = a2 - a1;
        goto LABEL_14;
      }
    }
    uint64_t v5 = v8 >> 2;
  }
LABEL_14:
  if (&a1[4 * v5] != a2) {
    return subscriber::instanceAsSimSlot((subscriber *)((unint64_t)v8 >> 2), a2);
  }
  return 0;
}

void sub_10046CDAC(void *a1, void *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v3 = a2[61];
  uint64_t v2 = a2[62];
  if (v2 == v3) {
    return;
  }
  uint64_t v5 = a1;
  unint64_t v6 = 0;
  int v7 = (Registry **)(a2 + 8);
  while (v6 < (uint64_t)(a2[55] - a2[54]) >> 3)
  {
    if ((*(_DWORD *)(v3 + 4 * v6) - 1) <= 1)
    {
      unint64_t v43 = 0;
      CFTypeRef cf = 0;
      uint64_t v42 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(*v7);
      unsigned int v9 = ServiceMap;
      if (v10 < 0)
      {
        char v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          uint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      *(void *)__n128 __p = v10;
      CFTypeRef v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)__p);
      if (v14)
      {
        uint64_t v15 = v14[3];
        CFTypeID v16 = (std::__shared_weak_count *)v14[4];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v5 = a1;
          sub_10004D2C8(v16);
          char v17 = 0;
          goto LABEL_13;
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      std::mutex::unlock(v9);
      CFTypeID v16 = 0;
      char v17 = 1;
LABEL_13:
      PersonalityIdFromSlotIdEx();
      (*(void (**)(uint64_t *__return_ptr, uint64_t, unsigned char *))(*(void *)v15 + 40))(&v42, v15, __p);
      if (v48 < 0)
      {
        operator delete(*(void **)__p);
        if ((v17 & 1) == 0) {
LABEL_15:
        }
          sub_10004D2C8(v16);
      }
      else if ((v17 & 1) == 0)
      {
        goto LABEL_15;
      }
      if (v42)
      {
        (*(void (**)(const void **__return_ptr))(*(void *)v42 + 40))(&v41);
        CFTypeRef v18 = cf;
        CFTypeRef cf = v41;
        *(void *)__n128 __p = v18;
        BOOL v41 = 0;
        sub_1000577C4((const void **)__p);
        sub_1000577C4(&v41);
      }
      uint64_t v19 = (BOOL *)cf;
      int v20 = 1;
      __p[0] = 1;
      if (cf)
      {
        CFTypeID v21 = CFGetTypeID(cf);
        if (v21 == CFBooleanGetTypeID())
        {
          ctu::cf::assign((ctu::cf *)__p, v19, v22);
          int v20 = __p[0];
        }
        else
        {
          int v20 = 1;
        }
      }
      if (v43) {
        sub_10004D2C8(v43);
      }
      sub_1000577C4(&cf);
      uint64_t v23 = 56;
      if (v20) {
        uint64_t v23 = 72;
      }
      uint64_t v24 = *(void *)(*(void *)(a2[54] + 8 * v6) + v23);
      __int16 v25 = a2[5];
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v26 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 56))(v24);
        uint64_t v27 = subscriber::asString();
        *(_DWORD *)__n128 __p = 136315394;
        *(void *)&__p[4] = v26;
        __int16 v46 = 2080;
        uint64_t v47 = v27;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I choose %s as wifi call agent for slot %s", __p, 0x16u);
      }
      char v29 = (void *)v5[1];
      unint64_t v28 = v5[2];
      if ((unint64_t)v29 >= v28)
      {
        unint64_t v31 = (void *)*v5;
        uint64_t v32 = ((uint64_t)v29 - *v5) >> 3;
        unint64_t v33 = v32 + 1;
        if ((unint64_t)(v32 + 1) >> 61) {
          sub_10006A748();
        }
        uint64_t v34 = v28 - (void)v31;
        if (v34 >> 2 > v33) {
          unint64_t v33 = v34 >> 2;
        }
        if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v35 = v33;
        }
        if (v35) {
          unint64_t v35 = (unint64_t)sub_100048350(v35);
        }
        else {
          uint64_t v36 = 0;
        }
        char v37 = (void *)(v35 + 8 * v32);
        *char v37 = v24;
        unint64_t v30 = v37 + 1;
        if (v29 != v31)
        {
          do
          {
            uint64_t v38 = *--v29;
            *--char v37 = v38;
          }
          while (v29 != v31);
          char v29 = (void *)*v5;
        }
        *uint64_t v5 = v37;
        v5[1] = v30;
        void v5[2] = v35 + 8 * v36;
        if (v29) {
          operator delete(v29);
        }
      }
      else
      {
        *char v29 = v24;
        unint64_t v30 = v29 + 1;
      }
      v5[1] = v30;
      uint64_t v3 = a2[61];
      uint64_t v2 = a2[62];
    }
    if (++v6 >= (v2 - v3) >> 2) {
      return;
    }
  }
  unint64_t v39 = a2[5];
  if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)__n128 __p = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "We have more SimPrefs than slots. Bailing out...", __p, 2u);
  }
}

void sub_10046D200(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  __int16 v25 = *(void **)a10;
  if (*(void *)a10)
  {
    *(void *)(a10 + 8) = v25;
    operator delete(v25);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10046D28C(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 224);
  if (!v3) {
    goto LABEL_11;
  }
  uint64_t v4 = a1 + 224;
  do
  {
    int v5 = *(_DWORD *)(v3 + 28);
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      int v7 = (uint64_t *)v3;
    }
    else {
      int v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 224 || *(_DWORD *)(v4 + 28) > a2)
  {
LABEL_11:
    sub_10046E12C(a1);
    return 0;
  }
  int v9 = *(_DWORD *)(v4 + 32);
  if (!sub_10046E12C(a1) || v9 != 5) {
    return 0;
  }

  return sub_10046E098(a1);
}

uint64_t sub_10046D34C(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 512);
  uint64_t v3 = *(int ***)(a1 + 432);
  uint64_t v4 = *(int ***)(a1 + 440);
  BOOL v5 = v3 == v4;
  if (!v2)
  {
    while (!v5)
    {
      if (!sub_10046D28C(a1, **v3))
      {
        BOOL v6 = *v3;
        return *((void *)v6 + 1);
      }
      BOOL v5 = ++v3 == v4;
    }
    return 0;
  }
  if (v3 != v4)
  {
    while (**v3 != v2)
    {
      if (++v3 == v4) {
        return 0;
      }
    }
  }
  if (v3 == v4) {
    return 0;
  }
  BOOL v6 = *v3;
  if (!v6 || sub_10046D28C(a1, v2)) {
    return 0;
  }
  return *((void *)v6 + 1);
}

uint64_t sub_10046D3F8(uint64_t a1, int a2, int a3)
{
  ++*(_DWORD *)(a1 + 552);
  *(_DWORD *)(a1 + 512) = a3;
  *(unsigned char *)(a1 + 560) = 0;
  if (a2)
  {
    unsigned int v4 = subscriber::simSlotAsInstance();
    uint64_t v5 = *(void *)(a1 + 488);
    if (v4 < (unint64_t)((*(void *)(a1 + 496) - v5) >> 2) && *(_DWORD *)(v5 + 4 * v4) == 2) {
      return sub_10047993C(*(void *)(a1 + 56), (uint64_t)__p, 1);
    }
    *(void *)(a1 + 536) = *(void *)(a1 + 528);
    BOOL v6 = *(int ***)(a1 + 432);
    int v7 = *(int ***)(a1 + 440);
    if (v6 != v7)
    {
      uint64_t v8 = (uint64_t *)(a1 + 224);
      while (*(_DWORD *)(a1 + 512) != **v6)
      {
LABEL_133:
        if (++v6 == v7) {
          goto LABEL_134;
        }
      }
      unsigned int v9 = subscriber::simSlotAsInstance();
      if (((*(void *)(*(void *)(a1 + 600) + (((unint64_t)v9 >> 3) & 0x1FFFFFF8)) >> v9) & 1) != 0
        && !sub_10046D28C(a1, *(_DWORD *)(a1 + 512))
        && (*(unsigned int (**)(void, void))(**(void **)(*((void *)*v6 + 1) + 120) + 48))(*(void *)(*((void *)*v6 + 1) + 120), *(unsigned int *)(*((void *)*v6 + 1) + 8)))
      {
        uint64_t v10 = *((void *)*v6 + 1);
        char v11 = *(void **)(a1 + 536);
        unint64_t v12 = *(void *)(a1 + 544);
        if ((unint64_t)v11 >= v12)
        {
          uint64_t v51 = *(void *)(a1 + 528);
          uint64_t v52 = ((uint64_t)v11 - v51) >> 3;
          if ((unint64_t)(v52 + 1) >> 61) {
            goto LABEL_175;
          }
          uint64_t v53 = v12 - v51;
          uint64_t v54 = v53 >> 2;
          if (v53 >> 2 <= (unint64_t)(v52 + 1)) {
            uint64_t v54 = v52 + 1;
          }
          if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v55 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v55 = v54;
          }
          if (v55) {
            unint64_t v55 = (unint64_t)sub_100048350(v55);
          }
          else {
            uint64_t v56 = 0;
          }
          long long v93 = (void *)(v55 + 8 * v52);
          *long long v93 = v10;
          unsigned int v13 = v93 + 1;
          std::string::size_type v94 = *(char **)(a1 + 536);
          v95 = *(char **)(a1 + 528);
          if (v94 != v95)
          {
            do
            {
              uint64_t v96 = *((void *)v94 - 1);
              v94 -= 8;
              *--long long v93 = v96;
            }
            while (v94 != v95);
            std::string::size_type v94 = *(char **)(a1 + 528);
          }
          *(void *)(a1 + 528) = v93;
          *(void *)(a1 + 536) = v13;
          *(void *)(a1 + 544) = v55 + 8 * v56;
          if (v94) {
            operator delete(v94);
          }
        }
        else
        {
          *char v11 = v10;
          unsigned int v13 = v11 + 1;
        }
        *(void *)(a1 + 536) = v13;
        unsigned int v97 = subscriber::simSlotAsInstance();
        *(void *)(*(void *)(a1 + 600) + (((unint64_t)v97 >> 3) & 0x1FFFFFF8)) &= ~(1 << v97);
        std::string v98 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_133;
        }
        LOWORD(__p[0]) = 0;
        long long v91 = v98;
        v92 = "#I Added CSAgent as preferred";
        goto LABEL_132;
      }
      int v14 = **v6;
      CFTypeRef cf = 0;
      *(void *)int buf = 0;
      long long v138 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
      CFTypeID v16 = ServiceMap;
      if (v17 < 0)
      {
        CFTypeRef v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v19 = 5381;
        do
        {
          uint64_t v17 = v19;
          unsigned int v20 = *v18++;
          uint64_t v19 = (33 * v19) ^ v20;
        }
        while (v20);
      }
      std::mutex::lock(ServiceMap);
      __p[0] = (void *)v17;
      CFTypeID v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)__p);
      if (v21)
      {
        uint64_t v22 = v21[3];
        uint64_t v23 = (std::__shared_weak_count *)v21[4];
        if (v23)
        {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v16);
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v23);
          char v24 = 0;
          goto LABEL_20;
        }
      }
      else
      {
        uint64_t v22 = 0;
      }
      std::mutex::unlock(v16);
      uint64_t v23 = 0;
      char v24 = 1;
LABEL_20:
      PersonalityIdFromSlotIdEx();
      (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v22 + 40))(buf, v22, __p);
      if (SHIBYTE(v136) < 0)
      {
        operator delete(__p[0]);
        if (v24) {
          goto LABEL_23;
        }
      }
      else if (v24)
      {
LABEL_23:
        if (*(void *)buf)
        {
          (*(void (**)(const void **__return_ptr))(**(void **)buf + 40))(&v134);
          CFTypeRef v25 = cf;
          CFTypeRef cf = v134;
          long long v134 = 0;
          __p[0] = (void *)v25;
          sub_1000577C4((const void **)__p);
          sub_1000577C4(&v134);
        }
        uint64_t v26 = (BOOL *)cf;
        LOBYTE(__p[0]) = 0;
        if (cf)
        {
          CFTypeID v27 = CFGetTypeID(cf);
          if (v27 == CFBooleanGetTypeID())
          {
            ctu::cf::assign((ctu::cf *)__p, v26, v28);
            LODWORD(v26) = LOBYTE(__p[0]);
          }
          else
          {
            LODWORD(v26) = 0;
          }
        }
        if (v138) {
          sub_10004D2C8(v138);
        }
        sub_1000577C4(&cf);
        uint64_t v29 = *v8;
        if (!*v8) {
          goto LABEL_52;
        }
        uint64_t v30 = a1 + 224;
        uint64_t v31 = *v8;
        do
        {
          int v32 = *(_DWORD *)(v31 + 28);
          BOOL v33 = v32 < v14;
          if (v32 >= v14) {
            uint64_t v34 = (uint64_t *)v31;
          }
          else {
            uint64_t v34 = (uint64_t *)(v31 + 8);
          }
          if (!v33) {
            uint64_t v30 = v31;
          }
          uint64_t v31 = *v34;
        }
        while (*v34);
        if ((uint64_t *)v30 != v8 && *(_DWORD *)(v30 + 28) <= v14 && v26 && *(_DWORD *)(v30 + 32) == 4) {
          goto LABEL_105;
        }
        uint64_t v35 = a1 + 224;
        do
        {
          int v36 = *(_DWORD *)(v29 + 28);
          BOOL v37 = v36 < v14;
          if (v36 >= v14) {
            uint64_t v38 = (uint64_t *)v29;
          }
          else {
            uint64_t v38 = (uint64_t *)(v29 + 8);
          }
          if (!v37) {
            uint64_t v35 = v29;
          }
          uint64_t v29 = *v38;
        }
        while (*v38);
        if ((uint64_t *)v35 != v8 && *(_DWORD *)(v35 + 28) <= v14)
        {
          int v50 = *(_DWORD *)(v35 + 32);
          BOOL v39 = sub_10046E12C(a1);
          if (v39 && v50 == 5)
          {
            BOOL v39 = sub_10046E098(a1);
            if (!v39) {
              goto LABEL_105;
            }
          }
        }
        else
        {
LABEL_52:
          BOOL v39 = sub_10046E12C(a1);
        }
        int v40 = capabilities::ct::supportsVoNR((capabilities::ct *)v39);
        BOOL v41 = *(void **)(a1 + 536);
        if (v40)
        {
          uint64_t v42 = *((void *)*v6 + 5);
          unint64_t v43 = *(void *)(a1 + 544);
          if ((unint64_t)v41 >= v43)
          {
            uint64_t v44 = *(void *)(a1 + 528);
            uint64_t v45 = ((uint64_t)v41 - v44) >> 3;
            if ((unint64_t)(v45 + 1) >> 61) {
              goto LABEL_175;
            }
            uint64_t v46 = v43 - v44;
            uint64_t v47 = v46 >> 2;
            if (v46 >> 2 <= (unint64_t)(v45 + 1)) {
              uint64_t v47 = v45 + 1;
            }
            if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v48 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v48 = v47;
            }
            if (v48) {
              unint64_t v48 = (unint64_t)sub_100048350(v48);
            }
            else {
              uint64_t v49 = 0;
            }
            uint64_t v57 = (void *)(v48 + 8 * v45);
            *uint64_t v57 = v42;
            BOOL v41 = v57 + 1;
            char v58 = *(char **)(a1 + 536);
            unsigned int v59 = *(char **)(a1 + 528);
            if (v58 != v59)
            {
              do
              {
                uint64_t v60 = *((void *)v58 - 1);
                v58 -= 8;
                *--uint64_t v57 = v60;
              }
              while (v58 != v59);
              char v58 = *(char **)(a1 + 528);
            }
            *(void *)(a1 + 528) = v57;
            *(void *)(a1 + 536) = v41;
            *(void *)(a1 + 544) = v48 + 8 * v49;
            if (v58) {
              operator delete(v58);
            }
          }
          else
          {
            *v41++ = v42;
          }
          *(void *)(a1 + 536) = v41;
          unint64_t v61 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I Added SoSVoNRAgent", (uint8_t *)__p, 2u);
            BOOL v41 = *(void **)(a1 + 536);
          }
        }
        uint64_t v62 = *((void *)*v6 + 3);
        unint64_t v63 = *(void *)(a1 + 544);
        if ((unint64_t)v41 >= v63)
        {
          uint64_t v65 = *(void *)(a1 + 528);
          uint64_t v66 = ((uint64_t)v41 - v65) >> 3;
          if ((unint64_t)(v66 + 1) >> 61) {
            goto LABEL_175;
          }
          uint64_t v67 = v63 - v65;
          uint64_t v68 = v67 >> 2;
          if (v67 >> 2 <= (unint64_t)(v66 + 1)) {
            uint64_t v68 = v66 + 1;
          }
          if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v69 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v69 = v68;
          }
          if (v69) {
            unint64_t v69 = (unint64_t)sub_100048350(v69);
          }
          else {
            uint64_t v70 = 0;
          }
          char v71 = (void *)(v69 + 8 * v66);
          *char v71 = v62;
          unsigned int v64 = v71 + 1;
          unsigned int v72 = *(char **)(a1 + 536);
          unint64_t v73 = *(char **)(a1 + 528);
          if (v72 != v73)
          {
            do
            {
              uint64_t v74 = *((void *)v72 - 1);
              v72 -= 8;
              *--char v71 = v74;
            }
            while (v72 != v73);
            unsigned int v72 = *(char **)(a1 + 528);
          }
          *(void *)(a1 + 528) = v71;
          *(void *)(a1 + 536) = v64;
          *(void *)(a1 + 544) = v69 + 8 * v70;
          if (v72) {
            operator delete(v72);
          }
        }
        else
        {
          *BOOL v41 = v62;
          unsigned int v64 = v41 + 1;
        }
        *(void *)(a1 + 536) = v64;
        char v75 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I Added SoSVoLTEAgent", (uint8_t *)__p, 2u);
        }
LABEL_105:
        if (sub_10046D28C(a1, **v6)) {
          goto LABEL_133;
        }
        uint64_t v76 = *((void *)*v6 + 1);
        unint64_t v77 = *(void **)(a1 + 536);
        unint64_t v78 = *(void *)(a1 + 544);
        if ((unint64_t)v77 >= v78)
        {
          uint64_t v80 = *(void *)(a1 + 528);
          uint64_t v81 = ((uint64_t)v77 - v80) >> 3;
          if ((unint64_t)(v81 + 1) >> 61) {
LABEL_175:
          }
            sub_10006A748();
          uint64_t v82 = v78 - v80;
          uint64_t v83 = v82 >> 2;
          if (v82 >> 2 <= (unint64_t)(v81 + 1)) {
            uint64_t v83 = v81 + 1;
          }
          if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v84 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v84 = v83;
          }
          if (v84) {
            unint64_t v84 = (unint64_t)sub_100048350(v84);
          }
          else {
            uint64_t v85 = 0;
          }
          v86 = (void *)(v84 + 8 * v81);
          void *v86 = v76;
          uint64_t v79 = v86 + 1;
          long long v87 = *(char **)(a1 + 536);
          v88 = *(char **)(a1 + 528);
          if (v87 != v88)
          {
            do
            {
              uint64_t v89 = *((void *)v87 - 1);
              v87 -= 8;
              *--v86 = v89;
            }
            while (v87 != v88);
            long long v87 = *(char **)(a1 + 528);
          }
          *(void *)(a1 + 528) = v86;
          *(void *)(a1 + 536) = v79;
          *(void *)(a1 + 544) = v84 + 8 * v85;
          if (v87) {
            operator delete(v87);
          }
        }
        else
        {
          *unint64_t v77 = v76;
          uint64_t v79 = v77 + 1;
        }
        *(void *)(a1 + 536) = v79;
        v90 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_133;
        }
        LOWORD(__p[0]) = 0;
        long long v91 = v90;
        v92 = "#I Added CSAgent";
LABEL_132:
        _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, v92, (uint8_t *)__p, 2u);
        goto LABEL_133;
      }
      sub_10004D2C8(v23);
      goto LABEL_23;
    }
LABEL_134:
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v136 = 0;
    sub_10046CDAC(__p, (void *)a1);
    std::string v99 = (char *)__p[0];
    if ((char *)__p[1] - (char *)__p[0] < 1) {
      goto LABEL_170;
    }
    unint64_t v100 = *(void *)(a1 + 536);
    int64_t v101 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    uint64_t v102 = *(void *)(a1 + 528);
    uint64_t v103 = v100 - v102;
    std::string v104 = (char *)(v102 + ((v100 - v102) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v105 = *(void *)(a1 + 544);
    if (v101 <= (uint64_t)(v105 - v100) >> 3)
    {
      uint64_t v112 = (uint64_t)(v100 - (void)v104) >> 3;
      if (v112 >= v101)
      {
        std::string v113 = (char *)__p[0] + 8 * v101;
        std::string v115 = *(char **)(a1 + 536);
      }
      else
      {
        std::string v113 = (char *)__p[0] + 8 * v112;
        std::string v114 = (char *)((char *)__p[1] - (char *)v113);
        if (__p[1] != v113) {
          memmove(*(void **)(a1 + 536), (char *)__p[0] + 8 * v112, (char *)__p[1] - (char *)v113);
        }
        std::string v115 = &v114[v100];
        *(void *)(a1 + 536) = &v114[v100];
        if ((uint64_t)(v100 - (void)v104) < 1) {
          goto LABEL_170;
        }
      }
      std::string v116 = &v104[8 * v101];
      std::string v117 = &v115[-8 * v101];
      v118 = v115;
      if ((unint64_t)v117 < v100)
      {
        v118 = v115;
        do
        {
          uint64_t v119 = *(void *)v117;
          v117 += 8;
          *(void *)v118 = v119;
          v118 += 8;
        }
        while ((unint64_t)v117 < v100);
      }
      *(void *)(a1 + 536) = v118;
      if (v115 != v116) {
        memmove(&v115[-8 * ((v115 - v116) >> 3)], v104, v115 - v116);
      }
      if (v113 != v99) {
        memmove(v104, v99, v113 - v99);
      }
    }
    else
    {
      uint64_t v106 = v103 >> 3;
      unint64_t v107 = (v103 >> 3) + v101;
      if (v107 >> 61) {
        sub_10006A748();
      }
      uint64_t v108 = v105 - v102;
      if (v108 >> 2 > v107) {
        unint64_t v107 = v108 >> 2;
      }
      if ((unint64_t)v108 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v109 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v109 = v107;
      }
      if (v109) {
        unint64_t v109 = (unint64_t)sub_100048350(v109);
      }
      else {
        uint64_t v110 = 0;
      }
      long long v120 = (void *)(v109 + 8 * v106);
      std::string v121 = (char *)&v120[v101];
      uint64_t v122 = 8 * v101;
      long long v123 = v120;
      do
      {
        uint64_t v124 = *(void *)v99;
        v99 += 8;
        *v123++ = v124;
        v122 -= 8;
      }
      while (v122);
      long long v125 = *(char **)(a1 + 528);
      if (v125 != v104)
      {
        long long v126 = v104;
        do
        {
          uint64_t v127 = *((void *)v126 - 1);
          v126 -= 8;
          *--long long v120 = v127;
        }
        while (v126 != v125);
      }
      unint64_t v128 = v109 + 8 * v110;
      long long v129 = *(unsigned char **)(a1 + 536);
      uint64_t v130 = v129 - v104;
      if (v129 != v104) {
        memmove(v121, v104, v129 - v104);
      }
      long long v131 = *(void **)(a1 + 528);
      *(void *)(a1 + 528) = v120;
      *(void *)(a1 + 536) = &v121[v130];
      *(void *)(a1 + 544) = v128;
      if (v131) {
        operator delete(v131);
      }
    }
LABEL_170:
    long long v132 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_DEFAULT, "#I Added WiFiAgent", buf, 2u);
    }
    if (__p[0]) {
      operator delete(__p[0]);
    }
    return sub_10047993C(*(void *)(a1 + 56), (uint64_t)__p, 1);
  }
  sub_10046CDAC(__p, (void *)a1);
  std::string v111 = *(void **)(a1 + 528);
  if (v111)
  {
    *(void *)(a1 + 536) = v111;
    operator delete(v111);
  }
  *(_OWORD *)(a1 + 528) = *(_OWORD *)__p;
  *(void *)(a1 + 544) = v136;
  return sub_10047993C(*(void *)(a1 + 56), (uint64_t)__p, 1);
}

void sub_10046DE3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (v21) {
    operator delete(v21);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10046DEA8(uint64_t a1)
{
  unsigned int v2 = subscriber::simSlotAsInstance();
  uint64_t v3 = *(void *)(a1 + 488);
  return v2 < (unint64_t)((*(void *)(a1 + 496) - v3) >> 2) && *(_DWORD *)(v3 + 4 * v2) == 2;
}

void sub_10046DEF8(uint64_t a1, int a2)
{
  unsigned int v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315138;
    uint64_t v6 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I dial as normal call on %s", (uint8_t *)&v5, 0xCu);
  }
  sub_10046BD10(a1);
  int v5 = 0;
  LODWORD(v6) = a2;
  sub_10046DFC0();
}

void sub_10046DFC0()
{
  xpc_object_t v3 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/events/e911_ready_to_dial");
  xpc_object_t object = v3;
  xpc_object_t v3 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_10046E054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

BOOL sub_10046E098(uint64_t a1)
{
  uint64_t v2 = a1 + 168;
  PersonalityIdFromSlotIdEx();
  uint64_t v7 = 0;
  xpc_object_t v3 = sub_100046F68(v2, &__p);
  unsigned int v4 = &v7;
  if ((void **)(a1 + 176) != v3) {
    unsigned int v4 = (uint64_t *)(v3 + 7);
  }
  uint64_t v5 = *v4;
  if (v9 < 0) {
    operator delete(__p);
  }
  return (v5 & 0x100000001) != 0;
}

void sub_10046E110(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10046E12C(uint64_t a1)
{
  unsigned int v20 = 0;
  CFTypeRef cf = 0;
  uint64_t v19 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  uint64_t v2 = ServiceMap;
  if (v3 < 0)
  {
    unsigned int v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      uint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v3;
  uint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, (unint64_t *)__p);
  if (v7)
  {
    uint64_t v9 = v7[3];
    uint64_t v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  uint64_t v8 = 0;
  char v10 = 1;
LABEL_9:
  PersonalityIdFromSlotIdEx();
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(void *)v9 + 40))(&v19, v9, __p);
  if ((v18 & 0x80000000) == 0)
  {
    if (v10) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  operator delete(__p[0]);
  if ((v10 & 1) == 0) {
LABEL_11:
  }
    sub_10004D2C8(v8);
LABEL_12:
  if (v19)
  {
    (*(void (**)(const void **__return_ptr))(*(void *)v19 + 40))(&v16);
    CFTypeRef v11 = cf;
    CFTypeRef cf = v16;
    uint64_t v16 = 0;
    __p[0] = (void *)v11;
    sub_1000577C4((const void **)__p);
    sub_1000577C4(&v16);
  }
  unint64_t v12 = (BOOL *)cf;
  LOBYTE(__p[0]) = 0;
  if (cf)
  {
    CFTypeID v13 = CFGetTypeID(cf);
    if (v13 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)__p, v12, v14);
      LODWORD(v12) = LOBYTE(__p[0]);
    }
    else
    {
      LODWORD(v12) = 0;
    }
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  sub_1000577C4(&cf);
  return v12 != 0;
}

void sub_10046E33C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, std::__shared_weak_count *a18, const void *a19)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  sub_1000577C4(&a19);
  _Unwind_Resume(a1);
}

BOOL sub_10046E394(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = operator new(0x10uLL);
  CFBooleanRef v28 = v4 + 2;
  uint64_t v29 = v4 + 2;
  void *v4 = @"EmergencyCalling";
  v4[1] = @"SwitchEmergencySubAfterFailures";
  uint64_t v26 = 0;
  CFTypeID v27 = v4;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  unsigned int v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v7;
  CFTypeRef v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    unint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  unint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, void **, void, uint64_t))(*(void *)v13 + 104))(__p, v13, a2, 2, &v27, 0, 1);
  sub_1000057AC(&v26, (CFTypeRef *)__p);
  sub_1000577C4((const void **)__p);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v26, v15);
  int v16 = buf[0];
  memset(buf, 0, 24);
  ctu::cf::assign();
  *(_OWORD *)__n128 __p = *(_OWORD *)buf;
  uint64_t v25 = *(void *)&buf[16];
  uint64_t v17 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    int v18 = subscriber::simSlotAsInstance();
    int v19 = SHIBYTE(v25);
    unsigned int v20 = (void **)__p[0];
    uint64_t v21 = asStringBool(v16 != 0);
    uint64_t v22 = __p;
    *(_DWORD *)int buf = 67109634;
    if (v19 < 0) {
      uint64_t v22 = v20;
    }
    *(_DWORD *)&uint8_t buf[4] = v18 + 1;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v22;
    *(_WORD *)&buf[18] = 2082;
    *(void *)&buf[20] = v21;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Sub%u: %{public}s = %{public}s", buf, 0x1Cu);
  }
  if (SHIBYTE(v25) < 0) {
    operator delete(__p[0]);
  }
  sub_100062778((const void **)&v26);
  if (v27)
  {
    CFBooleanRef v28 = v27;
    operator delete(v27);
  }
  return v16 != 0;
}

void sub_10046E61C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, uint64_t a19, char a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_100062778(&a16);
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10046E6AC(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = operator new(0x10uLL);
  char v24 = v4 + 2;
  uint64_t v25 = v4 + 2;
  void *v4 = @"EmergencyCalling";
  v4[1] = @"NonPreferredEmergencyNetworks";
  uint64_t v22 = 0;
  __n128 __p = v4;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  unsigned int v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v7;
  CFTypeRef v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    unint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  unint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, void **, void, uint64_t))(*(void *)v13 + 104))(&v22, v13, a2, 6, &__p, 0, 1);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  CFBooleanRef v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = subscriber::asString();
    if (v22) {
      uint64_t v17 = sub_100080934;
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v18 = asStringBool(v17 != 0);
    *(_DWORD *)int buf = 136315394;
    *(void *)&uint8_t buf[4] = v16;
    __int16 v27 = 2080;
    uint64_t v28 = v18;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [%s] NonPreferredEmergencyNetworks present?: %s", buf, 0x16u);
  }
  int v19 = v22;
  sub_1000577C4(&v22);
  if (__p)
  {
    char v24 = __p;
    operator delete(__p);
  }
  if (v19) {
    unsigned int v20 = sub_100080934;
  }
  else {
    unsigned int v20 = 0;
  }
  return v20 != 0;
}

void sub_10046E8EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
  {
    a11 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_10046E93C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 321))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136315138;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Shortcut search for suspicious 380 redirect with pre-decided slot: %s", buf, 0xCu);
    }
    return (void *)sub_10046D3F8(a1, 1, *(_DWORD *)(a1 + 512));
  }
  int v4 = *(_DWORD *)(a1 + 552);
  memset(v37, 0, 32);
  if (!v4)
  {
    *(_DWORD *)(a1 + 552) = 1;
    *(void *)int buf = off_1019CFE18;
    *(void *)&uint8_t buf[8] = a1;
    *(void *)uint64_t v34 = buf;
    sub_100335220(buf, v37);
    sub_10003B34C(buf);
  }
  RadioVendor = (capabilities::ct *)TelephonyRadiosGetRadioVendor();
  switch(RadioVendor)
  {
    case 1:
      if (capabilities::ct::supportsEmergencyQMIExtensions(RadioVendor))
      {
        BOOL v7 = *(unsigned char *)(a1 + 559) == 0;
        goto LABEL_16;
      }
      break;
    case 2:
LABEL_12:
      BOOL v7 = 1;
      goto LABEL_16;
    case 3:
      unsigned int v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Setting cell avoidance for: INT", buf, 2u);
      }
      goto LABEL_12;
  }
  BOOL v7 = 0;
LABEL_16:
  __n128 __p = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  sub_10035D43C(&__p, *(const void **)(a1 + 488), *(void *)(a1 + 496), (uint64_t)(*(void *)(a1 + 496) - *(void *)(a1 + 488)) >> 2);
  if (!*(unsigned char *)(a1 + 557))
  {
    int v10 = *(unsigned __int8 *)(a1 + 558);
    int v11 = *(_DWORD *)(a1 + 516);
    if (v11)
    {
      unint64_t v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = subscriber::asString();
        *(_DWORD *)int buf = 136315138;
        *(void *)&uint8_t buf[4] = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Using preferred slot: %s", buf, 0xCu);
        int v11 = *(_DWORD *)(a1 + 516);
      }
      *(_DWORD *)(a1 + 512) = v11;
      *(_DWORD *)(a1 + 516) = 0;
      if (v11 == 1)
      {
        *((_DWORD *)__p + 1) = 0;
        BOOL v14 = v10 != 0;
      }
      else
      {
        BOOL v14 = v10 != 0;
        if (v11 == 2) {
          *(_DWORD *)__n128 __p = 0;
        }
      }
    }
    else
    {
      BOOL v14 = v10 != 0;
      if (sub_10046E394(a1, *(unsigned int *)(a1 + 512)))
      {
        uint64_t v16 = *(NSObject **)(a1 + 40);
        BOOL v14 = 0;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = subscriber::asString();
          *(_DWORD *)int buf = 136315138;
          *(void *)&uint8_t buf[4] = v17;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Dropping cell avoidance slot: %s", buf, 0xCu);
          BOOL v14 = 0;
        }
      }
    }
    BOOL v15 = *(unsigned char *)(a1 + 559) != 0;
    *(unsigned char *)(a1 + 559) = 0;
    if (v7) {
      goto LABEL_39;
    }
    goto LABEL_34;
  }
  *(_WORD *)(a1 + 559) = 0;
  int v8 = *(_DWORD *)(a1 + 512);
  if (v8 == 2)
  {
    *(_DWORD *)(a1 + 512) = 1;
    uint64_t v9 = (char *)__p + 4;
    goto LABEL_26;
  }
  if (v8 == 1)
  {
    *(_DWORD *)(a1 + 512) = 2;
    uint64_t v9 = __p;
LABEL_26:
    *uint64_t v9 = 0;
  }
  BOOL v15 = 0;
  *(unsigned char *)(a1 + 559) = 0;
LABEL_34:
  BOOL v18 = !v15;
  if (!v4) {
    BOOL v18 = 0;
  }
  if (*(unsigned char *)(a1 + 557)) {
    BOOL v14 = 0;
  }
  else {
    BOOL v14 = v18;
  }
LABEL_39:
  int v19 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    int v20 = *(_DWORD *)(a1 + 552);
    if (v20 != 1 || v4 == 0) {
      uint64_t v22 = "start";
    }
    else {
      uint64_t v22 = "resume";
    }
    if (v4) {
      uint64_t v23 = "";
    }
    else {
      uint64_t v23 = "initial ";
    }
    uint64_t v24 = asStringBool(v14);
    uint64_t v25 = asStringBool(v15);
    *(_DWORD *)int buf = 136316162;
    *(void *)&uint8_t buf[4] = v22;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v23;
    __int16 v33 = 1024;
    *(_DWORD *)uint64_t v34 = v20;
    *(_WORD *)&v34[4] = 2080;
    *(void *)&v34[6] = v24;
    __int16 v35 = 2080;
    uint64_t v36 = v25;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s %ssearch round %d with avoidPrevCells=%s, fallbackRequested=%s", buf, 0x30u);
  }
  uint64_t v26 = *(void *)(a1 + 400);
  v31[0] = off_1019CFE98;
  v31[1] = a1;
  v31[3] = v31;
  sub_1000F0058((uint64_t)v30, (uint64_t)v37);
  (*(void (**)(uint64_t, void **, BOOL, BOOL, void *, void *))(*(void *)v26 + 16))(v26, &__p, v14, v15, v31, v30);
  sub_10003B34C(v30);
  sub_10035D6A8(v31);
  if (__p)
  {
    uint64_t v28 = __p;
    operator delete(__p);
  }
  return sub_10003B34C(v37);
}

void sub_10046EDEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10003B34C((void *)(v17 - 128));
  _Unwind_Resume(a1);
}

void *sub_10046EE50(uint64_t a1)
{
  return sub_10046E93C(a1 - 48);
}

void sub_10046EE58(void *a1)
{
  int v2 = sub_10046CAA0((uint64_t)a1);
  uint64_t v3 = (_DWORD **)a1[54];
  int v4 = (_DWORD **)a1[55];
  if (v3 != v4)
  {
    while (**v3 != v2)
    {
      if (++v3 == v4) {
        goto LABEL_26;
      }
    }
  }
  if (v3 != v4)
  {
    uint64_t v5 = *v3;
    if (*v3)
    {
      unsigned int v6 = (void *)a1[66];
      a1[67] = v6;
      BOOL v7 = a1[5];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = 136315138;
        uint64_t v23 = subscriber::asString();
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Need to try over IMS VoLTE on %s", (uint8_t *)&v22, 0xCu);
        unsigned int v6 = (void *)a1[67];
      }
      uint64_t v8 = *((void *)v5 + 11);
      unint64_t v9 = a1[68];
      if ((unint64_t)v6 >= v9)
      {
        uint64_t v11 = a1[66];
        uint64_t v12 = ((uint64_t)v6 - v11) >> 3;
        if ((unint64_t)(v12 + 1) >> 61) {
          sub_10006A748();
        }
        uint64_t v13 = v9 - v11;
        uint64_t v14 = v13 >> 2;
        if (v13 >> 2 <= (unint64_t)(v12 + 1)) {
          uint64_t v14 = v12 + 1;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v14;
        }
        if (v15) {
          unint64_t v15 = (unint64_t)sub_100048350(v15);
        }
        else {
          uint64_t v16 = 0;
        }
        uint64_t v17 = (void *)(v15 + 8 * v12);
        unint64_t v18 = v15 + 8 * v16;
        *uint64_t v17 = v8;
        int v10 = v17 + 1;
        int v19 = (char *)a1[67];
        int v20 = (char *)a1[66];
        if (v19 != v20)
        {
          do
          {
            uint64_t v21 = *((void *)v19 - 1);
            v19 -= 8;
            *--uint64_t v17 = v21;
          }
          while (v19 != v20);
          int v19 = (char *)a1[66];
        }
        a1[66] = v17;
        a1[67] = v10;
        a1[68] = v18;
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        *unsigned int v6 = v8;
        int v10 = v6 + 1;
      }
      a1[67] = v10;
    }
  }
LABEL_26:
  sub_10046F01C((uint64_t)a1);
}

void sub_10046F01C(uint64_t a1)
{
  sub_10046BAA0((void *)a1);
  while (1)
  {
    int v2 = *(char **)(a1 + 528);
    uint64_t v3 = *(char **)(a1 + 536);
    if (v2 == v3) {
      break;
    }
    uint64_t v4 = *(void *)v2;
    int64_t v5 = v3 - (v2 + 8);
    if (v3 != v2 + 8) {
      memmove(*(void **)(a1 + 528), v2 + 8, v3 - (v2 + 8));
    }
    *(void *)(a1 + 536) = &v2[v5];
    if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 40))(v4))
    {
      *(void *)(a1 + 520) = v4;
      break;
    }
  }
  BOOL v6 = sub_10046E394(a1, *(unsigned int *)(a1 + 512));
  BOOL v7 = *(NSObject **)(a1 + 40);
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 520);
    int v10 = v9 ? (char *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 56))(v9) : "<empty>";
    uint64_t v11 = asStringBool(*(void *)(a1 + 528) == *(void *)(a1 + 536));
    uint64_t v12 = asStringBool(*(unsigned char *)(a1 + 558));
    sub_10046F758(&__p, (void *)(a1 + 488));
    uint64_t v13 = v46 >= 0 ? &__p : (void **)__p;
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v10;
    __int16 v51 = 2080;
    uint64_t v52 = v11;
    __int16 v53 = 2080;
    uint64_t v54 = v12;
    __int16 v55 = 2080;
    uint64_t v56 = v13;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I fCurrentAgent: %s, fAgentsToAttempt.empty(): %s, fHadSipOrPdnError: %s, fSimPrefs: %s", buf, 0x2Au);
    if (v46 < 0) {
      operator delete(__p);
    }
  }
  if (!*(void *)(a1 + 520) && *(void *)(a1 + 528) == *(void *)(a1 + 536))
  {
    int v14 = capabilities::ct::callManagerSearchRoundsMaxValue((capabilities::ct *)v8);
    uint64_t v49 = 0;
    __n128 __p = 0;
    uint64_t v45 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
    uint64_t v16 = ServiceMap;
    if (v17 < 0)
    {
      unint64_t v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v19 = 5381;
      do
      {
        uint64_t v17 = v19;
        unsigned int v20 = *v18++;
        uint64_t v19 = (33 * v19) ^ v20;
      }
      while (v20);
    }
    std::mutex::lock(ServiceMap);
    *(void *)int buf = v17;
    uint64_t v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)buf);
    if (v21)
    {
      uint64_t v23 = v21[3];
      int v22 = (std::__shared_weak_count *)v21[4];
      if (v22)
      {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v16);
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v22);
        char v24 = 0;
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    std::mutex::unlock(v16);
    int v22 = 0;
    char v24 = 1;
LABEL_27:
    PersonalityIdFromSlotIdEx();
    (*(void (**)(void **__return_ptr, uint64_t, unsigned char *))(*(void *)v23 + 40))(&__p, v23, buf);
    if (SHIBYTE(v53) < 0) {
      operator delete(*(void **)buf);
    }
    if ((v24 & 1) == 0) {
      sub_10004D2C8(v22);
    }
    if (!__p) {
      goto LABEL_47;
    }
    CFTypeRef cf = 0;
    (*(void (**)(CFTypeRef *__return_ptr))(*(void *)__p + 40))(&cf);
    uint64_t v25 = (int *)cf;
    if (cf) {
      uint64_t v26 = sub_100080934;
    }
    else {
      uint64_t v26 = 0;
    }
    if (v26)
    {
      *(_DWORD *)int buf = v14;
      if (!cf) {
        goto LABEL_46;
      }
      CFTypeID v27 = CFGetTypeID(cf);
      if (v27 != CFNumberGetTypeID()) {
        goto LABEL_46;
      }
    }
    else
    {
      (*(void (**)(const void **__return_ptr))(*(void *)__p + 40))(&v47);
      *(void *)int buf = cf;
      uint64_t v29 = v47;
      uint64_t v47 = 0;
      CFTypeRef cf = v29;
      sub_1000577C4((const void **)buf);
      sub_1000577C4(&v47);
      uint64_t v25 = (int *)cf;
      if (cf) {
        uint64_t v30 = sub_100080934;
      }
      else {
        uint64_t v30 = 0;
      }
      if (!v30) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = v14;
      if (!cf) {
        goto LABEL_46;
      }
      CFTypeID v31 = CFGetTypeID(cf);
      if (v31 != CFNumberGetTypeID()) {
        goto LABEL_46;
      }
    }
    ctu::cf::assign((ctu::cf *)buf, v25, v28);
    int v14 = *(_DWORD *)buf;
LABEL_46:
    sub_1000577C4(&cf);
LABEL_47:
    if (v45) {
      sub_10004D2C8(v45);
    }
    int v32 = sub_1000577C4(&v49);
    if (v14 && *(_DWORD *)(a1 + 552) > v14 && !*(unsigned char *)(a1 + 556))
    {
      int v40 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I All search attempts have failed", buf, 2u);
      }
      *(unsigned char *)(a1 + 556) = 1;
      uint64_t v41 = sub_10046D34C(a1);
      *(void *)(a1 + 520) = v41;
      if (v41)
      {
        uint64_t v42 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v43 = (*(uint64_t (**)(uint64_t))(*(void *)v41 + 56))(v41);
          *(_DWORD *)int buf = 136315138;
          *(void *)&uint8_t buf[4] = v43;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I try final CS call with %s.", buf, 0xCu);
        }
      }
    }
    else if (*(unsigned char *)(a1 + 558) && capabilities::ct::supportsGemini((capabilities::ct *)v32))
    {
      uint64_t v34 = *(int **)(a1 + 488);
      __int16 v33 = *(int **)(a1 + 496);
      uint64_t v35 = v33 - v34;
      uint64_t v36 = 0;
      while (v34 != v33)
      {
        int v37 = *v34++;
        if (v37 == 1) {
          ++v36;
        }
      }
      if (v35 == v36 && v6)
      {
        BOOL v39 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I try other Sub", buf, 2u);
        }
        *(unsigned char *)(a1 + 557) = 1;
        (*(void (**)(void))(**(void **)(a1 + 400) + 24))(*(void *)(a1 + 400));
      }
    }
  }
}

void sub_10046F62C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, const void *a13, const void *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_1000577C4(&a14);
  _Unwind_Resume(a1);
}

void sub_10046F6A8(uint64_t a1)
{
}

void sub_10046F6B0(uint64_t a1)
{
  sub_10046CDAC(&v4, (void *)a1);
  int v2 = *(void **)(a1 + 528);
  if (v2)
  {
    *(void *)(a1 + 536) = v2;
    operator delete(v2);
  }
  *(_OWORD *)(a1 + 528) = v4;
  *(void *)(a1 + 544) = v5;
  *(unsigned char *)(a1 + 556) = 1;
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I try final Wifi call", (uint8_t *)&v4, 2u);
  }
  sub_10046F01C(a1);
}

void sub_10046F750(uint64_t a1)
{
}

uint64_t sub_10046F758(void *a1, void *a2)
{
  uint64_t v21 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  *(_OWORD *)__n128 __p = 0u;
  long long v10 = 0u;
  memset(v8, 0, sizeof(v8));
  sub_10004DE24((uint64_t)v8);
  sub_10004B96C(v8, (uint64_t)"{", 1);
  if (a2[1] != *a2)
  {
    unint64_t v4 = 0;
    do
    {
      if (v4) {
        sub_10004B96C(v8, (uint64_t)", ", 2);
      }
      uint64_t v5 = (const char *)asString();
      size_t v6 = strlen(v5);
      sub_10004B96C(v8, (uint64_t)v5, v6);
      ++v4;
    }
    while (v4 < (uint64_t)(a2[1] - *a2) >> 2);
  }
  sub_10004B96C(v8, (uint64_t)"}", 1);
  sub_10004BC98((uint64_t)v8 + 8, a1);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_10046F940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10046F958(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 556);
}

void sub_10046F960(uint64_t a1)
{
}

void sub_10046F968(uint64_t a1)
{
}

void sub_10046F970(uint64_t a1)
{
}

void sub_10046F980(uint64_t a1)
{
  sub_10046CDAC(buf, (void *)a1);
  int v2 = *(void **)(a1 + 528);
  if (v2)
  {
    *(void *)(a1 + 536) = v2;
    operator delete(v2);
  }
  *(_OWORD *)(a1 + 528) = *(_OWORD *)buf;
  *(void *)(a1 + 544) = *(void *)&buf[16];
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I search time out, check wifi call", buf, 2u);
  }
  unsigned int SingleSlotForEmergency = getSingleSlotForEmergency();
  if (!SingleSlotForEmergency)
  {
    int v4 = *(_DWORD *)(a1 + 248);
    char isValidSimSlot = subscriber::isValidSimSlot();
    if (v4 == 1) {
      int v6 = 2;
    }
    else {
      int v6 = 1;
    }
    if (isValidSimSlot) {
      int v6 = v4;
    }
    unsigned int SingleSlotForEmergency = v6;
  }
  BOOL v7 = operator new(0x10uLL);
  char v58 = 0;
  unsigned int v59 = v7;
  unint64_t v61 = v7 + 2;
  *BOOL v7 = @"EmergencyCalling";
  v7[1] = @"WaitForWiFiRegistration";
  uint64_t v60 = v7 + 2;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    long long v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v10;
  long long v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (v14)
  {
    uint64_t v16 = v14[3];
    long long v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  long long v15 = 0;
  char v17 = 1;
LABEL_20:
  (*(void (**)(void **__return_ptr, uint64_t, void, uint64_t, void **, void, uint64_t))(*(void *)v16
                                                                                                  + 104))(__p, v16, SingleSlotForEmergency, 1, &v59, 0, 1);
  sub_1000057AC(&v58, (CFTypeRef *)__p);
  sub_1000577C4((const void **)__p);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v58, v18);
  int v19 = buf[0];
  memset(buf, 0, 24);
  ctu::cf::assign();
  *(_OWORD *)__n128 __p = *(_OWORD *)buf;
  uint64_t v57 = *(void *)&buf[16];
  long long v20 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    int v21 = subscriber::simSlotAsInstance();
    int v22 = SHIBYTE(v57);
    uint64_t v23 = (void **)__p[0];
    uint64_t v24 = asStringBool(v19 != 0);
    uint64_t v25 = __p;
    *(_DWORD *)int buf = 67109634;
    if (v22 < 0) {
      uint64_t v25 = v23;
    }
    *(_DWORD *)&uint8_t buf[4] = v21 + 1;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v25;
    *(_WORD *)&buf[18] = 2082;
    *(void *)&buf[20] = v24;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Sub%u: %{public}s = %{public}s", buf, 0x1Cu);
  }
  if (SHIBYTE(v57) < 0) {
    operator delete(__p[0]);
  }
  sub_100062778((const void **)&v58);
  if (v59)
  {
    uint64_t v60 = v59;
    operator delete(v59);
  }
  if (v19)
  {
    sub_10046BAA0((void *)a1);
    uint64_t v26 = *(char **)(a1 + 528);
    CFTypeID v27 = *(char **)(a1 + 536);
    if (v26 != v27)
    {
      CFNumberRef v28 = (uint64_t *)(a1 + 224);
      while (1)
      {
        uint64_t v29 = *(void *)v26;
        int64_t v30 = v27 - (v26 + 8);
        if (v27 != v26 + 8) {
          memmove(v26, v26 + 8, v27 - (v26 + 8));
        }
        *(void *)(a1 + 536) = &v26[v30];
        PersonalityIdFromSlotIdEx();
        CFTypeID v31 = sub_100046F68(a1 + 192, (void **)buf);
        BOOL v34 = (void **)(a1 + 200) != v31
           && (*((_DWORD *)v31 + 14) == 1 ? (BOOL v32 = (*((_DWORD *)v31 + 15) & 1) == 0) : (BOOL v32 = 1),
               !v32 ? (BOOL v33 = *((unsigned char *)v31 + 64) == 0) : (BOOL v33 = 1),
               !v33)
           && *((_DWORD *)v31 + 17) == 1;
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v35 = *v28;
        if (!*v28) {
          goto LABEL_57;
        }
        int v36 = *(_DWORD *)(v29 + 8);
        uint64_t v37 = a1 + 224;
        do
        {
          int v38 = *(_DWORD *)(v35 + 28);
          BOOL v39 = v38 < v36;
          if (v38 >= v36) {
            int v40 = (uint64_t *)v35;
          }
          else {
            int v40 = (uint64_t *)(v35 + 8);
          }
          if (!v39) {
            uint64_t v37 = v35;
          }
          uint64_t v35 = *v40;
        }
        while (*v40);
        if ((uint64_t *)v37 != v28 && *(_DWORD *)(v37 + 28) <= v36) {
          BOOL v41 = *(_DWORD *)(v37 + 32) == 4;
        }
        else {
LABEL_57:
        }
          BOOL v41 = 0;
        uint64_t v42 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v43 = asStringBool(v34);
          uint64_t v44 = subscriber::asString();
          uint64_t v45 = asStringBool(v41);
          *(_DWORD *)int buf = 136315650;
          *(void *)&uint8_t buf[4] = v43;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v44;
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = v45;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I IMS Voice is registered on WiFi: %s, slot=%s, isRoaming: %s", buf, 0x20u);
        }
        if (v34)
        {
          int v46 = *(_DWORD *)(v29 + 8);
          if (SingleSlotForEmergency == v46 || !v41) {
            break;
          }
        }
        uint64_t v26 = *(char **)(a1 + 528);
        CFTypeID v27 = *(char **)(a1 + 536);
        if (v26 == v27) {
          goto LABEL_70;
        }
      }
      *(void *)(a1 + 520) = v29;
      *(_DWORD *)(a1 + 512) = v46;
    }
LABEL_70:
    unint64_t v48 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v49 = *(void *)(a1 + 520);
      int v50 = v49 ? (char *)(*(uint64_t (**)(uint64_t))(*(void *)v49 + 56))(v49) : "<empty>";
      uint64_t v51 = asStringBool(*(void *)(a1 + 528) == *(void *)(a1 + 536));
      uint64_t v52 = asStringBool(*(unsigned char *)(a1 + 558));
      sub_10046F758(&v59, (void *)(a1 + 488));
      __int16 v53 = SHIBYTE(v61) >= 0 ? &v59 : (void **)v59;
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v50;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v51;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = v52;
      __int16 v63 = 2080;
      unsigned int v64 = v53;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I fCurrentAgent: %s, fAgentsToAttempt.empty(): %s, fHadSipOrPdnError: %s, fSimPrefs: %s", buf, 0x2Au);
      if (SHIBYTE(v61) < 0) {
        operator delete(v59);
      }
    }
    if (!*(void *)(a1 + 520) && *(void *)(a1 + 528) == *(void *)(a1 + 536))
    {
      *(unsigned char *)(a1 + 560) = 1;
      uint64_t v54 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I WiFi call is not possible yet, but will wait for WiFi registration.", buf, 2u);
      }
    }
  }
  else
  {
    sub_10046F01C(a1);
  }
}

void sub_10046FFD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,const void *a22,void *__p,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a20 < 0) {
    operator delete(a15);
  }
  sub_100062778(&a22);
  if (__p)
  {
    a24 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100470080(uint64_t a1)
{
}

uint64_t sub_100470088(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Emergency Call session ended.", v4, 2u);
  }
  return sub_10046BD10(a1);
}

uint64_t sub_1004700F4(uint64_t a1)
{
  return sub_100470088(a1 - 48);
}

void *sub_1004700FC(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I call ended, go into EEM", v4, 2u);
  }
  sub_10046BBB0(a1);
  v5[0] = off_1019CFF18;
  void v5[3] = v5;
  sub_10046BE84(a1, (uint64_t)v5);
  return sub_10047575C(v5);
}

void sub_1004701CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10047575C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1004701E8(uint64_t a1)
{
  return sub_1004700FC(a1 - 48);
}

void sub_1004701F0(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I emegency call session failed", buf, 2u);
  }
  sub_10046BD10(a1);
  sub_10046DFC0();
}

void sub_10047026C(uint64_t a1)
{
}

void *sub_100470274(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 520);
  if (!v1) {
    __assert_rtn("startDialing", "EmergencyCallManager.cpp", 1477, "fCurrentAgent");
  }
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 56))(v1);
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I dialing with %s", (uint8_t *)&buf, 0xCu);
    uint64_t v1 = *(void *)(a1 + 520);
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v1 + 72))(v1) != 1)
  {
    uint64_t v37 = 0;
    __n128 __p = 0;
    uint64_t v35 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
    int v6 = ServiceMap;
    if (v7 < 0)
    {
      BOOL v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        uint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long buf = v7;
    long long v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&buf);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
        goto LABEL_13;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
LABEL_13:
    PersonalityIdFromSlotIdEx();
    (*(void (**)(void **__return_ptr, uint64_t, long long *))(*(void *)v13 + 40))(&__p, v13, &buf);
    if (SHIBYTE(v44) < 0)
    {
      operator delete((void *)buf);
      if (v14) {
        goto LABEL_16;
      }
    }
    else if (v14)
    {
LABEL_16:
      if (__p)
      {
        *(void *)&long long buf = 0;
        (*(void (**)(long long *__return_ptr))(*(void *)__p + 40))(&buf);
        long long v15 = (int *)buf;
        if ((void)buf) {
          uint64_t v16 = sub_100080934;
        }
        else {
          uint64_t v16 = 0;
        }
        int v17 = 20;
        if (v16)
        {
          LODWORD(v39) = 20;
          if ((void)buf)
          {
            CFTypeID v18 = CFGetTypeID((CFTypeRef)buf);
            if (v18 == CFNumberGetTypeID())
            {
              ctu::cf::assign((ctu::cf *)&v39, v15, v19);
              int v17 = v39;
            }
            else
            {
              int v17 = 20;
            }
          }
        }
        sub_1000577C4((const void **)&buf);
      }
      else
      {
        int v17 = 20;
      }
      if (v35) {
        sub_10004D2C8(v35);
      }
      sub_1000577C4((const void **)&v37);
      if (v17 >= 1)
      {
        long long v20 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = v17;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Arming Tlte timer with %lld seconds", (uint8_t *)&buf, 0xCu);
        }
        int v21 = *(std::__shared_weak_count **)(a1 + 16);
        if (!v21 || (uint64_t v22 = *(void *)(a1 + 8), (v23 = std::__shared_weak_count::lock(v21)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v24 = v23;
        atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v23);
        Registry::getTimerService(&v37, *(Registry **)(a1 + 64));
        uint64_t v25 = v37;
        sub_100058DB0(&__p, "EmergencyCallManager");
        uint64_t v26 = *(NSObject **)(a1 + 24);
        dispatch_object_t object = v26;
        if (v26) {
          dispatch_retain(v26);
        }
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 1174405120;
        uint64_t v44 = sub_10046C614;
        uint64_t v45 = &unk_1019CEFF0;
        uint64_t v46 = v22;
        uint64_t v47 = v24;
        atomic_fetch_add_explicit(&v24->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        aBlock = _Block_copy(&buf);
        sub_100118A44(v25, (uint64_t)&__p, 2, 1000000 * v17, &object, &aBlock);
        uint64_t v27 = v39;
        uint64_t v39 = 0;
        uint64_t v28 = *(void *)(a1 + 624);
        *(void *)(a1 + 624) = v27;
        if (v28)
        {
          (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
          uint64_t v29 = v39;
          uint64_t v39 = 0;
          if (v29) {
            (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
          }
        }
        if (aBlock) {
          _Block_release(aBlock);
        }
        if (object) {
          dispatch_release(object);
        }
        if (v36 < 0) {
          operator delete(__p);
        }
        if (v38) {
          sub_10004D2C8(v38);
        }
        if (v47) {
          std::__shared_weak_count::__release_weak(v47);
        }
        std::__shared_weak_count::__release_weak(v24);
      }
      goto LABEL_52;
    }
    sub_10004D2C8(v12);
    goto LABEL_16;
  }
LABEL_52:
  uint64_t v30 = *(void *)(a1 + 520);
  v42[0] = off_1019CFF98;
  v42[1] = a1;
  v42[3] = v42;
  v41[0] = off_1019D0018;
  v41[1] = a1;
  v41[3] = v41;
  v40[0] = off_1019D00B8;
  v40[1] = a1;
  v40[3] = v40;
  (*(void (**)(uint64_t, void *, void *, void *))(*(void *)v30 + 16))(v30, v42, v41, v40);
  sub_10003B34C(v40);
  sub_100060644(v41);
  return sub_10003B34C(v42);
}

void sub_10047083C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100470940(uint64_t a1)
{
  return sub_100470274(a1 - 48);
}

void sub_100470950(uint64_t a1)
{
  __n128 __p = 0;
  int v6 = 0;
  uint64_t v7 = 0;
  sub_10035D43C(&__p, *(const void **)(a1 + 576), *(void *)(a1 + 584), (uint64_t)(*(void *)(a1 + 584) - *(void *)(a1 + 576)) >> 2);
  *(void *)(a1 + 584) = *(void *)(a1 + 576);
  int v2 = (char *)__p;
  uint64_t v3 = *(_DWORD **)(a1 + 488);
  if (v6 - (unsigned char *)__p == *(void *)(a1 + 496) - (void)v3)
  {
    while (v2 != v6)
    {
      if (*(_DWORD *)v2 != *v3) {
        goto LABEL_5;
      }
      v2 += 4;
      ++v3;
    }
  }
  else
  {
LABEL_5:
    sub_10046BD10(a1);
  }
  if ((void **)(a1 + 488) != &__p) {
    sub_10008A534((char *)(a1 + 488), (char *)__p, (uint64_t)v6, (v6 - (unsigned char *)__p) >> 2);
  }
  v8[0] = off_1019D0138;
  v8[3] = v8;
  sub_10046BE84(a1, (uint64_t)v8);
  sub_10047575C(v8);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100470B30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100470B7C(uint64_t a1)
{
}

BOOL sub_100470B84(uint64_t a1)
{
  return sub_10046CAA0(a1) != 0;
}

BOOL sub_100470BA4(uint64_t a1)
{
  return sub_10046CAA0(a1 - 48) != 0;
}

BOOL sub_100470BC8(uint64_t a1)
{
  int v2 = (capabilities::ct *)sub_10046CD1C(*(char **)(a1 + 488), *(char **)(a1 + 496), 1);
  int v3 = (int)v2;
  BOOL v4 = v2 != 0;
  int v5 = capabilities::ct::supportsVoiceCall(v2);
  if (v3) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    return *(unsigned char *)(a1 + 132) != 0;
  }
  return v4;
}

BOOL sub_100470C2C(uint64_t a1)
{
  return sub_100470BC8(a1 - 48);
}

BOOL sub_100470C34(uint64_t a1)
{
  int v2 = (capabilities::ct *)sub_10046CD1C(*(char **)(a1 + 488), *(char **)(a1 + 496), 2);
  int v3 = (int)v2;
  BOOL v4 = v2 != 0;
  int v5 = capabilities::ct::supportsVoiceCall(v2);
  if (v3) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    return *(unsigned char *)(a1 + 132) != 0;
  }
  return v4;
}

BOOL sub_100470C98(uint64_t a1)
{
  return sub_100470C34(a1 - 48);
}

BOOL sub_100470CA0(uint64_t a1)
{
  unsigned int v2 = subscriber::simSlotAsInstance();
  uint64_t v3 = *(void *)(a1 + 440);
  return v2 < (unint64_t)((*(void *)(a1 + 448) - v3) >> 2) && *(_DWORD *)(v3 + 4 * v2) == 2;
}

uint64_t sub_100470CF0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 128);
}

uint64_t sub_100470CF8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 80);
}

uint64_t sub_100470D00(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 508);
}

BOOL sub_100470D08(uint64_t a1)
{
  return *(void *)(a1 + 520) != 0;
}

BOOL sub_100470D18(uint64_t a1)
{
  return *(void *)(a1 + 472) != 0;
}

uint64_t sub_100470D28(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 520);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

uint64_t sub_100470D58(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 472);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

uint64_t sub_100470D88(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 557);
}

uint64_t sub_100470D90(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 509);
}

void sub_100470D98(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      BOOL v4 = a2;
    }
    else {
      BOOL v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    BOOL v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Emergency manager state change to: %s", (uint8_t *)&v5, 0xCu);
  }
}

void sub_100470E44(uint64_t a1, uint64_t *a2)
{
}

void *sub_100470E4C(void *a1)
{
  ctu::RestModule::disconnect((ctu::RestModule *)(a1[9] + 184));
  ctu::RestModule::disconnect((ctu::RestModule *)(a1[11] + 184));
  sub_1001661C8(a1[7]);
  unsigned int v2 = (std::__shared_weak_count *)a1[12];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[10];
  if (v3) {
    sub_10004D2C8(v3);
  }
  BOOL v4 = (std::__shared_weak_count *)a1[8];
  if (v4) {
    sub_10004D2C8(v4);
  }
  int v5 = (std::__shared_weak_count *)a1[6];
  if (v5) {
    sub_10004D2C8(v5);
  }
  BOOL v6 = (std::__shared_weak_count *)a1[4];
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (v7) {
    sub_10004D2C8(v7);
  }
  return a1;
}

void sub_100470EDC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 132))
  {
    int v2 = *(_DWORD *)(a1 + 312);
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315138;
      uint64_t v5 = asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Airplane mode entered!! Checking if we are in emergency mode for T911: Current Emergency Mode: %s.", (uint8_t *)&v4, 0xCu);
    }
    if (v2 == 3) {
      sub_10046C48C(a1);
    }
  }
}

void sub_100470FA4(uint64_t a1, uint64_t a2)
{
  if (capabilities::ct::supportsEmergencyQMIExtensions((capabilities::ct *)a1))
  {
    int v4 = *(_DWORD **)(a1 + 136);
    for (uint64_t i = *(_DWORD **)(a1 + 144); v4 != i; v4 += 42)
    {
      if (*v4 == *(_DWORD *)(a1 + 512))
      {
        BOOL v6 = *(_DWORD **)a2;
        uint64_t v7 = *(_DWORD **)(a2 + 8);
        sub_10002E664((uint64_t)v12, (uint64_t)v4);
        if (v6 != v7)
        {
          while (*v6 != v12[0])
          {
            v6 += 42;
            if (v6 == v7)
            {
              BOOL v6 = v7;
              break;
            }
          }
        }
        if (v23 < 0) {
          operator delete(__p);
        }
        if (v21 < 0) {
          operator delete(v20);
        }
        if (v19 < 0) {
          operator delete(v18);
        }
        if (v17 < 0) {
          operator delete(v16);
        }
        *(void *)long long buf = &v15;
        sub_10002E39C((void ***)buf);
        if (v13)
        {
          char v14 = v13;
          operator delete(v13);
        }
        if (v6 == *(_DWORD **)(a2 + 8) || v6[2] != v4[2])
        {
          BOOL v8 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            int v9 = subscriber::simSlotAsInstance();
            uint64_t v10 = subscriber::asString();
            uint64_t v11 = asString();
            *(_DWORD *)long long buf = 67109634;
            *(_DWORD *)&uint8_t buf[4] = v9 + 1;
            __int16 v25 = 2080;
            uint64_t v26 = v10;
            __int16 v27 = 2080;
            uint64_t v28 = v11;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Handling SIM%u state change [%s] Current Emergency Mode: %s", buf, 0x1Cu);
          }
          if (subscriber::isSimAbsent())
          {
            if (*(_DWORD *)(a1 + 312) == 1)
            {
              (*(void (**)(void))(**(void **)(a1 + 400) + 24))(*(void *)(a1 + 400));
              sub_10046BDA8(a1);
            }
          }
        }
      }
    }
  }
}

void *sub_1004711DC(uint64_t a1)
{
  int isServiceActive = StewieFeatureState::isServiceActive();
  char v5 = isServiceActive;
  uint64_t result = (void *)StewieFeatureState::isServiceActive();
  if (isServiceActive != result)
  {
    int v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v8 = asStringBool(isServiceActive);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Stewie emergency service active changed to: %s", buf, 0xCu);
    }
    v6[0] = off_1019D02A8;
    v6[1] = &v5;
    uint64_t v6[3] = v6;
    sub_10046BE84(a1, (uint64_t)v6);
    return sub_10047575C(v6);
  }
  return result;
}

void sub_1004712F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10047575C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100471304(uint64_t a1, uint64_t a2)
{
  void (***v14)(uint64_t *__return_ptr, void, uint64_t);
  char v15;
  void **v16;
  int v17;
  NSObject *v18;
  const char *v19;
  uint64_t v20;
  int v21;
  void **v22;
  void **v23;
  BOOL v24;
  void **v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  unsigned char buf[24];

  if (*(void *)(a1 + 488) != *(void *)(a1 + 496))
  {
    if (*(unsigned char *)(a1 + 560))
    {
      uint64_t v3 = *(void ***)(a1 + 192);
      int v4 = (void **)(a1 + 200);
      if (v3 != (void **)(a1 + 200))
      {
        __int16 v25 = (void **)(a2 + 8);
        while (1)
        {
          uint64_t v26 = 0;
          __int16 v27 = 0;
          ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
          uint64_t v7 = ServiceMap;
          if (v8 < 0)
          {
            int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v10 = 5381;
            do
            {
              uint64_t v8 = v10;
              unsigned int v11 = *v9++;
              uint64_t v10 = (33 * v10) ^ v11;
            }
            while (v11);
          }
          std::mutex::lock(ServiceMap);
          *(void *)long long buf = v8;
          uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
          if (!v12) {
            break;
          }
          char v14 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v12[3];
          uint64_t v13 = (std::__shared_weak_count *)v12[4];
          if (!v13) {
            goto LABEL_12;
          }
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v7);
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v13);
          uint64_t v15 = 0;
LABEL_13:
          (**v14)(&v26, v14, (uint64_t)(v3 + 4));
          if ((v15 & 1) == 0) {
            sub_10004D2C8(v13);
          }
          if (v26)
          {
            uint64_t v16 = sub_100046F68(a2, v3 + 4);
            if (v25 == v16) {
              goto LABEL_27;
            }
            if (!sub_10047161C((uint64_t)(v3 + 7), (uint64_t)(v16 + 7)))
            {
              CFTypeID v18 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                char v19 = (const char *)(v26 + 24);
                long long v20 = *(unsigned __int8 *)(v26 + 47);
                char v21 = (char)v20;
                if ((v20 & 0x80u) != 0) {
                  long long v20 = *(void *)(v26 + 32);
                }
                if (v21 < 0) {
                  char v19 = *(const char **)(v26 + 24);
                }
                if (!v20) {
                  char v19 = "<invalid>";
                }
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = v19;
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I IMS registration state for Personality %s changed", buf, 0xCu);
              }
LABEL_27:
              if (*((_DWORD *)v3 + 14) == 1
                && (*((unsigned char *)v3 + 60) & 1) != 0
                && *((unsigned char *)v3 + 64)
                && *((_DWORD *)v3 + 17) == 1)
              {
                *(unsigned char *)(a1 + 560) = 0;
                sub_100479F08(*(void *)(a1 + 56), (uint64_t)buf, 1);
                char v17 = 4;
              }
              else
              {
                char v17 = 0;
              }
              goto LABEL_33;
            }
          }
          char v17 = 5;
LABEL_33:
          if (v27) {
            sub_10004D2C8(v27);
          }
          if (v17 == 5 || !v17)
          {
            uint64_t v22 = (void **)v3[1];
            if (v22)
            {
              do
              {
                char v23 = v22;
                uint64_t v22 = (void **)*v22;
              }
              while (v22);
            }
            else
            {
              do
              {
                char v23 = (void **)v3[2];
                uint64_t v24 = *v23 == v3;
                uint64_t v3 = v23;
              }
              while (!v24);
            }
            uint64_t v3 = v23;
            if (v23 != v4) {
              continue;
            }
          }
          return;
        }
        char v14 = 0;
LABEL_12:
        std::mutex::unlock(v7);
        uint64_t v13 = 0;
        uint64_t v15 = 1;
        goto LABEL_13;
      }
    }
  }
}

void sub_1004715D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10047161C(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)a1 == *(_DWORD *)a2
      && *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4)
      && *(unsigned __int8 *)(a1 + 8) == *(unsigned __int8 *)(a2 + 8)
      && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
      && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16);
}

void *sub_100471678(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1004716FC(void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = (void **)**a1;
  if (v2)
  {
    int v4 = (void **)v1[1];
    char v5 = **a1;
    if (v4 != v2)
    {
      do
        sub_100471780(--v4);
      while (v4 != v2);
      char v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_100471780(void **a1)
{
  uint64_t result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_100470E4C(result);
    operator delete();
  }
  return result;
}

void *sub_1004717D0(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100471854(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1004718DC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100471914(uint64_t a1)
{
}

uint64_t sub_100471930(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100471974(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1004719A0(ServiceManager::Service *this)
{
  *(void *)this = off_1019CF1B8;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1004719FC(ServiceManager::Service *this)
{
  *(void *)this = off_1019CF1B8;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100471A6C@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "EmergencyCallManager");
}

unsigned char *sub_100471A7C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100471ABC(uint64_t a1, NSObject **a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  dispatch_object_t v4 = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
    sub_10046A6A8(v2, &v4);
  }
  sub_10046A6A8(v2, &v4);
}

uint64_t sub_100471B44()
{
  return 0;
}

uint64_t sub_100471B4C()
{
  return 1;
}

uint64_t sub_100471B54()
{
  return 0;
}

void sub_100471B60(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100471C7C(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  dispatch_object_t v4 = *(NSObject **)(v3 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2 == 3)
  {
    if (v5)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I CallManager: Shutting down", buf, 2u);
    }
    BOOL v6 = *(std::__shared_weak_count **)(v3 + 16);
    if (v6)
    {
      if (std::__shared_weak_count::lock(v6)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  if (v5)
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Not handling unexpected shutdown stage (%s)", buf, 0xCu);
  }
}

void sub_100471E14(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100471E24(uint64_t a1)
{
  sub_1000B3D68((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void sub_100471E7C(uint64_t **a1)
{
  BOOL v6 = a1;
  uint64_t v1 = **a1;
  uint64_t v3 = *(void ***)(v1 + 432);
  for (uint64_t i = *(void ***)(v1 + 440); i != v3; sub_100471780(i))
    --i;
  *(void *)(v1 + 440) = v3;
  (*(void (**)(void))(**(void **)(v1 + 384) + 24))(*(void *)(v1 + 384));
  (*(void (**)(void))(**(void **)(v1 + 368) + 24))(*(void *)(v1 + 368));
  ctu::RestModule::disconnect((ctu::RestModule *)(v1 + 104));
  dispatch_object_t v4 = (atomic_uint **)(v1 + 80);
  for (uint64_t j = *(void *)(v1 + 88); (atomic_uint **)j != v4; uint64_t j = *(void *)(j + 8))
    sub_10016111C((uint64_t *)(j + 16));
  sub_100160A84(v4);
  operator delete();
}

void sub_100471F74()
{
}

void sub_100471FA4(void *a1)
{
  uint64_t v1 = (uint64_t *)*a1;
  BOOL v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = (void *)(*v1 + 64);
  dispatch_object_t v4 = (NSObject **)(*v1 + 24);
  __n128 __p = *(void **)(*v1 + 368);
  long long v8 = 0uLL;
  sub_100B17784(v3, v4, (uint64_t *)&__p, &v8);
  BOOL v5 = *(std::__shared_weak_count **)(v2 + 408);
  *(_OWORD *)(v2 + 400) = v8;
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_1013FE4A0(&v8);
}

void sub_100472C70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100472E94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v9[6] = a5;
  aBlock = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_10047334C;
  v9[3] = &unk_1019CF228;
  v9[4] = a2;
  void v9[5] = a4;
  aBlock = _Block_copy(v9);
  BOOL v6 = *(std::__shared_weak_count **)(a2 + 8);
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      long long v8 = v7;
      sub_1001644F8(v11, &aBlock, *(dispatch_object_t *)(a2 + 16));
      sub_100164540(&v12, v11);
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004730D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20)
{
  if (a2)
  {
    sub_100163BC8(v21 - 80);
    uint64_t v23 = *(void *)(v21 - 88);
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
    }
    std::__shared_weak_count::__release_weak(v20);
    sub_100161C9C((uint64_t)&a19);
    sub_10016578C((uint64_t)&a17);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10047318C(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/radio_state");
  v4[0] = off_1019CF468;
  v4[1] = a1;
  uint64_t v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_100473240(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10047326C(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/user_preferred_data_slot");
  v4[0] = off_1019CF808;
  v4[1] = a1;
  uint64_t v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_100473320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10047334C(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  char v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void *sub_100473398(void *a1)
{
  *a1 = off_1019CF258;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1004733E4(void *a1)
{
  *a1 = off_1019CF258;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100473450(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100473500(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100473518(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100473538()
{
}

void *sub_1004735A4(void *a1)
{
  *a1 = off_1019CF2A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1004735F0(void *a1)
{
  *a1 = off_1019CF2A8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_10047365C()
{
}

void sub_1004736CC()
{
}

__n128 sub_1004736E0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019CF2E8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100473734(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019CF2E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10047376C(void *a1)
{
  uint64_t v2 = (uint64_t *)a1[1];
  uint64_t v3 = *v2;
  uint64_t v4 = *((unsigned int *)v2 + 2);
  read_rest_value();
  BOOL v5 = (uint64_t (*)(void *, uint64_t, uint64_t))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    BOOL v5 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v7 + v5);
  }

  return v5(v7, v3, v4);
}

uint64_t sub_100473800(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100473840()
{
}

void sub_100473850()
{
}

__n128 sub_100473864(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019CF368;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004738B8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019CF368;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004738F0(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  BOOL v5 = (uint64_t (*)(void *))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    BOOL v5 = *(uint64_t (**)(void *))(*v7 + v5);
  }

  return v5(v7);
}

uint64_t sub_100473978(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004739B8()
{
}

void sub_1004739C8()
{
}

__n128 sub_1004739DC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019CF3E8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100473A30(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019CF3E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100473A68(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (uint64_t *)a1[1];
  long long v7 = *(_OWORD *)v3;
  uint64_t v8 = v3[2];
  uint64_t *v3 = 0;
  v3[1] = 0;
  void v3[2] = 0;
  sub_100089CF0(v3, a2);
  uint64_t v4 = (void (*)(void *, long long *))a1[3];
  uint64_t v5 = a1[4];
  uint64_t v6 = (void *)(a1[2] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(void (**)(void *, long long *))(*v6 + v4);
  }
  v4(v6, &v7);
  int v9 = (void **)&v7;
  sub_10008A88C(&v9);
}

void sub_100473B0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100473B28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100473B68()
{
}

void sub_100473B78()
{
}

void *sub_100473B8C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019CF468;
  result[1] = v3;
  return result;
}

uint64_t sub_100473BD4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019CF468;
  a2[1] = v2;
  return result;
}

uint64_t sub_100473C00(uint64_t a1, xpc *this, uint64_t a3)
{
  uint64_t v3 = *(unsigned char **)(a1 + 8);
  uint64_t result = xpc::dyn_cast_or_default(this, 0, a3);
  unint64_t v5 = 0x10101000000uLL >> (8 * result);
  if (result >= 7) {
    LOBYTE(v5) = 1;
  }
  unsigned char *v3 = v5;
  return result;
}

uint64_t sub_100473C48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100473C88()
{
}

void *sub_100473C94(void *a1)
{
  *a1 = off_1019CF4E8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100473CE0(void *a1)
{
  *a1 = off_1019CF4E8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100473D4C(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019CF4E8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100473DB0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019CF4E8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100473DF0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100473E00(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100473E40(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = (capabilities::ct *)std::__shared_weak_count::lock(v2);
    if (v4)
    {
      unint64_t v5 = (std::__shared_weak_count *)v4;
      if (a1[2])
      {
        int v6 = capabilities::ct::supportsStewie(v4);
        sub_10004D2C8(v5);
        if (v6)
        {
          long long v7 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v8 = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Stewie requested, exit ECBM", v8, 2u);
          }
          sub_10046AB0C(v3);
        }
      }
      else
      {
        sub_10004D2C8((std::__shared_weak_count *)v4);
      }
    }
  }
}

void sub_100473F10(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100473F24(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100473F64()
{
}

void sub_100473F74()
{
}

__n128 sub_100473F88(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019CF568;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100473FDC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019CF568;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100474014(void *a1, const xpc::object *a2)
{
  uint64_t v3 = (StewieFeatureState *)a1[1];
  int v4 = *(_DWORD *)v3;
  __int16 v10 = *((_WORD *)v3 + 2);
  int v9 = v4;
  read_rest_value(v3, a2);
  unint64_t v5 = (uint64_t (*)(void *, int *))a1[3];
  uint64_t v6 = a1[4];
  long long v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    unint64_t v5 = *(uint64_t (**)(void *, int *))(*v7 + v5);
  }
  return v5(v7, &v9);
}

uint64_t sub_1004740A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004740E0()
{
}

void sub_1004740F0()
{
}

__n128 sub_100474104(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019CF5E8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100474158(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019CF5E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100474190(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  int v4 = v3 + 1;
  uint64_t v5 = v3[1];
  int v9 = (char **)*v3;
  __int16 v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    void *v3 = v4;
    void *v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_1002430C8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_100474250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100474268(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004742A8()
{
}

void sub_1004742B8()
{
}

void *sub_1004742CC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019CF668;
  result[1] = v3;
  return result;
}

uint64_t sub_100474314(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019CF668;
  a2[1] = v2;
  return result;
}

void sub_100474340(uint64_t a1, const EmergencyMode *a2)
{
  xpc_object_t v5 = 0;
  write_rest_value(a2);
  sub_100058DB0(&__p, "/cc/props/emergency_mode");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_1004743E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100474428(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100474468()
{
}

void *sub_100474474(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    char v4 = (void *)result[3];
    xpc_object_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1004746DC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1004746EC()
{
}

void *sub_100474700(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019CF6F8;
  result[1] = v3;
  return result;
}

uint64_t sub_100474748(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019CF6F8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100474774(uint64_t a1, const xpc::object *a2)
{
  return read_rest_value(*(EmergencyMode **)(a1 + 8), a2);
}

uint64_t sub_10047477C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004747BC()
{
}

void sub_1004747CC()
{
}

void *sub_1004747E0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019CF778;
  result[1] = v3;
  return result;
}

uint64_t sub_100474828(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019CF778;
  a2[1] = v2;
  return result;
}

void sub_100474854()
{
  xpc_object_t v3 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/props/t911_preferences");
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_1004748F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10047493C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10047497C()
{
}

void sub_10047498C()
{
}

void *sub_1004749A0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019CF808;
  result[1] = v3;
  return result;
}

uint64_t sub_1004749E8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019CF808;
  a2[1] = v2;
  return result;
}

xpc_type_t sub_100474A14(uint64_t a1, xpc_object_t *a2)
{
  return sub_10041DCE4((int **)(a1 + 8), a2);
}

uint64_t sub_100474A1C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100474A5C()
{
}

uint64_t sub_100474A68()
{
  return 0;
}

void sub_100474A70(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      char v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 88))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100474AF0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100474B04(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 184))(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100474B98(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100474BAC(uint64_t a1, int a2, int a3)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v5) {
    goto LABEL_23;
  }
  uint64_t v6 = std::__shared_weak_count::lock(v5);
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)(a1 + 8);
    if (v8)
    {
      int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 160))(v8);
      sub_10004D2C8(v7);
      if (v9)
      {
        uint64_t v10 = a1 + 4 * a2;
        *(_DWORD *)(v10 + 24) = 2;
        unsigned int v11 = (int *)(v10 + 24);
        sub_100474A70(a1);
        *unsigned int v11 = 2;
        sub_100058DB0(__p, "Dialing");
        sub_100474B04(a1, (uint64_t)__p);
        if (v27 < 0) {
          operator delete(__p[0]);
        }
        int v12 = 3;
LABEL_26:
        *unsigned int v11 = v12;
        return 1;
      }
    }
    else
    {
      sub_10004D2C8(v7);
    }
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v13) {
    goto LABEL_23;
  }
  char v14 = std::__shared_weak_count::lock(v13);
  if (!v14) {
    goto LABEL_23;
  }
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)(a1 + 8);
  if (!v16)
  {
    sub_10004D2C8(v15);
    goto LABEL_23;
  }
  int v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 152))(v16);
  sub_10004D2C8(v15);
  if (!v17)
  {
LABEL_23:
    uint64_t v24 = a1 + 4 * a2;
    *(_DWORD *)(v24 + 24) = 2;
    unsigned int v11 = (int *)(v24 + 24);
    sub_100474E24(a1);
    *unsigned int v11 = 2;
    sub_100058DB0(__p, "Searching");
    sub_100474B04(a1, (uint64_t)__p);
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    int v12 = 1;
    goto LABEL_26;
  }
  uint64_t v18 = a1 + 4 * a2;
  *(_DWORD *)(v18 + 24) = 2;
  char v19 = (_DWORD *)(v18 + 24);
  long long v20 = *(std::__shared_weak_count **)(a1 + 16);
  if (v20)
  {
    uint64_t v21 = std::__shared_weak_count::lock(v20);
    if (v21)
    {
      uint64_t v22 = v21;
      uint64_t v23 = *(void *)(a1 + 8);
      if (v23) {
        (*(void (**)(uint64_t))(*(void *)v23 + 80))(v23);
      }
      sub_10004D2C8(v22);
    }
  }
  *char v19 = 2;
  sub_100058DB0(__p, "Idle");
  sub_100474B04(a1, (uint64_t)__p);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  *char v19 = 0;
  return 1;
}

void sub_100474DE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_100474E24(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      char v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100474EA4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100474EB8(uint64_t a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = *(void *)(**(void **)a1 + 56);
  *(_DWORD *)(v1 + 24) = 0;
  sub_100058DB0(__p, "Idle");
  sub_100474B04(v1, (uint64_t)__p);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  sub_100474F90(v1, (uint64_t)__p, 1);
  operator delete();
}

void sub_100474F4C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete();
}

uint64_t sub_100474F90(uint64_t a1, uint64_t a2, int a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0CE50[8 * *(_DWORD *)(a1 + 24) + 80])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if (v5) {
    sub_100474F90(a1, &v7, a3 | 1u);
  }
  if ((a3 & 6) == 0) {
    sub_10047525C((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10047511C(uint64_t result, _WORD *a2, int a3)
{
  char v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)__n128 result = 0;
      return result;
    case 2:
      __n128 result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      __n128 result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS2_5front4noneEhEENS0_5li"
                                        "st3INS0_5valueIPSC_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (__n128 result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS2_5front4noneEhEENS0_5list3INS0_5valueIPSC_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_100475228(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  char v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    char v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t *sub_10047525C(uint64_t *result)
{
  if (result[9])
  {
    uint64_t v1 = result;
    uint64_t v2 = (int64x2_t *)(result + 4);
    do
    {
      memset(v6, 0, sizeof(v6));
      uint64_t v3 = *(void *)(v1[5] + (((unint64_t)v1[8] >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v1[8] & 0x7F);
      uint64_t v4 = *(void *)v3;
      if (*(void *)v3)
      {
        *(void *)&v6[0] = *(void *)v3;
        if (v4)
        {
          long long v5 = *(_OWORD *)(v3 + 8);
          *((void *)&v6[1] + 1) = *(void *)(v3 + 24);
          *(_OWORD *)((char *)v6 + 8) = v5;
        }
        else
        {
          (*(void (**)(uint64_t, char *, void))(v4 & 0xFFFFFFFFFFFFFFFELL))(v3 + 8, (char *)v6 + 8, 0);
        }
      }
      sub_1000983B4(v2);
      sub_100098420(v6);
      __n128 result = sub_100098288((uint64_t *)v6);
    }
    while (v1[9]);
  }
  return result;
}

void sub_100475320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100475334(uint64_t a1, uint64_t a2, int a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0CE50[8 * *(_DWORD *)(a1 + 24) + 136])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if (v5) {
    sub_100474F90(a1, (uint64_t)&v7, a3 | 1);
  }
  if ((a3 & 6) == 0) {
    sub_10047525C((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1004754C0(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)__n128 result = 0;
      return result;
    case 2:
      __n128 result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      __n128 result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_10DialFailedEhEENS0_5l"
                                        "ist3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (__n128 result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_10DialFailedEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1004755CC(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_100475600()
{
  return 0;
}

uint64_t sub_100475608(uint64_t a1, int a2, int a3)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 3;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  sub_1004756C8(a1);
  *uint64_t v5 = 3;
  sub_100058DB0(__p, "ChoosingDomain");
  sub_100474B04(a1, (uint64_t)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  *uint64_t v5 = 2;
  return 1;
}

void sub_1004756AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004756C8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 48))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100475748(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_10047575C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1004757E0()
{
  return 0;
}

uint64_t sub_1004757E8(uint64_t a1, int a2, int a3)
{
  if (a3 != 5) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v5)
  {
    uint64_t v12 = a1 + 4 * a2;
    *(_DWORD *)(v12 + 24) = 5;
    uint64_t v13 = (_DWORD *)(v12 + 24);
LABEL_16:
    *uint64_t v13 = 5;
    sub_1004759A0(a1);
    *uint64_t v13 = 0;
    return 1;
  }
  uint64_t v6 = std::__shared_weak_count::lock(v5);
  if (!v6) {
    goto LABEL_11;
  }
  std::exception v7 = v6;
  uint64_t v8 = *(void *)(a1 + 8);
  if (!v8)
  {
    sub_10004D2C8(v7);
    goto LABEL_11;
  }
  int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 168))(v8);
  sub_10004D2C8(v7);
  if (!v9)
  {
LABEL_11:
    char v14 = *(std::__shared_weak_count **)(a1 + 16);
    uint64_t v15 = a1 + 4 * a2;
    *(_DWORD *)(v15 + 24) = 5;
    uint64_t v13 = (_DWORD *)(v15 + 24);
    if (v14)
    {
      uint64_t v16 = std::__shared_weak_count::lock(v14);
      if (v16)
      {
        int v17 = v16;
        uint64_t v18 = *(void *)(a1 + 8);
        if (v18) {
          (*(void (**)(uint64_t))(*(void *)v18 + 104))(v18);
        }
        sub_10004D2C8(v17);
      }
    }
    goto LABEL_16;
  }
  uint64_t v10 = a1 + 4 * a2;
  *(_DWORD *)(v10 + 24) = 5;
  unsigned int v11 = (_DWORD *)(v10 + 24);
  sub_100474A70(a1);
  *unsigned int v11 = 5;
  sub_100058DB0(__p, "Dialing");
  sub_100474B04(a1, (uint64_t)__p);
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  *unsigned int v11 = 3;
  return 1;
}

void sub_100475968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_1004759A0(uint64_t a1)
{
  sub_100058DB0(__p, "Idle");
  sub_100474B04(a1, (uint64_t)__p);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1004759F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100475A10(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 40))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100475A90(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100475AA4(uint64_t a1)
{
  sub_100058DB0(__p, "ChoosingDomain");
  sub_100474B04(a1, (uint64_t)__p);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100475AF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100475B14(uint64_t a1, int a2, int a3)
{
  if (a3) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v5) {
    goto LABEL_28;
  }
  uint64_t v6 = std::__shared_weak_count::lock(v5);
  if (!v6)
  {
LABEL_8:
    unsigned int v11 = *(std::__shared_weak_count **)(a1 + 16);
    if (v11)
    {
      uint64_t v12 = std::__shared_weak_count::lock(v11);
      if (v12)
      {
        uint64_t v13 = v12;
        uint64_t v14 = *(void *)(a1 + 8);
        if (v14)
        {
          int v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 120))(v14);
          sub_10004D2C8(v13);
          if (v15)
          {
            uint64_t v16 = a1 + 4 * a2;
            *(_DWORD *)(v16 + 24) = 0;
            int v17 = (int *)(v16 + 24);
            uint64_t v18 = *(std::__shared_weak_count **)(a1 + 16);
            if (!v18) {
              goto LABEL_26;
            }
            char v19 = std::__shared_weak_count::lock(v18);
            if (!v19) {
              goto LABEL_26;
            }
            long long v20 = v19;
            uint64_t v21 = *(void *)(a1 + 8);
            if (v21) {
              (*(void (**)(uint64_t))(*(void *)v21 + 32))(v21);
            }
LABEL_25:
            sub_10004D2C8(v20);
LABEL_26:
            *int v17 = 0;
            sub_100475AA4(a1);
            int v31 = 2;
LABEL_31:
            *int v17 = v31;
            return 1;
          }
        }
        else
        {
          sub_10004D2C8(v13);
        }
      }
      uint64_t v22 = *(std::__shared_weak_count **)(a1 + 16);
      if (v22)
      {
        uint64_t v23 = std::__shared_weak_count::lock(v22);
        if (v23)
        {
          uint64_t v24 = v23;
          uint64_t v25 = *(void *)(a1 + 8);
          if (v25)
          {
            int v26 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 112))(v25);
            sub_10004D2C8(v24);
            if (v26)
            {
              uint64_t v27 = a1 + 4 * a2;
              *(_DWORD *)(v27 + 24) = 0;
              int v17 = (int *)(v27 + 24);
              uint64_t v28 = *(std::__shared_weak_count **)(a1 + 16);
              if (!v28) {
                goto LABEL_26;
              }
              uint64_t v29 = std::__shared_weak_count::lock(v28);
              if (!v29) {
                goto LABEL_26;
              }
              long long v20 = v29;
              uint64_t v30 = *(void *)(a1 + 8);
              if (v30) {
                (*(void (**)(uint64_t))(*(void *)v30 + 24))(v30);
              }
              goto LABEL_25;
            }
          }
          else
          {
            sub_10004D2C8(v24);
          }
        }
      }
    }
LABEL_28:
    uint64_t v32 = a1 + 4 * a2;
    *(_DWORD *)(v32 + 24) = 0;
    int v17 = (int *)(v32 + 24);
    sub_100474E24(a1);
    *int v17 = 0;
    sub_100058DB0(__p, "Searching");
    sub_100474B04(a1, (uint64_t)__p);
    if (v35 < 0) {
      operator delete(__p[0]);
    }
    int v31 = 1;
    goto LABEL_31;
  }
  std::exception v7 = v6;
  uint64_t v8 = *(void *)(a1 + 8);
  if (!v8)
  {
    sub_10004D2C8(v7);
    goto LABEL_8;
  }
  int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 128))(v8);
  sub_10004D2C8(v7);
  if (!v9) {
    goto LABEL_8;
  }
  uint64_t v10 = a1 + 4 * a2;
  *(_DWORD *)(v10 + 24) = 0;
  sub_100475A10(a1);
  *(_DWORD *)(v10 + 24) = 0;
  sub_1004759A0(a1);
  *(_DWORD *)(v10 + 24) = 0;
  return 1;
}

void sub_100475D94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

uint64_t *sub_100475DD0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v80 = a1;
  uint64_t v81 = v1;
  uint64_t v2 = *(void *)v1;
  char v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    sub_10046F758(__p, (void *)(v1 + 8));
    uint64_t v4 = v85 >= 0 ? __p : (void **)__p[0];
    uint64_t v5 = asStringBool(*(unsigned char *)(v1 + 32));
    uint64_t v6 = asStringBool(*(unsigned char *)(v1 + 40));
    uint64_t v7 = subscriber::asString();
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = v4;
    __int16 v89 = 2080;
    uint64_t v90 = v5;
    __int16 v91 = 2080;
    v92 = (unsigned char *)v6;
    __int16 v93 = 2080;
    uint64_t v94 = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I prepare to call: %s, hadSipOrPdnError: %s, suspicious380Redirect: %s, preferredSlot: %s", buf, 0x2Au);
    if (SHIBYTE(v85) < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v8 = *(_DWORD **)(v1 + 8);
  int v9 = *(_DWORD **)(v1 + 16);
  if (v9 == v8)
  {
    uint64_t v14 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#E got an empty sim prefs, fail the call", buf, 2u);
    }
    goto LABEL_22;
  }
  uint64_t v10 = v9 - v8;
  if (v10 != (uint64_t)(*(void *)(v2 + 440) - *(void *)(v2 + 432)) >> 3)
  {
    int v15 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E got malformed sim prefs, fail the call", buf, 2u);
    }
    goto LABEL_22;
  }
  uint64_t v11 = 0;
  do
  {
    if (!*v8++) {
      ++v11;
    }
  }
  while (v8 != v9);
  if (v10 == v11)
  {
    uint64_t v13 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E got sim prefs that are not usable, fail the call", buf, 2u);
    }
LABEL_22:
    *(void *)long long buf = 0;
    sub_10046DFC0();
    goto LABEL_129;
  }
  if (*(void *)(v2 + 488) != *(void *)(v2 + 496))
  {
    uint64_t v16 = *(void *)(v2 + 520);
    if (v16)
    {
      if (*(int *)(v16 + 112) >= 1)
      {
        int v17 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I should have called retryToCall", buf, 2u);
        }
        if (*(unsigned char *)(v1 + 32)) {
          *(unsigned char *)(v2 + 558) = 1;
        }
        sub_100475334(*(void *)(v2 + 56), (uint64_t)buf, 1);
        goto LABEL_129;
      }
    }
  }
  uint64_t v79 = (void *)(v1 + 8);
  if (isActive() && *(void *)(v2 + 488) == *(void *)(v2 + 496))
  {
    sub_10046C564(v2);
    (*(void (**)(void))(**(void **)(v2 + 400) + 24))(*(void *)(v2 + 400));
  }
  uint64_t v18 = (capabilities::ct *)sub_10046CD1C(*(char **)(v1 + 8), *(char **)(v1 + 16), 2);
  int v19 = (int)v18;
  if (v18)
  {
    uint64_t v18 = (capabilities::ct *)sub_100529568();
    if (!v18)
    {
      sub_10046DEF8(v2, v19);
      goto LABEL_129;
    }
    *(_DWORD *)(v2 + 512) = v19;
  }
  if (*(_DWORD *)(v1 + 36) && capabilities::ct::supportsGemini(v18))
  {
    uint64_t v21 = *(_DWORD **)(v2 + 488);
    long long v20 = *(_DWORD **)(v2 + 496);
    uint64_t v22 = v20 - v21;
    uint64_t v23 = 0;
    while (v21 != v20)
    {
      if (!*v21++) {
        ++v23;
      }
    }
    if (v22 == v23)
    {
      BOOL v25 = sub_10046E6AC(v2, 1);
      if ((v25 | sub_10046E6AC(v2, 2)) == 1)
      {
        *(_DWORD *)(v2 + 516) = *(_DWORD *)(v1 + 36);
        int v26 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v27 = subscriber::asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v27;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Setting preferred slot: %s", buf, 0xCu);
        }
      }
    }
  }
  uint64_t v28 = *(char **)(v1 + 8);
  uint64_t v29 = *(void *)(v1 + 16);
  unint64_t v30 = (v29 - (uint64_t)v28) >> 2;
  if ((char *)v29 == v28)
  {
    uint64_t v28 = *(char **)(v1 + 16);
  }
  else if (*(void *)(v2 + 608))
  {
    for (unint64_t i = 0; i < v30 && i < *(void *)(v2 + 608); ++i)
    {
      if (!*(_DWORD *)&v28[4 * i]) {
        goto LABEL_91;
      }
      uint64_t v32 = subscriber::instanceAsSimSlot((subscriber *)i, v28);
      CFTypeRef cf = 0;
      __p[0] = 0;
      __p[1] = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 64));
      BOOL v34 = ServiceMap;
      if (v35 < 0)
      {
        char v36 = (unsigned __int8 *)(v35 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v37 = 5381;
        do
        {
          uint64_t v35 = v37;
          unsigned int v38 = *v36++;
          uint64_t v37 = (33 * v37) ^ v38;
        }
        while (v38);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v35;
      uint64_t v39 = sub_10004D37C(&v34[1].__m_.__sig, (unint64_t *)buf);
      if (v39)
      {
        uint64_t v41 = v39[3];
        int v40 = (std::__shared_weak_count *)v39[4];
        if (v40)
        {
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v34);
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v40);
          char v42 = 0;
          goto LABEL_59;
        }
      }
      else
      {
        uint64_t v41 = 0;
      }
      std::mutex::unlock(v34);
      int v40 = 0;
      char v42 = 1;
LABEL_59:
      PersonalityIdFromSlotIdEx();
      (*(void (**)(void **__return_ptr, uint64_t, unsigned char *))(*(void *)v41 + 40))(__p, v41, buf);
      if ((SHIBYTE(v91) & 0x80000000) == 0)
      {
        if (v42) {
          goto LABEL_62;
        }
LABEL_61:
        sub_10004D2C8(v40);
        goto LABEL_62;
      }
      operator delete(*(void **)buf);
      if ((v42 & 1) == 0) {
        goto LABEL_61;
      }
LABEL_62:
      if (__p[0])
      {
        (*(void (**)(const void **__return_ptr))(*(void *)__p[0] + 40))(&v86);
        CFTypeRef v43 = cf;
        CFTypeRef cf = v86;
        *(void *)long long buf = v43;
        v86 = 0;
        sub_1000577C4((const void **)buf);
        sub_1000577C4(&v86);
      }
      uint64_t v44 = (BOOL *)cf;
      int v45 = 1;
      buf[0] = 1;
      if (cf)
      {
        CFTypeID v46 = CFGetTypeID(cf);
        if (v46 == CFBooleanGetTypeID())
        {
          ctu::cf::assign((ctu::cf *)buf, v44, v47);
          int v45 = buf[0];
        }
        else
        {
          int v45 = 1;
        }
      }
      if (__p[1]) {
        sub_10004D2C8((std::__shared_weak_count *)__p[1]);
      }
      sub_1000577C4(&cf);
      if (!v45)
      {
        unint64_t v48 = (uint64_t *)(*(void *)(v2 + 600) + 8 * (i >> 6));
        uint64_t v49 = 1 << i;
LABEL_89:
        uint64_t v59 = *v48 & ~v49;
        goto LABEL_90;
      }
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v85 = 0;
      PersonalityIdFromSlotIdEx();
      if (SHIBYTE(v85) < 0)
      {
        sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)std::string __dst = *(_OWORD *)__p;
        uint64_t v83 = v85;
      }
      int v50 = sub_100046F68(v2 + 192, __dst);
      if ((void **)(v2 + 200) == v50 || *((_DWORD *)v50 + 14) != 1) {
        BOOL v51 = 0;
      }
      else {
        BOOL v51 = *((unsigned char *)v50 + 60) & 1;
      }
      if (SHIBYTE(v83) < 0) {
        operator delete(__dst[0]);
      }
      int v52 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 368) + 88))(*(void *)(v2 + 368), v32);
      BOOL v53 = v52;
      int v54 = v52 & !v51;
      __int16 v55 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v56 = asStringBool(v53);
        uint64_t v57 = asStringBool(v51);
        uint64_t v58 = asStringBool(v54);
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v56;
        __int16 v89 = 2080;
        uint64_t v90 = v57;
        __int16 v91 = 2080;
        v92 = (unsigned char *)v58;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Normal call stack registered: %s, is on IMS: %s, prefer CS: %s", buf, 0x20u);
      }
      if (SHIBYTE(v85) < 0) {
        operator delete(__p[0]);
      }
      unint64_t v48 = (uint64_t *)(*(void *)(v2 + 600) + 8 * (i >> 6));
      uint64_t v49 = 1 << i;
      if (!v54) {
        goto LABEL_89;
      }
      uint64_t v59 = *v48 | v49;
LABEL_90:
      uint64_t *v48 = v59;
      uint64_t v28 = *(char **)(v1 + 8);
      uint64_t v29 = *(void *)(v1 + 16);
LABEL_91:
      unint64_t v30 = (v29 - (uint64_t)v28) >> 2;
    }
  }
  if (*(unsigned char *)(v2 + 128))
  {
    uint64_t v60 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v61 = __p;
      sub_10046F758(__p, v79);
      if (v85 < 0) {
        unint64_t v61 = (void **)__p[0];
      }
      uint64_t v62 = __dst;
      sub_10046F758(__dst, (void *)(v2 + 488));
      if (v83 < 0) {
        uint64_t v62 = (void **)__dst[0];
      }
      uint64_t v63 = subscriber::asString();
      uint64_t v64 = *(void *)(v2 + 520);
      if (v64) {
        LOBYTE(v64) = (*(uint64_t (**)(uint64_t))(*(void *)v64 + 48))(v64);
      }
      uint64_t v65 = asStringBool(v64);
      *(_DWORD *)long long buf = 136315906;
      *(void *)&uint8_t buf[4] = v61;
      __int16 v89 = 2080;
      uint64_t v90 = (uint64_t)v62;
      __int16 v91 = 2080;
      v92 = (unsigned char *)v63;
      __int16 v93 = 2080;
      uint64_t v94 = v65;
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I simPrefs: %s, fSimPrefs: %s, fChosenSlot: %s, isCurrentAgentReady: %s", buf, 0x2Au);
      if (SHIBYTE(v83) < 0) {
        operator delete(__dst[0]);
      }
      if (SHIBYTE(v85) < 0) {
        operator delete(__p[0]);
      }
    }
    unsigned int v66 = subscriber::simSlotAsInstance();
    uint64_t v67 = *(void *)(v1 + 8);
    unint64_t v68 = (*(void *)(v1 + 16) - v67) >> 2;
    if (v68 > v66
      && (v69 = *(void *)(v2 + 488), unint64_t v70 = (*(void *)(v2 + 496) - v69) >> 2, v70 > v66)
      && v68 == v70
      && *(_DWORD *)(v67 + 4 * v66) == *(_DWORD *)(v69 + 4 * v66)
      && (uint64_t v71 = *(void *)(v2 + 520)) != 0
      && (*(unsigned int (**)(uint64_t))(*(void *)v71 + 48))(v71))
    {
      unsigned int v72 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v73 = (*(uint64_t (**)(void))(**(void **)(v2 + 520) + 56))(*(void *)(v2 + 520));
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v73;
        _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I same SIM prefs for previously chosen slot, %s is still ready, will dial with it", buf, 0xCu);
      }
    }
    else
    {
      sub_10046BAA0((void *)v2);
      if ((void *)(v2 + 576) != v79) {
        sub_10008A534((char *)(v2 + 576), *(char **)(v1 + 8), *(void *)(v1 + 16), (uint64_t)(*(void *)(v1 + 16) - *(void *)(v1 + 8)) >> 2);
      }
    }
  }
  else
  {
    if ((void *)(v2 + 488) != v79) {
      sub_10008A534((char *)(v2 + 488), v28, v29, v30);
    }
    char v74 = *(unsigned char *)(v1 + 40);
    if (v74)
    {
      int v75 = *(_DWORD *)(v2 + 248);
      int isValidSimSlot = subscriber::isValidSimSlot();
      if (v75 == 1) {
        int v77 = 2;
      }
      else {
        int v77 = 1;
      }
      if (isValidSimSlot) {
        int v77 = v75;
      }
      *(_DWORD *)(v2 + 512) = v77;
      char v74 = *(unsigned char *)(v1 + 40);
    }
    *(void *)long long buf = off_1019CF8C8;
    uint8_t buf[8] = v74;
    v92 = buf;
    sub_10046BE84(v2, (uint64_t)buf);
    sub_10047575C(buf);
  }
  sub_100476B0C(*(void *)(v2 + 56), (uint64_t)__p, 1);
LABEL_129:
  sub_100476984(&v81);
  return sub_100046B58((uint64_t *)&v80);
}

void sub_1004768B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  sub_100476984(&a16);
  sub_100046B58(&a15);
  _Unwind_Resume(a1);
}

uint64_t *sub_100476984(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(void **)(v1 + 8);
    if (v2)
    {
      *(void *)(v1 + 16) = v2;
      operator delete(v2);
    }
    operator delete();
  }
  return result;
}

void sub_1004769E0()
{
}

unsigned char *sub_1004769F4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = off_1019CF8C8;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t sub_100476A40(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019CF8C8;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

void sub_100476A70(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  long long v3 = *a2;
  int v4 = *((_DWORD *)a2 + 4);
  DWORD2(v3) = 0;
  BYTE1(v4) = *(unsigned char *)(a1 + 8);
  *(_OWORD *)a3 = v3;
  *(_DWORD *)(a3 + 16) = v4;
  EmergencyMode::~EmergencyMode((EmergencyMode *)&v3);
}

uint64_t sub_100476AC0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100476B00()
{
}

uint64_t sub_100476B0C(uint64_t a1, uint64_t a2, int a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0CE50[8 * *(_DWORD *)(a1 + 24) + 192])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if (v5) {
    sub_100474F90(a1, (uint64_t)&v7, a3 | 1);
  }
  if ((a3 & 6) == 0) {
    sub_10047525C((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_100476C98(uint64_t result, _WORD *a2, int a3)
{
  int v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)__n128 result = 0;
      return result;
    case 2:
      __n128 result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      __n128 result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_13PrepareToCallEhEENS0"
                                        "_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (__n128 result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_13PrepareToCallEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_100476DA4(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  int v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    int v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

void sub_100476DD8(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I retry to call", buf, 2u);
  }
  sub_100475334(*(void *)(v1 + 56), (uint64_t)&v4, 1);
  operator delete();
}

void sub_100476E7C()
{
}

uint64_t sub_100476EA8()
{
  return 0;
}

uint64_t sub_100476EB0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  char v4 = v3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 144))(v5);
  }
  else {
    uint64_t v6 = 0;
  }
  sub_10004D2C8(v4);
  return v6;
}

void sub_100476F30(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100476F44(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      char v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 72))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100476FC4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100476FD8(uint64_t a1)
{
  sub_100058DB0(__p, "EEM");
  sub_100474B04(a1, (uint64_t)__p);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10047702C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100477048(uint64_t a1, int a2, int a3)
{
  if (a3 != 4) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  int v5 = sub_100476EB0(a1);
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 24) = 4;
  std::exception v7 = (int *)(v6 + 24);
  if (v5)
  {
    sub_100476F44(a1);
    *std::exception v7 = 4;
    sub_100476FD8(a1);
    int v8 = 5;
  }
  else
  {
    sub_1004770EC(a1);
    *std::exception v7 = 4;
    sub_100477180(a1);
    int v8 = 0;
  }
  *std::exception v7 = v8;
  return 1;
}

void sub_1004770EC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      char v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 64))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10047716C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100477180(uint64_t a1)
{
  sub_100058DB0(__p, "Idle");
  sub_100474B04(a1, (uint64_t)__p);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1004771D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004771F0(uint64_t a1, int a2, int a3)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  int v5 = sub_100476EB0(a1);
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 24) = 3;
  std::exception v7 = (int *)(v6 + 24);
  if (v5)
  {
    sub_100476F44(a1);
    *std::exception v7 = 3;
    sub_100476FD8(a1);
    int v8 = 5;
  }
  else
  {
    sub_1004770EC(a1);
    *std::exception v7 = 3;
    sub_100477180(a1);
    int v8 = 0;
  }
  *std::exception v7 = v8;
  return 1;
}

uint64_t sub_100477294(uint64_t a1, int a2, int a3)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  int v5 = sub_100476EB0(a1);
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 24) = 1;
  std::exception v7 = (int *)(v6 + 24);
  if (v5)
  {
    sub_100476F44(a1);
    *std::exception v7 = 1;
    sub_100476FD8(a1);
    int v8 = 5;
  }
  else
  {
    sub_1004770EC(a1);
    *std::exception v7 = 1;
    sub_100477180(a1);
    int v8 = 0;
  }
  *std::exception v7 = v8;
  return 1;
}

void sub_100477338(uint64_t **a1)
{
  int v9 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I call disconnected", buf, 2u);
  }
  uint64_t v3 = *(void *)(v1 + 56);
  unsigned int v4 = *(_DWORD *)(v3 + 24);
  BOOL v5 = v4 > 4;
  int v6 = (1 << v4) & 0x1A;
  if (v5 || v6 == 0)
  {
    int v8 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v10 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "call disconnected while Fsm is not in a state that could handle EndCall event? Need to check", v10, 2u);
    }
  }
  else
  {
    sub_10047746C(v3, (uint64_t)&v11, 1);
  }
  operator delete();
}

void sub_100477440()
{
}

uint64_t sub_10047746C(uint64_t a1, uint64_t a2, int a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0CE50[8 * *(_DWORD *)(a1 + 24) + 248])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if (v5) {
    sub_100474F90(a1, (uint64_t)&v7, a3 | 1);
  }
  if ((a3 & 6) == 0) {
    sub_10047525C((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1004775F8(uint64_t result, _WORD *a2, int a3)
{
  unsigned int v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)__n128 result = 0;
      return result;
    case 2:
      __n128 result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      __n128 result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_7EndCallEhEENS0_5list3"
                                        "INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (__n128 result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_7EndCallEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_100477704(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  unsigned int v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    unsigned int v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

void sub_100477738(uint64_t **a1)
{
  int v9 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I end emergency requested, exit EEM.", buf, 2u);
  }
  if (*(unsigned char *)(v1 + 128))
  {
    int v3 = *(_DWORD *)(v1 + 124);
    if (v3 == 1)
    {
      sub_100477910(&event::call::NewCallInECBM[3]);
      unsigned int v4 = (uint64_t *)sub_100161CDC(&event::call::NewCallInECBM[1]);
      sub_10035414C(v4);
    }
    else
    {
      sub_1013FEFC8(*(void **)(v1 + 416), *(_DWORD *)(v1 + 512), 0, v3);
    }
  }
  else
  {
    int v5 = *(_DWORD *)(v1 + 312);
    int v6 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Not in EEM! Checking if we are in emergency mode for T911: Current Emergency Mode: %s.", buf, 0xCu);
    }
    if (v5 == 3)
    {
      sub_10046C48C(v1);
    }
    else
    {
      int v8 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I not in EEM, ignore endEmergency request", buf, 2u);
      }
    }
  }
  operator delete();
}

void sub_1004778E4()
{
}

void sub_100477910(uint64_t *a1)
{
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v2 = *a1;
    int v3 = 136315138;
    uint64_t v4 = v2;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Firing event '%s'", (uint8_t *)&v3, 0xCu);
  }
}

uint64_t sub_1004779B4(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

void sub_100477A18(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (subscriber::isValidSimSlot())
  {
    int v3 = *(_DWORD *)(v2 + 312);
    uint64_t v4 = *(NSObject **)(v2 + 40);
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3 == 5)
    {
      if (v5)
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Early Emergency session intent", (uint8_t *)&buf, 2u);
      }
      int v6 = *((_DWORD *)v1 + 2);
      BOOL v25 = off_1019CF998;
      int v26 = v6;
      uint64_t v27 = &v25;
      sub_10046BE84(v2, (uint64_t)&v25);
      sub_10047575C(&v25);
      int v7 = *((_DWORD *)v1 + 2);
      int v8 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = 300;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Arming Emergency Intent timer with %lld seconds", (uint8_t *)&buf, 0xCu);
      }
      int v9 = *(std::__shared_weak_count **)(v2 + 16);
      if (!v9 || (uint64_t v10 = *(void *)(v2 + 8), (v11 = std::__shared_weak_count::lock(v9)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v12 = v11;
      atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      Registry::getTimerService(&v22, *(Registry **)(v2 + 64));
      uint64_t v13 = v22;
      sub_100058DB0(__p, "EmergencyCallManager");
      uint64_t v14 = *(NSObject **)(v2 + 24);
      dispatch_object_t object = v14;
      if (v14) {
        dispatch_retain(v14);
      }
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 1174405120;
      uint64_t v29 = sub_10046C854;
      unint64_t v30 = &unk_1019CF020;
      uint64_t v31 = v10;
      uint64_t v32 = v12;
      atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      int v33 = v7;
      aBlock = _Block_copy(&buf);
      sub_100118A44(v13, (uint64_t)__p, 2, 300000000, &object, &aBlock);
      uint64_t v15 = v24;
      uint64_t v24 = 0;
      uint64_t v16 = *(void *)(v2 + 640);
      *(void *)(v2 + 640) = v15;
      if (v16)
      {
        (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
        uint64_t v17 = v24;
        uint64_t v24 = 0;
        if (v17) {
          (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v21 < 0) {
        operator delete(__p[0]);
      }
      if (v23) {
        sub_10004D2C8(v23);
      }
      if (v32) {
        std::__shared_weak_count::__release_weak(v32);
      }
      std::__shared_weak_count::__release_weak(v12);
      *(void *)&long long buf = 1;
      *((void *)&buf + 1) = v2 + 328;
      *(_DWORD *)(v2 + 364) = *((_DWORD *)v1 + 3);
      sub_1004779B4((uint64_t)&buf);
    }
    else if (v5)
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Not handling Early Emergency session intent in %s", (uint8_t *)&buf, 0xCu);
    }
  }
  operator delete();
}

void sub_100477D88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *aBlock, dispatch_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,std::__shared_weak_count *a31)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100477E40()
{
}

_DWORD *sub_100477E54(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = off_1019CF998;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_100477EA0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019CF998;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

void sub_100477ED0(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  long long v3 = *a2;
  int v4 = *((_DWORD *)a2 + 4);
  DWORD1(v3) = *(_DWORD *)(a1 + 8);
  DWORD2(v3) = 2;
  *(_DWORD *)(a3 + 16) = v4;
  *(_OWORD *)a3 = v3;
  EmergencyMode::~EmergencyMode((EmergencyMode *)&v3);
}

uint64_t sub_100477F1C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100477F5C()
{
}

void sub_100477F68(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  long long v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I sending T911 message", (uint8_t *)&buf, 2u);
  }
  if (*(void *)(v2 + 488) != *(void *)(v2 + 496))
  {
    int v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I In Emergency Mode for call, do nothing for T911", (uint8_t *)&buf, 2u);
    }
LABEL_66:
    operator delete();
  }
  uint64_t v5 = *((unsigned int *)v1 + 2);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 64));
  int v7 = ServiceMap;
  if (v8 < 0)
  {
    int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&buf);
  if (v12)
  {
    uint64_t v13 = v12[3];
    uint64_t v14 = (std::__shared_weak_count *)v12[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v15 = 0;
      if (!v13) {
        goto LABEL_12;
      }
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v14 = 0;
  char v15 = 1;
  if (!v13)
  {
LABEL_12:
    if (v15)
    {
LABEL_18:
      if (v13) {
        uint64_t v16 = v5;
      }
      else {
        uint64_t v16 = 300;
      }
      if (v16 >= 1)
      {
        uint64_t v17 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = v16;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Arming T911 timer with %lld seconds", (uint8_t *)&buf, 0xCu);
        }
        uint64_t v18 = *(std::__shared_weak_count **)(v2 + 16);
        if (!v18 || (uint64_t v19 = *(void *)(v2 + 8), (v20 = std::__shared_weak_count::lock(v18)) == 0)) {
          sub_100088B9C();
        }
        char v21 = v20;
        atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        Registry::getTimerService((uint64_t *)&v43, *(Registry **)(v2 + 64));
        uint64_t v22 = v43;
        sub_100058DB0(__p, "EmergencyCallManager");
        uint64_t v23 = *(NSObject **)(v2 + 24);
        dispatch_object_t object = v23;
        if (v23) {
          dispatch_retain(v23);
        }
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 1174405120;
        BOOL v51 = sub_10046C9D4;
        int v52 = &unk_1019CF050;
        uint64_t v53 = v19;
        int v54 = v21;
        atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        aBlock = _Block_copy(&buf);
        sub_100118A44((uint64_t)v22, (uint64_t)__p, 2, 1000000 * v16, &object, &aBlock);
        uint64_t v24 = v42;
        uint64_t v42 = 0;
        uint64_t v25 = *(void *)(v2 + 632);
        *(void *)(v2 + 632) = v24;
        if (v25)
        {
          (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
          uint64_t v26 = v42;
          uint64_t v42 = 0;
          if (v26) {
            (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
          }
        }
        if (aBlock) {
          _Block_release(aBlock);
        }
        if (object) {
          dispatch_release(object);
        }
        if (v48 < 0) {
          operator delete(__p[0]);
        }
        if (v44) {
          sub_10004D2C8(v44);
        }
        if (v54) {
          std::__shared_weak_count::__release_weak(v54);
        }
        std::__shared_weak_count::__release_weak(v21);
      }
      int v27 = *((_DWORD *)v1 + 2);
      *(void *)&long long buf = 1;
      *((void *)&buf + 1) = v2 + 328;
      *(_DWORD *)(v2 + 360) = v27;
      sub_1004779B4((uint64_t)&buf);
      if (isActive())
      {
        uint64_t v28 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v29 = asString();
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v29;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I EmergencyMode state %s", (uint8_t *)&buf, 0xCu);
        }
        if (*((_DWORD *)v1 + 3) == 2 && *(_DWORD *)(v2 + 304) != 2)
        {
          (*(void (**)(void))(**(void **)(v2 + 400) + 24))(*(void *)(v2 + 400));
        }
        else if (*((_DWORD *)v1 + 2) != *(_DWORD *)(v2 + 308))
        {
          (*(void (**)(void))(**(void **)(v2 + 400) + 24))(*(void *)(v2 + 400));
          uint64_t v30 = *(void *)(v2 + 400);
          switch(*((_DWORD *)v1 + 2))
          {
            case 1:
              char v36 = operator new(4uLL);
              CFTypeRef v43 = v36;
              *char v36 = 3;
              uint64_t v37 = (std::__shared_weak_count *)(v36 + 1);
              goto LABEL_62;
            case 2:
              unsigned int v38 = operator new(8uLL);
              CFTypeRef v43 = v38;
              void *v38 = 0x300000000;
              uint64_t v37 = (std::__shared_weak_count *)(v38 + 1);
LABEL_62:
              uint64_t v44 = v37;
              int v45 = v37;
              break;
            default:
              CFTypeRef v43 = 0;
              uint64_t v44 = 0;
              int v45 = 0;
              break;
          }
LABEL_63:
          int v52 = 0;
          uint64_t v49 = 0;
          (*(void (**)(uint64_t, void **, void, void, long long *, void **))(*(void *)v30 + 16))(v30, &v43, 0, 0, &buf, __p);
          sub_10003B34C(__p);
          sub_10035D6A8(&buf);
          if (v43)
          {
            uint64_t v44 = (std::__shared_weak_count *)v43;
            operator delete(v43);
          }
        }
      }
      else if ((*((_DWORD *)v1 + 3) - 1) <= 3)
      {
        uint64_t v31 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v32 = EmCallTypeAsString();
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v32;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I EmergencyCallType %s. Initiate cellular em search procedure", (uint8_t *)&buf, 0xCu);
        }
        uint64_t v30 = *(void *)(v2 + 400);
        switch(*((_DWORD *)v1 + 2))
        {
          case 1:
            int v33 = operator new(4uLL);
            CFTypeRef v43 = v33;
            *int v33 = 3;
            BOOL v34 = (std::__shared_weak_count *)(v33 + 1);
            goto LABEL_58;
          case 2:
            uint64_t v35 = operator new(8uLL);
            CFTypeRef v43 = v35;
            *uint64_t v35 = 0x300000000;
            BOOL v34 = (std::__shared_weak_count *)(v35 + 1);
LABEL_58:
            uint64_t v44 = v34;
            int v45 = v34;
            break;
          default:
            CFTypeRef v43 = 0;
            uint64_t v44 = 0;
            int v45 = 0;
            break;
        }
        goto LABEL_63;
      }
      uint64_t v39 = (std::__shared_weak_count *)(*((unsigned int *)v1 + 3) | ((unint64_t)*((unsigned int *)v1 + 2) << 32));
      CFTypeRef v43 = off_1019CFA18;
      uint64_t v44 = v39;
      CFTypeID v46 = &v43;
      sub_10046BE84(v2, (uint64_t)&v43);
      sub_10047575C(&v43);
      goto LABEL_66;
    }
LABEL_17:
    sub_10004D2C8(v14);
    goto LABEL_18;
  }
LABEL_16:
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v13 + 376))(v13, v5);
  if (v15) {
    goto LABEL_18;
  }
  goto LABEL_17;
}

void sub_10047866C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock, dispatch_object_t object, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29)
{
  if (__p) {
    operator delete(__p);
  }
  operator delete();
}

void sub_100478788()
{
}

void *sub_10047879C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019CFA18;
  result[1] = v3;
  return result;
}

uint64_t sub_1004787E4(uint64_t result, void *a2)
{
  *a2 = off_1019CFA18;
  a2[1] = *(void *)(result + 8);
  return result;
}

void sub_100478814(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  long long v4 = *a2;
  int v3 = *((_DWORD *)a2 + 4);
  *(void *)&long long v4 = *(void *)(a1 + 8);
  int v5 = v3;
  DWORD2(v4) = 3;
  *(_DWORD *)(a3 + 16) = v3;
  *(_OWORD *)a3 = v4;
  EmergencyMode::~EmergencyMode((EmergencyMode *)&v4);
}

uint64_t sub_100478864(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004788A4()
{
}

void sub_1004788B0(uint64_t **a1)
{
  int v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Cancel T911 message", buf, 2u);
  }
  sub_10046C48C(v1);
  operator delete();
}

void sub_10047894C()
{
}

uint64_t *sub_100478978(void **a1)
{
  uint64_t v1 = *a1;
  int v6 = a1;
  int v7 = v1;
  uint64_t v2 = *v1;
  long long v10 = *(_OWORD *)(*v1 + 304);
  int v11 = *(_DWORD *)(v2 + 320);
  if (DWORD2(v10) == 5)
  {
    EmergencyMode::operator=();
    if (BYTE1(v11))
    {
      EmergencyMode::EmergencyMode((EmergencyMode *)&v8);
      uint64_t v3 = v1[4];
      if (!v3) {
        sub_10007B600();
      }
    }
    else
    {
      long long v8 = v10;
      int v9 = v11;
      uint64_t v3 = v1[4];
      if (!v3) {
        sub_10007B600();
      }
    }
  }
  else if (BYTE1(v11))
  {
    EmergencyMode::EmergencyMode((EmergencyMode *)&v8);
    uint64_t v3 = v1[4];
    if (!v3) {
      sub_10007B600();
    }
  }
  else
  {
    long long v4 = (long long *)(v2 + 304);
    long long v8 = *v4;
    int v9 = *((_DWORD *)v4 + 4);
    uint64_t v3 = v1[4];
    if (!v3) {
      sub_10007B600();
    }
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v3 + 48))(v3, &v8);
  EmergencyMode::~EmergencyMode((EmergencyMode *)&v8);
  EmergencyMode::~EmergencyMode((EmergencyMode *)&v10);
  sub_100478B70((uint64_t *)&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100478B30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

uint64_t *sub_100478B70(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100471854((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

BOOL sub_100478BC0(uint64_t a1)
{
  uint64_t v1 = *(void *)(**(void **)(a1 + 40) + 520);
  return v1 && (*(unsigned int (**)(uint64_t))(*(void *)v1 + 72))(v1) == 2;
}

uint64_t sub_100478C1C(uint64_t a1)
{
  uint64_t result = *(void *)(**(void **)(a1 + 40) + 520);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 64))();
  }
  return result;
}

uint64_t sub_100478C54(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(**(void **)(a1 + 40) + 384) + 48))();
}

uint64_t sub_100478C84(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100478CC0(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

void sub_100478CFC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 40);
  uint64_t v2 = *v1;
  *(_DWORD *)v1[1] = (*(uint64_t (**)(void))(**(void **)(*v1 + 384) + 48))(*(void *)(*v1 + 384));
  (*(void (**)(long long *__return_ptr))(**(void **)(v2 + 384) + 56))(&v6);
  uint64_t v3 = v1[2];
  if (*(char *)(v3 + 23) < 0) {
    operator delete(*(void **)v3);
  }
  long long v4 = v6;
  *(void *)(v3 + 16) = v7;
  *(_OWORD *)uint64_t v3 = v4;
  (*(void (**)(long long *__return_ptr))(**(void **)(v2 + 384) + 64))(&v6);
  int v5 = (uint64_t *)v1[3];
  sub_10005CBB4(v5);
  *(_OWORD *)int v5 = v6;
  void v5[2] = v7;
  long long v6 = 0uLL;
  uint64_t v7 = 0;
  long long v8 = (void **)&v6;
  sub_100047F64(&v8);
}

void *sub_100478E0C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = **(void **)(a1 + 40);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  return sub_10035D43C(a2, *(const void **)(v2 + 576), *(void *)(v2 + 584), (uint64_t)(*(void *)(v2 + 584) - *(void *)(v2 + 576)) >> 2);
}

double sub_100478E34(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v3;
    operator delete(v3);
    *(void *)uint64_t v2 = 0;
    *(void *)(v2 + 8) = 0;
    *(void *)(v2 + 16) = 0;
  }
  double result = *(double *)&v5;
  *(_OWORD *)uint64_t v2 = v5;
  *(void *)(v2 + 16) = v6;
  return result;
}

double sub_100478EA0(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v3;
    operator delete(v3);
    *(void *)uint64_t v2 = 0;
    *(void *)(v2 + 8) = 0;
    *(void *)(v2 + 16) = 0;
  }
  double result = *(double *)&v5;
  *(_OWORD *)uint64_t v2 = v5;
  *(void *)(v2 + 16) = v6;
  return result;
}

void *sub_100478F0C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = **(void **)(a1 + 40);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  return sub_10035D43C(a2, *(const void **)(v2 + 488), *(void *)(v2 + 496), (uint64_t)(*(void *)(v2 + 496) - *(void *)(v2 + 488)) >> 2);
}

uint64_t sub_100478F30(uint64_t a1, uint64_t a2, int a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0CE50[8 * *(_DWORD *)(a1 + 24) + 304])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if (v5) {
    sub_100474F90(a1, (uint64_t)&v7, a3 | 1);
  }
  if ((a3 & 6) == 0) {
    sub_10047525C((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1004790BC(uint64_t result, _WORD *a2, int a3)
{
  long long v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)double result = 0;
      return result;
    case 2:
      double result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      double result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_13CallConnectedEhEENS0"
                                        "_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (double result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_13CallConnectedEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1004791C8(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  long long v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    long long v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1004791FC()
{
  return 0;
}

uint64_t sub_100479204(uint64_t a1, int a2, int a3)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 3;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    std::exception v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      long long v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t))(*(void *)v9 + 96))(v9);
      }
      sub_10004D2C8(v8);
    }
  }
  *uint64_t v5 = 3;
  sub_100058DB0(__p, "Connected");
  sub_100474B04(a1, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  *uint64_t v5 = 4;
  return 1;
}

void sub_1004792EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100479318(uint64_t a1, uint64_t a2, int a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0CE50[8 * *(_DWORD *)(a1 + 24) + 360])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if (v5) {
    sub_100474F90(a1, (uint64_t)&v7, a3 | 1);
  }
  if ((a3 & 6) == 0) {
    sub_10047525C((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1004794A4(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)double result = 0;
      return result;
    case 2:
      double result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      double result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_7ExitEEMEhEENS0_5list3"
                                        "INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (double result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_7ExitEEMEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1004795B0(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1004795E4()
{
  return 0;
}

uint64_t sub_1004795EC(uint64_t a1, int a2, int a3)
{
  if (a3 != 5) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 5;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  sub_1004770EC(a1);
  *uint64_t v5 = 5;
  sub_100058DB0(__p, "Idle");
  sub_100474B04(a1, (uint64_t)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  *uint64_t v5 = 0;
  return 1;
}

void sub_10047968C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004796AC()
{
}

void *sub_1004796C0(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = off_1019CFC58;
  result[1] = v3;
  return result;
}

uint64_t sub_100479708(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019CFC58;
  a2[1] = v2;
  return result;
}

void sub_100479734(long long *a1@<X1>, uint64_t a2@<X8>)
{
  long long v4 = *a1;
  int v3 = *((_DWORD *)a1 + 4);
  *(void *)&long long v4 = 0;
  int v5 = v3;
  DWORD2(v4) = 5;
  BYTE1(v5) = 0;
  if (StewieFeatureState::isServiceActive()) {
    DWORD2(v4) = 4;
  }
  *(_OWORD *)a2 = v4;
  *(_DWORD *)(a2 + 16) = v5;
  EmergencyMode::~EmergencyMode((EmergencyMode *)&v4);
}

void sub_1004797B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1004797C4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100479804()
{
}

void sub_100479814()
{
}

_DWORD *sub_100479828(uint64_t a1)
{
  double result = operator new(0x10uLL);
  *(void *)double result = off_1019CFCD8;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_100479874(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019CFCD8;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

void sub_1004798A4(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  long long v3 = *a2;
  int v4 = *((_DWORD *)a2 + 4);
  DWORD1(v3) = *(_DWORD *)(a1 + 8);
  DWORD2(v3) = 5;
  *(_DWORD *)(a3 + 16) = v4;
  *(_OWORD *)a3 = v3;
  EmergencyMode::~EmergencyMode((EmergencyMode *)&v3);
}

uint64_t sub_1004798F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100479930()
{
}

uint64_t sub_10047993C(uint64_t a1, uint64_t a2, int a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0CE50[8 * *(_DWORD *)(a1 + 24) + 416])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if (v5) {
    sub_100474F90(a1, (uint64_t)&v7, a3 | 1);
  }
  if ((a3 & 6) == 0) {
    sub_10047525C((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_100479AC8(uint64_t result, _WORD *a2, int a3)
{
  int v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)double result = 0;
      return result;
    case 2:
      double result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      double result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_10SearchDoneEhEENS0_5l"
                                        "ist3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (double result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_10SearchDoneEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_100479BD4(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  int v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    int v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_100479C08()
{
  return 0;
}

uint64_t sub_100479C10(uint64_t a1, int a2, int a3)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      std::exception v7 = v6;
      uint64_t v8 = *(void *)(a1 + 8);
      if (v8)
      {
        int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 136))(v8);
        sub_10004D2C8(v7);
        if (v9)
        {
          uint64_t v10 = a1 + 4 * a2;
          *(_DWORD *)(v10 + 24) = 1;
          int v11 = (_DWORD *)(v10 + 24);
          sub_100475A10(a1);
          *int v11 = 1;
          sub_100058DB0(__p, "Idle");
          sub_100474B04(a1, (uint64_t)__p);
          if (v16 < 0) {
            operator delete(__p[0]);
          }
          *int v11 = 0;
          return 1;
        }
      }
      else
      {
        sub_10004D2C8(v7);
      }
    }
  }
  uint64_t v12 = a1 + 4 * a2;
  *(_DWORD *)(v12 + 24) = 1;
  uint64_t v13 = (_DWORD *)(v12 + 24);
  sub_1004756C8(a1);
  *uint64_t v13 = 1;
  sub_100058DB0(__p, "ChoosingDomain");
  sub_100474B04(a1, (uint64_t)__p);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  *uint64_t v13 = 2;
  return 1;
}

void sub_100479D60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100479D94()
{
}

void *sub_100479DA8(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = off_1019CFD78;
  result[1] = v3;
  return result;
}

uint64_t sub_100479DF0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019CFD78;
  a2[1] = v2;
  return result;
}

void sub_100479E1C(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  long long v7 = *a2;
  int v8 = *((_DWORD *)a2 + 4);
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = (*(uint64_t (**)(void))(**(void **)(v4 + 520) + 72))(*(void *)(v4 + 520));
  unsigned int v6 = *(_DWORD *)(*(void *)(v4 + 520) + 8);
  LODWORD(v7) = v5;
  *(void *)((char *)&v7 + 4) = v6;
  *(_DWORD *)(a3 + 16) = v8;
  *(_OWORD *)a3 = v7;
  EmergencyMode::~EmergencyMode((EmergencyMode *)&v7);
}

void sub_100479EA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100479EBC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100479EFC()
{
}

uint64_t sub_100479F08(uint64_t a1, uint64_t a2, int a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0CE50[8 * *(_DWORD *)(a1 + 24) + 472])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if (v5) {
    sub_100474F90(a1, (uint64_t)&v7, a3 | 1);
  }
  if ((a3 & 6) == 0) {
    sub_10047525C((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10047A094(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)double result = 0;
      return result;
    case 2:
      double result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      double result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_13SearchTimeoutEhEENS0"
                                        "_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (double result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_13SearchTimeoutEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10047A1A0(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10047A1D4()
{
  return 0;
}

uint64_t sub_10047A1DC(uint64_t a1, int a2, int a3)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 1;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  unsigned int v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    std::exception v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      int v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t))(*(void *)v9 + 56))(v9);
      }
      sub_10004D2C8(v8);
    }
  }
  *uint64_t v5 = 1;
  sub_100058DB0(__p, "ChoosingDomain");
  sub_100474B04(a1, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  *uint64_t v5 = 2;
  return 1;
}

void sub_10047A2C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_10047A2F4()
{
}

void *sub_10047A308(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = off_1019CFE18;
  result[1] = v3;
  return result;
}

uint64_t sub_10047A350(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019CFE18;
  a2[1] = v2;
  return result;
}

uint64_t sub_10047A37C(uint64_t a1)
{
  return sub_100479F08(*(void *)(*(void *)(a1 + 8) + 56), (uint64_t)&v2, 1);
}

uint64_t sub_10047A3AC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10047A3EC()
{
}

void sub_10047A3FC()
{
}

void *sub_10047A410(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = off_1019CFE98;
  result[1] = v3;
  return result;
}

uint64_t sub_10047A458(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019CFE98;
  a2[1] = v2;
  return result;
}

uint64_t sub_10047A484(uint64_t a1, unsigned __int8 *a2, int *a3)
{
  return sub_10046D3F8(*(void *)(a1 + 8), *a2, *a3);
}

uint64_t sub_10047A494(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10047A4D4()
{
}

void sub_10047A4E4()
{
}

void *sub_10047A4F8()
{
  double result = operator new(0x10uLL);
  *double result = off_1019CFF18;
  return result;
}

void sub_10047A530(uint64_t a1, void *a2)
{
  *a2 = off_1019CFF18;
}

void sub_10047A558(long long *a1@<X1>, uint64_t a2@<X8>)
{
  long long v2 = *a1;
  int v3 = *((_DWORD *)a1 + 4);
  DWORD2(v2) = 1;
  *(_DWORD *)(a2 + 16) = v3;
  *(_OWORD *)a2 = v2;
  EmergencyMode::~EmergencyMode((EmergencyMode *)&v2);
}

uint64_t sub_10047A5A0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10047A5E0()
{
}

uint64_t sub_10047A5EC()
{
  return 0;
}

uint64_t sub_10047A5F4(uint64_t a1, int a2, int a3)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 3;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  sub_100474E24(a1);
  *uint64_t v5 = 3;
  sub_100058DB0(__p, "Searching");
  sub_100474B04(a1, (uint64_t)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  *uint64_t v5 = 1;
  return 1;
}

void sub_10047A698(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10047A6B8()
{
}

void *sub_10047A6CC(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = off_1019CFF98;
  result[1] = v3;
  return result;
}

uint64_t sub_10047A714(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019CFF98;
  a2[1] = v2;
  return result;
}

void sub_10047A740(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(v1 + 520);
  uint64_t v3 = *(NSObject **)(v1 + 40);
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      (*(void (**)(uint64_t))(*(void *)v2 + 72))(v2);
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = EmCallTypeAsString();
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Ready to dial over %s on %s.", buf, 0x16u);
      uint64_t v2 = *(void *)(v1 + 520);
    }
    if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 72))(v2) == 2) {
      (*(void (**)(void))(**(void **)(v1 + 400) + 24))(*(void *)(v1 + 400));
    }
    *(void *)long long buf = off_1019CFD78;
    *(void *)&uint8_t buf[8] = v1;
    uint64_t v13 = buf;
    sub_10046BE84(v1, (uint64_t)buf);
    sub_10047575C(buf);
    uint64_t v4 = *(_DWORD **)(v1 + 520);
    *(_DWORD *)(v1 + 512) = v4[2];
    int v5 = (*(uint64_t (**)(_DWORD *))(*(void *)v4 + 72))(v4);
    int v6 = *(_DWORD *)(*(void *)(v1 + 520) + 8);
    v11[0] = v5;
    v11[1] = v6;
    sub_10046DFC0();
    if ((*(unsigned int (**)(void))(**(void **)(v1 + 520) + 72))(*(void *)(v1 + 520)) != 1
      && !*(unsigned char *)(v1 + 321))
    {
      std::exception v7 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v11[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Setting IMS emergency mode and ECBM mode", (uint8_t *)v11, 2u);
      }
      uint64_t v8 = *(void *)(v1 + 416);
      int v9 = *(_DWORD *)(v1 + 512);
      int v10 = (*(uint64_t (**)(void))(**(void **)(v1 + 520) + 72))(*(void *)(v1 + 520));
      if ((v10 - 2) <= 3 && (!*(unsigned char *)(v8 + 200) || *(_DWORD *)(v8 + 204) != v10))
      {
        *(unsigned char *)(v8 + 200) = 1;
        *(_DWORD *)(v8 + 204) = v10;
        sub_1013FF088(v8, v9);
      }
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "ready to dial while not in Emergency mode? Need to check", buf, 2u);
  }
}

void sub_10047AA30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10047575C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10047AA4C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10047AA8C()
{
}

void sub_10047AA9C()
{
}

void *sub_10047AAB0(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = off_1019D0018;
  result[1] = v3;
  return result;
}

uint64_t sub_10047AAF8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D0018;
  a2[1] = v2;
  return result;
}

uint64_t sub_10047AB24(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(v3 + 520) + 56))(*(void *)(v3 + 520));
    int v7 = 136315138;
    uint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Dialing failed on %s", (uint8_t *)&v7, 0xCu);
  }
  if (v2)
  {
    *(unsigned char *)(v3 + 559) = 1;
    return sub_10047AC74(*(void *)(v3 + 56), (uint64_t)&v7, 1);
  }
  else
  {
    *(unsigned char *)(v3 + 558) = 1;
    return sub_100475334(*(void *)(v3 + 56), (uint64_t)&v7, 1);
  }
}

uint64_t sub_10047AC28(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10047AC68()
{
}

uint64_t sub_10047AC74(uint64_t a1, uint64_t a2, int a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0CE50[8 * *(_DWORD *)(a1 + 24) + 528])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if (v5) {
    sub_100474F90(a1, (uint64_t)&v7, a3 | 1);
  }
  if ((a3 & 6) == 0) {
    sub_10047525C((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10047AE00(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)double result = 0;
      return result;
    case 2:
      double result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      double result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_17FallbackRequestedEhE"
                                        "ENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (double result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN9emergency7CallFsmENS_9parameter5void_ESB_SB_SB_EERKNS9_17FallbackRequestedEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10047AF0C(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

void sub_10047AF44()
{
}

void *sub_10047AF58(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = off_1019D00B8;
  result[1] = v3;
  return result;
}

uint64_t sub_10047AFA0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D00B8;
  a2[1] = v2;
  return result;
}

void sub_10047AFCC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I context went down", (uint8_t *)__p, 2u);
  }
  uint64_t v3 = *(void *)(v1 + 520);
  if (!v3)
  {
    uint64_t v14 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "lost context while not in Emergency mode? Need to check", (uint8_t *)__p, 2u);
    }
    return;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 72))(v3) == 1) {
    return;
  }
  if (!*(unsigned char *)(v1 + 128)
    || (*(unsigned int (**)(void))(**(void **)(v1 + 520) + 72))(*(void *)(v1 + 520)) != 3
    && (*(unsigned int (**)(void))(**(void **)(v1 + 520) + 72))(*(void *)(v1 + 520)) != 4)
  {
    goto LABEL_32;
  }
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v1 + 64));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    std::exception v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)__p);
  if (v10)
  {
    uint64_t v12 = v10[3];
    int v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  int v11 = 0;
  char v13 = 1;
LABEL_18:
  PersonalityIdFromSlotIdEx();
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(void *)v12 + 40))(&v22, v12, __p);
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (v22)
  {
    (*(void (**)(void **__return_ptr))(*(void *)v22 + 40))(__p);
    if (__p[0]) {
      char v15 = sub_100080934;
    }
    else {
      char v15 = 0;
    }
    BOOL v16 = v15 != 0;
    sub_1000577C4((const void **)__p);
  }
  else
  {
    BOOL v16 = 0;
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (!v16 || *(unsigned char *)(v1 + 160))
  {
LABEL_32:
    uint64_t v17 = *(void **)(v1 + 416);
    int v18 = *(_DWORD *)(v1 + 512);
    int v19 = (*(uint64_t (**)(void))(**(void **)(v1 + 520) + 72))(*(void *)(v1 + 520));
    sub_1013FEFC8(v17, v18, 0, v19);
  }
}

void sub_10047B304(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10047B348(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10047B388()
{
}

void sub_10047B398()
{
}

void *sub_10047B3AC()
{
  double result = operator new(0x10uLL);
  *double result = off_1019D0138;
  return result;
}

void sub_10047B3E4(uint64_t a1, void *a2)
{
  *a2 = off_1019D0138;
}

void sub_10047B40C(long long *a1@<X1>, uint64_t a2@<X8>)
{
  long long v2 = *a1;
  int v3 = *((_DWORD *)a1 + 4);
  DWORD2(v2) = 0;
  *(_DWORD *)(a2 + 16) = v3;
  *(_OWORD *)a2 = v2;
  EmergencyMode::~EmergencyMode((EmergencyMode *)&v2);
}

uint64_t sub_10047B450(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10047B490()
{
}

void sub_10047B49C(uint64_t a1)
{
  uint64_t v1 = a1;
  sub_100476B0C(*(void *)(**(void **)a1 + 56), (uint64_t)&v2, 1);
  operator delete();
}

void sub_10047B4FC()
{
}

void sub_10047B528(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D01B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10047B548(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D01B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10047B59C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10047B5C4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D0208;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10047B5E4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D0208;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10047B638(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10047B660(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D0258;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10047B680(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D0258;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10047B6D4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10047B700()
{
}

void *sub_10047B714(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = off_1019D02A8;
  result[1] = v3;
  return result;
}

uint64_t sub_10047B75C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D02A8;
  a2[1] = v2;
  return result;
}

void sub_10047B788(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *((_DWORD *)a2 + 4);
  long long v5 = *a2;
  char v3 = **(unsigned char **)(a1 + 8);
  if (v3) {
    int v4 = 4;
  }
  else {
    int v4 = 5;
  }
  DWORD2(v5) = v4;
  LOBYTE(v6) = v3;
  *(_DWORD *)(a3 + 16) = v6;
  *(_OWORD *)a3 = v5;
  EmergencyMode::~EmergencyMode((EmergencyMode *)&v5);
}

uint64_t sub_10047B7E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10047B828()
{
}

void sub_10047B834()
{
  if ((byte_101B0CE50[0] & 1) == 0)
  {
    byte_101B0CE50[0] = 1;
    qword_101B0CEC0 = (uint64_t)sub_100474A68;
    unk_101B0CEC8 = sub_100474A68;
    qword_101B0CEB8 = (uint64_t)sub_100474A68;
    qword_101B0CEA0 = (uint64_t)sub_100474A68;
    unk_101B0CEA8 = sub_100474A68;
    qword_101B0CEB0 = (uint64_t)sub_100474BAC;
  }
}

void sub_10047B87C()
{
  if ((byte_101B0CE58 & 1) == 0)
  {
    byte_101B0CE58 = 1;
    qword_101B0CEF8 = (uint64_t)sub_100475600;
    unk_101B0CF00 = sub_100475600;
    qword_101B0CEE0 = (uint64_t)sub_100475600;
    unk_101B0CEE8 = sub_100475600;
    qword_101B0CED8 = (uint64_t)sub_100475600;
    qword_101B0CEF0 = (uint64_t)sub_100475608;
  }
}

void sub_10047B8C4()
{
  if ((byte_101B0CE60 & 1) == 0)
  {
    byte_101B0CE60 = 1;
    qword_101B0CF28 = (uint64_t)sub_1004757E0;
    unk_101B0CF30 = sub_1004757E0;
    qword_101B0CF18 = (uint64_t)sub_1004757E0;
    unk_101B0CF20 = sub_1004757E0;
    qword_101B0CF38 = (uint64_t)sub_1004757E8;
    qword_101B0CF10 = (uint64_t)sub_100475B14;
  }
}

void sub_10047B918()
{
  if ((byte_101B0CE68 & 1) == 0)
  {
    byte_101B0CE68 = 1;
    qword_101B0CF70 = (uint64_t)sub_100476EA8;
    qword_101B0CF58 = (uint64_t)sub_100476EA8;
    qword_101B0CF48 = (uint64_t)sub_100476EA8;
    qword_101B0CF68 = (uint64_t)sub_100477048;
    qword_101B0CF60 = (uint64_t)sub_1004771F0;
    qword_101B0CF50 = (uint64_t)sub_100477294;
  }
}

void sub_10047B980()
{
  if ((byte_101B0CE70 & 1) == 0)
  {
    byte_101B0CE70 = 1;
    qword_101B0CFA0 = (uint64_t)sub_1004791FC;
    unk_101B0CFA8 = sub_1004791FC;
    qword_101B0CF88 = (uint64_t)sub_1004791FC;
    unk_101B0CF90 = sub_1004791FC;
    qword_101B0CF80 = (uint64_t)sub_1004791FC;
    qword_101B0CF98 = (uint64_t)sub_100479204;
  }
}

void sub_10047B9C8()
{
  if ((byte_101B0CE78 & 1) == 0)
  {
    byte_101B0CE78 = 1;
    qword_101B0CFD0 = (uint64_t)sub_1004795E4;
    unk_101B0CFD8 = sub_1004795E4;
    qword_101B0CFC0 = (uint64_t)sub_1004795E4;
    unk_101B0CFC8 = sub_1004795E4;
    qword_101B0CFB8 = (uint64_t)sub_1004795E4;
    qword_101B0CFE0 = (uint64_t)sub_1004795EC;
  }
}

void sub_10047BA10()
{
  if ((byte_101B0CE80 & 1) == 0)
  {
    byte_101B0CE80 = 1;
    qword_101B0D010 = (uint64_t)sub_100479C08;
    unk_101B0D018 = sub_100479C08;
    qword_101B0D000 = (uint64_t)sub_100479C08;
    unk_101B0D008 = sub_100479C08;
    qword_101B0CFF0 = (uint64_t)sub_100479C08;
    qword_101B0CFF8 = (uint64_t)sub_100479C10;
  }
}

void sub_10047BA58()
{
  if ((byte_101B0CE88 & 1) == 0)
  {
    byte_101B0CE88 = 1;
    qword_101B0D048 = (uint64_t)sub_10047A1D4;
    unk_101B0D050 = sub_10047A1D4;
    qword_101B0D038 = (uint64_t)sub_10047A1D4;
    unk_101B0D040 = sub_10047A1D4;
    qword_101B0D028 = (uint64_t)sub_10047A1D4;
    qword_101B0D030 = (uint64_t)sub_10047A1DC;
  }
}

void sub_10047BAA0()
{
  if ((byte_101B0CE90 & 1) == 0)
  {
    byte_101B0CE90 = 1;
    qword_101B0D080 = (uint64_t)sub_10047A5EC;
    unk_101B0D088 = sub_10047A5EC;
    qword_101B0D068 = (uint64_t)sub_10047A5EC;
    unk_101B0D070 = sub_10047A5EC;
    qword_101B0D060 = (uint64_t)sub_10047A5EC;
    qword_101B0D078 = (uint64_t)sub_10047A5F4;
  }
}

void sub_10047BAE8(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10047BB54()
{
}

void *sub_10047BB78(void *a1, void *a2)
{
  *a1 = off_101A637F8;
  a1[1] = *a2;
  uint64_t v3 = a2[1];
  a1[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v5, kCtLoggingSystemName, "rm.bb.action");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v6, &v5);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 3), (const ctu::OsLogLogger *)v6);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v6);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v5);
  a1[4] = 0;
  a1[5] = 0;
  *a1 = off_1019D0338;
  ctu::RestModule::RestModule((ctu::RestModule *)(a1 + 6));
  a1[8] = 0;
  a1[9] = 0;
  a1[10] = 0;
  return a1;
}

void sub_10047BC60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  char v15 = (std::__shared_weak_count *)*((void *)v12 + 5);
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
  ctu::OsLogLogger::~OsLogLogger(v13);
  sub_10047BCB0(v12);
  _Unwind_Resume(a1);
}

void sub_10047BCB0(BasebandModeAction *this)
{
  *(void *)this = off_101A637F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  BasebandModeAction::~BasebandModeAction(this);
}

void sub_10047BD0C(uint64_t a1, dispatch_object_t *a2)
{
  dispatch_object_t v4 = *a2;
  if (*a2) {
    dispatch_retain(*a2);
  }
  OsLogContext v5 = *(NSObject **)(a1 + 64);
  *(void *)(a1 + 64) = v4;
  if (v5) {
    dispatch_release(v5);
  }
  sub_100058DB0(&__p, "BasebandModeActionUseABMFlexible");
  int v6 = *(NSObject **)(a1 + 64);
  dispatch_object_t v13 = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  dispatch_object_t object = 0;
  ctu::RestModule::RestModule();
  std::exception v7 = *(std::__shared_weak_count **)(a1 + 56);
  *(_OWORD *)(a1 + 48) = v18;
  long long v18 = 0uLL;
  if (v7)
  {
    sub_10004D2C8(v7);
    if (*((void *)&v18 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v18 + 1));
    }
  }
  if (object) {
    dispatch_release(object);
  }
  if (v13) {
    dispatch_release(v13);
  }
  if (v15 < 0) {
    operator delete(__p);
  }
  Registry::createRestModuleOneTimeUseConnection(&v10, *(Registry **)(a1 + 8));
  ctu::RestModule::connect();
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_100058DB0(&v18, "/cc/assertions/baseband_shutdown");
  *(_OWORD *)BOOL v16 = v18;
  uint64_t v17 = v19;
  uint64_t v19 = 0;
  long long v18 = 0uLL;
  ctu::path_join_impl();
  if (SHIBYTE(v19) < 0) {
    operator delete((void *)v18);
  }
  uint64_t v8 = operator new(0x28uLL);
  *uint64_t v8 = off_1019D0468;
  v8[1] = a1 + 72;
  void v8[2] = a1;
  v8[3] = sub_10047BFC8;
  void v8[4] = 0;
  long long v20 = v8;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v18);
  if (SHIBYTE(v17) < 0) {
    operator delete(v16[0]);
  }
  unsigned int v9 = *a2;
  if (v9) {
    dispatch_retain(v9);
  }
  sub_100E5DA68(a1);
}

void sub_10047BF1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, dispatch_object_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (v25) {
    dispatch_release(v25);
  }
  _Unwind_Resume(exception_object);
}

void sub_10047BFC8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = ctu::rest::asString();
    int v4 = *(_DWORD *)(a1 + 72);
    *(_DWORD *)uint64_t v17 = 136315394;
    *(void *)&_OWORD v17[4] = v3;
    __int16 v18 = 1024;
    int v19 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Evaluating shutdown assertion %s with generation %d", v17, 0x12u);
  }
  if (!*(_DWORD *)(a1 + 76) && *(void *)(a1 + 80))
  {
    OsLogContext v5 = *(NSObject **)(a1 + 24);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v17 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Shutting down baseband", v17, 2u);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
    std::exception v7 = ServiceMap;
    if (v8 < 0)
    {
      unsigned int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        uint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    *(void *)uint64_t v17 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)v17);
    if (v12)
    {
      uint64_t v14 = v12[3];
      dispatch_object_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
        if (!v14) {
          goto LABEL_20;
        }
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    dispatch_object_t v13 = 0;
    char v15 = 1;
    if (!v14) {
      goto LABEL_20;
    }
LABEL_17:
    BOOL v16 = *(NSObject **)(a1 + 24);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v17 = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Release EOS booted assertion as BB is going to be shutdown", v17, 2u);
    }
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
LABEL_20:
    if ((v15 & 1) == 0) {
      sub_10004D2C8(v13);
    }
    *(void *)uint64_t v17 = 0;
    sub_100E5DC04((abm **)v17);
  }
}

void sub_10047C24C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10047C290(uint64_t a1@<X0>, abm **a2@<X8>)
{
  int v4 = *(NSObject **)(a1 + 24);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = ctu::rest::asString();
    int v6 = *(_DWORD *)(a1 + 72);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Stopping with assertion %s and generation %d", buf, 0x12u);
    int v4 = *(NSObject **)(a1 + 24);
  }
  int v7 = *(_DWORD *)(a1 + 76);
  BOOL v8 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v7 != 1)
  {
    if (v8)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Proceeding with stop as no assertions are pending", buf, 2u);
    }
    sub_100E5DC04(a2);
  }
  if (!v8
    || (*(_WORD *)long long buf = 0,
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Granting shutdown assertion", buf, 2u),
        *(_DWORD *)(a1 + 76) == 1))
  {
    sub_100058DB0(__p, "/cc/assertions/baseband_shutdown");
    *(_OWORD *)long long buf = *(_OWORD *)__p;
    *(void *)&uint8_t buf[16] = v14;
    __p[1] = 0;
    uint64_t v14 = 0;
    __p[0] = 0;
    ctu::path_join_impl();
    xpc_object_t object = xpc_int64_create(*(unsigned int *)(a1 + 72));
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    ctu::RestModule::setProperty();
    xpc_release(object);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
  }
  unsigned int v9 = dispatch_group_create();
  uint64_t v10 = v9;
  *a2 = (abm *)v9;
  if (v9)
  {
    dispatch_retain(v9);
    dispatch_group_enter(v10);
  }
  unsigned int v11 = *(NSObject **)(a1 + 80);
  *(void *)(a1 + 80) = v10;
  if (v11)
  {
    dispatch_group_leave(v11);
    dispatch_release(v11);
  }
}

void sub_10047C4A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10047C50C()
{
  return 5;
}

void sub_10047C518(void *a1)
{
  sub_10047C550(a1);

  operator delete();
}

void sub_10047C550(void *a1)
{
  *a1 = off_1019D0338;
  char v2 = a1[10];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[10];
    if (v3) {
      dispatch_release(v3);
    }
  }
  int v4 = a1[8];
  if (v4) {
    dispatch_release(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[7];
  if (v5) {
    sub_10004D2C8(v5);
  }
  int v6 = (std::__shared_weak_count *)a1[5];
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  *a1 = off_101A637F8;
  int v7 = (std::__shared_weak_count *)a1[2];
  if (v7) {
    sub_10004D2C8(v7);
  }

  BasebandModeAction::~BasebandModeAction((BasebandModeAction *)a1);
}

void sub_10047C60C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10047C68C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10047C6C8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10047C700(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10047C730(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10047C778()
{
}

__n128 sub_10047C78C(uint64_t a1)
{
  char v2 = (char *)operator new(0x28uLL);
  *(void *)char v2 = off_1019D0468;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10047C7E0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D0468;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10047C818(void *a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  ctu::rest::read_rest_value();
  uint64_t v3 = (void (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(void (**)(void *))(*v5 + v3);
  }
  v3(v5);
  xpc_release(object);
}

void sub_10047C8B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

uint64_t sub_10047C8D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10047C910()
{
}

void sub_10047C91C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v2 = *(NSObject **)(*a1 + 24);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Closing pending shutdown session", v4, 2u);
  }
  uint64_t v3 = *(NSObject **)(v1 + 80);
  *(void *)(v1 + 80) = 0;
  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
  }
  operator delete();
}

uint64_t **sub_10047C9C0(uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  a1[1] = 0;
  uint64_t v4 = (uint64_t *)(a1 + 1);
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  if (a3)
  {
    uint64_t v5 = a2;
    int v6 = 0;
    int v7 = &a2[2 * a3];
    BOOL v8 = a1 + 1;
    while (1)
    {
      unsigned int v9 = v4;
      if (v8 == (uint64_t **)v4) {
        break;
      }
      uint64_t v10 = v6;
      unsigned int v11 = v4;
      if (v6)
      {
        do
        {
          unsigned int v9 = v10;
          uint64_t v10 = (uint64_t *)v10[1];
        }
        while (v10);
      }
      else
      {
        do
        {
          unsigned int v9 = (uint64_t *)v11[2];
          BOOL v12 = *v9 == (void)v11;
          unsigned int v11 = v9;
        }
        while (v12);
      }
      unint64_t v13 = *v5;
      if (v9[4] < *v5) {
        break;
      }
      char v15 = v4;
      uint64_t v14 = v4;
      if (!v6) {
        goto LABEL_25;
      }
      BOOL v16 = v6;
      while (1)
      {
        while (1)
        {
          uint64_t v14 = v16;
          unint64_t v17 = v16[4];
          if (v17 <= v13) {
            break;
          }
          BOOL v16 = (uint64_t *)*v14;
          char v15 = v14;
          if (!*v14) {
            goto LABEL_25;
          }
        }
        if (v17 >= v13) {
          break;
        }
        BOOL v16 = (uint64_t *)v14[1];
        if (!v16)
        {
          char v15 = v14 + 1;
          goto LABEL_25;
        }
      }
LABEL_28:
      v5 += 2;
      if (v5 == v7) {
        return a1;
      }
      BOOL v8 = (uint64_t **)*a1;
      int v6 = a1[1];
    }
    if (v6) {
      uint64_t v14 = v9;
    }
    else {
      uint64_t v14 = v4;
    }
    if (v6) {
      char v15 = v9 + 1;
    }
    else {
      char v15 = v4;
    }
    if (*v15) {
      goto LABEL_28;
    }
LABEL_25:
    __int16 v18 = operator new(0x30uLL);
    v18[2] = *(_OWORD *)v5;
    *(void *)__int16 v18 = 0;
    *((void *)v18 + 1) = 0;
    *((void *)v18 + 2) = v14;
    *char v15 = (uint64_t)v18;
    int v19 = (uint64_t *)**a1;
    if (v19)
    {
      *a1 = v19;
      __int16 v18 = (_OWORD *)*v15;
    }
    sub_100046C90(a1[1], (uint64_t *)v18);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    goto LABEL_28;
  }
  return a1;
}

void sub_10047CB24(_Unwind_Exception *a1)
{
  sub_10005D144(v1);
  _Unwind_Resume(a1);
}

void sub_10047CB38()
{
  __chkstk_darwin();
  uint64_t v26 = "getSubscriptionInfo:";
  LODWORD(v27) = 3;
  uint64_t v28 = "getActiveContexts:";
  LODWORD(v29) = 3;
  uint64_t v30 = "getDualSimCapability:";
  LODWORD(v31) = 3;
  uint64_t v32 = "getEvolvedSubscriptionLabelID:withCallback:";
  LODWORD(v33) = 3;
  BOOL v34 = "getDescriptorsForDomain:completion:";
  LODWORD(v35) = 1;
  char v36 = "ping:";
  LODWORD(v37) = 1;
  unsigned int v38 = "registerForNotifications:completion:";
  LODWORD(v39) = 1;
  int v40 = "sendRequest:completionHandler:";
  LODWORD(v41) = 0;
  uint64_t v42 = "reliableNetworkFallback:completion:";
  LODWORD(v43) = 3;
  uint64_t v44 = "setReliableNetworkFallback:enable:completion:";
  LODWORD(v45) = 3;
  CFTypeID v46 = "lowDataMode:completion:";
  LODWORD(v47) = 3;
  char v48 = "setLowDataMode:enable:completion:";
  LODWORD(v49) = 3;
  int v50 = "isSmartDataModeSupportedWithCompletion:";
  LODWORD(v51) = 3;
  int v52 = "smartDataMode:completion:";
  LODWORD(v53) = 3;
  int v54 = "setSmartDataMode:enable:completion:";
  int v55 = 3;
  uint64_t v56 = "isHighDataModeSupported:completion:";
  int v57 = 3;
  uint64_t v58 = "interfaceCostExpensive:completion:";
  int v59 = 3;
  uint64_t v60 = "setInterfaceCost:expensive:completion:";
  int v61 = 3;
  uint64_t v62 = "overriddenInterfaceCostInexpensiveWithCompletion:";
  int v63 = 29;
  uint64_t v64 = "setOverriddenInterfaceCostInexpensive:completion:";
  int v65 = 29;
  unsigned int v66 = "privacyProxy:completion:";
  int v67 = 3;
  unint64_t v68 = "setPrivacyProxy:enabled:completion:";
  int v69 = 18;
  unint64_t v70 = "dataUsageForLastPeriods:completion:";
  int v71 = 3;
  unsigned int v72 = "dataUsageForLastPeriodsOnActivePairedDevice:completion:";
  int v73 = 3;
  char v74 = "billingCycleEndDatesForLastPeriods:completion:";
  int v75 = 3;
  uint64_t v76 = "usageCollectionEnabled:";
  int v77 = 19;
  unint64_t v78 = "setUsageCollectionEnabled:completion:";
  int v79 = 19;
  uint64_t v80 = "userEnteredMonthlyBudget:completion:";
  int v81 = 3;
  uint64_t v82 = "setUserEntered:monthlyBudget:completion:";
  int v83 = 3;
  unint64_t v84 = "clearUserEnteredMonthlyBudget:completion:";
  int v85 = 3;
  v86 = "userEnteredMonthlyRoamingBudget:completion:";
  int v87 = 3;
  v88 = "setUserEntered:monthlyRoamingBudget:completion:";
  int v89 = 3;
  uint64_t v90 = "clearUserEnteredMonthlyRoamingBudget:completion:";
  int v91 = 3;
  v92 = "userEnteredBillingEndDayOfMont:completion:";
  int v93 = 3;
  uint64_t v94 = "setUserEnteredBillingEnd:dayOfMonth:completion:";
  int v95 = 3;
  uint64_t v96 = "clearUserEnteredBillingEndDayOfMonth:completion:";
  int v97 = 3;
  std::string v98 = "getCellularUsageWorkspaceInfo:";
  int v99 = 3;
  unint64_t v100 = "getLocalPolicies:completion:";
  int v101 = 11;
  uint64_t v102 = "getRemotePolicies:completion:";
  int v103 = 11;
  std::string v104 = "setLocalPolicies:completion:";
  int v105 = 12;
  uint64_t v106 = "setRemotePolicies:completion:";
  int v107 = 12;
  uint64_t v108 = "removePoliciesFromLocalDevice:completion:";
  int v109 = 12;
  uint64_t v110 = "performNetworkAccessFlowIfAllowed:ignoreForeground:completion:";
  int v111 = 11;
  uint64_t v112 = "sendTaggedInfo:type:payload:completion:";
  int v113 = 3;
  std::string v114 = "setPacketContextActiveByServiceType:connectionType:active:completion:";
  int v115 = 1;
  std::string v116 = "requestSliceByUUID:completion:";
  int v117 = 3;
  v118 = "requestSliceDeactivation:completion:";
  int v119 = 3;
  long long v120 = "resetAPNSettings:";
  int v121 = 3;
  uint64_t v122 = "addLowLatencyFilter:pdp:queueSetId:uplink:completion:";
  int v123 = 3;
  uint64_t v124 = "deleteLowLatencyFilter:pdp:queueSetId:uplink:completion:";
  int v125 = 3;
  long long v126 = "getLowLatencyFilters:queueSetId:completion:";
  int v127 = 3;
  unint64_t v128 = "sendDeadPeerDetection:";
  int v129 = 3;
  uint64_t v130 = "getInternationalDataAccess:completion:";
  int v131 = 3;
  long long v132 = "setInternationalDataAccess:status:completion:";
  int v133 = 3;
  long long v134 = "getSupportDynamicDataSimSwitch:";
  int v135 = 3;
  uint64_t v136 = "setSupportDynamicDataSimSwitch:completion:";
  int v137 = 3;
  long long v138 = "setSupportDynamicDataSimSwitch:forIccid:completion:";
  int v139 = 3;
  std::string v140 = "getPacketContextCount:";
  int v141 = 3;
  v142 = "getConnectionAvailability:connectionType:completion:";
  int v143 = 1;
  v144 = "getActiveConnections:completion:";
  int v145 = 1;
  v146 = "getConnectionState:connectionType:completion:";
  int v147 = 1;
  v148 = "getSliceTrafficDescriptorsInfo:connectionType:completion:";
  int v149 = 3;
  v150 = "getSliceTrafficDescriptors:";
  int v151 = 3;
  v152 = "getDataStatus:completion:";
  int v153 = 1;
  v154 = "getTetheringStatus:connectionType:";
  int v155 = 3;
  v156 = "getNATTKeepAliveOverCell:completion:";
  int v157 = 3;
  v158 = "isTetheringEditingSupported:completion:";
  int v159 = 3;
  v160 = "getAnbrActivationState:completion:";
  int v161 = 3;
  v162 = "queryAnbrBitrate:bitrate:direction:completion:";
  int v163 = 3;
  v164 = "setCoalescing:udp:completion:";
  int v165 = 3;
  v166 = "simulateDataStall:pdp:completion:";
  int v167 = 3;
  v168 = "getCurrentDataSubscriptionContext:";
  int v169 = 3;
  v170 = "getPreferredDataSubscriptionContext:";
  int v171 = 3;
  v172 = "getCurrentDataServiceDescriptor:";
  int v173 = 1;
  v174 = "getPreferredDataServiceDescriptor:";
  int v175 = 1;
  v176 = "enterLoopBackMode:";
  int v177 = 3;
  v178 = "setAssertionForConnectionType:enable:completion:";
  int v179 = 3;
  v180 = "setApplicationCategory:completion:";
  int v181 = 3;
  v182 = "getPublicDataBearer:";
  int v183 = 27;
  v184 = "getPublicNrFrequencyRange:";
  int v185 = 28;
  v186 = "authenticate:request:completion:";
  int v187 = 4;
  v188 = "copyEmergencyMode:";
  int v189 = 3;
  v190 = "getAllEmergencyNumbers:";
  int v191 = 3;
  v192 = "getStewieSupport:";
  int v193 = 3;
  v194 = "requestStewieWithContext:completion:";
  int v195 = 3;
  v196 = "exitStewieWithContext:completion:";
  int v197 = 3;
  v198 = "getConnectionAssistantConfig:";
  int v199 = 3;
  v200 = "getConnectionAssistantState:";
  int v201 = 3;
  v202 = "getConnectionAssistantServicePlot:";
  int v203 = 21;
  v204 = "setStewieBlocked:completion:";
  int v205 = 3;
  v206 = "reportStewieDeviceOrientation:completion:";
  int v207 = 3;
  v208 = "compressWithStewieCodec:completion:";
  int v209 = 3;
  v210 = "activateStewieEmergencyTryOutWithCompletion:";
  int v211 = 21;
  v212 = "reportStewieConnectionAssistantEvent:completion:";
  int v213 = 21;
  v214 = "testStewieCommand:completion:";
  int v215 = 3;
  v216 = "fetchRoadsideProvidersWithContext:completion:";
  int v217 = 3;
  v218 = "selectRoadsideProviderWithContext:completion:";
  int v219 = 21;
  v220 = "getResumableRoadsideProvider:";
  int v221 = 21;
  v222 = "setPrefForKey:heirarchy:value:storage:completion:";
  int v223 = 3;
  v224 = "getPrefForKey:heirarchy:storage:completion:";
  int v225 = 3;
  v226 = "terminateProcess:";
  int v227 = 3;
  v228 = "getRadioPersonality:completion:";
  int v229 = 3;
  v230 = "copyCarrierBundleValue:key:bundleType:completion:";
  int v231 = 1;
  v232 = "copyCarrierBundleValue:keyHierarchy:bundleType:completion:";
  int v233 = 1;
  v234 = "copyCarrierBundleValueWithDefault:key:bundleType:completion:";
  int v235 = 1;
  v236 = "copyCarrierBundleValueWithDefault:keyHierarchy:bundleType:completion:";
  int v237 = 1;
  v238 = "copyCarrierBundleValues:keys:defaultValues:bundleType:withFallbackBundleCheck:completion:";
  int v239 = 1;
  v240 = "copyCarrierBundleValues:keyHierarchies:defaultValues:bundleType:withFallbackBundleCheck:completion:";
  int v241 = 1;
  v242 = "copyCarrierBundleValueWithCountryBundleLookup:keyHierarchy:matchingInfo:completion:";
  int v243 = 3;
  v244 = "getCountryBundleLocationForBundleIdentifier:completion:";
  int v245 = 3;
  v246 = "getCountryBundleIdentifierForCountryCode:completion:";
  int v247 = 3;
  v248 = "copyCarrierBundleLocation:completion:";
  int v249 = 3;
  v250 = "copyCarrierBookmarks:completion:";
  int v251 = 1;
  v252 = "copyCarrierBundleVersion:completion:";
  int v253 = 3;
  v254 = "isAttachApnSettingAllowed:completion:";
  int v255 = 3;
  v256 = "context:modifyAttachApnSettings:completion:";
  int v257 = 3;
  v258 = "context:getAttachApnSettingsWithCompletion:";
  int v259 = 3;
  v260 = "copyBundleVersion:bundleType:completion:";
  int v261 = 3;
  v262 = "setWiFiCallingSettingPreferences:key:value:completion:";
  int v263 = 3;
  v264 = "getWiFiCallingSettingPreferences:key:completion:";
  int v265 = 3;
  v266 = "copyBundleIdentifier:bundleType:completion:";
  int v267 = 3;
  v268 = "restoreToSystemBundles:";
  int v269 = 19;
  v270 = "getEnglishCarrierNameFor:completion:";
  int v271 = 3;
  v272 = "copyBundleLocation:bundleType:completion:";
  int v273 = 3;
  v274 = "checkForUpdatedBundlesWithAutoInstall:completion:";
  int v275 = 3;
  v276 = "getCountryBundleLocationForMatchingInfo:completion:";
  int v277 = 3;
  int v295 = 3;
  v296 = "getActivationPolicyState:";
  int v293 = 3;
  v294 = "copyPriVersion:completion:";
  v290 = "copyLocationAreaCode:completion:";
  int v291 = 3;
  v292 = "refreshCellMonitor:completion:";
  int v287 = 3;
  v288 = "copyPublicCellId:completion:";
  int v289 = 9;
  int v285 = 3;
  v286 = "copyCellId:completion:";
  v282 = "getVoicemailCallInDetails:completion:";
  int v283 = 3;
  v284 = "copyCellInfo:completion:";
  v278 = "getVoicemailInfo:completion:";
  int v279 = 3;
  v280 = "setVisualVoicemailState:subscribed:completion:";
  int v281 = 3;
  int v297 = 15;
  v298 = "isFactoryDebugEnabled:";
  int v299 = 3;
  v300 = "fetchBasebandTicket:withCompletion:";
  int v301 = 14;
  v302 = "setUIConfiguredApns:apns:completion:";
  int v303 = 3;
  v304 = "getUIConfiguredApns:completion:";
  int v305 = 3;
  v306 = "resetUIConfiguredApns:completion:";
  int v307 = 3;
  v308 = "getConfiguredApns:completion:";
  int v309 = 3;
  v310 = "deletePersonalWallet:completion:";
  int v311 = 3;
  v312 = "getGSMAUIControlSetting:completion:";
  int v313 = 3;
  v314 = "loadGSMASettings:state:completion:";
  int v315 = 3;
  v316 = "listPersonalWallets:";
  int v317 = 3;
  v318 = "renamePersonalWallet:to:completion:";
  int v319 = 3;
  v320 = "transferPersonalWallet:to:completion:";
  int v321 = 3;
  v322 = "isPNRSupported:completion:";
  int v323 = 3;
  v324 = "issuePNRRequest:pnrReqType:completion:";
  int v325 = 3;
  v326 = "getPNRContext:completion:";
  int v327 = 3;
  v328 = "isPhoneNumberCredentialValid:completion:";
  int v329 = 3;
  v330 = "context:getPhoneNumberSignatureWithCompletion:";
  int v331 = 3;
  v332 = "context:resetPhoneNumber:";
  int v333 = 3;
  v334 = "getTransportKeysToUpdate:";
  int v335 = 3;
  v336 = "setTransportKeysUpdated:with:completion:";
  int v337 = 3;
  v338 = "forceRollAllTransportKeys:";
  int v339 = 3;
  v340 = "getSatelliteMsgCfgToUpdate:";
  int v341 = 3;
  v342 = "setSatelliteMsgCfgUpdated:completion:";
  int v343 = 3;
  v344 = "reprovisionSatelliteMsg:completion:";
  int v345 = 3;
  v346 = "hasDedicatedBearerSupport:";
  int v347 = 3;
  v348 = "addDedicatedBearer:completion:";
  int v349 = 3;
  v350 = "removeDedicatedBearer:completion:";
  int v351 = 3;
  v352 = "removeAllDedicatedBearers:";
  int v353 = 3;
  v354 = "isDedicatedBearerPresent:completion:";
  int v355 = 3;
  v356 = "getListOfPresentDedicatedBearers:";
  int v357 = 3;
  v358 = "getQoSLinkCharacteristics:";
  int v359 = 3;
  v360 = "requestQoSLinkCharacteristics:";
  int v361 = 3;
  v362 = "fetchCallWaitingValue:callClass:completion:";
  int v363 = 3;
  v364 = "saveCallWaitingValue:callClass:enabled:completion:";
  int v365 = 3;
  v366 = "fetchCallForwardingValue:reason:callClass:completion:";
  int v367 = 3;
  v368 = "saveCallForwardingValue:value:completion:";
  int v369 = 3;
  v370 = "isUnconditionalCallForwardingActive:completion:";
  int v371 = 3;
  v372 = "fetchCallBarringValue:facility:callClass:password:completion:";
  int v373 = 3;
  v374 = "saveCallBarringValue:facility:callClass:enabled:password:completion:";
  int v375 = 3;
  v376 = "fetchConnectedLinePresentationValue:completion:";
  int v377 = 3;
  v378 = "fetchCallingLinePresentationValue:completion:";
  int v379 = 3;
  v380 = "fetchConnectedLineIdRestrictionValue:completion:";
  int v381 = 3;
  v382 = "fetchCallingLineIdRestrictionValue:completion:";
  int v383 = 3;
  v384 = "saveCallingLineIdRestrictionValue:restrictionValue:completion:";
  int v385 = 3;
  v386 = "copyPriVersion:completion:";
  int v387 = 3;
  v388 = "context:canSetCapability:completion:";
  int v389 = 3;
  v390 = "context:getCapability:completion:";
  int v391 = 3;
  v392 = "context:setCapability:enabled:info:completion:";
  int v393 = 3;
  v394 = "context:getSystemCapabilities:";
  int v395 = 3;
  v396 = "getSupports5G:completion:";
  int v397 = 3;
  v398 = "context:recheckPhoneServicesAccountStatus:completion:";
  int v399 = 3;
  v400 = "getPhoneServicesDeviceList:";
  int v401 = 3;
  v402 = "getPhoneServicesDeviceInfo:";
  int v403 = 3;
  v404 = "context:addPhoneServicesDevice:withCompletion:";
  int v405 = 3;
  v406 = "context:removePhoneServicesDevice:withCompletion:";
  int v407 = 3;
  v408 = "wifiCallingCTFollowUpComplete:withCompletion:";
  int v409 = 3;
  v410 = "context:mandatoryDisableVoLTE:withCompletion:";
  int v411 = 3;
  v412 = "context:isMandatoryDisabledVoLTE:";
  int v413 = 3;
  v414 = "setVoLTEAudioCodec:codecInfo:completion:";
  int v415 = 3;
  v416 = "selectPhonebook:forPhonebookName:withPassword:completion:";
  int v417 = 3;
  v418 = "savePhonebookEntry:atIndex:withContactName:contactNumber:completion:";
  int v419 = 3;
  v420 = "fetchPhonebook:completion:";
  int v421 = 3;
  v422 = "getPhonebookEntryWithCompletion:atIndex:completion:";
  int v423 = 3;
  v424 = "getPhonebookEntryCountWithCompletion:completion:";
  int v425 = 3;
  v426 = "getPhoneNumberWithCompletion:completion:";
  int v427 = 3;
  v428 = "bootstrapPlanTransferForEndpoint:usingMessageSession:completion:";
  int v429 = 3;
  v430 = "getProximityTransportSession:remoteDeviceInfo:completion:";
  int v431 = 25;
  v432 = "checkRadioBootHealth:";
  int v433 = 3;
  v434 = "getBasebandRadioFrequencyFrontEndScanData:";
  int v435 = 14;
  v436 = "checkCellularDiagnosticsStatus:";
  int v437 = 3;
  v438 = "activateTurboMode:";
  int v439 = 3;
  v440 = "isEmergencyNumber:number:completion:";
  int v441 = 3;
  v442 = "isEmergencyNumberWithWhitelistIncluded:number:completion:";
  int v443 = 3;
  v444 = "shouldShowUserWarningWhenDialingCallOnContext:completion:";
  int v445 = 3;
  v446 = "shouldShowBrandedCallingInfo:";
  int v447 = 3;
  v448 = "setShouldShowBrandedCallingInfo:completion:";
  int v449 = 3;
  v450 = "getCallCapabilities:completion:";
  int v451 = 3;
  v452 = "getOperatorMultiPartyCallCountMaximum:completion:";
  int v453 = 3;
  v454 = "getSmsReadyState:completion:";
  int v455 = 3;
  v456 = "getSmscAddress:completion:";
  int v457 = 3;
  v458 = "getEmergencyTextNumbers:completion:";
  int v459 = 3;
  v460 = "getSweetgumCapabilities:completion:";
  int v461 = 3;
  v462 = "getSweetgumUserConsentInfo:completion:";
  int v463 = 3;
  v464 = "setSweetgumUserConsent:userConsent:completion:";
  int v465 = 3;
  v466 = "getSweetgumUsage:completion:";
  int v467 = 3;
  v468 = "refreshSweetgumUsage:completion:";
  int v469 = 3;
  v470 = "getSweetgumPlans:completion:";
  int v471 = 3;
  v472 = "refreshSweetgumPlans:completion:";
  int v473 = 3;
  v474 = "getSweetgumApps:completion:";
  int v475 = 3;
  v476 = "refreshSweetgumApps:completion:";
  int v477 = 3;
  v478 = "refreshSweetgumAll:completion:";
  int v479 = 3;
  v480 = "getSweetgumDataPlanMetrics:completion:";
  int v481 = 3;
  v482 = "purchaseSweetgumPlan:completion:";
  int v483 = 3;
  v484 = "getSIMToolkitMenuForContext:completion:";
  int v485 = 3;
  v486 = "selectSIMToolkitMenuItemForContext:index:completion:";
  int v487 = 3;
  v488 = "getSIMToolkitListItemsForContext:completion:";
  int v489 = 3;
  v490 = "selectSIMToolkitListItemForContext:session:response:index:completion:";
  int v491 = 3;
  v492 = "sendSIMToolkitUserActivityForContext:completion:";
  int v493 = 3;
  v494 = "sendSIMToolkitDisplayReadyForContext:completion:";
  int v495 = 3;
  v496 = "sendSIMToolkitResponseForContext:session:response:completion:";
  int v497 = 3;
  v498 = "sendSIMToolkitStringResponseForContext:session:response:string:completion:";
  int v499 = 3;
  v500 = "sendSIMToolkitBooleanResponseForContext:session:response:yesNo:completion:";
  int v501 = 3;
  v502 = "getSIMToolkitUSSDStringForContext:completion:";
  int v503 = 3;
  v504 = "sendSIMToolkitUSSDResponseForContext:response:completion:";
  int v505 = 3;
  v506 = "cancelSIMToolkitUSSDSessionForContext:completion:";
  int v507 = 3;
  v508 = "isVinylTapeSupportedWithCompletion:";
  int v509 = 15;
  v510 = "isVinylTestModeEnabledWithCompletion:";
  int v511 = 15;
  v512 = "setVinylTestMode:completion:";
  int v513 = 15;
  v514 = "setVirtualSimMode:withDualSim:completion:";
  int v515 = 14;
  v516 = "getEuiccData:";
  int v517 = 5;
  v518 = "setEosStatus:assertionState:completion:";
  int v519 = 14;
  v520 = "getEosStatus:";
  int v521 = 14;
  v522 = "getEOSFirmwareUpdateInfo:";
  int v523 = 3;
  v524 = "isPrivateNetworkContext:completion:";
  int v525 = 3;
  v526 = "getPrivateNetworkCapabilitiesForContext:completion:";
  int v527 = 3;
  v528 = "isPrivateNetworkSIM:completion:";
  int v529 = 3;
  v530 = "isPrivateNetworkEvaluationNeeded:";
  int v531 = 3;
  v532 = "isPrivateNetworkPreferredOverWifi:completion:";
  int v533 = 3;
  v534 = "updateGeofenceProfile:completion:";
  int v535 = 3;
  v536 = "removeGeofenceProfile:";
  int v537 = 3;
  v538 = "deleteHiddenSims:";
  int v539 = 3;
  v540 = "installPrivateNetworkProfile:completion:";
  int v541 = 3;
  v542 = "removePrivateNetworkProfile:completion:";
  int v543 = 3;
  v544 = "updatePrivateNetworkProfile:setProfileAside:completion:";
  int v545 = 3;
  v546 = "getPrivateNetworkSimInfoForContext:completion:";
  int v547 = 3;
  v548 = "requestBootstrapService:";
  int v549 = 31;
  v550 = "releaseBootstrapService:";
  int v551 = 31;
  v552 = "getBootstrapState:";
  int v553 = 25;
  sub_10047C9C0((uint64_t **)&v23, (unint64_t *)&v26, 264);
  uint64_t v0 = v24;
  qword_101B0D090 = (uint64_t)v23;
  qword_101B0D098 = (uint64_t)v24;
  qword_101B0D0A0 = v25;
  if (v25)
  {
    v24[2] = (uint64_t)&qword_101B0D098;
    uint64_t v23 = &v24;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v0 = 0;
  }
  else
  {
    qword_101B0D090 = (uint64_t)&qword_101B0D098;
  }
  sub_10005D144(v0);
  uint64_t v26 = "clientDidTriggerFault:";
  LODWORD(v27) = 3;
  uint64_t v28 = "subscriptionInfoDidChange";
  LODWORD(v29) = 3;
  uint64_t v30 = "activeSubscriptionsDidChange";
  LODWORD(v31) = 3;
  uint64_t v32 = "simLessSubscriptionsDidChange";
  LODWORD(v33) = 3;
  BOOL v34 = "dualSimCapabilityDidChange";
  LODWORD(v35) = 3;
  char v36 = "preferPrivateNetworkCellularOverWiFiDidChange";
  LODWORD(v37) = 3;
  unsigned int v38 = "privateNetworkInfoDidChange";
  LODWORD(v39) = 3;
  int v40 = "privateNetworkInfoDidChange:";
  LODWORD(v41) = 3;
  uint64_t v42 = "launchWebsheet:completion:";
  LODWORD(v43) = 3;
  uint64_t v44 = "launchSecureIntentUI:descriptor:isLocalConvertFlow:completion:";
  LODWORD(v45) = 25;
  CFTypeID v46 = "proxSetupAuthEventUpdate:";
  LODWORD(v47) = 25;
  char v48 = "transferEventUpdate:";
  LODWORD(v49) = 25;
  int v50 = "plansDidUpdate:";
  LODWORD(v51) = 3;
  int v52 = "reliableNetworkFallbackChanged:userEnabled:";
  LODWORD(v53) = 3;
  int v54 = "lowDataModeChanged:userEnabled:";
  int v55 = 3;
  uint64_t v56 = "smartDataModeChanged:userEnabled:";
  int v57 = 3;
  uint64_t v58 = "interfaceCostExpensiveChanged:isExpensive:";
  int v59 = 3;
  uint64_t v60 = "privacyProxyChanged:";
  int v61 = 3;
  uint64_t v62 = "refreshDataUsageUINotification";
  int v63 = 3;
  uint64_t v64 = "appDataUsagePolicyChange:";
  int v65 = 11;
  unsigned int v66 = "appDataUsagePolicyRemoved:";
  int v67 = 11;
  unint64_t v68 = "connectionAssistantStateChanged:";
  int v69 = 3;
  unint64_t v70 = "operatorNameChanged:name:";
  int v71 = 3;
  unsigned int v72 = "displayStatusChanged:status:";
  int v73 = 3;
  char v74 = "signalStrengthChanged:info:";
  int v75 = 3;
  uint64_t v76 = "rejectCauseCodeChanged:causeCode:";
  int v77 = 3;
  unint64_t v78 = "voiceLinkQualityChanged:metric:";
  int v79 = 3;
  uint64_t v80 = "enhancedVoiceLinkQualityChanged:metric:";
  int v81 = 3;
  uint64_t v82 = "enhancedDataLinkQualityChanged:metric:";
  int v83 = 3;
  unint64_t v84 = "imsRegistrationChanged:info:";
  int v85 = 3;
  v86 = "cellChanged:cell:";
  int v87 = 3;
  v88 = "cellMonitorUpdate:info:";
  int v89 = 3;
  uint64_t v90 = "networkListAvailable:list:";
  int v91 = 3;
  v92 = "customerServiceProfileChanged:visible:";
  int v93 = 3;
  uint64_t v94 = "networkSelected:success:mode:";
  int v95 = 3;
  uint64_t v96 = "networkReselectionNeeded:";
  int v97 = 3;
  std::string v98 = "encryptionStatusChanged:info:";
  int v99 = 3;
  unint64_t v100 = "ratSelectionChanged:selection:";
  int v101 = 3;
  uint64_t v102 = "nrDisableStatusChanged:status:";
  int v103 = 3;
  std::string v104 = "plmnChanged:plmn:";
  int v105 = 3;
  uint64_t v106 = "dataRatesChanged";
  int v107 = 3;
  uint64_t v108 = "taggedInfoIndicationChanged:type:payload:";
  int v109 = 3;
  uint64_t v110 = "systemConfigurationChanged:withConfiguration:";
  int v111 = 7;
  uint64_t v112 = "messageReceived:withID:ofType:";
  int v113 = 7;
  std::string v114 = "messageSendFailed:forMessageID:withError:";
  int v115 = 7;
  std::string v116 = "messageSendSuccess:withID:";
  int v117 = 7;
  v118 = "dispositionInformation:withStatus:";
  int v119 = 7;
  long long v120 = "composingIndicator:from:withID:withIndication:";
  int v121 = 7;
  uint64_t v122 = "didDiscover:destination:withCapabilities:withResult:";
  int v123 = 7;
  uint64_t v124 = "capabilitiesFound:destination:withCapabilities:";
  int v125 = 7;
  long long v126 = "revokationStatus:forMessageID:withResult:";
  int v127 = 7;
  unint64_t v128 = "requestToDisableAnonymization:from:withID:";
  int v129 = 7;
  uint64_t v130 = "requestToEnableDisplayedNotifications:from:withID:";
  int v131 = 7;
  long long v132 = "didFinishFetchChatBotRenderInformation:forChatBot:withRenderData:withResult:";
  int v133 = 7;
  long long v134 = "destinationCapabilitiesUpdated:withCapabilities:";
  int v135 = 7;
  uint64_t v136 = "didReportChatbotSpam:forChatbot:withResult:";
  int v137 = 7;
  long long v138 = "didReportSpam:forDestination:withResult:";
  int v139 = 7;
  std::string v140 = "incomingGroupChat:withGroupInformation:";
  int v141 = 7;
  v142 = "groupComposingIndicator:fromGroup:from:withID:withIndication:";
  int v143 = 7;
  v144 = "participantsRemoved:fromGroupChat:withRemovedParticipants:removedBy:";
  int v145 = 7;
  v146 = "participantsAdded:toGroupChat:withAddedParticipants:addedBy:";
  int v147 = 7;
  v148 = "subjectUpdated:forGroupChat:withNewSubject:updatedBy:";
  int v149 = 7;
  v150 = "didFinishGroupUpdate:forGroupChat:";
  int v151 = 7;
  v152 = "iconUpdated:forGroupChat:withNewIcon:updatedBy:";
  int v153 = 7;
  v154 = "chatDeleted:forGroupChat:deletedBy:";
  int v155 = 7;
  v156 = "didFinishGroupChatCreation:forGroupChat:withResult:";
  int v157 = 7;
  v158 = "didFinishParticipantsAddition:added:didNotAdd:withResult:";
  int v159 = 7;
  v160 = "didFinishParticipantsRemoval:removed:didNotRemove:withResult:";
  int v161 = 7;
  v162 = "didFinishExit:withResult:";
  int v163 = 7;
  v164 = "didFinishSubjectChange:withNewSubject:withResult:";
  int v165 = 7;
  v166 = "didFinishIconChange:withNewIcon:withResult:";
  int v167 = 7;
  v168 = "evictedFromGroup:withGroupInfo:evictedBy:";
  int v169 = 7;
  v170 = "connectionStateChanged:connection:dataConnectionStatusInfo:";
  int v171 = 1;
  v172 = "internetConnectionStateChanged:";
  int v173 = 1;
  v174 = "anbrActivationState:enabled:";
  int v175 = 3;
  v176 = "anbrBitrateRecommendation:bitrate:direction:";
  int v177 = 3;
  v178 = "connectionActivationError:connection:error:";
  int v179 = 1;
  v180 = "internetConnectionActivationError:";
  int v181 = 1;
  v182 = "preferredDataSimChanged:";
  int v183 = 3;
  v184 = "currentDataSimChanged:";
  int v185 = 3;
  v186 = "servingNetworkChanged:";
  int v187 = 3;
  v188 = "preferredDataServiceDescriptorChanged:";
  int v189 = 1;
  v190 = "currentDataServiceDescriptorChanged:";
  int v191 = 1;
  v192 = "connectionAvailability:availableConnections:";
  int v193 = 1;
  v194 = "internetConnectionAvailability:";
  int v195 = 1;
  v196 = "dataStatus:dataStatusInfo:";
  int v197 = 1;
  v198 = "regDataModeChanged:dataMode:";
  int v199 = 1;
  v200 = "internetDataStatus:";
  int v201 = 1;
  v202 = "internetDataStatusBasic:";
  int v203 = 1;
  v204 = "tetheringStatus:";
  int v205 = 3;
  v206 = "tetheringStatus:connectionType:";
  int v207 = 3;
  v208 = "dataSettingsChanged:";
  int v209 = 3;
  v210 = "serviceDisconnection:status:";
  int v211 = 3;
  v212 = "dataRoamingSettingsChanged:status:";
  int v213 = 3;
  v214 = "nrSliceAppStateChanged:status:trafficDescriptors:";
  int v215 = 3;
  v216 = "nrSlicedRunningAppStateChanged:";
  int v217 = 3;
  v218 = "simStatusDidChange:status:";
  int v219 = 3;
  v220 = "simLockSaveRequestDidComplete:success:";
  int v221 = 3;
  v222 = "simPinEntryErrorDidOccur:status:";
  int v223 = 3;
  v224 = "simPukEntryErrorDidOccur:status:";
  int v225 = 3;
  v226 = "simPinChangeRequestDidComplete:success:";
  int v227 = 3;
  v228 = "authTokenChanged:";
  int v229 = 16;
  v230 = "shortLabelsDidChange";
  int v231 = 3;
  v232 = "subscriberCountryCodeDidChange:";
  int v233 = 3;
  v234 = "userDefaultVoiceSlotDidChange:";
  int v235 = 3;
  v236 = "prlVersionDidChange:version:";
  int v237 = 3;
  v238 = "didDetectSimDeactivation:info:";
  int v239 = 3;
  v240 = "emergencyModeChanged:mode:";
  int v241 = 3;
  v242 = "smsReadyStateChanged:info:";
  int v243 = 3;
  v244 = "smsConditionsChanged:changeMask:";
  int v245 = 3;
  v246 = "smsMessageClass0Received:body:address:";
  int v247 = 3;
  v248 = "smsMessageCellBroadcastReceived:notificationDict:additionalDict:";
  int v249 = 3;
  v250 = "smsMessageTestMessageReceived:body:address:";
  int v251 = 3;
  v252 = "smsMessageReceived:msgID:";
  int v253 = 3;
  v254 = "mmsMessageReceived:msgID:";
  int v255 = 3;
  v256 = "smsMessageReceivedDeferred:msgID:";
  int v257 = 3;
  v258 = "mmsMessageReceivedDeferred:msgID:";
  int v259 = 3;
  v260 = "mmsConfigurationChangedNotification:changed:";
  int v261 = 3;
  v262 = "smsSent:messageID:info:";
  int v263 = 3;
  v264 = "postSMSMessageSent:success:messageID:err1:err2:";
  int v265 = 3;
  v266 = "postMMSMessageSent:success:messageID:err1:err2:";
  int v267 = 3;
  v268 = "postMessageProgressNotification:messageID:totalBytesSent:dataLength:";
  int v269 = 3;
  v270 = "postMmsDataActivationFailed:failureNotification:";
  int v271 = 3;
  v272 = "postSUPLInitNotification:body:";
  int v273 = 3;
  v274 = "postSUPLInitNotification:data:";
  int v275 = 3;
  v276 = "postSmscAddressAvailable:smsc:";
  int v277 = 3;
  v278 = "voicemailDatabaseReset:";
  int v279 = 3;
  v280 = "voicemailInfoAvailableNotification:voicemailInfo:";
  int v281 = 3;
  v282 = "pnrRequestSent:pnrReqData:";
  int v283 = 3;
  v284 = "pnrResponseReceived:pnrRspData:";
  int v285 = 3;
  v286 = "pnrReadyStateNotification:regState:";
  int v287 = 3;
  v288 = "context:pnrSupportChanged:";
  int v289 = 3;
  v290 = "stewieSupportChanged";
  int v291 = 3;
  v292 = "transportKeysChanged";
  int v293 = 3;
  v294 = "satelliteMsgCfgChanged";
  int v295 = 3;
  v296 = "dedicatedBearerSupportChanged:";
  int v297 = 3;
  v298 = "dedicatedBearerAdded:success:";
  int v299 = 3;
  v300 = "dedicatedBearedRemoved:";
  int v301 = 3;
  v302 = "qoSLinkCharacteristicsChanged:";
  int v303 = 3;
  v304 = "carrierBundleChange:";
  int v305 = 1;
  v306 = "operatorBundleChange:";
  int v307 = 3;
  v308 = "defaultBundleChange";
  int v309 = 3;
  v310 = "context:capabilitiesChanged:";
  int v311 = 3;
  v312 = "phoneServicesCapabilitiesChanged:";
  int v313 = 3;
  v314 = "suppServicesEvent:event:settingsType:data:";
  int v315 = 3;
  v316 = "spcUnlockSuccessful:";
  int v317 = 3;
  v318 = "phoneBookSelected:";
  int v319 = 3;
  v320 = "phoneBookFetched:";
  int v321 = 3;
  v322 = "phoneBookWritten:";
  int v323 = 3;
  v324 = "phoneBookError:";
  int v325 = 3;
  v326 = "phoneNumberAvailable:";
  int v327 = 3;
  v328 = "phoneNumberChanged:";
  int v329 = 3;
  v330 = "suppServicesStarted:";
  int v331 = 3;
  v332 = "suppServicesCompleted:";
  int v333 = 3;
  v334 = "suppServicesError:error:";
  int v335 = 3;
  v336 = "didChangeDeviceManagementSettings:";
  int v337 = 3;
  v338 = "callCapabilitiesChanged:capabilities:";
  int v339 = 3;
  v340 = "sweetgumCapabilitiesChanged:serviceDescriptor:";
  int v341 = 3;
  v342 = "sweetgumUserConsentInfoChanged:";
  int v343 = 3;
  v344 = "sweetgumUsageChanged:";
  int v345 = 3;
  v346 = "sweetgumPlansChanged:";
  int v347 = 3;
  v348 = "sweetgumAppsChanged:";
  int v349 = 3;
  v350 = "sweetgumDataPlanMetricsChanged:";
  int v351 = 3;
  sub_10047C9C0((uint64_t **)&v23, (unint64_t *)&v26, 163);
  uint64_t v1 = v24;
  qword_101B0D0A8 = (uint64_t)v23;
  qword_101B0D0B0 = (uint64_t)v24;
  qword_101B0D0B8 = v25;
  if (v25)
  {
    v24[2] = (uint64_t)&qword_101B0D0B0;
    uint64_t v23 = &v24;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v1 = 0;
  }
  else
  {
    qword_101B0D0A8 = (uint64_t)&qword_101B0D0B0;
  }
  sub_10005D144(v1);
  qword_101B0D0C8 = 0;
  qword_101B0D0D0 = 0;
  qword_101B0D0C0 = 0;
  char v2 = operator new(0x30uLL);
  void *v2 = "com.apple.Preferences";
  v2[1] = "com.apple.Bridge";
  v2[2] = "com.apple.NanoSettings";
  v2[3] = "cupolicy";
  v2[4] = "CSViewService";
  v2[5] = "com.apple.CSViewService";
  qword_101B0D0C0 = (uint64_t)v2;
  qword_101B0D0C8 = (uint64_t)(v2 + 6);
  qword_101B0D0D0 = (uint64_t)(v2 + 6);
  qword_101B0D0D8 = 0;
  qword_101B0D0E0 = 0;
  unk_101B0D0E8 = 0;
  uint64_t v3 = operator new(0x48uLL);
  qword_101B0D0E0 = (uint64_t)(v3 + 9);
  unk_101B0D0E8 = v3 + 9;
  void *v3 = "com.apple.Preferences";
  v3[1] = "com.apple.Bridge";
  void v3[2] = "com.apple.NanoSettings";
  v3[3] = "cupolicy";
  v3[4] = "ScreenSharingServer";
  v3[5] = "com.apple.screensharingserver";
  v3[6] = "CSViewService";
  v3[7] = "com.apple.CSViewService";
  v3[8] = "chronod";
  qword_101B0D0D8 = (uint64_t)v3;
  uint64_t v26 = "getLocalPolicies:completion:";
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  sub_10004EEB4(&v27, v3, (uint64_t)(v3 + 9), 9uLL);
  uint64_t v30 = "getRemotePolicies:completion:";
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  sub_10004EEB4(&v31, (const void *)qword_101B0D0D8, qword_101B0D0E0, (qword_101B0D0E0 - qword_101B0D0D8) >> 3);
  BOOL v34 = "setLocalPolicies:completion:";
  uint64_t v35 = 0;
  char v36 = 0;
  uint64_t v37 = 0;
  sub_10004EEB4(&v35, (const void *)qword_101B0D0C0, qword_101B0D0C8, (qword_101B0D0C8 - qword_101B0D0C0) >> 3);
  unsigned int v38 = "setRemotePolicies:completion:";
  uint64_t v39 = 0;
  int v40 = 0;
  uint64_t v41 = 0;
  sub_10004EEB4(&v39, (const void *)qword_101B0D0C0, qword_101B0D0C8, (qword_101B0D0C8 - qword_101B0D0C0) >> 3);
  uint64_t v4 = operator new(8uLL);
  void *v4 = "cupolicy";
  uint64_t v42 = "removePoliciesFromLocalDevice:completion:";
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  sub_10004EEB4(&v43, v4, (uint64_t)(v4 + 1), 1uLL);
  CFTypeID v46 = "appDataUsagePolicyChange:";
  uint64_t v47 = 0;
  char v48 = 0;
  uint64_t v49 = 0;
  sub_10004EEB4(&v47, (const void *)qword_101B0D0D8, qword_101B0D0E0, (qword_101B0D0E0 - qword_101B0D0D8) >> 3);
  int v50 = "appDataUsagePolicyRemoved:";
  uint64_t v51 = 0;
  int v52 = 0;
  uint64_t v53 = 0;
  sub_10004EEB4(&v51, (const void *)qword_101B0D0D8, qword_101B0D0E0, (qword_101B0D0E0 - qword_101B0D0D8) >> 3);
  uint64_t v5 = 0;
  int v6 = 0;
  uint64_t v7 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = &v24;
  BOOL v8 = &v24;
  while (1)
  {
    unsigned int v9 = (&v26)[4 * v7];
    uint64_t v10 = &v24;
    if (v8 == &v24) {
      goto LABEL_14;
    }
    unsigned int v11 = v6;
    BOOL v12 = &v24;
    if (v6)
    {
      do
      {
        uint64_t v10 = (uint64_t **)v11;
        unsigned int v11 = (uint64_t *)v11[1];
      }
      while (v11);
    }
    else
    {
      do
      {
        uint64_t v10 = (uint64_t **)v12[2];
        BOOL v13 = *v10 == (uint64_t *)v12;
        BOOL v12 = v10;
      }
      while (v13);
    }
    if (v10[4] < (uint64_t *)v9)
    {
LABEL_14:
      if (v6) {
        uint64_t v14 = v10;
      }
      else {
        uint64_t v14 = &v24;
      }
      if (v6)
      {
        char v15 = v10 + 1;
      }
      else
      {
        uint64_t v10 = (uint64_t **)&v23;
        char v15 = &v24;
      }
      if (v10[1]) {
        goto LABEL_33;
      }
LABEL_30:
      __int16 v18 = (uint64_t *)operator new(0x40uLL);
      v18[5] = 0;
      v18[4] = (uint64_t)v9;
      v18[6] = 0;
      v18[7] = 0;
      sub_10004EEB4(v18 + 5, (&v26)[4 * v7 + 1], (uint64_t)(&v28)[4 * v7], ((&v28)[4 * v7] - (&v26)[4 * v7 + 1]) >> 3);
      uint64_t *v18 = 0;
      v18[1] = 0;
      v18[2] = (uint64_t)v14;
      *char v15 = v18;
      if (*v23)
      {
        uint64_t v23 = (uint64_t **)*v23;
        __int16 v18 = *v15;
      }
      sub_100046C90(v24, v18);
      uint64_t v5 = ++v25;
      goto LABEL_33;
    }
    char v15 = &v24;
    uint64_t v14 = &v24;
    if (!v6) {
      goto LABEL_30;
    }
    BOOL v16 = v6;
    while (1)
    {
      while (1)
      {
        uint64_t v14 = (uint64_t **)v16;
        unint64_t v17 = v16[4];
        if (v17 <= (unint64_t)v9) {
          break;
        }
        BOOL v16 = *v14;
        char v15 = v14;
        if (!*v14) {
          goto LABEL_30;
        }
      }
      if (v17 >= (unint64_t)v9) {
        break;
      }
      BOOL v16 = v14[1];
      if (!v16)
      {
        char v15 = v14 + 1;
        goto LABEL_30;
      }
    }
LABEL_33:
    if (++v7 == 7) {
      break;
    }
    BOOL v8 = v23;
    int v6 = v24;
  }
  int v19 = v24;
  qword_101B0D0F0 = (uint64_t)v23;
  qword_101B0D0F8 = (uint64_t)v24;
  qword_101B0D100 = v5;
  if (v5)
  {
    v24[2] = (uint64_t)&qword_101B0D0F8;
    uint64_t v23 = &v24;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    int v19 = 0;
  }
  else
  {
    qword_101B0D0F0 = (uint64_t)&qword_101B0D0F8;
  }
  sub_100368D88(v19);
  for (uint64_t i = 0; i != -28; i -= 4)
  {
    char v21 = *(char **)((char *)&v51 + i * 8);
    if (v21)
    {
      (&v52)[i] = v21;
      operator delete(v21);
    }
  }
  operator delete(v4);
}

void sub_10047EB18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  operator delete(v19);
  while (1)
  {
    uint64_t v22 = (void *)*((void *)v20 - 3);
    if (v22)
    {
      *((void *)v20 - 2) = v22;
      operator delete(v22);
    }
    v20 -= 32;
    if (v20 == &a19) {
      _Unwind_Resume(a1);
    }
  }
}

uint64_t sub_10047EBC4(uint64_t a1, void *a2, uint64_t a3, _OWORD *a4)
{
  *(void *)a1 = off_101AB2248;
  uint64_t v7 = (void *)(a1 + 8);
  BOOL v8 = (std::__shared_weak_count *)a2[1];
  v10[0] = *a2;
  v10[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10132B1BC(v7, v10);
  if (v8) {
    sub_10004D2C8(v8);
  }
  *(void *)a1 = off_1019D04E8;
  sub_1000C6BDC((uint64_t *)(a1 + 32), a3);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  sub_10047F114((void *)(a1 + 56), *(void *)(a3 + 24), *(void *)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - *(void *)(a3 + 24)) >> 3));
  *(_OWORD *)(a1 + 80) = *a4;
  return a1;
}

void sub_10047ECAC(_Unwind_Exception *a1)
{
  sub_10005CD2C(v2, *(char **)(v1 + 40));
  if (*(void *)(v1 + 16)) {
    sub_10004D2C8(*(std::__shared_weak_count **)(v1 + 16));
  }
  _Unwind_Resume(a1);
}

void sub_10047ECDC()
{
  if (!v0) {
    JUMPOUT(0x10047ECD4);
  }
  JUMPOUT(0x10047ECCCLL);
}

void sub_10047ECE8(uint64_t a1@<X0>, os_log_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v19 = 0;
  unint64_t v20 = 0;
  unint64_t v21 = 0;
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = *(void *)(a1 + 64);
  if (v3 == v4)
  {
LABEL_36:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    goto LABEL_37;
  }
  __int16 v18 = a3;
  unint64_t v5 = 0;
  do
  {
    int v6 = *(void **)(v3 + 24);
    if (v6 != (void *)(v3 + 32))
    {
      while (1)
      {
        uint64_t v7 = 0;
        int v8 = *((char *)v6 + 55);
        unsigned int v9 = v8 >= 0 ? (char *)*((unsigned __int8 *)v6 + 55) : (char *)v6[5];
        uint64_t v10 = v8 >= 0 ? v6 + 4 : (void *)v6[4];
        while ((&off_1019D0500)[v7 + 1] != v9 || memcmp((&off_1019D0500)[v7], v10, (size_t)v9))
        {
          v7 += 2;
          if (v7 == 8)
          {
            goto LABEL_15;
          }
        }
        unsigned int v11 = &(&off_1019D0500)[v7];
LABEL_15:
        if ((char *)v11 - (char *)&off_1019D0500 != 64) {
          break;
        }
        BOOL v12 = (void *)v6[1];
        if (v12)
        {
          do
          {
            BOOL v13 = v12;
            BOOL v12 = (void *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            BOOL v13 = (void *)v6[2];
            BOOL v14 = *v13 == (void)v6;
            int v6 = v13;
          }
          while (!v14);
        }
        int v6 = v13;
        if (v13 == (void *)(v3 + 32)) {
          goto LABEL_30;
        }
      }
      if (v5 >= v21)
      {
        unint64_t v5 = sub_100048008(&v19, (long long *)v3);
      }
      else
      {
        if (*(char *)(v3 + 23) < 0)
        {
          sub_10004FC84((unsigned char *)v5, *(void **)v3, *(void *)(v3 + 8));
        }
        else
        {
          long long v15 = *(_OWORD *)v3;
          *(void *)(v5 + 16) = *(void *)(v3 + 16);
          *(_OWORD *)unint64_t v5 = v15;
        }
        v5 += 24;
      }
      unint64_t v20 = v5;
    }
LABEL_30:
    v3 += 56;
  }
  while (v3 != v4);
  if (v19 == v5)
  {
    BOOL v16 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I No access control servers found", buf, 2u);
    }
    a3 = v18;
    goto LABEL_36;
  }
  void *v18 = v19;
  v18[1] = v5;
  v18[2] = v21;
  unint64_t v20 = 0;
  unint64_t v21 = 0;
  uint64_t v19 = 0;
LABEL_37:
  *(void *)long long buf = &v19;
  sub_100047F64((void ***)buf);
}

void sub_10047EEF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void **a15)
{
  a15 = (void **)&a12;
  sub_100047F64(&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_10047EF18(uint64_t a1, os_log_t *a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v7 = 0;
  uint64_t v2 = *(void *)(a1 + 88);
  if (v2 <= 0)
  {
    uint64_t v4 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      unsigned int v9 = "AccessControl.xml";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Invalid validity of %s xml", buf, 0xCu);
    }
    return 1;
  }
  else
  {
    BOOL v3 = sub_10132B248(a1 + 8, v2, (uint64_t)__p);
    if (SHIBYTE(v7) < 0) {
      operator delete(__p[0]);
    }
  }
  return v3;
}

void sub_10047EFFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10047F018(uint64_t a1)
{
  *(void *)a1 = off_1019D04E8;
  uint64_t v2 = a1 + 32;
  unint64_t v5 = (void **)(a1 + 56);
  sub_10020F7F4(&v5);
  sub_10005CD2C(v2, *(char **)(a1 + 40));
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_10047F08C(uint64_t a1)
{
  *(void *)a1 = off_1019D04E8;
  uint64_t v2 = a1 + 32;
  uint64_t v4 = (void **)(a1 + 56);
  sub_10020F7F4(&v4);
  sub_10005CD2C(v2, *(char **)(a1 + 40));
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  operator delete();
}

void *sub_10047F114(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    int v6 = result;
    sub_10047F19C(result, a4);
    __n128 result = (void *)sub_10047F20C((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_10047F17C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_10020F7F4(&a9);
  _Unwind_Resume(a1);
}

char *sub_10047F19C(void *a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    sub_10047F1F4();
  }
  __n128 result = (char *)sub_100341ECC((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[56 * v4];
  return result;
}

void sub_10047F1F4()
{
}

uint64_t sub_10047F20C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_10047F290((void *)(a4 + v7), (long long *)(a2 + v7));
      v7 += 56;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_10047F26C(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 56;
    do
    {
      sub_10020F878(v4 + v2);
      v2 -= 56;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10047F290(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  sub_1000C6BDC(__dst + 3, (uint64_t)a2 + 24);
  *((unsigned char *)__dst + 48) = *((unsigned char *)a2 + 48);
  return __dst;
}

void sub_10047F2F4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void VinylController::maybe_create(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  if (*(void *)a1 && capabilities::ct::supportedVinylSlotCount(a1))
  {
    uint64_t v5 = 0;
    int v6 = 0;
    (*(void (**)(Registry **__return_ptr))(**(void **)a1 + 72))(&v7);
    Registry::getCommandDriversFactory((uint64_t *)&__p, v7);
    (*(void (**)(uint64_t *__return_ptr))(*(void *)__p + 224))(&v5);
    if (v10) {
      sub_10004D2C8(v10);
    }
    if (v8) {
      sub_10004D2C8(v8);
    }
    if (v5)
    {
      uint64_t v5 = 0;
      int v6 = 0;
      uint64_t v4 = *((void *)a1 + 1);
      if (v4) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
      }
      operator new();
    }
    *a2 = 0;
    a2[1] = 0;
    if (v6) {
      sub_10004D2C8(v6);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_10047F978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a15) {
    (*(void (**)(uint64_t))(*(void *)a15 + 8))(a15);
  }
  if (a22) {
    sub_10004D2C8(a22);
  }
  sub_10004D2C8(v22);
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(a1);
}

void sub_10047F9F4(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10048E0D0);
  __cxa_rethrow();
}

void sub_10047FA1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a12)
  {
    sub_10004D2C8(a12);
    sub_10004D2C8(a12);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(a1);
}

void sub_10047FC98(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = *(_DWORD *)(v1 + 224);
  if (v2 == 1)
  {
    int v3 = *(_DWORD *)(v1 + 232);
    int v64 = v3;
    (*(void (**)(dispatch_object_t *__return_ptr))(**(void **)(v1 + 80) + 72))(&object);
    uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
    uint64_t v60 = *(const char **)(v1 + 8);
    if (!v4 || (uint64_t v5 = std::__shared_weak_count::lock(v4), (v61 = v5) == 0)) {
      sub_100088B9C();
    }
    int v6 = v5;
    sub_100490398((std::__shared_weak_count **)&v56, &object, *(NSObject **)(v1 + 24), (uint64_t *)(v1 + 80), (unsigned int *)&v64, (void *)(v1 + 64), (uint64_t *)(v1 + 96), (uint64_t *)&v60);
    *(_DWORD *)int v65 = v3;
    *(_OWORD *)&v65[8] = v56;
    sub_10049068C((uint64_t *)(v1 + 160), v3, (uint64_t)v65);
    if (*(void *)&v65[16]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v65[16]);
    }
    sub_10004D2C8(v6);
    if (v63) {
      sub_10004D2C8(v63);
    }
  }
  else if (v2 >= 1)
  {
    int v7 = 0;
    do
    {
      int v8 = VinylSlotIdFromInt(++v7);
      int v64 = v8;
      (*(void (**)(dispatch_object_t *__return_ptr))(**(void **)(v1 + 80) + 72))(&object);
      uint64_t v9 = *(std::__shared_weak_count **)(v1 + 16);
      uint64_t v60 = *(const char **)(v1 + 8);
      if (!v9 || (uint64_t v10 = std::__shared_weak_count::lock(v9), (v61 = v10) == 0)) {
        sub_100088B9C();
      }
      unsigned int v11 = v10;
      sub_100490398((std::__shared_weak_count **)&v56, &object, *(NSObject **)(v1 + 24), (uint64_t *)(v1 + 80), (unsigned int *)&v64, (void *)(v1 + 64), (uint64_t *)(v1 + 96), (uint64_t *)&v60);
      *(_DWORD *)int v65 = v8;
      *(_OWORD *)&v65[8] = v56;
      sub_10049068C((uint64_t *)(v1 + 160), v8, (uint64_t)v65);
      if (*(void *)&v65[16]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v65[16]);
      }
      sub_10004D2C8(v11);
      if (v63) {
        sub_10004D2C8(v63);
      }
    }
    while (v7 < *(_DWORD *)(v1 + 224));
  }
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(v1 + 80) + 72))(v65);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)v65);
  BOOL v13 = ServiceMap;
  if (v14 < 0)
  {
    long long v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      uint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v56 = v14;
  __int16 v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)&v56);
  if (v18)
  {
    uint64_t v20 = v18[3];
    uint64_t v19 = (std::__shared_weak_count *)v18[4];
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v13);
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v19);
      char v21 = 0;
      goto LABEL_25;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  std::mutex::unlock(v13);
  uint64_t v19 = 0;
  char v21 = 1;
LABEL_25:
  if (*(void *)&v65[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v65[8]);
  }
  if (v20 && (*(unsigned int (**)(uint64_t))(*(void *)v20 + 32))(v20))
  {
    long long v56 = 0uLL;
    uint64_t v22 = *(std::__shared_weak_count **)(v1 + 16);
    if (!v22
      || (uint64_t v23 = *(void *)(v1 + 8), v24 = std::__shared_weak_count::lock(v22), (*(void *)&v65[8] = v24) == 0))
    {
      sub_100088B9C();
    }
    if (v23)
    {
      *(void *)&long long v56 = v23 + 48;
      *((void *)&v56 + 1) = v24;
      uint64_t v25 = (long long *)v65;
    }
    else
    {
      uint64_t v25 = &v56;
    }
    *(void *)uint64_t v25 = 0;
    *((void *)v25 + 1) = 0;
    if (*(void *)&v65[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v65[8]);
    }
    (*(void (**)(dispatch_object_t *__return_ptr))(**(void **)(v1 + 80) + 72))(&object);
    uint64_t v26 = (std::mutex *)Registry::getServiceMap((Registry *)object);
    uint64_t v27 = v26;
    uint64_t v28 = "18VinylTestXpcServer";
    if (((unint64_t)"18VinylTestXpcServer" & 0x8000000000000000) != 0)
    {
      uint64_t v29 = (unsigned __int8 *)((unint64_t)"18VinylTestXpcServer" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v30 = 5381;
      do
      {
        uint64_t v28 = (const char *)v30;
        unsigned int v31 = *v29++;
        uint64_t v30 = (33 * v30) ^ v31;
      }
      while (v31);
    }
    std::mutex::lock(v26);
    long long v32 = v56;
    *(_OWORD *)int v65 = v56;
    if (*((void *)&v56 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v56 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v60 = v28;
    uint64_t v33 = v27 + 1;
    if ((void)v32)
    {
      sub_100136784((uint64_t)v33, (unint64_t *)&v60, &v60, (uint64_t *)v65);
      char v35 = v34 & 1;
      char v36 = *(std::__shared_weak_count **)&v65[8];
      if (!*(void *)&v65[8])
      {
LABEL_44:
        std::mutex::unlock(v27);
        if ((v35 & 1) == 0)
        {
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "The given type is already in the map!");
        }
        if (v63) {
          sub_10004D2C8(v63);
        }
        if (*((void *)&v32 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v32 + 1));
        }
        goto LABEL_49;
      }
    }
    else
    {
      sub_100136C98(v33, (unint64_t *)&v60);
      char v35 = 1;
      char v36 = (std::__shared_weak_count *)*((void *)&v32 + 1);
      if (!*((void *)&v32 + 1)) {
        goto LABEL_44;
      }
    }
    sub_10004D2C8(v36);
    goto LABEL_44;
  }
LABEL_49:
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(v1 + 80) + 72))(v65);
  sub_1004EF288((Registry **)v65);
  if (*(void *)&v65[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v65[8]);
  }
  uint64_t v37 = *(std::__shared_weak_count **)(v1 + 16);
  if (!v37 || (v38 = *(std::__shared_weak_count **)(v1 + 8), (uint64_t v39 = std::__shared_weak_count::lock(v37)) == 0)) {
    sub_100088B9C();
  }
  int v40 = v39;
  atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v39);
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(v1 + 80) + 72))(v65);
  uint64_t v41 = (std::mutex *)Registry::getServiceMap(*(Registry **)v65);
  uint64_t v42 = v41;
  if (v43 < 0)
  {
    uint64_t v44 = (unsigned __int8 *)(v43 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v45 = 5381;
    do
    {
      uint64_t v43 = v45;
      unsigned int v46 = *v44++;
      uint64_t v45 = (33 * v45) ^ v46;
    }
    while (v46);
  }
  std::mutex::lock(v41);
  *(void *)&long long v56 = v43;
  uint64_t v47 = sub_10004D37C(&v42[1].__m_.__sig, (unint64_t *)&v56);
  if (v47)
  {
    uint64_t v48 = v47[3];
    uint64_t v49 = (std::__shared_weak_count *)v47[4];
    if (v49)
    {
      atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v42);
      atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v49);
      char v50 = 0;
      goto LABEL_63;
    }
  }
  else
  {
    uint64_t v48 = 0;
  }
  std::mutex::unlock(v42);
  uint64_t v49 = 0;
  char v50 = 1;
LABEL_63:
  if (*(void *)&v65[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v65[8]);
  }
  if (v48)
  {
    atomic_fetch_add_explicit(&v40->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v51 = *(NSObject **)(v1 + 24);
    if (v51) {
      dispatch_retain(*(dispatch_object_t *)(v1 + 24));
    }
    *(void *)&long long v56 = _NSConcreteStackBlock;
    *((void *)&v56 + 1) = 0x40000000;
    int v57 = sub_1004812A8;
    uint64_t v58 = &unk_1019D09D0;
    uint64_t v59 = v1;
    if (v51)
    {
      int v52 = _Block_copy(&v56);
      uint64_t v53 = v52;
      dispatch_object_t object = v51;
      *(void *)int v65 = _NSConcreteStackBlock;
      *(void *)&v65[8] = 1174405120;
      *(void *)&v65[16] = sub_100490754;
      unsigned int v66 = &unk_1019D19C0;
      int v67 = v38;
      unint64_t v68 = v40;
      atomic_fetch_add_explicit(&v40->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      if (v52) {
        int v54 = _Block_copy(v52);
      }
      else {
        int v54 = 0;
      }
      aBlock = v54;
      (*(void (**)(uint64_t, const char *, uint64_t, dispatch_object_t *, unsigned char *))(*(void *)v48 + 40))(v48, "commCenterVinylInfo", 1, &object, v65);
      if (object) {
        dispatch_release(object);
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (v68) {
        std::__shared_weak_count::__release_weak(v68);
      }
      if (v53) {
        _Block_release(v53);
      }
    }
    std::__shared_weak_count::__release_weak(v40);
  }
  if ((v50 & 1) == 0) {
    sub_10004D2C8(v49);
  }
  *(void *)int v65 = _NSConcreteStackBlock;
  *(void *)&v65[8] = 1174405120;
  *(void *)&v65[16] = sub_10048132C;
  unsigned int v66 = &unk_1019D0A10;
  int v67 = (std::__shared_weak_count *)v1;
  unint64_t v68 = v38;
  aBlock = v40;
  atomic_fetch_add_explicit(&v40->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  VinylCommandDriver::setDriverReadyCallback();
  if (aBlock) {
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)aBlock);
  }
  std::__shared_weak_count::__release_weak(v40);
}

void sub_100480428(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, dispatch_object_t object, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,void *aBlock)
{
  __cxa_free_exception(v27);
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100480590(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1004805AC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void *sub_1004805BC(uint64_t a1)
{
  int v3 = (void **)(a1 + 32);
  sub_1000C56F4(&v3);
  return sub_10048DCB8((void *)a1);
}

uint64_t sub_1004805FC(uint64_t a1)
{
  *(void *)a1 = off_1019D05C8;
  *(void *)(a1 + 48) = off_1019D07F8;
  *(void *)(a1 + 56) = &off_1019D0908;
  sub_10048DC44((uint64_t *)(a1 + 440));
  sub_10005CD2C(a1 + 416, *(char **)(a1 + 424));
  sub_1000C752C((void *)(a1 + 384));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 376);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(void *)(a1 + 360);
  *(void *)(a1 + 360) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 352);
  *(void *)(a1 + 352) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 344);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v14 = (void **)(a1 + 296);
  sub_1000C56F4(&v14);
  sub_10048DCB8((void *)(a1 + 264));
  uint64_t v14 = (void **)(a1 + 240);
  sub_1000C56F4(&v14);
  uint64_t v14 = (void **)(a1 + 200);
  sub_10008A88C(&v14);
  int v6 = *(std::__shared_weak_count **)(a1 + 192);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_100119D90(*(void **)(a1 + 168));
  int v7 = *(std::__shared_weak_count **)(a1 + 152);
  if (v7) {
    sub_10004D2C8(v7);
  }
  int v8 = *(std::__shared_weak_count **)(a1 + 136);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 120);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 104);
  if (v10) {
    sub_10004D2C8(v10);
  }
  unsigned int v11 = *(std::__shared_weak_count **)(a1 + 88);
  if (v11) {
    sub_10004D2C8(v11);
  }
  BOOL v12 = *(std::__shared_weak_count **)(a1 + 72);
  if (v12) {
    sub_10004D2C8(v12);
  }
  VinylController::~VinylController((VinylController *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_1004807D0(uint64_t a1)
{
  return sub_1004805FC(a1 - 48);
}

uint64_t sub_1004807D8(uint64_t a1)
{
  return sub_1004805FC(a1 - 56);
}

void sub_1004807E0(uint64_t a1)
{
  sub_1004805FC(a1);

  operator delete();
}

void sub_100480818(uint64_t a1)
{
  sub_1004805FC(a1 - 48);

  operator delete();
}

void sub_100480854(uint64_t a1)
{
  sub_1004805FC(a1 - 56);

  operator delete();
}

void *sub_100480890(void *result, uint64_t *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = result[4];
  uint64_t v6 = result[5];
  uint64_t v4 = (uint64_t)(result + 4);
  uint64_t v7 = *a2;
  if (v6 - v5 == a2[1] - *a2)
  {
    while (v5 != v6)
    {
      __n128 result = (void *)VinylInfo::operator==();
      if (!result) {
        goto LABEL_5;
      }
      v5 += 88;
      v7 += 88;
    }
  }
  else
  {
LABEL_5:
    if ((uint64_t *)v4 != a2) {
      sub_1003DB294(v4, *a2, a2[1], 0x2E8BA2E8BA2E8BA3 * ((a2[1] - *a2) >> 3));
    }
    __n128 result = (void *)v3[3];
    if (result)
    {
      int v8 = *(uint64_t (**)(void))(*result + 48);
      return (void *)v8();
    }
  }
  return result;
}

void sub_100480984(const VinylInfo **a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  uint64_t v7 = *a1;
  uint64_t v6 = a1[1];
  while (v7 != v6)
  {
    write_rest_value(v7);
    xpc_array_append_value(v5, value);
    xpc_release(value);
    uint64_t v7 = (const VinylInfo *)((char *)v7 + 88);
  }
  *a2 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v5);
}

void sub_100480A94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

__n128 sub_100480AC0(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = *(uint64_t **)(a2 + 168);
  xpc_object_t v5 = (uint64_t *)(a2 + 168);
  xpc_object_t v4 = v6;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  if (v6)
  {
    uint64_t v7 = v5;
    int v8 = v4;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < a3;
      if (v9 >= a3) {
        unsigned int v11 = (uint64_t **)v8;
      }
      else {
        unsigned int v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        uint64_t v7 = v8;
      }
      int v8 = *v11;
    }
    while (*v11);
    if (v7 != v5 && *((_DWORD *)v7 + 8) <= a3)
    {
      uint64_t v12 = *(void *)(*sub_1000389F8(v4, a3) + 160);
      if (v12)
      {
        __n128 result = *(__n128 *)(v12 + 8);
        *(__n128 *)(a1 + 1) = result;
        *(unsigned char *)a1 = 1;
      }
    }
  }
  return result;
}

void sub_100480B4C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, uint64_t a6)
{
  uint64_t v25 = a2;
  uint64_t v26 = a3;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  sub_1004852FC(&v18, a1, a2, a3);
  uint64_t v10 = v18;
  unsigned int v11 = *(NSObject **)(a1 + 40);
  if (v18)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(*a4 + 185)) {
        int v12 = *(unsigned __int8 *)(*a4 + 184);
      }
      else {
        int v12 = -1;
      }
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I fRegulatoryRestrictionActive = %d", buf, 8u);
    }
    BOOL v13 = (std::__shared_weak_count *)a4[1];
    uint64_t v15 = *a4;
    uint64_t v16 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100D29EEC(v10, &v15, a5, a6);
    if (v16) {
      sub_10004D2C8(v16);
    }
  }
  else
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      sCardSerialNumberAsString();
      uint64_t v14 = v22 >= 0 ? buf : *(uint8_t **)buf;
      *(_DWORD *)uint64_t v23 = 136315138;
      uint64_t v24 = v14;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "CSN not found for fetch %s", v23, 0xCu);
      if (v22 < 0) {
        operator delete(*(void **)buf);
      }
    }
    __int16 v17 = 3074;
    v20[0] = 0;
    (*(void (**)(uint64_t, __int16 *, unsigned char *))(a6 + 16))(a6, &v17, v20);
    sub_1000C60A0(v20);
    LOBYTE(v17) = 0;
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
}

void sub_100480D2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, uint64_t a15, std::__shared_weak_count *a16, char a17)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100480D7C(void *result, int a2)
{
  if (a2 != 1)
  {
    uint64_t v2 = (uint64_t)result;
    if (*((unsigned char *)result + 329) == 1)
    {
      uint64_t v3 = result[5];
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Internet status available - sending pending receipts", buf, 2u);
      }
      uint64_t v4 = *(void *)(v2 + 240);
      uint64_t v5 = *(void *)(v2 + 248);
      if (v4 != v5)
      {
        uint64_t v6 = (uint64_t *)(v2 + 168);
        do
        {
          uint64_t v18 = 0;
          memset(v17, 0, sizeof(v17));
          long long v15 = 0u;
          *(_OWORD *)__n128 __p = 0u;
          *(_OWORD *)long long buf = 0u;
          sub_1000C5DA8((uint64_t)buf, v4);
          uint64_t v7 = *v6;
          if (*v6)
          {
            uint64_t v8 = v2 + 168;
            do
            {
              int v9 = *(_DWORD *)(v7 + 32);
              BOOL v10 = v9 < *(_DWORD *)&buf[4];
              if (v9 >= *(int *)&buf[4]) {
                unsigned int v11 = (uint64_t *)v7;
              }
              else {
                unsigned int v11 = (uint64_t *)(v7 + 8);
              }
              if (!v10) {
                uint64_t v8 = v7;
              }
              uint64_t v7 = *v11;
            }
            while (*v11);
            if ((uint64_t *)v8 != v6 && *(int *)&buf[4] >= *(_DWORD *)(v8 + 32)) {
              sub_100D259C0(*(void *)(v8 + 40));
            }
          }
          if ((_BYTE)v18)
          {
            int v12 = (void **)v17 + 1;
            sub_1000C57C8(&v12);
          }
          if (SBYTE7(v17[0]) < 0) {
            operator delete(__p[0]);
          }
          v4 += 88;
        }
        while (v4 != v5);
      }
      v13[0] = off_1019D1900;
      v13[3] = v13;
      sub_100480F48(v2, 0, (uint64_t)v13);
      return sub_1000DBADC(v13);
    }
  }
  return result;
}

void sub_100480F1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000DBADC(va);
  _Unwind_Resume(a1);
}

void sub_100480F48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 144);
  if (!v4)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    sub_10033F214(a3, 0);
    return;
  }
  if ((a2 & 1) == 0 && *(unsigned char *)(a1 + 329) != 1)
  {
    int v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I No internet. abort attestation", buf, 2u);
    }
    goto LABEL_24;
  }
  if (!*(unsigned char *)(a1 + 328))
  {
    BOOL v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Device is not activated. abort attestation", buf, 2u);
    }
    goto LABEL_24;
  }
  uint64_t v6 = *(void *)(a1 + 240);
  uint64_t v7 = *(void *)(a1 + 248);
  if (v6 != v7)
  {
    while (*(_DWORD *)v6 != 2)
    {
      v6 += 88;
      if (v6 == v7) {
        goto LABEL_19;
      }
    }
  }
  if (v6 == v7)
  {
LABEL_19:
    unsigned int v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I non-vinyl capable device. abort attestation", buf, 2u);
    }
LABEL_24:
    sub_10033F214(a3, 0);
    return;
  }
  if ((a2 & 1) == 0)
  {
    unsigned int v8 = *(unsigned __int8 *)(a1 + 229);
    if (v8 >= 5)
    {
      int v9 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I reached max prefetch attempts. abort attestation", buf, 2u);
      }
      goto LABEL_24;
    }
    *(unsigned char *)(a1 + 229) = v8 + 1;
  }
  uint64_t v13 = *(void *)(v6 + 16);
  uint64_t v14 = *(void *)(v6 + 24);
  sub_10033ECA0((uint64_t)v19, a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v4 + 24))(v4, v13, v14, a2, v19);
  sub_1000DBADC(v19);
}

void sub_100481224(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004812A8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  (*(void (**)(Registry **__return_ptr))(**(void **)(v1 + 80) + 72))(&v2);
  sub_1004F0EC8(&v2, (uint64_t *)(v1 + 240));
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100481314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10048132C(void *a1, char a2, uint64_t a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    uint64_t v7 = (void *)a1[4];
    unsigned int v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      int v9 = v8;
      if (a1[5])
      {
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 0x40000000;
        v15[2] = sub_100481480;
        v15[3] = &unk_1019D09F0;
        char v16 = a2;
        v15[4] = v7;
        v15[5] = a3;
        BOOL v10 = (std::__shared_weak_count *)v7[2];
        if (!v10 || (v11 = v7[1], (int v12 = std::__shared_weak_count::lock(v10)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v13 = v12;
        uint64_t v14 = v7[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_10048E42C;
        block[3] = &unk_1019D14E0;
        block[5] = v11;
        uint64_t v18 = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v15;
        dispatch_async(v14, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v13);
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_100481480(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 48);
  if (*(unsigned char *)(a1 + 48))
  {
    if (v3 == 2)
    {
      long long v15 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v33[0] = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Baseband signalled it's ready!", (uint8_t *)v33, 2u);
      }
      unint64_t v16 = *(void *)(a1 + 40);
      uint64_t v17 = (uint64_t **)(v2 + 168);
      if ((_BYTE)v16)
      {
        if (*v17)
        {
          unint64_t v18 = HIDWORD(v16);
          uint64_t v19 = (uint64_t *)(v2 + 168);
          uint64_t v20 = *v17;
          do
          {
            int v21 = *((_DWORD *)v20 + 8);
            BOOL v22 = v21 < (int)v18;
            if (v21 >= (int)v18) {
              uint64_t v23 = v20;
            }
            else {
              uint64_t v23 = v20 + 1;
            }
            if (!v22) {
              uint64_t v19 = v20;
            }
            uint64_t v20 = (uint64_t *)*v23;
          }
          while (*v23);
          if (v19 != (uint64_t *)v17 && *((_DWORD *)v19 + 8) <= (int)v18)
          {
            uint64_t v24 = *sub_1000389F8(*v17, v18);
            *(unsigned char *)(v24 + 336) = 1;
            sub_100D252D4(v24, 0);
          }
        }
      }
      else
      {
        uint64_t v29 = *(uint64_t ***)(v2 + 160);
        if (v29 != v17)
        {
          do
          {
            uint64_t v30 = (uint64_t)v29[5];
            *(unsigned char *)(v30 + 336) = 1;
            sub_100D252D4(v30, 0);
            unsigned int v31 = v29[1];
            if (v31)
            {
              do
              {
                long long v32 = (uint64_t **)v31;
                unsigned int v31 = (uint64_t *)*v31;
              }
              while (v31);
            }
            else
            {
              do
              {
                long long v32 = (uint64_t **)v29[2];
                BOOL v28 = *v32 == (uint64_t *)v29;
                uint64_t v29 = v32;
              }
              while (!v28);
            }
            uint64_t v29 = v32;
          }
          while (v32 != v17);
        }
      }
    }
    else if (v3 == 1)
    {
      uint64_t v4 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Baseband signalled it's initialized; waiting for 'ready' to proceed",
          buf,
          2u);
      }
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)char v34 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Baseband signalled it's no longer ready", v34, 2u);
    }
    unint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = (uint64_t **)(v2 + 168);
    if ((_BYTE)v6)
    {
      if (*v7)
      {
        unint64_t v8 = HIDWORD(v6);
        int v9 = (uint64_t *)(v2 + 168);
        BOOL v10 = *v7;
        do
        {
          int v11 = *((_DWORD *)v10 + 8);
          BOOL v12 = v11 < (int)v8;
          if (v11 >= (int)v8) {
            uint64_t v13 = v10;
          }
          else {
            uint64_t v13 = v10 + 1;
          }
          if (!v12) {
            int v9 = v10;
          }
          BOOL v10 = (uint64_t *)*v13;
        }
        while (*v13);
        if (v9 != (uint64_t *)v7 && *((_DWORD *)v9 + 8) <= (int)v8)
        {
          uint64_t v14 = sub_1000389F8(*v7, v8);
          sub_100D228D4(*v14);
        }
      }
    }
    else
    {
      uint64_t v25 = *(uint64_t ***)(v2 + 160);
      if (v25 != v7)
      {
        do
        {
          sub_100D228D4((uint64_t)v25[5]);
          uint64_t v26 = v25[1];
          if (v26)
          {
            do
            {
              uint64_t v27 = (uint64_t **)v26;
              uint64_t v26 = (uint64_t *)*v26;
            }
            while (v26);
          }
          else
          {
            do
            {
              uint64_t v27 = (uint64_t **)v25[2];
              BOOL v28 = *v27 == (uint64_t *)v25;
              uint64_t v25 = v27;
            }
            while (!v28);
          }
          uint64_t v25 = v27;
        }
        while (v27 != v7);
      }
    }
  }
}

uint64_t sub_100481700(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10048171C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_10048172C(uint64_t a1, int a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_10048189C;
  void v5[3] = &unk_1019D0A40;
  void v5[4] = a1;
  int v6 = a2;
  uint64_t v7 = v5;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_1004908E8;
  v8[3] = &unk_1019D19F0;
  void v8[4] = a1 + 8;
  v8[5] = &v7;
  int v9 = v8;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    unsigned int v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    BOOL v12 = sub_100490938;
    uint64_t v13 = &unk_1019D1A30;
    uint64_t v14 = &v16;
    long long v15 = &v9;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    unsigned int v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    BOOL v12 = sub_1004908FC;
    uint64_t v13 = &unk_1019D1A10;
    uint64_t v14 = &v16;
    long long v15 = &v9;
    dispatch_sync(v2, &block);
  }
  return v16;
}

uint64_t *sub_10048189C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = (uint64_t *)(v2 + 168);
  __n128 result = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(a1 + 40);
    uint64_t v7 = v4;
    unint64_t v8 = result;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        uint64_t v7 = v8;
      }
      unint64_t v8 = *v11;
    }
    while (*v11);
    if (v7 == v4 || *((_DWORD *)v7 + 8) > v6) {
      return 0;
    }
    else {
      return (uint64_t *)*(unsigned int *)(*sub_1000389F8(result, v6) + 152);
    }
  }
  return result;
}

void sub_100481910(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      int v6 = v5;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v5);
    }
    else
    {
      int v6 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    }
  }
  else
  {
    int v6 = 0;
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100481B04(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100481B20(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100481C20(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100481D8C;
  void v5[3] = &unk_1019D0A60;
  void v5[4] = a1;
  int v6 = a2;
  uint64_t v7 = v5;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_100490E58;
  v8[3] = &unk_1019D1A50;
  void v8[4] = a1 + 8;
  v8[5] = &v7;
  int v9 = v8;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    BOOL v12 = sub_100490F18;
    uint64_t v13 = &unk_1019D1A90;
    uint64_t v14 = a3;
    long long v15 = &v9;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    BOOL v12 = sub_100490E6C;
    uint64_t v13 = &unk_1019D1A70;
    uint64_t v14 = a3;
    long long v15 = &v9;
    dispatch_sync(v3, &block);
  }
}

double sub_100481D8C@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)&double result = sub_100480AC0(a2, *(void *)(a1 + 32), *(_DWORD *)(a1 + 40)).n128_u64[0];
  return result;
}

void sub_100481D9C(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100481F88;
  void v5[3] = &unk_1019D0A80;
  void v5[4] = a1;
  int v6 = a2;
  uint64_t v7 = v5;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_100490FC4;
  v8[3] = &unk_1019D1AB0;
  void v8[4] = a1 + 8;
  v8[5] = &v7;
  int v9 = v8;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *(void *)(a3 + 496) = 0;
    *(_OWORD *)(a3 + 464) = 0u;
    *(_OWORD *)(a3 + 480) = 0u;
    *(_OWORD *)(a3 + 432) = 0u;
    *(_OWORD *)(a3 + 448) = 0u;
    *(_OWORD *)(a3 + 400) = 0u;
    *(_OWORD *)(a3 + 416) = 0u;
    *(_OWORD *)(a3 + 368) = 0u;
    *(_OWORD *)(a3 + 384) = 0u;
    *(_OWORD *)(a3 + 336) = 0u;
    *(_OWORD *)(a3 + 352) = 0u;
    *(_OWORD *)(a3 + 304) = 0u;
    *(_OWORD *)(a3 + 320) = 0u;
    *(_OWORD *)(a3 + 272) = 0u;
    *(_OWORD *)(a3 + 288) = 0u;
    *(_OWORD *)(a3 + 240) = 0u;
    *(_OWORD *)(a3 + 256) = 0u;
    *(_OWORD *)(a3 + 208) = 0u;
    *(_OWORD *)(a3 + 224) = 0u;
    *(_OWORD *)(a3 + 176) = 0u;
    *(_OWORD *)(a3 + 192) = 0u;
    *(_OWORD *)(a3 + 144) = 0u;
    *(_OWORD *)(a3 + 160) = 0u;
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    BOOL v12 = sub_1004910E8;
    uint64_t v13 = &unk_1019D1AF0;
    uint64_t v14 = a3;
    long long v15 = &v9;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *(void *)(a3 + 496) = 0;
    *(_OWORD *)(a3 + 464) = 0u;
    *(_OWORD *)(a3 + 480) = 0u;
    *(_OWORD *)(a3 + 432) = 0u;
    *(_OWORD *)(a3 + 448) = 0u;
    *(_OWORD *)(a3 + 400) = 0u;
    *(_OWORD *)(a3 + 416) = 0u;
    *(_OWORD *)(a3 + 368) = 0u;
    *(_OWORD *)(a3 + 384) = 0u;
    *(_OWORD *)(a3 + 336) = 0u;
    *(_OWORD *)(a3 + 352) = 0u;
    *(_OWORD *)(a3 + 304) = 0u;
    *(_OWORD *)(a3 + 320) = 0u;
    *(_OWORD *)(a3 + 272) = 0u;
    *(_OWORD *)(a3 + 288) = 0u;
    *(_OWORD *)(a3 + 240) = 0u;
    *(_OWORD *)(a3 + 256) = 0u;
    *(_OWORD *)(a3 + 208) = 0u;
    *(_OWORD *)(a3 + 224) = 0u;
    *(_OWORD *)(a3 + 176) = 0u;
    *(_OWORD *)(a3 + 192) = 0u;
    *(_OWORD *)(a3 + 144) = 0u;
    *(_OWORD *)(a3 + 160) = 0u;
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    BOOL v12 = sub_100490FD8;
    uint64_t v13 = &unk_1019D1AD0;
    uint64_t v14 = a3;
    long long v15 = &v9;
    dispatch_sync(v3, &block);
  }
}

void sub_100481F88(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(_DWORD *)(a1 + 40);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 208) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 240) = 0u;
  *(_OWORD *)(a2 + 256) = 0u;
  *(_OWORD *)(a2 + 272) = 0u;
  *(_OWORD *)(a2 + 288) = 0u;
  *(_OWORD *)(a2 + 304) = 0u;
  *(_OWORD *)(a2 + 320) = 0u;
  *(_OWORD *)(a2 + 336) = 0u;
  *(_OWORD *)(a2 + 352) = 0u;
  *(_OWORD *)(a2 + 368) = 0u;
  *(_OWORD *)(a2 + 384) = 0u;
  *(_OWORD *)(a2 + 400) = 0u;
  *(_OWORD *)(a2 + 416) = 0u;
  *(_OWORD *)(a2 + 432) = 0u;
  *(_OWORD *)(a2 + 448) = 0u;
  *(_OWORD *)(a2 + 464) = 0u;
  *(_OWORD *)(a2 + 480) = 0u;
  *(void *)(a2 + 496) = 0;
  uint64_t v7 = *(uint64_t **)(v3 + 168);
  int v6 = (uint64_t *)(v3 + 168);
  uint64_t v5 = v7;
  if (v7)
  {
    unint64_t v8 = v6;
    int v9 = v5;
    do
    {
      int v10 = *((_DWORD *)v9 + 8);
      BOOL v11 = v10 < v4;
      if (v10 >= v4) {
        BOOL v12 = (uint64_t **)v9;
      }
      else {
        BOOL v12 = (uint64_t **)(v9 + 1);
      }
      if (!v11) {
        unint64_t v8 = v9;
      }
      int v9 = *v12;
    }
    while (*v12);
    if (v8 != v6 && *((_DWORD *)v8 + 8) <= v4)
    {
      uint64_t v13 = sub_1000389F8(v5, v4);
      sub_100D29D94(*v13, (uint64_t)&v14);
      *(_OWORD *)a2 = v14;
      *(unsigned char *)(a2 + 16) = v15;
      sub_100179CB0(a2 + 24, &__p);
      sub_10048DF0C(a2 + 56, (uint64_t)v19);
      sub_10048DF0C(a2 + 280, (uint64_t)v20);
      if (v20[216]) {
        sub_1000C584C((uint64_t)v20);
      }
      if (v19[216]) {
        sub_1000C584C((uint64_t)v19);
      }
      if (v18)
      {
        if (v17 < 0) {
          operator delete((void *)__p.n128_u64[0]);
        }
      }
    }
  }
}

void sub_100482114(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100482170(uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_1004911F8;
  v7[3] = &unk_1019D1B10;
  v7[4] = a1 + 8;
  v7[5] = &v5;
  unint64_t v8 = v7;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0u;
    a3[1] = 0u;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    BOOL v11 = sub_100491334;
    BOOL v12 = &unk_1019D1B50;
    uint64_t v13 = a3;
    long long v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0u;
    a3[1] = 0u;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    BOOL v11 = sub_1004912CC;
    BOOL v12 = &unk_1019D1B30;
    uint64_t v13 = a3;
    long long v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

void sub_10048229C(uint64_t a1)
{
  uint64_t v3 = &stru_1019D0AC0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10049139C;
  block[3] = &unk_1019D1B70;
  block[4] = a1 + 8;
  block[5] = &v3;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8)) {
    dispatch_async_and_wait(v1, block);
  }
  else {
    dispatch_sync(v1, block);
  }
}

void sub_10048232C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 1174405120;
  v14[2] = sub_1004824B0;
  v14[3] = &unk_1019D0AE8;
  uint64_t v18 = a2;
  uint64_t v19 = a3;
  v14[5] = a1;
  __n128 __p = 0;
  unsigned int v16 = 0;
  uint64_t v17 = 0;
  sub_10005C928(&__p, *(const void **)a4, *(void *)(a4 + 8), *(void *)(a4 + 8) - *(void *)a4);
  v14[4] = a5;
  uint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (!v7 || (uint64_t v8 = a1[1], (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v10 = v9;
  BOOL v11 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v8;
  uint64_t v13 = v10;
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v14;
  dispatch_async(v11, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_10004D2C8(v10);
  if (__p)
  {
    unsigned int v16 = __p;
    operator delete(__p);
  }
}

void sub_1004824A4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1004824B0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  uint64_t v3 = *(void *)(a1 + 80);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v7 = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  sub_10005C928(&v7, *(const void **)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 56) - *(void *)(a1 + 48));
  uint64_t v5 = *(void (***)(void, void))(a1 + 32);
  uint64_t v13 = 0;
  long long v14 = 0;
  sub_1004852FC(&v13, v4, v2, v3);
  uint64_t v6 = v13;
  if (v13)
  {
    __n128 __p = 0;
    BOOL v11 = 0;
    BOOL v12 = 0;
    sub_10005C928(&__p, v7, (uint64_t)v8, v8 - (unsigned char *)v7);
    sub_100D2E02C(v6, (uint64_t)&__p, v5);
    if (__p)
    {
      BOOL v11 = __p;
      operator delete(__p);
    }
  }
  else
  {
    LOBYTE(__p) = 2;
    LOBYTE(v11) = 12;
    ((void (**)(void, void **))v5)[2](v5, &__p);
    if (__p == 1 && v11)
    {
      BOOL v12 = v11;
      operator delete(v11);
    }
    LOBYTE(__p) = 0;
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (v7)
  {
    uint64_t v8 = v7;
    operator delete(v7);
  }
}

void sub_1004825C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, void *__p, uint64_t a15)
{
  if (a13 == 1 && __p) {
    operator delete(__p);
  }
  uint64_t v17 = *(std::__shared_weak_count **)(v15 - 40);
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (a10) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100482630(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  uint64_t v2 = (void *)(a1 + 48);
  v2[2] = 0;
  return sub_10005C928(v2, *(const void **)(a2 + 48), *(void *)(a2 + 56), *(void *)(a2 + 56) - *(void *)(a2 + 48));
}

void sub_100482648(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void sub_100482660(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = 0;
  long long v11 = 0uLL;
  sub_10005C928(&v10[1], *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  v12[0] = 0;
  v12[1] = 0;
  uint64_t v13 = 0;
  sub_10005C928(v12, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v15 = 0;
  sub_10005C928(__p, *(const void **)a4, *(void *)(a4 + 8), *(void *)(a4 + 8) - *(void *)a4);
  sub_1004913B0((uint64_t)&v16, a5);
  uint64_t v9 = (std::__shared_weak_count *)a1[2];
  if (v9)
  {
    if (std::__shared_weak_count::lock(v9)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100482870(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1004828DC(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_1004829F4;
  v8[3] = &unk_1019D0B20;
  void v8[4] = a2;
  v8[5] = a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  uint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v4;
  uint64_t v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

void sub_1004829F4(uint64_t a1)
{
  uint64_t v1 = *(void (***)(void, void))(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  int v3 = (*(uint64_t (**)(void))(**(void **)(v2 + 80) + 80))(*(void *)(v2 + 80));
  if (v3)
  {
    int v4 = v3;
    uint64_t v7 = *(uint64_t **)(v2 + 168);
    uint64_t v6 = (uint64_t *)(v2 + 168);
    uint64_t v5 = v7;
    if (!v7) {
      goto LABEL_12;
    }
    uint64_t v8 = v6;
    uint64_t v9 = v5;
    do
    {
      int v10 = *((_DWORD *)v9 + 8);
      BOOL v11 = v10 < v4;
      if (v10 >= v4) {
        BOOL v12 = (uint64_t **)v9;
      }
      else {
        BOOL v12 = (uint64_t **)(v9 + 1);
      }
      if (!v11) {
        uint64_t v8 = v9;
      }
      uint64_t v9 = *v12;
    }
    while (*v12);
    if (v8 != v6 && v4 >= *((_DWORD *)v8 + 8))
    {
      uint64_t v13 = *sub_1000389F8(v5, v4);
      sub_100D2CCBC(v13, v1);
    }
    else
    {
LABEL_12:
      __int16 v14 = 258;
      ((void (**)(void, __int16 *))v1)[2](v1, &v14);
    }
  }
  else
  {
    __int16 v15 = 514;
    ((void (**)(void, __int16 *))v1)[2](v1, &v15);
  }
}

void sub_100482AEC(void *a1, uint64_t a2, uint64_t a3, long long *a4, long long *a5, uint64_t a6)
{
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 1174405120;
  v16[2] = sub_100482D20;
  v16[3] = &unk_1019D0B40;
  v16[4] = a1;
  v21[4] = a2;
  v21[5] = a3;
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(&v17, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v17 = *a4;
    uint64_t v18 = *((void *)a4 + 2);
  }
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long __p = *a5;
    uint64_t v20 = *((void *)a5 + 2);
  }
  sub_1000C7494((uint64_t)v21, a6);
  uint64_t v9 = (std::__shared_weak_count *)a1[2];
  if (!v9 || (uint64_t v10 = a1[1], (v11 = std::__shared_weak_count::lock(v9)) == 0)) {
    sub_100088B9C();
  }
  BOOL v12 = v11;
  uint64_t v13 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v10;
  __int16 v15 = v12;
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v16;
  dispatch_async(v13, block);
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_10004D2C8(v12);
  sub_1000C752C(v21);
  if (SHIBYTE(v20) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)v17);
  }
}

void sub_100482CD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100482D20(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = a1[15];
  uint64_t v4 = a1[16];
  sub_1000C7494((uint64_t)v6, (uint64_t)(a1 + 11));
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *, void *, void *))(*(void *)v2 + 224))(v2, v3, v4, a1 + 5, a1 + 8, v6);
  return sub_1000C752C(v6);
}

void sub_100482DD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C752C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100482DF0(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }
  if (*(char *)(a2 + 87) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 64), *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = v5;
  }
  return sub_1000C7494(a1 + 88, a2 + 88);
}

void sub_100482E88(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 63) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100482EBC(uint64_t a1)
{
  sub_1000C752C((void *)(a1 + 88));
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    operator delete(v2);
  }
}

void *sub_100482F1C(void *a1, char a2, char a3, uint64_t a4)
{
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 1174405120;
  v13[2] = sub_100483090;
  v13[3] = &unk_1019D0B70;
  void v13[4] = a1;
  char v15 = a2;
  char v16 = a3;
  sub_1000C7494((uint64_t)v14, a4);
  long long v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  uint64_t v9 = a1[3];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 1174405120;
  dispatch_object_t v11[2] = sub_10048E42C;
  v11[3] = &unk_1019D14E0;
  v11[5] = v6;
  BOOL v12 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  _DWORD v11[4] = v13;
  dispatch_async(v9, v11);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10004D2C8(v8);
  return sub_1000C752C(v14);
}

void sub_100483084(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void *sub_100483090(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  BOOL v2 = *(unsigned char *)(a1 + 72) != 0;
  BOOL v3 = *(unsigned char *)(a1 + 73) != 0;
  sub_1000C7494((uint64_t)v5, a1 + 40);
  (*(void (**)(uint64_t, BOOL, BOOL, void *))(*(void *)v1 + 240))(v1, v2, v3, v5);
  return sub_1000C752C(v5);
}

void sub_10048314C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C752C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100483168(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_1004832B8;
  v12[3] = &unk_1019D0BA8;
  v12[6] = a2;
  v12[7] = a3;
  _DWORD v12[4] = a4;
  v12[5] = a1;
  long long v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  uint64_t v9 = a1[3];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  void v10[2] = sub_10048E42C;
  v10[3] = &unk_1019D14E0;
  v10[5] = v6;
  BOOL v11 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  v10[4] = v12;
  dispatch_async(v9, v10);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v8);
}

void sub_1004832AC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1004832B8(void *a1)
{
  uint64_t v1 = a1[6];
  uint64_t v2 = a1[7];
  uint64_t v4 = a1[4];
  uint64_t v3 = a1[5];
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  sub_1004852FC(&v6, v3, v1, v2);
  if (v6) {
    sub_100D2DF00(v6, v4);
  }
  else {
    (*(void (**)(uint64_t, void))(v4 + 16))(v4, 0);
  }
  long long v5 = v7;
  if (v7)
  {
    sub_10004D2C8(v5);
  }
}

void sub_100483340(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100483358(void *a1, char a2, uint64_t a3, char a4)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  void v10[2] = sub_100483478;
  v10[3] = &unk_1019D0BD0;
  char v11 = a2;
  v10[4] = a3;
  v10[5] = a1;
  char v12 = a4;
  long long v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  uint64_t v9 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v6;
  __int16 v14 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v10;
  dispatch_async(v9, block);
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_10004D2C8(v8);
}

void sub_100483478(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 48);
  uint64_t v2 = *(void (***)(void, void))(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  int v4 = *(unsigned __int8 *)(a1 + 49);
  if (((***(uint64_t (****)(void))(v3 + 80))() & 1) == 0
    || (int v5 = (*(uint64_t (**)(void))(**(void **)(v3 + 80) + 80))(*(void *)(v3 + 80))) == 0)
  {
    v16[0] = 2;
    LOBYTE(v17) = 2;
    ((void (**)(void, char *))v2)[2](v2, v16);
LABEL_15:
    if (v16[0] == 1) {
      sub_100057D78(&v17);
    }
    return;
  }
  int v6 = v5;
  uint64_t v9 = *(uint64_t **)(v3 + 168);
  uint64_t v8 = (uint64_t *)(v3 + 168);
  uint64_t v7 = v9;
  if (!v9) {
    goto LABEL_13;
  }
  uint64_t v10 = v8;
  char v11 = v7;
  do
  {
    int v12 = *((_DWORD *)v11 + 8);
    BOOL v13 = v12 < v6;
    if (v12 >= v6) {
      __int16 v14 = (uint64_t **)v11;
    }
    else {
      __int16 v14 = (uint64_t **)(v11 + 1);
    }
    if (!v13) {
      uint64_t v10 = v11;
    }
    char v11 = *v14;
  }
  while (*v14);
  if (v10 == v8 || v6 < *((_DWORD *)v10 + 8))
  {
LABEL_13:
    v16[0] = 2;
    LOBYTE(v17) = 1;
    ((void (**)(void, char *))v2)[2](v2, v16);
    goto LABEL_15;
  }
  uint64_t v15 = *sub_1000389F8(v7, v6);

  sub_100D36F74(v15, v1 != 0, v2, v4 != 0);
}

void sub_100483640(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9)
{
  if (a9 == 1) {
    sub_100057D78(v9);
  }
  _Unwind_Resume(exception_object);
}

void sub_100483668(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 1174405120;
  v16[2] = sub_1004837E0;
  v16[3] = &unk_1019D0BF8;
  uint64_t v18 = a2;
  uint64_t v19 = a3;
  uint64_t v8 = *a4;
  uint64_t v7 = (std::__shared_weak_count *)a4[1];
  v16[6] = a1;
  v16[7] = v8;
  long long v17 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v16[4] = a5;
  void v16[5] = a6;
  uint64_t v9 = (std::__shared_weak_count *)a1[2];
  if (!v9 || (uint64_t v10 = a1[1], (v11 = std::__shared_weak_count::lock(v9)) == 0)) {
    sub_100088B9C();
  }
  int v12 = v11;
  BOOL v13 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v10;
  uint64_t v15 = v12;
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v16;
  dispatch_async(v13, block);
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_10004D2C8(v12);
  if (v17) {
    sub_10004D2C8(v17);
  }
}

void sub_1004837D4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1004837E0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(a1 + 48);
  int v4 = *(std::__shared_weak_count **)(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 72);
  v6[0] = *(void *)(a1 + 56);
  v6[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100480B4C(v3, v5, v2, v6, *(void **)(a1 + 32), *(void *)(a1 + 40));
  if (v4)
  {
    sub_10004D2C8(v4);
  }
}

void sub_100483860(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100483878(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 64);
  *(void *)(result + 56) = *(void *)(a2 + 56);
  *(void *)(result + 64) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100483894(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 64);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1004838A4(void *a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000;
  v13[2] = sub_1004839F8;
  v13[3] = &unk_1019D0C30;
  v13[6] = a2;
  v13[7] = a3;
  char v14 = a4;
  void v13[4] = a5;
  void v13[5] = a1;
  int v6 = (std::__shared_weak_count *)a1[2];
  if (!v6 || (v7 = a1[1], (uint64_t v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v9 = v8;
  uint64_t v10 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v7;
  int v12 = v9;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v13;
  dispatch_async(v10, block);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10004D2C8(v9);
}

void sub_1004839EC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1004839F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = *(unsigned __int8 *)(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  sub_1004852FC(&v7, v4, v1, v2);
  if (v7)
  {
    sub_100D2AC9C(v7, v3, v5);
  }
  else
  {
    __int16 v6 = 3074;
    (*(void (**)(uint64_t, __int16 *))(v5 + 16))(v5, &v6);
    LOBYTE(v6) = 0;
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_100483A78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100483A9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = a1;
  uint64_t v9 = a2;
  uint64_t v10 = a3;
  sub_1000C6BDC(&v11, a4);
  sub_1000C6AC0((uint64_t)&v12, a5);
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100483C34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100483C6C(void *a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5)
{
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 1174405120;
  v15[2] = sub_100483E18;
  v15[3] = &unk_1019D0C58;
  v15[5] = a1;
  uint64_t v20 = a2;
  uint64_t v21 = a3;
  long long v16 = *a4;
  if (*((char *)a4 + 39) < 0)
  {
    sub_10004FC84(&__p, *((void **)a4 + 2), *((void *)a4 + 3));
  }
  else
  {
    long long __p = a4[1];
    uint64_t v18 = *((void *)a4 + 4);
  }
  char v19 = *((unsigned char *)a4 + 40);
  v15[4] = a5;
  uint64_t v8 = (std::__shared_weak_count *)a1[2];
  if (!v8 || (v9 = a1[1], (uint64_t v10 = std::__shared_weak_count::lock(v8)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v11 = v10;
  uint64_t v12 = a1[3];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 1174405120;
  v13[2] = sub_10048E42C;
  v13[3] = &unk_1019D14E0;
  void v13[5] = v9;
  char v14 = v11;
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  void v13[4] = v15;
  dispatch_async(v12, v13);
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_10004D2C8(v11);
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)__p);
  }
}

void sub_100483E0C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100483E18(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 96);
  uint64_t v4 = *(void *)(a1 + 104);
  long long v10 = *(_OWORD *)(a1 + 48);
  if (*(char *)(a1 + 87) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 64), *(void *)(a1 + 72));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 64);
    uint64_t v12 = *(void *)(a1 + 80);
  }
  char v13 = *(unsigned char *)(a1 + 88);
  uint64_t v5 = *(void (***)(void, void))(a1 + 32);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  sub_1004852FC(&v8, v2, v3, v4);
  uint64_t v6 = v8;
  if (v8)
  {
    if ((*(unsigned int (**)(void))(**(void **)(v2 + 80) + 8))(*(void *)(v2 + 80)) == *(_DWORD *)(v6 + 80))
    {
      sub_100D305DC(v6, (uint64_t)&v10, v5);
      goto LABEL_10;
    }
    __int16 v7 = 2818;
    ((void (**)(void, __int16 *))v5)[2](v5, &v7);
  }
  else
  {
    __int16 v7 = 3074;
    ((void (**)(void, __int16 *))v5)[2](v5, &v7);
  }
  LOBYTE(v7) = 0;
LABEL_10:
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)__p);
  }
}

void sub_100483F84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100483FCC(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  double result = (void *)(a1 + 64);
  if (*(char *)(a2 + 87) < 0)
  {
    double result = sub_10004FC84(result, *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 64);
    result[2] = *(void *)(a2 + 80);
    *(_OWORD *)double result = v5;
  }
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(a2 + 88);
  return result;
}

void sub_10048402C(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
}

void sub_100484040(void *a1, uint64_t a2, uint64_t a3, long long *a4, long long *a5, uint64_t a6)
{
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 1174405120;
  v16[2] = sub_10048423C;
  v16[3] = &unk_1019D0C90;
  void v16[5] = a1;
  uint64_t v21 = a2;
  uint64_t v22 = a3;
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(&v17, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v17 = *a4;
    uint64_t v18 = *((void *)a4 + 2);
  }
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long __p = *a5;
    uint64_t v20 = *((void *)a5 + 2);
  }
  v16[4] = a6;
  uint64_t v9 = (std::__shared_weak_count *)a1[2];
  if (!v9 || (uint64_t v10 = a1[1], (v11 = std::__shared_weak_count::lock(v9)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v12 = v11;
  char v13 = a1[3];
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 1174405120;
  v14[2] = sub_10048E42C;
  v14[3] = &unk_1019D14E0;
  v14[5] = v10;
  uint64_t v15 = v12;
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  void v14[4] = v16;
  dispatch_async(v13, v14);
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_10004D2C8(v12);
  if (SHIBYTE(v20) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)v17);
  }
}

void sub_100484204(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10048423C(void *a1)
{
  uint64_t v2 = a1[12];
  uint64_t v3 = a1[13];
  long long v5 = (void (**)(void, void))a1[4];
  uint64_t v4 = a1[5];
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  sub_1004852FC(&v7, v4, v2, v3);
  if (v7)
  {
    sub_100D2F870(v7, (uint64_t)(a1 + 6), (uint64_t)(a1 + 9), v5);
  }
  else
  {
    __int16 v6 = 3074;
    ((void (**)(void, __int16 *))v5)[2](v5, &v6);
    LOBYTE(v6) = 0;
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_1004842C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_1004842E4(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 71) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 48), *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 48);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
    *(_OWORD *)(a1 + 48) = v4;
  }
  double result = (unsigned char *)(a1 + 72);
  if (*(char *)(a2 + 95) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 72), *(void *)(a2 + 80));
  }
  long long v6 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)double result = v6;
  return result;
}

void sub_10048436C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 71) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100484388(uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 48);
    operator delete(v2);
  }
}

void sub_1004843E0(void *a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000;
  v13[2] = sub_100484534;
  v13[3] = &unk_1019D0CC8;
  void v13[6] = a2;
  v13[7] = a3;
  char v14 = a4;
  void v13[4] = a5;
  void v13[5] = a1;
  long long v6 = (std::__shared_weak_count *)a1[2];
  if (!v6 || (v7 = a1[1], (uint64_t v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v9 = v8;
  uint64_t v10 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v7;
  uint64_t v12 = v9;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v13;
  dispatch_async(v10, block);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10004D2C8(v9);
}

void sub_100484528(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100484534(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  uint64_t v2 = *(void *)(a1 + 56);
  int v3 = *(unsigned __int8 *)(a1 + 64);
  long long v5 = *(void (***)(void, void))(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  sub_1004852FC(&v8, v4, v1, v2);
  if (v8)
  {
    sub_100D36F74(v8, v3 != 0, v5, 0);
  }
  else
  {
    v6[0] = 2;
    LOBYTE(v7) = 12;
    ((void (**)(void, char *))v5)[2](v5, v6);
    if (v6[0] == 1) {
      sub_100057D78(&v7);
    }
    v6[0] = 0;
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_1004845E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a9 == 1) {
    sub_100057D78(v12);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100484618(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_100484768;
  v12[3] = &unk_1019D0CF0;
  v12[6] = a2;
  v12[7] = a3;
  _DWORD v12[4] = a4;
  v12[5] = a1;
  long long v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  uint64_t v9 = a1[3];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  void v10[2] = sub_10048E42C;
  v10[3] = &unk_1019D14E0;
  v10[5] = v6;
  uint64_t v11 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  v10[4] = v12;
  dispatch_async(v9, v10);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v8);
}

void sub_10048475C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_100484768(void *a1)
{
  uint64_t v1 = a1[4];
  uint64_t v2 = a1[5];
  sub_1004852FC(&v7, v2, a1[6], a1[7]);
  uint64_t v3 = v7;
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v3)
  {
    sub_10048D930(v2);
    char v4 = 1;
    LOBYTE(v7) = 1;
  }
  else
  {
    long long v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v7) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Cannot find csn", (uint8_t *)&v7, 2u);
    }
    LOBYTE(v7) = 2;
    char v4 = 12;
  }
  BYTE1(v7) = v4;
  return (*(uint64_t (**)(uint64_t))(v1 + 16))(v1);
}

void sub_100484830(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_100484980;
  v12[3] = &unk_1019D0D18;
  v12[6] = a2;
  v12[7] = a3;
  _DWORD v12[4] = a4;
  v12[5] = a1;
  long long v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  uint64_t v9 = a1[3];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  void v10[2] = sub_10048E42C;
  v10[3] = &unk_1019D14E0;
  v10[5] = v6;
  uint64_t v11 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  v10[4] = v12;
  dispatch_async(v9, v10);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v8);
}

void sub_100484974(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100484980(void *a1)
{
  uint64_t v1 = a1[6];
  uint64_t v2 = a1[7];
  uint64_t v3 = a1[4];
  uint64_t v4 = a1[5];
  sub_1004862D0(v4);
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  sub_1004852FC(&v7, v4, v1, v2);
  if (v7)
  {
    sub_100D31A7C(v7, v3);
  }
  else
  {
    long long v5 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Cannot find csn", v6, 2u);
    }
    *(_WORD *)uint64_t v6 = 3074;
    (*(void (**)(uint64_t, uint8_t *))(v3 + 16))(v3, v6);
    v6[0] = 0;
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_100484A54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100484A78(uint64_t a1)
{
  (*(void (**)(Registry **__return_ptr))(**(void **)(a1 + 80) + 72))(&v31);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v31);
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    long long v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v27 = (Registry *)v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v27);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  if (v32) {
    sub_10004D2C8(v32);
  }
  if (!v10)
  {
LABEL_14:
    if (v11) {
      return;
    }
    goto LABEL_15;
  }
  if (*(_DWORD *)(a1 + 332) == 1)
  {
    sub_10005CD2C(a1 + 416, *(char **)(a1 + 424));
    *(void *)(a1 + 424) = 0;
    *(void *)(a1 + 432) = 0;
    *(void *)(a1 + 416) = a1 + 424;
    (*(void (**)(uint64_t, const __CFString *, void, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v10 + 16))(v10, @"VinylInstallRetryKey", 0, @"no_backup/com.apple.commcenter.vinyl", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    goto LABEL_14;
  }
  CFDictionaryRef theDict = 0;
  (*(void (**)(Registry **__return_ptr, uint64_t, const __CFString *, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v10 + 40))(&v31, v10, @"VinylInstallRetryKey", @"no_backup/com.apple.commcenter.vinyl", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_10004EFE4(&theDict, (CFTypeRef *)&v31);
  sub_1000577C4((const void **)&v31);
  if (theDict) {
    uint64_t v12 = sub_100080778;
  }
  else {
    uint64_t v12 = 0;
  }
  if (v12)
  {
    BOOL v28 = 0;
    uint64_t v29 = 0;
    uint64_t v27 = (Registry *)&v28;
    long long v32 = 0;
    uint64_t v33 = 0;
    context[1] = &v32;
    unsigned int v31 = (Registry *)&v32;
    context[0] = &v31;
    if (theDict)
    {
      CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_100491A98, context);
      char v14 = v27;
      char v13 = v28;
      uint64_t v27 = v31;
      BOOL v28 = v32;
      unsigned int v31 = v14;
      long long v32 = v13;
      uint64_t v15 = v29;
      uint64_t v29 = v33;
      uint64_t v33 = v15;
      p_shared_weak_owners = &v27;
      if (v29) {
        p_shared_weak_owners = (Registry **)&v28->__shared_weak_owners_;
      }
      *p_shared_weak_owners = (Registry *)&v28;
      BOOL v17 = v15 == 0;
      uint64_t v18 = &v31;
      if (!v17) {
        uint64_t v18 = (Registry **)&v13->__shared_weak_owners_;
      }
      std::__shared_weak_count *v18 = (Registry *)&v32;
    }
    else
    {
      char v13 = 0;
    }
    sub_10005CD2C((uint64_t)&v31, (char *)v13);
    char v19 = (char *)v28;
    uint64_t v23 = v27;
    uint64_t v24 = v28;
    uint64_t v25 = v29;
    if (v29)
    {
      v28->__shared_weak_owners_ = (uint64_t)&v24;
      uint64_t v27 = (Registry *)&v28;
      BOOL v28 = 0;
      uint64_t v29 = 0;
      char v19 = 0;
    }
    else
    {
      uint64_t v23 = (Registry *)&v24;
    }
    sub_10005CD2C((uint64_t)&v27, v19);
    uint64_t v20 = a1 + 424;
    sub_10005CD2C(a1 + 416, *(char **)(a1 + 424));
    uint64_t v21 = v24;
    *(void *)(a1 + 416) = v23;
    *(void *)(a1 + 424) = v21;
    uint64_t v22 = v25;
    *(void *)(a1 + 432) = v25;
    if (v22)
    {
      v21->__shared_weak_owners_ = v20;
      uint64_t v23 = (Registry *)&v24;
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      uint64_t v21 = 0;
    }
    else
    {
      *(void *)(a1 + 416) = v20;
    }
    sub_10005CD2C((uint64_t)&v23, (char *)v21);
  }
  sub_100057D78((const void **)&theDict);
  if ((v11 & 1) == 0) {
LABEL_15:
  }
    sub_10004D2C8(v9);
}

void sub_100484DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, char a13, char *a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, char *a19)
{
  sub_10005CD2C((uint64_t)&a18, a19);
  sub_10005CD2C((uint64_t)&a13, a14);
  sub_100057D78(&a12);
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v19);
  }
  _Unwind_Resume(a1);
}

void sub_100484E28(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v6 = a1[25];
  if (v5 - *a2 == a1[26] - v6)
  {
    while (v4 != v5)
    {
      if (!BasicSimInfo::operator==())
      {
        uint64_t v4 = *a2;
        uint64_t v5 = a2[1];
        goto LABEL_6;
      }
      v4 += 168;
      v6 += 168;
    }
  }
  else
  {
LABEL_6:
    while (v4 != v5)
    {
      if ((*(_DWORD *)(v4 + 64) - 3) < 2)
      {
        uint64_t v5 = v4;
        break;
      }
      v4 += 168;
    }
    uint64_t v7 = a1[25];
    uint64_t v8 = a1[26];
    if (v7 != v8)
    {
      uint64_t v9 = (uint64_t **)(a1 + 21);
      do
      {
        uint64_t v10 = *(int *)(v7 + 4);
        if (v10 <= 2 && *v9)
        {
          int v11 = dword_1014AC168[v10];
          uint64_t v12 = a1 + 21;
          char v13 = *v9;
          do
          {
            int v14 = *((_DWORD *)v13 + 8);
            BOOL v15 = v14 < v11;
            if (v14 >= v11) {
              long long v16 = v13;
            }
            else {
              long long v16 = v13 + 1;
            }
            if (!v15) {
              uint64_t v12 = v13;
            }
            char v13 = (uint64_t *)*v16;
          }
          while (*v16);
          if (v12 != (uint64_t *)v9 && v11 >= *((_DWORD *)v12 + 8))
          {
            if (v5 != a2[1] && *(_DWORD *)(v5 + 4) == v10 && *(_DWORD *)(v7 + 64) == 1)
            {
              BOOL v17 = a1[5];
              if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)char v19 = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "VinylCapability lost, skipping processing", v19, 2u);
              }
            }
            else
            {
              uint64_t v18 = sub_1000389F8(*v9, v11);
              sub_100D24B5C(*v18, v7);
            }
          }
        }
        v7 += 168;
      }
      while (v7 != v8);
    }
  }
}

uint64_t sub_100484FC8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 496)) {
    sub_1000C584C(a1 + 280);
  }
  if (*(unsigned char *)(a1 + 272)) {
    sub_1000C584C(a1 + 56);
  }
  if (*(unsigned char *)(a1 + 48) && *(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

VinylCommandDriver *sub_100485024(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 228);
    *(_DWORD *)long long buf = 67109120;
    LODWORD(v22) = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Receive vinyl info 0x%02x", buf, 8u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v20 = *(void *)(a1 + 360) == 0;
    uint64_t v5 = printers::asString((printers *)&v20, v4);
    uint64_t v6 = *(void *)(a1 + 456);
    *(_DWORD *)long long buf = 136315394;
    uint64_t v22 = (void *)v5;
    __int16 v23 = 2048;
    uint64_t v24 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Request Assertion Timer active: %s: waiting callback: %lu", buf, 0x16u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void **)(a1 + 432);
    *(_DWORD *)long long buf = 134217984;
    uint64_t v22 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Vinyl Install Retries: %lu", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(unsigned __int8 *)(a1 + 229);
    *(_DWORD *)long long buf = 67109120;
    LODWORD(v22) = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Attestation prefetch attempts: %hhu", buf, 8u);
  }
  uint64_t v9 = *(void **)(a1 + 416);
  if (v9 != (void *)(a1 + 424))
  {
    do
    {
      uint64_t v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = v9 + 4;
        if (*((char *)v9 + 55) < 0) {
          int v11 = (void *)*v11;
        }
        int v12 = *((_DWORD *)v9 + 14);
        *(_DWORD *)long long buf = 136315394;
        uint64_t v22 = v11;
        __int16 v23 = 1024;
        LODWORD(v24) = v12;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s - %d", buf, 0x12u);
      }
      char v13 = (void *)v9[1];
      if (v13)
      {
        do
        {
          int v14 = v13;
          char v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          int v14 = (void *)v9[2];
          BOOL v15 = *v14 == (void)v9;
          uint64_t v9 = v14;
        }
        while (!v15);
      }
      uint64_t v9 = v14;
    }
    while (v14 != (void *)(a1 + 424));
  }
  long long v16 = *(void **)(a1 + 160);
  if (v16 != (void *)(a1 + 168))
  {
    do
    {
      sub_100D38A48(v16[5]);
      BOOL v17 = (void *)v16[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          BOOL v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v16[2];
          BOOL v15 = *v18 == (void)v16;
          long long v16 = v18;
        }
        while (!v15);
      }
      long long v16 = v18;
    }
    while (v18 != (void *)(a1 + 168));
  }
  double result = *(VinylCommandDriver **)(a1 + 64);
  if (result) {
    return (VinylCommandDriver *)VinylCommandDriver::dumpState(result);
  }
  return result;
}

void sub_1004852FC(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v22 = a3;
  uint64_t v23 = a4;
  uint64_t v5 = *(void *)(a2 + 240);
  uint64_t v6 = *(void *)(a2 + 248);
  if (v5 == v6)
  {
LABEL_29:
    *a1 = 0;
    a1[1] = 0;
  }
  else
  {
    uint64_t v7 = (uint64_t **)(a2 + 168);
    while (1)
    {
      uint64_t v21 = 0;
      memset(v20, 0, sizeof(v20));
      long long v18 = 0u;
      *(_OWORD *)long long __p = 0u;
      long long v17 = 0u;
      sub_1000C5DA8((uint64_t)&v17, v5);
      BOOL v8 = (void)v18 == v22 && *((void *)&v18 + 1) == v23;
      if (v8 && *v7)
      {
        uint64_t v9 = v7;
        uint64_t v10 = *v7;
        do
        {
          int v11 = *((_DWORD *)v10 + 8);
          BOOL v12 = v11 < SDWORD1(v17);
          if (v11 >= SDWORD1(v17)) {
            char v13 = v10;
          }
          else {
            char v13 = v10 + 1;
          }
          if (!v12) {
            uint64_t v9 = (uint64_t **)v10;
          }
          uint64_t v10 = (uint64_t *)*v13;
        }
        while (*v13);
        if (v9 != v7 && SDWORD1(v17) >= *((_DWORD *)v9 + 8)) {
          break;
        }
      }
      if ((_BYTE)v21)
      {
        long long v16 = (void **)v20 + 1;
        sub_1000C57C8(&v16);
      }
      if (SBYTE7(v20[0]) < 0) {
        operator delete(__p[0]);
      }
      v5 += 88;
      if (v5 == v6) {
        goto LABEL_29;
      }
    }
    int v14 = sub_1000389F8(*v7, SDWORD1(v17));
    uint64_t v15 = v14[1];
    *a1 = *v14;
    a1[1] = v15;
    if (v15) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
    }
    if ((_BYTE)v21)
    {
      long long v16 = (void **)v20 + 1;
      sub_1000C57C8(&v16);
    }
    if (SBYTE7(v20[0]) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_100485470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10015A318((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10048548C(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4)
{
  __int16 v6 = a4;
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __int16 *))(*(void *)v4 + 48))(v4, a2, a3, &v6);
}

void sub_1004854E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v12 = 0;
  char v13 = 0;
  sub_1004852FC((uint64_t *)&v12, a1, a2, a3);
  uint64_t v9 = v12;
  if (v12)
  {
    sub_1000C7494((uint64_t)v14, a6);
    sub_100D2BF50(v9, a4, a5, (uint64_t)v14);
    sub_1000C752C(v14);
  }
  else
  {
    __int16 v11 = 258;
    uint64_t v10 = *(void *)(a6 + 24);
    if (!v10) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, __int16 *))(*(void *)v10 + 48))(v10, &v11);
    LOBYTE(v11) = 0;
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_1004855E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, ...)
{
  va_start(va, a4);
  sub_1000C752C((uint64_t *)va);
  if (a4) {
    sub_10004D2C8(a4);
  }
  _Unwind_Resume(a1);
}

void sub_10048561C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2 || (v3 = *(void *)(a1 + 8), (uint64_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  p_shared_weak_owners = &v4->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v4);
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  uint64_t v7 = operator new(0x20uLL);
  *uint64_t v7 = off_1019D1BA0;
  v7[1] = a1;
  void v7[2] = v3;
  v7[3] = v5;
  v8[3] = v7;
  VinylCommandDriver::setVirtualSimMode();
  sub_1000C752C(v8);
  std::__shared_weak_count::__release_weak(v5);
}

void sub_100485714(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C752C((uint64_t *)va);
  std::__shared_weak_count::__release_weak(v2);
  _Unwind_Resume(a1);
}

void sub_100485740(void *a1, char a2, uint64_t a3, uint64_t a4)
{
  if (a2)
  {
    if (a1[51])
    {
      __int16 v6 = a1[5];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "outstanding callback waiting for disable bootstrap assertion, busy", (uint8_t *)__p, 2u);
      }
      __int16 v23 = 1282;
      uint64_t v7 = *(void *)(a4 + 24);
      if (!v7) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, __int16 *))(*(void *)v7 + 48))(v7, &v23);
    }
    else
    {
      uint64_t v11 = a1[46];
      if (v11)
      {
        if (*(_DWORD *)(v11 + 68) == 2)
        {
          sub_100485AD8(a1 + 48, a4);
          BOOL v12 = *(void (**)(void *, uint64_t))(*a1 + 232);
          v12(a1, a3);
        }
        else
        {
          __int16 v22 = 1282;
          uint64_t v20 = *(void *)(a4 + 24);
          if (!v20) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t, __int16 *))(*(void *)v20 + 48))(v20, &v22);
        }
      }
      else
      {
        sub_100058DB0(__p, "/cc/assertions/disable_bootstrap_assertion");
        ctu::rest::AssertionHandle::create();
        if (v26 < 0) {
          operator delete(__p[0]);
        }
        char v13 = (std::__shared_weak_count *)a1[47];
        *((_OWORD *)a1 + 23) = v21;
        if (v13) {
          sub_10004D2C8(v13);
        }
        int v14 = (std::__shared_weak_count *)a1[2];
        if (!v14 || (uint64_t v15 = a1[1], (v16 = std::__shared_weak_count::lock(v14)) == 0)) {
          sub_100088B9C();
        }
        long long v17 = v16;
        p_shared_weak_owners = &v16->__shared_weak_owners_;
        atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        sub_100485AD8(a1 + 48, a4);
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        char v19 = operator new(0x28uLL);
        *char v19 = off_1019D1C20;
        v19[1] = v15;
        v19[2] = v17;
        v19[3] = a1;
        *((unsigned char *)v19 + 32) = a3;
        uint64_t v27 = v19;
        ctu::rest::AssertionHandle::setHandler_impl();
        sub_100060644(__p);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
  }
  else
  {
    BOOL v8 = a1[5];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "disabling vsim mode unsupported", (uint8_t *)__p, 2u);
    }
    __int16 v24 = 2818;
    uint64_t v9 = *(void *)(a4 + 24);
    if (!v9) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, __int16 *))(*(void *)v9 + 48))(v9, &v24);
  }
}

void sub_100485A84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  sub_100060644(&__p);
  std::__shared_weak_count::__release_weak(v18);
  _Unwind_Resume(a1);
}

void *sub_100485AD8(void *a1, uint64_t a2)
{
  sub_1000C7494((uint64_t)v6, a2);
  if (v6 != a1)
  {
    uint64_t v3 = v7;
    uint64_t v4 = (void *)a1[3];
    if (v7 == v6)
    {
      if (v4 == a1)
      {
        memset(v8, 0, sizeof(v8));
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, v8);
        (*(void (**)(void *))(*v7 + 32))(v7);
        uint64_t v7 = 0;
        (*(void (**)(void, void *))(*(void *)a1[3] + 24))(a1[3], v6);
        (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
        a1[3] = 0;
        uint64_t v7 = v6;
        (*(void (**)(void *, void *))(v8[0] + 24))(v8, a1);
        (*(void (**)(void *))(v8[0] + 32))(v8);
      }
      else
      {
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a1);
        (*(void (**)(void *))(*v7 + 32))(v7);
        uint64_t v7 = (void *)a1[3];
      }
      a1[3] = a1;
    }
    else if (v4 == a1)
    {
      (*(void (**)(void *, void *))(*a1 + 24))(a1, v6);
      (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
      a1[3] = v7;
      uint64_t v7 = v6;
    }
    else
    {
      uint64_t v7 = (void *)a1[3];
      a1[3] = v3;
    }
  }
  sub_1000C752C(v6);
  return a1;
}

void sub_100485D68(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100485D74(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 228);
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Received vinyl info for %s", buf, 0xCu);
  }
  int v6 = *(_DWORD *)(a2 + 4);
  if (v6 == 1)
  {
    unint64_t v7 = 0;
    LOBYTE(v8) = 1;
  }
  else
  {
    int v8 = *(_DWORD *)(a1 + 224);
    if (v8 == 1)
    {
      unint64_t v7 = 0;
    }
    else
    {
      if (v6 != 2 || v8 != 2)
      {
        unsigned int v31 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          uint64_t v32 = subscriber::asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v32;
          _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Invalid index, unknown vinyl slot (%s)", buf, 0xCu);
        }
        return;
      }
      unint64_t v7 = 1;
    }
  }
  *(unsigned char *)(a1 + 228) |= v8;
  if (!v4) {
    sub_1004862D0(a1);
  }
  uint64_t v9 = *(void *)(a1 + 296);
  uint64_t v10 = *(void *)(a1 + 304);
  if (v9 == v10) {
    goto LABEL_24;
  }
  if (0x2E8BA2E8BA2E8BA3 * ((v10 - v9) >> 3) <= v7) {
    sub_10015B728();
  }
  if ((VinylInfo::operator==() & 1) == 0)
  {
LABEL_24:
    uint64_t v11 = *(void *)(a1 + 240);
    uint64_t v12 = v11 + 88 * v7;
    long long v13 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)uint64_t v12 = *(_OWORD *)a2;
    *(_OWORD *)(v12 + 16) = v13;
    std::string::operator=((std::string *)(v12 + 32), (const std::string *)(a2 + 32));
    sub_1000C86CC(v11 + 88 * v7 + 56, a2 + 56);
    *(_OWORD *)long long buf = 0uLL;
    for (uint64_t i = *(void *)(a1 + 240); i != *(void *)(a1 + 248); i += 88)
    {
      if (*(_DWORD *)i)
      {
        if (*(void *)(i + 16) == *(void *)buf && *(void *)(i + 24) == *(void *)&buf[8])
        {
          uint64_t v30 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)char v35 = 0;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Detected vinyl SIM, but no CSN - waiting", v35, 2u);
          }
          return;
        }
      }
    }
    if (*(unsigned char *)(a1 + 228) == 3 || *(_DWORD *)(a1 + 224) == 1)
    {
      long long v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)char v35 = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Publishing vinyl info", v35, 2u);
      }
      long long v17 = *(std::__shared_weak_count **)(a1 + 120);
      if (v17)
      {
        long long v17 = std::__shared_weak_count::lock(v17);
        if (v17)
        {
          long long v18 = v17;
          uint64_t v19 = *(void *)(a1 + 112);
          if (v19) {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v19 + 16))(v19, a1 + 240);
          }
          sub_10004D2C8(v18);
        }
      }
      if (!capabilities::ct::shouldSaveVinylInfo((capabilities::ct *)v17)) {
        goto LABEL_51;
      }
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 80) + 72))(v35);
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)v35);
      long long v21 = ServiceMap;
      if (v22 < 0)
      {
        __int16 v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v24 = 5381;
        do
        {
          uint64_t v22 = v24;
          unsigned int v25 = *v23++;
          uint64_t v24 = (33 * v24) ^ v25;
        }
        while (v25);
      }
      std::mutex::lock(ServiceMap);
      uint64_t v37 = (const void *)v22;
      char v26 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)&v37);
      if (v26)
      {
        uint64_t v28 = v26[3];
        uint64_t v27 = (std::__shared_weak_count *)v26[4];
        if (v27)
        {
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v21);
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v27);
          char v29 = 0;
LABEL_45:
          if (v36) {
            sub_10004D2C8(v36);
          }
          if (v28)
          {
            *(void *)char v35 = 0;
            sub_100480984((const VinylInfo **)(a1 + 240), (xpc_object_t *)v35);
            uint64_t v37 = 0;
            xpc::bridge((uint64_t *)&v34, (xpc *)v35, v33);
            sub_100044D6C(&v37, &v34);
            sub_1000577C4(&v34);
            (*(void (**)(uint64_t, const __CFString *, const void *, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v28 + 16))(v28, @"CachedVinylInfoKey", v37, @"no_backup/com.apple.commcenter.vinyl", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
            (*(void (**)(uint64_t, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v28 + 48))(v28, @"no_backup/com.apple.commcenter.vinyl", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
            sub_100044D00(&v37);
            xpc_release(*(xpc_object_t *)v35);
          }
          if ((v29 & 1) == 0) {
            sub_10004D2C8(v27);
          }
LABEL_51:
          sub_100480890((void *)(a1 + 264), (uint64_t *)(a1 + 240));
          return;
        }
      }
      else
      {
        uint64_t v28 = 0;
      }
      std::mutex::unlock(v21);
      uint64_t v27 = 0;
      char v29 = 1;
      goto LABEL_45;
    }
  }
}

void sub_100486250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, xpc_object_t object, uint64_t a12, uint64_t a13, char a14)
{
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_1004862D0(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 464);
  if (v1 <= 0) {
    int v2 = 0;
  }
  else {
    int v2 = v1 - 1;
  }
  *(_DWORD *)(result + 464) = v2;
  if (*(void *)(result + 336)) {
    BOOL v3 = v2 == 0;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(NSObject **)(result + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Releasing booted assertion for session", v7, 2u);
    }
    int v6 = *(std::__shared_weak_count **)(v4 + 344);
    *(void *)(v4 + 336) = 0;
    *(void *)(v4 + 344) = 0;
    if (v6) {
      sub_10004D2C8(v6);
    }
    (*(void (**)(void))(**(void **)(v4 + 352) + 16))(*(void *)(v4 + 352));
    double result = *(void *)(v4 + 352);
    *(void *)(v4 + 352) = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void sub_1004863C0(uint64_t a1, uint64_t a2)
{
}

void sub_1004863C8(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  int v6 = *(std::__shared_weak_count **)(a1 + 136);
  if (v6)
  {
    unint64_t v7 = std::__shared_weak_count::lock(v6);
    a3[1] = v7;
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 128);
      *a3 = v8;
      if (v8)
      {
        if (*(void *)(a1 + 360))
        {
          uint64_t v9 = sub_100492504(a2);
          v9[1] = a1 + 440;
          uint64_t v10 = *(void *)(a1 + 440);
          *uint64_t v9 = v10;
          *(void *)(v10 + 8) = v9;
          *(void *)(a1 + 440) = v9;
          ++*(void *)(a1 + 456);
        }
        return;
      }
      sub_10004D2C8(v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
  uint64_t v11 = (char *)operator new(0x48uLL);
  *((void *)v11 + 2) = 0;
  *((void *)v11 + 1) = 0;
  *(void *)uint64_t v11 = off_1019D1CA0;
  *(_OWORD *)(v11 + 40) = 0u;
  *(_OWORD *)(v11 + 56) = 0u;
  *a3 = v11 + 24;
  a3[1] = v11;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 1, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 2, 1uLL, memory_order_relaxed);
  *((void *)v11 + 3) = v11 + 24;
  *((void *)v11 + 4) = v11;
  sub_10004D2C8((std::__shared_weak_count *)v11);
  uint64_t v12 = *(void *)(a1 + 336);
  if (v12)
  {
    uint64_t v13 = *(void *)(a1 + 344);
    if (v13) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    }
    int v14 = (std::__shared_weak_count *)*((void *)v11 + 6);
    *((void *)v11 + 5) = v12;
    *((void *)v11 + 6) = v13;
    if (v14) {
      sub_10004D2C8(v14);
    }
  }
  else
  {
    sub_100058DB0(&__p, "/cc/assertions/baseband_booted");
    ctu::rest::AssertionHandle::create();
    if (v38 < 0) {
      operator delete(__p);
    }
    long long v15 = *(_OWORD *)v34;
    v34[0] = 0;
    v34[1] = 0;
    long long v16 = (std::__shared_weak_count *)*((void *)v11 + 6);
    *(_OWORD *)(v11 + 40) = v15;
    if (v16)
    {
      sub_10004D2C8(v16);
      if (v34[1]) {
        sub_10004D2C8((std::__shared_weak_count *)v34[1]);
      }
    }
    long long __p = off_1019D1CF0;
    uint64_t v37 = a1;
    p_p = &__p;
    ctu::rest::AssertionHandle::setHandler_impl();
    sub_100060644(&__p);
  }
  sub_100058DB0(&__p, "/cc/assertions/prevent_baseband_reset");
  ctu::rest::AssertionHandle::create();
  if (v38 < 0) {
    operator delete(__p);
  }
  long long v17 = *(_OWORD *)v34;
  v34[0] = 0;
  v34[1] = 0;
  long long v18 = (std::__shared_weak_count *)*((void *)v11 + 8);
  *(_OWORD *)(v11 + 56) = v17;
  if (v18)
  {
    sub_10004D2C8(v18);
    if (v34[1]) {
      sub_10004D2C8((std::__shared_weak_count *)v34[1]);
    }
  }
  long long __p = off_1019D1D70;
  uint64_t v37 = a1;
  p_p = &__p;
  ctu::rest::AssertionHandle::setHandler_impl();
  sub_100060644(&__p);
  atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 2, 1uLL, memory_order_relaxed);
  uint64_t v19 = *(std::__shared_weak_count **)(a1 + 136);
  *(void *)(a1 + 128) = v11 + 24;
  *(void *)(a1 + 136) = v11;
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  uint64_t v20 = sub_100492504(a2);
  v20[1] = a1 + 440;
  uint64_t v21 = *(void *)(a1 + 440);
  *uint64_t v20 = v21;
  *(void *)(v21 + 8) = v20;
  *(void *)(a1 + 440) = v20;
  ++*(void *)(a1 + 456);
  (*(void (**)(Registry **__return_ptr))(**(void **)(a1 + 80) + 72))(&v29);
  Registry::getTimerService(&v31, v29);
  uint64_t v22 = v31;
  sub_100058DB0(v27, "VinylRequestAssertion");
  *(_OWORD *)char v34 = *(_OWORD *)v27;
  uint64_t v23 = v28;
  v27[0] = 0;
  v27[1] = 0;
  uint64_t v28 = 0;
  uint64_t v35 = v23;
  long long __p = off_1019D1DF0;
  uint64_t v37 = a1;
  p_p = &__p;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, uint64_t, uint64_t, void, void **))(*(void *)v22 + 40))(&v33, v22, v34, 1, 30000000, 0, &__p);
  sub_10003B34C(&__p);
  if (SHIBYTE(v35) < 0) {
    operator delete(v34[0]);
  }
  uint64_t v24 = v33;
  uint64_t v33 = 0;
  uint64_t v25 = *(void *)(a1 + 360);
  *(void *)(a1 + 360) = v24;
  if (v25)
  {
    (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
    uint64_t v26 = v33;
    uint64_t v33 = 0;
    if (v26) {
      (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
    }
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(v27[0]);
  }
  if (v32) {
    sub_10004D2C8(v32);
  }
  if (v30) {
    sub_10004D2C8(v30);
  }
}

void sub_100486810(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  sub_10004D2C8(v31);
  _Unwind_Resume(a1);
}

void sub_1004868BC(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
}

uint64_t sub_1004868C4(uint64_t a1)
{
  int v1 = *(void **)(a1 + 160);
  int v2 = (void *)(a1 + 168);
  if (v1 == (void *)(a1 + 168)) {
    return 1;
  }
  do
  {
    uint64_t result = sub_100D25CF8(v1[5]);
    if (!result) {
      break;
    }
    uint64_t v4 = (void *)v1[1];
    if (v4)
    {
      do
      {
        uint64_t v5 = v4;
        uint64_t v4 = (void *)*v4;
      }
      while (v4);
    }
    else
    {
      do
      {
        uint64_t v5 = (void *)v1[2];
        BOOL v6 = *v5 == (void)v1;
        int v1 = v5;
      }
      while (!v6);
    }
    int v1 = v5;
  }
  while (v5 != v2);
  return result;
}

uint64_t sub_10048693C(uint64_t a1)
{
  return sub_1004868C4(a1 - 56);
}

void sub_100486944(uint64_t a1, int a2)
{
  int v2 = *(void **)(a1 + 160);
  BOOL v3 = (void *)(a1 + 168);
  if (v2 != (void *)(a1 + 168))
  {
    do
    {
      if (*((_DWORD *)v2 + 8) != a2)
      {
        uint64_t v5 = v2[5];
        if (*(void *)(v5 + 160))
        {
          if ((sub_100D25CF8(v2[5]) & 1) != 0 || *(void *)(v5 + 176)) {
            sub_100D25F88(v2[5], 1);
          }
        }
      }
      BOOL v6 = (void *)v2[1];
      if (v6)
      {
        do
        {
          unint64_t v7 = v6;
          BOOL v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          unint64_t v7 = (void *)v2[2];
          BOOL v8 = *v7 == (void)v2;
          int v2 = v7;
        }
        while (!v8);
      }
      int v2 = v7;
    }
    while (v7 != v3);
  }
}

void sub_1004869EC(uint64_t a1, int a2)
{
}

std::string *sub_1004869F4@<X0>(std::string *result@<X0>, void *a2@<X1>, std::string *a3@<X8>)
{
  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  uint64_t v4 = a2[2];
  if (v4 == 2)
  {
    std::string::size_type size = result[8].__r_.__value_.__l.__size_;
    std::string::size_type v6 = result[8].__r_.__value_.__r.__words[2];
    if (size != v6)
    {
      while (!*(_DWORD *)size || *(_DWORD *)size == HIDWORD(result[13].__r_.__value_.__r.__words[1]))
      {
        size += 168;
        if (size == v6) {
          return result;
        }
      }
    }
    if (size != v6)
    {
      BOOL v8 = (const std::string *)(size + 72);
      uint64_t result = (std::string *)sub_10010E128((uint64_t)a2, (void **)(size + 72));
      if (result) {
        return std::string::operator=(a3, v8);
      }
    }
  }
  else if (v4 == 1)
  {
    return std::string::operator=(a3, (const std::string *)(*a2 + 32));
  }
  return result;
}

void sub_100486A9C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_100486ABC@<X0>(uint64_t a1@<X0>, void *a2@<X1>, std::string *a3@<X8>)
{
  return sub_1004869F4((std::string *)(a1 - 56), a2, a3);
}

BOOL sub_100486AC4(uint64_t a1, std::string::size_type *a2, std::string::size_type a3, std::string::size_type a4)
{
  std::string::size_type v6 = *a2;
  if (a2[1] - v6 != 24) {
    goto LABEL_10;
  }
  if (*(char *)(v6 + 23) < 0)
  {
    unint64_t v8 = *(void *)(v6 + 8);
    if (v8 <= 0x12) {
      goto LABEL_10;
    }
  }
  else
  {
    unint64_t v8 = *(unsigned __int8 *)(v6 + 23);
    if (v8 < 0x13) {
      goto LABEL_10;
    }
  }
  if (v8 <= 0x14)
  {
    valuePtr.__r_.__value_.__r.__words[0] = v6;
    uint64_t v9 = sub_100492E9C((uint64_t **)(a1 + 416), (void **)v6, (uint64_t)&unk_10144E20E, (long long **)&valuePtr);
    unsigned int v10 = *((_DWORD *)v9 + 14) + 1;
    *((_DWORD *)v9 + 14) = v10;
    BOOL v11 = v10 > 0xA;
    if (v10 != 11) {
      goto LABEL_27;
    }
    CFTypeRef cf = 0;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    sub_100058DB0(&valuePtr, "ICCID Retry Attempts for Carrier SMDP Server: (");
    if (*(char *)(a4 + 23) < 0)
    {
      sub_10004FC84(&v45, *(void **)a4, *(void *)(a4 + 8));
    }
    else
    {
      long long v45 = *(_OWORD *)a4;
      uint64_t v46 = *(void *)(a4 + 16);
    }
    sub_100058DB0(v47, "), retries: (");
    std::to_string(&v48, 0xAu);
    sub_100058DB0(v49, ")");
    CFTypeRef cf = 0;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&cf;
    __p.__r_.__value_.__l.__size_ = 0;
    CFTypeRef cf = operator new(0x78uLL);
    uint64_t v42 = (std::string *)cf;
    uint64_t v43 = (char *)cf + 120;
    uint64_t v38 = 0;
    uint64_t v42 = (std::string *)sub_1000D8A18((uint64_t)&v43, (long long *)&valuePtr, &v50, (char *)cf);
    do
    {
      if (SHIBYTE(v49[v38 + 2]) < 0) {
        operator delete((void *)v49[v38]);
      }
      v38 -= 3;
    }
    while (v38 != -15);
    goto LABEL_22;
  }
LABEL_10:
  uint64_t v12 = *(unsigned __int8 *)(a3 + 23);
  if ((v12 & 0x80u) != 0) {
    uint64_t v12 = *(void *)(a3 + 8);
  }
  if (!v12)
  {
    BOOL v11 = 0;
    goto LABEL_27;
  }
  valuePtr.__r_.__value_.__r.__words[0] = a3;
  uint64_t v13 = sub_100492E9C((uint64_t **)(a1 + 416), (void **)a3, (uint64_t)&unk_10144E20E, (long long **)&valuePtr);
  unsigned int v14 = *((_DWORD *)v13 + 14) + 1;
  *((_DWORD *)v13 + 14) = v14;
  BOOL v11 = v14 > 0xA;
  if (v14 != 11) {
    goto LABEL_27;
  }
  CFTypeRef cf = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  sub_100058DB0(&valuePtr, "Matching ID Retry Attempts for Carrier SMDP Server: (");
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(&v45, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    long long v45 = *(_OWORD *)a4;
    uint64_t v46 = *(void *)(a4 + 16);
  }
  sub_100058DB0(v47, "), retries: (");
  std::to_string(&v48, 0xAu);
  sub_100058DB0(v49, ")");
  CFTypeRef cf = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&cf;
  __p.__r_.__value_.__l.__size_ = 0;
  CFTypeRef cf = operator new(0x78uLL);
  uint64_t v42 = (std::string *)cf;
  uint64_t v43 = (char *)cf + 120;
  uint64_t v15 = 0;
  uint64_t v42 = (std::string *)sub_1000D8A18((uint64_t)&v43, (long long *)&valuePtr, &v50, (char *)cf);
  do
  {
    if (SHIBYTE(v49[v15 + 2]) < 0) {
      operator delete((void *)v49[v15]);
    }
    v15 -= 3;
  }
  while (v15 != -15);
LABEL_22:
  sub_100058DB0(&valuePtr, "SMDP Retries");
  sub_100062B40((std::string *)cf, v42, "", 0, &__p);
  sub_100487488(a1, &valuePtr, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(valuePtr.__r_.__value_.__l.__data_);
  }
  valuePtr.__r_.__value_.__r.__words[0] = (std::string::size_type)&cf;
  sub_100047F64((void ***)&valuePtr);
  BOOL v11 = 1;
LABEL_27:
  valuePtr.__r_.__value_.__r.__words[0] = a4;
  long long v16 = sub_100492E9C((uint64_t **)(a1 + 416), (void **)a4, (uint64_t)&unk_10144E20E, (long long **)&valuePtr);
  unsigned int v17 = *((_DWORD *)v16 + 14) + 1;
  *((_DWORD *)v16 + 14) = v17;
  if (v17 >= 0x65)
  {
    char v18 = v17 != 101 || v11;
    if ((v18 & 1) == 0)
    {
      CFTypeRef cf = 0;
      uint64_t v42 = 0;
      uint64_t v43 = 0;
      sub_100058DB0(&valuePtr, "SMDP Server Retry Attempts for Carrier SMDP Server: (");
      if (*(char *)(a4 + 23) < 0)
      {
        sub_10004FC84(&v45, *(void **)a4, *(void *)(a4 + 8));
      }
      else
      {
        long long v45 = *(_OWORD *)a4;
        uint64_t v46 = *(void *)(a4 + 16);
      }
      sub_100058DB0(v47, "), retries: (");
      std::to_string(&v48, 0x64u);
      sub_100058DB0(v49, ")");
      CFTypeRef cf = 0;
      uint64_t v42 = 0;
      uint64_t v43 = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&cf;
      __p.__r_.__value_.__l.__size_ = 0;
      CFTypeRef cf = operator new(0x78uLL);
      uint64_t v42 = (std::string *)cf;
      uint64_t v43 = (char *)cf + 120;
      uint64_t v19 = 0;
      uint64_t v42 = (std::string *)sub_1000D8A18((uint64_t)&v43, (long long *)&valuePtr, &v50, (char *)cf);
      do
      {
        if (SHIBYTE(v49[v19 + 2]) < 0) {
          operator delete((void *)v49[v19]);
        }
        v19 -= 3;
      }
      while (v19 != -15);
      sub_100058DB0(&valuePtr, "SMDP Retries");
      sub_100062B40((std::string *)cf, v42, "", 0, &__p);
      sub_100487488(a1, &valuePtr, &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(valuePtr.__r_.__value_.__l.__data_);
      }
      valuePtr.__r_.__value_.__r.__words[0] = (std::string::size_type)&cf;
      sub_100047F64((void ***)&valuePtr);
    }
    BOOL v11 = 1;
  }
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 80) + 72))(&valuePtr);
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)valuePtr.__r_.__value_.__l.__data_);
  uint64_t v21 = ServiceMap;
  if (v22 < 0)
  {
    uint64_t v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v24 = 5381;
    do
    {
      uint64_t v22 = v24;
      unsigned int v25 = *v23++;
      uint64_t v24 = (33 * v24) ^ v25;
    }
    while (v25);
  }
  std::mutex::lock(ServiceMap);
  CFTypeRef cf = (CFTypeRef)v22;
  uint64_t v26 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)&cf);
  if (v26)
  {
    uint64_t v28 = v26[3];
    uint64_t v27 = (std::__shared_weak_count *)v26[4];
    if (v27)
    {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v21);
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v27);
      char v29 = 0;
      goto LABEL_53;
    }
  }
  else
  {
    uint64_t v28 = 0;
  }
  std::mutex::unlock(v21);
  uint64_t v27 = 0;
  char v29 = 1;
LABEL_53:
  if (valuePtr.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)valuePtr.__r_.__value_.__l.__size_);
  }
  if (v28)
  {
    uint64_t v39 = 0;
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      uint64_t v31 = *(void **)(a1 + 416);
      uint64_t v32 = (void *)(a1 + 424);
      if (v31 != v32)
      {
        do
        {
          CFTypeRef cf = 0;
          valuePtr.__r_.__value_.__r.__words[0] = 0;
          ctu::cf::convert_copy();
          CFTypeRef cf = (CFTypeRef)valuePtr.__r_.__value_.__r.__words[0];
          __p.__r_.__value_.__r.__words[0] = 0;
          valuePtr.__r_.__value_.__r.__words[0] = *((unsigned int *)v31 + 14);
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
          sub_100328D40(Mutable, (void *)cf, (uint64_t)__p.__r_.__value_.__l.__data_);
          sub_10010F494((const void **)&__p.__r_.__value_.__l.__data_);
          sub_10010F494(&cf);
          uint64_t v33 = (void *)v31[1];
          if (v33)
          {
            do
            {
              char v34 = v33;
              uint64_t v33 = (void *)*v33;
            }
            while (v33);
          }
          else
          {
            do
            {
              char v34 = (void *)v31[2];
              BOOL v35 = *v34 == (void)v31;
              uint64_t v31 = v34;
            }
            while (!v35);
          }
          uint64_t v31 = v34;
        }
        while (v34 != v32);
      }
      std::string::size_type v36 = (std::string::size_type)v39;
      uint64_t v39 = Mutable;
      valuePtr.__r_.__value_.__r.__words[0] = v36;
      sub_10005717C((const void **)&valuePtr.__r_.__value_.__l.__data_);
    }
    (*(void (**)(uint64_t, const __CFString *, __CFDictionary *, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v28 + 16))(v28, @"VinylInstallRetryKey", v39, @"no_backup/com.apple.commcenter.vinyl", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    sub_10005717C((const void **)&v39);
  }
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  return v11;
}

void sub_10048726C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, char *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  a20 = &a17;
  sub_100047F64((void ***)&a20);
  _Unwind_Resume(a1);
}

void sub_100487488(uint64_t a1, const std::string *a2, const std::string *a3)
{
  memset(&v25[1], 0, 32);
  long long v26 = 0u;
  long long v31 = 0u;
  long long v30 = 0u;
  memset(&v28, 0, sizeof(v28));
  long long v27 = 0u;
  uint64_t v29 = 23;
  qmemcpy((char *)&v25[2] + 7, "\tVinyl Install", 14);
  v25[0] = *(void **)"Telephony";
  LOBYTE(v25[1]) = 121;
  BYTE7(v26) = 13;
  std::string::operator=((std::string *)((char *)&v26 + 8), a2);
  std::string::operator=(&v28, a3);
  uint64_t v32 = (Registry *)&v29;
  LODWORD(v33) = 0;
  sub_10019E478((uint64_t)&v32, 5uLL);
  v29 |= 1uLL;
  (*(void (**)(Registry **__return_ptr))(**(void **)(a1 + 80) + 72))(&v32);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v32);
  std::string::size_type v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    unint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v34 = v7;
  BOOL v11 = sub_10004D37C(&v6[1].__m_.__sig, &v34);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  sub_1000DB86C((char *)v15, (long long *)v25);
  v35[3] = 0;
  (*(void (**)(uint64_t, void **, void *))(*(void *)v13 + 16))(v13, v15, v35);
  sub_1000DBADC(v35);
  if (v24 < 0) {
    operator delete(__p);
  }
  if (v22 < 0) {
    operator delete(v21);
  }
  if (v20 < 0) {
    operator delete(v19);
  }
  if (v18 < 0) {
    operator delete(v17);
  }
  if ((v16 & 0x80000000) == 0)
  {
    if (v14) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  operator delete(v15[0]);
  if ((v14 & 1) == 0) {
LABEL_19:
  }
    sub_10004D2C8(v12);
LABEL_20:
  if (v33) {
    sub_10004D2C8(v33);
  }
  if (SBYTE7(v31) < 0) {
    operator delete((void *)v30);
  }
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(*((void **)&v26 + 1));
  }
  if (SBYTE7(v26) < 0) {
    operator delete(v25[3]);
  }
  if (SHIBYTE(v25[2]) < 0) {
    operator delete(v25[0]);
  }
}

void sub_100487764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  sub_1000DBADC((void *)(v28 - 88));
  sub_1001278A0((uint64_t)&a9);
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  long long v30 = *(std::__shared_weak_count **)(v28 - 104);
  if (v30) {
    sub_10004D2C8(v30);
  }
  sub_1001278A0((uint64_t)&a26);
  _Unwind_Resume(a1);
}

BOOL sub_1004877D0(uint64_t a1, std::string::size_type *a2, std::string::size_type a3, std::string::size_type a4)
{
  return sub_100486AC4(a1 - 56, a2, a3, a4);
}

BOOL sub_1004877D8(uint64_t a1)
{
  return *(_DWORD *)(a1 + 320) == 2 || *(unsigned char *)(a1 + 329) == 1;
}

BOOL sub_1004877FC(uint64_t a1)
{
  return *(_DWORD *)(a1 + 264) == 2 || *(unsigned char *)(a1 + 273) == 1;
}

void *sub_100487820(void *result, int a2)
{
  if (*((unsigned __int8 *)result + 328) != a2)
  {
    v2[0] = off_1019D1E70;
    v2[3] = v2;
    sub_100480F48((uint64_t)result, 0, (uint64_t)v2);
    return sub_1000DBADC(v2);
  }
  return result;
}

void sub_1004878B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000DBADC((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1004878C8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_1000278EC((uint64_t)&v5, a2);
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100487A00(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100487A18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = a1;
  uint64_t v9 = 0;
  *(void *)unsigned int v10 = 0;
  uint64_t v11 = 0;
  sub_10005C928(&v9, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  memset(__p, 0, sizeof(__p));
  sub_10005C928(__p, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  sub_1004913B0((uint64_t)&v13, a4);
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100487BE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100487C54(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_100487DB8;
  uint64_t v4[3] = &unk_1019D0D38;
  void v4[4] = a1;
  uint64_t v5 = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = sub_100490E58;
  void v6[3] = &unk_1019D1A50;
  void v6[4] = a1 + 8;
  v6[5] = &v5;
  unint64_t v7 = v6;
  uint64_t v3 = a1 + 24;
  int v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(unsigned char *)(a2 + 16) = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    unsigned int v10 = sub_100490F18;
    uint64_t v11 = &unk_1019D1A90;
    uint64_t v12 = a2;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(unsigned char *)(a2 + 16) = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    unsigned int v10 = sub_100490E6C;
    uint64_t v11 = &unk_1019D1A70;
    uint64_t v12 = a2;
    uint64_t v13 = &v7;
    dispatch_sync(v2, &block);
  }
}

double sub_100487DB8@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)&double result = sub_100480AC0(a2, *(void *)(a1 + 32), *(_DWORD *)(*(void *)(a1 + 32) + 232)).n128_u64[0];
  return result;
}

void sub_100487DC8(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
}

const void **sub_100487DD0(void *a1, int a2, int a3, const void **a4)
{
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 1174405120;
  dispatch_object_t v11[2] = sub_100487F04;
  v11[3] = &unk_1019D0D58;
  _DWORD v11[4] = a1;
  int v13 = a2;
  int v14 = a3;
  sub_100058198(&v12, a4);
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  uint64_t v9 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v6;
  char v16 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v11;
  dispatch_async(v9, block);
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v8);
  return sub_100057D78(&v12);
}

uint64_t *sub_100487F04(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = v2 + 168;
  double result = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(v4 + 64);
    unint64_t v7 = (uint64_t *)v4;
    uint64_t v8 = result;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        unint64_t v7 = v8;
      }
      uint64_t v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4 && v6 >= *((_DWORD *)v7 + 8))
    {
      uint64_t v12 = *sub_1000389F8(result, v6);
      uint64_t v13 = *(unsigned int *)(a1 + 48);
      int v14 = *(_DWORD *)(a1 + 52);
      sub_100058198(&v15, (const void **)(a1 + 40));
      sub_100D31BAC(v12, v13, v14, (CFDictionaryRef *)&v15);
      return (uint64_t *)sub_100057D78(&v15);
    }
  }
  return result;
}

void sub_100487FB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_100487FC4(uint64_t a1, uint64_t a2)
{
  return sub_100058198((const void **)(a1 + 40), (const void **)(a2 + 40));
}

const void **sub_100487FD0(uint64_t a1)
{
  return sub_100057D78((const void **)(a1 + 40));
}

const void **sub_100487FD8(uint64_t a1, int a2, int a3, const void **a4)
{
  return sub_100487DD0((void *)(a1 - 48), a2, a3, a4);
}

void sub_100487FE0(void *a1, long long *a2, uint64_t a3)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  v12[2] = sub_1004881B4;
  v12[3] = &unk_1019D0D88;
  _DWORD v12[4] = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v14 = *((void *)a2 + 2);
  }
  sub_1000C6AC0((uint64_t)v15, a3);
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  int v9 = a1[3];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  int v10[2] = sub_10048E42C;
  v10[3] = &unk_1019D14E0;
  v10[5] = v6;
  uint64_t v11 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  v10[4] = v12;
  dispatch_async(v9, v10);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v8);
  sub_1000C6B58(v15);
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)__p);
  }
}

void sub_10048817C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
}

void sub_1004881B4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = v2 + 168;
  uint64_t v3 = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(v4 + 64);
    unint64_t v7 = (uint64_t *)v4;
    uint64_t v8 = v3;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        unint64_t v7 = v8;
      }
      uint64_t v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4 && v6 >= *((_DWORD *)v7 + 8))
    {
      uint64_t v12 = *sub_1000389F8(v3, v6);
      if (*(char *)(a1 + 63) < 0)
      {
        sub_10004FC84(__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)(a1 + 40);
        uint64_t v14 = *(void *)(a1 + 56);
      }
      sub_1000C6AC0((uint64_t)v15, a1 + 64);
      sub_100D321F4(v12, (uint64_t)__p, (uint64_t)v15);
      sub_1000C6B58(v15);
      if (SHIBYTE(v14) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_1004882B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

uint64_t sub_1004882EC(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }
  return sub_1000C6AC0(a1 + 64, a2 + 64);
}

void sub_100488354(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 63) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100488370(uint64_t a1)
{
  sub_1000C6B58((void *)(a1 + 64));
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    operator delete(v2);
  }
}

void sub_1004883C0(uint64_t a1, long long *a2, uint64_t a3)
{
}

void sub_1004883C8(void *a1, long long *a2, uint64_t a3)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  v12[2] = sub_10048859C;
  v12[3] = &unk_1019D0DB8;
  _DWORD v12[4] = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v14 = *((void *)a2 + 2);
  }
  sub_1000C6AC0((uint64_t)v15, a3);
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  int v9 = a1[3];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  int v10[2] = sub_10048E42C;
  v10[3] = &unk_1019D14E0;
  v10[5] = v6;
  uint64_t v11 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  v10[4] = v12;
  dispatch_async(v9, v10);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v8);
  sub_1000C6B58(v15);
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)__p);
  }
}

void sub_100488564(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
}

void sub_10048859C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = v2 + 168;
  uint64_t v3 = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(v4 + 64);
    unint64_t v7 = (uint64_t *)v4;
    uint64_t v8 = v3;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        unint64_t v7 = v8;
      }
      uint64_t v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4 && v6 >= *((_DWORD *)v7 + 8))
    {
      uint64_t v12 = *sub_1000389F8(v3, v6);
      if (*(char *)(a1 + 63) < 0)
      {
        sub_10004FC84(__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)(a1 + 40);
        uint64_t v14 = *(void *)(a1 + 56);
      }
      sub_1000C6AC0((uint64_t)v15, a1 + 64);
      sub_100D322F0(v12, (uint64_t)__p, (uint64_t)v15);
      sub_1000C6B58(v15);
      if (SHIBYTE(v14) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_1004886A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

void sub_1004886D4(uint64_t a1, long long *a2, uint64_t a3)
{
}

void sub_1004886DC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_10048882C;
  v12[3] = &unk_1019D0DF0;
  v12[6] = a2;
  v12[7] = a3;
  _DWORD v12[4] = a4;
  void v12[5] = a1;
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  int v9 = a1[3];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  int v10[2] = sub_10048E42C;
  v10[3] = &unk_1019D14E0;
  v10[5] = v6;
  uint64_t v11 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  v10[4] = v12;
  dispatch_async(v9, v10);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v8);
}

void sub_100488820(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10048882C(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = v2 + 168;
  uint64_t v3 = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(v4 + 64);
    unint64_t v7 = (uint64_t *)v4;
    uint64_t v8 = v3;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        unint64_t v7 = v8;
      }
      uint64_t v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4 && v6 >= *((_DWORD *)v7 + 8))
    {
      uint64_t v12 = (void *)*sub_1000389F8(v3, v6);
      uint64_t v13 = a1[6];
      uint64_t v14 = a1[7];
      uint64_t v15 = a1[4];
      sub_100D323EC(v12, v13, v14, v15);
    }
  }
}

void sub_1004888C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1004888C8(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_1004889E0;
  void v8[3] = &unk_1019D0E18;
  void v8[4] = a2;
  v8[5] = a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  int v6 = v5;
  unint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v4;
  BOOL v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

void sub_1004889E0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = v2 + 168;
  uint64_t v3 = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(v4 + 64);
    unint64_t v7 = (uint64_t *)v4;
    uint64_t v8 = v3;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        unint64_t v7 = v8;
      }
      uint64_t v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4 && v6 >= *((_DWORD *)v7 + 8))
    {
      uint64_t v12 = *sub_1000389F8(v3, v6);
      uint64_t v13 = *(const void **)(a1 + 32);
      sub_100D3269C(v12, v13);
    }
  }
}

void sub_100488A70(uint64_t a1, uint64_t a2)
{
}

void sub_100488A78(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_100488B90;
  void v8[3] = &unk_1019D0E40;
  void v8[4] = a2;
  v8[5] = a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  int v6 = v5;
  unint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v4;
  BOOL v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

uint64_t *sub_100488B90(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = v2 + 168;
  double result = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(v4 + 64);
    unint64_t v7 = (uint64_t *)v4;
    uint64_t v8 = result;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        unint64_t v7 = v8;
      }
      uint64_t v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4 && v6 >= *((_DWORD *)v7 + 8))
    {
      uint64_t v12 = *sub_1000389F8(result, v6);
      uint64_t v13 = *(void *)(a1 + 32);
      return (uint64_t *)sub_100D33DD8(v12, v13);
    }
  }
  return result;
}

void sub_100488C20(uint64_t a1, uint64_t a2)
{
}

void sub_100488C28(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_100488D40;
  void v8[3] = &unk_1019D0E68;
  void v8[4] = a2;
  v8[5] = a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  int v6 = v5;
  unint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v4;
  BOOL v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

uint64_t *sub_100488D40(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v4 = *(uint64_t **)(v1 + 168);
  uint64_t v3 = v1 + 168;
  double result = v4;
  if (v4)
  {
    int v5 = *(_DWORD *)(v3 + 64);
    int v6 = (uint64_t *)v3;
    unint64_t v7 = result;
    do
    {
      int v8 = *((_DWORD *)v7 + 8);
      BOOL v9 = v8 < v5;
      if (v8 >= v5) {
        BOOL v10 = (uint64_t **)v7;
      }
      else {
        BOOL v10 = (uint64_t **)(v7 + 1);
      }
      if (!v9) {
        int v6 = v7;
      }
      unint64_t v7 = *v10;
    }
    while (*v10);
    if (v6 != (uint64_t *)v3 && v5 >= *((_DWORD *)v6 + 8))
    {
      uint64_t v11 = *sub_1000389F8(result, v5);
      return (uint64_t *)sub_100D33854(v11);
    }
  }
  return result;
}

void sub_100488DD0(uint64_t a1, uint64_t a2)
{
}

void sub_100488DD8(void *a1, uint64_t a2, uint64_t a3)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  int v10[2] = sub_100488F20;
  v10[3] = &unk_1019D0E90;
  v10[5] = a1;
  long long __p = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_10005C928(&__p, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  v10[4] = a3;
  int v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  int v8 = v7;
  BOOL v9 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v6;
  uint64_t v15 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v10;
  dispatch_async(v9, block);
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_10004D2C8(v8);
  if (__p)
  {
    uint64_t v12 = __p;
    operator delete(__p);
  }
}

void sub_100488F20(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  int v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = v2 + 168;
  uint64_t v3 = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(v4 + 64);
    unint64_t v7 = (uint64_t *)v4;
    int v8 = v3;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        unint64_t v7 = v8;
      }
      int v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4 && v6 >= *((_DWORD *)v7 + 8))
    {
      uint64_t v12 = *sub_1000389F8(v3, v6);
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      long long __p = 0;
      sub_10005C928(&__p, *(const void **)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 56) - *(void *)(a1 + 48));
      sub_100D341B0(v12, (uint64_t)&__p, *(void (***)(void, void))(a1 + 32));
      if (__p)
      {
        uint64_t v14 = __p;
        operator delete(__p);
      }
    }
  }
}

void sub_100488FD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100488FEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100488FF4(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_10048910C;
  void v8[3] = &unk_1019D0EF0;
  void v8[4] = a2;
  v8[5] = a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  int v6 = v5;
  unint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v4;
  BOOL v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

uint64_t *sub_10048910C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  int v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = v2 + 168;
  double result = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(v4 + 64);
    unint64_t v7 = (uint64_t *)v4;
    int v8 = result;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        unint64_t v7 = v8;
      }
      int v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4 && v6 >= *((_DWORD *)v7 + 8))
    {
      sub_1000389F8(result, v6);
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 0x40000000;
      v12[2] = sub_10048921C;
      v12[3] = &unk_1019D0EC8;
      _DWORD v12[4] = *(void *)(a1 + 32);
      void v12[5] = _NSConcreteStackBlock;
      v12[6] = 0x40000000;
      v12[7] = sub_100D34D9C;
      void v12[8] = &unk_101A528B8;
      v12[9] = v12;
      return (uint64_t *)VinylCommandDriver::getTapeEid();
    }
  }
  return result;
}

uint64_t sub_10048921C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v4 = 0;
  if (*(unsigned char *)a2)
  {
    long long v5 = *(_OWORD *)(a2 + 1);
    char v4 = 1;
  }
  return (*(uint64_t (**)(uint64_t, char *))(v2 + 16))(v2, &v4);
}

void sub_100489298(uint64_t a1, uint64_t a2)
{
}

void sub_1004892A0(void *a1, long long *a2, long long *a3, uint64_t a4)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  v12[2] = sub_100489458;
  v12[3] = &unk_1019D0F18;
  void v12[5] = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v13, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v13 = *a2;
    uint64_t v14 = *((void *)a2 + 2);
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long __p = *a3;
    uint64_t v16 = *((void *)a3 + 2);
  }
  _DWORD v12[4] = a4;
  unint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (!v7 || (uint64_t v8 = a1[1], (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
    sub_100088B9C();
  }
  BOOL v10 = v9;
  uint64_t v11 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v8;
  char v18 = v10;
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v12;
  dispatch_async(v11, block);
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_10004D2C8(v10);
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)v13);
  }
}

void sub_100489438(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100489458(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  long long v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = v2 + 168;
  uint64_t v3 = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(v4 + 64);
    unint64_t v7 = (uint64_t *)v4;
    uint64_t v8 = v3;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        unint64_t v7 = v8;
      }
      uint64_t v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4 && v6 >= *((_DWORD *)v7 + 8))
    {
      uint64_t v12 = *sub_1000389F8(v3, v6);
      long long v13 = *(void (***)(void, void))(a1 + 32);
      sub_100D34E20(v12, a1 + 48, a1 + 72, v13);
    }
  }
}

void sub_1004894F0(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
}

void sub_1004894F8(void *a1, long long *a2, uint64_t a3)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  int v10[2] = sub_100489654;
  v10[3] = &unk_1019D0F50;
  v10[5] = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v12 = *((void *)a2 + 2);
  }
  v10[4] = a3;
  long long v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  int v9 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v6;
  uint64_t v14 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v10;
  dispatch_async(v9, block);
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_10004D2C8(v8);
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)__p);
  }
}

void sub_100489654(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  long long v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = v2 + 168;
  uint64_t v3 = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(v4 + 64);
    unint64_t v7 = (uint64_t *)v4;
    uint64_t v8 = v3;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        unint64_t v7 = v8;
      }
      uint64_t v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4 && v6 >= *((_DWORD *)v7 + 8))
    {
      uint64_t v12 = *sub_1000389F8(v3, v6);
      if (*(char *)(a1 + 71) < 0)
      {
        sub_10004FC84(__p, *(void **)(a1 + 48), *(void *)(a1 + 56));
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)(a1 + 48);
        uint64_t v14 = *(void *)(a1 + 64);
      }
      sub_100D34EB4(v12, (uint64_t)__p, *(void *)(a1 + 32));
      if (SHIBYTE(v14) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_100489718(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100489734(uint64_t a1, uint64_t a2)
{
  double result = (void *)(a1 + 48);
  if (*(char *)(a2 + 71) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  long long v3 = *(_OWORD *)(a2 + 48);
  result[2] = *(void *)(a2 + 64);
  *(_OWORD *)double result = v3;
  return result;
}

void sub_100489764(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
}

void sub_100489778(uint64_t a1, long long *a2, uint64_t a3)
{
}

void sub_100489780(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_100489898;
  void v8[3] = &unk_1019D0FB0;
  void v8[4] = a2;
  v8[5] = a1;
  long long v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  int v6 = v5;
  unint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v4;
  BOOL v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

void sub_100489898(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(uint64_t **)(v1 + 168);
  if (v2)
  {
    int v3 = *(_DWORD *)(v1 + 232);
    uint64_t v4 = v1 + 168;
    uint64_t v5 = *(void *)(v1 + 168);
    do
    {
      int v6 = *(_DWORD *)(v5 + 32);
      BOOL v7 = v6 < v3;
      if (v6 >= v3) {
        uint64_t v8 = (uint64_t *)v5;
      }
      else {
        uint64_t v8 = (uint64_t *)(v5 + 8);
      }
      if (!v7) {
        uint64_t v4 = v5;
      }
      uint64_t v5 = *v8;
    }
    while (*v8);
    if (v4 != v1 + 168 && v3 >= *(_DWORD *)(v4 + 32))
    {
      int v9 = sub_1000389F8(v2, v3);
      sub_100D34F8C(*v9);
    }
  }
}

void sub_100489968(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *(unsigned __int8 *)a2;
  if (v5 == 1)
  {
    *(void *)uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    if (sub_10074B41C(a2 + 1))
    {
      int v6 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I fail parse profiles", buf, 2u);
      }
      uint64_t v7 = *(void *)(a1 + 32);
      char v16 = 2;
      char v17 = 1;
      (*(void (**)(void))(v7 + 16))();
      char v16 = 0;
    }
    else
    {
      *(void *)long long buf = 0;
      sub_1003EEC34(v21, (NSMutableArray **)buf);
      BOOL v10 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)char v20 = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I made profiles", v20, 2u);
      }
      uint64_t v11 = *(void *)(a1 + 32);
      v18[0] = 0;
      sub_100493D20((uint64_t)v18, (const void **)buf);
      (*(void (**)(uint64_t, unsigned char *))(v11 + 16))(v11, v18);
      if (v18[0] == 1) {
        sub_100044D00(&v19);
      }
      v18[0] = 0;
      sub_100044D00((const void **)buf);
    }
    *(void *)long long buf = v21;
    sub_1000C57C8((void ***)buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v21 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I fail force tape profile", v21, 2u);
      int v5 = *(unsigned __int8 *)a2;
    }
    if (v5 != 2)
    {
      exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      if (v5 == 1)
      {
        ctu::ResultIsNotError::ResultIsNotError(exception);
        uint64_t v14 = &ctu::ResultIsNotError::~ResultIsNotError;
      }
      else
      {
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        uint64_t v14 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
      }
      __cxa_throw(exception, v13, (void (*)(void *))v14);
    }
    uint64_t v9 = *(void *)(a1 + 32);
    unsigned __int8 v15 = *((unsigned char *)a2 + 8);
    (*(void (**)(void))(v9 + 16))();
  }
}

void sub_100489BD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, const void *a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a13 == 1) {
    sub_100044D00(&a14);
  }
  sub_100044D00((const void **)(v17 - 48));
  *(void *)(v17 - 48) = &a17;
  sub_1000C57C8((void ***)(v17 - 48));
  _Unwind_Resume(a1);
}

void sub_100489C74(uint64_t a1, uint64_t a2)
{
}

void sub_100489C7C(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_100489D94;
  void v8[3] = &unk_1019D1000;
  void v8[4] = a2;
  v8[5] = a1;
  int v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  int v6 = v5;
  uint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v4;
  BOOL v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

void sub_100489D94(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(uint64_t **)(v1 + 168);
  if (v2)
  {
    int v3 = *(_DWORD *)(v1 + 232);
    uint64_t v4 = v1 + 168;
    uint64_t v5 = *(void *)(v1 + 168);
    do
    {
      int v6 = *(_DWORD *)(v5 + 32);
      BOOL v7 = v6 < v3;
      if (v6 >= v3) {
        uint64_t v8 = (uint64_t *)v5;
      }
      else {
        uint64_t v8 = (uint64_t *)(v5 + 8);
      }
      if (!v7) {
        uint64_t v4 = v5;
      }
      uint64_t v5 = *v8;
    }
    while (*v8);
    if (v4 != v1 + 168 && v3 >= *(_DWORD *)(v4 + 32))
    {
      uint64_t v9 = sub_1000389F8(v2, v3);
      sub_100D35858(*v9);
    }
  }
}

void sub_100489E64(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *(unsigned __int8 *)a2;
  if (v5 == 1)
  {
    *(void *)std::string::size_type v36 = 0;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    uint64_t v33 = 0;
    unint64_t v34 = 0;
    uint64_t v35 = 0;
    if (sub_10074D7E0(a2 + 1, (uint64_t)v36, (unint64_t *)&v33))
    {
      int v6 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I fail parse euicc info1", buf, 2u);
      }
      uint64_t v7 = *(void *)(a1 + 32);
      char v20 = 2;
      char v21 = 1;
      (*(void (**)(void))(v7 + 16))();
      char v20 = 0;
LABEL_31:
      if (v33)
      {
        unint64_t v34 = v33;
        operator delete(v33);
      }
      if (SHIBYTE(v38) < 0) {
        operator delete(*(void **)v36);
      }
      return;
    }
    xpc_object_t v32 = 0;
    xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v11 = v10;
    if (v10)
    {
      xpc_object_t v32 = v10;
    }
    else
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v32 = v11;
      if (!v11)
      {
        xpc_object_t v12 = xpc_null_create();
        xpc_object_t v11 = 0;
        goto LABEL_17;
      }
    }
    if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v11);
LABEL_18:
      xpc_release(v11);
      if (v38 >= 0) {
        long long v13 = v36;
      }
      else {
        long long v13 = *(uint8_t **)v36;
      }
      xpc_object_t v30 = xpc_string_create((const char *)v13);
      if (!v30) {
        xpc_object_t v30 = xpc_null_create();
      }
      *(void *)long long buf = &v32;
      uint64_t v29 = "VerSupport";
      sub_100035E70((uint64_t)buf, &v30, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v30);
      xpc_object_t v30 = 0;
      xpc_object_t v26 = xpc_data_create(v33, v34 - v33);
      if (!v26) {
        xpc_object_t v26 = xpc_null_create();
      }
      *(void *)long long buf = &v32;
      uint64_t v29 = "PreferredSigningKey";
      sub_100035E70((uint64_t)buf, &v26, &v27);
      xpc_release(v27);
      xpc_object_t v27 = 0;
      xpc_release(v26);
      xpc_object_t v26 = 0;
      *(void *)long long buf = 0;
      xpc_object_t v24 = v32;
      if (v32) {
        xpc_retain(v32);
      }
      else {
        xpc_object_t v24 = xpc_null_create();
      }
      xpc::bridge((uint64_t *)&v25, (xpc *)&v24, v14);
      sub_10004EFE4(buf, &v25);
      sub_1000577C4(&v25);
      xpc_release(v24);
      uint64_t v15 = *(void *)(a1 + 32);
      v22[0] = 0;
      sub_1000C61E0((uint64_t)v22, (const void **)buf);
      (*(void (**)(uint64_t, char *))(v15 + 16))(v15, v22);
      if (v22[0] == 1) {
        sub_100057D78(&v23);
      }
      v22[0] = 0;
      sub_100057D78((const void **)buf);
      xpc_release(v32);
      goto LABEL_31;
    }
    xpc_object_t v12 = xpc_null_create();
LABEL_17:
    xpc_object_t v32 = v12;
    goto LABEL_18;
  }
  uint64_t v8 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string::size_type v36 = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I fail euicc info1", v36, 2u);
    int v5 = *(unsigned __int8 *)a2;
  }
  if (v5 != 2)
  {
    exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
    if (v5 == 1)
    {
      ctu::ResultIsNotError::ResultIsNotError(exception);
      char v18 = &ctu::ResultIsNotError::~ResultIsNotError;
    }
    else
    {
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
      char v18 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
    }
    __cxa_throw(exception, v17, (void (*)(void *))v18);
  }
  uint64_t v9 = *(void *)(a1 + 32);
  unsigned __int8 v19 = *((unsigned char *)a2 + 8);
  (*(void (**)(void))(v9 + 16))();
}

void sub_10048A22C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, xpc_object_t object, char a16, uint64_t a17, uint64_t a18, const void *a19)
{
  if (a13 == 1) {
    sub_100057D78((const void **)&a14);
  }
  sub_100057D78(&a19);
  xpc_release(*(xpc_object_t *)(v19 - 96));
  char v21 = *(void **)(v19 - 88);
  if (v21)
  {
    *(void *)(v19 - 80) = v21;
    operator delete(v21);
  }
  if (*(char *)(v19 - 41) < 0) {
    operator delete(*(void **)(v19 - 64));
  }
  _Unwind_Resume(a1);
}

void sub_10048A330(uint64_t a1, uint64_t a2)
{
}

void sub_10048A338(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_10048A450;
  void v8[3] = &unk_1019D1050;
  void v8[4] = a2;
  v8[5] = a1;
  int v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  int v6 = v5;
  uint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v4;
  xpc_object_t v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

uint64_t *sub_10048A450(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  double result = *(uint64_t **)(v1 + 168);
  if (result)
  {
    int v3 = *(_DWORD *)(v1 + 232);
    uint64_t v4 = v1 + 168;
    uint64_t v5 = *(void *)(v1 + 168);
    do
    {
      int v6 = *(_DWORD *)(v5 + 32);
      BOOL v7 = v6 < v3;
      if (v6 >= v3) {
        uint64_t v8 = (uint64_t *)v5;
      }
      else {
        uint64_t v8 = (uint64_t *)(v5 + 8);
      }
      if (!v7) {
        uint64_t v4 = v5;
      }
      uint64_t v5 = *v8;
    }
    while (*v8);
    if (v4 != v1 + 168 && v3 >= *(_DWORD *)(v4 + 32))
    {
      uint64_t v9 = sub_1000389F8(result, v3);
      return (uint64_t *)sub_100D354D0(*v9);
    }
  }
  return result;
}

void sub_10048A520(uint64_t a1, unsigned __int8 *a2)
{
  int v4 = *a2;
  if (v4 == 1)
  {
    xpc_object_t v58 = 0;
    xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v6 = v5;
    if (v5)
    {
      xpc_object_t v58 = v5;
    }
    else
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v58 = v6;
      if (!v6)
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v6 = 0;
        goto LABEL_13;
      }
    }
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v6);
      goto LABEL_14;
    }
    xpc_object_t v9 = xpc_null_create();
LABEL_13:
    xpc_object_t v58 = v9;
LABEL_14:
    xpc_release(v6);
    int v10 = *a2;
    if (v10 == 1)
    {
      xpc_object_t v56 = xpc_int64_create(a2[1]);
      if (!v56) {
        xpc_object_t v56 = xpc_null_create();
      }
      *(void *)long long buf = &v58;
      int v55 = "kGsmSupportedReleaseIndex";
      sub_100035E70((uint64_t)buf, &v56, &v57);
      xpc_release(v57);
      xpc_object_t v57 = 0;
      xpc_release(v56);
      xpc_object_t v56 = 0;
      int v11 = *a2;
      if (v11 == 1)
      {
        xpc_object_t v52 = xpc_int64_create(a2[4]);
        if (!v52) {
          xpc_object_t v52 = xpc_null_create();
        }
        *(void *)long long buf = &v58;
        int v55 = "kUtranSupportedReleaseIndex";
        sub_100035E70((uint64_t)buf, &v52, &v53);
        xpc_release(v53);
        xpc_object_t v53 = 0;
        xpc_release(v52);
        xpc_object_t v52 = 0;
        int v12 = *a2;
        if (v12 == 1)
        {
          xpc_object_t v50 = xpc_int64_create(a2[7]);
          if (!v50) {
            xpc_object_t v50 = xpc_null_create();
          }
          *(void *)long long buf = &v58;
          int v55 = "kCdma2000onexSupportedReleaseIndex";
          sub_100035E70((uint64_t)buf, &v50, &v51);
          xpc_release(v51);
          xpc_object_t v51 = 0;
          xpc_release(v50);
          xpc_object_t v50 = 0;
          int v13 = *a2;
          if (v13 == 1)
          {
            xpc_object_t v48 = xpc_int64_create(a2[10]);
            if (!v48) {
              xpc_object_t v48 = xpc_null_create();
            }
            *(void *)long long buf = &v58;
            int v55 = "kCdma2000hrpdSupportedReleaseIndex";
            sub_100035E70((uint64_t)buf, &v48, &v49);
            xpc_release(v49);
            xpc_object_t v49 = 0;
            xpc_release(v48);
            xpc_object_t v48 = 0;
            int v14 = *a2;
            if (v14 == 1)
            {
              xpc_object_t v46 = xpc_int64_create(a2[13]);
              if (!v46) {
                xpc_object_t v46 = xpc_null_create();
              }
              *(void *)long long buf = &v58;
              int v55 = "kCdma2000ehrpdSupportedReleaseIndex";
              sub_100035E70((uint64_t)buf, &v46, &object);
              xpc_release(object);
              xpc_object_t object = 0;
              xpc_release(v46);
              xpc_object_t v46 = 0;
              int v15 = *a2;
              if (v15 == 1)
              {
                xpc_object_t v44 = xpc_int64_create(a2[16]);
                if (!v44) {
                  xpc_object_t v44 = xpc_null_create();
                }
                *(void *)long long buf = &v58;
                int v55 = "kEutranSupportedReleaseIndex";
                sub_100035E70((uint64_t)buf, &v44, &v45);
                xpc_release(v45);
                xpc_object_t v45 = 0;
                xpc_release(v44);
                xpc_object_t v44 = 0;
                int v16 = *a2;
                if (v16 == 1)
                {
                  xpc_object_t v42 = xpc_int64_create(a2[19]);
                  if (!v42) {
                    xpc_object_t v42 = xpc_null_create();
                  }
                  *(void *)long long buf = &v58;
                  int v55 = "kContactlessSupportedReleaseIndex";
                  sub_100035E70((uint64_t)buf, &v42, &v43);
                  xpc_release(v43);
                  xpc_object_t v43 = 0;
                  xpc_release(v42);
                  xpc_object_t v42 = 0;
                  int v17 = *a2;
                  if (v17 == 1)
                  {
                    xpc_object_t v40 = xpc_int64_create(a2[22]);
                    if (!v40) {
                      xpc_object_t v40 = xpc_null_create();
                    }
                    *(void *)long long buf = &v58;
                    int v55 = "kRspCrlSupportedVersionIndex";
                    sub_100035E70((uint64_t)buf, &v40, &v41);
                    xpc_release(v41);
                    xpc_object_t v41 = 0;
                    xpc_release(v40);
                    xpc_object_t v40 = 0;
                    int v18 = *a2;
                    if (v18 == 1)
                    {
                      xpc_object_t v38 = xpc_int64_create(a2[25]);
                      if (!v38) {
                        xpc_object_t v38 = xpc_null_create();
                      }
                      *(void *)long long buf = &v58;
                      int v55 = "kNrEpcSupportedReleaseIndex";
                      sub_100035E70((uint64_t)buf, &v38, &v39);
                      xpc_release(v39);
                      xpc_object_t v39 = 0;
                      xpc_release(v38);
                      xpc_object_t v38 = 0;
                      int v19 = *a2;
                      if (v19 == 1)
                      {
                        xpc_object_t v36 = xpc_int64_create(a2[28]);
                        if (!v36) {
                          xpc_object_t v36 = xpc_null_create();
                        }
                        *(void *)long long buf = &v58;
                        int v55 = "kNr5gcSupportedReleaseIndex";
                        sub_100035E70((uint64_t)buf, &v36, &v37);
                        xpc_release(v37);
                        xpc_object_t v37 = 0;
                        xpc_release(v36);
                        xpc_object_t v36 = 0;
                        int v20 = *a2;
                        if (v20 == 1)
                        {
                          xpc_object_t v34 = xpc_int64_create(a2[31]);
                          if (!v34) {
                            xpc_object_t v34 = xpc_null_create();
                          }
                          *(void *)long long buf = &v58;
                          int v55 = "kEutran5gcSupportedReleaseIndex";
                          sub_100035E70((uint64_t)buf, &v34, &v35);
                          xpc_release(v35);
                          xpc_object_t v35 = 0;
                          xpc_release(v34);
                          xpc_object_t v34 = 0;
                          *(void *)long long buf = 0;
                          xpc_object_t v32 = v58;
                          if (v58) {
                            xpc_retain(v58);
                          }
                          else {
                            xpc_object_t v32 = xpc_null_create();
                          }
                          xpc::bridge((uint64_t *)&v33, (xpc *)&v32, v21);
                          sub_10004EFE4(buf, &v33);
                          sub_1000577C4(&v33);
                          xpc_release(v32);
                          uint64_t v22 = *(void *)(a1 + 32);
                          v30[0] = 0;
                          sub_1000C61E0((uint64_t)v30, (const void **)buf);
                          (*(void (**)(uint64_t, unsigned char *))(v22 + 16))(v22, v30);
                          if (v30[0] == 1) {
                            sub_100057D78(&v31);
                          }
                          v30[0] = 0;
                          sub_100057D78((const void **)buf);
                          xpc_release(v58);
                          return;
                        }
                        if (v20 == 2)
                        {
                          exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                          xpc_object_t v27 = &ctu::ResultIsError::~ResultIsError;
                          ctu::ResultIsError::ResultIsError(exception);
                          goto LABEL_77;
                        }
                        exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                        xpc_object_t v27 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
LABEL_91:
LABEL_92:
                        __cxa_throw(exception, v28, (void (*)(void *))v27);
                      }
                      if (v19 != 2)
                      {
                        exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                        xpc_object_t v27 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
                        goto LABEL_91;
                      }
                      exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                      xpc_object_t v27 = &ctu::ResultIsError::~ResultIsError;
                      ctu::ResultIsError::ResultIsError(exception);
                    }
                    else
                    {
                      if (v18 != 2)
                      {
                        exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                        xpc_object_t v27 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
                        goto LABEL_91;
                      }
                      exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                      xpc_object_t v27 = &ctu::ResultIsError::~ResultIsError;
                      ctu::ResultIsError::ResultIsError(exception);
                    }
                  }
                  else
                  {
                    if (v17 != 2)
                    {
                      exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                      xpc_object_t v27 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
                      goto LABEL_91;
                    }
                    exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                    xpc_object_t v27 = &ctu::ResultIsError::~ResultIsError;
                    ctu::ResultIsError::ResultIsError(exception);
                  }
                }
                else
                {
                  if (v16 != 2)
                  {
                    exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                    xpc_object_t v27 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                    ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
                    goto LABEL_91;
                  }
                  exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                  xpc_object_t v27 = &ctu::ResultIsError::~ResultIsError;
                  ctu::ResultIsError::ResultIsError(exception);
                }
              }
              else
              {
                if (v15 != 2)
                {
                  exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                  xpc_object_t v27 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                  ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
                  goto LABEL_91;
                }
                exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                xpc_object_t v27 = &ctu::ResultIsError::~ResultIsError;
                ctu::ResultIsError::ResultIsError(exception);
              }
            }
            else
            {
              if (v14 != 2)
              {
                exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                xpc_object_t v27 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
                goto LABEL_91;
              }
              exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
              xpc_object_t v27 = &ctu::ResultIsError::~ResultIsError;
              ctu::ResultIsError::ResultIsError(exception);
            }
          }
          else
          {
            if (v13 != 2)
            {
              exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
              xpc_object_t v27 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
              ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
              goto LABEL_91;
            }
            exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
            xpc_object_t v27 = &ctu::ResultIsError::~ResultIsError;
            ctu::ResultIsError::ResultIsError(exception);
          }
        }
        else
        {
          if (v12 != 2)
          {
            exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
            xpc_object_t v27 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
            ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
            goto LABEL_91;
          }
          exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          xpc_object_t v27 = &ctu::ResultIsError::~ResultIsError;
          ctu::ResultIsError::ResultIsError(exception);
        }
      }
      else
      {
        if (v11 != 2)
        {
          exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          xpc_object_t v27 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
          ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
          goto LABEL_91;
        }
        exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        xpc_object_t v27 = &ctu::ResultIsError::~ResultIsError;
        ctu::ResultIsError::ResultIsError(exception);
      }
    }
    else
    {
      if (v10 != 2)
      {
        exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        xpc_object_t v27 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        goto LABEL_91;
      }
      exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
      xpc_object_t v27 = &ctu::ResultIsError::~ResultIsError;
      ctu::ResultIsError::ResultIsError(exception);
    }
LABEL_77:
    goto LABEL_92;
  }
  BOOL v7 = *(NSObject **)(*(void *)(a1 + 40) + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I fail GetTapeDeviceCaps", buf, 2u);
    int v4 = *a2;
  }
  if (v4 != 2)
  {
    uint64_t v23 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
    if (v4 == 1)
    {
      ctu::ResultIsNotError::ResultIsNotError(v23);
      unsigned int v25 = &ctu::ResultIsNotError::~ResultIsNotError;
    }
    else
    {
      ctu::ResultIsEmptyError::ResultIsEmptyError(v23);
      unsigned int v25 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
    }
    __cxa_throw(v23, v24, (void (*)(void *))v25);
  }
  uint64_t v8 = *(void *)(a1 + 32);
  unsigned __int8 v29 = a2[1];
  (*(void (**)(void))(v8 + 16))();
}

void sub_10048AEE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, char a11, uint64_t a12, xpc_object_t object, char a14)
{
  __cxa_free_exception(v14);
  xpc_release(*(xpc_object_t *)(v15 - 56));
  _Unwind_Resume(a1);
}

void sub_10048B080(uint64_t a1, uint64_t a2)
{
}

void sub_10048B088(void *a1, long long *a2, uint64_t a3)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  v12[2] = sub_10048B25C;
  v12[3] = &unk_1019D1070;
  _DWORD v12[4] = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v14 = *((void *)a2 + 2);
  }
  sub_100493DE0((uint64_t)v15, a3);
  xpc_object_t v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  xpc_object_t v9 = a1[3];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  int v10[2] = sub_10048E42C;
  v10[3] = &unk_1019D14E0;
  v10[5] = v6;
  int v11 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  v10[4] = v12;
  dispatch_async(v9, v10);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v8);
  sub_100493E78(v15);
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)__p);
  }
}

void sub_10048B224(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
}

void sub_10048B25C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(uint64_t **)(v2 + 168);
  if (v3)
  {
    int v4 = *(_DWORD *)(v2 + 232);
    uint64_t v5 = v2 + 168;
    uint64_t v6 = *(void *)(v2 + 168);
    do
    {
      int v7 = *(_DWORD *)(v6 + 32);
      BOOL v8 = v7 < v4;
      if (v7 >= v4) {
        xpc_object_t v9 = (uint64_t *)v6;
      }
      else {
        xpc_object_t v9 = (uint64_t *)(v6 + 8);
      }
      if (!v8) {
        uint64_t v5 = v6;
      }
      uint64_t v6 = *v9;
    }
    while (*v9);
    if (v5 != v2 + 168 && v4 >= *(_DWORD *)(v5 + 32))
    {
      uint64_t v10 = *sub_1000389F8(v3, v4);
      int v11 = (long long *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0)
      {
        sub_10004FC84(&__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
      }
      else
      {
        long long __p = *v11;
        uint64_t v15 = *(void *)(a1 + 56);
      }
      sub_100493DE0((uint64_t)v16, a1 + 64);
      int v18 = 0;
      int v12 = operator new(0x48uLL);
      int v13 = v12;
      *int v12 = off_1019D1FF0;
      v12[1] = v2;
      if (SHIBYTE(v15) < 0)
      {
        sub_10004FC84((unsigned char *)v12 + 16, (void *)__p, *((unint64_t *)&__p + 1));
      }
      else
      {
        *((_OWORD *)v12 + 1) = __p;
        _DWORD v12[4] = v15;
      }
      sub_100493DE0((uint64_t)(v13 + 5), (uint64_t)v16);
      int v18 = v13;
      sub_100D35D98(v10, v11, (uint64_t)v17);
      sub_100493E78(v17);
      sub_100493E78(v16);
      if (SHIBYTE(v15) < 0) {
        operator delete((void *)__p);
      }
    }
  }
}

void sub_10048B3FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  operator delete(v18);
  sub_10048B468((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void sub_10048B450(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x10048B448);
}

uint64_t sub_10048B468(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_10048B4A4(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }
  return sub_100493DE0(a1 + 64, a2 + 64);
}

void sub_10048B50C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 63) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10048B528(uint64_t a1)
{
  sub_100493E78((void *)(a1 + 64));
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    operator delete(v2);
  }
}

void sub_10048B578(uint64_t a1, long long *a2, uint64_t a3)
{
}

void sub_10048B580(void *a1, long long *a2, long long *a3, uint64_t a4)
{
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 1174405120;
  v14[2] = sub_10048B7B4;
  v14[3] = &unk_1019D10A0;
  void v14[4] = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v15, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v15 = *a2;
    uint64_t v16 = *((void *)a2 + 2);
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long __p = *a3;
    uint64_t v18 = *((void *)a3 + 2);
  }
  sub_1000C7494((uint64_t)v19, a4);
  int v7 = (std::__shared_weak_count *)a1[2];
  if (!v7 || (uint64_t v8 = a1[1], (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v10 = v9;
  int v11 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v8;
  int v13 = v10;
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v14;
  dispatch_async(v11, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_10004D2C8(v10);
  sub_1000C752C(v19);
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)v15);
  }
}

void sub_10048B764(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_10048B7B4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = v2 + 168;
  double result = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(v4 + 64);
    int v7 = (uint64_t *)v4;
    uint64_t v8 = result;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        int v11 = (uint64_t **)v8;
      }
      else {
        int v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        int v7 = v8;
      }
      uint64_t v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4 && v6 >= *((_DWORD *)v7 + 8))
    {
      int v12 = (void *)*sub_1000389F8(result, v6);
      sub_1000C7494((uint64_t)v13, a1 + 88);
      sub_100D35FF4(v12, a1 + 40, a1 + 64, (uint64_t)v13);
      return sub_1000C752C(v13);
    }
  }
  return result;
}

void sub_10048B880(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C752C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_10048B89C(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
}

void sub_10048B8A4(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_10048B9BC;
  void v8[3] = &unk_1019D1100;
  void v8[4] = a2;
  v8[5] = a1;
  int v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  int v6 = v5;
  int v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v4;
  BOOL v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

void *sub_10048B9BC(uint64_t a1)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_10048BAC0;
  uint64_t v4[3] = &unk_1019D10D8;
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  int v6 = 0;
  void v4[4] = v1;
  v5[0] = off_1019D2070;
  v5[1] = _Block_copy(v4);
  int v6 = v5;
  sub_100480F48(v2, 1, (uint64_t)v5);
  return sub_1000DBADC(v5);
}

void sub_10048BAA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1000DBADC((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_10048BAC0(uint64_t a1, int a2, const std::string *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (a2)
  {
    v7[0] = 0;
    sub_100493D40((uint64_t)v7, a3);
    (*(void (**)(uint64_t, unsigned char *))(v3 + 16))(v3, v7);
    if (v7[0] == 1 && (v8[23] & 0x80000000) != 0)
    {
      uint64_t v4 = (void **)v8;
LABEL_7:
      operator delete(*v4);
    }
  }
  else
  {
    v5[0] = 2;
    uint64_t v4 = (void **)v6;
    v6[0] = 3;
    (*(void (**)(uint64_t, char *))(v3 + 16))(v3, v5);
    if (v5[0] == 1 && (v6[23] & 0x80000000) != 0) {
      goto LABEL_7;
    }
  }
}

void sub_10048BB78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a9 == 1 && a15 < 0) {
    operator delete(*v22);
  }
  _Unwind_Resume(exception_object);
}

void sub_10048BBC8(uint64_t a1, uint64_t a2)
{
}

void sub_10048BBD0(void *a1, uint64_t a2, uint64_t a3)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_10048BCEC;
  v9[3] = &unk_1019D1128;
  void v9[5] = a1;
  v9[6] = a2;
  v9[4] = a3;
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (!v4 || (v5 = a1[1], (int v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  int v7 = v6;
  uint64_t v8 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v5;
  int v11 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v8, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v7);
}

uint64_t sub_10048BCEC(void *a1)
{
  uint64_t v2 = *(void *)(a1[5] + 144);
  if (v2)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t, void))(*(void *)v2 + 32))(v2, a1[6]);
    uint64_t v4 = a1[4];
    v9[0] = 1;
    uint64_t v10 = v3;
    uint64_t v11 = v5;
    return (*(uint64_t (**)(uint64_t, char *))(v4 + 16))(v4, v9);
  }
  else
  {
    uint64_t v7 = a1[4];
    v8[0] = 2;
    v8[8] = 3;
    return (*(uint64_t (**)(uint64_t, unsigned char *))(v7 + 16))(v7, v8);
  }
}

void sub_10048BD94(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_10048BD9C(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_10048BEB4;
  void v8[3] = &unk_1019D1178;
  void v8[4] = a2;
  v8[5] = a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  int v6 = v5;
  uint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v4;
  uint64_t v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

void sub_10048BEB4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(uint64_t **)(v1 + 168);
  if (v2)
  {
    int v3 = *(_DWORD *)(v1 + 232);
    uint64_t v4 = v1 + 168;
    uint64_t v5 = *(void *)(v1 + 168);
    do
    {
      int v6 = *(_DWORD *)(v5 + 32);
      BOOL v7 = v6 < v3;
      if (v6 >= v3) {
        uint64_t v8 = (uint64_t *)v5;
      }
      else {
        uint64_t v8 = (uint64_t *)(v5 + 8);
      }
      if (!v7) {
        uint64_t v4 = v5;
      }
      uint64_t v5 = *v8;
    }
    while (*v8);
    if (v4 != v1 + 168 && v3 >= *(_DWORD *)(v4 + 32))
    {
      int v9 = sub_1000389F8(v2, v3);
      sub_100D36A34(*v9);
    }
  }
}

void sub_10048BF84(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *a2;
  if (v5 == 1)
  {
    *(void *)xpc_object_t v30 = 0;
    long long v31 = 0;
    uint64_t v32 = 0;
    if (sub_10074DF20((void *)a2 + 1, v30))
    {
      int v6 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I fail parse TapeEuiccChallenge", buf, 2u);
      }
      uint64_t v7 = *(void *)(a1 + 32);
      char v19 = 2;
      char v20 = 1;
      (*(void (**)(void))(v7 + 16))();
      char v19 = 0;
LABEL_26:
      if (*(void *)v30)
      {
        long long v31 = *(void **)v30;
        operator delete(*(void **)v30);
      }
      return;
    }
    xpc_object_t v29 = 0;
    xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v11 = v10;
    if (v10)
    {
      xpc_object_t v29 = v10;
    }
    else
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v29 = v11;
      if (!v11)
      {
        xpc_object_t v12 = xpc_null_create();
        xpc_object_t v11 = 0;
        goto LABEL_17;
      }
    }
    if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v11);
LABEL_18:
      xpc_release(v11);
      xpc_object_t object = xpc_data_create(*(const void **)v30, (size_t)v31 - *(void *)v30);
      if (!object) {
        xpc_object_t object = xpc_null_create();
      }
      *(void *)long long buf = &v29;
      xpc_object_t v26 = "EuiccChallenge";
      sub_100035E70((uint64_t)buf, &object, &v28);
      xpc_release(v28);
      xpc_object_t v28 = 0;
      xpc_release(object);
      xpc_object_t object = 0;
      *(void *)long long buf = 0;
      xpc_object_t v23 = v29;
      if (v29) {
        xpc_retain(v29);
      }
      else {
        xpc_object_t v23 = xpc_null_create();
      }
      xpc::bridge((uint64_t *)&v24, (xpc *)&v23, v13);
      sub_10004EFE4(buf, &v24);
      sub_1000577C4(&v24);
      xpc_release(v23);
      uint64_t v14 = *(void *)(a1 + 32);
      v21[0] = 0;
      sub_1000C61E0((uint64_t)v21, (const void **)buf);
      (*(void (**)(uint64_t, unsigned char *))(v14 + 16))(v14, v21);
      if (v21[0] == 1) {
        sub_100057D78(&v22);
      }
      v21[0] = 0;
      sub_100057D78((const void **)buf);
      xpc_release(v29);
      goto LABEL_26;
    }
    xpc_object_t v12 = xpc_null_create();
LABEL_17:
    xpc_object_t v29 = v12;
    goto LABEL_18;
  }
  uint64_t v8 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)xpc_object_t v30 = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I fail get TapeEuiccChallenge", v30, 2u);
    int v5 = *a2;
  }
  if (v5 != 2)
  {
    exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
    if (v5 == 1)
    {
      ctu::ResultIsNotError::ResultIsNotError(exception);
      int v17 = &ctu::ResultIsNotError::~ResultIsNotError;
    }
    else
    {
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
      int v17 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
    }
    __cxa_throw(exception, v16, (void (*)(void *))v17);
  }
  uint64_t v9 = *(void *)(a1 + 32);
  unsigned __int8 v18 = a2[8];
  (*(void (**)(void))(v9 + 16))();
}

void sub_10048C2CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, xpc_object_t object, char a16, int a17, const void *a18)
{
  if (a13 == 1) {
    sub_100057D78((const void **)&a14);
  }
  sub_100057D78(&a18);
  xpc_release(*(xpc_object_t *)(v18 - 72));
  char v20 = *(void **)(v18 - 64);
  if (v20)
  {
    *(void *)(v18 - 56) = v20;
    operator delete(v20);
  }
  _Unwind_Resume(a1);
}

void sub_10048C3B4(uint64_t a1, uint64_t a2)
{
}

void sub_10048C3BC(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_10048C4D4;
  void v8[3] = &unk_1019D11A0;
  void v8[4] = a2;
  v8[5] = a1;
  int v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  int v6 = v5;
  uint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v4;
  xpc_object_t v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

uint64_t *sub_10048C4D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v4 = *(uint64_t **)(v1 + 168);
  uint64_t v3 = v1 + 168;
  double result = v4;
  if (v4)
  {
    int v5 = *(_DWORD *)(v3 + 64);
    int v6 = (uint64_t *)v3;
    uint64_t v7 = result;
    do
    {
      int v8 = *((_DWORD *)v7 + 8);
      BOOL v9 = v8 < v5;
      if (v8 >= v5) {
        xpc_object_t v10 = (uint64_t **)v7;
      }
      else {
        xpc_object_t v10 = (uint64_t **)(v7 + 1);
      }
      if (!v9) {
        int v6 = v7;
      }
      uint64_t v7 = *v10;
    }
    while (*v10);
    if (v6 != (uint64_t *)v3 && v5 >= *((_DWORD *)v6 + 8))
    {
      uint64_t v11 = *sub_1000389F8(result, v5);
      return (uint64_t *)sub_100D3609C(v11);
    }
  }
  return result;
}

void sub_10048C564(uint64_t a1, uint64_t a2)
{
}

void sub_10048C56C(void *a1, uint64_t a2, uint64_t a3)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  int v10[2] = sub_10048C6B4;
  v10[3] = &unk_1019D11C8;
  v10[5] = a1;
  long long __p = 0;
  xpc_object_t v12 = 0;
  uint64_t v13 = 0;
  sub_10005C928(&__p, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  v10[4] = a3;
  int v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  int v8 = v7;
  BOOL v9 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v6;
  long long v15 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v10;
  dispatch_async(v9, block);
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_10004D2C8(v8);
  if (__p)
  {
    xpc_object_t v12 = __p;
    operator delete(__p);
  }
}

void sub_10048C6B4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  int v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = v2 + 168;
  uint64_t v3 = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(v4 + 64);
    uint64_t v7 = (uint64_t *)v4;
    int v8 = v3;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        uint64_t v7 = v8;
      }
      int v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4 && v6 >= *((_DWORD *)v7 + 8))
    {
      uint64_t v12 = *sub_1000389F8(v3, v6);
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      long long __p = 0;
      sub_10005C928(&__p, *(const void **)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 56) - *(void *)(a1 + 48));
      sub_100D366E4(v12, (char **)&__p);
      if (__p)
      {
        uint64_t v14 = __p;
        operator delete(__p);
      }
    }
  }
}

void sub_10048C764(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10048C780(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_10048C788(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_10033571C((uint64_t)&v5, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10048C8C0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10048C8D8(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v5 = a1;
  char v6 = a2;
  sub_1000DFC90((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10048CA24(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10048CA3C(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_10048CB54;
  void v8[3] = &unk_1019D1200;
  void v8[4] = a2;
  v8[5] = a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  char v6 = v5;
  uint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v4;
  BOOL v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

uint64_t *sub_10048CB54(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v4 = *(uint64_t **)(v1 + 168);
  uint64_t v3 = v1 + 168;
  double result = v4;
  if (v4)
  {
    int v5 = *(_DWORD *)(v3 + 64);
    char v6 = (uint64_t *)v3;
    uint64_t v7 = result;
    do
    {
      int v8 = *((_DWORD *)v7 + 8);
      BOOL v9 = v8 < v5;
      if (v8 >= v5) {
        BOOL v10 = (uint64_t **)v7;
      }
      else {
        BOOL v10 = (uint64_t **)(v7 + 1);
      }
      if (!v9) {
        char v6 = v7;
      }
      uint64_t v7 = *v10;
    }
    while (*v10);
    if (v6 != (uint64_t *)v3 && v5 >= *((_DWORD *)v6 + 8))
    {
      uint64_t v11 = *sub_1000389F8(result, v5);
      return (uint64_t *)sub_100D32718(v11);
    }
  }
  return result;
}

void sub_10048CBE4(uint64_t a1, uint64_t a2)
{
}

void sub_10048CBEC(void *a1, uint64_t a2, uint64_t a3)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  int v10[2] = sub_10048CD34;
  v10[3] = &unk_1019D1228;
  v10[5] = a1;
  long long __p = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_10005C928(&__p, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  v10[4] = a3;
  int v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  int v8 = v7;
  BOOL v9 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v6;
  uint64_t v15 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v10;
  dispatch_async(v9, block);
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_10004D2C8(v8);
  if (__p)
  {
    uint64_t v12 = __p;
    operator delete(__p);
  }
}

void sub_10048CD34(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  int v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = v2 + 168;
  uint64_t v3 = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(v4 + 64);
    uint64_t v7 = (uint64_t *)v4;
    int v8 = v3;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        uint64_t v7 = v8;
      }
      int v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4 && v6 >= *((_DWORD *)v7 + 8))
    {
      uint64_t v12 = *sub_1000389F8(v3, v6);
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      long long __p = 0;
      sub_10005C928(&__p, *(const void **)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 56) - *(void *)(a1 + 48));
      sub_100D32E04(v12, (char **)&__p, *(void *)(a1 + 32));
      if (__p)
      {
        uint64_t v14 = __p;
        operator delete(__p);
      }
    }
  }
}

void sub_10048CDE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10048CE00(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_10048CE08(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_10048CF20;
  v7[3] = &unk_1019D1258;
  v7[4] = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (!v2 || (v3 = a1[1], (uint64_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  int v5 = v4;
  int v6 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v3;
  int v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

void sub_10048CF20(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v4 = *(uint64_t **)(v1 + 168);
  uint64_t v3 = v1 + 168;
  uint64_t v2 = v4;
  if (v4)
  {
    int v5 = *(_DWORD *)(v3 + 64);
    int v6 = (uint64_t *)v3;
    uint64_t v7 = v2;
    do
    {
      int v8 = *((_DWORD *)v7 + 8);
      BOOL v9 = v8 < v5;
      if (v8 >= v5) {
        BOOL v10 = (uint64_t **)v7;
      }
      else {
        BOOL v10 = (uint64_t **)(v7 + 1);
      }
      if (!v9) {
        int v6 = v7;
      }
      uint64_t v7 = *v10;
    }
    while (*v10);
    if (v6 != (uint64_t *)v3 && v5 >= *((_DWORD *)v6 + 8))
    {
      uint64_t v11 = *sub_1000389F8(v2, v5);
      sub_100D32D98(v11);
    }
  }
}

void sub_10048CF9C(uint64_t a1)
{
}

void sub_10048CFA4(void *a1, uint64_t a2, uint64_t a3)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  int v10[2] = sub_10048D0EC;
  v10[3] = &unk_1019D1280;
  v10[5] = a1;
  long long __p = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_10005C928(&__p, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  v10[4] = a3;
  int v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  int v8 = v7;
  BOOL v9 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v6;
  uint64_t v15 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v10;
  dispatch_async(v9, block);
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_10004D2C8(v8);
  if (__p)
  {
    uint64_t v12 = __p;
    operator delete(__p);
  }
}

void sub_10048D0EC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  int v5 = *(uint64_t **)(v2 + 168);
  uint64_t v4 = v2 + 168;
  uint64_t v3 = v5;
  if (v5)
  {
    int v6 = *(_DWORD *)(v4 + 64);
    uint64_t v7 = (uint64_t *)v4;
    int v8 = v3;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v6;
      if (v9 >= v6) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        uint64_t v7 = v8;
      }
      int v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4 && v6 >= *((_DWORD *)v7 + 8))
    {
      uint64_t v12 = *sub_1000389F8(v3, v6);
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      long long __p = 0;
      sub_10005C928(&__p, *(const void **)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 56) - *(void *)(a1 + 48));
      sub_100D3332C(v12, (char **)&__p, *(void *)(a1 + 32));
      if (__p)
      {
        uint64_t v14 = __p;
        operator delete(__p);
      }
    }
  }
}

void sub_10048D19C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10048D1B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_10048D1C0(uint64_t a1@<X0>, void *a2@<X8>)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_10048D31C;
  uint64_t v4[3] = &unk_1019D12B0;
  void v4[4] = a1;
  int v5 = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = sub_100494E90;
  void v6[3] = &unk_1019D2160;
  void v6[4] = a1 + 8;
  v6[5] = &v5;
  uint64_t v7 = v6;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    *a2 = 0;
    a2[1] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    BOOL v10 = sub_100494F0C;
    uint64_t v11 = &unk_1019D21A0;
    uint64_t v12 = a2;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    BOOL v10 = sub_100494EA4;
    uint64_t v11 = &unk_1019D2180;
    uint64_t v12 = a2;
    uint64_t v13 = &v7;
    dispatch_sync(v2, &block);
  }
}

uint64_t *sub_10048D31C@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  *a2 = 0;
  a2[1] = 0;
  int v6 = *(uint64_t **)(v3 + 168);
  uint64_t v5 = v3 + 168;
  double result = v6;
  if (v6)
  {
    int v7 = *(_DWORD *)(v5 + 64);
    int v8 = (uint64_t *)v5;
    uint64_t v9 = result;
    do
    {
      int v10 = *((_DWORD *)v9 + 8);
      BOOL v11 = v10 < v7;
      if (v10 >= v7) {
        uint64_t v12 = (uint64_t **)v9;
      }
      else {
        uint64_t v12 = (uint64_t **)(v9 + 1);
      }
      if (!v11) {
        int v8 = v9;
      }
      uint64_t v9 = *v12;
    }
    while (*v12);
    if (v8 != (uint64_t *)v5 && v7 >= *((_DWORD *)v8 + 8))
    {
      double result = sub_1000389F8(result, v7);
      uint64_t v13 = *(atomic_ullong **)(*result + 160);
      if (v13)
      {
        atomic_ullong v14 = v13[20];
        uint64_t v13 = (atomic_ullong *)v13[21];
        if (v13) {
          atomic_fetch_add_explicit(v13 + 1, 1uLL, memory_order_relaxed);
        }
      }
      else
      {
        atomic_ullong v14 = 0;
      }
      *a2 = v14;
      a2[1] = (atomic_ullong)v13;
    }
  }
  return result;
}

void sub_10048D3B8(uint64_t a1@<X0>, void *a2@<X8>)
{
}

void sub_10048D3C0(uint64_t a1@<X0>, void *a2@<X8>)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_10048D51C;
  uint64_t v4[3] = &unk_1019D12D0;
  void v4[4] = a1;
  uint64_t v5 = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = sub_100494E90;
  void v6[3] = &unk_1019D2160;
  void v6[4] = a1 + 8;
  v6[5] = &v5;
  int v7 = v6;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    *a2 = 0;
    a2[1] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    int v10 = sub_100494F0C;
    BOOL v11 = &unk_1019D21A0;
    uint64_t v12 = a2;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    int v10 = sub_100494EA4;
    BOOL v11 = &unk_1019D2180;
    uint64_t v12 = a2;
    uint64_t v13 = &v7;
    dispatch_sync(v2, &block);
  }
}

uint64_t *sub_10048D51C@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  *a2 = 0;
  a2[1] = 0;
  int v6 = *(uint64_t **)(v3 + 168);
  uint64_t v5 = v3 + 168;
  double result = v6;
  if (v6)
  {
    int v7 = *(_DWORD *)(v5 + 64);
    int v8 = (uint64_t *)v5;
    uint64_t v9 = result;
    do
    {
      int v10 = *((_DWORD *)v9 + 8);
      BOOL v11 = v10 < v7;
      if (v10 >= v7) {
        uint64_t v12 = (uint64_t **)v9;
      }
      else {
        uint64_t v12 = (uint64_t **)(v9 + 1);
      }
      if (!v11) {
        int v8 = v9;
      }
      uint64_t v9 = *v12;
    }
    while (*v12);
    if (v8 != (uint64_t *)v5 && v7 >= *((_DWORD *)v8 + 8))
    {
      double result = sub_1000389F8(result, v7);
      uint64_t v13 = *(atomic_ullong **)(*result + 160);
      if (v13)
      {
        atomic_ullong v14 = v13[22];
        uint64_t v13 = (atomic_ullong *)v13[23];
        if (v13) {
          atomic_fetch_add_explicit(v13 + 1, 1uLL, memory_order_relaxed);
        }
      }
      else
      {
        atomic_ullong v14 = 0;
      }
      *a2 = v14;
      a2[1] = (atomic_ullong)v13;
    }
  }
  return result;
}

void sub_10048D5B8(uint64_t a1@<X0>, void *a2@<X8>)
{
}

uint64_t sub_10048D5C0(uint64_t a1)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_10048D728;
  uint64_t v4[3] = &unk_1019D12F0;
  void v4[4] = a1;
  uint64_t v5 = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = sub_100494F74;
  void v6[3] = &unk_1019D21C0;
  void v6[4] = a1 + 8;
  v6[5] = &v5;
  int v7 = v6;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    unsigned int v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    int v10 = sub_100494FC4;
    BOOL v11 = &unk_1019D2200;
    uint64_t v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    unsigned int v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    int v10 = sub_100494F88;
    BOOL v11 = &unk_1019D21E0;
    uint64_t v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_sync(v1, &block);
  }
  return v14;
}

uint64_t sub_10048D728(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 32) + 232);
}

uint64_t sub_10048D734(uint64_t a1)
{
  return sub_10048D5C0(a1 - 48);
}

void sub_10048D73C(void *a1, int a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_10048D858;
  void v8[3] = &unk_1019D1310;
  void v8[4] = a1;
  int v9 = a2;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  int v6 = v5;
  int v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10048E42C;
  block[3] = &unk_1019D14E0;
  block[5] = v4;
  BOOL v11 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v6);
}

const void **sub_10048D858(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CFNumberRef v9 = 0;
  LODWORD(valuePtr) = VinylSlotIdToInt();
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v3)
  {
    CFNumberRef v4 = v9;
    CFNumberRef v9 = v3;
    CFNumberRef valuePtr = v4;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v5 = v9;
  CFNumberRef v8 = v9;
  CFNumberRef v9 = 0;
  sub_1000570E8((const void **)&v9);
  DevicePersistentSaveValue(@"kPurchaseSlotOverride", v5);
  double result = sub_1000570E8((const void **)&v8);
  int v7 = *(_DWORD *)(a1 + 40);
  if (v7 != *(_DWORD *)(v2 + 232)) {
    *(_DWORD *)(v2 + 232) = v7;
  }
  return result;
}

void sub_10048D908(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

void sub_10048D928(uint64_t a1, int a2)
{
}

void sub_10048D930(uint64_t a1)
{
  ++*(_DWORD *)(a1 + 464);
  if (*(void *)(a1 + 336)) {
    return;
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 136);
  if (!v2)
  {
    CFNumberRef v3 = 0;
    goto LABEL_10;
  }
  CFNumberRef v3 = std::__shared_weak_count::lock(v2);
  if (!v3 || (uint64_t v4 = *(void *)(a1 + 128)) == 0)
  {
LABEL_10:
    sub_100058DB0(v23, "/cc/assertions/baseband_booted");
    ctu::rest::AssertionHandle::create();
    if (v24 < 0) {
      operator delete(v23[0]);
    }
    long long v8 = *(_OWORD *)__p;
    __p[0] = 0;
    __p[1] = 0;
    CFNumberRef v9 = *(std::__shared_weak_count **)(a1 + 344);
    *(_OWORD *)(a1 + 336) = v8;
    if (v9)
    {
      sub_10004D2C8(v9);
      if (__p[1]) {
        sub_10004D2C8((std::__shared_weak_count *)__p[1]);
      }
    }
    if (!v3) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  uint64_t v6 = *(void *)(v4 + 16);
  uint64_t v5 = *(void *)(v4 + 24);
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  int v7 = *(std::__shared_weak_count **)(a1 + 344);
  *(void *)(a1 + 336) = v6;
  *(void *)(a1 + 344) = v5;
  if (v7) {
    sub_10004D2C8(v7);
  }
LABEL_16:
  sub_10004D2C8(v3);
LABEL_17:
  (*(void (**)(Registry **__return_ptr))(**(void **)(a1 + 80) + 72))(&v16);
  Registry::getTimerService(&v18, v16);
  uint64_t v10 = v18;
  sub_100058DB0(v14, "vinyl session timeout");
  *(_OWORD *)long long __p = *(_OWORD *)v14;
  uint64_t v22 = v15;
  v14[0] = 0;
  v14[1] = 0;
  uint64_t v15 = 0;
  v23[0] = off_1019D2230;
  v23[1] = (void *)a1;
  unsigned int v25 = v23;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, uint64_t, uint64_t, void, void **))(*(void *)v10 + 40))(&v20, v10, __p, 1, 900000000, 0, v23);
  sub_10003B34C(v23);
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v11 = v20;
  uint64_t v20 = 0;
  uint64_t v12 = *(void *)(a1 + 352);
  *(void *)(a1 + 352) = v11;
  if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    uint64_t v13 = v20;
    uint64_t v20 = 0;
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    }
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
}

void sub_10048DBB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
  _Unwind_Resume(exception_object);
}

void sub_10048DC44(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    CFNumberRef v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        sub_10003B34C(v3 + 2);
        operator delete(v3);
        CFNumberRef v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void *sub_10048DCB8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10048DD3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      sub_10037DA5C(a3, v5);
      v5 += 88;
      a3 += 88;
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t sub_10048DD94(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x2E8BA2E8BA2E8BALL) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1745D1745D1745DLL) {
    unint64_t v9 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v9 = v5;
  }
  _OWORD v17[4] = a1 + 2;
  if (v9) {
    uint64_t v10 = sub_10010C8A4(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = (char *)&v10[11 * v4];
  v17[0] = v10;
  v17[1] = v11;
  void v17[3] = &v10[11 * v9];
  long long v12 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)uint64_t v11 = *(_OWORD *)a2;
  *((_OWORD *)v11 + 1) = v12;
  long long v13 = *(_OWORD *)(a2 + 32);
  *((void *)v11 + 6) = *(void *)(a2 + 48);
  *((_OWORD *)v11 + 2) = v13;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 32) = 0;
  v11[56] = 0;
  unsigned int v14 = v11 + 56;
  v11[80] = 0;
  if (*(unsigned char *)(a2 + 80))
  {
    *unsigned int v14 = 0;
    *((void *)v11 + 8) = 0;
    *((void *)v11 + 9) = 0;
    *(_OWORD *)unsigned int v14 = *(_OWORD *)(a2 + 56);
    v10[11 * v4 + 9] = *(void *)(a2 + 72);
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = 0;
    v11[80] = 1;
  }
  _OWORD v17[2] = v11 + 88;
  sub_10010C82C(a1, v17);
  uint64_t v15 = a1[1];
  sub_10010C988((uint64_t)v17);
  return v15;
}

void sub_10048DEF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10010C988((uint64_t)va);
  _Unwind_Resume(a1);
}

__n128 sub_10048DF0C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 216) == *(unsigned __int8 *)(a2 + 216))
  {
    if (*(unsigned char *)(a1 + 216))
    {
      sub_10032FC84(a1, a2);
    }
  }
  else if (*(unsigned char *)(a1 + 216))
  {
    *(unsigned char *)(sub_1000C584C(a1) + 216) = 0;
  }
  else
  {
    *(_OWORD *)a1 = *(_OWORD *)a2;
    long long v3 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = v3;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 16) = 0;
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 40) = 0;
    long long v5 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = v5;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = 0;
    *(void *)(a2 + 80) = 0;
    *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
    long long v6 = *(_OWORD *)(a2 + 96);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    *(_OWORD *)(a1 + 96) = v6;
    *(void *)(a2 + 104) = 0;
    *(void *)(a2 + 112) = 0;
    *(void *)(a2 + 96) = 0;
    long long v7 = *(_OWORD *)(a2 + 120);
    *(void *)(a1 + 136) = *(void *)(a2 + 136);
    *(_OWORD *)(a1 + 120) = v7;
    *(void *)(a2 + 128) = 0;
    *(void *)(a2 + 136) = 0;
    *(void *)(a2 + 120) = 0;
    long long v8 = *(_OWORD *)(a2 + 144);
    *(void *)(a1 + 160) = *(void *)(a2 + 160);
    *(_OWORD *)(a1 + 144) = v8;
    *(void *)(a2 + 152) = 0;
    *(void *)(a2 + 160) = 0;
    *(void *)(a2 + 144) = 0;
    long long v9 = *(_OWORD *)(a2 + 168);
    *(void *)(a1 + 184) = *(void *)(a2 + 184);
    *(_OWORD *)(a1 + 168) = v9;
    *(void *)(a2 + 168) = 0;
    *(void *)(a2 + 176) = 0;
    *(void *)(a2 + 184) = 0;
    __n128 result = *(__n128 *)(a2 + 192);
    *(void *)(a1 + 208) = *(void *)(a2 + 208);
    *(__n128 *)(a1 + 192) = result;
    *(void *)(a2 + 192) = 0;
    *(void *)(a2 + 200) = 0;
    *(void *)(a2 + 208) = 0;
    *(unsigned char *)(a1 + 216) = 1;
  }
  return result;
}

void sub_10048E038(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10048E070(uint64_t a1)
{
}

uint64_t sub_10048E08C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10048E0D0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10048E0FC(ServiceManager::Service *this)
{
  *(void *)this = off_1019D1468;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10048E158(ServiceManager::Service *this)
{
  *(void *)this = off_1019D1468;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10048E1C8@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "VinylControllerImpl");
}

unsigned char *sub_10048E1D8@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 3;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10048E218(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*a2) {
    dispatch_retain(*a2);
  }
  long long v3 = *(std::__shared_weak_count **)(v2 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10048E32C()
{
  return 0;
}

uint64_t sub_10048E334()
{
  return 1;
}

uint64_t sub_10048E33C()
{
  return 0;
}

void sub_10048E348(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10048E42C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10048E43C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10048E458(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10048E468(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D1520;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10048E488(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D1520;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t *sub_10048E4E4(capabilities::ct *a1)
{
  uint64_t v1 = *(void *)a1;
  char v74 = a1;
  int v75 = (dispatch_object_t *)v1;
  uint64_t v2 = *(void *)(v1 + 8);
  if (!capabilities::ct::shouldSaveVinylInfo(a1)) {
    goto LABEL_84;
  }
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 80) + 72))(buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  long long v4 = ServiceMap;
  if (v5 < 0)
  {
    long long v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int v93 = v5;
  long long v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)v93);
  if (!v9)
  {
    uint64_t v10 = 0;
    goto LABEL_9;
  }
  uint64_t v10 = v9[3];
  uint64_t v11 = (std::__shared_weak_count *)v9[4];
  if (!v11)
  {
LABEL_9:
    std::mutex::unlock(v4);
    uint64_t v11 = 0;
    char v12 = 1;
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v12 = 0;
LABEL_10:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (!v10) {
    goto LABEL_82;
  }
  int v79 = 0;
  (*(void (**)(uint8_t *__return_ptr, uint64_t, const __CFString *, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v10 + 40))(buf, v10, @"CachedVinylInfoKey", @"no_backup/com.apple.commcenter.vinyl", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_100044D6C(&v79, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  long long v13 = v79;
  if (v79) {
    unsigned int v14 = sub_100083F10;
  }
  else {
    unsigned int v14 = 0;
  }
  BOOL v15 = v14 == 0;
  if (!v14)
  {
    uint64_t v29 = kRemoteCellularPlanStorage;
    (*(void (**)(const void **__return_ptr, uint64_t, const __CFString *, void, const CFStringRef, const CFStringRef))(*(void *)v10 + 40))(&v76, v10, @"CachedVinylInfoKey", kRemoteCellularPlanStorage, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    sub_100044D6C(v93, &v76);
    *(void *)long long buf = v79;
    int v79 = *(ctu **)v93;
    *(void *)int v93 = 0;
    sub_100044D00((const void **)buf);
    sub_100044D00((const void **)v93);
    sub_1000577C4(&v76);
    if (v79) {
      xpc_object_t v30 = sub_100083F10;
    }
    else {
      xpc_object_t v30 = 0;
    }
    if (!v30) {
      goto LABEL_71;
    }
    (*(void (**)(uint64_t, const __CFString *, void, uint64_t, const CFStringRef, const CFStringRef))(*(void *)v10 + 16))(v10, @"CachedVinylInfoKey", 0, v29, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    long long v13 = v79;
    if (v79) {
      long long v31 = sub_100083F10;
    }
    else {
      long long v31 = 0;
    }
    if (!v31) {
      goto LABEL_70;
    }
  }
  int v73 = v11;
  uint64_t v16 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Loaded vinyl info", buf, 2u);
    long long v13 = v79;
  }
  char v72 = v12;
  *(void *)long long buf = 0;
  ctu::cf_to_xpc((uint64_t *)buf, v13, v17);
  sub_10010C4E0((uint64_t *)(v2 + 240), (xpc_object_t *)buf);
  uint64_t v18 = *(int **)(v2 + 240);
  uint64_t v19 = *(void *)(v2 + 248);
  if (0x2E8BA2E8BA2E8BA3 * ((v19 - (uint64_t)v18) >> 3) < (unint64_t)*(int *)(v2 + 224))
  {
    uint64_t v20 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v93 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Vinyl info size mismatch - clear and wait for vinyl info from baseband", v93, 2u);
      uint64_t v18 = *(int **)(v2 + 240);
      uint64_t v19 = *(void *)(v2 + 248);
    }
    while ((int *)v19 != v18)
    {
      v19 -= 88;
      sub_1000C5778(v19);
    }
    *(void *)(v2 + 248) = v18;
    (*(void (**)(uint64_t, const __CFString *, void, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v10 + 16))(v10, @"CachedVinylInfoKey", 0, @"no_backup/com.apple.commcenter.vinyl", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    goto LABEL_69;
  }
  if (v18 == (int *)v19) {
    goto LABEL_63;
  }
  char v21 = (uint64_t *)(v2 + 168);
  while (v18[3])
  {
    if (*(_DWORD *)(v2 + 224) != 1)
    {
      int v22 = v18[1];
LABEL_34:
      uint64_t v24 = *v21;
      if (*v21)
      {
        uint64_t v25 = v2 + 168;
        do
        {
          int v26 = *(_DWORD *)(v24 + 32);
          BOOL v27 = v26 < v22;
          if (v26 >= v22) {
            xpc_object_t v28 = (uint64_t *)v24;
          }
          else {
            xpc_object_t v28 = (uint64_t *)(v24 + 8);
          }
          if (!v27) {
            uint64_t v25 = v24;
          }
          uint64_t v24 = *v28;
        }
        while (*v28);
        if ((uint64_t *)v25 != v21 && v22 >= *(_DWORD *)(v25 + 32)) {
          sub_100D23D20(*(void *)(v25 + 40), v18);
        }
      }
      *(unsigned char *)(v2 + 228) |= VinylSlotIdToInt();
      v18 += 22;
      uint64_t v19 = *(void *)(v2 + 248);
      goto LABEL_46;
    }
    int v22 = *(_DWORD *)(v2 + 232);
    if (v22 == v18[1]) {
      goto LABEL_34;
    }
    uint64_t v19 = sub_10048DD3C((uint64_t)(v18 + 22), v19, (uint64_t)v18);
    for (uint64_t i = *(void *)(v2 + 248); i != v19; sub_1000C5778(i))
      i -= 88;
    *(void *)(v2 + 248) = v19;
    BOOL v15 = 1;
LABEL_46:
    if (v18 == (int *)v19) {
      goto LABEL_63;
    }
  }
  uint64_t v32 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v93 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Vinyl availability unknown - clear and wait for vinyl info from baseband", v93, 2u);
    uint64_t v19 = *(void *)(v2 + 248);
  }
  uint64_t v33 = *(void *)(v2 + 240);
  while (v19 != v33)
  {
    v19 -= 88;
    sub_1000C5778(v19);
  }
  *(void *)(v2 + 248) = v33;
  (*(void (**)(uint64_t, const __CFString *, void, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v10 + 16))(v10, @"CachedVinylInfoKey", 0, @"no_backup/com.apple.commcenter.vinyl", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
LABEL_63:
  xpc_object_t v34 = *(std::__shared_weak_count **)(v2 + 120);
  if (v34)
  {
    xpc_object_t v35 = std::__shared_weak_count::lock(v34);
    if (v35)
    {
      xpc_object_t v36 = v35;
      uint64_t v37 = *(void *)(v2 + 112);
      if (v37) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v37 + 16))(v37, v2 + 240);
      }
      sub_10004D2C8(v36);
    }
  }
  sub_100480890((void *)(v2 + 264), (uint64_t *)(v2 + 240));
LABEL_69:
  xpc_release(*(xpc_object_t *)buf);
  uint64_t v11 = v73;
  char v12 = v72;
  if (v15)
  {
LABEL_70:
    *(void *)long long buf = 0;
    sub_100480984((const VinylInfo **)(v2 + 240), (xpc_object_t *)buf);
    *(void *)int v93 = 0;
    xpc::bridge((uint64_t *)&v76, (xpc *)buf, v38);
    sub_100044D6C(v93, &v76);
    sub_1000577C4(&v76);
    (*(void (**)(uint64_t, const __CFString *, void, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v10 + 16))(v10, @"CachedVinylInfoKey", *(void *)v93, @"no_backup/com.apple.commcenter.vinyl", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    sub_100044D00((const void **)v93);
    xpc_release(*(xpc_object_t *)buf);
  }
LABEL_71:
  CFArrayRef theArray = 0;
  (*(void (**)(CFArrayRef *__return_ptr, uint64_t, void, const CFStringRef, const CFStringRef))(*(void *)v10 + 32))(&theArray, v10, kRemoteCellularPlanStorage, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  CFArrayRef v39 = theArray;
  if (theArray) {
    xpc_object_t v40 = sub_100083F10;
  }
  else {
    xpc_object_t v40 = 0;
  }
  if (v40)
  {
    v94.length = CFArrayGetCount(theArray);
    v94.location = 0;
    if (CFArrayContainsValue(v39, v94, kBoundProfilePackageKey))
    {
      uint64_t v92 = 0;
      long long v90 = 0u;
      long long v91 = 0u;
      long long v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v84 = 0u;
      long long v85 = 0u;
      long long v82 = 0u;
      long long v83 = 0u;
      long long v81 = 0u;
      memset(buf, 0, sizeof(buf));
      xpc_object_t v41 = (capabilities::ct *)sub_10030A548((uint64_t)buf);
      BYTE9(v83) = 1;
      int v42 = capabilities::ct::defaultVinylSlotID(v41);
      int v43 = VinylSlotIdFromInt(v42);
      if (v43)
      {
        memset(v93, 0, 17);
        sub_100480AC0((uint64_t)v93, v2, v43);
        if (v93[0])
        {
          long long v44 = *(_OWORD *)&v93[1];
          sub_100326828((long long *)buf, &v76);
          sub_100480B4C(v2, v44, *((uint64_t *)&v44 + 1), &v76, &stru_1019D0970, (uint64_t)&stru_1019D09B0);
          if (v77) {
            sub_10004D2C8(v77);
          }
        }
      }
      sub_10030A89C((uint64_t)buf);
    }
  }
  sub_100044D00((const void **)&theArray);
  sub_100044D00((const void **)&v79);
LABEL_82:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
LABEL_84:
  if (!*(unsigned char *)(v2 + 228))
  {
    int v49 = *(_DWORD *)(v2 + 224);
    if (v49 == 1)
    {
      int v50 = *(_DWORD *)(v2 + 232);
      *(_DWORD *)long long buf = 0;
      *(_DWORD *)&uint8_t buf[4] = v50;
      LOBYTE(v81) = 0;
      memset(&buf[8], 0, 49);
      unint64_t v51 = *(void *)(v2 + 248);
      if (v51 >= *(void *)(v2 + 256))
      {
        uint64_t v70 = sub_10048DD94((uint64_t *)(v2 + 240), (uint64_t)buf);
        int v71 = v81;
        *(void *)(v2 + 248) = v70;
        if (v71)
        {
          *(void *)int v93 = &buf[56];
          sub_1000C57C8((void ***)v93);
        }
      }
      else
      {
        long long v52 = *(_OWORD *)&buf[16];
        *(_OWORD *)unint64_t v51 = *(_OWORD *)buf;
        *(_OWORD *)(v51 + 16) = v52;
        long long v53 = *(_OWORD *)&buf[32];
        *(void *)(v51 + 48) = *(void *)&buf[48];
        *(_OWORD *)(v51 + 32) = v53;
        memset(&buf[32], 0, 24);
        *(unsigned char *)(v51 + 56) = 0;
        *(unsigned char *)(v51 + 80) = 0;
        *(void *)(v2 + 248) = v51 + 88;
      }
      if ((char)buf[55] < 0) {
        operator delete(*(void **)&buf[32]);
      }
    }
    else if (v49 >= 1)
    {
      int v64 = 1;
      do
      {
        int v65 = VinylSlotIdFromInt(v64);
        *(_DWORD *)long long buf = 0;
        *(_DWORD *)&uint8_t buf[4] = v65;
        LOBYTE(v81) = 0;
        memset(&buf[8], 0, 49);
        unint64_t v66 = *(void *)(v2 + 248);
        if (v66 >= *(void *)(v2 + 256))
        {
          uint64_t v69 = sub_10048DD94((uint64_t *)(v2 + 240), (uint64_t)buf);
        }
        else
        {
          long long v67 = *(_OWORD *)&buf[16];
          *(_OWORD *)unint64_t v66 = *(_OWORD *)buf;
          *(_OWORD *)(v66 + 16) = v67;
          long long v68 = *(_OWORD *)&buf[32];
          *(void *)(v66 + 48) = *(void *)&buf[48];
          *(_OWORD *)(v66 + 32) = v68;
          memset(&buf[32], 0, 24);
          *(unsigned char *)(v66 + 56) = 0;
          *(unsigned char *)(v66 + 80) = 0;
          if ((_BYTE)v81)
          {
            *(void *)(v66 + 56) = 0;
            *(void *)(v66 + 64) = 0;
            *(void *)(v66 + 72) = 0;
            *(_OWORD *)(v66 + 56) = *(_OWORD *)&buf[56];
            *(void *)(v66 + 72) = *(void *)&buf[72];
            memset(&buf[56], 0, 24);
            *(unsigned char *)(v66 + 80) = 1;
          }
          uint64_t v69 = v66 + 88;
          *(void *)(v2 + 248) = v66 + 88;
        }
        *(void *)(v2 + 248) = v69;
        if ((_BYTE)v81)
        {
          *(void *)int v93 = &buf[56];
          sub_1000C57C8((void ***)v93);
        }
        if ((char)buf[55] < 0) {
          operator delete(*(void **)&buf[32]);
        }
        BOOL v27 = v64++ < *(_DWORD *)(v2 + 224);
      }
      while (v27);
    }
  }
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 80) + 72))(buf);
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)&v76, *(Registry **)buf);
  ctu::RestModule::connect();
  if (v77) {
    sub_10004D2C8(v77);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  sub_100058DB0(v93, "/cc/events/dump_state");
  xpc_object_t v45 = operator new(0x20uLL);
  *xpc_object_t v45 = off_1019D1570;
  v45[1] = v2;
  v45[2] = sub_100485024;
  v45[3] = 0;
  *(void *)&uint8_t buf[24] = v45;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if ((v93[23] & 0x80000000) != 0) {
    operator delete(*(void **)v93);
  }
  sub_100058DB0(v93, "/cc/props/sims_on_device");
  xpc_object_t v46 = operator new(0x28uLL);
  *xpc_object_t v46 = off_1019D15F0;
  v46[1] = v2 + 200;
  v46[2] = v2;
  v46[3] = sub_100484E28;
  v46[4] = 0;
  *(void *)&uint8_t buf[24] = v46;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if ((v93[23] & 0x80000000) != 0) {
    operator delete(*(void **)v93);
  }
  sub_10041BCB4(v2 + 324);
  uint64_t v47 = v2 + 264;
  *(void *)long long buf = off_1019D1670;
  *(void *)&uint8_t buf[8] = v2 + 184;
  *(void *)&uint8_t buf[24] = buf;
  if (buf != (uint8_t *)(v2 + 264))
  {
    uint64_t v48 = *(void *)(v2 + 288);
    if (v48 == v47)
    {
      *(void *)&v93[8] = v2 + 184;
      *(void *)&v93[16] = 0;
      *(void *)int v93 = off_1019D1670;
      *(void *)&uint8_t buf[24] = 0;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v47 + 24))(v2 + 264, buf);
      (*(void (**)(void))(**(void **)(v2 + 288) + 32))(*(void *)(v2 + 288));
      *(void *)(v2 + 288) = 0;
      *(void *)&uint8_t buf[24] = buf;
      (*(void (**)(unsigned char *, uint64_t))(*(void *)v93 + 24))(v93, v2 + 264);
      (*(void (**)(unsigned char *))(*(void *)v93 + 32))(v93);
    }
    else
    {
      *(void *)(v2 + 264) = off_1019D1670;
      *(void *)(v2 + 272) = v2 + 184;
      *(void *)&uint8_t buf[24] = v48;
    }
    *(void *)(v2 + 288) = v47;
  }
  sub_10048DCB8(buf);
  uint64_t v54 = *(void *)(v2 + 288);
  if (v54) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v54 + 48))(v54, v2 + 296);
  }
  sub_100058DB0(v93, "/cc/props/cellular_plan_bootstrap_status");
  *(void *)long long buf = off_1019D1700;
  *(void *)&uint8_t buf[8] = v2 + 320;
  *(void *)&uint8_t buf[16] = v2;
  *(void *)&uint8_t buf[24] = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if ((v93[23] & 0x80000000) != 0) {
    operator delete(*(void **)v93);
  }
  if ((*(unsigned int (**)(void))(**(void **)(v2 + 80) + 96))(*(void *)(v2 + 80)))
  {
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 80) + 120))(buf);
    long long v55 = *(_OWORD *)buf;
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    xpc_object_t v56 = *(std::__shared_weak_count **)(v2 + 152);
    *(_OWORD *)(v2 + 144) = v55;
    if (v56)
    {
      sub_10004D2C8(v56);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
    }
    sub_100058DB0(v93, "/cc/props/is_postponement_ticket_available");
    xpc_object_t v57 = operator new(0x28uLL);
    *xpc_object_t v57 = off_1019D1780;
    v57[1] = v2 + 328;
    v57[2] = v2;
    v57[3] = sub_100487820;
    v57[4] = 0;
    *(void *)&uint8_t buf[24] = v57;
    ctu::RestModule::observeProperty();
    sub_10003F600(buf);
    if ((v93[23] & 0x80000000) != 0) {
      operator delete(*(void **)v93);
    }
  }
  sub_100058DB0(v93, "/cc/props/internet_status");
  xpc_object_t v58 = operator new(0x28uLL);
  void *v58 = off_1019D1800;
  v58[1] = v2 + 329;
  v58[2] = v2;
  v58[3] = sub_100480D7C;
  v58[4] = 0;
  *(void *)&uint8_t buf[24] = v58;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if ((v93[23] & 0x80000000) != 0) {
    operator delete(*(void **)v93);
  }
  sub_100058DB0(v93, "/cc/props/commcenter_starts_since_boot");
  uint64_t v59 = operator new(0x28uLL);
  *uint64_t v59 = off_1019D1880;
  v59[1] = v2 + 332;
  v59[2] = v2;
  v59[3] = sub_100484A78;
  v59[4] = 0;
  *(void *)&uint8_t buf[24] = v59;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if ((v93[23] & 0x80000000) != 0) {
    operator delete(*(void **)v93);
  }
  uint64_t v60 = *(VinylCommandDriver **)(v2 + 64);
  if (v60)
  {
    int v61 = *(NSObject **)v1;
    *(void *)long long buf = v61;
    if (v61)
    {
      dispatch_retain(v61);
      dispatch_group_enter(v61);
    }
    v62.var0.fObuint64_t j = (dispatch_object_s *)buf;
    VinylCommandDriver::bootstrap(v60, v62);
    if (*(void *)buf)
    {
      dispatch_group_leave(*(dispatch_group_t *)buf);
      if (*(void *)buf) {
        dispatch_release(*(dispatch_object_t *)buf);
      }
    }
  }
  sub_10048F648(&v75);
  return sub_100046B58((uint64_t *)&v74);
}

void sub_10048F430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11, std::__shared_weak_count *a12, uint64_t a13, dispatch_object_t *a14, __int16 a15, char a16, char a17, uint64_t a18, char a19, int a20,const void *a21,uint64_t a22,xpc_object_t object,uint64_t a24)
{
  sub_10004D2C8(v24);
  xpc_release(object);
  sub_100044D00(&a21);
  if ((a11 & 1) == 0) {
    sub_10004D2C8(a12);
  }
  sub_10048F648(&a14);
  sub_100046B58(&a13);
  _Unwind_Resume(a1);
}

dispatch_object_t **sub_10048F648(dispatch_object_t **result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*v1) {
      dispatch_release(*v1);
    }
    operator delete();
  }
  return result;
}

void sub_10048F6A0()
{
}

__n128 sub_10048F6B4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019D1570;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10048F708(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D1570;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10048F740(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  long long v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10048F788(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10048F7C8()
{
}

void sub_10048F7D8()
{
}

__n128 sub_10048F7EC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019D15F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10048F840(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D15F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10048F878(void *a1, xpc_object_t *a2)
{
  long long v3 = (uint64_t *)a1[1];
  long long v7 = *(_OWORD *)v3;
  uint64_t v8 = v3[2];
  uint64_t *v3 = 0;
  v3[1] = 0;
  void v3[2] = 0;
  sub_100089CF0(v3, a2);
  long long v4 = (void (*)(void *, long long *))a1[3];
  uint64_t v5 = a1[4];
  long long v6 = (void *)(a1[2] + (v5 >> 1));
  if (v5) {
    long long v4 = *(void (**)(void *, long long *))(*v6 + v4);
  }
  v4(v6, &v7);
  long long v9 = (void **)&v7;
  sub_10008A88C(&v9);
}

void sub_10048F91C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_10048F938(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10048F978()
{
}

void sub_10048F988()
{
}

void *sub_10048F99C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019D1670;
  result[1] = v3;
  return result;
}

uint64_t sub_10048F9E4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D1670;
  a2[1] = v2;
  return result;
}

void sub_10048FA10(uint64_t a1, const VinylInfo **a2)
{
  xpc_object_t v5 = 0;
  sub_100480984(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/vinyl_info");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_10048FAB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10048FAF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10048FB38()
{
}

void sub_10048FB48()
{
}

__n128 sub_10048FB5C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019D1700;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10048FBA8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D1700;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

xpc_type_t sub_10048FBD8(uint64_t a1, xpc_object_t *a2)
{
  char v4 = *(int **)(a1 + 8);
  xpc_type_t result = xpc_get_type(*a2);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    int v9 = *v4;
    xpc_type_t result = (xpc_type_t)ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v9, (int *)a2, v6);
    int *v4 = v9;
  }
  else if (result == (xpc_type_t)&_xpc_type_BOOL {
         || result == (xpc_type_t)&_xpc_type_int64
  }
         || result == (xpc_type_t)&_xpc_type_uint64)
  {
    xpc_type_t result = (xpc_type_t)xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
    int *v4 = (int)result;
  }
  **(unsigned char **)(*(void *)(a1 + 16) + 96) = *(_DWORD *)(*(void *)(a1 + 16) + 320) == 2;
  return result;
}

uint64_t sub_10048FC98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10048FCD8()
{
}

void sub_10048FCE8()
{
}

__n128 sub_10048FCFC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019D1780;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10048FD50(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D1780;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10048FD88(void *a1, xpc *this, BOOL a3)
{
  char v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  long long v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_10048FE24(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10048FE64()
{
}

void sub_10048FE74()
{
}

__n128 sub_10048FE88(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019D1800;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10048FEDC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D1800;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10048FF14(void *a1, xpc_object_t *a2)
{
  char v4 = (unsigned __int8 *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned __int8 v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned __int8 *)a2, v7);
    unsigned __int8 *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned __int8 *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  char v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_10049000C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10049004C()
{
}

void sub_10049005C()
{
}

__n128 sub_100490070(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019D1880;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004900C4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D1880;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004900FC(void *a1, xpc *this, unsigned int a3)
{
  char v4 = (_DWORD *)a1[1];
  uint64_t v5 = *v4;
  _DWORD *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  long long v6 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(uint64_t (**)(void *, uint64_t))(*v8 + v6);
  }

  return v6(v8, v5);
}

uint64_t sub_100490194(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004901D4()
{
}

void sub_1004901E0(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  if (!*(unsigned char *)(v1 + 228))
  {
    uint64_t v2 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I No vinyl info received - request assertion", buf, 2u);
    }
    sub_10048D930(v1);
  }
  VinylCommandDriver::start(*(VinylCommandDriver **)(v1 + 64));
  operator delete();
}

void sub_10049028C()
{
}

void sub_1004902BC()
{
}

void *sub_1004902D0()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_1019D1900;
  return result;
}

void sub_100490308(uint64_t a1, void *a2)
{
  *a2 = off_1019D1900;
}

void sub_100490330(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)a3;
  int v4 = *(char *)(a3 + 23);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  if (v4 < 0) {
    operator delete(v3);
  }
}

uint64_t sub_10049034C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10049038C()
{
}

void sub_100490398(std::__shared_weak_count **a1, void *a2, NSObject *a3, uint64_t *a4, unsigned int *a5, void *a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t v16 = (std::__shared_weak_count *)operator new(0x1B0uLL);
  v16->__shared_owners_ = 0;
  v16->__shared_weak_owners_ = 0;
  v16->__vftable = (std::__shared_weak_count_vtbl *)off_1019D1980;
  dispatch_object_t object = a3;
  if (a3) {
    dispatch_retain(a3);
  }
  uint64_t v17 = *a4;
  uint64_t v18 = (std::__shared_weak_count *)a4[1];
  v31[0] = v17;
  v31[1] = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v19 = *a5;
  uint64_t v20 = (std::__shared_weak_count *)a6[1];
  v30[0] = *a6;
  v30[1] = v20;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v21 = v16 + 1;
  uint64_t v22 = *a7;
  xpc_object_t v23 = (std::__shared_weak_count *)a7[1];
  v29[0] = v22;
  v29[1] = v23;
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v24 = *a8;
  uint64_t v25 = (std::__shared_weak_count *)a8[1];
  if (v24) {
    uint64_t v26 = v24 + 56;
  }
  else {
    uint64_t v26 = 0;
  }
  v28[0] = v26;
  v28[1] = v25;
  if (v25) {
    atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100D220B0((uint64_t)&v16[1], a2, &object, v31, v19, v30, v29, v28);
  if (v25) {
    std::__shared_weak_count::__release_weak(v25);
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (object) {
    dispatch_release(object);
  }
  *a1 = v21;
  a1[1] = v16;
  shared_weak_owners = (std::__shared_weak_count *)v16[1].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1) {
      return;
    }
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v16[1].__shared_owners_ = (uint64_t)v21;
    v16[1].__shared_weak_owners_ = (uint64_t)v16;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  else
  {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v16[1].__shared_owners_ = (uint64_t)v21;
    v16[1].__shared_weak_owners_ = (uint64_t)v16;
  }

  sub_10004D2C8(v16);
}

void sub_10049058C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, dispatch_object_t object)
{
  if (v22)
  {
    std::__shared_weak_count::__release_weak(v22);
    if (!v21)
    {
LABEL_3:
      if (!v20) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else if (!v21)
  {
    goto LABEL_3;
  }
  sub_10004D2C8(v21);
  if (!v20)
  {
LABEL_4:
    if (!v19) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
LABEL_11:
  sub_10004D2C8(v20);
  if (!v19)
  {
LABEL_6:
    if (object) {
      dispatch_release(object);
    }
    std::__shared_weak_count::~__shared_weak_count(v18);
    operator delete(v24);
    _Unwind_Resume(a1);
  }
LABEL_5:
  sub_10004D2C8(v19);
  goto LABEL_6;
}

void sub_1004905F0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D1980;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100490610(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D1980;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100490664(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t *sub_10049068C(uint64_t *result, int a2, uint64_t a3)
{
  int v4 = result;
  long long v6 = (uint64_t **)(result + 1);
  uint64_t v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (void *)v5;
        int v8 = *(_DWORD *)(v5 + 32);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        long long v6 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        long long v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = result + 1;
LABEL_9:
    int v9 = (char *)operator new(0x38uLL);
    *((_DWORD *)v9 + 8) = *(_DWORD *)a3;
    *(_OWORD *)(v9 + 40) = *(_OWORD *)(a3 + 8);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)int v9 = 0;
    *((void *)v9 + 1) = 0;
    *((void *)v9 + 2) = v7;
    *long long v6 = (uint64_t *)v9;
    uint64_t v10 = *(void *)*v4;
    if (v10)
    {
      uint64_t *v4 = v10;
      uint64_t v11 = *v6;
    }
    else
    {
      uint64_t v11 = (uint64_t *)v9;
    }
    __n128 result = sub_100046C90((uint64_t *)v4[1], v11);
    ++v4[2];
  }
  return result;
}

void sub_100490754(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      long long v6 = v5;
      if (a1[4])
      {
        uint64_t v7 = a1[6];
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)a2;
          uint64_t v9 = *(void *)(a2 + 16);
        }
        (*(void (**)(uint64_t, void **))(v7 + 16))(v7, __p);
        if (SHIBYTE(v9) < 0) {
          operator delete(__p[0]);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10049081C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

void *sub_100490848(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  __n128 result = (void *)a2[6];
  if (result) {
    __n128 result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_100490894(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *sub_1004908E8(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

uint64_t sub_1004908FC(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100490938(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t *sub_100490974(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v24 = a1;
  uint64_t v25 = v1;
  uint64_t v2 = *v1;
  uint64_t v26 = 0;
  BOOL v27 = 0;
  v28[0] = 0;
  uint64_t v3 = *(void **)(v2 + 160);
  int v4 = (void *)(v2 + 168);
  if (v3 == (void *)(v2 + 168))
  {
    uint64_t v21 = 0;
    uint64_t v20 = 0;
  }
  else
  {
    do
    {
      sub_100D27DF8(v3[5], (uint64_t)&v30);
      uint64_t v5 = v27;
      if ((unint64_t)v27 >= v28[0])
      {
        uint64_t v9 = 0x2E8BA2E8BA2E8BA3 * (((uint64_t)v27 - v26) >> 3);
        unint64_t v10 = v9 + 1;
        if ((unint64_t)(v9 + 1) > 0x2E8BA2E8BA2E8BALL) {
          sub_10006A748();
        }
        if (0x5D1745D1745D1746 * ((v28[0] - v26) >> 3) > v10) {
          unint64_t v10 = 0x5D1745D1745D1746 * ((v28[0] - v26) >> 3);
        }
        if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((v28[0] - v26) >> 3)) >= 0x1745D1745D1745DLL) {
          unint64_t v11 = 0x2E8BA2E8BA2E8BALL;
        }
        else {
          unint64_t v11 = v10;
        }
        v29[4] = (void **)v28;
        if (v11) {
          char v12 = (void **)sub_10010C8A4((uint64_t)v28, v11);
        }
        else {
          char v12 = 0;
        }
        long long v13 = &v12[11 * v9];
        v29[0] = v12;
        v29[1] = v13;
        v29[3] = &v12[11 * v11];
        long long v14 = v31;
        *(_OWORD *)long long v13 = v30;
        *((_OWORD *)v13 + 1) = v14;
        long long v15 = __p;
        void v13[6] = v33;
        *((_OWORD *)v13 + 2) = v15;
        uint64_t v33 = 0;
        long long __p = 0uLL;
        *((unsigned char *)v13 + 56) = 0;
        uint64_t v16 = v13 + 7;
        *((unsigned char *)v13 + 80) = 0;
        if (v36)
        {
          *uint64_t v16 = 0;
          void v13[8] = 0;
          v13[9] = 0;
          *(_OWORD *)uint64_t v16 = v34;
          v12[11 * v9 + 9] = v35;
          long long v34 = 0uLL;
          xpc_object_t v35 = 0;
          *((unsigned char *)v13 + 80) = 1;
        }
        void v29[2] = v13 + 11;
        sub_10010C82C(&v26, v29);
        int v8 = v27;
        sub_10010C988((uint64_t)v29);
      }
      else
      {
        long long v6 = v31;
        *BOOL v27 = v30;
        v5[1] = v6;
        long long v7 = __p;
        *((void *)v5 + 6) = v33;
        void v5[2] = v7;
        uint64_t v33 = 0;
        long long __p = 0uLL;
        *((unsigned char *)v5 + 56) = 0;
        *((unsigned char *)v5 + 80) = 0;
        if (v36)
        {
          *((void *)v5 + 7) = 0;
          *((void *)v5 + 8) = 0;
          *((void *)v5 + 9) = 0;
          *(_OWORD *)((char *)v5 + 56) = v34;
          *((void *)v5 + 9) = v35;
          long long v34 = 0uLL;
          xpc_object_t v35 = 0;
          *((unsigned char *)v5 + 80) = 1;
        }
        int v8 = (_OWORD *)((char *)v5 + 88);
      }
      BOOL v27 = v8;
      if (v36)
      {
        v29[0] = (void **)&v34;
        sub_1000C57C8(v29);
      }
      if (SHIBYTE(v33) < 0) {
        operator delete((void *)__p);
      }
      uint64_t v17 = (void *)v3[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v3[2];
          BOOL v19 = *v18 == (void)v3;
          uint64_t v3 = v18;
        }
        while (!v19);
      }
      uint64_t v3 = v18;
    }
    while (v18 != v4);
    uint64_t v20 = v26;
    uint64_t v21 = (uint64_t)v27;
  }
  long long v30 = 0uLL;
  *(void *)&long long v31 = 0;
  sub_100311ED8(&v30, v20, v21, 0x2E8BA2E8BA2E8BA3 * ((v21 - v20) >> 3));
  uint64_t v22 = v1[4];
  if (!v22) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v22 + 48))(v22, &v30);
  v29[0] = (void **)&v30;
  sub_1000C56F4(v29);
  v29[0] = (void **)&v26;
  sub_1000C56F4(v29);
  sub_100490D5C((uint64_t *)&v25);
  return sub_100046B58((uint64_t *)&v24);
}

void sub_100490CD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, __int16 *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  a18 = &a13;
  sub_1000C56F4((void ***)&a18);
  sub_100490D5C(&a12);
  sub_100046B58(&a11);
  _Unwind_Resume(a1);
}

uint64_t *sub_100490D5C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1000C8D24((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_100490DAC(void **a1)
{
  uint64_t v1 = *a1;
  long long v7 = a1;
  int v8 = v1;
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v4 = v1[2];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v3 + 120);
  *(void *)(v3 + 112) = v2;
  *(void *)(v3 + 120) = v4;
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  (*(void (**)(void, uint64_t))(*(void *)v1[1] + 16))(v1[1], v3 + 240);
  sub_1000E1A60((uint64_t *)&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100490E3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_100490E58(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
}

void *sub_100490E6C(uint64_t a1)
{
  uint64_t result = (*(void *(**)(char *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned char *)v3)
  {
    if (v4) {
      *(_OWORD *)(v3 + 1) = v5;
    }
    else {
      *(unsigned char *)uint64_t v3 = 0;
    }
  }
  else if (v4)
  {
    *(_OWORD *)(v3 + 1) = v5;
    *(unsigned char *)uint64_t v3 = 1;
  }
  return result;
}

void *sub_100490F18(uint64_t a1)
{
  uint64_t result = (*(void *(**)(char *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned char *)v3)
  {
    if (v4) {
      *(_OWORD *)(v3 + 1) = v5;
    }
    else {
      *(unsigned char *)uint64_t v3 = 0;
    }
  }
  else if (v4)
  {
    *(_OWORD *)(v3 + 1) = v5;
    *(unsigned char *)uint64_t v3 = 1;
  }
  return result;
}

uint64_t sub_100490FC4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
}

void sub_100490FD8(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = v4;
  *(unsigned char *)(v2 + 16) = v5;
  *(_OWORD *)uint64_t v2 = v3;
  sub_100179CB0(v2 + 24, &__p);
  sub_10048DF0C(v2 + 56, (uint64_t)v9);
  sub_10048DF0C(v2 + 280, (uint64_t)v10);
  if (v10[216]) {
    sub_1000C584C((uint64_t)v10);
  }
  if (v9[216]) {
    sub_1000C584C((uint64_t)v9);
  }
  if (v8)
  {
    if (v7 < 0) {
      operator delete((void *)__p.n128_u64[0]);
    }
  }
}

void sub_1004910CC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1004910E8(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = v4;
  *(unsigned char *)(v2 + 16) = v5;
  *(_OWORD *)uint64_t v2 = v3;
  sub_100179CB0(v2 + 24, &__p);
  sub_10048DF0C(v2 + 56, (uint64_t)v9);
  sub_10048DF0C(v2 + 280, (uint64_t)v10);
  if (v10[216]) {
    sub_1000C584C((uint64_t)v10);
  }
  if (v9[216]) {
    sub_1000C584C((uint64_t)v9);
  }
  if (v8)
  {
    if (v7 < 0) {
      operator delete((void *)__p.n128_u64[0]);
    }
  }
}

void sub_1004911DC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1004911F8(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  long long v3 = *(int **)(a1 + 40);
  int v4 = v3[2];
  long long v6 = (uint64_t **)(*(void *)v3 + 168);
  char v5 = *v6;
  *a2 = 0u;
  a2[1] = 0u;
  if (v5)
  {
    char v7 = v6;
    char v8 = v5;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < v4;
      if (v9 >= v4) {
        unint64_t v11 = (uint64_t **)v8;
      }
      else {
        unint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        char v7 = (uint64_t **)v8;
      }
      char v8 = *v11;
    }
    while (*v11);
    if (v7 != v6 && *((_DWORD *)v7 + 8) <= v4)
    {
      uint64_t v12 = *(void *)(*sub_1000389F8(v5, v4) + 160);
      if (v12 && *(unsigned char *)(v12 + 112))
      {
        sub_1000C5E38((uint64_t)&v13, v12 + 88);
      }
      else
      {
        v13.n128_u8[0] = 0;
        char v14 = 0;
      }
      sub_10037DAD4((uint64_t)a2, &v13);
      if (v14)
      {
        long long v15 = &v13;
        sub_1000C57C8((void ***)&v15);
      }
    }
  }
}

void sub_1004912CC(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v2);
  sub_10037DAD4(*(void *)(a1 + 32), &v2);
  if (v3)
  {
    int v4 = &v2;
    sub_1000C57C8((void ***)&v4);
  }
}

void sub_100491334(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v2);
  sub_10037DAD4(*(void *)(a1 + 32), &v2);
  if (v3)
  {
    int v4 = &v2;
    sub_1000C57C8((void ***)&v4);
  }
}

void *sub_10049139C(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

uint64_t sub_1004913B0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100491448(void *a1)
{
  __n128 v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1004914CC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_10049154C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  unint64_t v11 = a1;
  uint64_t v12 = v1;
  uint64_t v2 = *v1;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  BOOL v19 = 0;
  sub_10005C928(&v19, (const void *)v1[1], v1[2], v1[2] - v1[1]);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  sub_10005C928(&v16, (const void *)v1[4], v1[5], v1[5] - v1[4]);
  __n128 __p = 0;
  char v14 = 0;
  uint64_t v15 = 0;
  sub_10005C928(&__p, (const void *)v1[7], v1[8], v1[8] - v1[7]);
  sub_1004913B0((uint64_t)v31, (uint64_t)(v1 + 10));
  uint64_t v3 = *(void *)(v2 + 168);
  if (!v3) {
    goto LABEL_11;
  }
  uint64_t v4 = v2 + 168;
  int v5 = *(_DWORD *)(v2 + 232);
  do
  {
    int v6 = *(_DWORD *)(v3 + 32);
    BOOL v7 = v6 < v5;
    if (v6 >= v5) {
      char v8 = (uint64_t *)v3;
    }
    else {
      char v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v4 != v2 + 168 && v5 >= *(_DWORD *)(v4 + 32))
  {
    uint64_t v10 = *(void *)(v4 + 40);
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    xpc_object_t v28 = 0;
    sub_10005C928(&v28, v19, (uint64_t)v20, v20 - (unsigned char *)v19);
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    sub_10005C928(&v25, v16, (uint64_t)v17, v17 - (unsigned char *)v16);
    uint64_t v22 = 0;
    xpc_object_t v23 = 0;
    uint64_t v24 = 0;
    sub_10005C928(&v22, __p, (uint64_t)v14, v14 - (unsigned char *)__p);
    sub_1004913B0((uint64_t)v32, (uint64_t)v31);
    sub_100D2EC3C(v10, &v28, (char **)&v25, (char **)&v22, (uint64_t)v32);
    sub_100491448(v32);
    if (v22)
    {
      xpc_object_t v23 = v22;
      operator delete(v22);
    }
    if (v25)
    {
      uint64_t v26 = v25;
      operator delete(v25);
    }
    if (v28)
    {
      uint64_t v29 = v28;
      operator delete(v28);
    }
  }
  else
  {
LABEL_11:
    LOBYTE(v32[0]) = 0;
    char v33 = 0;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    xpc_object_t v28 = 0;
    sub_10048548C((uint64_t)v31, (uint64_t)v32, (uint64_t)&v28, 0);
    if (v28)
    {
      uint64_t v29 = v28;
      operator delete(v28);
    }
    if (v33) {
      sub_10026CF54((uint64_t)v32, (void *)v32[1]);
    }
  }
  sub_100491448(v31);
  if (__p)
  {
    char v14 = __p;
    operator delete(__p);
  }
  if (v16)
  {
    uint64_t v17 = v16;
    operator delete(v16);
  }
  if (v19)
  {
    uint64_t v20 = v19;
    operator delete(v19);
  }
  sub_10049187C(&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_100491784(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,void *a24,uint64_t a25)
{
  sub_100491448((void *)(v25 - 72));
  if (__p)
  {
    a22 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a24)
  {
    a25 = (uint64_t)a24;
    operator delete(a24);
  }
  uint64_t v27 = *(void **)(v25 - 128);
  if (v27)
  {
    *(void *)(v25 - 120) = v27;
    operator delete(v27);
  }
  sub_100491448((void *)(v25 - 104));
  if (a12)
  {
    a13 = (uint64_t)a12;
    operator delete(a12);
  }
  if (a15)
  {
    a16 = (uint64_t)a15;
    operator delete(a15);
  }
  if (a18)
  {
    a19 = (uint64_t)a18;
    operator delete(a18);
  }
  sub_10049187C(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void *sub_10049187C(void *result)
{
  uint64_t v1 = (void *)*result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100491448(v1 + 10);
    uint64_t v2 = (void *)v1[7];
    if (v2)
    {
      v1[8] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[4];
    if (v3)
    {
      v1[5] = v3;
      operator delete(v3);
    }
    uint64_t v4 = (void *)v1[1];
    if (v4)
    {
      v1[2] = v4;
      operator delete(v4);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1004918FC(uint64_t **a1)
{
  uint64_t v1 = *a1;
  BOOL v7 = a1;
  char v8 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = v1[1];
  uint64_t v4 = v1[2];
  sub_1000C6AC0((uint64_t)v11, (uint64_t)(v1 + 6));
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_1004852FC(&v9, v2, v3, v4);
  uint64_t v5 = v9;
  if (v9)
  {
    sub_1000C6AC0((uint64_t)v12, (uint64_t)v11);
    sub_100D2AFB8(v5, (uint64_t)(v1 + 3), (uint64_t)v12);
    sub_1000C6B58(v12);
  }
  else
  {
    sub_1000C26BC((uint64_t)v11, 268);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1000C6B58(v11);
  sub_100491A3C((uint64_t *)&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_1004919E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  uint64_t v7 = va_arg(va2, void);
  char v8 = va_arg(va2, std::__shared_weak_count *);
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_1000C6B58(va2);
  sub_100491A3C((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100491A3C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1000C6B58((void *)(v1 + 48));
    sub_10005CD2C(v1 + 24, *(char **)(v1 + 32));
    operator delete();
  }
  return result;
}

void sub_100491A98(uint64_t a1, void *a2, uint64_t a3)
{
  *(_OWORD *)uint64_t v25 = 0u;
  long long v26 = 0u;
  if (!ctu::cf::assign()) {
    goto LABEL_49;
  }
  if (a2)
  {
    CFTypeID v5 = CFGetTypeID(a2);
    if (v5 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)((char *)&v26 + 8), (unsigned int *)a2, v6);
    }
  }
  if (SBYTE7(v26) < 0)
  {
    sub_10004FC84(__p, v25[0], (unint64_t)v25[1]);
  }
  else
  {
    *(_OWORD *)__n128 __p = *(_OWORD *)v25;
    uint64_t v23 = v26;
  }
  int v24 = DWORD2(v26);
  uint64_t v7 = *(uint64_t ***)a3;
  char v8 = *(uint64_t **)(a3 + 8);
  uint64_t v30 = 0;
  long long v31 = 0;
  if (v7 + 1 == (uint64_t **)v8 || (sub_100046FE8(__p, (void **)v8 + 4) & 0x80) != 0)
  {
    uint64_t v10 = v8;
    if (*v7 == v8) {
      goto LABEL_53;
    }
    unint64_t v11 = (uint64_t *)*v8;
    if (*v8)
    {
      do
      {
        uint64_t v10 = v11;
        unint64_t v11 = (uint64_t *)v11[1];
      }
      while (v11);
    }
    else
    {
      uint64_t v15 = v8;
      do
      {
        uint64_t v10 = (uint64_t *)v15[2];
        BOOL v16 = *v10 == (void)v15;
        uint64_t v15 = v10;
      }
      while (v16);
    }
    if ((sub_100046FE8(v10 + 4, __p) & 0x80) != 0)
    {
LABEL_53:
      if (*v8)
      {
        long long v31 = v10;
        char v8 = v10 + 1;
      }
      else
      {
        long long v31 = v8;
      }
LABEL_37:
      uint64_t v9 = (uint64_t **)v8;
      char v8 = (uint64_t *)*v8;
      if (v8) {
        goto LABEL_42;
      }
      goto LABEL_38;
    }
    goto LABEL_24;
  }
  if ((sub_100046FE8(v8 + 4, __p) & 0x80) != 0)
  {
    uint64_t v12 = v8[1];
    if (v12)
    {
      __n128 v13 = (void *)v8[1];
      do
      {
        uint64_t v14 = (uint64_t)v13;
        __n128 v13 = (void *)*v13;
      }
      while (v13);
    }
    else
    {
      uint64_t v17 = v8;
      do
      {
        uint64_t v14 = v17[2];
        BOOL v16 = *(void *)v14 == (void)v17;
        uint64_t v17 = (uint64_t *)v14;
      }
      while (!v16);
    }
    if ((uint64_t **)v14 == v7 + 1) {
      goto LABEL_34;
    }
    if ((sub_100046FE8(__p, (void **)(v14 + 32)) & 0x80) != 0)
    {
      uint64_t v12 = v8[1];
LABEL_34:
      if (v12)
      {
        long long v31 = (uint64_t *)v14;
        char v8 = (uint64_t *)v14;
      }
      else
      {
        long long v31 = v8++;
      }
      goto LABEL_37;
    }
LABEL_24:
    char v8 = sub_100046ED4((uint64_t)v7, &v31, __p);
    goto LABEL_37;
  }
  uint64_t v30 = v8;
  long long v31 = v8;
  uint64_t v9 = &v30;
  if (v8) {
    goto LABEL_42;
  }
LABEL_38:
  uint64_t v29 = 0;
  uint64_t v18 = (char *)operator new(0x40uLL);
  uint64_t v27 = (uint64_t *)v18;
  xpc_object_t v28 = v7 + 1;
  BOOL v19 = v18 + 32;
  if (SHIBYTE(v23) < 0)
  {
    sub_10004FC84(v19, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)BOOL v19 = *(_OWORD *)__p;
    *((void *)v18 + 6) = v23;
  }
  *((_DWORD *)v18 + 14) = v24;
  LOBYTE(v29) = 1;
  sub_100046C38(v7, (uint64_t)v31, v9, (uint64_t *)v18);
  char v8 = v27;
LABEL_42:
  *(void *)(a3 + 8) = v8;
  uint64_t v20 = (uint64_t *)v8[1];
  if (v20)
  {
    do
    {
      uint64_t v21 = v20;
      uint64_t v20 = (uint64_t *)*v20;
    }
    while (v20);
  }
  else
  {
    do
    {
      uint64_t v21 = (uint64_t *)v8[2];
      BOOL v16 = *v21 == (void)v8;
      char v8 = v21;
    }
    while (!v16);
  }
  *(void *)(a3 + 8) = v21;
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
LABEL_49:
  if (SBYTE7(v26) < 0) {
    operator delete(v25[0]);
  }
}

void sub_100491D60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  sub_1000C6EE8(v25, v24);
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

void *sub_100491DB0(void *a1)
{
  *a1 = off_1019D1BA0;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100491DFC(void *a1)
{
  *a1 = off_1019D1BA0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100491E68(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019D1BA0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100491ECC(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019D1BA0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100491F0C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100491F1C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100491F5C(void *a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  if ((v3 - 1) >= 2) {
    unsigned __int8 v4 = 0;
  }
  else {
    unsigned __int8 v4 = a2[1];
  }
  if ((v3 - 1) >= 2) {
    int v5 = 0;
  }
  else {
    int v5 = *a2;
  }
  CFNumberRef v6 = (std::__shared_weak_count *)a1[3];
  if (v6)
  {
    uint64_t v7 = (void *)a1[1];
    char v8 = std::__shared_weak_count::lock(v6);
    if (v8)
    {
      uint64_t v9 = v8;
      if (a1[2])
      {
        if (v3 == 2)
        {
          uint64_t v10 = (std::__shared_weak_count *)v7[47];
          v7[46] = 0;
          v7[47] = 0;
          if (v10) {
            sub_10004D2C8(v10);
          }
          unint64_t v11 = v7[5];
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            if (v5 != 2)
            {
              exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
              if (v5 == 1)
              {
                uint64_t v15 = &ctu::ResultIsNotError::~ResultIsNotError;
                ctu::ResultIsNotError::ResultIsNotError(exception);
              }
              else
              {
                uint64_t v15 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
              }
              __cxa_throw(exception, v16, (void (*)(void *))v15);
            }
            int v17 = 136315138;
            uint64_t v18 = asString();
            _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to enable VSIM: %s", (uint8_t *)&v17, 0xCu);
          }
        }
        uint64_t v12 = v7[51];
        if (v12)
        {
          LOWORD(v17) = 0;
          if ((v5 - 1) <= 1)
          {
            LOBYTE(v17) = v5;
            BYTE1(v17) = v4;
          }
          (*(void (**)(uint64_t, int *))(*(void *)v12 + 48))(v12, &v17);
          LOBYTE(v17) = 0;
          __n128 v13 = (void *)v7[51];
          v7[51] = 0;
          if (v13 == v7 + 48)
          {
            (*(void (**)(void *))(v7[48] + 32))(v7 + 48);
          }
          else if (v13)
          {
            (*(void (**)(void *))(*v13 + 40))(v13);
          }
        }
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_100492190(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9)
{
  __cxa_free_exception(v10);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

uint64_t sub_1004921C4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100492204()
{
}

void *sub_100492210(void *a1)
{
  *a1 = off_1019D1C20;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10049225C(void *a1)
{
  *a1 = off_1019D1C20;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_1004922C8(uint64_t a1)
{
  uint64_t result = operator new(0x28uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_1019D1C20;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = *(void *)(a1 + 24);
  *((unsigned char *)result + 32) = *(unsigned char *)(a1 + 32);
  return result;
}

uint64_t sub_100492334(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *(void *)a2 = off_1019D1C20;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(result + 24);
  *(unsigned char *)(a2 + 32) = *(unsigned char *)(result + 32);
  *(void *)(a2 + 24) = v4;
  return result;
}

void sub_10049237C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10049238C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1004923CC(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    int v4 = *a2;
    int v5 = *(void **)(a1 + 24);
    CFNumberRef v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (*(void *)(a1 + 8) && v5[51])
      {
        if (v4)
        {
          (*(void (**)(void *, void))(*v5 + 232))(v5, *(unsigned __int8 *)(a1 + 32));
        }
        else
        {
          char v8 = v5[5];
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t v9 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "disable bootstrap assertion not granted, wait until it is granted", v9, 2u);
          }
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1004924A4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004924B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004924F8()
{
}

void *sub_100492504(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  void *v2 = 0;
  v2[1] = 0;
  sub_1000F0058((uint64_t)(v2 + 2), a1);
  return v2;
}

void sub_100492544(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_100492558(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D1CA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100492578(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D1CA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1004925CC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = (std::__shared_weak_count *)a1[4];
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_100492630()
{
}

void *sub_100492644(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1019D1CF0;
  result[1] = v3;
  return result;
}

uint64_t sub_10049268C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D1CF0;
  a2[1] = v2;
  return result;
}

void sub_1004926B8(uint64_t a1, unsigned char *a2)
{
  if (*a2)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    uint64_t v3 = (std::__shared_weak_count *)v2[17];
    if (v3)
    {
      int v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        uint64_t v5 = v2[16];
        if (v5)
        {
          if (*(_DWORD *)(*(void *)(v5 + 32) + 68) == 2)
          {
            uint64_t v6 = v2[45];
            v2[45] = 0;
            if (v6) {
              (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
            }
            sub_10048DC44(v2 + 55);
            uint64_t v7 = (void *)v2[20];
            if (v7 != v2 + 21)
            {
              while (1)
              {
                uint64_t v8 = v7[5];
                if (*(void *)(v8 + 160))
                {
                  if ((sub_100D25CF8(v7[5]) & 1) != 0 || *(void *)(v8 + 176)) {
                    break;
                  }
                }
                uint64_t v9 = (void *)v7[1];
                if (v9)
                {
                  do
                  {
                    uint64_t v10 = v9;
                    uint64_t v9 = (void *)*v9;
                  }
                  while (v9);
                }
                else
                {
                  do
                  {
                    uint64_t v10 = (void *)v7[2];
                    BOOL v11 = *v10 == (void)v7;
                    uint64_t v7 = v10;
                  }
                  while (!v11);
                }
                uint64_t v7 = v10;
                if (v10 == v2 + 21) {
                  goto LABEL_23;
                }
              }
              uint64_t v15 = v2[5];
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v16) = 0;
                _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Start next operation", (uint8_t *)&v16, 2u);
              }
              sub_100D25F88(v7[5], 0);
LABEL_23:
              if (!v4) {
                return;
              }
            }
          }
          else
          {
            uint64_t v14 = v2[5];
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v16) = 0;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Prevent baseband reset assertion not acquired - wait", (uint8_t *)&v16, 2u);
            }
          }
          sub_10004D2C8(v4);
          return;
        }
      }
    }
    else
    {
      int v4 = 0;
    }
    uint64_t v12 = v2[57];
    if (v12)
    {
      __n128 v13 = v2[5];
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        int v16 = 134217984;
        uint64_t v17 = v12;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "No assertion object?  Timeout callbacks waiting: %lu", (uint8_t *)&v16, 0xCu);
      }
    }
    goto LABEL_23;
  }
}

void sub_1004928E4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004928FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10049293C()
{
}

void sub_10049294C()
{
}

void *sub_100492960(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1019D1D70;
  result[1] = v3;
  return result;
}

uint64_t sub_1004929A8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D1D70;
  a2[1] = v2;
  return result;
}

void sub_1004929D4(uint64_t a1, unsigned char *a2)
{
  if (*a2)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    uint64_t v3 = (std::__shared_weak_count *)v2[17];
    if (v3)
    {
      int v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        uint64_t v5 = v4;
        uint64_t v6 = v2[16];
        if (v6)
        {
          if (*(_DWORD *)(*(void *)(v6 + 16) + 68) == 2)
          {
            uint64_t v7 = v2[45];
            v2[45] = 0;
            if (v7) {
              (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
            }
            sub_10048DC44(v2 + 55);
            uint64_t v8 = (void *)v2[20];
            if (v8 != v2 + 21)
            {
              while (1)
              {
                uint64_t v9 = v8[5];
                if (*(void *)(v9 + 160))
                {
                  if ((sub_100D25CF8(v8[5]) & 1) != 0 || *(void *)(v9 + 176)) {
                    break;
                  }
                }
                uint64_t v10 = (void *)v8[1];
                if (v10)
                {
                  do
                  {
                    BOOL v11 = v10;
                    uint64_t v10 = (void *)*v10;
                  }
                  while (v10);
                }
                else
                {
                  do
                  {
                    BOOL v11 = (void *)v8[2];
                    BOOL v12 = *v11 == (void)v8;
                    uint64_t v8 = v11;
                  }
                  while (!v12);
                }
                uint64_t v8 = v11;
                if (v11 == v2 + 21) {
                  goto LABEL_24;
                }
              }
              uint64_t v14 = v2[5];
              if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)uint64_t v15 = 0;
                _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Start next operation", v15, 2u);
              }
              sub_100D25F88(v8[5], 0);
            }
          }
          else
          {
            __n128 v13 = v2[5];
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Booted baseband not acquired - wait", buf, 2u);
            }
          }
        }
LABEL_24:
        sub_10004D2C8(v5);
      }
    }
  }
}

void sub_100492B74(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100492B8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100492BCC()
{
}

void sub_100492BDC()
{
}

void *sub_100492BF0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1019D1DF0;
  result[1] = v3;
  return result;
}

uint64_t sub_100492C38(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D1DF0;
  a2[1] = v2;
  return result;
}

void sub_100492C64(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100492D44(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100492D84()
{
}

void sub_100492D90(void **a1)
{
  uint64_t v1 = (void *)**a1;
  uint64_t v2 = v1[45];
  v1[45] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = v1 + 55;
  for (uint64_t i = (uint64_t *)v1[56]; i != v3; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v5 = i[5];
    if (!v5) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t))(*(void *)v5 + 48))(v5);
  }
  sub_10048DC44(v3);
  operator delete();
}

void sub_100492E6C()
{
}

uint64_t *sub_100492E9C(uint64_t **a1, void **a2, uint64_t a3, long long **a4)
{
  uint64_t v9 = 0;
  uint64_t v6 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v9, a2);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_100492F40((uint64_t)a1, a4, v8);
    sub_100046C38(a1, v9, v6, v8[0]);
    return v8[0];
  }
  return result;
}

unsigned char *sub_100492F40@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  uint64_t v6 = a3 + 1;
  uint64_t v7 = (char *)operator new(0x40uLL);
  *a3 = v7;
  *uint64_t v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = v7 + 32;
  uint64_t v9 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_10004FC84(result, *(void **)v9, *((void *)v9 + 1));
  }
  else
  {
    long long v10 = *v9;
    *((void *)v7 + 6) = *((void *)v9 + 2);
    *(_OWORD *)uint64_t result = v10;
  }
  *((_DWORD *)v7 + 14) = 0;
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100492FD8(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_1000C6EE8(v3, v2);
  _Unwind_Resume(a1);
}

void sub_100492FF8()
{
}

void *sub_10049300C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1019D1E70;
  return result;
}

void sub_100493044(uint64_t a1, void *a2)
{
  *a2 = off_1019D1E70;
}

void sub_10049306C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)a3;
  int v4 = *(char *)(a3 + 23);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  if (v4 < 0) {
    operator delete(v3);
  }
}

uint64_t sub_100493088(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1004930C8()
{
}

uint64_t *sub_1004930D4(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *v1;
  sub_1000278EC((uint64_t)v7, (uint64_t)(v1 + 1));
  uint64_t v9 = 0;
  uint64_t v3 = operator new(0x28uLL);
  void *v3 = off_1019D1EF0;
  sub_1000279CC((uint64_t)(v3 + 1), (uint64_t)v7);
  uint64_t v9 = v3;
  sub_100480F48(v2, 1, (uint64_t)v8);
  sub_1000DBADC(v8);
  sub_10001E914(v7);
  sub_1004931DC((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1004931A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v7 = va_arg(va3, void);
  uint64_t v9 = va_arg(va3, void);
  uint64_t v10 = va_arg(va3, void);
  uint64_t v11 = va_arg(va3, void);
  sub_1000DBADC((uint64_t *)va3);
  sub_10001E914((uint64_t *)va2);
  sub_1004931DC((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1004931DC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_10001E914((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

void *sub_10049322C(void *a1)
{
  *a1 = off_1019D1EF0;
  sub_10001E914(a1 + 1);
  return a1;
}

void sub_100493270(void *a1)
{
  *a1 = off_1019D1EF0;
  sub_10001E914(a1 + 1);

  operator delete();
}

void *sub_1004932D4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_1019D1EF0;
  sub_1000278EC((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100493328(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10049333C(uint64_t a1, void *a2)
{
  *a2 = off_1019D1EF0;
  return sub_1000278EC((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_100493368(uint64_t a1)
{
  return sub_10001E914((void *)(a1 + 8));
}

void sub_100493370(void *a1)
{
  sub_10001E914(a1 + 1);

  operator delete(a1);
}

void sub_1004933AC(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  int v5 = *a2;
  uint64_t v7 = *(void **)a3;
  uint64_t v6 = *(void **)(a3 + 8);
  *(_DWORD *)uint64_t v10 = *(_DWORD *)(a3 + 16);
  *(_DWORD *)&v10[3] = *(_DWORD *)(a3 + 19);
  int v8 = *(char *)(a3 + 23);
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  if (v5)
  {
    if (v8 < 0)
    {
      sub_10004FC84(__p, v7, (unint64_t)v6);
    }
    else
    {
      __p[0] = v7;
      __p[1] = v6;
      *(_DWORD *)BOOL v12 = *(_DWORD *)v10;
      *(_DWORD *)&v12[3] = *(_DWORD *)&v10[3];
      char v13 = v8;
    }
  }
  else
  {
    sub_100058DB0(__p, "");
  }
  uint64_t v9 = *(void *)(a1 + 32);
  if (!v9) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v9 + 48))(v9, __p);
  if ((v13 & 0x80000000) == 0)
  {
    if ((v8 & 0x80000000) == 0) {
      return;
    }
LABEL_11:
    operator delete(v7);
    return;
  }
  operator delete(__p[0]);
  if (v8 < 0) {
    goto LABEL_11;
  }
}

void sub_1004934A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (v16 < 0) {
    operator delete(v15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004934D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100493514()
{
}

uint64_t *sub_100493520(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v9 = *(void *)v1;
  uint64_t v2 = v9;
  uint64_t v10 = 0;
  *(void *)uint64_t v11 = 0;
  uint64_t v12 = 0;
  sub_10005C928(&v10, *(const void **)(v1 + 8), *(void *)(v1 + 16), *(void *)(v1 + 16) - *(void *)(v1 + 8));
  __n128 __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  sub_10005C928(&__p, *(const void **)(v1 + 32), *(void *)(v1 + 40), *(void *)(v1 + 40) - *(void *)(v1 + 32));
  sub_1004913B0((uint64_t)v16, v1 + 56);
  uint64_t v18 = 0;
  uint64_t v3 = operator new(0x60uLL);
  uint64_t v5 = v9;
  int v4 = v10;
  void *v3 = off_1019D1F70;
  v3[1] = v5;
  void v3[2] = 0;
  v3[3] = 0;
  v3[4] = 0;
  sub_10005C928(v3 + 2, v4, *(uint64_t *)v11, *(void *)v11 - (void)v4);
  v3[5] = 0;
  v3[6] = 0;
  v3[7] = 0;
  sub_10005C928(v3 + 5, __p, (uint64_t)v14, v14 - (unsigned char *)__p);
  sub_1004914CC((uint64_t)(v3 + 8), (uint64_t)v16);
  uint64_t v18 = v3;
  sub_100480F48(v2, 1, (uint64_t)v17);
  sub_1000DBADC(v17);
  sub_100491448(v16);
  if (__p)
  {
    uint64_t v14 = __p;
    operator delete(__p);
  }
  if (v10)
  {
    *(void *)uint64_t v11 = v10;
    operator delete(v10);
  }
  sub_100493724(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100493690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  sub_1000DBADC((void *)(v17 - 72));
  sub_100491448(v16);
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a12)
  {
    a13 = (uint64_t)a12;
    operator delete(a12);
  }
  sub_100493724(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void *sub_100493724(void *result)
{
  uint64_t v1 = (void *)*result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100491448(v1 + 7);
    uint64_t v2 = (void *)v1[4];
    if (v2)
    {
      v1[5] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[1];
    if (v3)
    {
      v1[2] = v3;
      operator delete(v3);
    }
    operator delete();
  }
  return result;
}

void *sub_100493794(void *a1)
{
  *a1 = off_1019D1F70;
  sub_100491448(a1 + 8);
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1004937F8(void *a1)
{
  *a1 = off_1019D1F70;
  sub_100491448(a1 + 8);
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }

  operator delete();
}

void *sub_10049387C(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x60uLL);
  void *v2 = off_1019D1F70;
  sub_100493C0C(v2 + 1, v1);
  return v2;
}

void sub_1004938D0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1004938E4(uint64_t a1, void *a2)
{
  *a2 = off_1019D1F70;
  return sub_100493C0C(a2 + 1, (uint64_t *)(a1 + 8));
}

void sub_100493910(uint64_t a1)
{
}

void sub_100493918(void *a1)
{
  sub_100493CC0(a1 + 1);

  operator delete(a1);
}

void sub_100493954(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  int v4 = *a2;
  *(_OWORD *)uint64_t v7 = *(_OWORD *)a3;
  uint64_t v8 = *(void *)(a3 + 16);
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  uint64_t v5 = *(void **)(a1 + 8);
  if (v4)
  {
    char v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    sub_10005C928(&v13, *(const void **)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 24) - *(void *)(a1 + 16));
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    sub_10005C928(&v10, *(const void **)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 48) - *(void *)(a1 + 40));
    ctu::base64::decode();
    sub_1004913B0((uint64_t)buf, a1 + 64);
    (*(void (**)(void *, void **, void **, void **, void *))(*v5 + 56))(v5, &v13, &v10, __p, buf);
    sub_100491448(buf);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v10)
    {
      uint64_t v11 = v10;
      operator delete(v10);
    }
    if (v13)
    {
      uint64_t v14 = v13;
      operator delete(v13);
    }
  }
  else
  {
    uint64_t v6 = v5[5];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "No attestation token", (uint8_t *)buf, 2u);
    }
    LOBYTE(buf[0]) = 0;
    char v17 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    char v13 = 0;
    sub_10048548C(a1 + 64, (uint64_t)buf, (uint64_t)&v13, 259);
    if (v13)
    {
      uint64_t v14 = v13;
      operator delete(v13);
    }
    if (v17) {
      sub_10026CF54((uint64_t)buf, (void *)buf[1]);
    }
  }
  if (SHIBYTE(v8) < 0) {
    operator delete(v7[0]);
  }
}

void sub_100493B20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22)
{
  if (__p) {
    operator delete(__p);
  }
  if (*(unsigned char *)(v22 - 40)) {
    sub_10026CF54(v22 - 64, *(void **)(v22 - 56));
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100493BC0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100493C00()
{
}

void *sub_100493C0C(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  a1[1] = 0;
  *a1 = v4;
  a1[2] = 0;
  a1[3] = 0;
  sub_10005C928(a1 + 1, (const void *)a2[1], a2[2], a2[2] - a2[1]);
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  sub_10005C928(a1 + 4, (const void *)a2[4], a2[5], a2[5] - a2[4]);
  sub_1004913B0((uint64_t)(a1 + 7), (uint64_t)(a2 + 7));
  return a1;
}

void sub_100493C8C(_Unwind_Exception *exception_object)
{
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 40) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

void sub_100493CC0(void *a1)
{
  sub_100491448(a1 + 7);
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
}

const void **sub_100493D20(uint64_t a1, const void **a2)
{
  if (*(unsigned char *)a1 == 1) {
    return sub_100449580((const void **)(a1 + 8), a2);
  }
  *(unsigned char *)a1 = 1;
  return sub_100062740((const void **)(a1 + 8), a2);
}

std::string *sub_100493D40(uint64_t a1, const std::string *a2)
{
  if (*(unsigned char *)a1 == 1) {
    return std::string::operator=((std::string *)(a1 + 8), a2);
  }
  *(unsigned char *)a1 = 1;
  uint64_t result = (std::string *)(a1 + 8);
  if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0) {
    return (std::string *)sub_10004FC84(result, a2->__r_.__value_.__l.__data_, a2->__r_.__value_.__l.__size_);
  }
  long long v3 = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
  result->__r_.__value_.__r.__words[2] = a2->__r_.__value_.__r.__words[2];
  *(_OWORD *)&result->__r_.__value_.__l.__data_ = v3;
  return result;
}

void sub_100493D84(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v4 = *a1;
  if (v4 == 1)
  {
    if ((char)a1[31] < 0) {
      operator delete(*((void **)a1 + 1));
    }
    goto LABEL_6;
  }
  if (v4 != 2) {
LABEL_6:
  }
    *a1 = 2;
  a1[8] = *a2;
}

uint64_t sub_100493DE0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100493E78(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100493EFC(uint64_t a1)
{
  *(void *)a1 = off_1019D1FF0;
  sub_100493E78((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100493F50(uint64_t a1)
{
  *(void *)a1 = off_1019D1FF0;
  sub_100493E78((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100493FC4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x48uLL);
  void *v2 = off_1019D1FF0;
  sub_100494374((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100494018(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10049402C(uint64_t a1, void *a2)
{
  *a2 = off_1019D1FF0;
  return sub_100494374((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100494058(uint64_t a1)
{
}

void sub_100494060(void *a1)
{
  sub_100494404((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10049409C(uint64_t a1, unsigned __int8 *a2)
{
  *(_OWORD *)__n128 __p = 0u;
  long long v11 = 0u;
  sub_100494454((unsigned __int8 *)__p, a2);
  int v3 = LOBYTE(__p[0]);
  if (LOBYTE(__p[0]) == 1)
  {
    buf[0] = 0;
    sub_100493D40((uint64_t)buf, (const std::string *)&__p[1]);
    uint64_t v4 = *(void *)(a1 + 64);
    if (!v4) {
      sub_10007B600();
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = a1 + 16;
      if (*(char *)(a1 + 39) < 0) {
        uint64_t v6 = *(void *)(a1 + 16);
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)char v13 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "failed: tape get associated imei for %s", buf, 0xCu);
      int v3 = LOBYTE(__p[0]);
    }
    if (v3 != 2)
    {
      exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      if (v3 == 1)
      {
        uint64_t v8 = &ctu::ResultIsNotError::~ResultIsNotError;
        ctu::ResultIsNotError::ResultIsNotError(exception);
      }
      else
      {
        uint64_t v8 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
      }
      __cxa_throw(exception, v9, (void (*)(void *))v8);
    }
    buf[0] = 2;
    void v13[4] = __p[1];
    uint64_t v4 = *(void *)(a1 + 64);
    if (!v4) {
      sub_10007B600();
    }
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 48))(v4, buf);
  if (buf[0] == 1 && v14 < 0) {
    operator delete(*(void **)&v13[4]);
  }
  if (LOBYTE(__p[0]) == 1 && SHIBYTE(v11) < 0) {
    operator delete(__p[1]);
  }
}

void sub_1004942C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  __cxa_free_exception(v22);
  if (a9 == 1 && a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100494328(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019D2050)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100494368()
{
  return &off_1019D2050;
}

uint64_t sub_100494374(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  sub_100493DE0(a1 + 32, a2 + 32);
  return a1;
}

void sub_1004943E8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100494404(uint64_t a1)
{
  sub_100493E78((void *)(a1 + 32));
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    operator delete(v2);
  }
}

unsigned __int8 *sub_100494454(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  if (v3 == 2)
  {
    sub_100493D84(a1, a2 + 8);
  }
  else if (v3 == 1)
  {
    sub_1004944A8((uint64_t)a1, (__n128 *)(a2 + 8));
  }
  return a1;
}

__n128 sub_1004944A8(uint64_t a1, __n128 *a2)
{
  if (*(unsigned char *)a1 == 1)
  {
    uint64_t v3 = a1 + 8;
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)v3);
    }
    __n128 result = *a2;
    *(void *)(v3 + 16) = a2[1].n128_u64[0];
    *(__n128 *)uint64_t v3 = result;
    a2[1].n128_u8[7] = 0;
    a2->n128_u8[0] = 0;
  }
  else
  {
    *(unsigned char *)a1 = 1;
    __n128 result = *a2;
    *(void *)(a1 + 24) = a2[1].n128_u64[0];
    *(__n128 *)(a1 + 8) = result;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    a2->n128_u64[0] = 0;
  }
  return result;
}

void sub_100494528()
{
}

uint64_t sub_10049453C()
{
  return 0;
}

void *sub_100494544(uint64_t a1, void *a2)
{
  *a2 = off_1019D2070;
  __n128 result = *(void **)(a1 + 8);
  if (result) {
    __n128 result = _Block_copy(result);
  }
  a2[1] = result;
  return result;
}

void sub_100494590(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  *(void *)(a1 + 8) = 0;
}

void sub_1004945C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a3 + 16);
  *(_OWORD *)__n128 __p = *(_OWORD *)a3;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  (*(void (**)(void))(v3 + 16))();
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10049462C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100494648(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019D20D0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100494688()
{
  return &off_1019D20D0;
}

uint64_t *sub_100494694(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(*(void *)v1 + 80) + 72))(&v8);
  uint64_t v2 = v9;
  v10[0] = v8;
  v10[1] = v9;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  char v3 = sub_100494888((capabilities::ct *)v10);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v3)
  {
    sub_10033571C((uint64_t)&v8, v1 + 8);
    long long v11 = 0;
    long long v4 = operator new(0x28uLL);
    void *v4 = off_1019D20F0;
    sub_1003357B4((uint64_t)(v4 + 1), (uint64_t)&v8);
    long long v11 = v4;
    VinylCommandDriver::getVinylSlotTestMode();
    sub_100060644(v10);
    sub_1000F25E0(&v8);
  }
  else
  {
    sub_100335978(v1 + 8, 0);
  }
  sub_100494838(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_1004947DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v7 = va_arg(va3, void);
  uint64_t v9 = va_arg(va3, void);
  uint64_t v10 = va_arg(va3, void);
  uint64_t v11 = va_arg(va3, void);
  sub_100060644((uint64_t *)va3);
  sub_1000F25E0((uint64_t *)va2);
  sub_100494838((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100494838(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_1000F25E0((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100494888(capabilities::ct *a1)
{
  if (!capabilities::ct::supportsVinylTestMode(a1)) {
    return 0;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v25 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v25);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_11:
  if ((*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10))
  {
    uint64_t v12 = 1;
    if (v11) {
      return v12;
    }
    goto LABEL_22;
  }
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v10 + 24))(v10))
  {
    uint64_t v12 = 0;
    if (v11) {
      return v12;
    }
LABEL_22:
    sub_10004D2C8(v9);
    return v12;
  }
  char v13 = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
  char v14 = v13;
  if ((v15 & 0x8000000000000000) != 0)
  {
    int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      unint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(v13);
  unint64_t v25 = v15;
  BOOL v19 = sub_10004D37C(&v14[1].__m_.__sig, &v25);
  if (v19)
  {
    uint64_t v21 = v19[3];
    uint64_t v20 = (std::__shared_weak_count *)v19[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v14);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v20);
      char v22 = 0;
      goto LABEL_26;
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  std::mutex::unlock(v14);
  uint64_t v20 = 0;
  char v22 = 1;
LABEL_26:
  unint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 128))(v21);
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  if ((v24 & 0xFF00000000) != 0) {
    uint64_t v12 = (v24 >> 5) & 1;
  }
  else {
    uint64_t v12 = 0;
  }
  if ((v11 & 1) == 0) {
    goto LABEL_22;
  }
  return v12;
}

void sub_100494ACC(_Unwind_Exception *exception_object)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100494B04(void *a1)
{
  *a1 = off_1019D20F0;
  sub_1000F25E0(a1 + 1);
  return a1;
}

void sub_100494B48(void *a1)
{
  *a1 = off_1019D20F0;
  sub_1000F25E0(a1 + 1);

  operator delete();
}

void *sub_100494BAC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_1019D20F0;
  sub_10033571C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100494C00(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100494C14(uint64_t a1, void *a2)
{
  *a2 = off_1019D20F0;
  return sub_10033571C((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_100494C40(uint64_t a1)
{
  return sub_1000F25E0((void *)(a1 + 8));
}

void sub_100494C48(void *a1)
{
  sub_1000F25E0(a1 + 1);

  operator delete(a1);
}

uint64_t sub_100494C84(uint64_t a1, unsigned __int8 *a2)
{
  return sub_100335978(a1 + 8, *a2 | 0x100u);
}

uint64_t sub_100494C94(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100494CD4()
{
}

uint64_t *sub_100494CE0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(*(void *)v1 + 80) + 72))(&v7);
  uint64_t v2 = v8;
  v9[0] = v7;
  v9[1] = v8;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  char v3 = sub_100494888((capabilities::ct *)v9);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v3)
  {
    sub_1000DFC90((uint64_t)v9, v1 + 16);
    VinylCommandDriver::enableVinylSlotTestMode();
    sub_100060644(v9);
  }
  else
  {
    sub_1000607A8(v1 + 16, 0);
  }
  sub_100494E40(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100494DF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v8 = va_arg(va2, void);
  sub_100060644((uint64_t *)va2);
  sub_100494E40((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100494E40(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_100494E90(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
}

void sub_100494EA4(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = v5;
  long long v5 = 0uLL;
  char v4 = *(std::__shared_weak_count **)(v2 + 8);
  *(_OWORD *)uint64_t v2 = v3;
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*((void *)&v5 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v5 + 1));
  }
}

void sub_100494F0C(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = v5;
  long long v5 = 0uLL;
  char v4 = *(std::__shared_weak_count **)(v2 + 8);
  *(_OWORD *)uint64_t v2 = v3;
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*((void *)&v5 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v5 + 1));
  }
}

void *sub_100494F74(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

uint64_t sub_100494F88(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100494FC4(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

void sub_100495004()
{
}

void *sub_100495018(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1019D2230;
  result[1] = v3;
  return result;
}

uint64_t sub_100495060(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D2230;
  a2[1] = v2;
  return result;
}

void sub_10049508C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10049516C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1004951AC()
{
}

void sub_1004951B8(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(v1 + 464);
    *(_DWORD *)long long buf = 67109120;
    int v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I releasing booted assertion with %d holders", buf, 8u);
  }
  *(_DWORD *)(v1 + 464) = 0;
  char v4 = *(std::__shared_weak_count **)(v1 + 344);
  *(void *)(v1 + 336) = 0;
  *(void *)(v1 + 344) = 0;
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(void *)(v1 + 352);
  *(void *)(v1 + 352) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  operator delete();
}

void sub_1004952CC(void *a1@<X0>, uint64_t a2@<X8>)
{
  id v3 = a1;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)a2 = a2 + 8;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v4 = v3;
  id v5 = [v4 countByEnumeratingWithState:&v9 objects:v13 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v10;
    do
    {
      int v7 = 0;
      do
      {
        if (*(void *)v10 != v6) {
          objc_enumerationMutation(v4);
        }
        uint64_t v8 = (char *)[*(id *)(*((void *)&v9 + 1) + 8 * (void)v7) UTF8String];
        sub_100495908((uint64_t **)a2, &v8);
        int v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id v5 = [v4 countByEnumeratingWithState:&v9 objects:v13 count:16];
    }
    while (v5);
  }
}

void sub_1004953E4(_Unwind_Exception *a1)
{
  sub_10005CD2C(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

id sub_100495418(void *a1)
{
  uint64_t v2 = +[NSMutableSet setWithCapacity:a1[2]];
  id v3 = (void *)*a1;
  id v4 = a1 + 1;
  if ((void *)*a1 != a1 + 1)
  {
    do
    {
      id v5 = objc_alloc((Class)NSString);
      uint64_t v6 = v3 + 4;
      if (*((char *)v3 + 55) < 0) {
        uint64_t v6 = (void *)*v6;
      }
      id v7 = [v5 initWithUTF8String:v6];
      [v2 addObject:v7];

      uint64_t v8 = (void *)v3[1];
      if (v8)
      {
        do
        {
          long long v9 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          long long v9 = (void *)v3[2];
          BOOL v10 = *v9 == (void)v3;
          id v3 = v9;
        }
        while (!v10);
      }
      id v3 = v9;
    }
    while (v9 != v4);
  }
  id v11 = [v2 copy];
  long long v12 = +[NSSet setWithSet:v11];

  return v12;
}

void sub_100495520(_Unwind_Exception *a1)
{
  id v3 = v2;

  _Unwind_Resume(a1);
}

unint64_t sub_100495548(void *a1)
{
  id v1 = a1;
  id v2 = [v1 cellular];
  id v3 = [v1 wifi];
  [v1 isManaged];
  [v1 isRestricted];

  return (v2 != 0) | ((unint64_t)(v3 != 0) << 32);
}

void sub_1004955D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1004955E4(void *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)a2 = a2 + 8;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v3 = [a1 policies];
  id v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v11;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v11 != v5) {
          objc_enumerationMutation(v3);
        }
        id v7 = *(void **)(*((void *)&v10 + 1) + 8 * i);
        id v8 = [v7 bundleId];
        long long v9 = (char *)[v8 UTF8String];
        sub_100495548(v7);
        sub_100495A50((uint64_t **)a2, &v9);
      }
      id v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v4);
  }
}

void sub_100495738(_Unwind_Exception *a1)
{
  sub_10005CD2C(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

id sub_100495780(void *a1)
{
  id v2 = +[NSMutableSet setWithCapacity:a1[2]];
  id v3 = (void *)*a1;
  id v4 = a1 + 1;
  if ((void *)*a1 != a1 + 1)
  {
    do
    {
      id v5 = objc_alloc((Class)CTDataUsagePolicies);
      id v6 = objc_alloc((Class)NSString);
      id v7 = v3 + 4;
      if (*((char *)v3 + 55) < 0) {
        id v7 = (void *)*v7;
      }
      id v8 = [v6 initWithUTF8String:v7];
      id v9 = [v5 init:v8 withCellularPolicy:*((_DWORD *)v3 + 14) != 0 wifiPolicy:*((_DWORD *)v3 + 15) != 0 isManaged:*((unsigned __int8 *)v3 + 64) andIsRestricted:*((unsigned __int8 *)v3 + 65)];
      [v2 addObject:v9];

      long long v10 = (void *)v3[1];
      if (v10)
      {
        do
        {
          long long v11 = v10;
          long long v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          long long v11 = (void *)v3[2];
          BOOL v12 = *v11 == (void)v3;
          id v3 = v11;
        }
        while (!v12);
      }
      id v3 = v11;
    }
    while (v11 != v4);
  }
  id v13 = objc_alloc((Class)CTDataUsagePoliciesWrapper);
  id v14 = [v2 copy];
  id v15 = [v13 initWithPolicies:v14];

  return v15;
}

void sub_1004958D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *sub_100495908(uint64_t **a1, char **a2)
{
  __n128 __p = 0;
  v9[0] = 0;
  v9[1] = 0;
  sub_1004959C0((uint64_t)a1, a2, &__p);
  uint64_t v7 = 0;
  id v3 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v7, (void **)__p + 4);
  id v4 = *v3;
  if (*v3)
  {
    id v5 = (void **)__p;
    __n128 __p = 0;
    if (v5) {
      sub_1000C6EE8((uint64_t)v9, v5);
    }
  }
  else
  {
    sub_100046C38(a1, v7, v3, (uint64_t *)__p);
    return (uint64_t *)__p;
  }
  return v4;
}

void sub_10049599C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p) {
    sub_1000C6EE8((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1004959C0@<X0>(uint64_t a1@<X0>, char **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  id v6 = a3 + 1;
  uint64_t v7 = operator new(0x38uLL);
  *a3 = v7;
  *id v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = sub_100058DB0(v7 + 4, *a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100495A34(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_1000C6EE8(v2, v3);
  _Unwind_Resume(a1);
}

uint64_t *sub_100495A50(uint64_t **a1, char **a2)
{
  __n128 __p = 0;
  v9[0] = 0;
  v9[1] = 0;
  sub_100495B08((uint64_t)a1, a2, &__p);
  uint64_t v7 = 0;
  id v3 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v7, (void **)__p + 4);
  id v4 = *v3;
  if (*v3)
  {
    uint64_t v5 = (void **)__p;
    __n128 __p = 0;
    if (v5) {
      sub_1000C6EE8((uint64_t)v9, v5);
    }
  }
  else
  {
    sub_100046C38(a1, v7, v3, (uint64_t *)__p);
    return (uint64_t *)__p;
  }
  return v4;
}

void sub_100495AE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p) {
    sub_1000C6EE8((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100495B08@<X0>(uint64_t a1@<X0>, char **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  id v6 = a3 + 1;
  uint64_t v7 = operator new(0x48uLL);
  *a3 = v7;
  *id v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = sub_100495BB0((uint64_t)v7 + 32, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100495B94(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_1000C6EE8(v2, v3);
  _Unwind_Resume(a1);
}

uint64_t sub_100495BB0(uint64_t a1, char **a2)
{
  sub_100058DB0(&__p, *a2);
  du::policy::BundleProperties::BundleProperties();
  if (v5 < 0) {
    operator delete(__p);
  }
  return a1;
}

void sub_100495C20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100495C3C()
{
  return sub_100495CB8((wis::MetricFactory *)0x80141);
}

uint64_t sub_100495CB8(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    id v4 = (wis::MetricContainer *)v3;
    char v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    id v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_100495E14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_100495E98(uint64_t a1, uint64_t a2)
{
  id v4 = *(const std::string **)(a1 + 32);
  *(_DWORD *)(a2 + 56) |= 2u;
  char v5 = *(std::string **)(a2 + 16);
  if (v5 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v5, v4);
  id v6 = *(const std::string **)(a1 + 40);
  *(_DWORD *)(a2 + 56) |= 4u;
  uint64_t v7 = *(std::string **)(a2 + 24);
  if (v7 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v7, v6);
  id v8 = *(const std::string **)(a1 + 48);
  *(_DWORD *)(a2 + 56) |= 8u;
  id v9 = *(std::string **)(a2 + 32);
  if (v9 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v9, v8);
  long long v10 = *(const std::string **)(a1 + 56);
  *(_DWORD *)(a2 + 56) |= 8u;
  long long v11 = *(std::string **)(a2 + 32);
  if (v11 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v11, v10);
  if (**(unsigned char **)(a1 + 64)) {
    uint64_t v13 = 2;
  }
  else {
    uint64_t v13 = 1;
  }
  uint64_t result = awd::metrics::CommCenterSubscriptionImeiChangeReason_IsValid((awd::metrics *)v13, v12);
  if ((result & 1) == 0) {
    __assert_rtn("set_reason", "CCMetricsCP.pb.h", 9958, "::awd::metrics::CommCenterSubscriptionImeiChangeReason_IsValid(value)");
  }
  *(_DWORD *)(a2 + 56) |= 0x20u;
  *(_DWORD *)(a2 + 48) = v13;
  return result;
}

void *sub_10049603C@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = operator new(0x30uLL);
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = off_1019D2320;
  uint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  result[3] = off_1019D22E0;
  result[4] = v6;
  result[5] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = off_1019D2370;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1004960E0(uint64_t a1@<X0>, void *a2@<X8>)
{
  id v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v4) {
    goto LABEL_8;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v4);
  if (!v5) {
    goto LABEL_8;
  }
  uint64_t v6 = v5;
  if (!*(void *)(a1 + 8))
  {
    sub_10004D2C8(v5);
LABEL_8:
    *a2 = 0;
    a2[1] = 0;
    return;
  }
  uint64_t v7 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_101033FD8(&v8);
  *(_OWORD *)a2 = v8;
  long long v8 = 0uLL;
  sub_10004D2C8(v7);
  sub_10004D2C8(v6);
}

void sub_10049617C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_10049619C(LocalAuthenticationFactoryInterface *this)
{
  *(void *)this = off_1019D22E0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  LocalAuthenticationFactoryInterface::~LocalAuthenticationFactoryInterface(this);
}

void sub_1004961F8(LocalAuthenticationFactoryInterface *this)
{
  *(void *)this = off_1019D22E0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  LocalAuthenticationFactoryInterface::~LocalAuthenticationFactoryInterface(this);

  operator delete();
}

void sub_100496268(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D2320;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100496288(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D2320;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004962DC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100496304(LocalAuthenticationFactoryInterface *this)
{
  *(void *)this = off_1019D22E0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  LocalAuthenticationFactoryInterface::~LocalAuthenticationFactoryInterface(this);
}

void sub_100496360(LocalAuthenticationFactoryInterface *this)
{
  *(void *)this = off_1019D22E0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  LocalAuthenticationFactoryInterface::~LocalAuthenticationFactoryInterface(this);

  operator delete();
}

uint64_t *sub_1004963D0(uint64_t *a1, uint64_t a2, uint64_t *a3, const void **a4, char a5, const void **a6)
{
  *a1 = *a3;
  uint64_t v8 = a3[1];
  a1[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *((unsigned char *)a1 + 16) = a5;
  sub_100083DA4((const void **)a1 + 3, a6);
  a1[7] = 0;
  a1[6] = (uint64_t)(a1 + 7);
  a1[4] = 0;
  id v9 = (__CFDictionary **)(a1 + 4);
  a1[5] = 0;
  a1[8] = 0;
  a1[9] = a2;
  a1[10] = 0;
  uint64_t v80 = (std::string *)(a1 + 10);
  long long v81 = (std::string *)(a1 + 5);
  sub_100058198((const void **)&theDict, a4);
  long long v89 = 0;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  sub_1003AA8C0(&v89, (CFTypeRef *)&buf.__r_.__value_.__l.__data_);
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"MobileDeviceCarriersByCarrierID");
  CFDictionaryRef v11 = Value;
  if (Value)
  {
    CFTypeID v12 = CFGetTypeID(Value);
    if (v12 == CFDictionaryGetTypeID())
    {
      copyMergedDictionaries(v89, v11, &v109);
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v89;
      long long v89 = (__CFDictionary *)v109.__r_.__value_.__r.__words[0];
      v109.__r_.__value_.__r.__words[0] = 0;
      sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
      sub_100057D78((const void **)&v109.__r_.__value_.__l.__data_);
    }
  }
  CFDictionaryRef v13 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"MobileDeviceCarriersByMccMnc");
  CFDictionaryRef v14 = v13;
  if (v13)
  {
    CFTypeID v15 = CFGetTypeID(v13);
    if (v15 == CFDictionaryGetTypeID())
    {
      Mutable = 0;
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFIndex Count = CFDictionaryGetCount(v14);
      std::string v104 = 0;
      int v105 = 0;
      uint64_t v106 = 0;
      sub_10004EE3C(&v104, Count);
      int v101 = 0;
      uint64_t v102 = 0;
      uint64_t v103 = 0;
      sub_10004EE3C(&v101, Count);
      CFDictionaryGetKeysAndValues(v14, v104, v101);
      CFIndex v83 = Count;
      if (Count >= 1)
      {
        uint64_t v17 = 0;
        do
        {
          unsigned int v18 = v104[v17];
          if (v18)
          {
            CFTypeID v19 = CFGetTypeID(v104[v17]);
            if (v19 != CFStringGetTypeID()) {
              unsigned int v18 = 0;
            }
          }
          unint64_t v100 = v18;
          CFDictionaryRef v20 = (const __CFDictionary *)v101[v17];
          if (v20)
          {
            CFTypeID v21 = CFGetTypeID(v101[v17]);
            if (v21 != CFDictionaryGetTypeID()) {
              CFDictionaryRef v20 = 0;
            }
          }
          char v22 = CFDictionaryGetValue(v20, @"BundleName");
          uint64_t v23 = v22;
          if (v22)
          {
            CFTypeID v24 = CFGetTypeID(v22);
            if (v24 == CFStringGetTypeID()) {
              CFDictionarySetValue(Mutable, v18, v23);
            }
          }
          CFArrayRef v25 = (const __CFArray *)CFDictionaryGetValue(v20, @"MVNOs");
          CFArrayRef v26 = v25;
          if (v25)
          {
            CFTypeID v27 = CFGetTypeID(v25);
            if (v27 == CFArrayGetTypeID())
            {
              CFIndex v28 = CFArrayGetCount(v26);
              if (v28 >= 1)
              {
                for (CFIndex i = 0; i != v28; ++i)
                {
                  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v26, i);
                  CFDictionaryRef v31 = ValueAtIndex;
                  if (ValueAtIndex)
                  {
                    CFTypeID v32 = CFGetTypeID(ValueAtIndex);
                    if (v32 == CFDictionaryGetTypeID()) {
                      CFDictionaryRef v33 = v31;
                    }
                    else {
                      CFDictionaryRef v33 = 0;
                    }
                  }
                  else
                  {
                    CFDictionaryRef v33 = 0;
                  }
                  long long v34 = CFDictionaryGetValue(v33, @"BundleName");
                  xpc_object_t v35 = v34;
                  if (v34)
                  {
                    CFTypeID v36 = CFGetTypeID(v34);
                    if (v36 == CFStringGetTypeID())
                    {
                      memset(&v99, 0, sizeof(v99));
                      sub_1000292E0((uint64_t)&v99);
                      uint64_t v37 = CFDictionaryGetValue(v33, @"GID1");
                      xpc_object_t v38 = v37;
                      if (v37 && (CFTypeID v39 = CFGetTypeID(v37), v39 == CFStringGetTypeID()))
                      {
                        std::string v98 = v38;
                        sub_1000292E0((uint64_t)&v97);
                        xpc_object_t v40 = std::string::insert(&v97, 0, "_", 1uLL);
                        long long v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
                        v109.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&v109.__r_.__value_.__l.__data_ = v41;
                        v40->__r_.__value_.__l.__size_ = 0;
                        v40->__r_.__value_.__r.__words[2] = 0;
                        v40->__r_.__value_.__r.__words[0] = 0;
                        sub_1000292E0((uint64_t)&__p);
                        if ((v96 & 0x80u) == 0) {
                          p_p = (const std::string::value_type *)&__p;
                        }
                        else {
                          p_p = (const std::string::value_type *)__p;
                        }
                        if ((v96 & 0x80u) == 0) {
                          std::string::size_type v43 = v96;
                        }
                        else {
                          std::string::size_type v43 = v95;
                        }
                        long long v44 = std::string::append(&v109, p_p, v43);
                        long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
                        buf.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v45;
                        v44->__r_.__value_.__l.__size_ = 0;
                        v44->__r_.__value_.__r.__words[2] = 0;
                        v44->__r_.__value_.__r.__words[0] = 0;
                        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          p_std::string buf = &buf;
                        }
                        else {
                          p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
                        }
                        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                        }
                        else {
                          std::string::size_type size = buf.__r_.__value_.__l.__size_;
                        }
                        std::string::append(&v99, (const std::string::value_type *)p_buf, size);
                        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(buf.__r_.__value_.__l.__data_);
                        }
                        if ((char)v96 < 0) {
                          operator delete(__p);
                        }
                        if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v109.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v97.__r_.__value_.__l.__data_);
                        }
                      }
                      else
                      {
                        std::string v98 = 0;
                      }
                      uint64_t v48 = CFDictionaryGetValue(v33, @"GID2");
                      int v49 = v48;
                      if (v48 && (CFTypeID v50 = CFGetTypeID(v48), v50 == CFStringGetTypeID()))
                      {
                        int v93 = v49;
                        sub_1000292E0((uint64_t)&v97);
                        unint64_t v51 = std::string::insert(&v97, 0, "_", 1uLL);
                        long long v52 = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
                        v109.__r_.__value_.__r.__words[2] = v51->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&v109.__r_.__value_.__l.__data_ = v52;
                        v51->__r_.__value_.__l.__size_ = 0;
                        v51->__r_.__value_.__r.__words[2] = 0;
                        v51->__r_.__value_.__r.__words[0] = 0;
                        sub_1000292E0((uint64_t)&__p);
                        if ((v96 & 0x80u) == 0) {
                          long long v53 = (const std::string::value_type *)&__p;
                        }
                        else {
                          long long v53 = (const std::string::value_type *)__p;
                        }
                        if ((v96 & 0x80u) == 0) {
                          std::string::size_type v54 = v96;
                        }
                        else {
                          std::string::size_type v54 = v95;
                        }
                        long long v55 = std::string::append(&v109, v53, v54);
                        long long v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
                        buf.__r_.__value_.__r.__words[2] = v55->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v56;
                        v55->__r_.__value_.__l.__size_ = 0;
                        v55->__r_.__value_.__r.__words[2] = 0;
                        v55->__r_.__value_.__r.__words[0] = 0;
                        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          xpc_object_t v57 = &buf;
                        }
                        else {
                          xpc_object_t v57 = (std::string *)buf.__r_.__value_.__r.__words[0];
                        }
                        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          std::string::size_type v58 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                        }
                        else {
                          std::string::size_type v58 = buf.__r_.__value_.__l.__size_;
                        }
                        std::string::append(&v99, (const std::string::value_type *)v57, v58);
                        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(buf.__r_.__value_.__l.__data_);
                        }
                        if ((char)v96 < 0) {
                          operator delete(__p);
                        }
                        if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v109.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v97.__r_.__value_.__l.__data_);
                        }
                      }
                      else
                      {
                        int v93 = 0;
                      }
                      uint64_t v59 = CFDictionaryGetValue(v33, @"ICCID");
                      uint64_t v60 = v59;
                      if (v59 && (CFTypeID v61 = CFGetTypeID(v59), v61 == CFStringGetTypeID()))
                      {
                        uint64_t v92 = v60;
                        sub_1000292E0((uint64_t)&v97);
                        group_session v62 = std::string::insert(&v97, 0, "_", 1uLL);
                        long long v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
                        v109.__r_.__value_.__r.__words[2] = v62->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&v109.__r_.__value_.__l.__data_ = v63;
                        v62->__r_.__value_.__l.__size_ = 0;
                        v62->__r_.__value_.__r.__words[2] = 0;
                        v62->__r_.__value_.__r.__words[0] = 0;
                        sub_1000292E0((uint64_t)&__p);
                        if ((v96 & 0x80u) == 0) {
                          int v64 = (const std::string::value_type *)&__p;
                        }
                        else {
                          int v64 = (const std::string::value_type *)__p;
                        }
                        if ((v96 & 0x80u) == 0) {
                          std::string::size_type v65 = v96;
                        }
                        else {
                          std::string::size_type v65 = v95;
                        }
                        unint64_t v66 = std::string::append(&v109, v64, v65);
                        long long v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
                        buf.__r_.__value_.__r.__words[2] = v66->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v67;
                        v66->__r_.__value_.__l.__size_ = 0;
                        v66->__r_.__value_.__r.__words[2] = 0;
                        v66->__r_.__value_.__r.__words[0] = 0;
                        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          long long v68 = &buf;
                        }
                        else {
                          long long v68 = (std::string *)buf.__r_.__value_.__r.__words[0];
                        }
                        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          std::string::size_type v69 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                        }
                        else {
                          std::string::size_type v69 = buf.__r_.__value_.__l.__size_;
                        }
                        std::string::append(&v99, (const std::string::value_type *)v68, v69);
                        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(buf.__r_.__value_.__l.__data_);
                        }
                        if ((char)v96 < 0) {
                          operator delete(__p);
                        }
                        if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v109.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v97.__r_.__value_.__l.__data_);
                        }
                      }
                      else
                      {
                        uint64_t v92 = 0;
                      }
                      uint64_t v70 = Mutable;
                      if (SHIBYTE(v99.__r_.__value_.__r.__words[2]) < 0) {
                        sub_10004FC84(&__dst, v99.__r_.__value_.__l.__data_, v99.__r_.__value_.__l.__size_);
                      }
                      else {
                        std::string __dst = v99;
                      }
                      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                        sub_10004FC84(&v109, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
                      }
                      else {
                        std::string v109 = __dst;
                      }
                      uint64_t v108 = 0;
                      if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
                        sub_10004FC84(&buf, v109.__r_.__value_.__l.__data_, v109.__r_.__value_.__l.__size_);
                      }
                      else {
                        std::string buf = v109;
                      }
                      __n128 __p = 0;
                      if (ctu::cf::convert_copy())
                      {
                        std::string::size_type v71 = (std::string::size_type)v108;
                        uint64_t v108 = __p;
                        v97.__r_.__value_.__r.__words[0] = v71;
                        sub_1000558F4((const void **)&v97.__r_.__value_.__l.__data_);
                      }
                      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(buf.__r_.__value_.__l.__data_);
                      }
                      long long v91 = v108;
                      uint64_t v108 = 0;
                      sub_1000558F4((const void **)&v108);
                      if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v109.__r_.__value_.__l.__data_);
                      }
                      CFDictionarySetValue(v70, v91, v35);
                      sub_1000558F4((const void **)&v91);
                      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(__dst.__r_.__value_.__l.__data_);
                      }
                      if (SHIBYTE(v99.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v99.__r_.__value_.__l.__data_);
                      }
                    }
                  }
                }
              }
            }
          }
          ++v17;
        }
        while (v17 != v83);
      }
      copyMergedDictionaries(v89, Mutable, &v109);
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v89;
      long long v89 = (__CFDictionary *)v109.__r_.__value_.__r.__words[0];
      v109.__r_.__value_.__r.__words[0] = 0;
      sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
      sub_100057D78((const void **)&v109.__r_.__value_.__l.__data_);
      id v9 = (__CFDictionary **)(a1 + 4);
      if (v101)
      {
        uint64_t v102 = v101;
        operator delete(v101);
      }
      if (v104)
      {
        int v105 = v104;
        operator delete(v104);
      }
      sub_10005717C((const void **)&Mutable);
    }
  }
  if (v9 != &v89)
  {
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)*v9;
    *id v9 = v89;
    long long v89 = 0;
    sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
  }
  sub_100057D78((const void **)&v89);
  sub_100057D78((const void **)&theDict);
  sub_100058198((const void **)&v87, a4);
  v109.__r_.__value_.__r.__words[0] = 0;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  sub_1003AA8C0(&v109, (CFTypeRef *)&buf.__r_.__value_.__l.__data_);
  CFDictionaryRef v72 = (const __CFDictionary *)CFDictionaryGetValue(v87, @"MobileDeviceCarrierBundlesByProductVersion");
  CFDictionaryRef v73 = v72;
  if (!v72 || (CFTypeID v74 = CFGetTypeID(v72), v74 != CFDictionaryGetTypeID()))
  {
    int v75 = *(NSObject **)a1[9];
    if (!os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_134;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    uint64_t v76 = "#I MobileDeviceCarrierBundlesByProductVersion is not found in version.xml";
    goto LABEL_133;
  }
  if (CFDictionaryGetCount(v73))
  {
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v73;
    sub_100282490((const void **)&v109.__r_.__value_.__l.__data_, (CFTypeRef *)&buf.__r_.__value_.__l.__data_);
    goto LABEL_134;
  }
  int v75 = *(NSObject **)a1[9];
  if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    uint64_t v76 = "#I MobileDeviceCarrierBundlesByProductVersion has 0 elements";
LABEL_133:
    _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, v76, (uint8_t *)&buf, 2u);
  }
LABEL_134:
  if (v81 != &v109)
  {
    buf.__r_.__value_.__r.__words[0] = v81->__r_.__value_.__r.__words[0];
    v81->__r_.__value_.__r.__words[0] = v109.__r_.__value_.__r.__words[0];
    v109.__r_.__value_.__r.__words[0] = 0;
    sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
  }
  sub_100057D78((const void **)&v109.__r_.__value_.__l.__data_);
  sub_100057D78((const void **)&v87);
  int v77 = (os_log_t *)a1[9];
  unint64_t v78 = (std::__shared_weak_count *)a1[1];
  uint64_t v85 = *a1;
  long long v86 = v78;
  if (v78) {
    atomic_fetch_add_explicit(&v78->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058198(&v84, a4);
  sub_1006CF1AC(v77, (uint64_t)&v85, (uint64_t *)&v84, (const void **)&v109.__r_.__value_.__l.__data_);
  if (v80 != &v109)
  {
    buf.__r_.__value_.__r.__words[0] = v80->__r_.__value_.__r.__words[0];
    v80->__r_.__value_.__r.__words[0] = v109.__r_.__value_.__r.__words[0];
    v109.__r_.__value_.__r.__words[0] = 0;
    sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
  }
  sub_100057D78((const void **)&v109.__r_.__value_.__l.__data_);
  sub_100057D78(&v84);
  if (v86) {
    sub_10004D2C8(v86);
  }
  return a1;
}

void sub_100496E50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void **a14, const void **a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,const void *a24,__int16 a25,char a26,char a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  sub_100057D78((const void **)(v56 - 144));
  sub_100057D78(&a24);
  sub_100057D78(a14);
  sub_10005CD2C(a13, *(char **)(v53 + 56));
  sub_100057D78(a15);
  sub_100057D78(v55);
  sub_1000558F4(v54);
  std::string::size_type v58 = *(std::__shared_weak_count **)(v53 + 8);
  if (v58) {
    sub_10004D2C8(v58);
  }
  _Unwind_Resume(a1);
}

const void **sub_10049707C@<X0>(uint64_t a1@<X0>, CFDictionaryRef *a2@<X1>, uint64_t a3@<X8>)
{
  CFTypeRef cf = 0;
  std::string v114 = 0;
  *(void *)std::string buf = CFDictionaryGetValue(*a2, @"kBundleNameToCheckForUpdate");
  sub_100056248(&cf, (CFTypeRef *)buf);
  CFDictionaryRef Value = (int *)CFDictionaryGetValue(*a2, @"kUpdateBundleType");
  uint64_t v7 = Value;
  *(_DWORD *)std::string buf = 0;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, v7, v9);
    }
  }
  uint64_t v10 = buf[0];
  CFDictionaryRef v11 = **(NSObject ***)(a1 + 72);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = asString();
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Checking update for %s", buf, 0xCu);
  }
  if (v10 == 3)
  {
    sub_100058198(&v112, (const void **)a2);
    sub_1004D3980((CFDictionaryRef *)&v112, (const __CFDictionary **)&v120);
    if (&v120 != (long long *)a2)
    {
      *(void *)std::string buf = *a2;
      *a2 = (CFDictionaryRef)v120;
      *(void *)&long long v120 = 0;
      sub_100057D78((const void **)buf);
    }
    sub_100057D78((const void **)&v120);
    sub_100057D78(&v112);
  }
  if (cf) {
    CFDictionaryRef v13 = sub_1000810B8;
  }
  else {
    CFDictionaryRef v13 = 0;
  }
  if (v13)
  {
    *(void *)&long long v120 = cf;
    if (cf)
    {
      CFRetain(cf);
      CFDictionaryRef v14 = (const void *)v120;
    }
    else
    {
      CFDictionaryRef v14 = 0;
    }
    *(void *)std::string buf = v114;
    std::string v114 = v14;
    *(void *)&long long v120 = 0;
    sub_1000577C4((const void **)buf);
    sub_1000577C4((const void **)&v120);
  }
  else
  {
    CFTypeID v15 = *(const void ***)(a1 + 72);
    sub_100058198(&v111, (const void **)(a1 + 32));
    sub_1006CE9F8(v15, (Registry **)a1, (const __CFDictionary **)&v111, *a2, &v120);
    *(void *)std::string buf = cf;
    CFTypeRef cf = (CFTypeRef)v120;
    *(void *)&long long v120 = 0;
    sub_1000558F4((const void **)buf);
    sub_1000558F4((const void **)&v120);
    sub_100057D78(&v111);
    *(void *)&long long v120 = *a2;
    if ((void)v120)
    {
      CFRetain((CFTypeRef)v120);
      int v16 = (const void *)v120;
    }
    else
    {
      int v16 = 0;
    }
    *(void *)std::string buf = v114;
    std::string v114 = v16;
    *(void *)&long long v120 = 0;
    sub_1000577C4((const void **)buf);
    sub_1000577C4((const void **)&v120);
    uint64_t v17 = **(NSObject ***)(a1 + 72);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v128 = 0;
      ctu::cf::assign();
      long long v120 = *(_OWORD *)buf;
      uint64_t v121 = v128;
      unsigned int v18 = *(long long **)buf;
      if (v128 >= 0) {
        unsigned int v18 = &v120;
      }
      LODWORD(v125) = 136446210;
      *(void *)((char *)&v125 + 4) = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#N Bundle name is not provided, the best match found from the version.xml is %{public}s", (uint8_t *)&v125, 0xCu);
      if (SHIBYTE(v121) < 0) {
        operator delete((void *)v120);
      }
    }
  }
  if (cf) {
    CFTypeID v19 = sub_1000810B8;
  }
  else {
    CFTypeID v19 = 0;
  }
  if (v19)
  {
    v109[0] = 0;
    v109[1] = 0;
    uint64_t v110 = 0;
    *(void *)std::string buf = cf;
    sub_1000292E0((uint64_t)v109);
    sub_100046BAC((uint64_t **)(a1 + 48), v109, (uint64_t)v109);
    if (!v20)
    {
      CFArrayRef v25 = **(NSObject ***)(a1 + 72);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, sizeof(buf));
        uint64_t v128 = 0;
        ctu::cf::assign();
        long long v120 = *(_OWORD *)buf;
        uint64_t v121 = v128;
        CFArrayRef v26 = &v120;
        if (v128 < 0) {
          CFArrayRef v26 = (long long *)v120;
        }
        LODWORD(v125) = 136446210;
        *(void *)((char *)&v125 + 4) = v26;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#N %{public}s is already covered", (uint8_t *)&v125, 0xCu);
        if (SHIBYTE(v121) < 0) {
          operator delete((void *)v120);
        }
      }
      *(unsigned char *)a3 = 3;
      *(void *)(a3 + 8) = 0;
      *(void *)std::string buf = 0;
      sub_100057D78((const void **)buf);
      goto LABEL_195;
    }
    CFTypeRef v108 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFTypeRef v22 = v108;
      CFTypeRef v108 = Mutable;
      *(void *)std::string buf = v22;
      sub_10005717C((const void **)buf);
    }
    sub_10010F3F0((__CFDictionary *)v108, @"BundleID", (uint64_t)cf);
    CFTypeRef v106 = cf;
    CFTypeRef v107 = 0;
    if (cf)
    {
      CFRetain(cf);
      uint64_t v23 = v106;
    }
    else
    {
      uint64_t v23 = 0;
    }
    CFTypeID v27 = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v23);
    CFIndex v28 = v27;
    if (v27 && (CFTypeID v29 = CFGetTypeID(v27), v29 == CFDictionaryGetTypeID()))
    {
      CFMutableDictionaryRef MutableCopy = v28;
      CFRetain(v28);
    }
    else
    {
      CFIndex v28 = 0;
      CFMutableDictionaryRef MutableCopy = 0;
    }
    if (v28) {
      uint64_t v30 = sub_100080778;
    }
    else {
      uint64_t v30 = 0;
    }
    if (v30)
    {
      if (CFDictionaryGetCount(v28))
      {
        CFTypeRef v107 = MutableCopy;
        CFMutableDictionaryRef MutableCopy = 0;
        goto LABEL_66;
      }
      CFDictionaryRef v31 = **(NSObject ***)(a1 + 72);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, sizeof(buf));
        uint64_t v128 = 0;
        ctu::cf::assign();
        long long v120 = *(_OWORD *)buf;
        uint64_t v121 = v128;
        long long v34 = &v120;
        if (v128 < 0) {
          long long v34 = (long long *)v120;
        }
        LODWORD(v125) = 136446210;
        *(void *)((char *)&v125 + 4) = v34;
        CFDictionaryRef v33 = "#N No product versions listed for %{public}s";
LABEL_63:
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, v33, (uint8_t *)&v125, 0xCu);
        if (SHIBYTE(v121) < 0) {
          operator delete((void *)v120);
        }
      }
    }
    else
    {
      CFDictionaryRef v31 = **(NSObject ***)(a1 + 72);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, sizeof(buf));
        uint64_t v128 = 0;
        ctu::cf::assign();
        long long v120 = *(_OWORD *)buf;
        uint64_t v121 = v128;
        CFTypeID v32 = &v120;
        if (v128 < 0) {
          CFTypeID v32 = (long long *)v120;
        }
        LODWORD(v125) = 136446210;
        *(void *)((char *)&v125 + 4) = v32;
        CFDictionaryRef v33 = "#N No entry for bundle %{public}s in the MobileDeviceCarrierBundlesByProductVersion";
        goto LABEL_63;
      }
    }
    CFTypeRef v107 = 0;
LABEL_66:
    sub_100057D78((const void **)&MutableCopy);
    sub_1000558F4(&v106);
    CFDictionaryRef v35 = (const __CFDictionary *)v107;
    if (v107) {
      CFTypeID v36 = sub_100080778;
    }
    else {
      CFTypeID v36 = 0;
    }
    if (!v36)
    {
      buf[0] = 3;
      *(void *)&uint8_t buf[8] = v108;
      if (v108) {
        CFRetain(v108);
      }
      *(unsigned char *)a3 = 3;
      sub_10004EFE4((void *)(a3 + 8), (CFTypeRef *)&buf[8]);
      sub_10005717C((const void **)&buf[8]);
      goto LABEL_194;
    }
    CFDictionaryRef theDict = (CFDictionaryRef)v107;
    CFTypeRef v105 = 0;
    if (v107)
    {
      CFRetain(v107);
      CFDictionaryRef v35 = theDict;
    }
    CFDictionaryRef v37 = (const __CFDictionary *)CFDictionaryGetValue(v35, @"ByProductType");
    CFDictionaryRef v38 = v37;
    if (v37 && (CFTypeID v39 = CFGetTypeID(v37), v39 == CFDictionaryGetTypeID()))
    {
      CFDictionaryRef v40 = (const __CFDictionary *)CFDictionaryGetValue(v38, *(const void **)(a1 + 24));
      CFDictionaryRef v41 = v40;
      if (v40)
      {
        CFTypeID v42 = CFGetTypeID(v40);
        if (v42 == CFDictionaryGetTypeID()) {
          goto LABEL_86;
        }
      }
      std::string::size_type v43 = **(NSObject ***)(a1 + 72);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, sizeof(buf));
        uint64_t v128 = 0;
        ctu::cf::assign();
        long long v120 = *(_OWORD *)buf;
        uint64_t v121 = v128;
        long long v44 = &v120;
        if (v128 < 0) {
          long long v44 = (long long *)v120;
        }
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = v44;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#N No entry for the device %{public}s in ByProductType", buf, 0xCu);
        if (SHIBYTE(v121) < 0) {
          operator delete((void *)v120);
        }
      }
      long long v45 = *(unsigned char *)(a1 + 16) ? @"iPhone" : @"iPad";
      CFDictionaryRef v46 = (const __CFDictionary *)CFDictionaryGetValue(v38, v45);
      CFDictionaryRef v41 = v46;
      if (v46)
      {
        CFTypeID v47 = CFGetTypeID(v46);
        if (v47 == CFDictionaryGetTypeID())
        {
LABEL_86:
          uint64_t v48 = (BOOL *)CFDictionaryGetValue(v41, @"FallbackToByProductVersion");
          int v49 = v48;
          buf[0] = 0;
          if (v48
            && (CFTypeID v50 = CFGetTypeID(v48), v50 == CFBooleanGetTypeID())
            && (ctu::cf::assign((ctu::cf *)buf, v49, v51), buf[0]))
          {
            long long v52 = **(NSObject ***)(a1 + 72);
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I Falling back to product version based search", buf, 2u);
            }
            CFDictionaryRef v41 = theDict;
            CFTypeRef v105 = theDict;
            if (!theDict)
            {
LABEL_96:
              sub_100057D78((const void **)&theDict);
              if (v105) {
                std::string::size_type v54 = sub_100080778;
              }
              else {
                std::string::size_type v54 = 0;
              }
              if (!v54)
              {
                buf[0] = 3;
                *(void *)&uint8_t buf[8] = v108;
                if (v108) {
                  CFRetain(v108);
                }
                *(unsigned char *)a3 = 3;
                sub_10004EFE4((void *)(a3 + 8), (CFTypeRef *)&buf[8]);
                sub_10005717C((const void **)&buf[8]);
                goto LABEL_193;
              }
              CFDictionaryRef v102 = (CFDictionaryRef)v105;
              CFDictionaryRef v103 = 0;
              if (v105) {
                CFRetain(v105);
              }
              CFTypeRef v101 = cf;
              if (cf) {
                CFRetain(cf);
              }
              sub_100058198(&v100, (const void **)a2);
              CFStringRef v122 = 0;
              ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
              uint64_t v56 = ServiceMap;
              if (v57 < 0)
              {
                std::string::size_type v58 = (unsigned __int8 *)(v57 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v59 = 5381;
                do
                {
                  uint64_t v57 = v59;
                  unsigned int v60 = *v58++;
                  uint64_t v59 = (33 * v59) ^ v60;
                }
                while (v60);
              }
              std::mutex::lock(ServiceMap);
              *(void *)std::string buf = v57;
              CFTypeID v61 = sub_10004D37C(&v56[1].__m_.__sig, (unint64_t *)buf);
              if (v61)
              {
                uint64_t v63 = v61[3];
                group_session v62 = (std::__shared_weak_count *)v61[4];
                if (v62)
                {
                  atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v56);
                  atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v62);
                  char v64 = 0;
LABEL_118:
                  (*(void (**)(const __CFString **__return_ptr, uint64_t))(*(void *)v63 + 112))(&v122, v63);
                  if ((v64 & 1) == 0) {
                    sub_10004D2C8(v62);
                  }
                  CFIndex Count = CFDictionaryGetCount(v102);
                  long long v120 = 0uLL;
                  uint64_t v121 = 0;
                  sub_10004EE3C(&v120, Count);
                  long long v125 = 0uLL;
                  uint64_t v126 = 0;
                  sub_10004EE3C(&v125, Count);
                  CFMutableDictionaryRef MutableCopy = 0;
                  v118 = 0;
                  unint64_t v119 = 0;
                  CFDictionaryGetKeysAndValues(v102, (const void **)v120, (const void **)v125);
                  if (Count >= 1)
                  {
                    for (uint64_t i = 0; i != Count; ++i)
                    {
                      CFStringRef v67 = *(const __CFString **)(v120 + 8 * i);
                      if (v67)
                      {
                        CFTypeID v68 = CFGetTypeID(*(CFTypeRef *)(v120 + 8 * i));
                        if (v68 != CFStringGetTypeID()) {
                          CFStringRef v67 = 0;
                        }
                      }
                      if (!CFEqual(v67, @"ByProductType")
                        && _CompareBundleVersionStrings(v67, @"7.0") != -1
                        && _CompareBundleVersionStrings(v67, v122) != 1)
                      {
                        std::string::size_type v69 = v118;
                        if ((unint64_t)v118 >= v119)
                        {
                          int64_t v71 = (v118 - (char *)MutableCopy) >> 3;
                          if ((unint64_t)(v71 + 1) >> 61) {
                            sub_10006A748();
                          }
                          unint64_t v72 = (uint64_t)(v119 - (void)MutableCopy) >> 2;
                          if (v72 <= v71 + 1) {
                            unint64_t v72 = v71 + 1;
                          }
                          if (v119 - (unint64_t)MutableCopy >= 0x7FFFFFFFFFFFFFF8) {
                            unint64_t v73 = 0x1FFFFFFFFFFFFFFFLL;
                          }
                          else {
                            unint64_t v73 = v72;
                          }
                          if (v73) {
                            CFTypeID v74 = (char *)sub_10004EF74((uint64_t)&v119, v73);
                          }
                          else {
                            CFTypeID v74 = 0;
                          }
                          int v75 = (__CFDictionary *)&v74[8 * v71];
                          *(void *)int v75 = v67;
                          uint64_t v70 = (char *)v75 + 8;
                          CFMutableDictionaryRef v77 = MutableCopy;
                          CFMutableDictionaryRef v76 = (CFMutableDictionaryRef)v118;
                          if (v118 != (char *)MutableCopy)
                          {
                            do
                            {
                              uint64_t v78 = *((void *)v76 - 1);
                              CFMutableDictionaryRef v76 = (CFMutableDictionaryRef)((char *)v76 - 8);
                              *((void *)v75 - 1) = v78;
                              int v75 = (__CFDictionary *)((char *)v75 - 8);
                            }
                            while (v76 != v77);
                            CFMutableDictionaryRef v76 = MutableCopy;
                          }
                          CFMutableDictionaryRef MutableCopy = v75;
                          v118 = v70;
                          unint64_t v119 = (unint64_t)&v74[8 * v73];
                          if (v76) {
                            operator delete(v76);
                          }
                        }
                        else
                        {
                          *(void *)v118 = v67;
                          uint64_t v70 = v69 + 8;
                        }
                        v118 = v70;
                      }
                    }
                  }
                  if (MutableCopy == (CFMutableDictionaryRef)v118) {
                    goto LABEL_156;
                  }
                  *(void *)std::string buf = sub_1006CEC10;
                  sub_10049981C((uint64_t)MutableCopy, v118, (uint64_t (**)(uint64_t, uint64_t))buf, 126 - 2 * __clz((v118 - (char *)MutableCopy) >> 3), 1);
                  int v79 = **(NSObject ***)(a1 + 72);
                  if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
                  {
                    memset(buf, 0, sizeof(buf));
                    uint64_t v128 = 0;
                    ctu::cf::assign();
                    *(_OWORD *)__n128 __p = *(_OWORD *)buf;
                    uint64_t v116 = v128;
                    uint64_t v80 = __p;
                    if (v128 < 0) {
                      uint64_t v80 = (void **)__p[0];
                    }
                    *(_DWORD *)int v123 = 136446210;
                    uint64_t v124 = v80;
                    _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#I latest version available: %{public}s", v123, 0xCu);
                    if (SHIBYTE(v116) < 0) {
                      operator delete(__p[0]);
                    }
                  }
                  CFDictionaryRef v81 = (const __CFDictionary *)CFDictionaryGetValue(v102, *((const void **)v118 - 1));
                  CFDictionaryRef v82 = v81;
                  if (v81 && (CFTypeID v83 = CFGetTypeID(v81), v83 == CFDictionaryGetTypeID()))
                  {
                    CFDictionaryRef v103 = v82;
                    CFRetain(v82);
                  }
                  else
                  {
LABEL_156:
                    long long v84 = **(NSObject ***)(a1 + 72);
                    if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)std::string buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "#I Cannot find version specific dict", buf, 2u);
                    }
                    CFDictionaryRef v103 = 0;
                  }
                  if (MutableCopy)
                  {
                    v118 = (char *)MutableCopy;
                    operator delete(MutableCopy);
                  }
                  if ((void)v125)
                  {
                    *((void *)&v125 + 1) = v125;
                    operator delete((void *)v125);
                  }
                  if ((void)v120)
                  {
                    *((void *)&v120 + 1) = v120;
                    operator delete((void *)v120);
                  }
                  sub_1000558F4((const void **)&v122);
                  sub_100057D78(&v100);
                  sub_1000558F4(&v101);
                  sub_100057D78((const void **)&v102);
                  if (v103) {
                    uint64_t v85 = sub_100080778;
                  }
                  else {
                    uint64_t v85 = 0;
                  }
                  if (v85)
                  {
                    *(void *)&long long v125 = 0;
                    *(void *)std::string buf = CFDictionaryGetValue(v103, @"BuildVersion");
                    sub_100056248(&v125, (CFTypeRef *)buf);
                    CFDictionaryRef v99 = v103;
                    if (v103) {
                      CFRetain(v103);
                    }
                    sub_100058198(&v98, (const void **)a2);
                    CFTypeRef v97 = cf;
                    if (cf) {
                      CFRetain(cf);
                    }
                    unsigned __int8 v96 = (const void *)v125;
                    if ((void)v125) {
                      CFRetain((CFTypeRef)v125);
                    }
                    char v86 = sub_100498480(a1, v99, (CFDictionaryRef *)&v98, &v97, (const __CFString **)&v96);
                    sub_1000558F4(&v96);
                    sub_1000558F4(&v97);
                    sub_100057D78(&v98);
                    sub_100057D78((const void **)&v99);
                    if (v86)
                    {
                      CFMutableDictionaryRef MutableCopy = 0;
                      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v103);
                      CFDictionarySetValue(MutableCopy, @"BundleID", cf);
                      CFDictionaryRef v87 = MutableCopy;
                      *(void *)&long long v120 = 0;
                      *(void *)std::string buf = v10;
                      CFNumberRef v88 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
                      if (v88)
                      {
                        uint64_t v89 = v120;
                        *(void *)&long long v120 = v88;
                        *(void *)std::string buf = v89;
                        sub_1000570E8((const void **)buf);
                      }
                      __p[0] = (void *)v120;
                      *(void *)&long long v120 = 0;
                      sub_1000570E8((const void **)&v120);
                      CFDictionarySetValue(v87, @"kUpdateBundleType", __p[0]);
                      sub_1000570E8((const void **)__p);
                      CFDictionarySetValue(MutableCopy, @"UseOldUpdateFormat", kCFBooleanTrue);
                      buf[0] = 4;
                      *(void *)&uint8_t buf[8] = MutableCopy;
                      if (MutableCopy) {
                        CFRetain(MutableCopy);
                      }
                      *(unsigned char *)a3 = 4;
                      sub_10004EFE4((void *)(a3 + 8), (CFTypeRef *)&buf[8]);
                      sub_10005717C((const void **)&buf[8]);
                      p_CFMutableDictionaryRef MutableCopy = (const void **)&MutableCopy;
                    }
                    else
                    {
                      uint64_t v92 = **(NSObject ***)(a1 + 72);
                      if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)std::string buf = 0;
                        _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "#I Not a new bundle, nothing to download", buf, 2u);
                      }
                      buf[0] = 3;
                      *(void *)&uint8_t buf[8] = v108;
                      if (v108) {
                        CFRetain(v108);
                      }
                      *(unsigned char *)a3 = 3;
                      sub_10004EFE4((void *)(a3 + 8), (CFTypeRef *)&buf[8]);
                      p_CFMutableDictionaryRef MutableCopy = (const void **)&buf[8];
                    }
                    sub_10005717C(p_MutableCopy);
                    sub_1000558F4((const void **)&v125);
                  }
                  else
                  {
                    long long v91 = **(NSObject ***)(a1 + 72);
                    if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)std::string buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, "#I Cannot find version specific dict", buf, 2u);
                    }
                    buf[0] = 3;
                    *(void *)&uint8_t buf[8] = v108;
                    if (v108) {
                      CFRetain(v108);
                    }
                    *(unsigned char *)a3 = 3;
                    sub_10004EFE4((void *)(a3 + 8), (CFTypeRef *)&buf[8]);
                    sub_10005717C((const void **)&buf[8]);
                  }
                  sub_100057D78((const void **)&v103);
LABEL_193:
                  sub_100057D78(&v105);
LABEL_194:
                  sub_100057D78(&v107);
                  sub_10005717C(&v108);
LABEL_195:
                  if (SHIBYTE(v110) < 0) {
                    operator delete(v109[0]);
                  }
                  goto LABEL_197;
                }
              }
              else
              {
                uint64_t v63 = 0;
              }
              std::mutex::unlock(v56);
              group_session v62 = 0;
              char v64 = 1;
              goto LABEL_118;
            }
          }
          else
          {
            CFTypeRef v105 = v41;
          }
          CFRetain(v41);
          goto LABEL_96;
        }
      }
      CFRange v94 = **(NSObject ***)(a1 + 72);
      if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, sizeof(buf));
        uint64_t v128 = 0;
        ctu::cf::assign();
        long long v120 = *(_OWORD *)buf;
        uint64_t v121 = v128;
        std::string::size_type v95 = &v120;
        if (v128 < 0) {
          std::string::size_type v95 = (long long *)v120;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v95;
        _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#N No entry for the device %s in ByProductType", buf, 0xCu);
        if (SHIBYTE(v121) < 0) {
          operator delete((void *)v120);
        }
      }
    }
    else
    {
      uint64_t v53 = **(NSObject ***)(a1 + 72);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#N No ByProductType key in the dictionary", buf, 2u);
      }
    }
    CFTypeRef v105 = 0;
    goto LABEL_96;
  }
  CFTypeID v24 = **(NSObject ***)(a1 + 72);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#N Did not get the bundle to look for the update", buf, 2u);
  }
  *(unsigned char *)a3 = 3;
  *(void *)(a3 + 8) = 0;
  *(void *)std::string buf = 0;
  sub_100057D78((const void **)buf);
LABEL_197:
  sub_1000558F4(&cf);
  return sub_1000577C4(&v114);
}

void sub_1004981B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,const void *a21,uint64_t a22,uint64_t a23,const void *a24,const void *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,const void *a34,const void *a35)
{
  if (*(char *)(v35 - 105) < 0) {
    operator delete(*(void **)(v35 - 128));
  }
  sub_100057D78(&a21);
  sub_100057D78(&a24);
  sub_10005717C(&a25);
  if (a31 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a34);
  sub_1000577C4(&a35);
  _Unwind_Resume(a1);
}

uint64_t sub_100498480(uint64_t a1, CFDictionaryRef theDict, CFDictionaryRef *a3, CFTypeRef *a4, const __CFString **a5)
{
  CFDictionaryRef Value = CFDictionaryGetValue(theDict, @"BundleURL");
  if (Value && (uint64_t v10 = Value, v11 = CFGetTypeID(Value), v11 == CFStringGetTypeID()))
  {
    CFDictionaryRef v40 = v10;
    CFRetain(v10);
    uint64_t v12 = v10;
  }
  else
  {
    uint64_t v12 = 0;
    CFDictionaryRef v40 = 0;
  }
  if (v12) {
    CFDictionaryRef v13 = sub_1000810B8;
  }
  else {
    CFDictionaryRef v13 = 0;
  }
  if (!v13)
  {
    CFIndex v28 = **(NSObject ***)(a1 + 72);
    uint64_t v27 = 0;
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_36;
    }
    *(_WORD *)std::string buf = 0;
    CFTypeID v29 = "#I No bundle URL key found in the version specific dict";
LABEL_35:
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v29, buf, 2u);
    uint64_t v27 = 0;
    goto LABEL_36;
  }
  CFDictionaryRef v14 = CFDictionaryGetValue(*a3, @"BundleIDOnTheDevice");
  CFTypeID v15 = v14;
  if (v14)
  {
    CFTypeID v16 = CFGetTypeID(v14);
    if (v16 != CFStringGetTypeID()) {
      CFTypeID v15 = 0;
    }
  }
  CFStringRef v17 = (const __CFString *)CFDictionaryGetValue(*a3, @"BundleVersionOnTheDevice");
  CFStringRef v18 = v17;
  if (v17)
  {
    CFTypeID v19 = CFGetTypeID(v17);
    if (v19 != CFStringGetTypeID()) {
      CFStringRef v18 = 0;
    }
  }
  char v20 = *(os_log_t **)(a1 + 72);
  CFTypeID v21 = *v20;
  if (os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT))
  {
    ctu::cf::assign();
    *(_OWORD *)CFDictionaryRef v38 = 0u;
    uint64_t v39 = 0;
    ctu::cf::assign();
    *(_OWORD *)CFTypeID v36 = 0uLL;
    uint64_t v37 = 0;
    CFDictionaryRef v31 = a4;
    long long v41 = 0uLL;
    uint64_t v42 = 0;
    ctu::cf::assign();
    uint64_t v35 = v42;
    *(_OWORD *)long long v34 = v41;
    CFTypeRef v22 = a5;
    int v23 = SHIBYTE(v42);
    CFTypeID v24 = (void **)v41;
    long long v41 = 0uLL;
    uint64_t v42 = 0;
    ctu::cf::assign();
    CFArrayRef v25 = v34;
    if (v23 < 0) {
      CFArrayRef v25 = v24;
    }
    *(_OWORD *)__n128 __p = v41;
    uint64_t v33 = v42;
    CFArrayRef v26 = __p;
    if (v42 < 0) {
      CFArrayRef v26 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136446978;
    long long v44 = v38;
    __int16 v45 = 2082;
    CFDictionaryRef v46 = v36;
    __int16 v47 = 2082;
    uint64_t v48 = v25;
    __int16 v49 = 2082;
    CFTypeID v50 = v26;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Current bundle ID %{public}s and version %{public}s, Available bundle ID: %{public}s and version %{public}s", buf, 0x2Au);
    if (SHIBYTE(v33) < 0) {
      operator delete(__p[0]);
    }
    a5 = v22;
    if (SHIBYTE(v35) < 0) {
      operator delete(v34[0]);
    }
    a4 = v31;
    if (SHIBYTE(v37) < 0) {
      operator delete(v36[0]);
    }
    if (SHIBYTE(v39) < 0) {
      operator delete(v38[0]);
    }
    char v20 = *(os_log_t **)(a1 + 72);
  }
  if ((sub_1006CEC58(v20, v15, v18, *a4, *a5) & 1) == 0)
  {
    CFIndex v28 = **(NSObject ***)(a1 + 72);
    uint64_t v27 = 0;
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_36;
    }
    *(_WORD *)std::string buf = 0;
    CFTypeID v29 = "#I Not a new bundle, nothing to download";
    goto LABEL_35;
  }
  uint64_t v27 = 1;
LABEL_36:
  sub_1000558F4(&v40);
  return v27;
}

void sub_100498814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,const void *a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  if (v39 < 0) {
    operator delete(v40);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  sub_1000558F4(&a33);
  _Unwind_Resume(a1);
}

const void **sub_1004988C4@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  int v113 = 0;
  memset(&buf, 0, sizeof(buf));
  ctu::cf::assign();
  long long v111 = 0u;
  uint64_t v112 = 0;
  sub_100046BAC((uint64_t **)(a1 + 48), (void **)&v111, (uint64_t)&v111);
  if (!v6)
  {
    CFStringRef v18 = **(NSObject ***)(a1 + 72);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeID v19 = &v111;
      if (v112 < 0) {
        CFTypeID v19 = (long long *)v111;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v19;
      char v20 = "#N %{public}s is already covered";
      CFTypeID v21 = v18;
      uint32_t v22 = 12;
      goto LABEL_18;
    }
LABEL_19:
    *(unsigned char *)a3 = 3;
    sub_100058198((const void **)(a3 + 8), &v113);
    goto LABEL_168;
  }
  if (*(void *)(a1 + 80)) {
    uint64_t v7 = sub_100080778;
  }
  else {
    uint64_t v7 = 0;
  }
  if (!v7)
  {
    int v23 = **(NSObject ***)(a1 + 72);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      char v20 = "#N No GSMA updates available.";
      CFTypeID v21 = v23;
      uint32_t v22 = 2;
LABEL_18:
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&buf, v22);
      goto LABEL_19;
    }
    goto LABEL_19;
  }
  uint64_t v110 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
  CFNumberRef v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    CFTypeID v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      std::string::size_type v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  buf.__r_.__value_.__r.__words[0] = v10;
  CFDictionaryRef v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&buf);
  if (!v14)
  {
    uint64_t v16 = 0;
    goto LABEL_21;
  }
  uint64_t v16 = v14[3];
  CFTypeID v15 = (std::__shared_weak_count *)v14[4];
  if (!v15)
  {
LABEL_21:
    std::mutex::unlock(v9);
    CFTypeID v15 = 0;
    char v17 = 1;
    goto LABEL_22;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
LABEL_22:
  (*(void (**)(__CFString **__return_ptr, uint64_t))(*(void *)v16 + 112))(&v110, v16);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  if (v110) {
    CFTypeID v24 = sub_1000810B8;
  }
  else {
    CFTypeID v24 = 0;
  }
  if (!v24)
  {
    char v108 = 3;
    std::string v109 = v113;
    if (v113) {
      CFRetain(v113);
    }
    sub_100057D78(&v109);
  }
  memset(&buf, 0, sizeof(buf));
  ctu::cf::assign();
  std::string __str = buf;
  std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  p_str = &__str;
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if (!size) {
    goto LABEL_41;
  }
  std::string::size_type v27 = 0;
  while (p_str->__r_.__value_.__s.__data_[v27] != 46)
  {
    if (size == ++v27) {
      goto LABEL_41;
    }
  }
  if (size == v27)
  {
LABEL_41:
    __p[0] = 0;
    __p[1] = 0;
    int64_t v106 = 0;
  }
  else
  {
    __p[0] = 0;
    __p[1] = 0;
    int64_t v106 = 0;
    if (v27 != -1)
    {
      std::string::basic_string(&buf, &__str, 0, v27, (std::allocator<char> *)&v102);
      goto LABEL_45;
    }
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&buf, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
  }
  else {
    std::string buf = __str;
  }
LABEL_45:
  CFIndex v28 = std::string::append(&buf, ".0", 2uLL);
  long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
  int64_t v106 = v28->__r_.__value_.__r.__words[2];
  *(_OWORD *)__n128 __p = v29;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  CFTypeRef v104 = 0;
  if (v106 >= 0) {
    uint64_t v30 = __p;
  }
  else {
    uint64_t v30 = (void **)__p[0];
  }
  CFStringRef v31 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v30, 0x8000100u);
  CFDictionaryRef v103 = 0;
  CFTypeRef v104 = v31;
  long long v102 = 0uLL;
  CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 80));
  keys = 0;
  unint64_t v100 = 0;
  uint64_t v101 = 0;
  sub_10004EE3C(&keys, Count);
  values = 0;
  CFTypeRef v97 = 0;
  uint64_t v98 = 0;
  sub_10004EE3C(&values, Count);
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 80), (const void **)keys, (const void **)values);
  if (Count >= 1)
  {
    uint64_t v33 = 0;
    while (1)
    {
      CFTypeRef cf = 0;
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)values[v33];
      sub_10004EFE4(&cf, (CFTypeRef *)&buf.__r_.__value_.__l.__data_);
      long long v34 = cf ? sub_100080778 : 0;
      uint64_t v35 = *(os_log_t **)(a1 + 72);
      if (v34) {
        break;
      }
      os_log_t v47 = *v35;
      if (os_log_type_enabled(*v35, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        __int16 v45 = v47;
        CFDictionaryRef v46 = "#N No update dict in collection.";
        goto LABEL_73;
      }
LABEL_74:
      sub_100057D78(&cf);
      if (++v33 == Count) {
        goto LABEL_135;
      }
    }
    CFDictionaryRef theDict = (CFDictionaryRef)cf;
    if (cf) {
      CFRetain(cf);
    }
    int v93 = v110;
    if (v110) {
      CFRetain(v110);
    }
    uint64_t v92 = (__CFString *)v104;
    if (v104) {
      CFRetain(v104);
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"OS");
    CFDictionaryRef v37 = Value;
    if (Value && (CFTypeID v38 = CFGetTypeID(Value), v38 == CFDictionaryGetTypeID()))
    {
      CFStringRef v39 = (const __CFString *)CFDictionaryGetValue(v37, @"Min");
      CFStringRef v40 = v39;
      if (v39)
      {
        CFTypeID v41 = CFGetTypeID(v39);
        if (v41 == CFStringGetTypeID()) {
          CFStringRef v42 = v40;
        }
        else {
          CFStringRef v42 = 0;
        }
      }
      else
      {
        CFStringRef v42 = 0;
      }
      CFStringRef v48 = (const __CFString *)CFDictionaryGetValue(v37, @"Max");
      CFStringRef v49 = v48;
      if (v48)
      {
        CFTypeID v50 = CFGetTypeID(v48);
        if (v50 == CFStringGetTypeID()) {
          CFStringRef v51 = v49;
        }
        else {
          CFStringRef v51 = 0;
        }
        if (v42)
        {
LABEL_82:
          if (_CompareBundleVersionStrings(v42, v92) != -1
            && _CompareBundleVersionStrings(v42, v93) != 1
            && (!v51 || _CompareBundleVersionStrings(v93, v51) != 1))
          {
            sub_1000558F4((const void **)&v92);
            sub_1000558F4((const void **)&v93);
            sub_100057D78((const void **)&theDict);
            CFDictionaryRef v91 = (CFDictionaryRef)cf;
            if (cf) {
              CFRetain(cf);
            }
            sub_100083DA4(&v90, (const void **)(a1 + 24));
            CFDictionaryRef v52 = (const __CFDictionary *)CFDictionaryGetValue(v91, @"Device");
            CFDictionaryRef v53 = v52;
            if (!v52) {
              goto LABEL_117;
            }
            CFTypeID v54 = CFGetTypeID(v52);
            if (v54 != CFDictionaryGetTypeID()) {
              goto LABEL_117;
            }
            buf.__r_.__value_.__r.__words[0] = 0;
            CFArrayRef v119 = (const __CFArray *)CFDictionaryGetValue(v53, @"Supported");
            sub_100044D6C(&buf, (CFTypeRef *)&v119);
            CFArrayRef v119 = 0;
            *(void *)v118 = CFDictionaryGetValue(v53, @"UnSupported");
            sub_100044D6C(&v119, (CFTypeRef *)v118);
            if (buf.__r_.__value_.__r.__words[0]) {
              long long v55 = sub_100083F10;
            }
            else {
              long long v55 = 0;
            }
            if (v55)
            {
              std::string::size_type v117 = buf.__r_.__value_.__r.__words[0];
              if (buf.__r_.__value_.__r.__words[0]) {
                CFRetain(buf.__r_.__value_.__l.__data_);
              }
              CFTypeRef v116 = v90;
              if (v90) {
                CFRetain(v90);
              }
              uint64_t v56 = (const void **)&v117;
              uint64_t v57 = &v116;
              BOOL v58 = sub_10049A78C((CFArrayRef *)&v117, (CFStringRef *)&v116);
            }
            else
            {
              if (v119) {
                group_session v62 = sub_100083F10;
              }
              else {
                group_session v62 = 0;
              }
              if (!v62)
              {
                sub_100044D00((const void **)&v119);
                sub_100044D00((const void **)&buf.__r_.__value_.__l.__data_);
LABEL_117:
                sub_1000558F4(&v90);
                sub_100057D78((const void **)&v91);
LABEL_118:
                *(void *)v118 = keys[v33];
                sub_100056248(&v119, (CFTypeRef *)v118);
                char v64 = (const __CFArray **)*((void *)&v102 + 1);
                if (*((void *)&v102 + 1) >= (unint64_t)v103)
                {
                  uint64_t v66 = (uint64_t)(*((void *)&v102 + 1) - v102) >> 3;
                  if ((unint64_t)(v66 + 1) >> 61) {
                    sub_10006A748();
                  }
                  unint64_t v67 = (uint64_t)&v103[-v102] >> 2;
                  if (v67 <= v66 + 1) {
                    unint64_t v67 = v66 + 1;
                  }
                  if ((unint64_t)&v103[-v102] >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v68 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v68 = v67;
                  }
                  CFStringRef v122 = &v103;
                  if (v68) {
                    std::string::size_type v69 = (char *)sub_10004EF74((uint64_t)&v103, v68);
                  }
                  else {
                    std::string::size_type v69 = 0;
                  }
                  uint64_t v70 = (const __CFArray **)&v69[8 * v66];
                  int64_t v71 = &v69[8 * v68];
                  uint64_t v121 = v71;
                  *uint64_t v70 = 0;
                  *uint64_t v70 = v119;
                  std::string::size_type v65 = v70 + 1;
                  CFArrayRef v119 = 0;
                  buf.__r_.__value_.__r.__words[2] = (std::string::size_type)(v70 + 1);
                  unint64_t v72 = (void *)*((void *)&v102 + 1);
                  unint64_t v73 = (void *)v102;
                  if (*((void *)&v102 + 1) == (void)v102)
                  {
                    int64x2_t v75 = vdupq_n_s64(*((unint64_t *)&v102 + 1));
                  }
                  else
                  {
                    do
                    {
                      *--uint64_t v70 = 0;
                      CFArrayRef v74 = (const __CFArray *)*--v72;
                      *uint64_t v70 = v74;
                      void *v72 = 0;
                    }
                    while (v72 != v73);
                    int64x2_t v75 = (int64x2_t)v102;
                    std::string::size_type v65 = (void *)buf.__r_.__value_.__r.__words[2];
                    int64_t v71 = v121;
                  }
                  *(void *)&long long v102 = v70;
                  *((void *)&v102 + 1) = v65;
                  *(int64x2_t *)&buf.__r_.__value_.__r.__words[1] = v75;
                  CFMutableDictionaryRef v76 = v103;
                  CFDictionaryRef v103 = v71;
                  uint64_t v121 = v76;
                  buf.__r_.__value_.__r.__words[0] = v75.i64[0];
                  sub_100083DDC((uint64_t)&buf);
                }
                else
                {
                  **((void **)&v102 + 1) = 0;
                  *char v64 = v119;
                  std::string::size_type v65 = v64 + 1;
                  CFArrayRef v119 = 0;
                }
                *((void *)&v102 + 1) = v65;
                sub_1000558F4((const void **)&v119);
                goto LABEL_74;
              }
              CFArrayRef v115 = v119;
              if (v119) {
                CFRetain(v119);
              }
              CFTypeRef v114 = v90;
              if (v90) {
                CFRetain(v90);
              }
              BOOL v58 = !sub_10049A78C(&v115, (CFStringRef *)&v114);
              uint64_t v56 = (const void **)&v115;
              uint64_t v57 = &v114;
            }
            sub_1000558F4(v57);
            sub_100044D00(v56);
            sub_100044D00((const void **)&v119);
            sub_100044D00((const void **)&buf.__r_.__value_.__l.__data_);
            sub_1000558F4(&v90);
            sub_100057D78((const void **)&v91);
            if (v58) {
              goto LABEL_118;
            }
            uint64_t v63 = **(NSObject ***)(a1 + 72);
            if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.__r_.__value_.__l.__data_) = 0;
              __int16 v45 = v63;
              CFDictionaryRef v46 = "#N Update not allowed for device";
              goto LABEL_73;
            }
            goto LABEL_74;
          }
          goto LABEL_69;
        }
      }
      else
      {
        CFStringRef v51 = 0;
        if (v42) {
          goto LABEL_82;
        }
      }
      os_log_t v59 = *v35;
      if (!os_log_type_enabled(*v35, OS_LOG_TYPE_ERROR))
      {
LABEL_69:
        sub_1000558F4((const void **)&v92);
        sub_1000558F4((const void **)&v93);
        sub_100057D78((const void **)&theDict);
        long long v44 = **(NSObject ***)(a1 + 72);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          __int16 v45 = v44;
          CFDictionaryRef v46 = "#N Update not allowed for os.";
LABEL_73:
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, v46, (uint8_t *)&buf, 2u);
          goto LABEL_74;
        }
        goto LABEL_74;
      }
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      unsigned int v60 = v59;
      CFTypeID v61 = "OS Dict is missing min OS entry. This is a mandatory key. Skipping";
    }
    else
    {
      os_log_t v43 = *v35;
      if (!os_log_type_enabled(*v35, OS_LOG_TYPE_ERROR)) {
        goto LABEL_69;
      }
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      unsigned int v60 = v43;
      CFTypeID v61 = "OS Dict is missing. Not a valid config. Skipping";
    }
    _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, v61, (uint8_t *)&buf, 2u);
    goto LABEL_69;
  }
LABEL_135:
  if ((void)v102 == *((void *)&v102 + 1))
  {
    CFDictionaryRef v81 = **(NSObject ***)(a1 + 72);
    if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "#N No matched updates present.", (uint8_t *)&buf, 2u);
    }
    CFArrayRef v119 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFArrayRef v83 = v119;
      CFArrayRef v119 = Mutable;
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v83;
      sub_10005717C((const void **)&buf.__r_.__value_.__l.__data_);
    }
    sub_10010F3F0(v119, @"BundleID", @"OtherKnown");
    buf.__r_.__value_.__s.__data_[0] = 3;
    buf.__r_.__value_.__l.__size_ = (std::string::size_type)v119;
    if (v119) {
      CFRetain(v119);
    }
    *(unsigned char *)a3 = 3;
    sub_10004EFE4((void *)(a3 + 8), (CFTypeRef *)&buf.__r_.__value_.__l.__size_);
    sub_10005717C((const void **)&buf.__r_.__value_.__l.__size_);
    sub_10005717C((const void **)&v119);
    goto LABEL_159;
  }
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)sub_1006CEC30;
  sub_10049A840(v102, *((const void ***)&v102 + 1), (uint64_t (**)(const void **, const void **))&buf, 126 - 2 * __clz((uint64_t)(*((void *)&v102 + 1) - v102) >> 3), 1);
  CFArrayRef v119 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), *(const void **)(*((void *)&v102 + 1) - 8));
  buf.__r_.__value_.__r.__words[0] = 0;
  CFMutableDictionaryRef v77 = (const void **)sub_10004EFE4(&buf, (CFTypeRef *)&v119);
  std::string::size_type v78 = (std::string::size_type)v113;
  int v113 = (const void *)buf.__r_.__value_.__r.__words[0];
  buf.__r_.__value_.__r.__words[0] = v78;
  sub_100057D78(v77);
  if (v113) {
    int v79 = sub_100080778;
  }
  else {
    int v79 = 0;
  }
  if (v79)
  {
    buf.__r_.__value_.__r.__words[0] = 0;
    CFArrayRef v119 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v113, @"BundleID");
    sub_100056248(&buf, (CFTypeRef *)&v119);
    CFArrayRef v119 = 0;
    *(void *)v118 = CFDictionaryGetValue((CFDictionaryRef)v113, @"BundleVersion");
    sub_100056248(&v119, (CFTypeRef *)v118);
    CFDictionaryRef v89 = (CFDictionaryRef)v113;
    if (v113) {
      CFRetain(v113);
    }
    sub_100058198(&v88, a2);
    std::string::size_type v87 = buf.__r_.__value_.__r.__words[0];
    if (buf.__r_.__value_.__r.__words[0]) {
      CFRetain(buf.__r_.__value_.__l.__data_);
    }
    CFArrayRef v86 = v119;
    if (v119) {
      CFRetain(v119);
    }
    char v80 = sub_100498480(a1, v89, (CFDictionaryRef *)&v88, (CFTypeRef *)&v87, (const __CFString **)&v86);
    sub_1000558F4((const void **)&v86);
    sub_1000558F4((const void **)&v87);
    sub_100057D78(&v88);
    sub_100057D78((const void **)&v89);
    if ((v80 & 1) == 0)
    {
      long long v84 = **(NSObject ***)(a1 + 72);
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v118 = 0;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "#I Not a new GSMA bundle, nothing to download", v118, 2u);
      }
      *(unsigned char *)a3 = 3;
      sub_100058198((const void **)(a3 + 8), &v113);
      sub_1000558F4((const void **)&v119);
      sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
      goto LABEL_159;
    }
    sub_1000558F4((const void **)&v119);
    sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
  }
  *(unsigned char *)a3 = 4;
  sub_100058198((const void **)(a3 + 8), &v113);
LABEL_159:
  if (values)
  {
    CFTypeRef v97 = values;
    operator delete(values);
  }
  if (keys)
  {
    unint64_t v100 = keys;
    operator delete(keys);
  }
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v102;
  sub_100084178((void ***)&buf);
  sub_1000558F4(&v104);
  if (SHIBYTE(v106) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  sub_1000558F4((const void **)&v110);
LABEL_168:
  if (SHIBYTE(v112) < 0) {
    operator delete((void *)v111);
  }
  return sub_100057D78(&v113);
}

void sub_1004995C0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10049981C(uint64_t result, char *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  std::string::size_type v10 = (char *)result;
LABEL_2:
  CFTypeID v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    std::string::size_type v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = a2 - v11;
    unint64_t v15 = (a2 - v11) >> 3;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t result = (*a3)(*((void *)a2 - 1), *(void *)v11);
          if (result)
          {
            uint64_t v22 = *(void *)v11;
            *(void *)CFTypeID v11 = *((void *)a2 - 1);
            *((void *)a2 - 1) = v22;
          }
          break;
        case 3uLL:
          uint64_t result = sub_100499D44(v11, (void *)v11 + 1, (void *)a2 - 1, (unsigned int (**)(void))a3);
          break;
        case 4uLL:
          uint64_t result = sub_10049A228(v11, (void *)v11 + 1, (void *)v11 + 2, (void *)a2 - 1, (unsigned int (**)(void))a3);
          break;
        case 5uLL:
          uint64_t result = sub_10049A2DC(v11, (void *)v11 + 1, (void *)v11 + 2, (void *)v11 + 3, (void *)a2 - 1, (unsigned int (**)(void))a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)sub_10049A3B8(v11, a2, (uint64_t *)a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    char v17 = &v11[8 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x401)
    {
      sub_100499D44(v11, &v11[8 * (v15 >> 1)], (void *)a2 - 1, (unsigned int (**)(void))a3);
      sub_100499D44((void *)v11 + 1, (void *)v17 - 1, (void *)a2 - 2, (unsigned int (**)(void))a3);
      sub_100499D44((void *)v11 + 2, &v11[8 * v16 + 8], (void *)a2 - 3, (unsigned int (**)(void))a3);
      sub_100499D44((void *)v17 - 1, v17, &v11[8 * v16 + 8], (unsigned int (**)(void))a3);
      uint64_t v18 = *(void *)v11;
      *(void *)CFTypeID v11 = *(void *)v17;
      *(void *)char v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      sub_100499D44(&v11[8 * (v15 >> 1)], v11, (void *)a2 - 1, (unsigned int (**)(void))a3);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (((*a3)(*((void *)v11 - 1), *(void *)v11) & 1) == 0)
    {
      uint64_t result = (uint64_t)sub_100499E34((uint64_t *)v11, (uint64_t *)a2, a3);
      CFTypeID v11 = (char *)result;
      goto LABEL_19;
    }
LABEL_14:
    CFTypeID v19 = sub_100499F44((uint64_t *)v11, (uint64_t *)a2, a3);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = sub_10049A060(v11, v19, (unsigned int (**)(void))a3);
    CFTypeID v11 = (char *)(v19 + 1);
    uint64_t result = sub_10049A060(v19 + 1, a2, (unsigned int (**)(void))a3);
    if (result)
    {
      a4 = -v13;
      a2 = (char *)v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      uint64_t result = sub_10049981C(v10, v19, a3, -v13, a5 & 1);
      CFTypeID v11 = (char *)(v19 + 1);
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return sub_100499BE0((uint64_t)v11, (uint64_t *)a2, a3);
  }
  else
  {
    return sub_100499CA8((uint64_t)v11, a2, a3);
  }
}

uint64_t sub_100499BE0(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  if ((uint64_t *)result != a2)
  {
    id v4 = (void *)result;
    char v5 = (uint64_t *)(result + 8);
    if ((uint64_t *)(result + 8) != a2)
    {
      uint64_t v7 = 0;
      CFTypeID v8 = (uint64_t *)result;
      do
      {
        uint64_t v10 = *v8;
        uint64_t v9 = v8[1];
        CFTypeID v8 = v5;
        uint64_t result = (*a3)(v9, v10);
        if (result)
        {
          uint64_t v11 = *v8;
          uint64_t v12 = v7;
          while (1)
          {
            *(void *)((char *)v4 + v12 + 8) = *(void *)((char *)v4 + v12);
            if (!v12) {
              break;
            }
            uint64_t result = (*a3)(v11, *(void *)((char *)v4 + v12 - 8));
            v12 -= 8;
            if ((result & 1) == 0)
            {
              uint64_t v13 = (void *)((char *)v4 + v12 + 8);
              goto LABEL_10;
            }
          }
          uint64_t v13 = v4;
LABEL_10:
          *uint64_t v13 = v11;
        }
        char v5 = v8 + 1;
        v7 += 8;
      }
      while (v8 + 1 != a2);
    }
  }
  return result;
}

uint64_t sub_100499CA8(uint64_t result, void *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  if ((void *)result != a2)
  {
    id v4 = (void *)result;
    for (uint64_t i = (void *)(result + 8); v4 + 1 != a2; uint64_t i = v4 + 1)
    {
      uint64_t v8 = *v4;
      uint64_t v7 = v4[1];
      id v4 = i;
      uint64_t result = (*a3)(v7, v8);
      if (result)
      {
        uint64_t v9 = *v4;
        uint64_t v10 = v4;
        do
        {
          uint64_t v11 = v10;
          uint64_t v12 = *--v10;
          *uint64_t v11 = v12;
          uint64_t result = (*a3)(v9, *(v11 - 2));
        }
        while ((result & 1) != 0);
        *uint64_t v10 = v9;
      }
    }
  }
  return result;
}

uint64_t sub_100499D44(void *a1, void *a2, void *a3, unsigned int (**a4)(void))
{
  char v8 = ((uint64_t (*)(void, void))*a4)(*a2, *a1);
  uint64_t result = ((uint64_t (*)(void, void))*a4)(*a3, *a2);
  if ((v8 & 1) == 0)
  {
    if (!result) {
      return result;
    }
    uint64_t v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    if (!((unsigned int (*)(void, void))*a4)(*a2, *a1)) {
      return 1;
    }
    uint64_t v12 = *a1;
    *a1 = *a2;
    *a2 = v12;
    return 2;
  }
  uint64_t v10 = *a1;
  if (!result)
  {
    *a1 = *a2;
    *a2 = v10;
    if (!(*a4)(*a3)) {
      return 1;
    }
    uint64_t v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    return 2;
  }
  *a1 = *a3;
  *a3 = v10;
  return 1;
}

uint64_t *sub_100499E34(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  id v4 = a2;
  uint64_t v6 = *a1;
  if ((*a3)(*a1, *(a2 - 1)))
  {
    uint64_t v7 = a1;
    do
    {
      uint64_t v8 = v7[1];
      ++v7;
    }
    while (((*a3)(v6, v8) & 1) == 0);
  }
  else
  {
    uint64_t v9 = a1 + 1;
    do
    {
      uint64_t v7 = v9;
      if (v9 >= v4) {
        break;
      }
      ++v9;
    }
    while (!(*a3)(v6, *v7));
  }
  if (v7 < v4)
  {
    do
      uint64_t v10 = *--v4;
    while (((*a3)(v6, v10) & 1) != 0);
  }
  while (v7 < v4)
  {
    uint64_t v11 = *v7;
    *uint64_t v7 = *v4;
    uint64_t *v4 = v11;
    do
    {
      uint64_t v12 = v7[1];
      ++v7;
    }
    while (!(*a3)(v6, v12));
    do
      uint64_t v13 = *--v4;
    while (((*a3)(v6, v13) & 1) != 0);
  }
  if (v7 - 1 != a1) {
    *a1 = *(v7 - 1);
  }
  *(v7 - 1) = v6;
  return v7;
}

uint64_t *sub_100499F44(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  uint64_t v6 = 0;
  uint64_t v7 = *a1;
  do
    char v8 = (*a3)(a1[++v6], v7);
  while ((v8 & 1) != 0);
  uint64_t v9 = &a1[v6];
  uint64_t v10 = &a1[v6 - 1];
  if (v6 == 1)
  {
    do
    {
      if (v9 >= a2) {
        break;
      }
      uint64_t v12 = *--a2;
    }
    while (((*a3)(v12, v7) & 1) == 0);
  }
  else
  {
    do
      uint64_t v11 = *--a2;
    while (!(*a3)(v11, v7));
  }
  if (v9 < a2)
  {
    uint64_t v13 = a2;
    uint64_t v14 = v9;
    do
    {
      uint64_t v15 = *v14;
      *uint64_t v14 = *v13;
      *uint64_t v13 = v15;
      do
      {
        uint64_t v16 = v14[1];
        ++v14;
      }
      while (((*a3)(v16, v7) & 1) != 0);
      do
        uint64_t v17 = *--v13;
      while (!(*a3)(v17, v7));
    }
    while (v14 < v13);
    uint64_t v10 = v14 - 1;
  }
  if (v10 != a1) {
    *a1 = *v10;
  }
  *uint64_t v10 = v7;
  return v10;
}

BOOL sub_10049A060(void *a1, void *a2, unsigned int (**a3)(void))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(void, void))*a3)(*(a2 - 1), *a1))
      {
        uint64_t v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      sub_100499D44(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      sub_10049A228(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      sub_10049A2DC(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v9 = a1 + 2;
      sub_100499D44(a1, a1 + 1, a1 + 2, a3);
      uint64_t v10 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    if (((unsigned int (*)(void, void))*a3)(*v10, *v9))
    {
      uint64_t v13 = *v10;
      uint64_t v14 = v11;
      while (1)
      {
        uint64_t v15 = (char *)a1 + v14;
        *(void *)((char *)a1 + v14 + 24) = *(void *)((char *)a1 + v14 + 16);
        if (v14 == -16) {
          break;
        }
        v14 -= 8;
        if ((((uint64_t (*)(uint64_t, void))*a3)(v13, *((void *)v15 + 1)) & 1) == 0)
        {
          uint64_t v16 = (void *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }
      uint64_t v16 = a1;
LABEL_12:
      *uint64_t v16 = v13;
      if (++v12 == 8) {
        return v10 + 1 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 8;
    if (++v10 == a2) {
      return 1;
    }
  }
}

uint64_t sub_10049A228(void *a1, void *a2, void *a3, void *a4, unsigned int (**a5)(void))
{
  sub_100499D44(a1, a2, a3, a5);
  uint64_t result = ((uint64_t (*)(void, void))*a5)(*a4, *a3);
  if (result)
  {
    uint64_t v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    uint64_t result = ((uint64_t (*)(void, void))*a5)(*a3, *a2);
    if (result)
    {
      uint64_t v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      uint64_t result = ((uint64_t (*)(void, void))*a5)(*a2, *a1);
      if (result)
      {
        uint64_t v13 = *a1;
        *a1 = *a2;
        *a2 = v13;
      }
    }
  }
  return result;
}

uint64_t sub_10049A2DC(void *a1, void *a2, void *a3, void *a4, void *a5, unsigned int (**a6)(void))
{
  sub_10049A228(a1, a2, a3, a4, a6);
  uint64_t result = ((uint64_t (*)(void, void))*a6)(*a5, *a4);
  if (result)
  {
    uint64_t v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    uint64_t result = ((uint64_t (*)(void, void))*a6)(*a4, *a3);
    if (result)
    {
      uint64_t v14 = *a3;
      *a3 = *a4;
      *a4 = v14;
      uint64_t result = ((uint64_t (*)(void, void))*a6)(*a3, *a2);
      if (result)
      {
        uint64_t v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        uint64_t result = ((uint64_t (*)(void, void))*a6)(*a2, *a1);
        if (result)
        {
          uint64_t v16 = *a1;
          *a1 = *a2;
          *a2 = v16;
        }
      }
    }
  }
  return result;
}

uint64_t *sub_10049A3B8(char *a1, char *a2, uint64_t *a3, uint64_t (**a4)(uint64_t, uint64_t))
{
  if (a1 != a2)
  {
    uint64_t v8 = a2 - a1;
    uint64_t v9 = (a2 - a1) >> 3;
    if (a2 - a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[8 * v10];
      do
      {
        sub_10049A510((uint64_t)a1, (unsigned int (**)(void, void))a4, v9, v12);
        v12 -= 8;
        --v11;
      }
      while (v11);
    }
    uint64_t v13 = a2;
    if (a2 != (char *)a3)
    {
      uint64_t v14 = (uint64_t *)a2;
      do
      {
        if ((*a4)(*v14, *(void *)a1))
        {
          uint64_t v15 = *v14;
          *uint64_t v14 = *(void *)a1;
          *(void *)a1 = v15;
          sub_10049A510((uint64_t)a1, (unsigned int (**)(void, void))a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      uint64_t v13 = (char *)a3;
    }
    if (v8 >= 9)
    {
      uint64_t v16 = (unint64_t)v8 >> 3;
      uint64_t v17 = a2 - 8;
      do
      {
        uint64_t v18 = *(void *)a1;
        CFTypeID v19 = (char *)sub_10049A638(a1, (unsigned int (**)(void, void))a4, v16);
        if (v17 == v19)
        {
          *(void *)CFTypeID v19 = v18;
        }
        else
        {
          *(void *)CFTypeID v19 = *(void *)v17;
          *(void *)uint64_t v17 = v18;
          sub_10049A6E8((uint64_t)a1, (uint64_t)(v19 + 8), a4, (v19 + 8 - a1) >> 3);
        }
        v17 -= 8;
      }
      while (v16-- > 2);
    }
    return (uint64_t *)v13;
  }
  return a3;
}

uint64_t sub_10049A510(uint64_t result, unsigned int (**a2)(void, void), uint64_t a3, void *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    char v5 = a4;
    uint64_t v6 = result;
    int64_t v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v10 = ((uint64_t)a4 - result) >> 2;
      uint64_t v11 = v10 + 1;
      uint64_t v12 = (void *)(result + 8 * (v10 + 1));
      uint64_t v13 = v10 + 2;
      if (v10 + 2 < a3 && (*a2)(*v12, v12[1]))
      {
        ++v12;
        uint64_t v11 = v13;
      }
      uint64_t result = ((uint64_t (*)(void, void))*a2)(*v12, *v5);
      if ((result & 1) == 0)
      {
        uint64_t v14 = *v5;
        do
        {
          uint64_t v15 = v12;
          *char v5 = *v12;
          if (v7 < v11) {
            break;
          }
          uint64_t v16 = (2 * v11) | 1;
          uint64_t v12 = (void *)(v6 + 8 * v16);
          if (2 * v11 + 2 < a3)
          {
            if ((*a2)(*v12, v12[1]))
            {
              ++v12;
              uint64_t v16 = 2 * v11 + 2;
            }
          }
          uint64_t result = ((uint64_t (*)(void, uint64_t))*a2)(*v12, v14);
          char v5 = v15;
          uint64_t v11 = v16;
        }
        while (!result);
        *uint64_t v15 = v14;
      }
    }
  }
  return result;
}

void *sub_10049A638(void *a1, unsigned int (**a2)(void, void), uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    uint64_t v9 = &a1[v6 + 1];
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3 && (*a2)(a1[v6 + 1], a1[v6 + 2]))
    {
      ++v9;
      uint64_t v10 = v11;
    }
    *a1 = *v9;
    a1 = v9;
    uint64_t v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

uint64_t sub_10049A6E8(uint64_t result, uint64_t a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v6 = result;
    unint64_t v7 = v4 >> 1;
    uint64_t v8 = (uint64_t *)(result + 8 * (v4 >> 1));
    uint64_t v9 = (uint64_t *)(a2 - 8);
    uint64_t result = (*a3)(*v8, *(void *)(a2 - 8));
    if (result)
    {
      uint64_t v10 = *v9;
      do
      {
        uint64_t v11 = v8;
        *uint64_t v9 = *v8;
        if (!v7) {
          break;
        }
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v8 = (uint64_t *)(v6 + 8 * v7);
        uint64_t result = (*a3)(*v8, v10);
        uint64_t v9 = v11;
      }
      while ((result & 1) != 0);
      *uint64_t v11 = v10;
    }
  }
  return result;
}

BOOL sub_10049A78C(CFArrayRef *a1, CFStringRef *a2)
{
  CFIndex Count = CFArrayGetCount(*a1);
  if (Count < 1)
  {
    return 0;
  }
  else
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0;
    BOOL v7 = 1;
    do
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*a1, v6);
      if (ValueAtIndex)
      {
        CFStringRef v9 = ValueAtIndex;
        CFTypeID v10 = CFGetTypeID(ValueAtIndex);
        if (v10 == CFStringGetTypeID() && CFEqual(v9, *a2)) {
          break;
        }
      }
      BOOL v7 = ++v6 < v5;
    }
    while (v5 != v6);
  }
  return v7;
}

uint64_t sub_10049A840(uint64_t result, const void **a2, uint64_t (**a3)(const void **, const void **), uint64_t a4, char a5)
{
  CFTypeID v10 = (const void **)result;
LABEL_2:
  uint64_t v11 = v10;
  v118 = v10 + 1;
  CFArrayRef v115 = v10 - 1;
  CFTypeRef v116 = v10 + 2;
  uint64_t v12 = a2;
  while (1)
  {
    uint64_t v13 = (char *)v12 - (char *)v11;
    uint64_t v14 = v12 - v11;
    if (!(!v6 & v5))
    {
      switch(v14)
      {
        case 0:
        case 1:
          return result;
        case 2:
          long long v55 = *a3;
          sub_100083DA4(&v123, v12 - 1);
          sub_100083DA4(&v122, v11);
          LODWORD(v55) = v55(&v123, &v122);
          sub_1000558F4(&v122);
          uint64_t result = (uint64_t)sub_1000558F4(&v123);
          if (v55) {
            uint64_t result = (uint64_t)sub_10049B818(v11, v12 - 1);
          }
          break;
        case 3:
          uint64_t result = (uint64_t)sub_10049B898(v11, v11 + 1, v12 - 1, a3);
          break;
        case 4:
          uint64_t result = (uint64_t)sub_10049BDA4(v11, v11 + 1, v11 + 2, v12 - 1, a3);
          break;
        case 5:
          uint64_t result = (uint64_t)sub_10049BF18(v11, v11 + 1, v11 + 2, v11 + 3, v12 - 1, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v13 <= 191) {
      break;
    }
    a2 = v12;
    if (!a4)
    {
      if (v11 != v12)
      {
        int64_t v70 = (unint64_t)(v14 - 2) >> 1;
        int64_t v119 = v70;
        do
        {
          int64_t v71 = v70;
          if (v119 >= v70)
          {
            uint64_t v72 = (2 * v70) | 1;
            unint64_t v73 = &v11[v72];
            if (2 * v70 + 2 < v14)
            {
              CFArrayRef v74 = *a3;
              sub_100083DA4(&v134, &v11[v72]);
              sub_100083DA4(&v133, v73 + 1);
              LODWORD(v74) = v74(&v134, &v133);
              sub_1000558F4(&v133);
              sub_1000558F4(&v134);
              v73 += v74;
              if (v74) {
                uint64_t v72 = 2 * v71 + 2;
              }
            }
            int64x2_t v75 = &v11[v71];
            CFMutableDictionaryRef v76 = *a3;
            sub_100083DA4(&v132, v73);
            sub_100083DA4(&v131, v75);
            char v77 = v76(&v132, &v131);
            sub_1000558F4(&v131);
            uint64_t result = (uint64_t)sub_1000558F4(&v132);
            if ((v77 & 1) == 0)
            {
              CFTypeRef cf = *v75;
              *int64x2_t v75 = 0;
              do
              {
                std::string::size_type v78 = v73;
                if (v75 != v73)
                {
                  int v79 = *v75;
                  *int64x2_t v75 = 0;
                  v135[0] = v79;
                  *int64x2_t v75 = *v73;
                  *unint64_t v73 = 0;
                  sub_1000558F4(v135);
                }
                if (v119 < v72) {
                  break;
                }
                uint64_t v80 = (2 * v72) | 1;
                unint64_t v73 = &v11[v80];
                uint64_t v72 = 2 * v72 + 2;
                if (v72 < v14)
                {
                  CFDictionaryRef v81 = *a3;
                  sub_100083DA4(&v129, &v11[v80]);
                  sub_100083DA4(&v128, v73 + 1);
                  LODWORD(v81) = v81(&v129, &v128);
                  sub_1000558F4(&v128);
                  sub_1000558F4(&v129);
                  v73 += v81;
                  if (!v81) {
                    uint64_t v72 = v80;
                  }
                }
                else
                {
                  uint64_t v72 = v80;
                }
                CFDictionaryRef v82 = *a3;
                sub_100083DA4(&v127, v73);
                CFTypeRef v126 = cf;
                if (cf) {
                  CFRetain(cf);
                }
                int v83 = v82(&v127, &v126);
                sub_1000558F4(&v126);
                sub_1000558F4(&v127);
                int64x2_t v75 = v78;
              }
              while (!v83);
              if (v78 != &cf)
              {
                CFTypeRef v84 = *v78;
                CFTypeRef *v78 = 0;
                v135[0] = v84;
                CFTypeRef *v78 = cf;
                CFTypeRef cf = 0;
                sub_1000558F4(v135);
              }
              uint64_t result = (uint64_t)sub_1000558F4(&cf);
            }
          }
          int64_t v70 = v71 - 1;
        }
        while (v71);
        uint64_t v85 = (unint64_t)v13 >> 3;
        CFArrayRef v86 = a2;
        do
        {
          if (v85 >= 2)
          {
            std::string::size_type v87 = v86;
            uint64_t v88 = 0;
            int v129 = *v11;
            *uint64_t v11 = 0;
            CFDictionaryRef v89 = v11;
            do
            {
              CFTypeRef v90 = &v89[v88 + 1];
              uint64_t v91 = 2 * v88;
              uint64_t v88 = (2 * v88) | 1;
              uint64_t v92 = v91 + 2;
              if (v91 + 2 < v85)
              {
                int v93 = *a3;
                sub_100083DA4(&v134, v90);
                sub_100083DA4(&v133, v90 + 1);
                LODWORD(v93) = v93(&v134, &v133);
                sub_1000558F4(&v133);
                sub_1000558F4(&v134);
                v90 += v93;
                if (v93) {
                  uint64_t v88 = v92;
                }
              }
              if (v89 != v90)
              {
                CFRange v94 = *v89;
                *CFDictionaryRef v89 = 0;
                v135[0] = v94;
                *CFDictionaryRef v89 = *v90;
                const char *v90 = 0;
                sub_1000558F4(v135);
              }
              CFDictionaryRef v89 = v90;
            }
            while (v88 <= (uint64_t)((unint64_t)(v85 - 2) >> 1));
            CFArrayRef v86 = v87;
            std::string::size_type v95 = v87 - 1;
            if (v90 == v87 - 1)
            {
              if (v90 != &v129)
              {
                int64_t v106 = *v90;
                const char *v90 = 0;
                v135[0] = v106;
                const char *v90 = v129;
                int v129 = 0;
                sub_1000558F4(v135);
              }
            }
            else
            {
              unsigned __int8 v96 = *v90;
              const char *v90 = 0;
              v135[0] = v96;
              const char *v90 = *v95;
              CFTypeRef v97 = v90 + 1;
              long long *v95 = 0;
              uint64_t v98 = sub_1000558F4(v135);
              if (v95 != &v129)
              {
                v135[0] = *v95;
                long long *v95 = v129;
                int v129 = 0;
                sub_1000558F4(v98);
              }
              if ((char *)v97 - (char *)v11 >= 9)
              {
                unint64_t v99 = (((unint64_t)((char *)v97 - (char *)v11) >> 3) - 2) >> 1;
                unint64_t v100 = &v11[v99];
                uint64_t v101 = *a3;
                sub_100083DA4(&v134, v100);
                sub_100083DA4(&v133, v90);
                LODWORD(v101) = v101(&v134, &v133);
                sub_1000558F4(&v133);
                sub_1000558F4(&v134);
                if (v101)
                {
                  long long v132 = *v90;
                  const char *v90 = 0;
                  do
                  {
                    long long v102 = v100;
                    if (v90 != v100)
                    {
                      CFDictionaryRef v103 = *v90;
                      const char *v90 = 0;
                      v135[0] = v103;
                      const char *v90 = *v100;
                      *unint64_t v100 = 0;
                      sub_1000558F4(v135);
                    }
                    if (!v99) {
                      break;
                    }
                    unint64_t v99 = (v99 - 1) >> 1;
                    unint64_t v100 = &v11[v99];
                    CFTypeRef v104 = *a3;
                    sub_100083DA4(&v131, v100);
                    CFTypeRef cf = v132;
                    if (v132) {
                      CFRetain(v132);
                    }
                    char v105 = v104(&v131, &cf);
                    sub_1000558F4(&cf);
                    sub_1000558F4(&v131);
                    CFTypeRef v90 = v102;
                  }
                  while ((v105 & 1) != 0);
                  if (v102 != &v132)
                  {
                    v135[0] = *v102;
                    *long long v102 = v132;
                    long long v132 = 0;
                    sub_1000558F4(v135);
                  }
                  sub_1000558F4(&v132);
                  CFArrayRef v86 = v87;
                }
              }
            }
            uint64_t result = (uint64_t)sub_1000558F4(&v129);
          }
          --v86;
        }
        while ((unint64_t)v85-- > 2);
      }
      return result;
    }
    uint64_t v15 = &v11[(unint64_t)v14 >> 1];
    if ((unint64_t)v13 < 0x401)
    {
      sub_10049B898(v15, v11, v12 - 1, a3);
    }
    else
    {
      sub_10049B898(v11, v15, v12 - 1, a3);
      sub_10049B898(v118, v15 - 1, v12 - 2, a3);
      sub_10049B898(v116, v15 + 1, v12 - 3, a3);
      sub_10049B898(v15 - 1, v15, v15 + 1, a3);
      uint64_t v16 = *v11;
      long long v134 = *v11;
      *uint64_t v11 = 0;
      v135[0] = 0;
      *uint64_t v11 = *v15;
      *uint64_t v15 = 0;
      uint64_t v17 = sub_1000558F4(v135);
      if (&v134 != v15)
      {
        v135[0] = *v15;
        *uint64_t v15 = v16;
        long long v134 = 0;
        sub_1000558F4(v17);
      }
      sub_1000558F4(&v134);
    }
    --a4;
    if ((a5 & 1) == 0)
    {
      uint64_t v18 = *a3;
      sub_100083DA4(&v121, v115);
      sub_100083DA4(&v120, v11);
      LOBYTE(v18) = v18(&v121, &v120);
      sub_1000558F4(&v120);
      sub_1000558F4(&v121);
      if ((v18 & 1) == 0)
      {
        long long v134 = *v11;
        CFDictionaryRef v37 = v134;
        *uint64_t v11 = 0;
        CFTypeID v38 = *a3;
        int v133 = v37;
        if (v37) {
          CFRetain(v37);
        }
        sub_100083DA4(&v132, v12 - 1);
        char v39 = v38(&v133, &v132);
        sub_1000558F4(&v132);
        sub_1000558F4(&v133);
        if (v39)
        {
          CFTypeID v10 = v11;
          do
          {
            CFStringRef v40 = *a3;
            int v131 = v134;
            if (v134) {
              CFRetain(v134);
            }
            sub_100083DA4(&cf, ++v10);
            char v41 = v40(&v131, &cf);
            sub_1000558F4(&cf);
            sub_1000558F4(&v131);
          }
          while ((v41 & 1) == 0);
        }
        else
        {
          CFStringRef v42 = v11 + 1;
          do
          {
            CFTypeID v10 = v42;
            if (v42 >= v12) {
              break;
            }
            os_log_t v43 = *a3;
            int v131 = v134;
            if (v134) {
              CFRetain(v134);
            }
            sub_100083DA4(&cf, v10);
            char v44 = v43(&v131, &cf);
            sub_1000558F4(&cf);
            sub_1000558F4(&v131);
            CFStringRef v42 = v10 + 1;
          }
          while ((v44 & 1) == 0);
        }
        __int16 v45 = v12;
        if (v10 < v12)
        {
          __int16 v45 = v12;
          do
          {
            CFDictionaryRef v46 = *a3;
            int v129 = v134;
            if (v134) {
              CFRetain(v134);
            }
            sub_100083DA4(&v128, --v45);
            char v47 = v46(&v129, &v128);
            sub_1000558F4(&v128);
            sub_1000558F4(&v129);
          }
          while ((v47 & 1) != 0);
        }
        while (v10 < v45)
        {
          sub_10049B818(v10, v45);
          do
          {
            CFStringRef v48 = *a3;
            int v127 = v134;
            if (v134) {
              CFRetain(v134);
            }
            sub_100083DA4(&v126, ++v10);
            int v49 = v48(&v127, &v126);
            sub_1000558F4(&v126);
            sub_1000558F4(&v127);
          }
          while (!v49);
          do
          {
            CFTypeID v50 = *a3;
            long long v125 = v134;
            if (v134) {
              CFRetain(v134);
            }
            sub_100083DA4(&v124, --v45);
            char v51 = v50(&v125, &v124);
            sub_1000558F4(&v124);
            sub_1000558F4(&v125);
          }
          while ((v51 & 1) != 0);
        }
        CFDictionaryRef v52 = v10 - 1;
        if (v10 - 1 != v11)
        {
          CFDictionaryRef v53 = *v11;
          *uint64_t v11 = 0;
          v135[0] = v53;
          *uint64_t v11 = *v52;
          NSObject *v52 = 0;
          sub_1000558F4(v135);
        }
        if (v52 != &v134)
        {
          CFTypeID v54 = *v52;
          NSObject *v52 = 0;
          v135[0] = v54;
          NSObject *v52 = v134;
          long long v134 = 0;
          sub_1000558F4(v135);
        }
        uint64_t result = (uint64_t)sub_1000558F4(&v134);
        a5 = 0;
        goto LABEL_2;
      }
    }
    uint64_t v19 = 0;
    long long v134 = *v11;
    *uint64_t v11 = 0;
    do
    {
      char v20 = *a3;
      sub_100083DA4(&v133, &v11[v19 + 1]);
      long long v132 = v134;
      if (v134) {
        CFRetain(v134);
      }
      char v21 = v20(&v133, &v132);
      sub_1000558F4(&v132);
      sub_1000558F4(&v133);
      ++v19;
    }
    while ((v21 & 1) != 0);
    uint64_t v22 = &v11[v19];
    int v23 = v12;
    if (v19 == 1)
    {
      int v23 = v12;
      do
      {
        if (v22 >= v23) {
          break;
        }
        CFArrayRef v26 = *a3;
        sub_100083DA4(&v131, --v23);
        CFTypeRef cf = v134;
        if (v134) {
          CFRetain(v134);
        }
        char v27 = v26(&v131, &cf);
        sub_1000558F4(&cf);
        sub_1000558F4(&v131);
      }
      while ((v27 & 1) == 0);
    }
    else
    {
      do
      {
        --v23;
        CFTypeID v24 = *a3;
        sub_100083DA4(&v131, v23);
        CFTypeRef cf = v134;
        if (v134) {
          CFRetain(v134);
        }
        char v25 = v24(&v131, &cf);
        sub_1000558F4(&cf);
        sub_1000558F4(&v131);
      }
      while ((v25 & 1) == 0);
    }
    if (v22 >= v23)
    {
      uint64_t v12 = v22 - 1;
    }
    else
    {
      CFIndex v28 = v22;
      long long v29 = v23;
      do
      {
        sub_10049B818(v28, v29);
        do
        {
          ++v28;
          uint64_t v30 = *a3;
          sub_100083DA4(&v129, v28);
          uint64_t v128 = v134;
          if (v134) {
            CFRetain(v134);
          }
          char v31 = v30(&v129, &v128);
          sub_1000558F4(&v128);
          sub_1000558F4(&v129);
        }
        while ((v31 & 1) != 0);
        do
        {
          --v29;
          CFTypeID v32 = *a3;
          sub_100083DA4(&v127, v29);
          CFTypeRef v126 = v134;
          if (v134) {
            CFRetain(v134);
          }
          int v33 = v32(&v127, &v126);
          sub_1000558F4(&v126);
          sub_1000558F4(&v127);
        }
        while (!v33);
      }
      while (v28 < v29);
      uint64_t v12 = v28 - 1;
    }
    if (v12 != v11)
    {
      long long v34 = *v11;
      *uint64_t v11 = 0;
      v135[0] = v34;
      *uint64_t v11 = *v12;
      *uint64_t v12 = 0;
      sub_1000558F4(v135);
    }
    if (v12 != &v134)
    {
      uint64_t v35 = *v12;
      *uint64_t v12 = 0;
      v135[0] = v35;
      *uint64_t v12 = v134;
      long long v134 = 0;
      sub_1000558F4(v135);
    }
    sub_1000558F4(&v134);
    if (v22 < v23) {
      goto LABEL_49;
    }
    char v36 = sub_10049BAA4(v11, v12, a3);
    CFTypeID v10 = v12 + 1;
    uint64_t result = sub_10049BAA4(v12 + 1, a2, a3);
    if (!result)
    {
      if (v36) {
        goto LABEL_2;
      }
LABEL_49:
      uint64_t result = sub_10049A840(v11, v12, a3, a4, a5 & 1);
      a5 = 0;
      CFTypeID v10 = v12 + 1;
      goto LABEL_2;
    }
    if (v36) {
      return result;
    }
  }
  uint64_t v56 = v11 + 1;
  BOOL v58 = v11 == v12 || v56 == v12;
  if (a5)
  {
    if (!v58)
    {
      uint64_t v59 = 0;
      unsigned int v60 = v11;
      do
      {
        CFTypeID v61 = v60;
        unsigned int v60 = v56;
        group_session v62 = *a3;
        sub_100083DA4(&v134, v56);
        sub_100083DA4(&v133, v61);
        LODWORD(v61) = v62(&v134, &v133);
        sub_1000558F4(&v133);
        uint64_t result = (uint64_t)sub_1000558F4(&v134);
        if (v61)
        {
          long long v132 = *v60;
          NSObject *v60 = 0;
          uint64_t v63 = v59;
          while (1)
          {
            char v64 = (const void **)((char *)v11 + v63);
            v135[0] = *(const void **)((char *)v11 + v63 + 8);
            uint64_t v65 = *(uint64_t *)((char *)v11 + v63);
            *char v64 = 0;
            v64[1] = v65;
            sub_1000558F4(v135);
            if (!v63) {
              break;
            }
            uint64_t v66 = *a3;
            int v131 = v132;
            if (v132) {
              CFRetain(v132);
            }
            sub_100083DA4(&cf, (const void **)((char *)v11 + v63 - 8));
            char v67 = v66(&v131, &cf);
            sub_1000558F4(&cf);
            sub_1000558F4(&v131);
            v63 -= 8;
            if ((v67 & 1) == 0)
            {
              unint64_t v68 = (const void **)((char *)v11 + v63 + 8);
              goto LABEL_105;
            }
          }
          unint64_t v68 = v11;
LABEL_105:
          if (v68 != &v132)
          {
            std::string::size_type v69 = *v68;
            *unint64_t v68 = 0;
            v135[0] = v69;
            *unint64_t v68 = v132;
            long long v132 = 0;
            sub_1000558F4(v135);
          }
          uint64_t result = (uint64_t)sub_1000558F4(&v132);
        }
        uint64_t v56 = v60 + 1;
        v59 += 8;
      }
      while (v60 + 1 != v12);
    }
  }
  else if (!v58)
  {
    do
    {
      char v108 = v11;
      uint64_t v11 = v56;
      std::string v109 = *a3;
      sub_100083DA4(&v134, v56);
      sub_100083DA4(&v133, v108);
      LODWORD(v108) = v109(&v134, &v133);
      sub_1000558F4(&v133);
      uint64_t result = (uint64_t)sub_1000558F4(&v134);
      if (v108)
      {
        long long v132 = *v11;
        *uint64_t v11 = 0;
        uint64_t v110 = v11;
        do
        {
          v135[0] = *v110;
          long long v111 = *(v110 - 1);
          *(v110 - 1) = 0;
          *uint64_t v110 = v111;
          sub_1000558F4(v135);
          uint64_t v112 = *a3;
          int v131 = v132;
          if (v132) {
            CFRetain(v132);
          }
          sub_100083DA4(&cf, v110 - 2);
          char v113 = v112(&v131, &cf);
          sub_1000558F4(&cf);
          sub_1000558F4(&v131);
          --v110;
        }
        while ((v113 & 1) != 0);
        if (v110 != &v132)
        {
          CFTypeRef v114 = *v110;
          *uint64_t v110 = 0;
          v135[0] = v114;
          *uint64_t v110 = v132;
          long long v132 = 0;
          sub_1000558F4(v135);
        }
        uint64_t result = (uint64_t)sub_1000558F4(&v132);
      }
      uint64_t v56 = v11 + 1;
    }
    while (v11 + 1 != v12);
  }
  return result;
}

void sub_10049B678(_Unwind_Exception *a1)
{
  sub_1000558F4((const void **)(v1 - 120));
  sub_1000558F4((const void **)(v1 - 112));
  sub_1000558F4((const void **)(v1 - 104));
  _Unwind_Resume(a1);
}

const void **sub_10049B818(const void **a1, const void **a2)
{
  uint64_t v3 = *a1;
  char v6 = *a1;
  *a1 = 0;
  if (a1 != a2)
  {
    *a1 = 0;
    BOOL v7 = 0;
    *a1 = *a2;
    *a2 = 0;
    sub_1000558F4(&v7);
  }
  if (&v6 != a2)
  {
    unint64_t v4 = *a2;
    char v6 = 0;
    BOOL v7 = v4;
    *a2 = v3;
    sub_1000558F4(&v7);
  }
  return sub_1000558F4(&v6);
}

const void **sub_10049B898(const void **a1, const void **a2, const void **a3, uint64_t (**a4)(const void **, const void **))
{
  uint64_t v8 = *a4;
  sub_100083DA4(&v26, a2);
  sub_100083DA4(&v25, a1);
  LOBYTE(v8) = v8(&v26, &v25);
  sub_1000558F4(&v25);
  sub_1000558F4(&v26);
  CFStringRef v9 = *a4;
  if (v8)
  {
    sub_100083DA4(&v20, a3);
    sub_100083DA4(&v19, a2);
    int v10 = v9(&v20, &v19);
    sub_1000558F4(&v19);
    sub_1000558F4(&v20);
    uint64_t v11 = a1;
    if (!v10)
    {
      sub_10049B818(a1, a2);
      uint64_t v12 = *a4;
      sub_100083DA4(&v18, a3);
      sub_100083DA4(&v17, a2);
      LODWORD(v12) = v12(&v18, &v17);
      sub_1000558F4(&v17);
      uint64_t result = sub_1000558F4(&v18);
      if (!v12) {
        return result;
      }
      uint64_t v11 = a2;
    }
    uint64_t v14 = a3;
    return sub_10049B818(v11, v14);
  }
  sub_100083DA4(&v24, a3);
  sub_100083DA4(&v23, a2);
  char v15 = v9(&v24, &v23);
  sub_1000558F4(&v23);
  uint64_t result = sub_1000558F4(&v24);
  if (v15)
  {
    sub_10049B818(a2, a3);
    uint64_t v16 = *a4;
    sub_100083DA4(&v22, a2);
    sub_100083DA4(&v21, a1);
    LODWORD(v16) = v16(&v22, &v21);
    sub_1000558F4(&v21);
    uint64_t result = sub_1000558F4(&v22);
    if (v16)
    {
      uint64_t v11 = a1;
      uint64_t v14 = a2;
      return sub_10049B818(v11, v14);
    }
  }
  return result;
}

void sub_10049BA44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  char v6 = va_arg(va1, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_10049BAA4(const void **a1, const void **a2, uint64_t (**a3)(const void **, const void **))
{
  BOOL v6 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v6;
    case 2:
      BOOL v7 = *a3;
      uint64_t v8 = a2 - 1;
      sub_100083DA4(&v29, a2 - 1);
      sub_100083DA4(&v28, a1);
      int v9 = v7(&v29, &v28);
      sub_1000558F4(&v28);
      sub_1000558F4(&v29);
      if (v9) {
        sub_10049B818(a1, v8);
      }
      return 1;
    case 3:
      sub_10049B898(a1, a1 + 1, a2 - 1, a3);
      return v6;
    case 4:
      sub_10049BDA4(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return v6;
    case 5:
      sub_10049BF18(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return v6;
    default:
      int v10 = a1 + 2;
      sub_10049B898(a1, a1 + 1, a1 + 2, a3);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    uint64_t v14 = *a3;
    sub_100083DA4(&v27, v11);
    sub_100083DA4(&v26, v10);
    int v15 = v14(&v27, &v26);
    sub_1000558F4(&v26);
    sub_1000558F4(&v27);
    if (v15) {
      break;
    }
LABEL_19:
    int v10 = v11;
    v12 += 8;
    if (++v11 == a2) {
      return 1;
    }
  }
  CFTypeRef cf = *v11;
  *uint64_t v11 = 0;
  uint64_t v16 = v12;
  while (1)
  {
    uint64_t v17 = (char *)a1 + v16;
    uint64_t v18 = *(uint64_t *)((char *)a1 + v16 + 16);
    CFTypeRef v30 = *(const void **)((char *)a1 + v16 + 24);
    *((void *)v17 + 2) = 0;
    *((void *)v17 + 3) = v18;
    sub_1000558F4(&v30);
    if (v16 == -16) {
      break;
    }
    uint64_t v19 = *a3;
    CFTypeRef v24 = cf;
    if (cf) {
      CFRetain(cf);
    }
    sub_100083DA4(&v23, (const void **)((char *)a1 + v16 + 8));
    char v20 = v19(&v24, &v23);
    sub_1000558F4(&v23);
    sub_1000558F4(&v24);
    v16 -= 8;
    if ((v20 & 1) == 0)
    {
      char v21 = (const void **)((char *)a1 + v16 + 24);
      goto LABEL_15;
    }
  }
  char v21 = a1;
LABEL_15:
  if (v21 != &cf)
  {
    CFTypeRef v30 = *v21;
    *char v21 = cf;
    CFTypeRef cf = 0;
    sub_1000558F4(&v30);
  }
  if (++v13 != 8)
  {
    sub_1000558F4(&cf);
    goto LABEL_19;
  }
  BOOL v6 = v11 + 1 == a2;
  sub_1000558F4(&cf);
  return v6;
}

void sub_10049BD3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  BOOL v7 = va_arg(va1, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

const void **sub_10049BDA4(const void **a1, const void **a2, const void **a3, const void **a4, uint64_t (**a5)(const void **, const void **))
{
  sub_10049B898(a1, a2, a3, a5);
  int v10 = *a5;
  sub_100083DA4(&v19, a4);
  sub_100083DA4(&v18, a3);
  LODWORD(v10) = v10(&v19, &v18);
  sub_1000558F4(&v18);
  uint64_t result = sub_1000558F4(&v19);
  if (v10)
  {
    sub_10049B818(a3, a4);
    uint64_t v12 = *a5;
    sub_100083DA4(&v17, a3);
    sub_100083DA4(&v16, a2);
    LODWORD(v12) = v12(&v17, &v16);
    sub_1000558F4(&v16);
    uint64_t result = sub_1000558F4(&v17);
    if (v12)
    {
      sub_10049B818(a2, a3);
      int v13 = *a5;
      sub_100083DA4(&v15, a2);
      sub_100083DA4(&v14, a1);
      LODWORD(v13) = v13(&v15, &v14);
      sub_1000558F4(&v14);
      uint64_t result = sub_1000558F4(&v15);
      if (v13) {
        return sub_10049B818(a1, a2);
      }
    }
  }
  return result;
}

void sub_10049BED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

const void **sub_10049BF18(const void **a1, const void **a2, const void **a3, const void **a4, const void **a5, uint64_t (**a6)(const void **, const void **))
{
  sub_10049BDA4(a1, a2, a3, a4, a6);
  uint64_t v12 = *a6;
  sub_100083DA4(&v24, a5);
  sub_100083DA4(&v23, a4);
  LODWORD(v12) = v12(&v24, &v23);
  sub_1000558F4(&v23);
  uint64_t result = sub_1000558F4(&v24);
  if (v12)
  {
    sub_10049B818(a4, a5);
    uint64_t v14 = *a6;
    sub_100083DA4(&v22, a4);
    sub_100083DA4(&v21, a3);
    LODWORD(v14) = v14(&v22, &v21);
    sub_1000558F4(&v21);
    uint64_t result = sub_1000558F4(&v22);
    if (v14)
    {
      sub_10049B818(a3, a4);
      int v15 = *a6;
      sub_100083DA4(&v20, a3);
      sub_100083DA4(&v19, a2);
      LODWORD(v15) = v15(&v20, &v19);
      sub_1000558F4(&v19);
      uint64_t result = sub_1000558F4(&v20);
      if (v15)
      {
        sub_10049B818(a2, a3);
        uint64_t v16 = *a6;
        sub_100083DA4(&v18, a2);
        sub_100083DA4(&v17, a1);
        LODWORD(v16) = v16(&v18, &v17);
        sub_1000558F4(&v17);
        uint64_t result = sub_1000558F4(&v18);
        if (v16) {
          return sub_10049B818(a1, a2);
        }
      }
    }
  }
  return result;
}

void sub_10049C0A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_10049C0F4()
{
  return 0;
}

uint64_t sub_10049C0FC()
{
  return 0;
}

uint64_t sub_10049C104()
{
  return 0;
}

uint64_t sub_10049C10C()
{
  return 0;
}

BOOL sub_10049C114(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  if (!v2) {
    return 0;
  }
  if (*(void *)(a1 + 32)) {
    char v5 = sub_100136254;
  }
  else {
    char v5 = 0;
  }
  if (!v5)
  {
    __TUAssertTrigger();
    uint64_t v2 = *(void *)(a2 + 56);
  }
  BOOL v6 = *(const void **)(v2 + 64);
  if (v6) {
    BOOL v7 = sub_100136254;
  }
  else {
    BOOL v7 = 0;
  }
  if (!v7)
  {
    __TUAssertTrigger();
    BOOL v6 = *(const void **)(*(void *)(a2 + 56) + 64);
  }
  if (!CFEqual(v6, *(CFTypeRef *)(a1 + 32))) {
    return 1;
  }
  uint64_t v8 = *(void *)(a2 + 56);
  unsigned int v9 = *(unsigned __int16 *)(v8 + 160);
  BOOL result = 1;
  if (v9 >= 0x100 && *(unsigned __int8 *)(a1 + 40) == v9)
  {
    int v11 = *(_WORD *)(v8 + 160);
    unsigned int v12 = *(unsigned __int16 *)(v8 + 194);
    return v12 > 0xFF && v11 == v12;
  }
  return result;
}

BOOL sub_10049C1F8(uint64_t a1, uint64_t a2)
{
  return sub_10049C114(a1 - 16, a2);
}

uint64_t sub_10049C200()
{
  return 0;
}

uint64_t sub_10049C208()
{
  return 0;
}

uint64_t sub_10049C210(uint64_t a1, os_log_t *a2)
{
  uint64_t v3 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
  {
    char v5 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v6 = 136315138;
    BOOL v7 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Compression is not supported for this message", (uint8_t *)&v6, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_10049C2C4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_10049C2CC(uint64_t a1, os_log_t *a2)
{
  return sub_10049C210(a1 - 16, a2);
}

BOOL sub_10049C2D4(uint64_t a1, void *a2)
{
  return sub_10049C2DC(a2);
}

BOOL sub_10049C2DC(void *a1)
{
  if (!a1[7]) {
    return 0;
  }
  uint64_t v2 = a1[11];
  if (!v2) {
    goto LABEL_5;
  }
  if (*(unsigned char *)(v2 + 184))
  {
    uint64_t v2 = 0;
LABEL_5:
    uint64_t v3 = 0;
    goto LABEL_6;
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[12];
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
LABEL_6:
  uint64_t v4 = a1[9];
  if (v4)
  {
    if (v2)
    {
      if (*(unsigned char *)(v4 + 77) && !*(unsigned char *)(v4 + 78)) {
        goto LABEL_13;
      }
    }
    else if (*(unsigned char *)(v4 + 77))
    {
      BOOL v5 = *(unsigned __int8 *)(v4 + 78) == 0;
      goto LABEL_19;
    }
  }
  else if (v2)
  {
LABEL_13:
    BOOL v5 = *(unsigned char *)(v2 + 123) != 0;
    goto LABEL_19;
  }
  BOOL v5 = 0;
LABEL_19:
  if (v3) {
    sub_10004D2C8(v3);
  }
  return v5;
}

BOOL sub_10049C394(uint64_t a1, void *a2)
{
  return sub_10049C2DC(a2);
}

uint64_t sub_10049C39C()
{
  return 0;
}

uint64_t sub_10049C3A4()
{
  return 0;
}

void sub_10049C3AC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", buf, 0xCu);
  }
  if (sub_10049C2DC((void *)a2))
  {
    uint64_t v8 = *(void *)(a2 + 88);
    if (v8)
    {
      if (*(unsigned char *)(v8 + 184))
      {
        uint64_t v8 = 0;
      }
      else
      {
        uint64_t v48 = *(void *)(a2 + 96);
        if (v48)
        {
          group_session v62 = *(std::__shared_weak_count **)(a2 + 96);
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v48 + 8), 1uLL, memory_order_relaxed);
LABEL_8:
          *(_OWORD *)CFArrayRef v74 = 0u;
          long long v75 = 0u;
          sub_10024060C((uint64_t)v74, 0xC8uLL);
          sub_10024081C((unint64_t *)v74, *(unsigned __int8 *)(a1 + 24), 2uLL);
          sub_10024081C((unint64_t *)v74, *(unsigned __int8 *)(a1 + 25), 6uLL);
          unsigned int v9 = *(NSObject **)a2;
          if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v10 = *(char *)(a1 + 24);
            if (v10 > 4) {
              int v11 = "???";
            }
            else {
              int v11 = off_1019D3CB8[v10];
            }
            int v13 = sub_10093AA7C(*(unsigned __int8 *)(a1 + 25));
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = v11;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v13;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Serialized header: Version: %s, MessageType: %s", buf, 0x16u);
          }
          uint64_t v14 = *(void *)(a2 + 72);
          if (v14)
          {
            sub_1004FC1C0(v14, buf);
            int v15 = *(unsigned __int8 **)buf;
            uint64_t v16 = *(unsigned __int8 **)&buf[8];
          }
          else
          {
            uint64_t v16 = 0;
            int v15 = 0;
          }
          sub_10024081C((unint64_t *)v74, v15 != v16, 1uLL);
          sub_10024081C((unint64_t *)v74, *(void *)(a2 + 72) != 0, 1uLL);
          __n128 __p = 0;
          uint64_t v72 = 0;
          uint64_t v73 = 0;
          if (v8)
          {
            sub_1006BEB94(v8, (uint64_t *)buf);
            uint64_t v17 = *(void **)&buf[8];
            if (!*(void *)&buf[8]) {
              goto LABEL_25;
            }
            uint64_t v18 = *(void **)&buf[8];
            do
            {
              uint64_t v19 = v18;
              uint64_t v18 = (void *)*v18;
            }
            while (v18);
            if (v19 == &buf[8] || v19[25]) {
LABEL_25:
            }
              uint64_t v19 = &buf[8];
            BOOL v63 = v19 != &buf[8];
            if (!*(void *)&buf[8]) {
              goto LABEL_35;
            }
            char v20 = (uint64_t *)&buf[8];
            uint64_t v21 = *(void *)&buf[8];
            do
            {
              uint64_t v22 = (uint64_t *)v21;
              int v23 = v20;
              int v24 = *(unsigned __int8 *)(v21 + 25);
              char v25 = (uint64_t *)(v21 + 8);
              if (v24)
              {
                char v25 = v22;
                char v20 = v22;
              }
              uint64_t v21 = *v25;
            }
            while (v21);
            if (v20 == (uint64_t *)&buf[8]) {
              goto LABEL_35;
            }
            if (!v24) {
              uint64_t v22 = v23;
            }
            if (*((unsigned __int8 *)v22 + 25) >= 2u) {
LABEL_35:
            }
              char v20 = (uint64_t *)&buf[8];
            BOOL v66 = v20 != (uint64_t *)&buf[8];
            if (v19 == &buf[8] && v20 == (uint64_t *)&buf[8])
            {
              unint64_t v68 = v15;
              CFArrayRef v26 = 0;
              char v27 = 0;
              CFIndex v28 = 0;
              long long v29 = 0;
              unsigned int v65 = 2;
            }
            else
            {
              int v33 = *(unsigned __int8 **)(v8 + 80);
              unsigned int v65 = *v33;
              if (v65 == 2
                || !*((void *)v33 + 3)
                || *((void *)v33 + 4) == *((void *)v33 + 5)
                || !*((void *)v33 + 7))
              {
                long long v34 = *(NSObject **)a2;
                if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
                {
                  CFTypeID v61 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                  LODWORD(v95) = 136315138;
                  *(void *)((char *)&v95 + 4) = v61;
                  _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "[%s] Invalid SatSms configuration", (uint8_t *)&v95, 0xCu);
                  uint64_t v17 = *(void **)&buf[8];
                }
                *(unsigned char *)a3 = 0;
                *(unsigned char *)(a3 + 24) = 0;
                sub_1000346F8((uint64_t)buf, v17);
                if (__p)
                {
                  uint64_t v72 = (unsigned __int8 *)__p;
                  operator delete(__p);
                }
                if (v15) {
                  operator delete(v15);
                }
                if (v74[0])
                {
                  v74[1] = v74[0];
                  operator delete(v74[0]);
                }
                goto LABEL_123;
              }
              unint64_t v68 = v15;
              if (v19 == &buf[8])
              {
                CFIndex v28 = 0;
                int64_t v70 = 0;
              }
              else
              {
                sub_1006C0550((void *)v8, 0, &v95);
                CFIndex v28 = (unsigned __int8 *)*((void *)&v95 + 1);
                int64_t v70 = (unsigned __int8 *)v95;
              }
              if (v20 == (uint64_t *)&buf[8])
              {
                CFArrayRef v26 = 0;
                char v27 = 0;
                long long v29 = v70;
              }
              else
              {
                long long v29 = v70;
                sub_1006C0550((void *)v8, 1u, &v95);
                CFArrayRef v26 = (unsigned __int8 *)*((void *)&v95 + 1);
                char v27 = (unsigned __int8 *)v95;
              }
              sub_1006C062C(v8);
              if (&__p != (void **)(v33 + 32)) {
                sub_10006E4A8(&__p, *((char **)v33 + 4), *((char **)v33 + 5), *((void *)v33 + 5) - *((void *)v33 + 4));
              }
            }
            sub_1000346F8((uint64_t)buf, *(void **)&buf[8]);
            int v30 = v63;
          }
          else
          {
            unint64_t v68 = v15;
            CFArrayRef v26 = 0;
            char v27 = 0;
            CFIndex v28 = 0;
            long long v29 = 0;
            BOOL v66 = 0;
            int v30 = 0;
            unsigned int v65 = 2;
          }
          int v64 = v30;
          std::string::size_type v69 = v29;
          sub_10024081C((unint64_t *)v74, v30, 1uLL);
          sub_10024081C((unint64_t *)v74, v66, 1uLL);
          sub_10024081C((unint64_t *)v74, v65 == 1, 1uLL);
          sub_10024081C((unint64_t *)v74, v29 != v28, 1uLL);
          sub_10024081C((unint64_t *)v74, v27 != v26, 1uLL);
          sub_10024081C((unint64_t *)v74, __p != v72, 1uLL);
          sub_10024081C((unint64_t *)v74, *(unsigned __int8 *)(a1 + 40), 4uLL);
          uint64_t v31 = *(void *)(a2 + 72);
          if (v31) {
            BOOL v32 = *(unsigned __int8 *)(v31 + 76) != 0;
          }
          else {
            BOOL v32 = 0;
          }
          sub_10024081C((unint64_t *)v74, v32, 1uLL);
          sub_10024081C((unint64_t *)v74, 0, 3uLL);
          if (v68 != v16)
          {
            uint64_t v35 = v68;
            do
              sub_10024081C((unint64_t *)v74, *v35++, 8uLL);
            while (v35 != v16);
          }
          char v36 = (unsigned __int8 *)__p;
          CFDictionaryRef v37 = v72;
          while (v36 != v37)
            sub_10024081C((unint64_t *)v74, *v36++, 8uLL);
          if (v69 != v28)
          {
            CFTypeID v38 = v69;
            do
              sub_10024081C((unint64_t *)v74, *v38++, 8uLL);
            while (v38 != v28);
          }
          if (v27 != v26)
          {
            char v39 = v27;
            do
              sub_10024081C((unint64_t *)v74, *v39++, 8uLL);
            while (v39 != v26);
          }
          uint64_t v40 = *(void *)(a2 + 72);
          if (v40)
          {
            char v41 = *(unint64_t ***)(v40 + 80);
            if (v41)
            {
              CFStringRef v42 = *v41;
              os_log_t v43 = v41[1];
              while (v42 != v43)
                sub_1003CA8B4((NSObject **)(*(void *)(a2 + 56) + 72), *v42++);
            }
            uint64_t v44 = *(void *)(a2 + 56);
            if (*(void *)(v44 + 88) - *(void *)(v44 + 80) >= 0x80uLL)
            {
              __TUAssertTrigger();
              uint64_t v44 = *(void *)(a2 + 56);
            }
            *(void *)std::string buf = off_1019D35F8;
            *(void *)&uint8_t buf[8] = v74;
            *(void *)std::string::size_type v78 = buf;
            sub_1003CABCC(v44 + 72, (uint64_t)buf);
            sub_1004A54DC(buf);
          }
          __int16 v45 = *(NSObject **)a2;
          if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
          {
            CFDictionaryRef v46 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            sub_100BC8FAC((CFUUIDRef *)(a1 + 32), &v95);
            if (v65 > 2) {
              char v47 = "???";
            }
            else {
              char v47 = off_1019D3CA0[(char)v65];
            }
            int v49 = *(unsigned __int8 *)(a1 + 40);
            CFTypeID v50 = (long long *)v95;
            if (v96 >= 0) {
              CFTypeID v50 = &v95;
            }
            if (v66) {
              char v51 = "yes";
            }
            else {
              char v51 = "no";
            }
            if (v64) {
              CFDictionaryRef v52 = "yes";
            }
            else {
              CFDictionaryRef v52 = "no";
            }
            if (*(void *)(a2 + 72)) {
              CFDictionaryRef v53 = "yes";
            }
            else {
              CFDictionaryRef v53 = "no";
            }
            *(_DWORD *)std::string buf = 136317954;
            if (v68 == v16) {
              CFTypeID v54 = "no";
            }
            else {
              CFTypeID v54 = "yes";
            }
            *(void *)&uint8_t buf[4] = v46;
            if (v69 == v28) {
              long long v55 = "no";
            }
            else {
              long long v55 = "yes";
            }
            *(_WORD *)&unsigned char buf[12] = 2082;
            if (v27 == v26) {
              uint64_t v56 = "no";
            }
            else {
              uint64_t v56 = "yes";
            }
            *(void *)&buf[14] = v50;
            __int16 v77 = 1024;
            if (__p == v72) {
              uint64_t v57 = "no";
            }
            else {
              uint64_t v57 = "yes";
            }
            *(_DWORD *)std::string::size_type v78 = v49;
            if (v32) {
              BOOL v58 = "yes";
            }
            else {
              BOOL v58 = "no";
            }
            *(_WORD *)&v78[4] = 2080;
            *(void *)&v78[6] = v54;
            __int16 v79 = 2080;
            uint64_t v80 = v53;
            __int16 v81 = 2080;
            CFDictionaryRef v82 = v52;
            __int16 v83 = 2080;
            CFTypeRef v84 = v51;
            __int16 v85 = 2080;
            CFArrayRef v86 = v47;
            __int16 v87 = 2080;
            uint64_t v88 = v55;
            __int16 v89 = 2080;
            CFTypeRef v90 = v56;
            __int16 v91 = 2080;
            uint64_t v92 = v57;
            __int16 v93 = 2080;
            CFRange v94 = v58;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I [%s] LLC ID: %{public}s, Token:%hhu, HasOffGridModeKey: %s, iMessageLite enabled: %s, SatSmsForSimConfig0Enabled: %s, SatSmsForSimConfig1Enabled: %s, satSmsSPSBucketId: %s, HasSatSmsResyncSimConfig0: %s, HasSatSmsResyncSimConfig1: %s, HasSmsEscrowKey: %s, areAllPrimaryContactsReachableViaIML: %s", buf, 0x76u);
            if (v96 < 0) {
              operator delete((void *)v95);
            }
          }
          long long v67 = *(_OWORD *)v74;
          v74[0] = 0;
          v74[1] = 0;
          uint64_t v59 = v75;
          *(void *)&long long v75 = 0;
          if (__p)
          {
            uint64_t v72 = (unsigned __int8 *)__p;
            operator delete(__p);
          }
          if (v27) {
            operator delete(v27);
          }
          if (v69) {
            operator delete(v69);
          }
          if (v68) {
            operator delete(v68);
          }
          if (v74[0])
          {
            v74[1] = v74[0];
            operator delete(v74[0]);
          }
          *(_OWORD *)a3 = v67;
          *(void *)(a3 + 16) = v59;
          *(unsigned char *)(a3 + 24) = 1;
LABEL_123:
          if (v62) {
            sub_10004D2C8(v62);
          }
          return;
        }
      }
    }
    group_session v62 = 0;
    goto LABEL_8;
  }
  unsigned int v12 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
  {
    unsigned int v60 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v60;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "[%s] Environment not ready", buf, 0xCu);
  }
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 24) = 0;
}

void sub_10049CC90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,void *a26)
{
  if (__p) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  if (a16) {
    operator delete(a16);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(a1);
}

void sub_10049CD88(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_10049CD90()
{
  return 0;
}

uint64_t sub_10049CD98()
{
  return 0;
}

void sub_10049CDA0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 56);
  if (v4)
  {
    if (sub_1003CAF24(v4, (const void **)(a1 + 32), *(unsigned __int8 *)(a1 + 40)))
    {
      uint64_t v5 = *(void *)(a2 + 72);
      if (v5) {
        sub_1004FB86C(v5, (const void **)(a1 + 32), *(unsigned char *)(a1 + 40));
      }
      uint64_t v6 = *(void *)(a2 + 88);
      if (v6 && !*(unsigned char *)(v6 + 184))
      {
        BOOL v7 = *(std::__shared_weak_count **)(a2 + 96);
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1006BED34(v6, (const void **)(a1 + 32), *(unsigned char *)(a1 + 40));
        if (v7)
        {
          sub_10004D2C8(v7);
        }
      }
    }
  }
  else
  {
    uint64_t v8 = *(NSObject **)a2;
    if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
    {
      unsigned int v9 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      int v10 = 136315138;
      int v11 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "[%s] LLC environment doesn't exist", (uint8_t *)&v10, 0xCu);
    }
  }
}

void sub_10049CEF8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10049CF10(uint64_t a1, uint64_t a2)
{
}

void sub_10049CF18(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 56);
  if (v4)
  {
    if (sub_1003CB048(v4, (const void **)(a1 + 32), *(unsigned __int8 *)(a1 + 40)))
    {
      uint64_t v5 = *(void *)(a2 + 72);
      if (v5)
      {
        uint64_t v6 = *(uint64_t ***)(v5 + 80);
        if (v6)
        {
          BOOL v7 = *v6;
          uint64_t v8 = v6[1];
          if (*v6 != v8)
          {
            do
            {
              uint64_t v9 = *v7++;
              sub_1003CAA78(*(void *)(a2 + 56) + 72, v9);
            }
            while (v7 != v8);
            uint64_t v5 = *(void *)(a2 + 72);
          }
        }
        sub_1004FBAE4(v5, (const void **)(a1 + 32), *(unsigned char *)(a1 + 40));
      }
      uint64_t v10 = *(void *)(a2 + 88);
      if (v10 && !*(unsigned char *)(v10 + 184))
      {
        int v11 = *(std::__shared_weak_count **)(a2 + 96);
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1006BEFAC(v10, (const void **)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
        if (v11)
        {
          sub_10004D2C8(v11);
        }
      }
    }
  }
  else
  {
    unsigned int v12 = *(NSObject **)a2;
    if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
    {
      int v13 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      int v14 = 136315138;
      int v15 = v13;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "[%s] LLC environment doesn't exist", (uint8_t *)&v14, 0xCu);
    }
  }
}

void sub_10049D0AC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10049D0C4(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_10049D0CC()
{
  return 0;
}

uint64_t sub_10049D0D4()
{
  return 0;
}

uint64_t sub_10049D0DC(uint64_t a1, uint64_t a2, os_log_t *a3)
{
  uint64_t v4 = *a3;
  if (os_log_type_enabled(*a3, OS_LOG_TYPE_ERROR))
  {
    uint64_t v6 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v7 = 136315138;
    uint64_t v8 = v6;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Decompression is NOT required for this message. message.", (uint8_t *)&v7, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_10049D190(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_10049D198(uint64_t a1, uint64_t a2, os_log_t *a3)
{
  return sub_10049D0DC(a1 - 16, a2, a3);
}

BOOL sub_10049D1A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding", buf, 0xCu);
  }
  if (*(void *)(a2 + 56))
  {
    *(unsigned char *)(a1 + 26) = 0;
    unint64_t v8 = 4;
    while (1)
    {
      unint64_t v9 = *(void *)(a3 + 32);
      unint64_t v10 = *(void *)(a3 + 40);
      if (!v10)
      {
        *(void *)(a3 + 32) = ++v9;
        *(void *)(a3 + 40) = 8;
        unint64_t v10 = 8;
      }
      uint64_t v11 = *(void *)a3;
      if (v9 >= *(void *)(a3 + 8) - *(void *)a3) {
        break;
      }
      unint64_t v12 = v8 - v10;
      if (v8 <= v10)
      {
        int v14 = 0;
        *(void *)(a3 + 40) = v10 - v8;
        if (v8 < 8) {
          char v15 = ~(-1 << v8);
        }
        else {
          char v15 = -1;
        }
        *(unsigned char *)(a1 + 26) |= (*(unsigned __int8 *)(v11 + v9) >> (v10 - v8)) & v15;
        uint64_t v16 = *(void *)a3;
        unint64_t v17 = *(void *)(a3 + 8) - *(void *)a3;
        unint64_t v18 = *(void *)(a3 + 32);
        unint64_t v19 = *(void *)(a3 + 40);
        unint64_t v20 = 2;
        if (v19) {
          goto LABEL_16;
        }
        while (1)
        {
          *(void *)(a3 + 32) = ++v18;
          *(void *)(a3 + 40) = 8;
          unint64_t v19 = 8;
LABEL_16:
          if (v18 >= v17) {
            break;
          }
          BOOL v21 = v19 >= v20;
          unint64_t v22 = v19 - v20;
          if (v21)
          {
            int v24 = 0;
            *(void *)(a3 + 40) = v22;
            unsigned int v25 = v14 | (*(unsigned __int8 *)(v16 + v18) >> v22) & ~(-1 << v20);
            if ((v25 & 0xFC) != 0) {
              char v26 = 0;
            }
            else {
              char v26 = v25;
            }
            *(unsigned char *)(a1 + 56) = 0x504050100uLL >> (8 * v26);
            unint64_t v27 = 2;
            if (v22) {
              goto LABEL_24;
            }
            while (1)
            {
              *(void *)(a3 + 32) = ++v18;
              *(void *)(a3 + 40) = 8;
              unint64_t v22 = 8;
LABEL_24:
              if (v18 >= v17) {
                break;
              }
              BOOL v21 = v22 >= v27;
              unint64_t v28 = v22 - v27;
              if (v21)
              {
                long long v125 = (os_log_t *)a2;
                *(void *)(a3 + 40) = v28;
                unsigned int v30 = v24 | (*(unsigned __int8 *)(v16 + v18) >> v28) & ~(-1 << v27);
                if ((v30 & 0xFC) != 0) {
                  char v31 = 0;
                }
                else {
                  char v31 = v30;
                }
                *(_WORD *)(a1 + 28) = 0;
                *(unsigned char *)(a1 + 57) = 0x504050100uLL >> (8 * v31);
                if (sub_10036C2D8((uint64_t *)a3, (_WORD *)(a1 + 28), 0xDuLL))
                {
                  *(unsigned char *)(a1 + 30) = 0;
                  unint64_t v32 = 7;
                  while (1)
                  {
                    unint64_t v33 = *(void *)(a3 + 32);
                    unint64_t v34 = *(void *)(a3 + 40);
                    if (!v34)
                    {
                      *(void *)(a3 + 32) = ++v33;
                      *(void *)(a3 + 40) = 8;
                      unint64_t v34 = 8;
                    }
                    uint64_t v35 = *(void *)a3;
                    if (v33 >= *(void *)(a3 + 8) - *(void *)a3) {
                      break;
                    }
                    unint64_t v36 = v32 - v34;
                    if (v32 <= v34)
                    {
                      *(void *)(a3 + 40) = v34 - v32;
                      int v42 = *(unsigned __int8 *)(v35 + v33) >> (v34 - v32);
                      if (v32 < 8) {
                        char v43 = ~(-1 << v32);
                      }
                      else {
                        char v43 = -1;
                      }
                      *(unsigned char *)(a1 + 30) |= v42 & v43;
                      *(unsigned char *)(a1 + 31) = 0;
                      unint64_t v44 = 7;
                      while (1)
                      {
                        unint64_t v45 = *(void *)(a3 + 32);
                        unint64_t v46 = *(void *)(a3 + 40);
                        if (!v46)
                        {
                          *(void *)(a3 + 32) = ++v45;
                          *(void *)(a3 + 40) = 8;
                          unint64_t v46 = 8;
                        }
                        uint64_t v47 = *(void *)a3;
                        if (v45 >= *(void *)(a3 + 8) - *(void *)a3) {
                          break;
                        }
                        unint64_t v48 = v44 - v46;
                        if (v44 <= v46)
                        {
                          *(void *)(a3 + 40) = v46 - v44;
                          if (v44 < 8) {
                            char v50 = ~(-1 << v44);
                          }
                          else {
                            char v50 = -1;
                          }
                          *(unsigned char *)(a1 + 31) |= (*(unsigned __int8 *)(v47 + v45) >> (v46 - v44)) & v50;
                          unint64_t v51 = *(void *)(a3 + 8) - *(void *)a3;
                          unint64_t v52 = *(void *)(a3 + 32);
                          unint64_t v53 = *(void *)(a3 + 40);
                          unint64_t v54 = 5;
                          while (1)
                          {
                            if (!v53)
                            {
                              *(void *)(a3 + 32) = ++v52;
                              *(void *)(a3 + 40) = 8;
                              unint64_t v53 = 8;
                            }
                            if (v52 >= v51)
                            {
                              *(unsigned char *)(a3 + 24) = 1;
                              CFTypeID v38 = *(NSObject **)a2;
                              BOOL result = os_log_type_enabled(*v125, OS_LOG_TYPE_ERROR);
                              if (!result) {
                                return result;
                              }
                              v118 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                              *(_DWORD *)std::string buf = 136315138;
                              *(void *)&uint8_t buf[4] = v118;
                              char v41 = "[%s] Failed to skip reserved bits";
                              goto LABEL_40;
                            }
                            unint64_t v55 = v54 - v53;
                            if (v54 <= v53) {
                              break;
                            }
                            unint64_t v53 = 0;
                            *(void *)(a3 + 40) = 0;
                            unint64_t v54 = v55;
                            if (v55 - 9 < 0xFFFFFFFFFFFFFFF8) {
                              __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
                            }
                          }
                          *(void *)(a3 + 40) = v53 - v54;
                          uint64_t v56 = *(void **)(a1 + 32);
                          for (uint64_t i = *(void **)(a1 + 40); i != v56; sub_100274EC0(i))
                            i -= 7;
                          *(void *)(a1 + 40) = v56;
                          if (v26 == 1)
                          {
                            memset(buf, 0, sizeof(buf));
                            if (sub_1004A50DC((uint64_t *)a3, (uint64_t *)&buf[8])
                              && sub_1004A50DC((uint64_t *)a3, (uint64_t *)&buf[32]))
                            {
                              sub_10049E054((void **)(a1 + 32), (char *)buf);
                              sub_10049E260(buf);
                              goto LABEL_68;
                            }
                            BOOL v63 = *v125;
                            if (os_log_type_enabled(*v125, OS_LOG_TYPE_ERROR))
                            {
                              int v64 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                              *(_DWORD *)int v129 = 136315138;
                              uint64_t v130 = v64;
                              unsigned int v65 = "[%s] Failed to read challengeForSimConfig0";
                              goto LABEL_153;
                            }
                            goto LABEL_85;
                          }
LABEL_68:
                          if (v31 == 1)
                          {
                            *(void *)std::string buf = 1;
                            memset(&buf[8], 0, 48);
                            if (!sub_1004A50DC((uint64_t *)a3, (uint64_t *)&buf[8])
                              || !sub_1004A50DC((uint64_t *)a3, (uint64_t *)&buf[32]))
                            {
                              BOOL v63 = *v125;
                              if (os_log_type_enabled(*v125, OS_LOG_TYPE_ERROR))
                              {
                                int64_t v119 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                                *(_DWORD *)int v129 = 136315138;
                                uint64_t v130 = v119;
                                unsigned int v65 = "[%s] Failed to read challengeForSimConfig1";
LABEL_153:
                                _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, v65, v129, 0xCu);
                              }
LABEL_85:
                              sub_10049E260(buf);
                              return 0;
                            }
                            sub_10049E054((void **)(a1 + 32), (char *)buf);
                            sub_10049E260(buf);
                          }
                          if (*(unsigned char *)(a3 + 24))
                          {
                            __TUAssertTrigger();
                            if (*(unsigned char *)(a3 + 24)) {
                              sub_10016C840();
                            }
                          }
                          uint64_t v59 = *(void *)(a3 + 32);
                          uint64_t v58 = *(void *)(a3 + 40);
                          if (v58) {
                            uint64_t v60 = 0;
                          }
                          else {
                            uint64_t v60 = -1;
                          }
                          if ((v58 | 8) != 8) {
                            __TUAssertTrigger();
                          }
                          unint64_t v61 = v60 + *(void *)(a3 + 8) - (v59 + *(void *)a3);
                          if ((v61 & 7) != 0)
                          {
                            CFTypeID v38 = *v125;
                            BOOL result = os_log_type_enabled(*v125, OS_LOG_TYPE_ERROR);
                            if (!result) {
                              return result;
                            }
                            group_session v62 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                            *(_DWORD *)std::string buf = 136315138;
                            *(void *)&uint8_t buf[4] = v62;
                            char v41 = "[%s] Malformed iMessageLite counts";
                          }
                          else
                          {
                            *(void *)(a1 + 72) = *(void *)(a1 + 64);
                            if (v61 < 8)
                            {
LABEL_131:
                              long long v102 = *v125;
                              if (os_log_type_enabled(*v125, OS_LOG_TYPE_DEFAULT))
                              {
                                CFDictionaryRef v103 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                                unint64_t v104 = *(char *)(a1 + 56);
                                if (v104 > 5) {
                                  char v105 = "???";
                                }
                                else {
                                  char v105 = off_1019D3C70[v104];
                                }
                                int v109 = *(unsigned __int8 *)(a1 + 26);
                                int v110 = *(unsigned __int16 *)(a1 + 28);
                                int v111 = *(unsigned __int8 *)(a1 + 30);
                                int v112 = *(unsigned __int8 *)(a1 + 31);
                                uint64_t v113 = 0x6DB6DB6DB6DB6DB7
                                     * ((uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 3);
                                unint64_t v114 = *(char *)(a1 + 57);
                                if (v114 > 5) {
                                  CFArrayRef v115 = "???";
                                }
                                else {
                                  CFArrayRef v115 = off_1019D3C70[v114];
                                }
                                *(_DWORD *)std::string buf = 136316930;
                                *(void *)&uint8_t buf[4] = v103;
                                *(_WORD *)&unsigned char buf[12] = 1024;
                                *(_DWORD *)&buf[14] = v109;
                                *(_WORD *)&buf[18] = 1024;
                                *(_DWORD *)&buf[20] = v110;
                                *(_WORD *)&uint8_t buf[24] = 1024;
                                *(_DWORD *)&buf[26] = v111;
                                *(_WORD *)&buf[30] = 1024;
                                *(_DWORD *)&unsigned char buf[32] = v112;
                                *(_WORD *)&buf[36] = 2048;
                                *(void *)&buf[38] = v113;
                                *(_WORD *)&buf[46] = 2080;
                                *(void *)&buf[48] = v105;
                                __int16 v127 = 2080;
                                uint64_t v128 = v115;
                                _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "#I [%s] Token: %hhu, SequenceNumber: %hu, PendingIMessageLiteCount: %hu, PendingSatSmsCount: %hu, SatSmsChallenges count: %zu, fAuthStatusForSimConfig0: %s, fAuthStatusForSimConfig1: %s", buf, 0x42u);
                              }
                              return 1;
                            }
                            int v66 = 0;
                            unint64_t v123 = v61 >> 3;
                            while (2)
                            {
                              int v67 = 0;
                              uint64_t v68 = *(void *)a3;
                              unint64_t v69 = *(void *)(a3 + 8) - *(void *)a3;
                              unint64_t v70 = *(void *)(a3 + 32);
                              unint64_t v71 = *(void *)(a3 + 40);
                              unint64_t v72 = 8;
                              while (1)
                              {
                                if (!v71)
                                {
                                  *(void *)(a3 + 32) = ++v70;
                                  *(void *)(a3 + 40) = 8;
                                  unint64_t v71 = 8;
                                }
                                if (v70 >= v69)
                                {
                                  *(unsigned char *)(a3 + 24) = 1;
                                  goto LABEL_155;
                                }
                                unint64_t v73 = v72 - v71;
                                if (v72 <= v71) {
                                  break;
                                }
                                unsigned int v74 = *(unsigned __int8 *)(v68 + v70) & ~(-1 << v71);
                                *(void *)(a3 + 40) = 0;
                                v67 |= v74 << v73;
                                unint64_t v72 = v73;
                                unint64_t v71 = 0;
                                if (v73 - 9 < 0xFFFFFFFFFFFFFFF8) {
                                  __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
                                }
                              }
                              int v124 = v66;
                              char v75 = v71 - v72;
                              *(void *)(a3 + 40) = v71 - v72;
                              unsigned int v76 = *(unsigned __int8 *)(v68 + v70);
                              *(_WORD *)std::string buf = 0;
                              if (sub_10036C2D8((uint64_t *)a3, buf, 0x10uLL))
                              {
                                char v77 = v72 < 8 ? ~(-1 << v72) : -1;
                                uint64_t v78 = *(unsigned __int16 *)buf;
                                *(_WORD *)std::string buf = 0;
                                if (sub_10036C2D8((uint64_t *)a3, buf, 0x10uLL))
                                {
                                  *(_WORD *)int v129 = 0;
                                  if (sub_10036C2D8((uint64_t *)a3, v129, 0x10uLL))
                                  {
                                    int v79 = 0;
                                    unint64_t v80 = *(unsigned __int16 *)v129 | ((unint64_t)*(unsigned __int16 *)buf << 16) | ((unint64_t)(v67 | (v76 >> v75) & v77) << 48) | (v78 << 32);
                                    uint64_t v81 = *(void *)a3;
                                    unint64_t v82 = *(void *)(a3 + 8) - *(void *)a3;
                                    unint64_t v83 = *(void *)(a3 + 32);
                                    unint64_t v84 = *(void *)(a3 + 40);
                                    unint64_t v85 = 8;
                                    while (1)
                                    {
                                      if (!v84)
                                      {
                                        *(void *)(a3 + 32) = ++v83;
                                        *(void *)(a3 + 40) = 8;
                                        unint64_t v84 = 8;
                                      }
                                      if (v83 >= v82)
                                      {
                                        *(unsigned char *)(a3 + 24) = 1;
                                        CFTypeID v38 = *v125;
                                        BOOL result = os_log_type_enabled(*v125, OS_LOG_TYPE_ERROR);
                                        if (!result) {
                                          return result;
                                        }
                                        uint64_t v121 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                                        *(_DWORD *)std::string buf = 136315138;
                                        *(void *)&uint8_t buf[4] = v121;
                                        char v41 = "[%s] Failed to read count from iMessageLite counts";
                                        goto LABEL_40;
                                      }
                                      unint64_t v86 = v85 - v84;
                                      if (v85 <= v84) {
                                        break;
                                      }
                                      unsigned int v87 = *(unsigned __int8 *)(v81 + v83) & ~(-1 << v84);
                                      *(void *)(a3 + 40) = 0;
                                      v79 |= v87 << v86;
                                      unint64_t v85 = v86;
                                      unint64_t v84 = 0;
                                      if (v86 - 9 < 0xFFFFFFFFFFFFFFF8) {
                                        __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
                                      }
                                    }
                                    *(void *)(a3 + 40) = v84 - v85;
                                    int v88 = *(unsigned __int8 *)(v81 + v83) >> (v84 - v85);
                                    if (v85 < 8) {
                                      char v89 = ~(-1 << v85);
                                    }
                                    else {
                                      char v89 = -1;
                                    }
                                    char v90 = v79 | v88 & v89;
                                    uint64_t v92 = *(unsigned char **)(a1 + 72);
                                    unint64_t v91 = *(void *)(a1 + 80);
                                    if ((unint64_t)v92 >= v91)
                                    {
                                      CFRange v94 = *(unsigned char **)(a1 + 64);
                                      uint64_t v95 = (v92 - v94) >> 4;
                                      unint64_t v96 = v95 + 1;
                                      if ((unint64_t)(v95 + 1) >> 60) {
                                        sub_10006A748();
                                      }
                                      uint64_t v97 = v91 - (void)v94;
                                      if (v97 >> 3 > v96) {
                                        unint64_t v96 = v97 >> 3;
                                      }
                                      if ((unint64_t)v97 >= 0x7FFFFFFFFFFFFFF0) {
                                        unint64_t v98 = 0xFFFFFFFFFFFFFFFLL;
                                      }
                                      else {
                                        unint64_t v98 = v96;
                                      }
                                      if (v98)
                                      {
                                        if (v98 >> 60) {
                                          sub_10006A7CC();
                                        }
                                        unint64_t v99 = (char *)operator new(16 * v98);
                                      }
                                      else
                                      {
                                        unint64_t v99 = 0;
                                      }
                                      unint64_t v100 = &v99[16 * v95];
                                      *(void *)unint64_t v100 = v80;
                                      v100[8] = v90;
                                      uint64_t v101 = v100;
                                      if (v92 != v94)
                                      {
                                        do
                                        {
                                          *((_OWORD *)v101 - 1) = *((_OWORD *)v92 - 1);
                                          v101 -= 16;
                                          v92 -= 16;
                                        }
                                        while (v92 != v94);
                                        uint64_t v92 = *(unsigned char **)(a1 + 64);
                                      }
                                      __int16 v93 = v100 + 16;
                                      *(void *)(a1 + 64) = v101;
                                      *(void *)(a1 + 72) = v100 + 16;
                                      *(void *)(a1 + 80) = &v99[16 * v98];
                                      if (v92) {
                                        operator delete(v92);
                                      }
                                    }
                                    else
                                    {
                                      *(void *)uint64_t v92 = v80;
                                      v92[8] = v90;
                                      __int16 v93 = v92 + 16;
                                    }
                                    *(void *)(a1 + 72) = v93;
                                    int v66 = v124 + 1;
                                    if (v123 > (v124 + 1)) {
                                      continue;
                                    }
                                    goto LABEL_131;
                                  }
                                }
                              }
                              break;
                            }
LABEL_155:
                            CFTypeID v38 = *v125;
                            BOOL result = os_log_type_enabled(*v125, OS_LOG_TYPE_ERROR);
                            if (!result) {
                              return result;
                            }
                            long long v120 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                            *(_DWORD *)std::string buf = 136315138;
                            *(void *)&uint8_t buf[4] = v120;
                            char v41 = "[%s] Failed to read shortHandle from iMessageLite counts";
                          }
                          goto LABEL_40;
                        }
                        unsigned int v49 = *(unsigned __int8 *)(v47 + v45) & ~(-1 << v46);
                        *(void *)(a3 + 40) = 0;
                        *(unsigned char *)(a1 + 31) |= v49 << v48;
                        unint64_t v44 = v48;
                        if (v48 - 9 < 0xFFFFFFFFFFFFFFF8) {
                          __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
                        }
                      }
                      *(unsigned char *)(a3 + 24) = 1;
                      CFTypeID v38 = *(NSObject **)a2;
                      BOOL result = os_log_type_enabled(*v125, OS_LOG_TYPE_ERROR);
                      if (!result) {
                        return result;
                      }
                      std::string::size_type v117 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                      *(_DWORD *)std::string buf = 136315138;
                      *(void *)&uint8_t buf[4] = v117;
                      char v41 = "[%s] Failed to read pending SatSms count";
                      goto LABEL_40;
                    }
                    unsigned int v37 = *(unsigned __int8 *)(v35 + v33) & ~(-1 << v34);
                    *(void *)(a3 + 40) = 0;
                    *(unsigned char *)(a1 + 30) |= v37 << v36;
                    unint64_t v32 = v36;
                    if (v36 - 9 < 0xFFFFFFFFFFFFFFF8) {
                      __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
                    }
                  }
                  *(unsigned char *)(a3 + 24) = 1;
                  CFTypeID v38 = *(NSObject **)a2;
                  BOOL result = os_log_type_enabled(*v125, OS_LOG_TYPE_ERROR);
                  if (!result) {
                    return result;
                  }
                  CFTypeRef v116 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                  *(_DWORD *)std::string buf = 136315138;
                  *(void *)&uint8_t buf[4] = v116;
                  char v41 = "[%s] Failed to read pending iMessageLite count";
                }
                else
                {
                  CFTypeID v38 = *(NSObject **)a2;
                  BOOL result = os_log_type_enabled(*v125, OS_LOG_TYPE_ERROR);
                  if (!result) {
                    return result;
                  }
                  uint64_t v40 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                  *(_DWORD *)std::string buf = 136315138;
                  *(void *)&uint8_t buf[4] = v40;
                  char v41 = "[%s] Failed to read sequence number";
                }
                goto LABEL_40;
              }
              char v29 = *(unsigned char *)(v16 + v18);
              *(void *)(a3 + 40) = 0;
              v24 |= 2 * (v29 & 1);
              unint64_t v27 = 1;
            }
            *(unsigned char *)(a3 + 24) = 1;
            CFTypeID v38 = *(NSObject **)a2;
            BOOL result = os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            char v108 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = v108;
            char v41 = "[%s] Failed to read auth status for SIM config 1";
            goto LABEL_40;
          }
          char v23 = *(unsigned char *)(v16 + v18);
          *(void *)(a3 + 40) = 0;
          v14 |= 2 * (v23 & 1);
          unint64_t v20 = 1;
        }
        *(unsigned char *)(a3 + 24) = 1;
        CFTypeID v38 = *(NSObject **)a2;
        BOOL result = os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        CFTypeRef v107 = sub_10093AA58(*(_DWORD *)(a1 + 12));
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v107;
        char v41 = "[%s] Failed to read auth status for SIM config 0";
        goto LABEL_40;
      }
      unsigned int v13 = *(unsigned __int8 *)(v11 + v9) & ~(-1 << v10);
      *(void *)(a3 + 40) = 0;
      *(unsigned char *)(a1 + 26) |= v13 << v12;
      unint64_t v8 = v12;
      if (v12 - 9 < 0xFFFFFFFFFFFFFFF8) {
        __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
      }
    }
    *(unsigned char *)(a3 + 24) = 1;
    CFTypeID v38 = *(NSObject **)a2;
    BOOL result = os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int64_t v106 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v106;
    char v41 = "[%s] Failed to read token";
  }
  else
  {
    CFTypeID v38 = *(NSObject **)a2;
    BOOL result = os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    CFStringRef v122 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v122;
    char v41 = "[%s] LLC environment doesn't exist";
  }
LABEL_40:
  _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, v41, buf, 0xCu);
  return 0;
}

void sub_10049DF54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10049E260((uint64_t *)va);
  _Unwind_Resume(a1);
}

BOOL sub_10049DF74(uint64_t *a1, unsigned char *a2, unint64_t a3)
{
  while (1)
  {
    unint64_t v3 = a1[4];
    unint64_t v4 = a1[5];
    if (!v4)
    {
      a1[4] = ++v3;
      a1[5] = 8;
      unint64_t v4 = 8;
    }
    uint64_t v5 = *a1;
    unint64_t v6 = a1[1] - *a1;
    if (v3 >= v6)
    {
      *((unsigned char *)a1 + 24) = 1;
      return v3 < v6;
    }
    unint64_t v7 = a3 - v4;
    if (a3 <= v4) {
      break;
    }
    unsigned int v8 = *(unsigned __int8 *)(v5 + v3) & ~(-1 << v4);
    a1[5] = 0;
    *a2 |= v8 << v7;
    a3 -= v4;
    if (v7 - 9 < 0xFFFFFFFFFFFFFFF8) {
      __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
    }
  }
  a1[5] = v4 - a3;
  if (a3 < 8) {
    char v9 = ~(-1 << a3);
  }
  else {
    char v9 = -1;
  }
  *a2 |= (*(unsigned __int8 *)(v5 + v3) >> (v4 - a3)) & v9;
  return v3 < v6;
}

void sub_10049E054(void **a1, char *a2)
{
  unint64_t v4 = (char *)a1[1];
  uint64_t v5 = (char *)a1[2];
  if (v4 >= v5)
  {
    uint64_t v7 = 0x6DB6DB6DB6DB6DB7 * ((v4 - (unsigned char *)*a1) >> 3);
    unint64_t v8 = v7 + 1;
    if ((unint64_t)(v7 + 1) > 0x492492492492492) {
      sub_10006A748();
    }
    unint64_t v9 = 0x6DB6DB6DB6DB6DB7 * ((v5 - (unsigned char *)*a1) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x249249249249249) {
      unint64_t v10 = 0x492492492492492;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10 > 0x492492492492492) {
      sub_10006A7CC();
    }
    uint64_t v11 = (char *)operator new(56 * v10);
    unint64_t v12 = &v11[56 * v7];
    *unint64_t v12 = *a2;
    *(_OWORD *)(v12 + 8) = *(_OWORD *)(a2 + 8);
    *((void *)v12 + 3) = *((void *)a2 + 3);
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *((_OWORD *)v12 + 2) = *((_OWORD *)a2 + 2);
    *((void *)v12 + 6) = *((void *)a2 + 6);
    *((void *)a2 + 3) = 0;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 6) = 0;
    unsigned int v13 = (char *)*a1;
    int v14 = (char *)a1[1];
    if (v14 == *a1)
    {
      unint64_t v6 = v12 + 56;
      *a1 = v12;
      a1[1] = v12 + 56;
      a1[2] = &v11[56 * v10];
    }
    else
    {
      uint64_t v15 = 0;
      do
      {
        uint64_t v16 = &v12[v15];
        unint64_t v17 = &v14[v15];
        *(v16 - 56) = v14[v15 - 56];
        *((_OWORD *)v16 - 3) = *(_OWORD *)&v14[v15 - 48];
        *((void *)v16 - 4) = *(void *)&v14[v15 - 32];
        *((void *)v17 - 6) = 0;
        *((void *)v17 - 5) = 0;
        *((void *)v17 - 4) = 0;
        *(_OWORD *)(v16 - 24) = *(_OWORD *)&v14[v15 - 24];
        *((void *)v16 - 1) = *(void *)&v14[v15 - 8];
        *((void *)v17 - 3) = 0;
        *((void *)v17 - 2) = 0;
        *((void *)v17 - 1) = 0;
        v15 -= 56;
      }
      while (&v14[v15] != v13);
      int v14 = (char *)*a1;
      unint64_t v18 = (char *)a1[1];
      unint64_t v6 = v12 + 56;
      *a1 = &v12[v15];
      a1[1] = v12 + 56;
      a1[2] = &v11[56 * v10];
      while (v18 != v14)
      {
        v18 -= 56;
        sub_100274EC0(v18);
      }
    }
    if (v14) {
      operator delete(v14);
    }
  }
  else
  {
    char *v4 = *a2;
    *((void *)v4 + 2) = 0;
    *((void *)v4 + 3) = 0;
    *((void *)v4 + 1) = 0;
    *(_OWORD *)(v4 + 8) = *(_OWORD *)(a2 + 8);
    *((void *)v4 + 3) = *((void *)a2 + 3);
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    *((void *)v4 + 4) = 0;
    *((void *)v4 + 5) = 0;
    *((void *)v4 + 6) = 0;
    *((_OWORD *)v4 + 2) = *((_OWORD *)a2 + 2);
    *((void *)v4 + 6) = *((void *)a2 + 6);
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 6) = 0;
    unint64_t v6 = v4 + 56;
  }
  a1[1] = v6;
}

void *sub_10049E260(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t sub_10049E2A4(uint64_t *a1, void *a2, unint64_t a3)
{
  if (a3 <= 0x20)
  {
    if (a3 <= 0x10)
    {
      unsigned __int16 v9 = 0;
      uint64_t result = sub_10036C2D8(a1, &v9, a3);
      if (!result) {
        return result;
      }
      unint64_t v6 = v9;
      goto LABEL_17;
    }
    unsigned __int16 v9 = 0;
    if (sub_10036C2D8(a1, &v9, a3 - 16))
    {
      unsigned __int16 v8 = 0;
      uint64_t result = sub_10036C2D8(a1, &v8, 0x10uLL);
      if (!result) {
        return result;
      }
      unint64_t v6 = v8 | ((unint64_t)v9 << 16);
      goto LABEL_17;
    }
    return 0;
  }
  if (a3 - 32 > 0x10)
  {
    unsigned __int16 v9 = 0;
    if ((sub_10036C2D8(a1, &v9, a3 - 48) & 1) == 0) {
      return 0;
    }
    unsigned __int16 v8 = 0;
    uint64_t result = sub_10036C2D8(a1, &v8, 0x10uLL);
    if (!result) {
      return result;
    }
    unint64_t v7 = v8 | ((unint64_t)v9 << 16);
  }
  else
  {
    unsigned __int16 v9 = 0;
    uint64_t result = sub_10036C2D8(a1, &v9, a3 - 32);
    if (!result) {
      return result;
    }
    unint64_t v7 = v9;
  }
  unsigned __int16 v9 = 0;
  if ((sub_10036C2D8(a1, &v9, 0x10uLL) & 1) == 0) {
    return 0;
  }
  unsigned __int16 v8 = 0;
  if ((sub_10036C2D8(a1, &v8, 0x10uLL) & 1) == 0) {
    return 0;
  }
  unint64_t v6 = v8 | ((unint64_t)v9 << 16) | (v7 << 32);
LABEL_17:
  *a2 |= v6;
  return 1;
}

BOOL sub_10049E400(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_10049D1A0(a1 - 16, a2, a3);
}

uint64_t sub_10049E408()
{
  return 1;
}

uint64_t sub_10049E410()
{
  return 1;
}

uint64_t sub_10049E418()
{
  return 0;
}

uint64_t sub_10049E420()
{
  return 0;
}

uint64_t sub_10049E428()
{
  return 0;
}

uint64_t sub_10049E430()
{
  return 0;
}

uint64_t sub_10049E438()
{
  return 0;
}

uint64_t sub_10049E440()
{
  return 0;
}

uint64_t sub_10049E448(uint64_t a1, os_log_t *a2)
{
  unint64_t v3 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
  {
    uint64_t v5 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v6 = 136315138;
    unint64_t v7 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Compression is not supported for this message", (uint8_t *)&v6, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_10049E4FC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_10049E504(uint64_t a1, os_log_t *a2)
{
  return sub_10049E448(a1 - 16, a2);
}

BOOL sub_10049E50C(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 56)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a2 + 72);
  if (!v3 || !*(unsigned char *)(v3 + 77) || !*(unsigned char *)(v3 + 75)) {
    return 0;
  }
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 96);
  v7[0] = *(void *)(a1 + 88);
  v7[1] = (uint64_t)v4;
  if (!v4) {
    return sub_1004FC244(v3, v7);
  }
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  BOOL v5 = sub_1004FC244(v3, v7);
  sub_10004D2C8(v4);
  return v5;
}

BOOL sub_10049E59C(uint64_t a1, uint64_t a2)
{
  return sub_10049E50C(a1 - 16, a2);
}

uint64_t sub_10049E5A4()
{
  return 1;
}

uint64_t sub_10049E5AC()
{
  return 1;
}

void sub_10049E5B4(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v58 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", buf, 0xCu);
  }
  if (!*(void *)(a2 + 56))
  {
    uint64_t v47 = *(NSObject **)a2;
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      goto LABEL_72;
    }
    unint64_t v48 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v58 = v48;
    unsigned int v49 = "[%s] LLC environment doesn't exist";
LABEL_71:
    _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, v49, buf, 0xCu);
    goto LABEL_72;
  }
  uint64_t v8 = *(void *)(a2 + 72);
  if (!v8)
  {
    uint64_t v47 = *(NSObject **)a2;
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      goto LABEL_72;
    }
    char v50 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v58 = v50;
    unsigned int v49 = "[%s] iMessageLite environment doesn't exist";
    goto LABEL_71;
  }
  if (!*(unsigned char *)(v8 + 77))
  {
    uint64_t v47 = *(NSObject **)a2;
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      goto LABEL_72;
    }
    unint64_t v51 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v58 = v51;
    unsigned int v49 = "[%s] iMessageLite environment is not ready";
    goto LABEL_71;
  }
  if (!*(unsigned char *)(v8 + 75))
  {
    uint64_t v47 = *(NSObject **)a2;
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      unint64_t v52 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v58 = v52;
      unsigned int v49 = "[%s] CarrierPigeonStartMessage hasn't been acked yet";
      goto LABEL_71;
    }
LABEL_72:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
    return;
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v56 = 0u;
  sub_10024060C((uint64_t)__p, 0xC8uLL);
  sub_10024081C((unint64_t *)__p, *(unsigned __int8 *)(a1 + 24), 2uLL);
  sub_10024081C((unint64_t *)__p, *(unsigned __int8 *)(a1 + 25), 6uLL);
  unsigned __int16 v9 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v10 = *(char *)(a1 + 24);
    if (v10 > 4) {
      uint64_t v11 = "???";
    }
    else {
      uint64_t v11 = off_1019D3CB8[v10];
    }
    unint64_t v12 = sub_10093AA7C(*(unsigned __int8 *)(a1 + 25));
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v58 = v11;
    __int16 v59 = 2080;
    uint64_t v60 = v12;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Serialized header: Version: %s, MessageType: %s", buf, 0x16u);
  }
  sub_10024081C((unint64_t *)__p, 0, 4uLL);
  unsigned int v13 = *(const char **)(a1 + 48);
  unsigned __int8 v14 = (_BYTE)v13 - 1;
  if (((_BYTE)v13 - 1) >= 4u)
  {
    unint64_t v20 = *(NSObject **)a2;
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    BOOL v21 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v58 = v21;
    __int16 v59 = 2048;
    uint64_t v60 = v13;
    unint64_t v22 = "[%s] Invalid ParNumber %zu";
LABEL_32:
    unint64_t v28 = v20;
    uint32_t v29 = 22;
LABEL_33:
    _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, v22, buf, v29);
    goto LABEL_46;
  }
  uint64_t v15 = *(const char **)(a1 + 56);
  if (v15 - 1 >= 4)
  {
    unint64_t v20 = *(NSObject **)a2;
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    char v23 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v58 = v23;
    __int16 v59 = 2048;
    uint64_t v60 = v15;
    unint64_t v22 = "[%s] Invalid TotalParts %zu";
    goto LABEL_32;
  }
  sub_10024081C((unint64_t *)__p, v14, 2uLL);
  sub_10024081C((unint64_t *)__p, (*(unsigned char *)(a1 + 56) - 1), 2uLL);
  uint64_t v16 = *(const char **)(a1 + 32);
  if ((unint64_t)v16 >> 56)
  {
    unint64_t v20 = *(NSObject **)a2;
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    int v24 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v58 = v24;
    __int16 v59 = 2048;
    uint64_t v60 = v16;
    unint64_t v22 = "[%s] Invalid myShortHandle %llu";
    goto LABEL_32;
  }
  uint64_t v17 = sub_1003CA8B4((NSObject **)(*(void *)(a2 + 56) + 72), *(void *)(a1 + 32));
  unsigned __int8 v18 = v17;
  if ((v17 & 0xFF0000) != 0)
  {
    if ((v17 & 0xFF00) != 0)
    {
      LOBYTE(v16) = 0;
      unint64_t v25 = 0;
      int v19 = 1;
      goto LABEL_27;
    }
    int v19 = 0;
  }
  else
  {
    int v19 = 0;
    unsigned __int8 v18 = 0;
  }
  unint64_t v25 = (unint64_t)v16 & 0xFFFFFFFFFFFFFF00;
LABEL_27:
  char v26 = *(const char **)(a1 + 40);
  if ((unint64_t)v26 >> 56)
  {
    unint64_t v20 = *(NSObject **)a2;
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    unint64_t v27 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v58 = v27;
    __int16 v59 = 2048;
    uint64_t v60 = v26;
    unint64_t v22 = "[%s] Invalid otherShortHandle %llu";
    goto LABEL_32;
  }
  int v53 = sub_1003CA8B4((NSObject **)(*(void *)(a2 + 56) + 104), *(void *)(a1 + 40));
  if ((v53 & 0xFF0000) == 0)
  {
    LOBYTE(v53) = 0;
LABEL_36:
    int v31 = 0;
    unint64_t v30 = (unint64_t)v26 & 0xFFFFFFFFFFFFFF00;
    goto LABEL_37;
  }
  if ((v53 & 0xFF00) == 0) {
    goto LABEL_36;
  }
  LOBYTE(v26) = 0;
  unint64_t v30 = 0;
  int v31 = 1;
LABEL_37:
  sub_10024081C((unint64_t *)__p, v19, 1uLL);
  sub_10024081C((unint64_t *)__p, v18, 3uLL);
  sub_10024081C((unint64_t *)__p, v31, 1uLL);
  sub_10024081C((unint64_t *)__p, v53, 3uLL);
  if ((v19 & 1) == 0)
  {
    sub_10024081C((unint64_t *)__p, BYTE6(v25), 8uLL);
    sub_10024081C((unint64_t *)__p, BYTE5(v25), 8uLL);
    sub_10024081C((unint64_t *)__p, BYTE4(v25), 8uLL);
    sub_10024081C((unint64_t *)__p, BYTE3(v25), 8uLL);
    sub_10024081C((unint64_t *)__p, BYTE2(v25), 8uLL);
    sub_10024081C((unint64_t *)__p, BYTE1(v25), 8uLL);
    sub_10024081C((unint64_t *)__p, v16, 8uLL);
  }
  if ((v31 & 1) == 0)
  {
    sub_10024081C((unint64_t *)__p, BYTE6(v30), 8uLL);
    sub_10024081C((unint64_t *)__p, BYTE5(v30), 8uLL);
    sub_10024081C((unint64_t *)__p, BYTE4(v30), 8uLL);
    sub_10024081C((unint64_t *)__p, BYTE3(v30), 8uLL);
    sub_10024081C((unint64_t *)__p, BYTE2(v30), 8uLL);
    sub_10024081C((unint64_t *)__p, BYTE1(v30), 8uLL);
    sub_10024081C((unint64_t *)__p, v26, 8uLL);
  }
  unint64_t v32 = *(unsigned __int8 **)(a1 + 64);
  unint64_t v33 = *(unsigned __int8 **)(a1 + 72);
  if (v32 == v33)
  {
    unint64_t v34 = *(NSObject **)a2;
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    unint64_t v46 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v58 = v46;
    unint64_t v22 = "[%s] Payload is missing";
    goto LABEL_62;
  }
  if ((unint64_t)(v33 - v32) < 0x94)
  {
    if (*((void *)&v56 + 1))
    {
      __TUAssertTrigger();
      unint64_t v32 = *(unsigned __int8 **)(a1 + 64);
      unint64_t v33 = *(unsigned __int8 **)(a1 + 72);
    }
    for (; v32 != v33; ++v32)
      sub_10024081C((unint64_t *)__p, *v32, 8uLL);
    char v39 = *(NSObject **)a2;
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v40 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      char v41 = *(const char **)(a1 + 32);
      uint64_t v42 = *(void *)(a1 + 40);
      uint64_t v43 = *(void *)(a1 + 48);
      uint64_t v44 = *(void *)(a1 + 56);
      uint64_t v45 = *(void *)(a1 + 72) - *(void *)(a1 + 64);
      *(_DWORD *)std::string buf = 136316930;
      uint64_t v58 = v40;
      __int16 v59 = 2048;
      uint64_t v60 = v41;
      __int16 v61 = 1024;
      int v62 = v18;
      __int16 v63 = 2048;
      uint64_t v64 = v42;
      __int16 v65 = 1024;
      int v66 = v53;
      __int16 v67 = 2048;
      uint64_t v68 = v43;
      __int16 v69 = 2048;
      uint64_t v70 = v44;
      __int16 v71 = 2048;
      uint64_t v72 = v45;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I [%s] MyShortHandle: %llu [Index: %hhu], OtherShortHandle: %llu [Index: %hhu], PartNumber: %zu, TotalParts: %zu, Payload size: %zu", buf, 0x4Au);
    }
    long long v38 = *(_OWORD *)__p;
    uint64_t v36 = v56;
    char v37 = 1;
    __p[0] = 0;
    *(void *)&long long v56 = 0;
    goto LABEL_47;
  }
  unint64_t v34 = *(NSObject **)a2;
  if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
  {
    uint64_t v35 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v58 = v35;
    unint64_t v22 = "[%s] Payload is too big";
LABEL_62:
    unint64_t v28 = v34;
    uint32_t v29 = 12;
    goto LABEL_33;
  }
LABEL_46:
  uint64_t v36 = 0;
  char v37 = 0;
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 24) = 0;
  long long v38 = 0uLL;
LABEL_47:
  if (__p[0])
  {
    __p[1] = __p[0];
    long long v54 = v38;
    operator delete(__p[0]);
    long long v38 = v54;
  }
  if (v37)
  {
    *(_OWORD *)a3 = v38;
    *(void *)(a3 + 16) = v36;
    *(unsigned char *)(a3 + 24) = 1;
  }
  else if ((void)v38)
  {
    operator delete((void *)v38);
  }
}

void sub_10049EDE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10049EE10(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_10049EE18()
{
  return 0;
}

uint64_t sub_10049EE20()
{
  return 0;
}

void sub_10049EE30(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  if (v2)
  {
    sub_1003CAA78(v2 + 72, *(void *)(a1 + 32));
    uint64_t v5 = *(void *)(a2 + 56) + 104;
    uint64_t v6 = *(void *)(a1 + 40);
    sub_1003CAA78(v5, v6);
  }
}

void sub_10049EE90(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_10049EE98()
{
  return 0;
}

uint64_t sub_10049EEA0()
{
  return 0;
}

uint64_t sub_10049EEA8(uint64_t a1, uint64_t a2, os_log_t *a3)
{
  unint64_t v4 = *a3;
  if (os_log_type_enabled(*a3, OS_LOG_TYPE_ERROR))
  {
    uint64_t v6 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v7 = 136315138;
    uint64_t v8 = v6;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Decompression is NOT required for this message. message.", (uint8_t *)&v7, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_10049EF5C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_10049EF64(uint64_t a1, uint64_t a2, os_log_t *a3)
{
  return sub_10049EEA8(a1 - 16, a2, a3);
}

BOOL sub_10049EF6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding", buf, 0xCu);
  }
  if (*(void *)(a2 + 56) && (uint64_t v8 = *(void *)(a2 + 72)) != 0 && *(unsigned char *)(v8 + 77))
  {
    uint64_t v9 = *(void *)a3;
    unint64_t v10 = *(void *)(a3 + 8) - *(void *)a3;
    unint64_t v11 = *(void *)(a3 + 32);
    unint64_t v12 = *(void *)(a3 + 40);
    unint64_t v13 = 4;
    while (1)
    {
      if (!v12)
      {
        *(void *)(a3 + 32) = ++v11;
        *(void *)(a3 + 40) = 8;
        unint64_t v12 = 8;
      }
      if (v11 >= v10) {
        break;
      }
      unint64_t v14 = v13 - v12;
      if (v13 <= v12)
      {
        char v15 = 0;
        unint64_t v16 = v12 - v13;
        *(void *)(a3 + 40) = v16;
        unint64_t v17 = 2;
        if (v16) {
          goto LABEL_15;
        }
        while (1)
        {
          *(void *)(a3 + 32) = ++v11;
          *(void *)(a3 + 40) = 8;
          unint64_t v16 = 8;
LABEL_15:
          if (v11 >= v10)
          {
            *(unsigned char *)(a3 + 24) = 1;
            uint64_t v78 = *(NSObject **)a2;
            BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            int v112 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = v112;
            unint64_t v86 = "[%s] Failed to read part number";
            goto LABEL_133;
          }
          unint64_t v18 = v16 - v17;
          if (v16 >= v17) {
            break;
          }
          char v19 = *(unsigned char *)(v9 + v11);
          *(void *)(a3 + 40) = 0;
          v15 |= 2 * (v19 & 1);
          unint64_t v17 = 1;
        }
        int v20 = 0;
        *(void *)(a3 + 40) = v18;
        *(void *)(a1 + 64) = (v15 | (*(unsigned __int8 *)(v9 + v11) >> v18) & ~(-1 << v17))
                             + 1;
        unint64_t v21 = 2;
        while (1)
        {
          if (!v18)
          {
            *(void *)(a3 + 32) = ++v11;
            *(void *)(a3 + 40) = 8;
            unint64_t v18 = 8;
          }
          if (v11 >= v10)
          {
            *(unsigned char *)(a3 + 24) = 1;
            uint64_t v78 = *(NSObject **)a2;
            BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            uint64_t v113 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = v113;
            unint64_t v86 = "[%s] Failed to total parts";
            goto LABEL_133;
          }
          unint64_t v22 = v21 - v18;
          if (v21 <= v18) {
            break;
          }
          unsigned int v23 = *(unsigned __int8 *)(v9 + v11) & ~(-1 << v18);
          *(void *)(a3 + 40) = 0;
          v20 |= v23 << v22;
          unint64_t v21 = v22;
          unint64_t v18 = 0;
          if (v22 - 9 < 0xFFFFFFFFFFFFFFF8) {
            __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
          }
        }
        *(void *)(a3 + 40) = v18 - v21;
        int v24 = *(unsigned __int8 *)(v9 + v11) >> (v18 - v21);
        if (v21 < 8) {
          char v25 = ~(-1 << v21);
        }
        else {
          char v25 = -1;
        }
        *(void *)(a1 + 72) = (v20 | v24 & v25) + 1;
        *(void *)(a1 + 32) = 0;
        *(_WORD *)std::string buf = 0;
        if ((sub_10036C2D8((uint64_t *)a3, buf, 0x10uLL) & 1) == 0
          || (unsigned __int16 v124 = 0, !sub_10036C2D8((uint64_t *)a3, &v124, 0x10uLL))
          || (uint64_t v26 = *(unsigned __int16 *)buf,
              uint64_t v27 = v124,
              *(_WORD *)std::string buf = 0,
              (sub_10036C2D8((uint64_t *)a3, buf, 0x10uLL) & 1) == 0)
          || (unsigned __int16 v124 = 0, (sub_10036C2D8((uint64_t *)a3, &v124, 0x10uLL) & 1) == 0))
        {
          uint64_t v78 = *(NSObject **)a2;
          BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
          if (!result) {
            return result;
          }
          long long v120 = sub_10093AA58(*(_DWORD *)(a1 + 12));
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v120;
          unint64_t v86 = "[%s] Failed to read timestamp";
          goto LABEL_133;
        }
        *(void *)(a1 + 32) |= (v26 << 48) | (v27 << 32) | v124 | ((unint64_t)*(unsigned __int16 *)buf << 16);
        unint64_t v28 = *(void *)(a3 + 8) - *(void *)a3;
        unint64_t v30 = *(void *)(a3 + 32);
        uint64_t v29 = *(void *)(a3 + 40);
        if (!v29)
        {
          uint64_t v29 = 8;
          *(void *)(a3 + 32) = ++v30;
          *(void *)(a3 + 40) = 8;
        }
        if (v30 < v28)
        {
          unint64_t v31 = v29 - 1;
          *(void *)(a3 + 40) = v29 - 1;
          *(unsigned char *)(a1 + 40) = 0;
          for (unint64_t i = 7; ; unint64_t i = v35)
          {
            unint64_t v33 = *(void *)(a3 + 32);
            if (!v31)
            {
              *(void *)(a3 + 32) = ++v33;
              *(void *)(a3 + 40) = 8;
              unint64_t v31 = 8;
            }
            uint64_t v34 = *(void *)a3;
            if (v33 >= *(void *)(a3 + 8) - *(void *)a3) {
              break;
            }
            unint64_t v35 = i - v31;
            if (i <= v31)
            {
              *(void *)(a3 + 40) = v31 - i;
              if (i < 8) {
                char v37 = ~(-1 << i);
              }
              else {
                char v37 = -1;
              }
              *(unsigned char *)(a1 + 40) |= (*(unsigned __int8 *)(v34 + v33) >> (v31 - i)) & v37;
              unint64_t v38 = *(void *)(a3 + 8) - *(void *)a3;
              unint64_t v39 = *(void *)(a3 + 32);
              unint64_t v40 = *(void *)(a3 + 40);
              unint64_t v41 = 1;
              while (1)
              {
                if (!v40)
                {
                  *(void *)(a3 + 32) = ++v39;
                  *(void *)(a3 + 40) = 8;
                  unint64_t v40 = 8;
                }
                if (v39 >= v38) {
                  break;
                }
                unint64_t v42 = v41 - v40;
                if (v41 <= v40)
                {
                  unint64_t v43 = v40 - v41;
                  *(void *)(a3 + 40) = v43;
                  *(unsigned char *)(a1 + 41) = 0;
                  for (unint64_t j = 7; ; unint64_t j = v47)
                  {
                    unint64_t v45 = *(void *)(a3 + 32);
                    if (!v43)
                    {
                      *(void *)(a3 + 32) = ++v45;
                      *(void *)(a3 + 40) = 8;
                      unint64_t v43 = 8;
                    }
                    uint64_t v46 = *(void *)a3;
                    if (v45 >= *(void *)(a3 + 8) - *(void *)a3)
                    {
                      *(unsigned char *)(a3 + 24) = 1;
                      uint64_t v78 = *(NSObject **)a2;
                      BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
                      if (!result) {
                        return result;
                      }
                      CFTypeRef v116 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                      *(_DWORD *)std::string buf = 136315138;
                      *(void *)&uint8_t buf[4] = v116;
                      unint64_t v86 = "[%s] Failed to read pending count";
                      goto LABEL_133;
                    }
                    unint64_t v47 = j - v43;
                    if (j <= v43) {
                      break;
                    }
                    unsigned int v48 = *(unsigned __int8 *)(v46 + v45) & ~(-1 << v43);
                    *(void *)(a3 + 40) = 0;
                    *(unsigned char *)(a1 + 41) |= v48 << v47;
                    if (v47 - 9 < 0xFFFFFFFFFFFFFFF8) {
                      __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
                    }
                    unint64_t v43 = *(void *)(a3 + 40);
                  }
                  *(void *)(a3 + 40) = v43 - j;
                  if (j < 8) {
                    char v49 = ~(-1 << j);
                  }
                  else {
                    char v49 = -1;
                  }
                  *(unsigned char *)(a1 + 41) |= (*(unsigned __int8 *)(v46 + v45) >> (v43 - j)) & v49;
                  *(_WORD *)std::string buf = 0;
                  if (sub_10036C2D8((uint64_t *)a3, buf, 0x10uLL))
                  {
                    int v50 = 0;
                    uint64_t v51 = *(void *)a3;
                    unint64_t v52 = *(void *)(a3 + 8) - *(void *)a3;
                    unint64_t v53 = *(void *)(a3 + 32);
                    unint64_t v54 = *(void *)(a3 + 40);
                    unint64_t v55 = 1;
                    while (1)
                    {
                      if (!v54)
                      {
                        *(void *)(a3 + 32) = ++v53;
                        *(void *)(a3 + 40) = 8;
                        unint64_t v54 = 8;
                      }
                      if (v53 >= v52) {
                        break;
                      }
                      unint64_t v56 = v55 - v54;
                      if (v55 <= v54)
                      {
                        int v58 = 0;
                        unint64_t v59 = v54 - v55;
                        *(void *)(a3 + 40) = v59;
                        if (v55 < 8) {
                          unsigned int v60 = ~(-1 << v55);
                        }
                        else {
                          unsigned int v60 = 255;
                        }
                        int v61 = v50 | (*(unsigned __int8 *)(v51 + v53) >> v59) & v60;
                        unint64_t v62 = 3;
                        while (1)
                        {
                          if (!v59)
                          {
                            *(void *)(a3 + 32) = ++v53;
                            *(void *)(a3 + 40) = 8;
                            unint64_t v59 = 8;
                          }
                          if (v53 >= v52) {
                            break;
                          }
                          unint64_t v63 = v62 - v59;
                          if (v62 <= v59)
                          {
                            int v65 = 0;
                            unint64_t v66 = v59 - v62;
                            *(void *)(a3 + 40) = v59 - v62;
                            int v67 = *(unsigned __int8 *)(v51 + v53) >> (v59 - v62);
                            if (v62 < 8) {
                              char v68 = ~(-1 << v62);
                            }
                            else {
                              char v68 = -1;
                            }
                            unsigned __int8 v69 = v58 | v67 & v68;
                            unint64_t v70 = 1;
                            while (1)
                            {
                              if (!v66)
                              {
                                *(void *)(a3 + 32) = ++v53;
                                *(void *)(a3 + 40) = 8;
                                unint64_t v66 = 8;
                              }
                              if (v53 >= v52)
                              {
                                *(unsigned char *)(a3 + 24) = 1;
                                uint64_t v78 = *(NSObject **)a2;
                                BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
                                if (!result) {
                                  return result;
                                }
                                int64_t v119 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                                *(_DWORD *)std::string buf = 136315138;
                                *(void *)&uint8_t buf[4] = v119;
                                unint64_t v86 = "[%s] Failed to read otherShortHandleIndexOnly format bit";
                                goto LABEL_133;
                              }
                              unint64_t v71 = v70 - v66;
                              if (v70 <= v66) {
                                break;
                              }
                              unsigned int v72 = *(unsigned __int8 *)(v51 + v53) & ~(-1 << v66);
                              *(void *)(a3 + 40) = 0;
                              v65 |= (v72 << v71);
                              unint64_t v70 = v71;
                              unint64_t v66 = 0;
                              if (v71 - 9 < 0xFFFFFFFFFFFFFFF8) {
                                __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
                              }
                            }
                            char v73 = v66 - v70;
                            *(void *)(a3 + 40) = v66 - v70;
                            unsigned int v74 = *(unsigned __int8 *)(v51 + v53);
                            if (v70 < 8) {
                              unsigned int v75 = ~(-1 << v70);
                            }
                            else {
                              unsigned int v75 = 255;
                            }
                            LOBYTE(v124) = 0;
                            if (!sub_10049DF74((uint64_t *)a3, &v124, 3uLL))
                            {
                              uint64_t v78 = *(NSObject **)a2;
                              BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
                              if (!result) {
                                return result;
                              }
                              int v110 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                              *(_DWORD *)std::string buf = 136315138;
                              *(void *)&uint8_t buf[4] = v110;
                              unint64_t v86 = "[%s] Failed to read other index";
                              goto LABEL_133;
                            }
                            if (v61)
                            {
                              unint64_t v76 = sub_1003CA86C(*(void *)(a2 + 56) + 72, v69);
                              if (v77)
                              {
                                *(void *)(a1 + 48) = v76;
                                goto LABEL_100;
                              }
                              unint64_t v84 = *(NSObject **)a2;
                              BOOL result = os_log_type_enabled(v84, OS_LOG_TYPE_ERROR);
                              if (!result) {
                                return result;
                              }
                              unint64_t v85 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                              *(_DWORD *)std::string buf = 136315394;
                              *(void *)&uint8_t buf[4] = v85;
                              *(_WORD *)&unsigned char buf[12] = 1024;
                              *(_DWORD *)&buf[14] = v69;
                              unint64_t v86 = "[%s] Invalid myShortHandleIndex %d";
LABEL_118:
                              uint64_t v95 = v84;
                              uint32_t v96 = 18;
                              goto LABEL_134;
                            }
                            *(void *)(a1 + 48) = 0;
                            if ((sub_10049E2A4((uint64_t *)a3, (void *)(a1 + 48), 0x38uLL) & 1) == 0)
                            {
                              uint64_t v78 = *(NSObject **)a2;
                              BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
                              if (!result) {
                                return result;
                              }
                              __int16 v93 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                              *(_DWORD *)std::string buf = 136315138;
                              *(void *)&uint8_t buf[4] = v93;
                              unint64_t v86 = "[%s] Failed to myShortHandle";
                              goto LABEL_133;
                            }
LABEL_100:
                            int v80 = v65 | (v74 >> v73) & v75;
                            if (v80)
                            {
                              int v81 = v124;
                              unint64_t v82 = sub_1003CA86C(*(void *)(a2 + 56) + 104, v124);
                              if (!v83)
                              {
                                unint64_t v84 = *(NSObject **)a2;
                                BOOL result = os_log_type_enabled(v84, OS_LOG_TYPE_ERROR);
                                if (!result) {
                                  return result;
                                }
                                CFRange v94 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                                *(_DWORD *)std::string buf = 136315394;
                                *(void *)&uint8_t buf[4] = v94;
                                *(_WORD *)&unsigned char buf[12] = 1024;
                                *(_DWORD *)&buf[14] = v81;
                                unint64_t v86 = "[%s] Invalid otherShortHandleIndex %d";
                                goto LABEL_118;
                              }
                              *(void *)(a1 + 56) = v82;
                            }
                            else
                            {
                              *(void *)(a1 + 56) = 0;
                              if ((sub_10049E2A4((uint64_t *)a3, (void *)(a1 + 56), 0x38uLL) & 1) == 0)
                              {
                                uint64_t v78 = *(NSObject **)a2;
                                BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
                                if (!result) {
                                  return result;
                                }
                                int v109 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                                *(_DWORD *)std::string buf = 136315138;
                                *(void *)&uint8_t buf[4] = v109;
                                unint64_t v86 = "[%s] Failed to read otherShortHandle";
                                goto LABEL_133;
                              }
                            }
                            if (*(unsigned char *)(a3 + 24))
                            {
                              __TUAssertTrigger();
                              if (*(unsigned char *)(a3 + 24)) {
                                sub_10016C840();
                              }
                            }
                            uint64_t v87 = *(void *)(a3 + 40);
                            if ((v87 | 8) == 8)
                            {
                              BOOL v88 = v87 == 0;
                              uint64_t v89 = *(void *)(a3 + 32);
                              if (v88) {
                                ++v89;
                              }
                              uint64_t v91 = *(void *)a3;
                              uint64_t v90 = *(void *)(a3 + 8);
                              if (v90 - *(void *)a3 != v89)
                              {
                                memset(buf, 0, sizeof(buf));
                                sub_10036CCEC(buf, (const void *)(v91 + v89), v90, v90 - (v91 + v89));
                                unint64_t v98 = *(void **)(a1 + 80);
                                if (v98)
                                {
                                  *(void *)(a1 + 88) = v98;
                                  operator delete(v98);
                                }
                                uint64_t v99 = *(void *)buf;
                                *(void *)(a1 + 80) = *(void *)buf;
                                uint64_t v123 = *(void *)&buf[8];
                                *(_OWORD *)(a1 + 88) = *(_OWORD *)&buf[8];
                                unint64_t v100 = *(NSObject **)a2;
                                if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
                                {
                                  uint64_t v101 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                                  uint64_t v102 = *(void *)(a1 + 32);
                                  int v103 = *(unsigned __int8 *)(a1 + 40);
                                  int v104 = *(unsigned __int8 *)(a1 + 41);
                                  uint64_t v105 = *(void *)(a1 + 48);
                                  uint64_t v106 = *(void *)(a1 + 56);
                                  uint64_t v107 = *(void *)(a1 + 64);
                                  uint64_t v108 = *(void *)(a1 + 72);
                                  *(_DWORD *)std::string buf = 136317186;
                                  *(void *)&uint8_t buf[4] = v101;
                                  *(_WORD *)&unsigned char buf[12] = 2048;
                                  *(void *)&buf[14] = v102;
                                  *(_WORD *)&unsigned char buf[22] = 1024;
                                  int v126 = v103;
                                  __int16 v127 = 1024;
                                  int v128 = v104;
                                  __int16 v129 = 2048;
                                  uint64_t v130 = v105;
                                  __int16 v131 = 2048;
                                  uint64_t v132 = v106;
                                  __int16 v133 = 2048;
                                  uint64_t v134 = v107;
                                  __int16 v135 = 2048;
                                  uint64_t v136 = v108;
                                  __int16 v137 = 2048;
                                  uint64_t v138 = v123 - v99;
                                  _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#I [%s] fTimestamp %llu, PendingTotalCount: %hhu, PendingCount: %hhu, MyShortHandle: %llu, OtherShortHandle: %llu, PartNumber: %zu, TotalParts: %zu, Payload size: %zu", buf, 0x54u);
                                }
                                if (v61) {
                                  sub_1003CAAD4(*(void *)(a2 + 56) + 72, v69);
                                }
                                if (v80) {
                                  sub_1003CAAD4(*(void *)(a2 + 56) + 104, v124);
                                }
                                return 1;
                              }
                              uint64_t v78 = *(NSObject **)a2;
                              BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
                              if (!result) {
                                return result;
                              }
                              uint64_t v92 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                              *(_DWORD *)std::string buf = 136315138;
                              *(void *)&uint8_t buf[4] = v92;
                              unint64_t v86 = "[%s] Payload is empty";
                            }
                            else
                            {
                              uint64_t v78 = *(NSObject **)a2;
                              BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
                              if (!result) {
                                return result;
                              }
                              uint64_t v97 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                              *(_DWORD *)std::string buf = 136315138;
                              *(void *)&uint8_t buf[4] = v97;
                              unint64_t v86 = "[%s] Payload is not byte aligned";
                            }
                            goto LABEL_133;
                          }
                          unsigned int v64 = *(unsigned __int8 *)(v51 + v53) & ~(-1 << v59);
                          *(void *)(a3 + 40) = 0;
                          v58 |= v64 << v63;
                          unint64_t v62 = v63;
                          unint64_t v59 = 0;
                          if (v63 - 9 < 0xFFFFFFFFFFFFFFF8) {
                            __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
                          }
                        }
                        *(unsigned char *)(a3 + 24) = 1;
                        uint64_t v78 = *(NSObject **)a2;
                        BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
                        if (!result) {
                          return result;
                        }
                        v118 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                        *(_DWORD *)std::string buf = 136315138;
                        *(void *)&uint8_t buf[4] = v118;
                        unint64_t v86 = "[%s] Failed to read my index";
                        goto LABEL_133;
                      }
                      unsigned int v57 = *(unsigned __int8 *)(v51 + v53) & ~(-1 << v54);
                      *(void *)(a3 + 40) = 0;
                      v50 |= (v57 << v56);
                      unint64_t v55 = v56;
                      unint64_t v54 = 0;
                      if (v56 - 9 < 0xFFFFFFFFFFFFFFF8) {
                        __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
                      }
                    }
                    *(unsigned char *)(a3 + 24) = 1;
                    uint64_t v78 = *(NSObject **)a2;
                    BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
                    if (!result) {
                      return result;
                    }
                    std::string::size_type v117 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                    *(_DWORD *)std::string buf = 136315138;
                    *(void *)&uint8_t buf[4] = v117;
                    unint64_t v86 = "[%s] Failed to read myShortHandleIndexOnly format bit";
                  }
                  else
                  {
                    uint64_t v78 = *(NSObject **)a2;
                    BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
                    if (!result) {
                      return result;
                    }
                    CFStringRef v122 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                    *(_DWORD *)std::string buf = 136315138;
                    *(void *)&uint8_t buf[4] = v122;
                    unint64_t v86 = "[%s] Failed to skip reserved bits";
                  }
                  goto LABEL_133;
                }
                unint64_t v40 = 0;
                *(void *)(a3 + 40) = 0;
                unint64_t v41 = v42;
                if (v42 - 9 < 0xFFFFFFFFFFFFFFF8) {
                  __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
                }
              }
              *(unsigned char *)(a3 + 24) = 1;
              uint64_t v78 = *(NSObject **)a2;
              BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
              if (!result) {
                return result;
              }
              goto LABEL_144;
            }
            unsigned int v36 = *(unsigned __int8 *)(v34 + v33) & ~(-1 << v31);
            *(void *)(a3 + 40) = 0;
            *(unsigned char *)(a1 + 40) |= v36 << v35;
            if (v35 - 9 < 0xFFFFFFFFFFFFFFF8) {
              __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
            }
            unint64_t v31 = *(void *)(a3 + 40);
          }
          *(unsigned char *)(a3 + 24) = 1;
          uint64_t v78 = *(NSObject **)a2;
          BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
          if (!result) {
            return result;
          }
          unint64_t v114 = sub_10093AA58(*(_DWORD *)(a1 + 12));
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v114;
          unint64_t v86 = "[%s] Failed to read pending total count";
          goto LABEL_133;
        }
        *(unsigned char *)(a3 + 24) = 1;
        uint64_t v78 = *(NSObject **)a2;
        BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
        if (result)
        {
LABEL_144:
          CFArrayRef v115 = sub_10093AA58(*(_DWORD *)(a1 + 12));
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v115;
          unint64_t v86 = "[%s] Failed to skip reserved bit";
          goto LABEL_133;
        }
        return result;
      }
      unint64_t v12 = 0;
      *(void *)(a3 + 40) = 0;
      unint64_t v13 = v14;
      if (v14 - 9 < 0xFFFFFFFFFFFFFFF8) {
        __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
      }
    }
    *(unsigned char *)(a3 + 24) = 1;
    uint64_t v78 = *(NSObject **)a2;
    BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v111 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v111;
    unint64_t v86 = "[%s] Failed to skip reserved bits";
  }
  else
  {
    uint64_t v78 = *(NSObject **)a2;
    BOOL result = os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    uint64_t v121 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v121;
    unint64_t v86 = "[%s] Environment not ready";
  }
LABEL_133:
  uint64_t v95 = v78;
  uint32_t v96 = 12;
LABEL_134:
  _os_log_error_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_ERROR, v86, buf, v96);
  return 0;
}

BOOL sub_10049FE84(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_10049EF6C(a1 - 16, a2, a3);
}

uint64_t sub_10049FE8C()
{
  return 1;
}

uint64_t sub_10049FE94()
{
  return 1;
}

uint64_t sub_10049FE9C()
{
  return 0;
}

uint64_t sub_10049FEA4()
{
  return 0;
}

uint64_t sub_10049FEAC()
{
  return 0;
}

uint64_t sub_10049FEB4()
{
  return 0;
}

uint64_t sub_10049FEBC()
{
  return 0;
}

uint64_t sub_10049FEC4()
{
  return 0;
}

uint64_t sub_10049FECC(uint64_t a1, os_log_t *a2)
{
  uint64_t v3 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
  {
    uint64_t v5 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v6 = 136315138;
    int v7 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Compression is not supported for this message", (uint8_t *)&v6, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_10049FF80(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_10049FF88(uint64_t a1, os_log_t *a2)
{
  return sub_10049FECC(a1 - 16, a2);
}

BOOL sub_10049FF90(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 72);
  return v2 && *(unsigned char *)(v2 + 77) && *(unsigned char *)(v2 + 75) != 0;
}

BOOL sub_10049FFB8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 72);
  return v2 && *(unsigned char *)(v2 + 77) && *(unsigned char *)(v2 + 75) != 0;
}

uint64_t sub_10049FFE0()
{
  return 0;
}

uint64_t sub_10049FFE8()
{
  return 0;
}

void sub_10049FFF0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = (void *)v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", (uint8_t *)__p, 0xCu);
  }
  uint64_t v8 = *(void *)(a2 + 72);
  if (!v8)
  {
    unsigned int v23 = *(NSObject **)a2;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      int v24 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)v24;
      char v25 = "[%s] iMessageLite environment doesn't exist";
LABEL_26:
      uint64_t v27 = v23;
      goto LABEL_30;
    }
LABEL_28:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
    return;
  }
  if (!*(unsigned char *)(v8 + 77))
  {
    unsigned int v23 = *(NSObject **)a2;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      uint64_t v26 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)v26;
      char v25 = "[%s] iMessageLite environment is not ready";
      goto LABEL_26;
    }
    goto LABEL_28;
  }
  uint64_t v9 = *(NSObject **)a2;
  unint64_t v10 = *(NSObject **)a2;
  if (!*(unsigned char *)(v8 + 75))
  {
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    unint64_t v28 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = (void *)v28;
    char v25 = "[%s] CarrierPigeonStartMessage hasn't been acked yet";
    uint64_t v27 = v9;
LABEL_30:
    _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, v25, (uint8_t *)__p, 0xCu);
    goto LABEL_28;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v11 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    uint64_t v12 = (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 3;
    LODWORD(__p[0]) = 136315394;
    *(void **)((char *)__p + 4) = (void *)v11;
    WORD2(__p[1]) = 2048;
    *(void **)((char *)&__p[1] + 6) = (void *)v12;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [%s] Other short handles count: %zu", (uint8_t *)__p, 0x16u);
  }
  memset(__p, 0, sizeof(__p));
  sub_10024060C((uint64_t)__p, 0xC8uLL);
  sub_10024081C((unint64_t *)__p, *(unsigned __int8 *)(a1 + 24), 2uLL);
  sub_10024081C((unint64_t *)__p, *(unsigned __int8 *)(a1 + 25), 6uLL);
  unint64_t v13 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v14 = *(char *)(a1 + 24);
    if (v14 > 4) {
      char v15 = "???";
    }
    else {
      char v15 = off_1019D3CB8[v14];
    }
    unint64_t v16 = sub_10093AA7C(*(unsigned __int8 *)(a1 + 25));
    *(_DWORD *)std::string buf = 136315394;
    unint64_t v31 = v15;
    __int16 v32 = 2080;
    unint64_t v33 = v16;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Serialized header: Version: %s, MessageType: %s", buf, 0x16u);
  }
  sub_10024081C((unint64_t *)__p, 0, 8uLL);
  sub_10024081C((unint64_t *)__p, 0, 8uLL);
  unint64_t v18 = *(char **)(a1 + 32);
  unint64_t v17 = *(char **)(a1 + 40);
  if ((unint64_t)(v17 - v18) > 0xBF)
  {
    int v20 = *(NSObject **)a2;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      unint64_t v22 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)std::string buf = 136315138;
      unint64_t v31 = v22;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "[%s] Too many other handles", buf, 0xCu);
    }
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    while (v18 != v17)
    {
      uint64_t v19 = *(void *)v18;
      sub_10024081C((unint64_t *)__p, BYTE6(*(void *)v18), 8uLL);
      sub_10024081C((unint64_t *)__p, BYTE5(v19), 8uLL);
      sub_10024081C((unint64_t *)__p, BYTE4(v19), 8uLL);
      sub_10024081C((unint64_t *)__p, BYTE3(v19), 8uLL);
      sub_10024081C((unint64_t *)__p, BYTE2(v19), 8uLL);
      sub_10024081C((unint64_t *)__p, BYTE1(v19), 8uLL);
      sub_10024081C((unint64_t *)__p, v19, 8uLL);
      v18 += 8;
    }
    unint64_t v21 = __p[2];
    *(_OWORD *)a3 = *(_OWORD *)__p;
    *(void *)(a3 + 16) = v21;
    *(unsigned char *)(a3 + 24) = 1;
  }
}

void sub_1004A03FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
}

void sub_1004A0424(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

BOOL sub_1004A042C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 72);
  return !v2 || !*(unsigned char *)(v2 + 77) || *(unsigned char *)(v2 + 75) == 0;
}

BOOL sub_1004A0454(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 72);
  return !v2 || !*(unsigned char *)(v2 + 77) || *(unsigned char *)(v2 + 75) == 0;
}

uint64_t sub_1004A048C()
{
  return 0;
}

uint64_t sub_1004A0494()
{
  return 0;
}

uint64_t sub_1004A049C(uint64_t a1, uint64_t a2, os_log_t *a3)
{
  unint64_t v4 = *a3;
  if (os_log_type_enabled(*a3, OS_LOG_TYPE_ERROR))
  {
    int v6 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v7 = 136315138;
    uint64_t v8 = v6;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Decompression is NOT required for this message. message.", (uint8_t *)&v7, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_1004A0550(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_1004A0558(uint64_t a1, uint64_t a2, os_log_t *a3)
{
  return sub_1004A049C(a1 - 16, a2, a3);
}

BOOL sub_1004A0560(uint64_t a1, os_log_t *a2, uint64_t a3)
{
  int v6 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    __int16 v32 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding", buf, 0xCu);
  }
  *(void *)(a1 + 32) = 0;
  *(_WORD *)std::string buf = 0;
  if ((sub_10036C2D8((uint64_t *)a3, buf, 0x10uLL) & 1) != 0
    && (unsigned __int16 v30 = 0, sub_10036C2D8((uint64_t *)a3, &v30, 0x10uLL))
    && (uint64_t v8 = *(unsigned __int16 *)buf, v9 = v30,
                                       *(_WORD *)std::string buf = 0,
                                       (sub_10036C2D8((uint64_t *)a3, buf, 0x10uLL) & 1) != 0)
    && (unsigned __int16 v30 = 0, (sub_10036C2D8((uint64_t *)a3, &v30, 0x10uLL) & 1) != 0))
  {
    int v10 = 0;
    *(void *)(a1 + 32) |= (v8 << 48) | (v9 << 32) | v30 | ((unint64_t)*(unsigned __int16 *)buf << 16);
    uint64_t v11 = *(void *)a3;
    unint64_t v12 = *(void *)(a3 + 8) - *(void *)a3;
    unint64_t v13 = *(void *)(a3 + 32);
    unint64_t v14 = *(void *)(a3 + 40);
    unint64_t v15 = 8;
    while (1)
    {
      if (!v14)
      {
        *(void *)(a3 + 32) = ++v13;
        *(void *)(a3 + 40) = 8;
        unint64_t v14 = 8;
      }
      if (v13 >= v12) {
        break;
      }
      unint64_t v16 = v15 - v14;
      if (v15 <= v14)
      {
        *(void *)(a3 + 40) = v14 - v15;
        int v18 = *(unsigned __int8 *)(v11 + v13) >> (v14 - v15);
        if (v15 < 8) {
          unsigned int v19 = ~(-1 << v15);
        }
        else {
          unsigned int v19 = 255;
        }
        int v20 = v10 | v18 & v19;
        *(unsigned char *)(a1 + 40) = v20 != 0;
        if (!v20) {
          return 1;
        }
        unint64_t v21 = *a2;
        BOOL result = os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        unsigned int v23 = sub_10093AA58(*(_DWORD *)(a1 + 12));
        *(_DWORD *)std::string buf = 136315394;
        __int16 v32 = v23;
        __int16 v33 = 1024;
        int v34 = v20;
        int v24 = "[%s] Invalid errorCode: %hhu";
        char v25 = v21;
        uint32_t v26 = 18;
        goto LABEL_20;
      }
      unsigned int v17 = *(unsigned __int8 *)(v11 + v13) & ~(-1 << v14);
      *(void *)(a3 + 40) = 0;
      v10 |= (v17 << v16);
      unint64_t v15 = v16;
      unint64_t v14 = 0;
      if (v16 - 9 < 0xFFFFFFFFFFFFFFF8) {
        __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
      }
    }
    *(unsigned char *)(a3 + 24) = 1;
    uint64_t v27 = *a2;
    BOOL result = os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    unint64_t v28 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    __int16 v32 = v28;
    int v24 = "[%s] Failed to read errorCode";
  }
  else
  {
    uint64_t v27 = *a2;
    BOOL result = os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    uint64_t v29 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    __int16 v32 = v29;
    int v24 = "[%s] Failed to read timestamp";
  }
  char v25 = v27;
  uint32_t v26 = 12;
LABEL_20:
  _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, v24, buf, v26);
  return 0;
}

BOOL sub_1004A0874(uint64_t a1, os_log_t *a2, uint64_t a3)
{
  return sub_1004A0560(a1 - 16, a2, a3);
}

uint64_t sub_1004A087C(uint64_t a1)
{
  *(_WORD *)(a1 + 8) = 32;
  *(_DWORD *)(a1 + 12) = 16;
  *(void *)a1 = off_1019D23D0;
  *(void *)(a1 + 16) = &unk_1019D2478;
  *(_DWORD *)(a1 + 24) = 134144;
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 96) = 0;
  uint64_t v2 = operator new(0x20uLL);
  v2[1] = 0;
  v2[2] = 0;
  void *v2 = off_1019B3378;
  *((unsigned char *)v2 + 24) = 1;
  *(void *)(a1 + 104) = v2 + 3;
  *(void *)(a1 + 112) = v2;
  return a1;
}

void sub_1004A0948(_Unwind_Exception *a1)
{
  sub_10012577C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004A095C()
{
  return 0;
}

uint64_t sub_1004A0964()
{
  return 0;
}

uint64_t sub_1004A096C()
{
  return 0;
}

uint64_t sub_1004A0974()
{
  return 0;
}

uint64_t sub_1004A097C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 88);
  if (v3 && !*(unsigned char *)(v3 + 184))
  {
    unint64_t v4 = *(std::__shared_weak_count **)(a2 + 96);
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if ((sub_1006BF030(v3, (const void **)(a1 + 32), *(unsigned __int8 *)(a1 + 27)) & 1) == 0)
    {
      uint64_t v5 = 1;
      if (!v4) {
        return v5;
      }
      goto LABEL_5;
    }
  }
  else
  {
    unint64_t v4 = 0;
  }
  uint64_t v5 = 0;
  if (v4) {
LABEL_5:
  }
    sub_10004D2C8(v4);
  return v5;
}

void sub_1004A09F4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004A0A0C(uint64_t a1, uint64_t a2)
{
  return sub_1004A097C(a1 - 16, a2);
}

uint64_t sub_1004A0A14()
{
  return 0;
}

uint64_t sub_1004A0A1C()
{
  return 0;
}

uint64_t sub_1004A0A24(uint64_t a1, os_log_t *a2)
{
  uint64_t v3 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
  {
    uint64_t v5 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v6 = 136315138;
    int v7 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Compression is not supported for this message", (uint8_t *)&v6, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_1004A0AD8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_1004A0AE0(uint64_t a1, os_log_t *a2)
{
  return sub_1004A0A24(a1 - 16, a2);
}

BOOL sub_1004A0AE8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 88);
  if (v2 && !v2[184])
  {
    uint64_t v5 = *(std::__shared_weak_count **)(a2 + 96);
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v2[123])
    {
      BOOL v3 = v2[121] != 0;
      if (!v5) {
        return v3;
      }
    }
    else
    {
      BOOL v3 = 0;
      if (!v5) {
        return v3;
      }
    }
    sub_10004D2C8(v5);
    return v3;
  }
  return 0;
}

uint64_t sub_1004A0B60()
{
  return 0;
}

uint64_t sub_1004A0B68()
{
  return 0;
}

void sub_1004A0B70(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", buf, 0xCu);
  }
  uint64_t v8 = *(void *)(a2 + 88);
  if (!v8 || *(unsigned char *)(v8 + 184))
  {
    uint64_t v9 = 0;
LABEL_6:
    int v10 = *(NSObject **)a2;
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
LABEL_7:
      *(unsigned char *)a3 = 0;
      *(unsigned char *)(a3 + 24) = 0;
      goto LABEL_8;
    }
    unint64_t v16 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v16;
    unint64_t v15 = "[%s] Environment not ready";
LABEL_21:
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v15, buf, 0xCu);
    goto LABEL_7;
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a2 + 96);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!*(unsigned char *)(v8 + 123)) {
    goto LABEL_6;
  }
  if ((sub_1006BF030(v8, (const void **)(a1 + 32), *(unsigned __int8 *)(a1 + 27)) & 1) == 0)
  {
    int v10 = *(NSObject **)a2;
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    unint64_t v14 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v14;
    unint64_t v15 = "[%s] StewieSatSmsStartMessage not valid anymore";
    goto LABEL_21;
  }
  memset(buf, 0, 32);
  sub_10024060C((uint64_t)buf, 0xC8uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 24), 2uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 25), 6uLL);
  uint64_t v11 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v12 = *(char *)(a1 + 24);
    if (v12 > 4) {
      unint64_t v13 = "???";
    }
    else {
      unint64_t v13 = off_1019D3CB8[v12];
    }
    unsigned int v17 = sub_10093AA7C(*(unsigned __int8 *)(a1 + 25));
    *(_DWORD *)int v61 = 136315394;
    *(void *)unint64_t v62 = v13;
    *(_WORD *)&v62[8] = 2080;
    *(void *)&v62[10] = v17;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Serialized header: Version: %s, MessageType: %s", v61, 0x16u);
  }
  sub_1006BEB94(v8, (uint64_t *)v61);
  int v18 = *(void **)&v62[4];
  if (!*(void *)&v62[4]) {
    goto LABEL_29;
  }
  unsigned int v19 = *(void **)&v62[4];
  do
  {
    int v20 = v19;
    unsigned int v19 = (void *)*v19;
  }
  while (v19);
  if (v20 == &v62[4] || v20[25]) {
LABEL_29:
  }
    int v20 = &v62[4];
  if (!*(void *)&v62[4]) {
    goto LABEL_39;
  }
  unint64_t v21 = (uint64_t *)&v62[4];
  uint64_t v22 = *(void *)&v62[4];
  do
  {
    unsigned int v23 = (uint64_t *)v22;
    int v24 = v21;
    int v25 = *(unsigned __int8 *)(v22 + 25);
    uint32_t v26 = (uint64_t *)(v22 + 8);
    if (v25)
    {
      uint32_t v26 = v23;
      unint64_t v21 = v23;
    }
    uint64_t v22 = *v26;
  }
  while (v22);
  if (v21 == (uint64_t *)&v62[4]) {
    goto LABEL_39;
  }
  if (!v25) {
    unsigned int v23 = v24;
  }
  if (*((unsigned __int8 *)v23 + 25) >= 2u) {
LABEL_39:
  }
    unint64_t v21 = (uint64_t *)&v62[4];
  if (v20 == &v62[4] && v21 == (uint64_t *)&v62[4])
  {
    int v27 = 2;
  }
  else
  {
    unsigned __int16 v30 = *(void **)(v8 + 80);
    int v27 = *(unsigned __int8 *)v30;
    if (v27 == 2 || !v30[3] || v30[4] == v30[5] || !v30[7])
    {
      unint64_t v31 = *(NSObject **)a2;
      if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
      {
        unint64_t v53 = sub_10093AA58(*(_DWORD *)(a1 + 12));
        *(_DWORD *)unint64_t v59 = 136315138;
        unsigned int v60 = v53;
        _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "[%s] Invalid SatSms configuration", v59, 0xCu);
        int v18 = *(void **)&v62[4];
      }
      *(unsigned char *)a3 = 0;
      *(unsigned char *)(a3 + 24) = 0;
      sub_1000346F8((uint64_t)v61, v18);
      uint64_t v32 = 0;
      int v33 = 0;
      goto LABEL_81;
    }
  }
  sub_1000346F8((uint64_t)v61, *(void **)&v62[4]);
  sub_10024081C((unint64_t *)buf, v20 != &v62[4], 1uLL);
  sub_10024081C((unint64_t *)buf, v21 != (uint64_t *)&v62[4], 1uLL);
  sub_10024081C((unint64_t *)buf, v27 == 1, 1uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 27), 4uLL);
  sub_10024081C((unint64_t *)buf, 0, 4uLL);
  if (*(unsigned char *)(a1 + 64))
  {
    unint64_t v28 = *(void *)(a1 + 48) - *(void *)(a1 + 40);
    if (v28 - 36 >= 0xD)
    {
      unint64_t v41 = *(NSObject **)a2;
      if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
      {
LABEL_80:
        uint64_t v32 = 0;
        int v33 = 0;
        *(unsigned char *)a3 = 0;
        *(unsigned char *)(a3 + 24) = 0;
LABEL_81:
        long long v55 = 0u;
        goto LABEL_82;
      }
      uint64_t v44 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)int v61 = 136315138;
      *(void *)unint64_t v62 = v44;
      unint64_t v45 = "[%s] Wrong size of response for SIM config 0";
LABEL_99:
      _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, v45, v61, 0xCu);
      goto LABEL_80;
    }
    if (v28 <= 0x23)
    {
      __TUAssertTrigger();
      unint64_t v28 = *(void *)(a1 + 48) - *(void *)(a1 + 40);
    }
    unsigned __int8 v29 = v28 - 35;
  }
  else
  {
    unsigned __int8 v29 = 0;
  }
  sub_10024081C((unint64_t *)buf, v29, 4uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 96), 1uLL);
  if (v20 == &v62[4] && *(unsigned char *)(a1 + 64)) {
    __TUAssertTrigger();
  }
  if (*(unsigned char *)(a1 + 96) && v21 == (uint64_t *)&v62[4]) {
    __TUAssertTrigger();
  }
  if (*(void *)&buf[24]) {
    __TUAssertTrigger();
  }
  if (*(unsigned char *)(a1 + 64))
  {
    int v34 = *(NSObject **)a2;
    if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v35 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      uint64_t v36 = *(void *)(a1 + 48) - *(void *)(a1 + 40);
      *(_DWORD *)int v61 = 136315394;
      *(void *)unint64_t v62 = v35;
      *(_WORD *)&v62[8] = 2048;
      *(void *)&v62[10] = v36;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I [%s] Size of response for SIM config 0: %zu", v61, 0x16u);
    }
    char v37 = *(unsigned __int8 **)(a1 + 40);
    unint64_t v38 = *(unsigned __int8 **)(a1 + 48);
    while (v37 != v38)
      sub_10024081C((unint64_t *)buf, *v37++, 8uLL);
  }
  if (!*(unsigned char *)(a1 + 96)) {
    goto LABEL_76;
  }
  unint64_t v39 = *(unsigned __int8 **)(a1 + 72);
  unint64_t v40 = *(unsigned __int8 **)(a1 + 80);
  unint64_t v41 = *(NSObject **)a2;
  unint64_t v42 = *(NSObject **)a2;
  if ((unint64_t)(v40 - v39 - 36) >= 0xD)
  {
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
      goto LABEL_80;
    }
    unint64_t v54 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)int v61 = 136315138;
    *(void *)unint64_t v62 = v54;
    unint64_t v45 = "[%s] Wrong size of response for SIM config 1";
    goto LABEL_99;
  }
  if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v43 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)int v61 = 136315394;
    *(void *)unint64_t v62 = v43;
    *(_WORD *)&v62[8] = 2048;
    *(void *)&v62[10] = v40 - v39;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I [%s] Size of response for SIM config 1: %zu", v61, 0x16u);
    unint64_t v39 = *(unsigned __int8 **)(a1 + 72);
    unint64_t v40 = *(unsigned __int8 **)(a1 + 80);
  }
  while (v39 != v40)
    sub_10024081C((unint64_t *)buf, *v39++, 8uLL);
LABEL_76:
  long long v55 = *(_OWORD *)buf;
  uint64_t v32 = *(void *)&buf[16];
  int v33 = 1;
  *(void *)std::string buf = 0;
  *(void *)&uint8_t buf[16] = 0;
LABEL_82:
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  if (v33)
  {
    uint64_t v46 = *(NSObject **)a2;
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v47 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      unint64_t v48 = *(char *)(a1 + 26);
      if (v48 > 2) {
        char v49 = "???";
      }
      else {
        char v49 = off_1019D3CA0[v48];
      }
      int v50 = *(unsigned __int8 *)(a1 + 27);
      uint64_t v51 = "yes";
      if (*(unsigned char *)(a1 + 64)) {
        unint64_t v52 = "yes";
      }
      else {
        unint64_t v52 = "no";
      }
      if (!*(unsigned char *)(a1 + 96)) {
        uint64_t v51 = "no";
      }
      *(_DWORD *)std::string buf = 136316162;
      *(void *)&uint8_t buf[4] = v47;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v49;
      *(_WORD *)&unsigned char buf[22] = 1024;
      *(_DWORD *)&uint8_t buf[24] = v50;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = v52;
      __int16 v57 = 2080;
      int v58 = v51;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I [%s] SPSBucketID: %s, token: %hhu, response for simConfigs: [%s, %s]", buf, 0x30u);
    }
    *(_OWORD *)a3 = v55;
    *(void *)(a3 + 16) = v32;
    *(unsigned char *)(a3 + 24) = 1;
  }
  else if ((void)v55)
  {
    operator delete((void *)v55);
  }
LABEL_8:
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_1004A1334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004A137C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_1004A1384()
{
  return 0;
}

uint64_t sub_1004A138C()
{
  return 0;
}

void sub_1004A1394(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (const void **)(a1 + 32);
  if (*(void *)(a1 + 32)) {
    uint64_t v5 = sub_100136254;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5)
  {
    uint64_t v6 = *(void *)(a2 + 88);
    if (v6 && !*(unsigned char *)(v6 + 184))
    {
      int v7 = *(std::__shared_weak_count **)(a2 + 96);
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_1006BF7B8(v6, v4, *(unsigned __int8 *)(a1 + 27), *(unsigned char *)(a1 + 64), *(unsigned char *)(a1 + 96));
      if (v7)
      {
        sub_10004D2C8(v7);
      }
    }
  }
  else
  {
    uint64_t v8 = *(NSObject **)a2;
    if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      int v10 = 136315138;
      uint64_t v11 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "[%s] LLCEnvironmentID missing", (uint8_t *)&v10, 0xCu);
    }
  }
}

void sub_1004A14D8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004A14F0(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1004A1500()
{
  return 1;
}

uint64_t sub_1004A1508()
{
  return 1;
}

uint64_t sub_1004A1510()
{
  return 0;
}

uint64_t sub_1004A1518()
{
  return 0;
}

uint64_t sub_1004A1520(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 88);
  if (v2)
  {
    if (*(unsigned char *)(v2 + 184))
    {
      return 0;
    }
    else
    {
      unint64_t v4 = *(std::__shared_weak_count **)(a2 + 96);
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_1006BEB94(v2, &v12);
      unsigned int v5 = sub_1006BE9C8(v2, *(_DWORD *)(a1 + 28));
      if (!v13[0]) {
        goto LABEL_16;
      }
      uint64_t v6 = v13;
      int v7 = v13[0];
      do
      {
        uint64_t v8 = v7;
        uint64_t v9 = v6;
        unsigned int v10 = *((unsigned __int8 *)v7 + 25);
        if (v10 >= v5) {
          uint64_t v6 = (void **)v7;
        }
        else {
          ++v7;
        }
        int v7 = (void *)*v7;
      }
      while (v7);
      if (v6 == v13) {
        goto LABEL_16;
      }
      if (v10 < v5) {
        uint64_t v8 = v9;
      }
      if (v5 < *((unsigned __int8 *)v8 + 25)) {
LABEL_16:
      }
        uint64_t v6 = v13;
      uint64_t v2 = v6 == v13;
      sub_1000346F8((uint64_t)&v12, v13[0]);
      if (v4) {
        sub_10004D2C8(v4);
      }
    }
  }
  return v2;
}

void sub_1004A1610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  sub_1000346F8((uint64_t)&a10, a11);
  if (v11) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1004A163C(uint64_t a1, uint64_t a2)
{
  return sub_1004A1520(a1 - 16, a2);
}

uint64_t sub_1004A1644()
{
  return 0;
}

uint64_t sub_1004A164C()
{
  return 0;
}

uint64_t sub_1004A1654(uint64_t a1, os_log_t *a2)
{
  BOOL v3 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
  {
    unsigned int v5 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v6 = 136315138;
    int v7 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Compression is not supported for this message", (uint8_t *)&v6, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_1004A1708(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_1004A1710(uint64_t a1, os_log_t *a2)
{
  return sub_1004A1654(a1 - 16, a2);
}

uint64_t sub_1004A1718(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 88);
  if (v3 && !*(unsigned char *)(v3 + 184))
  {
    int v6 = *(std::__shared_weak_count **)(a2 + 96);
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(unsigned char *)(v3 + 123))
    {
      uint64_t v4 = sub_1006BEAAC(v3, *(_DWORD *)(a1 + 28));
      if (!v6) {
        return v4;
      }
    }
    else
    {
      uint64_t v4 = 0;
      if (!v6) {
        return v4;
      }
    }
    sub_10004D2C8(v6);
    return v4;
  }
  return 0;
}

void sub_1004A1794(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004A17AC(uint64_t a1, uint64_t a2)
{
  return sub_1004A1718(a1 - 16, a2);
}

uint64_t sub_1004A17B4()
{
  return 0;
}

uint64_t sub_1004A17BC()
{
  return 0;
}

void sub_1004A17C4(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", buf, 0xCu);
  }
  uint64_t v8 = *(void *)(a2 + 88);
  if (!v8 || *(unsigned char *)(v8 + 184))
  {
    uint64_t v9 = 0;
LABEL_6:
    unsigned int v10 = *(NSObject **)a2;
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
LABEL_7:
      *(unsigned char *)a3 = 0;
      *(unsigned char *)(a3 + 24) = 0;
      goto LABEL_8;
    }
    unsigned __int8 v29 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v29;
    uint64_t v22 = "[%s] Environment not ready";
    goto LABEL_36;
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a2 + 96);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!*(unsigned char *)(v8 + 123)) {
    goto LABEL_6;
  }
  if (!*(unsigned char *)(v8 + 121))
  {
    unsigned int v10 = *(NSObject **)a2;
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    char v77 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v77;
    uint64_t v22 = "[%s] CarrierPigeonStartMessage hasn't been acked yet";
LABEL_36:
    unsigned int v23 = v10;
LABEL_37:
    uint32_t v24 = 12;
    goto LABEL_38;
  }
  unsigned int v11 = sub_1006BE9C8(v8, *(_DWORD *)(a1 + 28));
  sub_1006BEB94(v8, (uint64_t *)buf);
  if (!*(void *)&buf[8]) {
    goto LABEL_26;
  }
  uint64_t v12 = &buf[8];
  unint64_t v13 = *(uint8_t **)&buf[8];
  do
  {
    unint64_t v14 = v13;
    unint64_t v15 = v12;
    unsigned int v16 = v13[25];
    if (v16 >= v11) {
      uint64_t v12 = v13;
    }
    else {
      v13 += 8;
    }
    unint64_t v13 = *(uint8_t **)v13;
  }
  while (v13);
  if (v12 == &buf[8] || (v16 >= v11 ? (unsigned int v17 = v14) : (unsigned int v17 = v15), v11 < v17[25]))
  {
LABEL_26:
    sub_1000346F8((uint64_t)buf, *(void **)&buf[8]);
    int v18 = *(NSObject **)a2;
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    unsigned int v19 = *(_DWORD *)(a1 + 12);
    uint64_t v20 = subscriber::asString();
    unint64_t v21 = sub_10093AA58(v19);
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v21;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v20;
    uint64_t v22 = "[%s] Slot: %s is not enabled";
    unsigned int v23 = v18;
    uint32_t v24 = 22;
LABEL_38:
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v22, buf, v24);
    goto LABEL_7;
  }
  sub_1000346F8((uint64_t)buf, *(void **)&buf[8]);
  uint64_t v25 = *(void *)(v8 + 80);
  if (*(unsigned char *)v25 == 2 || !*(void *)(v25 + 24) || *(void *)(v25 + 32) == *(void *)(v25 + 40))
  {
    uint32_t v26 = *(NSObject **)a2;
    goto LABEL_40;
  }
  uint32_t v26 = *(NSObject **)a2;
  if (!*(void *)(v25 + 56))
  {
LABEL_40:
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    unsigned __int16 v30 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v30;
    uint64_t v22 = "[%s] Invalid SatSms configuration";
    unsigned int v23 = v26;
    goto LABEL_37;
  }
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    int v27 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    uint64_t v28 = subscriber::asString();
    if (*(unsigned char *)(a1 + 32))
    {
      std::operator+<char>();
    }
    else if (*(char *)(a1 + 63) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
    }
    else
    {
      *(_OWORD *)__n128 __p = *(_OWORD *)(a1 + 40);
      __p[2] = *(void **)(a1 + 56);
    }
    unint64_t v31 = __p;
    if (SHIBYTE(__p[2]) < 0) {
      unint64_t v31 = (void **)__p[0];
    }
    int v32 = *(unsigned __int8 *)(a1 + 64);
    uint64_t v33 = *(void *)(a1 + 80) - *(void *)(a1 + 72);
    if (*(unsigned char *)(a1 + 33)) {
      int v34 = "yes";
    }
    else {
      int v34 = "no";
    }
    *(_DWORD *)std::string buf = 136316418;
    *(void *)&uint8_t buf[4] = v27;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v28;
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v31;
    __int16 v88 = 1024;
    int v89 = v32;
    __int16 v90 = 2048;
    uint64_t v91 = v33;
    __int16 v92 = 2080;
    __int16 v93 = v34;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I [%s] SimSlot: %s, DestinationPhoneNumber: %s, CodecId: %hhu, Payload size: %zu, NotifyDowngrade: %s", buf, 0x3Au);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
  memset(buf, 0, sizeof(buf));
  sub_10024060C((uint64_t)buf, 0xC8uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 24), 2uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 25), 6uLL);
  unint64_t v35 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v36 = *(char *)(a1 + 24);
    if (v36 > 4) {
      char v37 = "???";
    }
    else {
      char v37 = off_1019D3CB8[v36];
    }
    unint64_t v38 = sub_10093AA7C(*(unsigned __int8 *)(a1 + 25));
    LODWORD(__p[0]) = 136315394;
    *(void **)((char *)__p + 4) = (void *)v37;
    WORD2(__p[1]) = 2080;
    *(void **)((char *)&__p[1] + 6) = (void *)v38;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Serialized header: Version: %s, MessageType: %s", (uint8_t *)__p, 0x16u);
  }
  sub_10024081C((unint64_t *)buf, v11 != 0, 1uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 33), 1uLL);
  sub_10024081C((unint64_t *)buf, 0, 6uLL);
  char v83 = 0;
  long long v84 = 0uLL;
  memset(__p, 0, sizeof(__p));
  sub_10024060C((uint64_t)__p, 0xC8uLL);
  sub_10024081C((unint64_t *)__p, *(unsigned __int8 *)(a1 + 32), 1uLL);
  unint64_t v39 = (void *)(a1 + 40);
  unint64_t v40 = sub_10132CC20((const std::string *)(a1 + 40));
  if (!v41)
  {
    unint64_t v52 = *(NSObject **)a2;
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
    {
      unint64_t v53 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      if (*(char *)(a1 + 63) < 0) {
        unint64_t v39 = (void *)*v39;
      }
      *(_DWORD *)unint64_t v85 = 136315394;
      *(void *)&v85[4] = v53;
      *(_WORD *)&v85[12] = 2080;
      *(void *)&v85[14] = v39;
      unint64_t v48 = "[%s] Failed to encode phone number: %s";
      unint64_t v54 = v52;
      uint32_t v55 = 22;
      goto LABEL_76;
    }
    goto LABEL_77;
  }
  unint64_t v42 = v40;
  sub_10024081C((unint64_t *)__p, BYTE6(v40), 3uLL);
  sub_10024081C((unint64_t *)__p, BYTE5(v42), 8uLL);
  sub_10024081C((unint64_t *)__p, BYTE4(v42), 8uLL);
  sub_10024081C((unint64_t *)__p, BYTE3(v42), 8uLL);
  sub_10024081C((unint64_t *)__p, BYTE2(v42), 8uLL);
  sub_10024081C((unint64_t *)__p, BYTE1(v42), 8uLL);
  sub_10024081C((unint64_t *)__p, v42, 8uLL);
  sub_10024081C((unint64_t *)__p, 0, 8uLL);
  unsigned int v43 = *(unsigned __int8 *)(a1 + 64);
  if (v43 >= 0x10)
  {
    unint64_t v56 = *(NSObject **)a2;
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      __int16 v57 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)unint64_t v85 = 136315394;
      *(void *)&v85[4] = v57;
      *(_WORD *)&v85[12] = 1024;
      *(_DWORD *)&v85[14] = v43;
      unint64_t v48 = "[%s] Invalid codecID: %hhu";
      unint64_t v54 = v56;
      uint32_t v55 = 18;
LABEL_76:
      _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, v48, v85, v55);
      goto LABEL_77;
    }
    goto LABEL_77;
  }
  sub_10024081C((unint64_t *)__p, *(unsigned __int8 *)(a1 + 64), 4uLL);
  uint64_t v44 = *(unsigned __int8 **)(a1 + 72);
  unint64_t v45 = *(unsigned __int8 **)(a1 + 80);
  if (v44 == v45)
  {
    uint64_t v46 = *(NSObject **)a2;
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      int v58 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)unint64_t v85 = 136315138;
      *(void *)&v85[4] = v58;
      unint64_t v48 = "[%s] Payload is missing";
      goto LABEL_75;
    }
LABEL_77:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
    unint64_t v59 = (unsigned __int8 *)__p[0];
    if (!__p[0])
    {
LABEL_80:
      if (v83)
      {
        *(void *)&long long v84 = v83;
        operator delete(v83);
      }
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
      goto LABEL_8;
    }
    __p[1] = __p[0];
LABEL_79:
    operator delete(v59);
    goto LABEL_80;
  }
  if ((unint64_t)(v45 - v44) > 0x8E)
  {
    uint64_t v46 = *(NSObject **)a2;
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      unint64_t v47 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)unint64_t v85 = 136315138;
      *(void *)&v85[4] = v47;
      unint64_t v48 = "[%s] Payload is too big";
LABEL_75:
      unint64_t v54 = v46;
      uint32_t v55 = 12;
      goto LABEL_76;
    }
    goto LABEL_77;
  }
  do
    sub_10024081C((unint64_t *)__p, *v44++, 8uLL);
  while (v44 != v45);
  if (__p[3]) {
    __TUAssertTrigger();
  }
  char v49 = __p[0];
  int v50 = v83;
  uint64_t v51 = (void *)*((void *)&v84 + 1);
  char v83 = __p[0];
  long long v84 = *(_OWORD *)&__p[1];
  __p[0] = v50;
  __p[2] = v51;
  unsigned int v60 = __p[1];
  if (v49 == __p[1])
  {
    __TUAssertTrigger();
    char v49 = v83;
    unsigned int v60 = (unsigned char *)v84;
  }
  if (*(unsigned char *)(a1 + 33)) {
    size_t v61 = 7;
  }
  else {
    size_t v61 = 0;
  }
  if (v60 - v49 <= v61)
  {
    __TUAssertTrigger();
    char v49 = v83;
    unsigned int v60 = (unsigned char *)v84;
  }
  memset(__p, 0, 24);
  uint64_t v62 = *(void *)(v25 + 56);
  memset(v85, 0, 24);
  sub_10036CCEC(v85, &v49[v61], (uint64_t)v60, v60 - &v49[v61]);
  int v81 = 0;
  uint64_t v82 = 0;
  int v80 = 0;
  sub_10036CCEC(&v80, v83, (uint64_t)v83 + v61, v61);
  (*(void (**)(void **__return_ptr, uint64_t, BOOL, uint8_t *, void **))(*(void *)v62 + 16))(__p, v62, v11 != 0, v85, &v80);
  if (v80)
  {
    int v81 = v80;
    operator delete(v80);
  }
  if (*(void *)v85)
  {
    *(void *)&v85[8] = *(void *)v85;
    operator delete(*(void **)v85);
  }
  if (LODWORD(__p[0]) || !__p[1])
  {
    unint64_t v63 = *(NSObject **)a2;
    if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
    {
      uint64_t v78 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)unint64_t v85 = 136315138;
      *(void *)&v85[4] = v78;
      _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "[%s] Encryption failed", v85, 0xCu);
    }
    unsigned int v64 = 0;
    int v65 = 0;
    int v66 = 0;
    int v67 = 0;
    unsigned int v68 = 0;
    char v69 = 0;
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
  }
  else
  {
    int v66 = *((unsigned __int8 *)__p[1] + 2);
    int v67 = *((unsigned __int8 *)__p[1] + 3);
    unsigned int v68 = *(unsigned __int16 *)__p[1];
    sub_1003F0208((unint64_t *)&v83, v61);
    unint64_t v70 = __p[1];
    unint64_t v71 = (unsigned char *)*((void *)__p[1] + 1);
    unsigned int v72 = (unsigned char *)*((void *)__p[1] + 2);
    *(void *)unint64_t v85 = &v83;
    if (v71 != v72)
    {
      do
        sub_100240714((unint64_t **)v85, v71++);
      while (v71 != v72);
      unint64_t v70 = __p[1];
    }
    int v65 = (unsigned __int8 *)v70[4];
    unsigned int v64 = (unsigned __int8 *)v70[5];
    if (v64 - v65 != 8)
    {
      __TUAssertTrigger();
      unint64_t v70 = __p[1];
      int v65 = (unsigned __int8 *)*((void *)__p[1] + 4);
      unsigned int v64 = (unsigned __int8 *)*((void *)__p[1] + 5);
    }
    v70[4] = 0;
    v70[5] = 0;
    char v69 = 1;
    v70[6] = 0;
  }
  if (__p[2]) {
    sub_10004D2C8((std::__shared_weak_count *)__p[2]);
  }
  if ((v69 & 1) == 0)
  {
    if (!v65) {
      goto LABEL_80;
    }
    unint64_t v59 = v65;
    goto LABEL_79;
  }
  sub_10024081C((unint64_t *)buf, v66, 8uLL);
  sub_10024081C((unint64_t *)buf, v67, 8uLL);
  sub_1004A2390((unint64_t *)buf, v68);
  char v73 = (unsigned __int8 *)v83;
  unsigned int v74 = (unsigned __int8 *)v84;
  while (v73 != v74)
    sub_10024081C((unint64_t *)buf, *v73++, 8uLL);
  if (v65 != v64)
  {
    unsigned int v75 = v65;
    do
      sub_10024081C((unint64_t *)buf, *v75++, 8uLL);
    while (v75 != v64);
  }
  long long v79 = *(_OWORD *)buf;
  memset(buf, 0, 24);
  uint64_t v76 = *(void *)&buf[16];
  if (v65) {
    operator delete(v65);
  }
  if (v83)
  {
    *(void *)&long long v84 = v83;
    operator delete(v83);
  }
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  *(_OWORD *)a3 = v79;
  *(void *)(a3 + 16) = v76;
  *(unsigned char *)(a3 + 24) = 1;
LABEL_8:
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_1004A22B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,uint64_t a24,void *a25,uint64_t a26)
{
  if (a23) {
    sub_10004D2C8(a23);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a25) {
    operator delete(a25);
  }
  if (v26) {
    sub_10004D2C8(v26);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004A2390(unint64_t *a1, unsigned int a2)
{
  unsigned __int8 v2 = a2;
  sub_10024081C(a1, a2 >> 8, 8uLL);

  sub_10024081C(a1, v2, 8uLL);
}

void sub_1004A23DC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_1004A23E4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 88);
  if (v3 && !*(unsigned char *)(v3 + 184))
  {
    int v6 = *(std::__shared_weak_count **)(a2 + 96);
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(unsigned char *)(v3 + 123))
    {
      uint64_t v4 = sub_1006BEAAC(v3, *(_DWORD *)(a1 + 28)) ^ 1;
      if (!v6) {
        return v4;
      }
    }
    else
    {
      uint64_t v4 = 1;
      if (!v6) {
        return v4;
      }
    }
    sub_10004D2C8(v6);
    return v4;
  }
  return 1;
}

void sub_1004A2460(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004A2478(uint64_t a1, uint64_t a2)
{
  return sub_1004A23E4(a1 - 16, a2);
}

uint64_t sub_1004A2490()
{
  return 0;
}

uint64_t sub_1004A2498()
{
  return 0;
}

uint64_t sub_1004A24A0(uint64_t a1, uint64_t a2, os_log_t *a3)
{
  uint64_t v4 = *a3;
  if (os_log_type_enabled(*a3, OS_LOG_TYPE_ERROR))
  {
    int v6 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v7 = 136315138;
    uint64_t v8 = v6;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Decompression is NOT required for this message. message.", (uint8_t *)&v7, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_1004A2554(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_1004A255C(uint64_t a1, uint64_t a2, os_log_t *a3)
{
  return sub_1004A24A0(a1 - 16, a2, a3);
}

uint64_t sub_1004A2564(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v9 = *(void *)(a2 + 88);
  uint64_t v8 = *(std::__shared_weak_count **)(a2 + 96);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v9 || !*(unsigned char *)(v9 + 123))
  {
    uint64_t v25 = *(NSObject **)a2;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    CFStringRef v122 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v122;
    unint64_t v71 = "[%s] Environment not ready";
    goto LABEL_86;
  }
  uint64_t v10 = *(void *)(v9 + 80);
  if (*(unsigned char *)v10 == 2
    || !*(void *)(v10 + 24)
    || *(void *)(v10 + 32) == *(void *)(v10 + 40)
    || !*(void *)(v10 + 56))
  {
    uint64_t v25 = *(NSObject **)a2;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    char v73 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v73;
    unint64_t v71 = "[%s] Invalid SatSms configuration";
LABEL_86:
    _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, v71, (uint8_t *)&buf, 0xCu);
    goto LABEL_26;
  }
  LOWORD(buf.__r_.__value_.__l.__data_) = 0;
  if ((sub_10036C2D8((uint64_t *)a3, &buf, 0x10uLL) & 1) == 0
    || (LOWORD(v197[0]) = 0, !sub_10036C2D8((uint64_t *)a3, v197, 0x10uLL))
    || (uint64_t data_low = LOWORD(buf.__r_.__value_.__l.__data_),
        uint64_t v12 = LOWORD(v197[0]),
        LOWORD(buf.__r_.__value_.__l.__data_) = 0,
        (sub_10036C2D8((uint64_t *)a3, &buf, 0x10uLL) & 1) == 0)
    || (LOWORD(v197[0]) = 0, (sub_10036C2D8((uint64_t *)a3, v197, 0x10uLL) & 1) == 0))
  {
    uint64_t v25 = *(NSObject **)a2;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    int v128 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v128;
    unint64_t v71 = "[%s] Failed to read timestamp";
    goto LABEL_86;
  }
  *(void *)(a1 + 32) |= (data_low << 48) | (v12 << 32) | LOWORD(v197[0]) | ((unint64_t)LOWORD(buf.__r_.__value_.__l.__data_) << 16);
  uint64_t v13 = *(void *)a3;
  unint64_t v14 = *(void *)(a3 + 8) - *(void *)a3;
  unint64_t v15 = *(void *)(a3 + 32);
  uint64_t v16 = *(void *)(a3 + 40);
  if (!v16)
  {
    uint64_t v16 = 8;
    *(void *)(a3 + 32) = ++v15;
    *(void *)(a3 + 40) = 8;
  }
  if (v15 >= v14)
  {
    *(unsigned char *)(a3 + 24) = 1;
    uint64_t v25 = *(NSObject **)a2;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    uint64_t v132 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v132;
    unint64_t v71 = "[%s] Failed to read simConfigInfo";
    goto LABEL_86;
  }
  uint64_t v17 = v16 - 1;
  *(void *)(a3 + 40) = v17;
  int v18 = *(unsigned __int8 *)(v13 + v15) >> v17;
  *(_DWORD *)(a1 + 40) = sub_1006BEA40(v9, v18 & 1);
  *(unsigned char *)(a1 + 44) = 0;
  unint64_t v19 = 7;
  while (1)
  {
    unint64_t v20 = *(void *)(a3 + 32);
    unint64_t v21 = *(void *)(a3 + 40);
    if (!v21)
    {
      *(void *)(a3 + 32) = ++v20;
      *(void *)(a3 + 40) = 8;
      unint64_t v21 = 8;
    }
    uint64_t v22 = *(void *)a3;
    if (v20 >= *(void *)(a3 + 8) - *(void *)a3)
    {
      *(unsigned char *)(a3 + 24) = 1;
      uint64_t v25 = *(NSObject **)a2;
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        goto LABEL_26;
      }
      std::string::size_type v117 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v117;
      unint64_t v71 = "[%s] Failed to read pending total count";
      goto LABEL_86;
    }
    unint64_t v23 = v19 - v21;
    if (v19 <= v21) {
      break;
    }
    unsigned int v24 = *(unsigned __int8 *)(v22 + v20) & ~(-1 << v21);
    *(void *)(a3 + 40) = 0;
    *(unsigned char *)(a1 + 44) |= v24 << v23;
    unint64_t v19 = v23;
    if (v23 - 9 < 0xFFFFFFFFFFFFFFF8) {
LABEL_39:
    }
      __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
  }
  *(void *)(a3 + 40) = v21 - v19;
  int v28 = *(unsigned __int8 *)(v22 + v20) >> (v21 - v19);
  if (v19 < 8) {
    char v29 = ~(-1 << v19);
  }
  else {
    char v29 = -1;
  }
  *(unsigned char *)(a1 + 44) |= v28 & v29;
  *(unsigned char *)(a1 + 45) = 0;
  unint64_t v30 = 7;
  while (1)
  {
    unint64_t v31 = *(void *)(a3 + 32);
    unint64_t v32 = *(void *)(a3 + 40);
    if (!v32)
    {
      *(void *)(a3 + 32) = ++v31;
      *(void *)(a3 + 40) = 8;
      unint64_t v32 = 8;
    }
    uint64_t v33 = *(void *)a3;
    if (v31 >= *(void *)(a3 + 8) - *(void *)a3)
    {
      *(unsigned char *)(a3 + 24) = 1;
      uint64_t v25 = *(NSObject **)a2;
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        goto LABEL_26;
      }
      v118 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v118;
      unint64_t v71 = "[%s] Failed to read pending count";
      goto LABEL_86;
    }
    unint64_t v34 = v30 - v32;
    if (v30 <= v32) {
      break;
    }
    unsigned int v35 = *(unsigned __int8 *)(v33 + v31) & ~(-1 << v32);
    *(void *)(a3 + 40) = 0;
    *(unsigned char *)(a1 + 45) |= v35 << v34;
    unint64_t v30 = v34;
    if (v34 - 9 < 0xFFFFFFFFFFFFFFF8) {
      goto LABEL_39;
    }
  }
  int v36 = 0;
  *(void *)(a3 + 40) = v32 - v30;
  int v37 = *(unsigned __int8 *)(v33 + v31) >> (v32 - v30);
  if (v30 < 8) {
    char v38 = ~(-1 << v30);
  }
  else {
    char v38 = -1;
  }
  *(unsigned char *)(a1 + 45) |= v37 & v38;
  uint64_t v39 = *(void *)a3;
  unint64_t v40 = *(void *)(a3 + 8) - *(void *)a3;
  unint64_t v41 = *(void *)(a3 + 32);
  unint64_t v42 = *(void *)(a3 + 40);
  unint64_t v43 = 1;
  while (1)
  {
    if (!v42)
    {
      *(void *)(a3 + 32) = ++v41;
      *(void *)(a3 + 40) = 8;
      unint64_t v42 = 8;
    }
    if (v41 >= v40)
    {
      *(unsigned char *)(a3 + 24) = 1;
      uint64_t v25 = *(NSObject **)a2;
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        goto LABEL_26;
      }
      int64_t v119 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v119;
      unint64_t v71 = "[%s] Failed to read isMMS bit";
      goto LABEL_86;
    }
    unint64_t v44 = v43 - v42;
    if (v43 <= v42) {
      break;
    }
    unsigned int v45 = *(unsigned __int8 *)(v39 + v41) & ~(-1 << v42);
    *(void *)(a3 + 40) = 0;
    v36 |= (v45 << v44);
    unint64_t v43 = v44;
    unint64_t v42 = 0;
    if (v44 - 9 < 0xFFFFFFFFFFFFFFF8) {
LABEL_69:
    }
      __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
  }
  *(void *)(a3 + 40) = v42 - v43;
  int v46 = *(unsigned __int8 *)(v39 + v41) >> (v42 - v43);
  if (v43 < 8) {
    unsigned int v47 = ~(-1 << v43);
  }
  else {
    unsigned int v47 = 255;
  }
  int v48 = v36 | v46 & v47;
  *(unsigned char *)(a1 + 160) = v48 != 0;
  *(unsigned char *)(a1 + 47) = 0;
  unint64_t v49 = 8;
  while (1)
  {
    unint64_t v50 = *(void *)(a3 + 32);
    unint64_t v51 = *(void *)(a3 + 40);
    if (!v51)
    {
      *(void *)(a3 + 32) = ++v50;
      *(void *)(a3 + 40) = 8;
      unint64_t v51 = 8;
    }
    uint64_t v52 = *(void *)a3;
    if (v50 >= *(void *)(a3 + 8) - *(void *)a3)
    {
      *(unsigned char *)(a3 + 24) = 1;
      uint64_t v25 = *(NSObject **)a2;
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        goto LABEL_26;
      }
      long long v120 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v120;
      unint64_t v71 = "[%s] Failed to read key IWF Digest";
      goto LABEL_86;
    }
    unint64_t v53 = v49 - v51;
    if (v49 <= v51) {
      break;
    }
    unsigned int v54 = *(unsigned __int8 *)(v52 + v50) & ~(-1 << v51);
    *(void *)(a3 + 40) = 0;
    *(unsigned char *)(a1 + 47) |= v54 << v53;
    unint64_t v49 = v53;
    if (v53 - 9 < 0xFFFFFFFFFFFFFFF8) {
      goto LABEL_69;
    }
  }
  *(void *)(a3 + 40) = v51 - v49;
  int v55 = *(unsigned __int8 *)(v52 + v50) >> (v51 - v49);
  if (v49 < 8) {
    char v56 = ~(-1 << v49);
  }
  else {
    char v56 = -1;
  }
  *(unsigned char *)(a1 + 47) |= v55 & v56;
  *(unsigned char *)(a1 + 46) = 0;
  unint64_t v57 = 8;
  while (1)
  {
    unint64_t v58 = *(void *)(a3 + 32);
    unint64_t v59 = *(void *)(a3 + 40);
    if (!v59)
    {
      *(void *)(a3 + 32) = ++v58;
      *(void *)(a3 + 40) = 8;
      unint64_t v59 = 8;
    }
    uint64_t v60 = *(void *)a3;
    if (v58 >= *(void *)(a3 + 8) - *(void *)a3)
    {
      *(unsigned char *)(a3 + 24) = 1;
      uint64_t v25 = *(NSObject **)a2;
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        goto LABEL_26;
      }
      uint64_t v121 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v121;
      unint64_t v71 = "[%s] Failed to read key UE Digest";
      goto LABEL_86;
    }
    unint64_t v61 = v57 - v59;
    if (v57 <= v59) {
      break;
    }
    unsigned int v62 = *(unsigned __int8 *)(v60 + v58) & ~(-1 << v59);
    *(void *)(a3 + 40) = 0;
    *(unsigned char *)(a1 + 46) |= v62 << v61;
    unint64_t v57 = v61;
    if (v61 - 9 < 0xFFFFFFFFFFFFFFF8) {
      goto LABEL_69;
    }
  }
  *(void *)(a3 + 40) = v59 - v57;
  int v63 = *(unsigned __int8 *)(v60 + v58) >> (v59 - v57);
  if (v57 < 8) {
    char v64 = ~(-1 << v57);
  }
  else {
    char v64 = -1;
  }
  *(_WORD *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 46) |= v63 & v64;
  if ((sub_10036C2D8((uint64_t *)a3, (_WORD *)(a1 + 48), 0x10uLL) & 1) == 0)
  {
    uint64_t v25 = *(NSObject **)a2;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    unsigned int v72 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v72;
    unint64_t v71 = "[%s] Failed to read ratchet counter";
    goto LABEL_86;
  }
  if (*(unsigned char *)(a3 + 24))
  {
    __TUAssertTrigger();
    if (*(unsigned char *)(a3 + 24)) {
      sub_10016C840();
    }
  }
  uint64_t v65 = *(void *)(a3 + 40);
  if ((v65 | 8) != 8)
  {
    uint64_t v25 = *(NSObject **)a2;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    unsigned int v74 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v74;
    unint64_t v71 = "[%s] Payload is not byte aligned";
    goto LABEL_86;
  }
  int v186 = v48;
  char v187 = v18 & 1;
  if (v65) {
    uint64_t v66 = *(void *)(a3 + 32);
  }
  else {
    uint64_t v66 = *(void *)(a3 + 32) + 1;
  }
  uint64_t v67 = *(void *)a3;
  unint64_t v68 = *(void *)(a3 + 8) - *(void *)a3 - v66;
  unint64_t v69 = v68 - 8;
  if (v68 <= 8)
  {
    uint64_t v25 = *(NSObject **)a2;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      unint64_t v70 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v70;
      unint64_t v71 = "[%s] Payload is empty";
      goto LABEL_86;
    }
LABEL_26:
    uint64_t v26 = 0;
    goto LABEL_27;
  }
  if (v69 <= 7)
  {
    uint64_t v25 = *(NSObject **)a2;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    unsigned int v75 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v75;
    unint64_t v71 = "[%s][A] Payload is too short";
    goto LABEL_86;
  }
  v202[0] = 0;
  v202[1] = 0;
  int v203 = 0;
  sub_10036CCEC(v202, (const void *)(v67 + v66), v67 + v66 + v69, v68 - 8);
  uint64_t v76 = *(void *)(a3 + 8);
  unint64_t v183 = v69;
  char v77 = (const void *)(*(void *)a3 + v66 + v69);
  memset(&buf, 0, sizeof(buf));
  sub_10036CCEC(&buf, v77, v76, v76 - (void)v77);
  uint64_t v78 = *(void **)(a1 + 56);
  if (v78)
  {
    *(void *)(a1 + 64) = v78;
    operator delete(v78);
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
  }
  std::string::size_type v79 = buf.__r_.__value_.__r.__words[0];
  *(void *)(a1 + 56) = buf.__r_.__value_.__r.__words[0];
  std::string::size_type size = buf.__r_.__value_.__l.__size_;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&buf.__r_.__value_.__r.__words[1];
  if (size - v79 != 8) {
    __TUAssertTrigger();
  }
  v197[0] = 0;
  v197[1] = 0;
  v198 = 0;
  uint64_t v81 = *(void *)(v10 + 56);
  LOWORD(buf.__r_.__value_.__l.__data_) = *(_WORD *)(a1 + 48);
  buf.__r_.__value_.__s.__data_[2] = *(unsigned char *)(a1 + 47);
  buf.__r_.__value_.__s.__data_[3] = *(unsigned char *)(a1 + 46);
  uint64_t v205 = 0;
  *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0uLL;
  sub_10005C928(&buf.__r_.__value_.__l.__size_, v202[0], (uint64_t)v202[1], (char *)v202[1] - (char *)v202[0]);
  uint64_t v206 = 0;
  long long v207 = 0uLL;
  sub_10005C928(&v206, *(const void **)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 64) - *(void *)(a1 + 56));
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v194 = 0;
  (*(void (**)(void **__return_ptr, uint64_t, void, std::string *, void **))(*(void *)v81 + 24))(v197, v81, v18 & 1, &buf, __p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  sub_10049E260(&buf);
  if (LODWORD(v197[0]) || (char v83 = v197[1]) == 0 || (v84 = (void *)*((void *)v197[1] + 1), *(void **)v197[1] == v84))
  {
    uint64_t v82 = *(NSObject **)a2;
    if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
    {
      int v126 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v126;
      _os_log_error_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_ERROR, "[%s] Decryption failed", (uint8_t *)&buf, 0xCu);
    }
    if (v198) {
      sub_10004D2C8(v198);
    }
    uint64_t v26 = 0;
    goto LABEL_104;
  }
  unint64_t v85 = v202[0];
  v202[0] = *(void **)v197[1];
  *(void *)v197[1] = v85;
  unint64_t v86 = v202[1];
  v202[1] = v84;
  v83[1] = v86;
  uint64_t v87 = v203;
  int v203 = (std::__shared_weak_count *)v83[2];
  v83[2] = v87;
  if (v198) {
    sub_10004D2C8(v198);
  }
  *(_OWORD *)int v197 = *(_OWORD *)v202;
  __int16 v88 = v203;
  v202[0] = 0;
  v202[1] = 0;
  int v203 = 0;
  v198 = v88;
  uint64_t v199 = 0;
  uint64_t v200 = 0;
  uint64_t v201 = 8;
  char v196 = 0;
  if (!sub_10049DF74((uint64_t *)v197, &v196, 1uLL))
  {
    uint64_t v123 = *(NSObject **)a2;
    if (!os_log_type_enabled(v123, OS_LOG_TYPE_ERROR)) {
      goto LABEL_185;
    }
    unsigned __int16 v124 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v124;
    long long v125 = "[%s] Failed to read hasPlusSign";
LABEL_181:
    _os_log_error_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_ERROR, v125, (uint8_t *)&buf, 0xCu);
    goto LABEL_185;
  }
  unint64_t v195 = 0;
  if ((sub_10049E2A4((uint64_t *)v197, &v195, 0x33uLL) & 1) == 0)
  {
    uint64_t v123 = *(NSObject **)a2;
    if (!os_log_type_enabled(v123, OS_LOG_TYPE_ERROR)) {
      goto LABEL_185;
    }
    __int16 v127 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v127;
    long long v125 = "[%s] Failed to read encoded phone number";
    goto LABEL_181;
  }
  *(_OWORD *)__n128 __p = 0u;
  long long v194 = 0u;
  sub_10132CCF0(v195, (std::string *)__p);
  if (!BYTE8(v194))
  {
    __int16 v129 = *(NSObject **)a2;
    if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR))
    {
      int v163 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v163;
      __int16 v131 = "[%s] Failed to decode phone number";
      goto LABEL_222;
    }
LABEL_185:
    uint64_t v26 = 0;
    goto LABEL_186;
  }
  if (v196) {
    int v89 = "+";
  }
  else {
    int v89 = "";
  }
  sub_100058DB0(&buf, v89);
  if ((SBYTE7(v194) & 0x80u) == 0) {
    __int16 v90 = __p;
  }
  else {
    __int16 v90 = (void **)__p[0];
  }
  if ((SBYTE7(v194) & 0x80u) == 0) {
    std::string::size_type v91 = BYTE7(v194);
  }
  else {
    std::string::size_type v91 = (std::string::size_type)__p[1];
  }
  __int16 v92 = std::string::append(&buf, (const std::string::value_type *)v90, v91);
  std::string::size_type v93 = v92->__r_.__value_.__r.__words[0];
  *(void *)&long long v228 = v92->__r_.__value_.__l.__size_;
  *(void *)((char *)&v228 + 7) = *(std::string::size_type *)((char *)&v92->__r_.__value_.__r.__words[1] + 7);
  char v94 = HIBYTE(v92->__r_.__value_.__r.__words[2]);
  v92->__r_.__value_.__l.__size_ = 0;
  v92->__r_.__value_.__r.__words[2] = 0;
  v92->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  uint64_t v95 = v228;
  *(void *)(a1 + 80) = v93;
  *(void *)(a1 + 88) = v95;
  *(void *)(a1 + 95) = *(void *)((char *)&v228 + 7);
  *(unsigned char *)(a1 + 103) = v94;
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  *(unsigned char *)(a1 + 104) = 0;
  if (!sub_10049DF74((uint64_t *)v197, (unsigned char *)(a1 + 104), 4uLL))
  {
    __int16 v129 = *(NSObject **)a2;
    if (!os_log_type_enabled(v129, OS_LOG_TYPE_ERROR)) {
      goto LABEL_224;
    }
    uint64_t v130 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v130;
    __int16 v131 = "[%s] Failed to read codec ID";
    goto LABEL_222;
  }
  v176 = (void *)(a1 + 80);
  unsigned int v96 = *(unsigned __int8 *)(a1 + 104);
  if (v96 >= 0x10)
  {
    __int16 v133 = *(NSObject **)a2;
    if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
    {
      uint64_t v134 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v134;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v96;
      __int16 v131 = "[%s] Invalid codec ID: %hhu";
      __int16 v135 = v133;
      uint32_t v136 = 18;
      goto LABEL_223;
    }
    goto LABEL_224;
  }
  if (!*(unsigned char *)(a1 + 160))
  {
    unint64_t v116 = 0;
LABEL_196:
    if (v183 <= v116 + 7)
    {
      __int16 v129 = *(NSObject **)a2;
      if (!os_log_type_enabled(v129, OS_LOG_TYPE_ERROR)) {
        goto LABEL_224;
      }
      v162 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v162;
      __int16 v131 = "[%s][B] Payload is too short";
LABEL_222:
      __int16 v135 = v129;
      uint32_t v136 = 12;
      goto LABEL_223;
    }
    if ((_BYTE)v199) {
      __TUAssertTrigger();
    }
    memset(&buf, 0, sizeof(buf));
    sub_10036CCEC(&buf, (char *)v197[0] + v116 + 7, (uint64_t)v197[1], (char *)v197[1] - ((char *)v197[0] + v116 + 7));
    __int16 v137 = *(void **)(a1 + 112);
    if (v137)
    {
      *(void *)(a1 + 120) = v137;
      operator delete(v137);
      *(void *)(a1 + 112) = 0;
      *(void *)(a1 + 120) = 0;
      *(void *)(a1 + 128) = 0;
    }
    std::string::size_type v138 = buf.__r_.__value_.__r.__words[0];
    *(void *)(a1 + 112) = buf.__r_.__value_.__r.__words[0];
    std::string::size_type v139 = buf.__r_.__value_.__l.__size_;
    *(_OWORD *)(a1 + 120) = *(_OWORD *)&buf.__r_.__value_.__r.__words[1];
    if (v138 == v139) {
      __TUAssertTrigger();
    }
    long long v228 = 0uLL;
    uint64_t v229 = 0;
    sub_10008E4E8(&v228, 0x13uLL);
    CFUUIDBytes v140 = CFUUIDGetUUIDBytes((CFUUIDRef)*(void *)(*(void *)(v10 + 56) + 8));
    *(_WORD *)long long v228 = *(_WORD *)&v140.byte0;
    *(unsigned char *)(v228 + 2) = v140.byte2;
    *(unsigned char *)(v228 + 3) = v140.byte3;
    *(unsigned char *)(v228 + 4) = v140.byte4;
    *(unsigned char *)(v228 + 5) = v140.byte5;
    *(unsigned char *)(v228 + 6) = v140.byte6;
    *(unsigned char *)(v228 + 7) = v140.byte7;
    int v141 = (unsigned char *)v228;
    *(void *)(v228 + 8) = *(void *)&v140.byte8;
    v141[16] = v187;
    v141[17] = *(unsigned char *)(a1 + 49);
    v141[18] = *(unsigned char *)(a1 + 48);
    ctu::base64::encode();
    v142 = (void **)(a1 + 136);
    if (*(char *)(a1 + 159) < 0) {
      operator delete(*v142);
    }
    *(_OWORD *)v142 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
    *(void *)(a1 + 152) = *((void *)&buf.__r_.__value_.__l + 2);
    uint64_t v143 = *(void *)(a1 + 168);
    v144 = *(NSObject **)a2;
    BOOL v145 = os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT);
    if (v143)
    {
      if (v145)
      {
        v184 = sub_10093AA58(*(_DWORD *)(a1 + 12));
        std::string::size_type v188 = *(void *)(a1 + 32);
        uint64_t v146 = subscriber::asString();
        int v147 = *(unsigned __int8 *)(a1 + 44);
        int v148 = *(unsigned __int8 *)(a1 + 45);
        int v149 = *(unsigned __int8 *)(a1 + 46);
        int v178 = *(unsigned __int8 *)(a1 + 47);
        int v181 = *(unsigned __int16 *)(a1 + 48);
        ctu::hex_sp();
        if (v191 >= 0) {
          v150 = v190;
        }
        else {
          v150 = (void **)v190[0];
        }
        if (*(char *)(a1 + 103) < 0) {
          v176 = (void *)*v176;
        }
        int v151 = *(unsigned __int8 *)(a1 + 104);
        uint64_t v152 = *(void *)(a1 + 120) - *(void *)(a1 + 112);
        if (*(char *)(a1 + 159) < 0) {
          v142 = (void **)*v142;
        }
        int v153 = *(unsigned __int16 **)(a1 + 168);
        v154 = "yes";
        int v155 = *v153;
        int v156 = *((unsigned __int8 *)v153 + 3);
        if (!v186) {
          v154 = "no";
        }
        int v157 = *((unsigned __int8 *)v153 + 2);
        LODWORD(buf.__r_.__value_.__l.__data_) = 136319234;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v184;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v188;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
        uint64_t v205 = v146;
        LOWORD(v206) = 1024;
        *(_DWORD *)((char *)&v206 + 2) = v147;
        HIWORD(v206) = 1024;
        LODWORD(v207) = v148;
        WORD2(v207) = 1024;
        *(_DWORD *)((char *)&v207 + 6) = v149;
        WORD5(v207) = 1024;
        HIDWORD(v207) = v178;
        __int16 v208 = 1024;
        int v209 = v181;
        __int16 v210 = 2080;
        int v211 = v150;
        __int16 v212 = 2080;
        int v213 = v176;
        __int16 v214 = 1024;
        int v215 = v151;
        __int16 v216 = 2048;
        uint64_t v217 = v152;
        __int16 v218 = 2080;
        int v219 = v142;
        __int16 v220 = 2080;
        int v221 = v154;
        __int16 v222 = 1024;
        int v223 = v155;
        __int16 v224 = 1024;
        int v225 = v156;
        __int16 v226 = 1024;
        int v227 = v157;
        v158 = "#I [%s] Timestamp: %llu, SimSlot: %s, PendingTotalCount: %hhu, PendingCount: %hhu, UEDigest: %hhu, IWFDig"
               "est: %hhu, RatchetCounter: %hu, AuthTag: %s, SourcePhoneNumber: %s, CodecId: %hhu, Payload size: %zu, Uni"
               "queId: %s, isMMS: %s, isMultipart: true, MessageId: %hu, PartNumber: %hhu, Total Parts: %hhu";
        int v159 = v144;
        uint32_t v160 = 136;
LABEL_239:
        _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, v158, (uint8_t *)&buf, v160);
        if (v191 < 0) {
          operator delete(v190[0]);
        }
      }
    }
    else if (v145)
    {
      int v185 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      std::string::size_type v189 = *(void *)(a1 + 32);
      uint64_t v164 = subscriber::asString();
      int v165 = *(unsigned __int8 *)(a1 + 44);
      int v166 = *(unsigned __int8 *)(a1 + 45);
      int v167 = *(unsigned __int8 *)(a1 + 46);
      int v179 = *(unsigned __int8 *)(a1 + 47);
      int v182 = *(unsigned __int16 *)(a1 + 48);
      ctu::hex_sp();
      if (v191 >= 0) {
        v168 = v190;
      }
      else {
        v168 = (void **)v190[0];
      }
      if (*(char *)(a1 + 103) < 0) {
        v176 = (void *)*v176;
      }
      int v169 = *(unsigned __int8 *)(a1 + 104);
      uint64_t v170 = *(void *)(a1 + 120) - *(void *)(a1 + 112);
      if (*(char *)(a1 + 159) < 0) {
        v142 = (void **)*v142;
      }
      int v171 = "yes";
      LODWORD(buf.__r_.__value_.__l.__data_) = 136318466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v185;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
      if (!v186) {
        int v171 = "no";
      }
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v189;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      uint64_t v205 = v164;
      LOWORD(v206) = 1024;
      *(_DWORD *)((char *)&v206 + 2) = v165;
      HIWORD(v206) = 1024;
      LODWORD(v207) = v166;
      WORD2(v207) = 1024;
      *(_DWORD *)((char *)&v207 + 6) = v167;
      WORD5(v207) = 1024;
      HIDWORD(v207) = v179;
      __int16 v208 = 1024;
      int v209 = v182;
      __int16 v210 = 2080;
      int v211 = v168;
      __int16 v212 = 2080;
      int v213 = v176;
      __int16 v214 = 1024;
      int v215 = v169;
      __int16 v216 = 2048;
      uint64_t v217 = v170;
      __int16 v218 = 2080;
      int v219 = v142;
      __int16 v220 = 2080;
      int v221 = v171;
      v158 = "#I [%s] Timestamp: %llu, SimSlot: %s, PendingTotalCount: %hhu, PendingCount: %hhu, UEDigest: %hhu, IWFDiges"
             "t: %hhu, RatchetCounter: %hu, AuthTag: %s, SourcePhoneNumber: %s, CodecId: %hhu, Payload size: %zu, UniqueI"
             "d: %s, isMMS: %s, isMultipart: false";
      int v159 = v144;
      uint32_t v160 = 118;
      goto LABEL_239;
    }
    if ((void)v228)
    {
      *((void *)&v228 + 1) = v228;
      operator delete((void *)v228);
    }
    uint64_t v26 = 1;
    goto LABEL_225;
  }
  LOBYTE(v228) = 0;
  if (!sub_10049DF74((uint64_t *)v197, &v228, 8uLL))
  {
    __int16 v129 = *(NSObject **)a2;
    if (!os_log_type_enabled(v129, OS_LOG_TYPE_ERROR)) {
      goto LABEL_224;
    }
    int v161 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v161;
    __int16 v131 = "[%s] Failed to read userDataHeaderLength";
    goto LABEL_222;
  }
  unint64_t v97 = 0;
  unint64_t v177 = v228;
  while (1)
  {
    if (v97 >= v177) {
      goto LABEL_164;
    }
    LOBYTE(v190[0]) = 0;
    if (!sub_10049DF74((uint64_t *)v197, v190, 8uLL))
    {
      __int16 v129 = *(NSObject **)a2;
      if (!os_log_type_enabled(v129, OS_LOG_TYPE_ERROR)) {
        goto LABEL_224;
      }
      v172 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v172;
      __int16 v131 = "[%s] Failed to read informationElementId";
      goto LABEL_222;
    }
    unsigned __int8 v192 = 0;
    if (!sub_10049DF74((uint64_t *)v197, &v192, 8uLL))
    {
      __int16 v129 = *(NSObject **)a2;
      if (!os_log_type_enabled(v129, OS_LOG_TYPE_ERROR)) {
        goto LABEL_224;
      }
      int v173 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v173;
      __int16 v131 = "[%s] Failed to read lengthOfInformationElement";
      goto LABEL_222;
    }
    int v98 = LOBYTE(v190[0]);
    uint64_t v180 = v192;
    if ((LOBYTE(v190[0]) | 8) == 8) {
      break;
    }
    sub_1004A3DDC((uint64_t)v197, v192);
    int v105 = 50;
LABEL_162:
    v97 += v180;
    if (v105 != 50)
    {
      if (v105 != 51) {
        goto LABEL_224;
      }
LABEL_164:
      unint64_t v116 = v177 + 1;
      goto LABEL_196;
    }
  }
  if (LOBYTE(v190[0])) {
    int v99 = 4;
  }
  else {
    int v99 = 3;
  }
  if (v99 == v192)
  {
    unint64_t v100 = (char *)operator new(0x20uLL);
    *((void *)v100 + 1) = 0;
    *((void *)v100 + 2) = 0;
    *(void *)unint64_t v100 = off_1019D3688;
    *((_DWORD *)v100 + 6) = 0;
    uint64_t v101 = v100 + 24;
    if (v98) {
      unint64_t v102 = 16;
    }
    else {
      unint64_t v102 = 8;
    }
    if (sub_10036C2D8((uint64_t *)v197, v101, v102))
    {
      int v103 = v100 + 26;
      if (sub_10049DF74((uint64_t *)v197, v100 + 26, 8uLL))
      {
        if (sub_10049DF74((uint64_t *)v197, v100 + 27, 8uLL))
        {
          if (*v103 && *v103 > (v100[27] - 1))
          {
            atomic_fetch_add_explicit((atomic_ullong *volatile)v100 + 1, 1uLL, memory_order_relaxed);
            int v104 = *(std::__shared_weak_count **)(a1 + 176);
            *(void *)(a1 + 168) = v101;
            *(void *)(a1 + 176) = v100;
            if (v104) {
              sub_10004D2C8(v104);
            }
            int v105 = 51;
            goto LABEL_161;
          }
          os_log_t v114 = *(os_log_t *)a2;
          if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
          {
            CFArrayRef v115 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v115;
            uint64_t v108 = v114;
            int v109 = "[%s] Provided multiPart info is invalid";
LABEL_159:
            _os_log_error_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_ERROR, v109, (uint8_t *)&buf, 0xCu);
          }
        }
        else
        {
          os_log_t v112 = *(os_log_t *)a2;
          if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
          {
            uint64_t v113 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v113;
            uint64_t v108 = v112;
            int v109 = "[%s] Failed to read PartNumber";
            goto LABEL_159;
          }
        }
      }
      else
      {
        os_log_t v110 = *(os_log_t *)a2;
        if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
        {
          int v111 = sub_10093AA58(*(_DWORD *)(a1 + 12));
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v111;
          uint64_t v108 = v110;
          int v109 = "[%s] Failed to read TotalParts";
          goto LABEL_159;
        }
      }
    }
    else
    {
      os_log_t v106 = *(os_log_t *)a2;
      if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
      {
        uint64_t v107 = sub_10093AA58(*(_DWORD *)(a1 + 12));
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v107;
        uint64_t v108 = v106;
        int v109 = "[%s] Failed to read MessageID";
        goto LABEL_159;
      }
    }
    int v105 = 1;
LABEL_161:
    sub_10004D2C8((std::__shared_weak_count *)v100);
    goto LABEL_162;
  }
  v174 = *(NSObject **)a2;
  if (!os_log_type_enabled(v174, OS_LOG_TYPE_ERROR)) {
    goto LABEL_224;
  }
  int v175 = sub_10093AA58(*(_DWORD *)(a1 + 12));
  LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v175;
  WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
  *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v99;
  WORD1(buf.__r_.__value_.__r.__words[2]) = 1024;
  HIDWORD(buf.__r_.__value_.__r.__words[2]) = v180;
  __int16 v131 = "[%s] Expected lengthOfMultiPartHeader to be %hhu, but it is: %hhu";
  __int16 v135 = v174;
  uint32_t v136 = 24;
LABEL_223:
  _os_log_error_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_ERROR, v131, (uint8_t *)&buf, v136);
LABEL_224:
  uint64_t v26 = 0;
LABEL_225:
  if (BYTE8(v194) && SBYTE7(v194) < 0) {
    operator delete(__p[0]);
  }
LABEL_186:
  if (v197[0])
  {
    v197[1] = v197[0];
    operator delete(v197[0]);
  }
LABEL_104:
  if (v202[0])
  {
    v202[1] = v202[0];
    operator delete(v202[0]);
  }
LABEL_27:
  if (v8) {
    sub_10004D2C8(v8);
  }
  return v26;
}

void sub_1004A3CAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  uint64_t v52 = *(void **)(v50 - 128);
  if (v52)
  {
    *(void *)(v50 - 120) = v52;
    operator delete(v52);
  }
  if (a31 && a30 < 0) {
    operator delete(__p);
  }
  if (a34) {
    operator delete(a34);
  }
  if (a40) {
    operator delete(a40);
  }
  if (v49) {
    sub_10004D2C8(v49);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004A3DDC(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = 0;
    unint64_t v3 = *(void *)(result + 8) - *(void *)result;
    unint64_t v4 = *(void *)(result + 32);
    unint64_t v5 = *(void *)(result + 40);
    while (2)
    {
      unint64_t v6 = 8;
      while (1)
      {
        if (!v5)
        {
          *(void *)(result + 32) = ++v4;
          *(void *)(result + 40) = 8;
          unint64_t v5 = 8;
        }
        if (v4 >= v3)
        {
          *(unsigned char *)(result + 24) = 1;
          return result;
        }
        unint64_t v7 = v6 - v5;
        if (v6 <= v5) {
          break;
        }
        unint64_t v5 = 0;
        *(void *)(result + 40) = 0;
        unint64_t v6 = v7;
        if (v7 - 9 < 0xFFFFFFFFFFFFFFF8) {
          __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
        }
      }
      v5 -= v6;
      *(void *)(result + 40) = v5;
      if (++v2 != a2) {
        continue;
      }
      break;
    }
  }
  return result;
}

uint64_t sub_1004A3E88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1004A2564(a1 - 16, a2, a3);
}

uint64_t sub_1004A3E90(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_1004A3E9C()
{
}

uint64_t sub_1004A3EB0(uint64_t a1)
{
  *(void *)a1 = off_1019D36F8;
  *(void *)(a1 + 16) = &unk_1019D37A0;
  sub_10012577C((const void **)(a1 + 32));
  return a1;
}

void sub_1004A3F18(uint64_t a1)
{
  *(void *)a1 = off_1019D36F8;
  *(void *)(a1 + 16) = &unk_1019D37A0;
  sub_10012577C((const void **)(a1 + 32));

  operator delete();
}

const void **sub_1004A3FA0(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1019D36F8;
  *(void *)a1 = &unk_1019D37A0;
  return sub_10012577C((const void **)(a1 + 16));
}

void sub_1004A3FE0(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1019D36F8;
  *(void *)a1 = &unk_1019D37A0;
  sub_10012577C((const void **)(a1 + 16));

  operator delete();
}

uint64_t sub_1004A4060(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_1004A406C()
{
}

void sub_1004A4080(uint64_t a1)
{
  *(void *)a1 = off_1019D3880;
  *(void *)(a1 + 16) = &unk_1019D38E8;
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(void *)(a1 + 72) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void **)(a1 + 32);
  sub_100274E3C(&v3);
  operator delete();
}

void sub_1004A411C(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1019D3880;
  *(void *)a1 = &unk_1019D38E8;
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void **)(a1 + 16);
  sub_100274E3C(&v3);
}

void sub_1004A41A0(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1019D3880;
  *(void *)a1 = &unk_1019D38E8;
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void **)(a1 + 16);
  sub_100274E3C(&v3);
  operator delete();
}

uint64_t sub_1004A423C(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_1004A4248()
{
}

void *sub_1004A425C(void *a1)
{
  *a1 = off_1019D2820;
  a1[2] = &unk_1019D28C8;
  uint64_t v2 = (std::__shared_weak_count *)a1[12];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unint64_t v3 = (void *)a1[8];
  if (v3)
  {
    a1[9] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1004A42D8(void *a1)
{
  *a1 = off_1019D2820;
  a1[2] = &unk_1019D28C8;
  uint64_t v2 = (std::__shared_weak_count *)a1[12];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unint64_t v3 = (void *)a1[8];
  if (v3)
  {
    a1[9] = v3;
    operator delete(v3);
  }

  operator delete();
}

void sub_1004A4374(void *a1)
{
  *(a1 - 2) = off_1019D2820;
  *a1 = &unk_1019D28C8;
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unint64_t v3 = (void *)a1[6];
  if (v3)
  {
    a1[7] = v3;
    operator delete(v3);
  }
}

void sub_1004A43EC(void *a1)
{
  *(a1 - 2) = off_1019D2820;
  *a1 = &unk_1019D28C8;
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unint64_t v3 = (void *)a1[6];
  if (v3)
  {
    a1[7] = v3;
    operator delete(v3);
  }

  operator delete();
}

uint64_t sub_1004A4488(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_1004A4494()
{
}

void sub_1004A44A8(void *a1)
{
  *a1 = off_1019D3988;
  a1[2] = &unk_1019D39F0;
  uint64_t v2 = (void *)a1[10];
  if (v2)
  {
    a1[11] = v2;
    operator delete(v2);
  }

  operator delete();
}

void sub_1004A4538(void *a1)
{
  *(a1 - 2) = off_1019D3988;
  *a1 = &unk_1019D39F0;
  uint64_t v1 = (void *)a1[8];
  if (v1)
  {
    a1[9] = v1;
    operator delete(v1);
  }
}

void sub_1004A459C(void *a1)
{
  *(a1 - 2) = off_1019D3988;
  *a1 = &unk_1019D39F0;
  uint64_t v1 = (void *)a1[8];
  if (v1)
  {
    a1[9] = v1;
    operator delete(v1);
  }

  operator delete();
}

uint64_t sub_1004A462C(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_1004A4638()
{
}

void *sub_1004A464C(void *a1)
{
  *a1 = off_1019D2CA8;
  a1[2] = &unk_1019D2D50;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1004A46BC(void *a1)
{
  *a1 = off_1019D2CA8;
  a1[2] = &unk_1019D2D50;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }

  operator delete();
}

void sub_1004A474C(void *a1)
{
  *(a1 - 2) = off_1019D2CA8;
  *a1 = &unk_1019D2D50;
  uint64_t v1 = (void *)a1[2];
  if (v1)
  {
    a1[3] = v1;
    operator delete(v1);
  }
}

void sub_1004A47B0(void *a1)
{
  *(a1 - 2) = off_1019D2CA8;
  *a1 = &unk_1019D2D50;
  uint64_t v1 = (void *)a1[2];
  if (v1)
  {
    a1[3] = v1;
    operator delete(v1);
  }

  operator delete();
}

uint64_t sub_1004A4840(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_1004A484C()
{
}

void sub_1004A4864()
{
}

void sub_1004A487C()
{
}

uint64_t sub_1004A4894(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

uint64_t sub_1004A489C(uint64_t a1)
{
  *(void *)a1 = off_1019D23D0;
  *(void *)(a1 + 16) = &unk_1019D2478;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 112);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(unsigned char *)(a1 + 96))
  {
    unint64_t v3 = *(void **)(a1 + 72);
    if (v3)
    {
      *(void *)(a1 + 80) = v3;
      operator delete(v3);
    }
  }
  if (*(unsigned char *)(a1 + 64))
  {
    unint64_t v4 = *(void **)(a1 + 40);
    if (v4)
    {
      *(void *)(a1 + 48) = v4;
      operator delete(v4);
    }
  }
  sub_10012577C((const void **)(a1 + 32));
  return a1;
}

void sub_1004A4940(uint64_t a1)
{
  *(void *)a1 = off_1019D23D0;
  *(void *)(a1 + 16) = &unk_1019D2478;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 112);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(unsigned char *)(a1 + 96))
  {
    unint64_t v3 = *(void **)(a1 + 72);
    if (v3)
    {
      *(void *)(a1 + 80) = v3;
      operator delete(v3);
    }
  }
  if (*(unsigned char *)(a1 + 64))
  {
    unint64_t v4 = *(void **)(a1 + 40);
    if (v4)
    {
      *(void *)(a1 + 48) = v4;
      operator delete(v4);
    }
  }
  sub_10012577C((const void **)(a1 + 32));

  operator delete();
}

const void **sub_1004A4A04(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1019D23D0;
  *(void *)a1 = &unk_1019D2478;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(unsigned char *)(a1 + 80))
  {
    unint64_t v3 = *(void **)(a1 + 56);
    if (v3)
    {
      *(void *)(a1 + 64) = v3;
      operator delete(v3);
    }
  }
  if (*(unsigned char *)(a1 + 48))
  {
    unint64_t v4 = *(void **)(a1 + 24);
    if (v4)
    {
      *(void *)(a1 + 32) = v4;
      operator delete(v4);
    }
  }

  return sub_10012577C((const void **)(a1 + 16));
}

void sub_1004A4AB0(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1019D23D0;
  *(void *)a1 = &unk_1019D2478;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(unsigned char *)(a1 + 80))
  {
    unint64_t v3 = *(void **)(a1 + 56);
    if (v3)
    {
      *(void *)(a1 + 64) = v3;
      operator delete(v3);
    }
  }
  if (*(unsigned char *)(a1 + 48))
  {
    unint64_t v4 = *(void **)(a1 + 24);
    if (v4)
    {
      *(void *)(a1 + 32) = v4;
      operator delete(v4);
    }
  }
  sub_10012577C((const void **)(a1 + 16));

  operator delete();
}

uint64_t sub_1004A4B74(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_1004A4B80()
{
}

uint64_t sub_1004A4B94(uint64_t a1)
{
  *(void *)a1 = off_1019D3190;
  *(void *)(a1 + 16) = &unk_1019D3238;
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  return a1;
}

void sub_1004A4C14(uint64_t a1)
{
  *(void *)a1 = off_1019D3190;
  *(void *)(a1 + 16) = &unk_1019D3238;
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }

  operator delete();
}

void sub_1004A4CB4(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1019D3190;
  *(void *)a1 = &unk_1019D3238;
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
}

void sub_1004A4D30(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1019D3190;
  *(void *)a1 = &unk_1019D3238;
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

uint64_t sub_1004A4DD0(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_1004A4DDC()
{
}

uint64_t sub_1004A4DF0(uint64_t a1)
{
  *(void *)a1 = off_1019D3A90;
  *(void *)(a1 + 16) = &unk_1019D3AF8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 176);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  unint64_t v3 = *(void **)(a1 + 112);
  if (v3)
  {
    *(void *)(a1 + 120) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  unint64_t v4 = *(void **)(a1 + 56);
  if (v4)
  {
    *(void *)(a1 + 64) = v4;
    operator delete(v4);
  }
  return a1;
}

void sub_1004A4E9C(uint64_t a1)
{
  *(void *)a1 = off_1019D3A90;
  *(void *)(a1 + 16) = &unk_1019D3AF8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 176);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  unint64_t v3 = *(void **)(a1 + 112);
  if (v3)
  {
    *(void *)(a1 + 120) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  unint64_t v4 = *(void **)(a1 + 56);
  if (v4)
  {
    *(void *)(a1 + 64) = v4;
    operator delete(v4);
  }

  operator delete();
}

void sub_1004A4F68(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1019D3A90;
  *(void *)a1 = &unk_1019D3AF8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 160);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  unint64_t v3 = *(void **)(a1 + 96);
  if (v3)
  {
    *(void *)(a1 + 104) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  unint64_t v4 = *(void **)(a1 + 40);
  if (v4)
  {
    *(void *)(a1 + 48) = v4;
    operator delete(v4);
  }
}

void sub_1004A5010(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1019D3A90;
  *(void *)a1 = &unk_1019D3AF8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 160);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  unint64_t v3 = *(void **)(a1 + 96);
  if (v3)
  {
    *(void *)(a1 + 104) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  unint64_t v4 = *(void **)(a1 + 40);
  if (v4)
  {
    *(void *)(a1 + 48) = v4;
    operator delete(v4);
  }

  operator delete();
}

BOOL sub_1004A50DC(uint64_t *a1, uint64_t *a2)
{
  char v17 = 0;
  unint64_t v4 = a2[1] - *a2;
  if (v4 > 0xF)
  {
    if (v4 != 16) {
      a2[1] = *a2 + 16;
    }
  }
  else
  {
    sub_1004A5238(a2, 16 - v4, &v17);
  }
  BOOL v5 = 0;
  unint64_t v6 = 0;
LABEL_6:
  uint64_t v7 = *a2;
  unint64_t v8 = 8;
  while (1)
  {
    unint64_t v9 = a1[4];
    unint64_t v10 = a1[5];
    if (!v10)
    {
      a1[4] = ++v9;
      a1[5] = 8;
      unint64_t v10 = 8;
    }
    uint64_t v11 = *a1;
    if (v9 >= a1[1] - *a1) {
      break;
    }
    unint64_t v12 = v8 - v10;
    if (v8 <= v10)
    {
      a1[5] = v10 - v8;
      int v14 = *(unsigned __int8 *)(v11 + v9) >> (v10 - v8);
      if (v8 < 8) {
        char v15 = ~(-1 << v8);
      }
      else {
        char v15 = -1;
      }
      *(unsigned char *)(v7 + v6) |= v14 & v15;
      BOOL v5 = v6++ > 0xE;
      if (v6 == 16) {
        return 1;
      }
      goto LABEL_6;
    }
    unsigned int v13 = *(unsigned __int8 *)(v11 + v9) & ~(-1 << v10);
    a1[5] = 0;
    *(unsigned char *)(v7 + v6) |= v13 << v12;
    unint64_t v8 = v12;
    if (v12 - 9 < 0xFFFFFFFFFFFFFFF8) {
      __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
    }
  }
  *((unsigned char *)a1 + 24) = 1;
  return v5;
}

void sub_1004A5238(void *a1, unint64_t a2, unsigned char *a3)
{
  unint64_t v4 = a2;
  uint64_t v7 = (unsigned char *)a1[1];
  uint64_t v6 = a1[2];
  if (v6 - (uint64_t)v7 >= a2)
  {
    if (a2)
    {
      unsigned int v13 = &v7[a2];
      do
      {
        *v7++ = *a3;
        --v4;
      }
      while (v4);
      uint64_t v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = &v7[-*a1];
    unint64_t v9 = (unint64_t)&v8[a2];
    if ((uint64_t)&v8[a2] < 0) {
      sub_10006A748();
    }
    unint64_t v10 = v6 - *a1;
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v9;
    }
    if (v11) {
      unint64_t v12 = operator new(v11);
    }
    else {
      unint64_t v12 = 0;
    }
    int v14 = &v8[(void)v12];
    char v15 = &v8[(void)v12 + v4];
    uint64_t v16 = &v8[(void)v12];
    do
    {
      *v16++ = *a3;
      --v4;
    }
    while (v4);
    char v17 = (unsigned char *)*a1;
    if (v7 != (unsigned char *)*a1)
    {
      do
      {
        char v18 = *--v7;
        *--int v14 = v18;
      }
      while (v7 != v17);
      uint64_t v7 = (unsigned char *)*a1;
    }
    *a1 = v14;
    a1[1] = v15;
    a1[2] = (char *)v12 + v11;
    if (v7)
    {
      operator delete(v7);
    }
  }
}

void sub_1004A5368()
{
}

void *sub_1004A537C(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = off_1019D35F8;
  result[1] = v3;
  return result;
}

uint64_t sub_1004A53C4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D35F8;
  a2[1] = v2;
  return result;
}

void sub_1004A53F0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  unint64_t v4 = *(unint64_t **)(a1 + 8);
  sub_10024081C(v4, BYTE6(*a3), 8uLL);
  sub_10024081C(v4, BYTE5(v3), 8uLL);
  sub_10024081C(v4, BYTE4(v3), 8uLL);
  sub_10024081C(v4, BYTE3(v3), 8uLL);
  sub_10024081C(v4, BYTE2(v3), 8uLL);
  sub_10024081C(v4, BYTE1(v3), 8uLL);

  sub_10024081C(v4, v3, 8uLL);
}

uint64_t sub_1004A5490(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1004A54D0()
{
}

void *sub_1004A54DC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1004A5560(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D3688;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004A5580(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D3688;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004A55DC(uint64_t a1, Registry *this)
{
  *(void *)a1 = &off_1019D3CF0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(this);
  unint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v5;
  unint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v15);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  unint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 88))(v11);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  *(_DWORD *)(a1 + 8) = v13;
  return a1;
}

void sub_1004A5708(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004A5724(void *a1, Registry *this)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(this);
  unint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v5;
  unint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v12);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v11 = 0;
    unint64_t v10 = 0;
  }
  std::mutex::unlock(v4);
  *a1 = v11;
  a1[1] = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
}

uint64_t sub_1004A57F8(uint64_t a1, unsigned __int8 *a2)
{
  if (*(char *)(a1 + 63) < 0)
  {
    sub_10004FC84(&__dst, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    long long __dst = *(_OWORD *)(a1 + 40);
    uint64_t v9 = *(void *)(a1 + 56);
  }
  if (*(char *)(a1 + 39) < 0)
  {
    sub_10004FC84(&v10, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    long long v10 = *(_OWORD *)(a1 + 16);
    v11[0] = *(void *)(a1 + 32);
  }
  sub_1004AD8F8((uint64_t)v7, (void **)&__dst, 2);
  uint64_t v4 = sub_100145EC0(a2, v7);
  sub_10005CD2C((uint64_t)v7, (char *)v7[1]);
  for (uint64_t i = 0; i != -6; i -= 3)
  {
    if (SHIBYTE(v11[i]) < 0) {
      operator delete((void *)v11[i - 2]);
    }
  }
  return v4;
}

void sub_1004A5910(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004A5978(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a1 + 87);
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = *(unsigned __int8 *)(a1 + 87);
  }
  else {
    uint64_t v3 = *(void *)(a1 + 72);
  }
  uint64_t v4 = *(unsigned __int8 *)(a2 + 87);
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a2 + 72);
  }
  if (v3 != v4) {
    return 0;
  }
  uint64_t v6 = (const void **)(a1 + 64);
  uint64_t v9 = *(unsigned __int8 **)(a2 + 64);
  uint64_t v7 = (unsigned __int8 *)(a2 + 64);
  unsigned int v8 = v9;
  if (v5 < 0) {
    uint64_t v7 = v8;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*v6, v7, *(void *)(a1 + 72)) == 0;
  }
  if (!*(unsigned char *)(a1 + 87)) {
    return 1;
  }
  uint64_t v10 = v2 - 1;
  do
  {
    int v12 = *(unsigned __int8 *)v6;
    uint64_t v6 = (const void **)((char *)v6 + 1);
    int v11 = v12;
    int v14 = *v7++;
    int v13 = v14;
    BOOL v16 = v10-- != 0;
    uint64_t result = v11 == v13;
  }
  while (v11 == v13 && v16);
  return result;
}

const void **sub_1004A5A1C(void *a1, char *a2)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  unint64_t v20 = Mutable;
  int v5 = a2 + 40;
  if (a2[63] < 0) {
    int v5 = *(const char **)v5;
  }
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&value, v5);
  CFDictionarySetValue(Mutable, @"CmamText", value);
  ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)&value);
  uint64_t v6 = a2 + 16;
  if (a2[39] < 0) {
    uint64_t v6 = *(const char **)v6;
  }
  uint64_t v7 = v20;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&value, v6);
  CFDictionarySetValue(v7, @"CmamLongText", value);
  ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)&value);
  unsigned int v8 = a2 + 112;
  if (a2[135] < 0) {
    unsigned int v8 = *(const char **)v8;
  }
  uint64_t v9 = v20;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&value, v8);
  CFDictionarySetValue(v9, @"Headline", value);
  ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)&value);
  uint64_t v10 = a2 + 160;
  if (a2[183] < 0) {
    uint64_t v10 = *(const char **)v10;
  }
  int v11 = v20;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&value, v10);
  CFDictionarySetValue(v11, @"Description", value);
  ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)&value);
  int v12 = a2 + 136;
  if (a2[159] < 0) {
    int v12 = *(const char **)v12;
  }
  int v13 = v20;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&value, v12);
  CFDictionarySetValue(v13, @"Instruction", value);
  ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)&value);
  int v14 = a2 + 208;
  if (a2[231] < 0) {
    int v14 = *(const char **)v14;
  }
  unint64_t v15 = v20;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&value, v14);
  CFDictionarySetValue(v15, @"ExpiryTimestamp", value);
  ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)&value);
  BOOL v16 = a2 + 184;
  if (a2[207] < 0) {
    BOOL v16 = *(const char **)v16;
  }
  char v17 = v20;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&value, v16);
  CFDictionarySetValue(v17, @"EffectiveTimestamp", value);
  ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)&value);
  sub_10004EFE4(a1, (CFTypeRef *)&v20);
  return sub_10005717C((const void **)&v20);
}

void sub_1004A5C14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1004A5C6C(void *a1, uint64_t a2)
{
  uint64_t v44 = 0;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  *(_OWORD *)unint64_t v32 = 0u;
  long long v33 = 0u;
  memset(v31, 0, sizeof(v31));
  long long v30 = 0u;
  sub_10004BD84((uint64_t)&v30);
  sub_10004B96C(v31, (uint64_t)"Safety alert details - ", 23);
  uint64_t v4 = sub_10004B96C(v31, (uint64_t)" [Unique ID]: ", 14);
  sub_1004A60C8(&__p, a2 + 64);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v4, (uint64_t)p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  uint64_t v7 = sub_10004B96C(v31, (uint64_t)" [Session ID]: ", 15);
  sub_1004A60C8(&__p, a2 + 88);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unsigned int v8 = &__p;
  }
  else {
    unsigned int v8 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v9 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v9 = __p.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v7, (uint64_t)v8, v9);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  uint64_t v10 = sub_10004B96C(v31, (uint64_t)" [CMAM Text]: ", 14);
  sub_1004A60C8(&__p, a2 + 40);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v11 = &__p;
  }
  else {
    int v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v12 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v12 = __p.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v10, (uint64_t)v11, v12);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  int v13 = sub_10004B96C(v31, (uint64_t)" [CMAM Long Text]: ", 19);
  sub_1004A60C8(&__p, a2 + 16);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v14 = &__p;
  }
  else {
    int v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v15 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v15 = __p.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v13, (uint64_t)v14, v15);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  BOOL v16 = sub_10004B96C(v31, (uint64_t)" [Instruction]: ", 16);
  sub_1004A60C8(&__p, a2 + 136);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v17 = &__p;
  }
  else {
    char v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v18 = __p.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v16, (uint64_t)v17, v18);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  unint64_t v19 = sub_10004B96C(v31, (uint64_t)" [WEA handling type]: ", 22);
  uint64_t v20 = *(int *)(a2 + 236);
  if (v20 > 6) {
    unint64_t v21 = "???";
  }
  else {
    unint64_t v21 = off_1019D3F00[v20];
  }
  size_t v22 = strlen(v21);
  sub_10004B96C(v19, (uint64_t)v21, v22);
  unint64_t v23 = sub_10004B96C(v31, (uint64_t)" [Language]: ", 13);
  uint64_t v24 = *(int *)(a2 + 284);
  if (v24 > 2) {
    uint64_t v25 = "???";
  }
  else {
    uint64_t v25 = off_1019D3F38[v24];
  }
  size_t v26 = strlen(v25);
  sub_10004B96C(v23, (uint64_t)v25, v26);
  sub_10004BC98((uint64_t)v31 + 8, a1);
  *(void *)((char *)&v31[-1]
  *(void *)&v31[0] = v27;
  if (SHIBYTE(v33) < 0) {
    operator delete(v32[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1004A6078(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10008248C((uint64_t)&a16);
  _Unwind_Resume(a1);
}

double sub_1004A60C8(std::string *a1, uint64_t a2)
{
  memset(&__dst, 0, sizeof(__dst));
  if (*(char *)(a2 + 23) < 0) {
    sub_10004FC84(&__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __dst = *(std::string *)a2;
  }
  std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __dst.__r_.__value_.__l.__size_;
  }
  if (size < 7)
  {
    *(void *)&long long v14 = __dst.__r_.__value_.__r.__words[0];
    *a1 = __dst;
  }
  else
  {
    std::string::resize(&__dst, 6uLL, 0);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v5 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    }
    else {
      size_t v5 = __dst.__r_.__value_.__l.__size_;
    }
    memset(&v17, 0, sizeof(v17));
    uint64_t v6 = &v17;
    sub_1000C140C((uint64_t)&v17, v5 + 4);
    if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v6 = (std::string *)v17.__r_.__value_.__r.__words[0];
    }
    if (v5)
    {
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_dst = &__dst;
      }
      else {
        p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      memmove(v6, p_dst, v5);
    }
    strcpy((char *)v6 + v5, "...[");
    if (*(char *)(a2 + 23) >= 0) {
      unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      unint64_t v8 = *(void *)(a2 + 8);
    }
    std::to_string(&__p, v8);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v10 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v10 = __p.__r_.__value_.__l.__size_;
    }
    int v11 = std::string::append(&v17, (const std::string::value_type *)p_p, v10);
    long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v18.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    int v13 = std::string::append(&v18, "]", 1uLL);
    long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    *a1 = *v13;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v18.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v17.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  return *(double *)&v14;
}

void sub_1004A62A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (*(char *)(v26 - 41) < 0) {
    operator delete(*(void **)(v26 - 64));
  }
  _Unwind_Resume(exception_object);
}

char *sub_1004A6310@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[87] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 8), *((void *)result + 9));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 4);
  *(void *)(a2 + 16) = *((void *)result + 10);
  return result;
}

uint64_t sub_1004A633C(uint64_t a1, Registry *a2, std::__shared_weak_count *a3, int a4, long long *a5, long long *a6)
{
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1004A55DC(a1, a2);
  if (a3) {
    sub_10004D2C8(a3);
  }
  *(void *)a1 = &off_1019D3D50;
  *(_DWORD *)(a1 + 12) = a4;
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 16), *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v11 = *a5;
    *(void *)(a1 + 32) = *((void *)a5 + 2);
    *(_OWORD *)(a1 + 16) = v11;
  }
  long long v12 = (unsigned char *)(a1 + 40);
  if (*((char *)a6 + 23) < 0)
  {
    sub_10004FC84(v12, *(void **)a6, *((void *)a6 + 1));
  }
  else
  {
    long long v13 = *a6;
    *(void *)(a1 + 56) = *((void *)a6 + 2);
    *(_OWORD *)long long v12 = v13;
  }
  return a1;
}

void sub_1004A6418(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004A6448(uint64_t a1, unsigned __int8 *a2)
{
  if (*(char *)(a1 + 39) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 16);
    uint64_t v7 = *(void *)(a1 + 32);
  }
  sub_1004AD8F8((uint64_t)v5, __p, 1);
  uint64_t v3 = sub_100145EC0(a2, v5);
  sub_10005CD2C((uint64_t)v5, (char *)v5[1]);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
  return v3;
}

void sub_1004A650C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
}

char *sub_1004A6544@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[63] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 5), *((void *)result + 6));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 40);
  *(void *)(a2 + 16) = *((void *)result + 7);
  return result;
}

uint64_t CellBroadcastConfig::handleAppleSafetyAlert(uint64_t a1, void *a2)
{
  if (*a2) {
    uint64_t v2 = sub_100080778;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    v8[0] = a2;
    v8[1] = a1;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    void v9[2] = sub_1004ADAB8;
    v9[3] = &unk_1019D3DB0;
    void v9[4] = a1 + 8;
    void v9[5] = v8;
    std::string::size_type v10 = v9;
    uint64_t v4 = a1 + 24;
    uint64_t v3 = *(NSObject **)(a1 + 24);
    if (*(void *)(v4 + 8))
    {
      uint64_t v17 = 0;
      block = _NSConcreteStackBlock;
      uint64_t v12 = 0x40000000;
      long long v13 = sub_1004AF768;
      long long v14 = &unk_1019D3DF0;
      std::string::size_type v15 = &v17;
      BOOL v16 = &v10;
      dispatch_async_and_wait(v3, &block);
    }
    else
    {
      uint64_t v17 = 0;
      block = _NSConcreteStackBlock;
      uint64_t v12 = 0x40000000;
      long long v13 = sub_1004AF72C;
      long long v14 = &unk_1019D3DD0;
      std::string::size_type v15 = &v17;
      BOOL v16 = &v10;
      dispatch_sync(v3, &block);
    }
    return v17;
  }
  else
  {
    uint64_t v5 = 0x5E00000001;
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(block) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Missing apple safety alert dict", (uint8_t *)&block, 2u);
    }
  }
  return v5;
}

BOOL CellBroadcastConfig::getEnhancedDeliverySwitchState_sync(uint64_t a1, const void **a2, const void **a3)
{
  uint64_t v6 = *a2;
  *a2 = 0;
  *(void *)&long long keys = v6;
  sub_1000558F4((const void **)&keys);
  uint64_t v7 = *a3;
  *a3 = 0;
  *(void *)&long long keys = v7;
  sub_100057D78((const void **)&keys);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 240));
  std::string::size_type v9 = ServiceMap;
  if (v10 < 0)
  {
    long long v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long keys = v10;
  long long v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&keys);
  if (v14)
  {
    uint64_t v15 = v14[3];
    BOOL v16 = (std::__shared_weak_count *)v14[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v89 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v9);
  BOOL v16 = 0;
  char v89 = 1;
LABEL_9:
  __int16 v88 = v16;
  if (v15)
  {
    uint64_t v97 = 0;
    int v98 = 0;
    Registry::getMobileHelper(&v97, *(Registry **)(a1 + 240));
    if (!v97)
    {
      int v48 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        LOWORD(keys) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "Mobile helper is absent", (uint8_t *)&keys, 2u);
      }
      BOOL v47 = 0;
      goto LABEL_77;
    }
    uint64_t v87 = (CellBroadcastConfig *)a1;
    CFDictionaryRef theDict = 0;
    subscriber::makeSimSlotRange();
    uint64_t v17 = (unsigned int *)*((void *)&keys + 1);
    std::string v18 = (unsigned int *)keys;
    if ((void)keys != *((void *)&keys + 1))
    {
      unint64_t v19 = v101;
      while ((v19(*v18) & 1) == 0)
      {
        if (++v18 == v17)
        {
          std::string v18 = v17;
          break;
        }
      }
      uint64_t v20 = (unsigned int *)*((void *)&keys + 1);
      while (v18 != v20)
      {
        uint64_t v21 = *v18;
        size_t v22 = operator new(8uLL);
        std::string __p = v22;
        *size_t v22 = @"CellBroadcast";
        __int16 v92 = v22 + 1;
        std::string::size_type v93 = v22 + 1;
        (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v15 + 104))(&v94, v15, v21, 2, &__p, 0, 0);
        sub_10004EFE4(&v95, &v94);
        *(void *)std::string buf = theDict;
        unint64_t v23 = v95;
        uint64_t v95 = 0;
        CFDictionaryRef theDict = (CFDictionaryRef)v23;
        sub_100057D78((const void **)buf);
        sub_100057D78((const void **)&v95);
        sub_1000577C4(&v94);
        if (__p)
        {
          __int16 v92 = __p;
          operator delete(__p);
        }
        if (theDict) {
          uint64_t v24 = sub_100080778;
        }
        else {
          uint64_t v24 = 0;
        }
        if (v24) {
          break;
        }
        uint64_t v25 = v18 + 1;
        std::string v18 = v17;
        if (v25 != v17)
        {
          std::string v18 = v25;
          while ((v19(*v18) & 1) == 0)
          {
            if (++v18 == v17)
            {
              std::string v18 = v17;
              break;
            }
          }
        }
      }
    }
    if (theDict) {
      uint64_t v26 = sub_100080778;
    }
    else {
      uint64_t v26 = 0;
    }
    if (v26)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"AlertTypes");
      CFDictionaryRef v28 = Value;
      if (Value)
      {
        CFTypeID v29 = CFGetTypeID(Value);
        if (v29 == CFDictionaryGetTypeID())
        {
          CFIndex Count = CFDictionaryGetCount(v28);
          long long keys = 0uLL;
          uint64_t v101 = 0;
          std::string __p = 0;
          sub_10039E2FC(&keys, Count, &__p);
          std::string __p = 0;
          __int16 v92 = 0;
          std::string::size_type v93 = 0;
          *(void *)std::string buf = 0;
          sub_10039E2FC(&__p, Count, buf);
          CFDictionaryGetKeysAndValues(v28, (const void **)keys, (const void **)__p);
          if (Count >= 1)
          {
            uint64_t v31 = 0;
            while (1)
            {
              CFDictionaryRef v32 = (const __CFDictionary *)*((void *)__p + v31);
              if (v32)
              {
                CFTypeID v33 = CFGetTypeID(*((CFTypeRef *)__p + v31));
                if (v33 == CFDictionaryGetTypeID())
                {
                  CFArrayRef v34 = (const __CFArray *)CFDictionaryGetValue(v32, @"CustomPreferences");
                  CFArrayRef v35 = v34;
                  if (v34)
                  {
                    CFTypeID v36 = CFGetTypeID(v34);
                    if (v36 == CFArrayGetTypeID()) {
                      break;
                    }
                  }
                }
              }
              if (Count == ++v31) {
                goto LABEL_42;
              }
            }
            CFIndex v65 = CFArrayGetCount(v35);
            if (v65 >= 1)
            {
              CFIndex v66 = 0;
              while (1)
              {
                CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v35, v66);
                CFDictionaryRef v68 = ValueAtIndex;
                if (ValueAtIndex)
                {
                  CFTypeID v69 = CFGetTypeID(ValueAtIndex);
                  if (v69 == CFDictionaryGetTypeID())
                  {
                    if (CFDictionaryContainsKey(v68, @"EnableEnhancedDelivery")) {
                      break;
                    }
                  }
                }
                if (v65 == ++v66) {
                  goto LABEL_42;
                }
              }
              *(void *)std::string buf = v68;
              sub_100282490(a3, (CFTypeRef *)buf);
              uint64_t v82 = *(void *)(keys + 8 * v31);
              if (v82)
              {
                CFTypeID v83 = CFGetTypeID(*(CFTypeRef *)(keys + 8 * v31));
                if (v83 == CFStringGetTypeID()) {
                  uint64_t v84 = v82;
                }
                else {
                  uint64_t v84 = 0;
                }
              }
              else
              {
                uint64_t v84 = 0;
              }
              *(void *)std::string buf = v84;
              sub_100013168(a2, (CFTypeRef *)buf);
            }
          }
LABEL_42:
          if (*a3) {
            long long v37 = sub_100080778;
          }
          else {
            long long v37 = 0;
          }
          if (v37)
          {
            if (*a2) {
              long long v38 = sub_1000810B8;
            }
            else {
              long long v38 = 0;
            }
            if (v38)
            {
              unsigned __int8 v90 = 0;
              subscriber::makeSimSlotRange();
              long long v40 = *(unsigned int **)buf;
              long long v39 = *(unsigned int **)&buf[8];
              if (*(void *)buf != *(void *)&buf[8])
              {
                long long v41 = *(uint64_t (**)(void))&buf[16];
                while ((v41(*v40) & 1) == 0)
                {
                  if (++v40 == v39)
                  {
                    long long v40 = v39;
                    break;
                  }
                }
                long long v42 = *(unsigned int **)&buf[8];
LABEL_56:
                while (v40 != v42)
                {
                  int CellBroadcastSettingForAlertType_sync = CellBroadcastConfig::getCellBroadcastSettingForAlertType_sync((uint64_t)v87, *v40, *a2, &v90);
                  if (v90) {
                    int v44 = CellBroadcastSettingForAlertType_sync;
                  }
                  else {
                    int v44 = 0;
                  }
                  if (v44 == 1) {
                    goto LABEL_85;
                  }
                  unsigned int v45 = v40 + 1;
                  long long v40 = v39;
                  if (v45 != v39)
                  {
                    long long v40 = v45;
                    while ((v41(*v40) & 1) == 0)
                    {
                      if (++v40 == v39)
                      {
                        long long v40 = v39;
                        goto LABEL_56;
                      }
                    }
                  }
                }
              }
              if (v90)
              {
LABEL_85:
                uint64_t v95 = 0;
                uint64_t v57 = v97;
                CellBroadcastConfig::getEnhancedDeliveryPrefKey((const __CFString *)*a2, (CFStringRef *)&v94);
                (*(void (**)(unsigned char *__return_ptr, uint64_t, void, const void *))(*(void *)v57 + 16))(buf, v57, kCommCenterSharedSettingsBundleId, v94);
                sub_1000057AC(&v95, (CFTypeRef *)buf);
                sub_1000577C4((const void **)buf);
                sub_1000558F4(&v94);
                if (v95) {
                  unint64_t v59 = sub_100084B4C;
                }
                else {
                  unint64_t v59 = 0;
                }
                if (v59)
                {
                  buf[0] = 0;
                  ctu::cf::assign((ctu::cf *)buf, v95, v58);
                  int v60 = buf[0];
                  unsigned __int8 v90 = buf[0];
                  unint64_t v61 = *((void *)v87 + 5);
                  if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
                  {
                    unint64_t v85 = "enabled";
                    if (!v60) {
                      unint64_t v85 = "disabled";
                    }
                    *(_DWORD *)std::string buf = 136315138;
                    *(void *)&uint8_t buf[4] = v85;
                    _os_log_error_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "Custom preference for Enhanced delivery: %s", buf, 0xCu);
                    int v60 = v90;
                  }
                  BOOL v47 = v60 != 0;
                  goto LABEL_120;
                }
                CFDictionaryRef v70 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)*a3, @"AlertType");
                CFDictionaryRef v71 = v70;
                if (v70 && (CFTypeID v72 = CFGetTypeID(v70), v72 == CFDictionaryGetTypeID()))
                {
                  char v73 = (BOOL *)CFDictionaryGetValue(v71, @"EnabledByDefault");
                  unsigned int v74 = v73;
                  if (v73)
                  {
                    CFTypeID v75 = CFGetTypeID(v73);
                    if (v75 == CFBooleanGetTypeID())
                    {
                      buf[0] = 0;
                      ctu::cf::assign((ctu::cf *)buf, v74, v76);
                      int v77 = buf[0];
                      BOOL v47 = buf[0] != 0;
                      uint64_t v78 = *((void *)v87 + 5);
                      if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
                      {
                        std::string::size_type v79 = "disabled";
                        int v80 = *a2;
                        if (v77) {
                          std::string::size_type v79 = "enabled";
                        }
                        *(_DWORD *)std::string buf = 138543618;
                        *(void *)&uint8_t buf[4] = v80;
                        *(_WORD *)&unsigned char buf[12] = 2080;
                        *(void *)&buf[14] = v79;
                        _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#I Using enhanced delivery state from bundle for %{public}@: %s", buf, 0x16u);
                      }
                      goto LABEL_120;
                    }
                  }
                  uint64_t v81 = *((void *)v87 + 5);
                  if (!os_log_type_enabled(v81, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_119;
                  }
                  *(_DWORD *)std::string buf = 138412546;
                  *(void *)&uint8_t buf[4] = @"CustomPreferences";
                  *(_WORD *)&unsigned char buf[12] = 2112;
                  *(void *)&buf[14] = @"EnabledByDefault";
                }
                else
                {
                  uint64_t v81 = *((void *)v87 + 5);
                  if (!os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
                  {
LABEL_119:
                    BOOL v47 = 0;
LABEL_120:
                    sub_100062778((const void **)&v95);
                    goto LABEL_121;
                  }
                  *(_DWORD *)std::string buf = 138412546;
                  *(void *)&uint8_t buf[4] = @"CustomPreferences";
                  *(_WORD *)&unsigned char buf[12] = 2112;
                  *(void *)&buf[14] = @"AlertType";
                }
                _os_log_error_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "Invalid key: %@.[].%@", buf, 0x16u);
                goto LABEL_119;
              }
              char v64 = *((void *)v87 + 5);
              if (!os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
              {
LABEL_96:
                BOOL v47 = 0;
LABEL_121:
                if (__p)
                {
                  __int16 v92 = __p;
                  operator delete(__p);
                }
                if ((void)keys)
                {
                  *((void *)&keys + 1) = keys;
                  operator delete((void *)keys);
                }
                goto LABEL_76;
              }
              unint64_t v86 = *a2;
              *(_DWORD *)std::string buf = 138412290;
              *(void *)&uint8_t buf[4] = v86;
              char v56 = "Alert disabled by user: %@";
              unsigned int v62 = v64;
              uint32_t v63 = 12;
LABEL_94:
              _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, v56, buf, v63);
              goto LABEL_96;
            }
            int v55 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
              goto LABEL_96;
            }
            *(_WORD *)std::string buf = 0;
            char v56 = "Failed to find root key for enhanced delivery state";
          }
          else
          {
            int v55 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
              goto LABEL_96;
            }
            *(_WORD *)std::string buf = 0;
            char v56 = "Failed to find custom dict";
          }
          unsigned int v62 = v55;
          uint32_t v63 = 2;
          goto LABEL_94;
        }
      }
      unint64_t v49 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
      {
        LODWORD(keys) = 138412290;
        *(void *)((char *)&keys + 4) = @"AlertTypes";
        uint64_t v50 = "Feature not supported from bundle: CellBroadcast.%@";
        unint64_t v51 = v49;
        uint32_t v52 = 12;
LABEL_98:
        _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, v50, (uint8_t *)&keys, v52);
      }
    }
    else
    {
      unint64_t v53 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(*((os_log_t *)v87 + 5), OS_LOG_TYPE_ERROR))
      {
        LOWORD(keys) = 0;
        uint64_t v50 = "Feature not supported from bundle: CellBroadcast";
        unint64_t v51 = v53;
        uint32_t v52 = 2;
        goto LABEL_98;
      }
    }
    BOOL v47 = 0;
LABEL_76:
    sub_100057D78((const void **)&theDict);
LABEL_77:
    if (v98) {
      sub_10004D2C8(v98);
    }
    goto LABEL_79;
  }
  int v46 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
  {
    LOWORD(keys) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Carrier settings interface missing", (uint8_t *)&keys, 2u);
  }
  BOOL v47 = 0;
LABEL_79:
  if ((v89 & 1) == 0) {
    sub_10004D2C8(v88);
  }
  return v47;
}

void sub_1004A7188(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, char a12, void *__p, uint64_t a14, uint64_t a15, char a16, int a17, const void *a18, const void *a19, uint64_t a20,std::__shared_weak_count *a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27)
{
  if (__p) {
    operator delete(__p);
  }
  if (a26)
  {
    a27 = (uint64_t)a26;
    operator delete(a26);
  }
  sub_100057D78(&a19);
  if (a21) {
    sub_10004D2C8(a21);
  }
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_1004A72AC(uint64_t *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = result + 2;
  unint64_t v5 = result[2];
  unint64_t v6 = result[1];
  if (v6 >= v5)
  {
    uint64_t v10 = (uint64_t)(v6 - *result) >> 6;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 58) {
      sub_10006A748();
    }
    uint64_t v12 = v5 - *result;
    if (v12 >> 5 > v11) {
      unint64_t v11 = v12 >> 5;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = v4;
    if (v13) {
      unint64_t v13 = (unint64_t)sub_10016063C(v13);
    }
    else {
      uint64_t v14 = 0;
    }
    unint64_t v15 = v13 + (v10 << 6);
    v18[0] = v13;
    v18[1] = v15;
    v18[3] = v13 + (v14 << 6);
    *(void *)unint64_t v15 = &off_1019D3D50;
    *(void *)(v15 + 8) = *(void *)(a2 + 8);
    long long v16 = *(_OWORD *)(a2 + 16);
    *(void *)(v15 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(v15 + 16) = v16;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 16) = 0;
    long long v17 = *(_OWORD *)(a2 + 40);
    *(void *)(v15 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(v15 + 40) = v17;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 40) = 0;
    v18[2] = v15 + 64;
    sub_1004AC790(v3, v18);
    uint64_t v9 = v3[1];
    uint64_t result = (uint64_t *)sub_1004AC858((uint64_t)v18);
  }
  else
  {
    *(void *)unint64_t v6 = &off_1019D3D50;
    *(void *)(v6 + 8) = *(void *)(a2 + 8);
    long long v7 = *(_OWORD *)(a2 + 16);
    *(void *)(v6 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(v6 + 16) = v7;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 16) = 0;
    long long v8 = *(_OWORD *)(a2 + 40);
    *(void *)(v6 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(v6 + 40) = v8;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 40) = 0;
    uint64_t v9 = v6 + 64;
  }
  v3[1] = v9;
  return result;
}

uint64_t sub_1004A7428(uint64_t a1)
{
  *(void *)a1 = &off_1019D3D50;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1004A7488(uint64_t a1, uint64_t a2, uint64_t a3, const void **a4, const void **a5)
{
  uint64_t v29 = a1;
  uint64_t v30 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v34 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  sub_1004ACA8C(&v30, a2, a3, (a3 - a2) >> 6);
  sub_100058198(&cf, a4);
  sub_100058198(&v34, a5);
  if (*(void *)(a1 + 264))
  {
    long long v8 = *(std::__shared_weak_count **)(a1 + 272);
    *(void *)(a1 + 264) = 0;
    *(void *)(a1 + 272) = 0;
    if (v8) {
      sub_10004D2C8(v8);
    }
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 240));
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v11;
  unint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (v15)
  {
    long long v17 = (void (***)(void, uint8_t *, uint64_t, void *))v15[3];
    long long v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    long long v17 = 0;
  }
  std::mutex::unlock(v10);
  long long v16 = 0;
  char v18 = 1;
LABEL_12:
  unint64_t v19 = *(NSObject **)(a1 + 40);
  if (v17)
  {
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Creating power assertion for Earthquake warning", buf, 2u);
    }
    sub_100058DB0(buf, "com.apple.ct.cmas");
    uint64_t v22 = v29;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    sub_1004ACA8C(&v23, v30, v31, (v31 - v30) >> 6);
    *(void *)&long long v26 = cf;
    if (cf) {
      CFRetain(cf);
    }
    *((void *)&v26 + 1) = v34;
    if (v34) {
      CFRetain(v34);
    }
    long long v37 = 0;
    uint64_t v20 = (char *)operator new(0x38uLL);
    uint64_t v21 = v23;
    *(void *)uint64_t v20 = off_1019D3E20;
    *((void *)v20 + 1) = v22;
    *((void *)v20 + 3) = 0;
    *((void *)v20 + 4) = 0;
    *((void *)v20 + 2) = 0;
    sub_1004ACA8C(v20 + 16, v21, v24, (v24 - v21) >> 6);
    *(_OWORD *)(v20 + 40) = v26;
    long long v26 = 0uLL;
    long long v37 = v20;
    (**v17)(v17, buf, 10, v36);
    sub_100160BF8(v36);
    sub_100057D78((const void **)&v26 + 1);
    sub_100057D78((const void **)&v26);
    CFArrayRef v35 = (void **)&v23;
    sub_1004AC990(&v35);
    if (v28 < 0)
    {
      operator delete(*(void **)buf);
      if (v18) {
        goto LABEL_25;
      }
      goto LABEL_24;
    }
  }
  else if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Missing power interface", buf, 2u);
    if (v18) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if ((v18 & 1) == 0) {
LABEL_24:
  }
    sub_10004D2C8(v16);
LABEL_25:
  sub_100057D78(&v34);
  sub_100057D78(&cf);
  *(void *)std::string buf = &v30;
  sub_1004AC990((void ***)buf);
}

void sub_1004A77CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004A785C(uint64_t a1)
{
  sub_100057D78((const void **)(a1 + 40));
  sub_100057D78((const void **)(a1 + 32));
  uint64_t v3 = (void **)(a1 + 8);
  sub_1004AC990(&v3);
  return a1;
}

uint64_t sub_1004A78A8(uint64_t a1, CFDictionaryRef *a2)
{
  uint64_t v4 = *(Registry **)(a1 + 240);
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 248);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)std::string buf = 86400;
  sub_1004AB61C(&__p, v4, (uint64_t *)(a1 + 128), (uint64_t)buf);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v5) {
    sub_10004D2C8(v5);
  }
  *(void *)std::string buf = 0;
  CellBroadcastConfig::getAppleSafetyAlertConfig_sync((CellBroadcastConfig *)a1, buf);
  if (*(void *)buf) {
    unint64_t v6 = sub_100080778;
  }
  else {
    unint64_t v6 = 0;
  }
  if (!v6)
  {
    long long v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v431.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No apple safety alert support", (uint8_t *)&v431, 2u);
    }
    uint64_t v8 = 0x2D00000001;
    sub_100057D78((const void **)buf);
    return v8;
  }
  sub_100057D78((const void **)buf);
  CFDictionaryRef Value = CFDictionaryGetValue(*a2, @"SafetyAlertMissingForHash");
  uint64_t v10 = Value;
  if (Value)
  {
    CFTypeID v11 = CFGetTypeID(Value);
    if (v11 == CFStringGetTypeID())
    {
      uint64_t v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 138543362;
        *(void *)&uint8_t buf[4] = v10;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Safety alert missing Hash: %{public}@", buf, 0xCu);
      }
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      v431.__r_.__value_.__r.__words[0] = (std::string::size_type)Mutable;
      if (Mutable) {
        unsigned int v14 = sub_1000C06D0;
      }
      else {
        unsigned int v14 = 0;
      }
      if (v14)
      {
        CFDictionarySetValue(Mutable, @"kCTSMSAppleSafetyAlertMissingForHash", v10);
        unint64_t v15 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 138543362;
          *(void *)&uint8_t buf[4] = v431.__r_.__value_.__r.__words[0];
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Sending Apple safety alert message notification: %{public}@", buf, 0xCu);
        }
        ctu::cf_to_xpc((uint64_t *)buf, (ctu *)v431.__r_.__value_.__l.__data_, v16);
        xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
        if (v17 || (xpc_object_t v17 = xpc_null_create()) != 0)
        {
          if (xpc_get_type(v17) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_retain(v17);
            xpc_object_t v18 = v17;
          }
          else
          {
            xpc_object_t v18 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v18 = xpc_null_create();
          xpc_object_t v17 = 0;
        }
        xpc_release(v17);
        v430.__r_.__value_.__r.__words[0] = (std::string::size_type)v18;
        if (v18) {
          xpc_retain(v18);
        }
        else {
          v430.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
        }
        sub_1000452AC(28, (xpc_object_t *)buf, (xpc_object_t *)&v430.__r_.__value_.__l.__data_);
        xpc_release(v430.__r_.__value_.__l.__data_);
        v430.__r_.__value_.__r.__words[0] = 0;
        xpc_release(v18);
        xpc_release(*(xpc_object_t *)buf);
        ctu::cf_to_xpc((uint64_t *)buf, (ctu *)v431.__r_.__value_.__l.__data_, v67);
        xpc_object_t v68 = xpc_dictionary_create(0, 0, 0);
        if (v68 || (xpc_object_t v68 = xpc_null_create()) != 0)
        {
          if (xpc_get_type(v68) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_retain(v68);
            xpc_object_t v69 = v68;
          }
          else
          {
            xpc_object_t v69 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v69 = xpc_null_create();
          xpc_object_t v68 = 0;
        }
        xpc_release(v68);
        v430.__r_.__value_.__r.__words[0] = (std::string::size_type)v69;
        if (v69) {
          xpc_retain(v69);
        }
        else {
          v430.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
        }
        sub_1000452AC(27, (xpc_object_t *)buf, (xpc_object_t *)&v430.__r_.__value_.__l.__data_);
        xpc_release(v430.__r_.__value_.__l.__data_);
        v430.__r_.__value_.__r.__words[0] = 0;
        xpc_release(v69);
        xpc_release(*(xpc_object_t *)buf);
      }
      else
      {
        long long v43 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "Failed to allocate dictionary for notification", buf, 2u);
        }
      }
      sub_10005717C((const void **)&v431.__r_.__value_.__l.__data_);
      return 0;
    }
  }
  unint64_t v19 = CFDictionaryGetValue(*a2, @"UniqueID");
  if (!v19 || (CFTypeID v20 = CFGetTypeID(v19), v20 != CFStringGetTypeID()))
  {
    uint64_t v8 = 0x1600000001;
    long long v40 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Invalid uniqueID", buf, 2u);
    }
    return v8;
  }
  int64x2_t v410 = 0uLL;
  uint64_t v411 = 0;
  memset(__val, 0, sizeof(__val));
  long long v425 = 0u;
  *(_OWORD *)v426 = 0u;
  long long v424 = 0u;
  long long v422 = 0u;
  memset(v423, 0, sizeof(v423));
  memset(v421, 0, sizeof(v421));
  long long v420 = 0u;
  long long v418 = 0u;
  memset(v419, 0, sizeof(v419));
  memset(v417, 0, sizeof(v417));
  *(_OWORD *)std::string buf = 0u;
  uint64_t v21 = *(Registry **)(a1 + 240);
  uint64_t v22 = *(std::__shared_weak_count **)(a1 + 248);
  if (v22)
  {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1004A55DC((uint64_t)buf, v21);
  if (v22) {
    sub_10004D2C8(v22);
  }
  *(void *)std::string buf = &off_1019D3D20;
  memset(v417, 0, sizeof(v417));
  long long v418 = 0u;
  memset(v419, 0, sizeof(v419));
  long long v420 = 0u;
  memset(v421, 0, sizeof(v421));
  long long v422 = 0u;
  memset(v423, 0, sizeof(v423));
  long long v424 = 0u;
  long long v425 = 0u;
  *(_OWORD *)v426 = 0u;
  __val[0] = 0;
  memset(&__val[2], 0, 88);
  if (v22) {
    sub_10004D2C8(v22);
  }
  memset(&v431, 0, sizeof(v431));
  ctu::cf::assign();
  v430.__r_.__value_.__r.__words[0] = v431.__r_.__value_.__l.__size_;
  uint64_t v23 = (void *)v431.__r_.__value_.__r.__words[0];
  *(std::string::size_type *)((char *)v430.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v431.__r_.__value_.__r.__words[1] + 7);
  char v24 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(v419[2]) < 0) {
    operator delete(v419[0]);
  }
  v419[0] = v23;
  v419[1] = v430.__r_.__value_.__l.__data_;
  *(void **)((char *)&v419[1] + 7) = *(void **)((char *)v430.__r_.__value_.__r.__words + 7);
  HIBYTE(v419[2]) = v24;
  uint64_t v25 = CFDictionaryGetValue(*a2, @"SessionID");
  if (!v25 || (CFTypeID v26 = CFGetTypeID(v25), v26 != CFStringGetTypeID()))
  {
    uint64_t v8 = 0x1600000001;
    long long v41 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
      goto LABEL_72;
    }
    LOWORD(v431.__r_.__value_.__l.__data_) = 0;
    CFDictionaryRef v70 = "Invalid sessionID";
LABEL_172:
    _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, v70, (uint8_t *)&v431, 2u);
    goto LABEL_72;
  }
  int v403 = (int64x2_t *)(a1 + 128);
  uint64_t v27 = *(void *)(a1 + 128);
  uint64_t v28 = *(void *)(a1 + 136);
  while (v27 != v28)
  {
    memset(&v431, 0, sizeof(v431));
    ctu::cf::assign();
    std::string v430 = v431;
    uint64_t v29 = *(unsigned __int8 *)(v27 + 87);
    if ((v29 & 0x80u) == 0) {
      uint64_t v30 = *(unsigned __int8 *)(v27 + 87);
    }
    else {
      uint64_t v30 = *(void *)(v27 + 72);
    }
    std::string::size_type size = HIBYTE(v430.__r_.__value_.__r.__words[2]);
    int v32 = SHIBYTE(v430.__r_.__value_.__r.__words[2]);
    if ((v430.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v430.__r_.__value_.__l.__size_;
    }
    if (v30 == size)
    {
      if ((v430.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        CFTypeID v33 = &v430;
      }
      else {
        CFTypeID v33 = (std::string *)v430.__r_.__value_.__r.__words[0];
      }
      if ((v29 & 0x80) != 0)
      {
        BOOL v38 = memcmp(*(const void **)(v27 + 64), v33, *(void *)(v27 + 72)) == 0;
        if ((v32 & 0x80000000) == 0) {
          goto LABEL_59;
        }
      }
      else if (*(unsigned char *)(v27 + 87))
      {
        uint64_t v34 = 0;
        uint64_t v35 = v29 - 1;
        do
        {
          int v36 = v33->__r_.__value_.__s.__data_[v34];
          int v37 = *(unsigned __int8 *)(v27 + v34 + 64);
          BOOL v38 = v37 == v36;
        }
        while (v37 == v36 && v35 != v34++);
        if ((SHIBYTE(v430.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_59:
          if (v38) {
            goto LABEL_131;
          }
          goto LABEL_63;
        }
      }
      else
      {
        BOOL v38 = 1;
        if ((SHIBYTE(v430.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_59;
        }
      }
    }
    else
    {
      BOOL v38 = 0;
      if ((SHIBYTE(v430.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_59;
      }
    }
    operator delete(v430.__r_.__value_.__l.__data_);
    if (v38)
    {
LABEL_131:
      uint64_t v8 = 0x2500000001;
      long long v41 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
        goto LABEL_72;
      }
      LOWORD(v431.__r_.__value_.__l.__data_) = 0;
      CFDictionaryRef v70 = "UniqueID has been processed previously";
      goto LABEL_172;
    }
LABEL_63:
    v27 += 336;
  }
  memset(&v431, 0, sizeof(v431));
  ctu::cf::assign();
  v430.__r_.__value_.__r.__words[0] = v431.__r_.__value_.__l.__size_;
  int v44 = (void *)v431.__r_.__value_.__r.__words[0];
  *(std::string::size_type *)((char *)v430.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v431.__r_.__value_.__r.__words[1] + 7);
  char v45 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(v420) < 0) {
    operator delete(v419[3]);
  }
  v419[3] = v44;
  *(void *)&long long v420 = v430.__r_.__value_.__r.__words[0];
  *(void *)((char *)&v420 + 7) = *(std::string::size_type *)((char *)v430.__r_.__value_.__r.__words + 7);
  HIBYTE(v420) = v45;
  v408 = 0;
  long long v409 = 0uLL;
  CFNumberRef v46 = (const __CFNumber *)CFDictionaryGetValue(*a2, @"Status");
  CFNumberRef v47 = v46;
  if (!v46 || (CFTypeID v48 = CFGetTypeID(v46), v48 != CFNumberGetTypeID()))
  {
    memset(&v431, 0, sizeof(v431));
    ctu::cf::assign();
    std::string v430 = v431;
    unint64_t v61 = std::string::insert(&v430, 0, "Missing key: ", 0xDuLL);
LABEL_108:
    unsigned int v62 = (void *)v61->__r_.__value_.__r.__words[0];
    v428.__r_.__value_.__r.__words[0] = v61->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v61->__r_.__value_.__r.__words[1] + 7);
    char v63 = HIBYTE(v61->__r_.__value_.__r.__words[2]);
    v61->__r_.__value_.__l.__size_ = 0;
    v61->__r_.__value_.__r.__words[2] = 0;
    v61->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v409) < 0) {
      operator delete(v408);
    }
    v408 = v62;
    *(void *)&long long v409 = v428.__r_.__value_.__r.__words[0];
    *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7);
    HIBYTE(v409) = v63;
    if ((SHIBYTE(v430.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_113;
    }
    int v60 = (void *)v430.__r_.__value_.__r.__words[0];
    goto LABEL_112;
  }
  if (!CFNumberGetValue(v47, kCFNumberIntType, __val))
  {
    memset(&v431, 0, sizeof(v431));
    ctu::cf::assign();
    std::string v430 = v431;
    unint64_t v61 = std::string::insert(&v430, 0, "Failed to read key: ", 0x14uLL);
    goto LABEL_108;
  }
  if (__val[0] < 6u) {
    goto LABEL_114;
  }
  sub_100058DB0(&v414, "Invalid value for [");
  memset(&v431, 0, sizeof(v431));
  ctu::cf::assign();
  std::string v413 = v431;
  if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v49 = &v413;
  }
  else {
    unint64_t v49 = (std::string *)v413.__r_.__value_.__r.__words[0];
  }
  if ((v413.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v50 = HIBYTE(v413.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v50 = v413.__r_.__value_.__l.__size_;
  }
  unint64_t v51 = std::string::append(&v414, (const std::string::value_type *)v49, v50);
  long long v52 = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
  v428.__r_.__value_.__r.__words[2] = v51->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v428.__r_.__value_.__l.__data_ = v52;
  v51->__r_.__value_.__l.__size_ = 0;
  v51->__r_.__value_.__r.__words[2] = 0;
  v51->__r_.__value_.__r.__words[0] = 0;
  unint64_t v53 = std::string::append(&v428, "]: ", 3uLL);
  long long v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
  v430.__r_.__value_.__r.__words[2] = v53->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v430.__r_.__value_.__l.__data_ = v54;
  v53->__r_.__value_.__l.__size_ = 0;
  v53->__r_.__value_.__r.__words[2] = 0;
  v53->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v431, __val[0]);
  if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v55 = &v431;
  }
  else {
    int v55 = (std::string *)v431.__r_.__value_.__r.__words[0];
  }
  if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v56 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v56 = v431.__r_.__value_.__l.__size_;
  }
  uint64_t v57 = std::string::append(&v430, (const std::string::value_type *)v55, v56);
  CFBooleanRef v58 = (void *)v57->__r_.__value_.__r.__words[0];
  __str.__r_.__value_.__r.__words[0] = v57->__r_.__value_.__l.__size_;
  *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v57->__r_.__value_.__r.__words[1] + 7);
  char v59 = HIBYTE(v57->__r_.__value_.__r.__words[2]);
  v57->__r_.__value_.__l.__size_ = 0;
  v57->__r_.__value_.__r.__words[2] = 0;
  v57->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v409) < 0) {
    operator delete(v408);
  }
  v408 = v58;
  *(void *)&long long v409 = __str.__r_.__value_.__r.__words[0];
  *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7);
  HIBYTE(v409) = v59;
  if (SHIBYTE(v431.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v431.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v430.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v430.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v428.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v428.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v413.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v413.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v414.__r_.__value_.__r.__words[2]) < 0)
  {
    int v60 = (void *)v414.__r_.__value_.__r.__words[0];
LABEL_112:
    operator delete(v60);
  }
LABEL_113:
  char v64 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
  {
    int v98 = &v408;
    if (v409 < 0) {
      int v98 = v408;
    }
    LODWORD(v431.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v431.__r_.__value_.__r.__words + 4) = (std::string::size_type)v98;
    _os_log_error_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "Failed to parse status: %s", (uint8_t *)&v431, 0xCu);
  }
LABEL_114:
  CFDictionaryRef v65 = *a2;
  if (SHIBYTE(v409) < 0)
  {
    *(void *)&long long v409 = 0;
    CFIndex v66 = v408;
  }
  else
  {
    HIBYTE(v409) = 0;
    CFIndex v66 = &v408;
  }
  *CFIndex v66 = 0;
  CFNumberRef v71 = (const __CFNumber *)CFDictionaryGetValue(v65, @"MessageType");
  CFNumberRef v72 = v71;
  if (!v71 || (CFTypeID v73 = CFGetTypeID(v71), v73 != CFNumberGetTypeID()))
  {
    memset(&v431, 0, sizeof(v431));
    ctu::cf::assign();
    std::string v430 = v431;
    uint64_t v87 = std::string::insert(&v430, 0, "Missing key: ", 0xDuLL);
LABEL_163:
    __int16 v88 = (void *)v87->__r_.__value_.__r.__words[0];
    v428.__r_.__value_.__r.__words[0] = v87->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v87->__r_.__value_.__r.__words[1] + 7);
    char v89 = HIBYTE(v87->__r_.__value_.__r.__words[2]);
    v87->__r_.__value_.__l.__size_ = 0;
    v87->__r_.__value_.__r.__words[2] = 0;
    v87->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v409) < 0) {
      operator delete(v408);
    }
    v408 = v88;
    *(void *)&long long v409 = v428.__r_.__value_.__r.__words[0];
    *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7);
    HIBYTE(v409) = v89;
    if ((SHIBYTE(v430.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_168;
    }
    unint64_t v86 = (void *)v430.__r_.__value_.__r.__words[0];
    goto LABEL_167;
  }
  if (!CFNumberGetValue(v72, kCFNumberIntType, &v426[2]))
  {
    memset(&v431, 0, sizeof(v431));
    ctu::cf::assign();
    std::string v430 = v431;
    uint64_t v87 = std::string::insert(&v430, 0, "Failed to read key: ", 0x14uLL);
    goto LABEL_163;
  }
  unsigned int v74 = v426[2];
  if (v426[2] >= 5u)
  {
    sub_100058DB0(&v414, "Invalid value for [");
    memset(&v431, 0, sizeof(v431));
    ctu::cf::assign();
    std::string v413 = v431;
    if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      CFTypeID v75 = &v413;
    }
    else {
      CFTypeID v75 = (std::string *)v413.__r_.__value_.__r.__words[0];
    }
    if ((v413.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v76 = HIBYTE(v413.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v76 = v413.__r_.__value_.__l.__size_;
    }
    int v77 = std::string::append(&v414, (const std::string::value_type *)v75, v76);
    long long v78 = *(_OWORD *)&v77->__r_.__value_.__l.__data_;
    v428.__r_.__value_.__r.__words[2] = v77->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v428.__r_.__value_.__l.__data_ = v78;
    v77->__r_.__value_.__l.__size_ = 0;
    v77->__r_.__value_.__r.__words[2] = 0;
    v77->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v79 = std::string::append(&v428, "]: ", 3uLL);
    long long v80 = *(_OWORD *)&v79->__r_.__value_.__l.__data_;
    v430.__r_.__value_.__r.__words[2] = v79->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v430.__r_.__value_.__l.__data_ = v80;
    v79->__r_.__value_.__l.__size_ = 0;
    v79->__r_.__value_.__r.__words[2] = 0;
    v79->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v431, v426[2]);
    if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v81 = &v431;
    }
    else {
      uint64_t v81 = (std::string *)v431.__r_.__value_.__r.__words[0];
    }
    if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v82 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v82 = v431.__r_.__value_.__l.__size_;
    }
    CFTypeID v83 = std::string::append(&v430, (const std::string::value_type *)v81, v82);
    uint64_t v84 = (void *)v83->__r_.__value_.__r.__words[0];
    __str.__r_.__value_.__r.__words[0] = v83->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v83->__r_.__value_.__r.__words[1] + 7);
    char v85 = HIBYTE(v83->__r_.__value_.__r.__words[2]);
    v83->__r_.__value_.__l.__size_ = 0;
    v83->__r_.__value_.__r.__words[2] = 0;
    v83->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v409) < 0) {
      operator delete(v408);
    }
    v408 = v84;
    *(void *)&long long v409 = __str.__r_.__value_.__r.__words[0];
    *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7);
    HIBYTE(v409) = v85;
    if (SHIBYTE(v431.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v431.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v430.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v430.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v428.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v428.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v413.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v413.__r_.__value_.__l.__data_);
    }
    if ((SHIBYTE(v414.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_168;
    }
    unint64_t v86 = (void *)v414.__r_.__value_.__r.__words[0];
LABEL_167:
    operator delete(v86);
LABEL_168:
    uint64_t v8 = 0x1600000001;
    unsigned __int8 v90 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
      goto LABEL_169;
    }
    int v99 = &v408;
    if (v409 < 0) {
      int v99 = v408;
    }
    LODWORD(v431.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v431.__r_.__value_.__r.__words + 4) = (std::string::size_type)v99;
    unint64_t v100 = "Failed to parse messageType: %s";
    uint64_t v101 = v90;
    uint32_t v102 = 12;
LABEL_201:
    _os_log_error_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_ERROR, v100, (uint8_t *)&v431, v102);
    goto LABEL_169;
  }
  uint64_t v91 = *(void *)(a1 + 128);
  uint64_t v92 = *(void *)(a1 + 136);
  if (v91 == v92) {
    goto LABEL_218;
  }
  if (v420 >= 0) {
    uint64_t v93 = HIBYTE(v420);
  }
  else {
    uint64_t v93 = v420;
  }
  if (v420 >= 0) {
    char v94 = &v419[3];
  }
  else {
    char v94 = (void **)v419[3];
  }
  while (1)
  {
    uint64_t v95 = *(unsigned __int8 *)(v91 + 111);
    uint64_t v96 = (v95 & 0x80u) == 0 ? *(unsigned __int8 *)(v91 + 111) : *(void *)(v91 + 96);
    if (v96 == v93)
    {
      if ((v95 & 0x80) == 0)
      {
        if (!*(unsigned char *)(v91 + 111)) {
          break;
        }
        uint64_t v97 = 0;
        while (*(unsigned __int8 *)(v91 + v97 + 88) == *((unsigned __int8 *)v94 + v97))
        {
          if (v95 == ++v97) {
            goto LABEL_202;
          }
        }
        goto LABEL_193;
      }
      if (!memcmp(*(const void **)(v91 + 88), v94, *(void *)(v91 + 96))) {
        break;
      }
    }
LABEL_193:
    v91 += 336;
    if (v91 == v92) {
      goto LABEL_218;
    }
  }
LABEL_202:
  int v103 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v431.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "#I SessionID matched", (uint8_t *)&v431, 2u);
    unsigned int v74 = v426[2];
  }
  uint64_t v104 = a1 + 128;
  if (v74 - 3 < 2)
  {
LABEL_207:
    int v105 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
    {
      if (v74 > 4) {
        os_log_t v106 = "???";
      }
      else {
        os_log_t v106 = off_1019D3F50[v74];
      }
      LODWORD(v431.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v431.__r_.__value_.__r.__words + 4) = (std::string::size_type)v106;
      _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_DEFAULT, "#I Canceling alert: %s", (uint8_t *)&v431, 0xCu);
    }
    sub_1004AB898((uint64_t)v403, v91);
    goto LABEL_735;
  }
  if (v74 == 2)
  {
    uint64_t v107 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT))
    {
      sub_1004A5C6C(&v431, v91);
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v108 = &v431;
      }
      else {
        uint64_t v108 = (std::string *)v431.__r_.__value_.__r.__words[0];
      }
      LODWORD(v430.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v430.__r_.__value_.__r.__words + 4) = (std::string::size_type)v108;
      _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEFAULT, "#I Replacing older alert: %{public}s", (uint8_t *)&v430, 0xCu);
      if (SHIBYTE(v431.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v431.__r_.__value_.__l.__data_);
      }
      uint64_t v104 = a1 + 128;
    }
    sub_1004AB898(v104, v91);
LABEL_218:
    CFArrayRef v109 = (const __CFArray *)CFDictionaryGetValue(*a2, @"Info");
    CFArrayRef v110 = v109;
    if (!v109 || (CFTypeID v111 = CFGetTypeID(v109), v111 != CFArrayGetTypeID()))
    {
      uint64_t v8 = 0x1600000001;
      int v387 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v387, OS_LOG_TYPE_ERROR)) {
        goto LABEL_169;
      }
      LOWORD(v431.__r_.__value_.__l.__data_) = 0;
      unint64_t v100 = "Failed to parse info array";
      uint64_t v101 = v387;
      uint32_t v102 = 2;
      goto LABEL_201;
    }
    CFIndex Count = CFArrayGetCount(v110);
    CFArrayRef theArray = v110;
    os_log_t v112 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v431.__r_.__value_.__l.__data_) = 134217984;
      *(std::string::size_type *)((char *)v431.__r_.__value_.__r.__words + 4) = Count;
      _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "#I Received %ld info array", (uint8_t *)&v431, 0xCu);
    }
    if (Count < 1)
    {
LABEL_724:
      uint64_t v388 = *(void *)(a1 + 128);
      uint64_t v389 = *(void *)(a1 + 136);
      uint64_t v391 = v410.i64[1];
      uint64_t v390 = v410.i64[0];
      while (v388 != v389)
      {
        uint64_t v392 = v390;
        if (v390 != v391)
        {
          while (!sub_1004A5978(v388, v392))
          {
            v392 += 336;
            if (v392 == v391) {
              goto LABEL_729;
            }
          }
          v394 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v394, OS_LOG_TYPE_DEFAULT))
          {
            sub_1004A5C6C(&v431, v388);
            int v395 = (v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                 ? &v431
                 : (std::string *)v431.__r_.__value_.__r.__words[0];
            LODWORD(v430.__r_.__value_.__l.__data_) = 136446210;
            *(std::string::size_type *)((char *)v430.__r_.__value_.__r.__words + 4) = (std::string::size_type)v395;
            _os_log_impl((void *)&_mh_execute_header, v394, OS_LOG_TYPE_DEFAULT, "#I Alert already present: %{public}s", (uint8_t *)&v430, 0xCu);
            if (SHIBYTE(v431.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v431.__r_.__value_.__l.__data_);
            }
          }
          goto LABEL_735;
        }
LABEL_729:
        v388 += 336;
      }
      if (v390 == v391) {
        goto LABEL_735;
      }
      do
      {
        unint64_t v396 = *(void *)(a1 + 136);
        if (v396 >= *(void *)(a1 + 144))
        {
          uint64_t v397 = sub_1004ACF24(v403, v390);
        }
        else
        {
          sub_1004AD23C(*(void *)(a1 + 136), v390);
          uint64_t v397 = v396 + 336;
          *(void *)(a1 + 136) = v396 + 336;
        }
        *(void *)(a1 + 136) = v397;
        v398 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v398, OS_LOG_TYPE_DEFAULT))
        {
          sub_1004A5C6C(&v431, v390);
          int v399 = (v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
               ? &v431
               : (std::string *)v431.__r_.__value_.__r.__words[0];
          LODWORD(v430.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)v430.__r_.__value_.__r.__words + 4) = (std::string::size_type)v399;
          _os_log_impl((void *)&_mh_execute_header, v398, OS_LOG_TYPE_DEFAULT, "#I Storing apple safety alert : %{public}s", (uint8_t *)&v430, 0xCu);
          if (SHIBYTE(v431.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v431.__r_.__value_.__l.__data_);
          }
        }
        CellBroadcastConfig::addAppleSafetyAlertMetric_sync(a1, v390);
        uint64_t v8 = 0;
        v390 += 336;
      }
      while (v390 != v391);
      goto LABEL_169;
    }
    CFIndex v113 = 0;
    uint64_t v8 = 0x2D00000001;
    while (1)
    {
      CFIndex v402 = v113;
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v113);
      CFArrayRef v115 = ValueAtIndex;
      if (ValueAtIndex)
      {
        CFTypeID v116 = CFGetTypeID(ValueAtIndex);
        CFDictionaryRef v117 = v116 == CFDictionaryGetTypeID() ? (const __CFDictionary *)v115 : 0;
      }
      else
      {
        CFDictionaryRef v117 = 0;
      }
      if (SHIBYTE(v409) < 0)
      {
        *(void *)&long long v409 = 0;
        v118 = v408;
      }
      else
      {
        HIBYTE(v409) = 0;
        v118 = &v408;
      }
      unsigned char *v118 = 0;
      CFNumberRef v119 = (const __CFNumber *)CFDictionaryGetValue(v117, @"Language");
      CFNumberRef v120 = v119;
      if (!v119) {
        break;
      }
      CFTypeID v121 = CFGetTypeID(v119);
      if (v121 != CFNumberGetTypeID()) {
        break;
      }
      if (!CFNumberGetValue(v120, kCFNumberIntType, &__val[11]))
      {
        memset(&v431, 0, sizeof(v431));
        ctu::cf::assign();
        std::string v430 = v431;
        uint64_t v134 = std::string::insert(&v430, 0, "Failed to read key: ", 0x14uLL);
        goto LABEL_261;
      }
      if (__val[11] < 3u) {
        goto LABEL_267;
      }
      sub_100058DB0(&v414, "Invalid value for [");
      memset(&v431, 0, sizeof(v431));
      ctu::cf::assign();
      std::string v413 = v431;
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        CFStringRef v122 = &v413;
      }
      else {
        CFStringRef v122 = (std::string *)v413.__r_.__value_.__r.__words[0];
      }
      if ((v413.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v123 = HIBYTE(v413.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v123 = v413.__r_.__value_.__l.__size_;
      }
      unsigned __int16 v124 = std::string::append(&v414, (const std::string::value_type *)v122, v123);
      long long v125 = *(_OWORD *)&v124->__r_.__value_.__l.__data_;
      v428.__r_.__value_.__r.__words[2] = v124->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v428.__r_.__value_.__l.__data_ = v125;
      v124->__r_.__value_.__l.__size_ = 0;
      v124->__r_.__value_.__r.__words[2] = 0;
      v124->__r_.__value_.__r.__words[0] = 0;
      int v126 = std::string::append(&v428, "]: ", 3uLL);
      long long v127 = *(_OWORD *)&v126->__r_.__value_.__l.__data_;
      v430.__r_.__value_.__r.__words[2] = v126->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v430.__r_.__value_.__l.__data_ = v127;
      v126->__r_.__value_.__l.__size_ = 0;
      v126->__r_.__value_.__r.__words[2] = 0;
      v126->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v431, __val[11]);
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v128 = &v431;
      }
      else {
        int v128 = (std::string *)v431.__r_.__value_.__r.__words[0];
      }
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v129 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v129 = v431.__r_.__value_.__l.__size_;
      }
      uint64_t v130 = std::string::append(&v430, (const std::string::value_type *)v128, v129);
      __int16 v131 = (void *)v130->__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = v130->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v130->__r_.__value_.__r.__words[1] + 7);
      char v132 = HIBYTE(v130->__r_.__value_.__r.__words[2]);
      v130->__r_.__value_.__l.__size_ = 0;
      v130->__r_.__value_.__r.__words[2] = 0;
      v130->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v409) < 0) {
        operator delete(v408);
      }
      v408 = v131;
      *(void *)&long long v409 = __str.__r_.__value_.__r.__words[0];
      *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7);
      HIBYTE(v409) = v132;
      if (SHIBYTE(v431.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v431.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v430.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v430.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v428.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v428.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v413.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v413.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v414.__r_.__value_.__r.__words[2]) < 0)
      {
        __int16 v133 = (void *)v414.__r_.__value_.__r.__words[0];
LABEL_265:
        operator delete(v133);
      }
LABEL_266:
      __int16 v137 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR))
      {
        int v337 = &v408;
        if (v409 < 0) {
          int v337 = v408;
        }
        LODWORD(v431.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v431.__r_.__value_.__r.__words + 4) = (std::string::size_type)v337;
        _os_log_error_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_ERROR, "Failed to parse language: %{public}s", (uint8_t *)&v431, 0xCu);
      }
LABEL_267:
      if (SHIBYTE(v409) < 0)
      {
        *(void *)&long long v409 = 0;
        std::string::size_type v138 = v408;
      }
      else
      {
        HIBYTE(v409) = 0;
        std::string::size_type v138 = &v408;
      }
      *std::string::size_type v138 = 0;
      CFArrayRef v139 = (const __CFArray *)CFDictionaryGetValue(v117, @"ResponseCode");
      CFArrayRef v140 = v139;
      if (!v139 || (CFTypeID v141 = CFGetTypeID(v139), v141 != CFArrayGetTypeID()))
      {
        memset(&v431, 0, sizeof(v431));
        ctu::cf::assign();
        std::string v430 = v431;
        uint32_t v160 = std::string::insert(&v430, 0, "Missing key: ", 0xDuLL);
LABEL_299:
        int v161 = (void *)v160->__r_.__value_.__r.__words[0];
        v428.__r_.__value_.__r.__words[0] = v160->__r_.__value_.__l.__size_;
        *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v160->__r_.__value_.__r.__words[1] + 7);
        char v162 = HIBYTE(v160->__r_.__value_.__r.__words[2]);
        v160->__r_.__value_.__l.__size_ = 0;
        v160->__r_.__value_.__r.__words[2] = 0;
        v160->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v409) < 0) {
          operator delete(v408);
        }
        v408 = v161;
        *(void *)&long long v409 = v428.__r_.__value_.__r.__words[0];
        *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7);
        HIBYTE(v409) = v162;
        if ((SHIBYTE(v430.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_304;
        }
        int v163 = (void *)v430.__r_.__value_.__r.__words[0];
        goto LABEL_303;
      }
      CFIndex v142 = CFArrayGetCount(v140);
      if (v142 < 1) {
        goto LABEL_305;
      }
      CFIndex v143 = 0;
      while (1)
      {
        CFNumberRef v144 = (const __CFNumber *)CFArrayGetValueAtIndex(v140, v143);
        CFNumberRef v145 = v144;
        if (v144)
        {
          CFTypeID v146 = CFGetTypeID(v144);
          if (v146 == CFNumberGetTypeID()) {
            CFNumberRef v147 = v145;
          }
          else {
            CFNumberRef v147 = 0;
          }
        }
        else
        {
          CFNumberRef v147 = 0;
        }
        LODWORD(v406.__r_.__value_.__l.__data_) = 0;
        if (!CFNumberGetValue(v147, kCFNumberIntType, &v406))
        {
          memset(&v431, 0, sizeof(v431));
          ctu::cf::assign();
          std::string v430 = v431;
          uint32_t v160 = std::string::insert(&v430, 0, "Failed to read key: ", 0x14uLL);
          goto LABEL_299;
        }
        int data = (int)v406.__r_.__value_.__l.__data_;
        if (LODWORD(v406.__r_.__value_.__l.__data_) >= 0xA) {
          break;
        }
        int v149 = *(char **)&__val[14];
        if (*(void *)&__val[14] >= *(void *)&__val[16])
        {
          int v151 = *(char **)&__val[12];
          uint64_t v152 = (uint64_t)(*(void *)&__val[14] - *(void *)&__val[12]) >> 2;
          unint64_t v153 = v152 + 1;
          if ((unint64_t)(v152 + 1) >> 62) {
            sub_10006A748();
          }
          uint64_t v154 = *(void *)&__val[16] - *(void *)&__val[12];
          if ((uint64_t)(*(void *)&__val[16] - *(void *)&__val[12]) >> 1 > v153) {
            unint64_t v153 = v154 >> 1;
          }
          BOOL v155 = (unint64_t)v154 >= 0x7FFFFFFFFFFFFFFCLL;
          unint64_t v156 = 0x3FFFFFFFFFFFFFFFLL;
          if (!v155) {
            unint64_t v156 = v153;
          }
          if (v156)
          {
            unint64_t v156 = (unint64_t)sub_1000492A8(v156);
            int v149 = *(char **)&__val[14];
            int v151 = *(char **)&__val[12];
            int data = (int)v406.__r_.__value_.__l.__data_;
          }
          else
          {
            uint64_t v157 = 0;
          }
          v158 = (_DWORD *)(v156 + 4 * v152);
          _DWORD *v158 = data;
          v150 = v158 + 1;
          while (v149 != v151)
          {
            int v159 = *((_DWORD *)v149 - 1);
            v149 -= 4;
            *--v158 = v159;
          }
          *(void *)&__val[12] = v158;
          *(void *)&__val[14] = v150;
          *(void *)&__val[16] = v156 + 4 * v157;
          if (v151) {
            operator delete(v151);
          }
        }
        else
        {
          **(_DWORD **)&__val[14] = v406.__r_.__value_.__l.__data_;
          v150 = v149 + 4;
        }
        *(void *)&__val[14] = v150;
        if (++v143 == v142) {
          goto LABEL_305;
        }
      }
      sub_100058DB0(&v414, "Invalid value for [");
      memset(&v431, 0, sizeof(v431));
      ctu::cf::assign();
      std::string v413 = v431;
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v304 = &v413;
      }
      else {
        v304 = (std::string *)v413.__r_.__value_.__r.__words[0];
      }
      if ((v413.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v305 = HIBYTE(v413.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v305 = v413.__r_.__value_.__l.__size_;
      }
      v306 = std::string::append(&v414, (const std::string::value_type *)v304, v305);
      long long v307 = *(_OWORD *)&v306->__r_.__value_.__l.__data_;
      v428.__r_.__value_.__r.__words[2] = v306->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v428.__r_.__value_.__l.__data_ = v307;
      v306->__r_.__value_.__l.__size_ = 0;
      v306->__r_.__value_.__r.__words[2] = 0;
      v306->__r_.__value_.__r.__words[0] = 0;
      v308 = std::string::append(&v428, "]: ", 3uLL);
      long long v309 = *(_OWORD *)&v308->__r_.__value_.__l.__data_;
      v430.__r_.__value_.__r.__words[2] = v308->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v430.__r_.__value_.__l.__data_ = v309;
      v308->__r_.__value_.__l.__size_ = 0;
      v308->__r_.__value_.__r.__words[2] = 0;
      v308->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v431, (int)v406.__r_.__value_.__l.__data_);
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v310 = &v431;
      }
      else {
        v310 = (std::string *)v431.__r_.__value_.__r.__words[0];
      }
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v311 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v311 = v431.__r_.__value_.__l.__size_;
      }
      v312 = std::string::append(&v430, (const std::string::value_type *)v310, v311);
      int v313 = (void *)v312->__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = v312->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v312->__r_.__value_.__r.__words[1] + 7);
      char v314 = HIBYTE(v312->__r_.__value_.__r.__words[2]);
      v312->__r_.__value_.__l.__size_ = 0;
      v312->__r_.__value_.__r.__words[2] = 0;
      v312->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v409) < 0) {
        operator delete(v408);
      }
      v408 = v313;
      *(void *)&long long v409 = __str.__r_.__value_.__r.__words[0];
      *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7);
      HIBYTE(v409) = v314;
      if (SHIBYTE(v431.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v431.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v430.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v430.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v428.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v428.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v413.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v413.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v414.__r_.__value_.__r.__words[2]) < 0)
      {
        int v163 = (void *)v414.__r_.__value_.__r.__words[0];
LABEL_303:
        operator delete(v163);
      }
LABEL_304:
      uint64_t v164 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v164, OS_LOG_TYPE_ERROR))
      {
        int v341 = &v408;
        if (v409 < 0) {
          int v341 = v408;
        }
        LODWORD(v431.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v431.__r_.__value_.__r.__words + 4) = (std::string::size_type)v341;
        _os_log_error_impl((void *)&_mh_execute_header, v164, OS_LOG_TYPE_ERROR, "Failed to Response code: %{public}s", (uint8_t *)&v431, 0xCu);
      }
LABEL_305:
      if (SHIBYTE(v409) < 0)
      {
        *(void *)&long long v409 = 0;
        int v165 = v408;
      }
      else
      {
        HIBYTE(v409) = 0;
        int v165 = &v408;
      }
      *int v165 = 0;
      CFArrayRef v166 = (const __CFArray *)CFDictionaryGetValue(v117, @"EventCode");
      CFArrayRef v167 = v166;
      if (!v166 || (CFTypeID v168 = CFGetTypeID(v166), v168 != CFArrayGetTypeID()))
      {
        memset(&v431, 0, sizeof(v431));
        ctu::cf::assign();
        std::string v430 = v431;
        int v186 = std::string::insert(&v430, 0, "Missing key: ", 0xDuLL);
LABEL_337:
        char v187 = (void *)v186->__r_.__value_.__r.__words[0];
        v428.__r_.__value_.__r.__words[0] = v186->__r_.__value_.__l.__size_;
        *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v186->__r_.__value_.__r.__words[1] + 7);
        char v188 = HIBYTE(v186->__r_.__value_.__r.__words[2]);
        v186->__r_.__value_.__l.__size_ = 0;
        v186->__r_.__value_.__r.__words[2] = 0;
        v186->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v409) < 0) {
          operator delete(v408);
        }
        v408 = v187;
        *(void *)&long long v409 = v428.__r_.__value_.__r.__words[0];
        *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7);
        HIBYTE(v409) = v188;
        if ((SHIBYTE(v430.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_342;
        }
        std::string::size_type v189 = (void *)v430.__r_.__value_.__r.__words[0];
        goto LABEL_341;
      }
      CFIndex v169 = CFArrayGetCount(v167);
      if (v169 < 1) {
        goto LABEL_343;
      }
      CFIndex v170 = 0;
      while (1)
      {
        CFNumberRef v171 = (const __CFNumber *)CFArrayGetValueAtIndex(v167, v170);
        CFNumberRef v172 = v171;
        if (v171)
        {
          CFTypeID v173 = CFGetTypeID(v171);
          if (v173 == CFNumberGetTypeID()) {
            CFNumberRef v174 = v172;
          }
          else {
            CFNumberRef v174 = 0;
          }
        }
        else
        {
          CFNumberRef v174 = 0;
        }
        LODWORD(v406.__r_.__value_.__l.__data_) = 0;
        if (!CFNumberGetValue(v174, kCFNumberIntType, &v406))
        {
          memset(&v431, 0, sizeof(v431));
          ctu::cf::assign();
          std::string v430 = v431;
          int v186 = std::string::insert(&v430, 0, "Failed to read key: ", 0x14uLL);
          goto LABEL_337;
        }
        int v175 = (int)v406.__r_.__value_.__l.__data_;
        if (LODWORD(v406.__r_.__value_.__l.__data_) >= 0x33) {
          break;
        }
        v176 = *(char **)&__val[20];
        if (*(void *)&__val[20] >= *(void *)&__val[22])
        {
          int v178 = *(char **)&__val[18];
          uint64_t v179 = (uint64_t)(*(void *)&__val[20] - *(void *)&__val[18]) >> 2;
          unint64_t v180 = v179 + 1;
          if ((unint64_t)(v179 + 1) >> 62) {
            sub_10006A748();
          }
          uint64_t v181 = *(void *)&__val[22] - *(void *)&__val[18];
          if ((uint64_t)(*(void *)&__val[22] - *(void *)&__val[18]) >> 1 > v180) {
            unint64_t v180 = v181 >> 1;
          }
          BOOL v155 = (unint64_t)v181 >= 0x7FFFFFFFFFFFFFFCLL;
          unint64_t v182 = 0x3FFFFFFFFFFFFFFFLL;
          if (!v155) {
            unint64_t v182 = v180;
          }
          if (v182)
          {
            unint64_t v182 = (unint64_t)sub_1000492A8(v182);
            v176 = *(char **)&__val[20];
            int v178 = *(char **)&__val[18];
            int v175 = (int)v406.__r_.__value_.__l.__data_;
          }
          else
          {
            uint64_t v183 = 0;
          }
          v184 = (_DWORD *)(v182 + 4 * v179);
          _DWORD *v184 = v175;
          unint64_t v177 = v184 + 1;
          while (v176 != v178)
          {
            int v185 = *((_DWORD *)v176 - 1);
            v176 -= 4;
            *--v184 = v185;
          }
          *(void *)&__val[18] = v184;
          *(void *)&__val[20] = v177;
          *(void *)&__val[22] = v182 + 4 * v183;
          if (v178) {
            operator delete(v178);
          }
        }
        else
        {
          **(_DWORD **)&__val[20] = v406.__r_.__value_.__l.__data_;
          unint64_t v177 = v176 + 4;
        }
        *(void *)&__val[20] = v177;
        if (++v170 == v169) {
          goto LABEL_343;
        }
      }
      sub_100058DB0(&v414, "Invalid value for [");
      memset(&v431, 0, sizeof(v431));
      ctu::cf::assign();
      std::string v413 = v431;
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v315 = &v413;
      }
      else {
        int v315 = (std::string *)v413.__r_.__value_.__r.__words[0];
      }
      if ((v413.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v316 = HIBYTE(v413.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v316 = v413.__r_.__value_.__l.__size_;
      }
      int v317 = std::string::append(&v414, (const std::string::value_type *)v315, v316);
      long long v318 = *(_OWORD *)&v317->__r_.__value_.__l.__data_;
      v428.__r_.__value_.__r.__words[2] = v317->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v428.__r_.__value_.__l.__data_ = v318;
      v317->__r_.__value_.__l.__size_ = 0;
      v317->__r_.__value_.__r.__words[2] = 0;
      v317->__r_.__value_.__r.__words[0] = 0;
      int v319 = std::string::append(&v428, "]: ", 3uLL);
      long long v320 = *(_OWORD *)&v319->__r_.__value_.__l.__data_;
      v430.__r_.__value_.__r.__words[2] = v319->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v430.__r_.__value_.__l.__data_ = v320;
      v319->__r_.__value_.__l.__size_ = 0;
      v319->__r_.__value_.__r.__words[2] = 0;
      v319->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v431, (int)v406.__r_.__value_.__l.__data_);
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v321 = &v431;
      }
      else {
        int v321 = (std::string *)v431.__r_.__value_.__r.__words[0];
      }
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v322 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v322 = v431.__r_.__value_.__l.__size_;
      }
      int v323 = std::string::append(&v430, (const std::string::value_type *)v321, v322);
      v324 = (void *)v323->__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = v323->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v323->__r_.__value_.__r.__words[1] + 7);
      char v325 = HIBYTE(v323->__r_.__value_.__r.__words[2]);
      v323->__r_.__value_.__l.__size_ = 0;
      v323->__r_.__value_.__r.__words[2] = 0;
      v323->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v409) < 0) {
        operator delete(v408);
      }
      v408 = v324;
      *(void *)&long long v409 = __str.__r_.__value_.__r.__words[0];
      *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7);
      HIBYTE(v409) = v325;
      if (SHIBYTE(v431.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v431.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v430.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v430.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v428.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v428.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v413.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v413.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v414.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::size_type v189 = (void *)v414.__r_.__value_.__r.__words[0];
LABEL_341:
        operator delete(v189);
      }
LABEL_342:
      v190 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v190, OS_LOG_TYPE_ERROR))
      {
        v342 = &v408;
        if (v409 < 0) {
          v342 = v408;
        }
        LODWORD(v431.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v431.__r_.__value_.__r.__words + 4) = (std::string::size_type)v342;
        _os_log_error_impl((void *)&_mh_execute_header, v190, OS_LOG_TYPE_ERROR, "Failed to Response code: %{public}s", (uint8_t *)&v431, 0xCu);
      }
LABEL_343:
      if (SHIBYTE(v409) < 0)
      {
        *(void *)&long long v409 = 0;
        char v191 = v408;
      }
      else
      {
        HIBYTE(v409) = 0;
        char v191 = &v408;
      }
      *char v191 = 0;
      CFArrayRef v192 = (const __CFArray *)CFDictionaryGetValue(v117, @"Category");
      CFArrayRef v193 = v192;
      if (!v192 || (CFTypeID v194 = CFGetTypeID(v192), v194 != CFArrayGetTypeID()))
      {
        memset(&v431, 0, sizeof(v431));
        ctu::cf::assign();
        std::string v430 = v431;
        __int16 v212 = std::string::insert(&v430, 0, "Missing key: ", 0xDuLL);
LABEL_375:
        int v213 = (void *)v212->__r_.__value_.__r.__words[0];
        v428.__r_.__value_.__r.__words[0] = v212->__r_.__value_.__l.__size_;
        *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v212->__r_.__value_.__r.__words[1] + 7);
        char v214 = HIBYTE(v212->__r_.__value_.__r.__words[2]);
        v212->__r_.__value_.__l.__size_ = 0;
        v212->__r_.__value_.__r.__words[2] = 0;
        v212->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v409) < 0) {
          operator delete(v408);
        }
        v408 = v213;
        *(void *)&long long v409 = v428.__r_.__value_.__r.__words[0];
        *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7);
        HIBYTE(v409) = v214;
        if ((SHIBYTE(v430.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_380;
        }
        int v215 = (void *)v430.__r_.__value_.__r.__words[0];
        goto LABEL_379;
      }
      CFIndex v195 = CFArrayGetCount(v193);
      if (v195 < 1) {
        goto LABEL_381;
      }
      CFIndex v196 = 0;
      while (1)
      {
        CFNumberRef v197 = (const __CFNumber *)CFArrayGetValueAtIndex(v193, v196);
        CFNumberRef v198 = v197;
        if (v197)
        {
          CFTypeID v199 = CFGetTypeID(v197);
          if (v199 == CFNumberGetTypeID()) {
            CFNumberRef v200 = v198;
          }
          else {
            CFNumberRef v200 = 0;
          }
        }
        else
        {
          CFNumberRef v200 = 0;
        }
        LODWORD(v406.__r_.__value_.__l.__data_) = 0;
        if (!CFNumberGetValue(v200, kCFNumberIntType, &v406))
        {
          memset(&v431, 0, sizeof(v431));
          ctu::cf::assign();
          std::string v430 = v431;
          __int16 v212 = std::string::insert(&v430, 0, "Failed to read key: ", 0x14uLL);
          goto LABEL_375;
        }
        int v201 = (int)v406.__r_.__value_.__l.__data_;
        if (LODWORD(v406.__r_.__value_.__l.__data_) >= 0xD) {
          break;
        }
        v202 = *(char **)&__val[4];
        if (*(void *)&__val[4] >= *(void *)&__val[6])
        {
          v204 = *(char **)&__val[2];
          uint64_t v205 = (uint64_t)(*(void *)&__val[4] - *(void *)&__val[2]) >> 2;
          unint64_t v206 = v205 + 1;
          if ((unint64_t)(v205 + 1) >> 62) {
            sub_10006A748();
          }
          uint64_t v207 = *(void *)&__val[6] - *(void *)&__val[2];
          if ((uint64_t)(*(void *)&__val[6] - *(void *)&__val[2]) >> 1 > v206) {
            unint64_t v206 = v207 >> 1;
          }
          BOOL v155 = (unint64_t)v207 >= 0x7FFFFFFFFFFFFFFCLL;
          unint64_t v208 = 0x3FFFFFFFFFFFFFFFLL;
          if (!v155) {
            unint64_t v208 = v206;
          }
          if (v208)
          {
            unint64_t v208 = (unint64_t)sub_1000492A8(v208);
            v202 = *(char **)&__val[4];
            v204 = *(char **)&__val[2];
            int v201 = (int)v406.__r_.__value_.__l.__data_;
          }
          else
          {
            uint64_t v209 = 0;
          }
          __int16 v210 = (_DWORD *)(v208 + 4 * v205);
          _DWORD *v210 = v201;
          int v203 = v210 + 1;
          while (v202 != v204)
          {
            int v211 = *((_DWORD *)v202 - 1);
            v202 -= 4;
            *--__int16 v210 = v211;
          }
          *(void *)&__val[2] = v210;
          *(void *)&__val[4] = v203;
          *(void *)&__val[6] = v208 + 4 * v209;
          if (v204) {
            operator delete(v204);
          }
        }
        else
        {
          **(_DWORD **)&__val[4] = v406.__r_.__value_.__l.__data_;
          int v203 = v202 + 4;
        }
        *(void *)&__val[4] = v203;
        if (++v196 == v195) {
          goto LABEL_381;
        }
      }
      sub_100058DB0(&v414, "Invalid value for [");
      memset(&v431, 0, sizeof(v431));
      ctu::cf::assign();
      std::string v413 = v431;
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v326 = &v413;
      }
      else {
        v326 = (std::string *)v413.__r_.__value_.__r.__words[0];
      }
      if ((v413.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v327 = HIBYTE(v413.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v327 = v413.__r_.__value_.__l.__size_;
      }
      v328 = std::string::append(&v414, (const std::string::value_type *)v326, v327);
      long long v329 = *(_OWORD *)&v328->__r_.__value_.__l.__data_;
      v428.__r_.__value_.__r.__words[2] = v328->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v428.__r_.__value_.__l.__data_ = v329;
      v328->__r_.__value_.__l.__size_ = 0;
      v328->__r_.__value_.__r.__words[2] = 0;
      v328->__r_.__value_.__r.__words[0] = 0;
      v330 = std::string::append(&v428, "]: ", 3uLL);
      long long v331 = *(_OWORD *)&v330->__r_.__value_.__l.__data_;
      v430.__r_.__value_.__r.__words[2] = v330->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v430.__r_.__value_.__l.__data_ = v331;
      v330->__r_.__value_.__l.__size_ = 0;
      v330->__r_.__value_.__r.__words[2] = 0;
      v330->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v431, (int)v406.__r_.__value_.__l.__data_);
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v332 = &v431;
      }
      else {
        v332 = (std::string *)v431.__r_.__value_.__r.__words[0];
      }
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v333 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v333 = v431.__r_.__value_.__l.__size_;
      }
      v334 = std::string::append(&v430, (const std::string::value_type *)v332, v333);
      int v335 = (void *)v334->__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = v334->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v334->__r_.__value_.__r.__words[1] + 7);
      char v336 = HIBYTE(v334->__r_.__value_.__r.__words[2]);
      v334->__r_.__value_.__l.__size_ = 0;
      v334->__r_.__value_.__r.__words[2] = 0;
      v334->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v409) < 0) {
        operator delete(v408);
      }
      v408 = v335;
      *(void *)&long long v409 = __str.__r_.__value_.__r.__words[0];
      *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7);
      HIBYTE(v409) = v336;
      if (SHIBYTE(v431.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v431.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v430.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v430.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v428.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v428.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v413.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v413.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v414.__r_.__value_.__r.__words[2]) < 0)
      {
        int v215 = (void *)v414.__r_.__value_.__r.__words[0];
LABEL_379:
        operator delete(v215);
      }
LABEL_380:
      __int16 v216 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v216, OS_LOG_TYPE_ERROR))
      {
        int v343 = &v408;
        if (v409 < 0) {
          int v343 = v408;
        }
        LODWORD(v431.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v431.__r_.__value_.__r.__words + 4) = (std::string::size_type)v343;
        _os_log_error_impl((void *)&_mh_execute_header, v216, OS_LOG_TYPE_ERROR, "Failed to parse category: %{public}s", (uint8_t *)&v431, 0xCu);
      }
LABEL_381:
      if (SHIBYTE(v409) < 0)
      {
        *(void *)&long long v409 = 0;
        uint64_t v217 = v408;
      }
      else
      {
        HIBYTE(v409) = 0;
        uint64_t v217 = &v408;
      }
      *uint64_t v217 = 0;
      CFNumberRef v218 = (const __CFNumber *)CFDictionaryGetValue(v117, @"Urgency");
      CFNumberRef v219 = v218;
      if (!v218 || (CFTypeID v220 = CFGetTypeID(v218), v220 != CFNumberGetTypeID()))
      {
        memset(&v431, 0, sizeof(v431));
        ctu::cf::assign();
        std::string v430 = v431;
        int v233 = std::string::insert(&v430, 0, "Missing key: ", 0xDuLL);
LABEL_413:
        v234 = (void *)v233->__r_.__value_.__r.__words[0];
        v428.__r_.__value_.__r.__words[0] = v233->__r_.__value_.__l.__size_;
        *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v233->__r_.__value_.__r.__words[1] + 7);
        char v235 = HIBYTE(v233->__r_.__value_.__r.__words[2]);
        v233->__r_.__value_.__l.__size_ = 0;
        v233->__r_.__value_.__r.__words[2] = 0;
        v233->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v409) < 0) {
          operator delete(v408);
        }
        v408 = v234;
        *(void *)&long long v409 = v428.__r_.__value_.__r.__words[0];
        *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7);
        HIBYTE(v409) = v235;
        if ((SHIBYTE(v430.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_418;
        }
        v232 = (void *)v430.__r_.__value_.__r.__words[0];
        goto LABEL_417;
      }
      if (!CFNumberGetValue(v219, kCFNumberIntType, &__val[8]))
      {
        memset(&v431, 0, sizeof(v431));
        ctu::cf::assign();
        std::string v430 = v431;
        int v233 = std::string::insert(&v430, 0, "Failed to read key: ", 0x14uLL);
        goto LABEL_413;
      }
      if (__val[8] < 6u) {
        goto LABEL_419;
      }
      sub_100058DB0(&v414, "Invalid value for [");
      memset(&v431, 0, sizeof(v431));
      ctu::cf::assign();
      std::string v413 = v431;
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v221 = &v413;
      }
      else {
        int v221 = (std::string *)v413.__r_.__value_.__r.__words[0];
      }
      if ((v413.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v222 = HIBYTE(v413.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v222 = v413.__r_.__value_.__l.__size_;
      }
      int v223 = std::string::append(&v414, (const std::string::value_type *)v221, v222);
      long long v224 = *(_OWORD *)&v223->__r_.__value_.__l.__data_;
      v428.__r_.__value_.__r.__words[2] = v223->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v428.__r_.__value_.__l.__data_ = v224;
      v223->__r_.__value_.__l.__size_ = 0;
      v223->__r_.__value_.__r.__words[2] = 0;
      v223->__r_.__value_.__r.__words[0] = 0;
      int v225 = std::string::append(&v428, "]: ", 3uLL);
      long long v226 = *(_OWORD *)&v225->__r_.__value_.__l.__data_;
      v430.__r_.__value_.__r.__words[2] = v225->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v430.__r_.__value_.__l.__data_ = v226;
      v225->__r_.__value_.__l.__size_ = 0;
      v225->__r_.__value_.__r.__words[2] = 0;
      v225->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v431, __val[8]);
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v227 = &v431;
      }
      else {
        int v227 = (std::string *)v431.__r_.__value_.__r.__words[0];
      }
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v228 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v228 = v431.__r_.__value_.__l.__size_;
      }
      uint64_t v229 = std::string::append(&v430, (const std::string::value_type *)v227, v228);
      v230 = (void *)v229->__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = v229->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v229->__r_.__value_.__r.__words[1] + 7);
      char v231 = HIBYTE(v229->__r_.__value_.__r.__words[2]);
      v229->__r_.__value_.__l.__size_ = 0;
      v229->__r_.__value_.__r.__words[2] = 0;
      v229->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v409) < 0) {
        operator delete(v408);
      }
      v408 = v230;
      *(void *)&long long v409 = __str.__r_.__value_.__r.__words[0];
      *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7);
      HIBYTE(v409) = v231;
      if (SHIBYTE(v431.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v431.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v430.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v430.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v428.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v428.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v413.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v413.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v414.__r_.__value_.__r.__words[2]) < 0)
      {
        v232 = (void *)v414.__r_.__value_.__r.__words[0];
LABEL_417:
        operator delete(v232);
      }
LABEL_418:
      v236 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v236, OS_LOG_TYPE_ERROR))
      {
        v338 = &v408;
        if (v409 < 0) {
          v338 = v408;
        }
        LODWORD(v431.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v431.__r_.__value_.__r.__words + 4) = (std::string::size_type)v338;
        _os_log_error_impl((void *)&_mh_execute_header, v236, OS_LOG_TYPE_ERROR, "Failed to parse category: %{public}s", (uint8_t *)&v431, 0xCu);
      }
LABEL_419:
      if (SHIBYTE(v409) < 0)
      {
        *(void *)&long long v409 = 0;
        int v237 = v408;
      }
      else
      {
        HIBYTE(v409) = 0;
        int v237 = &v408;
      }
      *int v237 = 0;
      CFNumberRef v238 = (const __CFNumber *)CFDictionaryGetValue(v117, @"Severity");
      CFNumberRef v239 = v238;
      if (!v238 || (CFTypeID v240 = CFGetTypeID(v238), v240 != CFNumberGetTypeID()))
      {
        memset(&v431, 0, sizeof(v431));
        ctu::cf::assign();
        std::string v430 = v431;
        int v253 = std::string::insert(&v430, 0, "Missing key: ", 0xDuLL);
LABEL_451:
        v254 = (void *)v253->__r_.__value_.__r.__words[0];
        v428.__r_.__value_.__r.__words[0] = v253->__r_.__value_.__l.__size_;
        *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v253->__r_.__value_.__r.__words[1] + 7);
        char v255 = HIBYTE(v253->__r_.__value_.__r.__words[2]);
        v253->__r_.__value_.__l.__size_ = 0;
        v253->__r_.__value_.__r.__words[2] = 0;
        v253->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v409) < 0) {
          operator delete(v408);
        }
        v408 = v254;
        *(void *)&long long v409 = v428.__r_.__value_.__r.__words[0];
        *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7);
        HIBYTE(v409) = v255;
        if ((SHIBYTE(v430.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_456;
        }
        v252 = (void *)v430.__r_.__value_.__r.__words[0];
        goto LABEL_455;
      }
      if (!CFNumberGetValue(v239, kCFNumberIntType, &__val[9]))
      {
        memset(&v431, 0, sizeof(v431));
        ctu::cf::assign();
        std::string v430 = v431;
        int v253 = std::string::insert(&v430, 0, "Failed to read key: ", 0x14uLL);
        goto LABEL_451;
      }
      if (__val[9] < 6u) {
        goto LABEL_457;
      }
      sub_100058DB0(&v414, "Invalid value for [");
      memset(&v431, 0, sizeof(v431));
      ctu::cf::assign();
      std::string v413 = v431;
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v241 = &v413;
      }
      else {
        int v241 = (std::string *)v413.__r_.__value_.__r.__words[0];
      }
      if ((v413.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v242 = HIBYTE(v413.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v242 = v413.__r_.__value_.__l.__size_;
      }
      int v243 = std::string::append(&v414, (const std::string::value_type *)v241, v242);
      long long v244 = *(_OWORD *)&v243->__r_.__value_.__l.__data_;
      v428.__r_.__value_.__r.__words[2] = v243->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v428.__r_.__value_.__l.__data_ = v244;
      v243->__r_.__value_.__l.__size_ = 0;
      v243->__r_.__value_.__r.__words[2] = 0;
      v243->__r_.__value_.__r.__words[0] = 0;
      int v245 = std::string::append(&v428, "]: ", 3uLL);
      long long v246 = *(_OWORD *)&v245->__r_.__value_.__l.__data_;
      v430.__r_.__value_.__r.__words[2] = v245->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v430.__r_.__value_.__l.__data_ = v246;
      v245->__r_.__value_.__l.__size_ = 0;
      v245->__r_.__value_.__r.__words[2] = 0;
      v245->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v431, __val[9]);
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v247 = &v431;
      }
      else {
        int v247 = (std::string *)v431.__r_.__value_.__r.__words[0];
      }
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v248 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v248 = v431.__r_.__value_.__l.__size_;
      }
      int v249 = std::string::append(&v430, (const std::string::value_type *)v247, v248);
      v250 = (void *)v249->__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = v249->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v249->__r_.__value_.__r.__words[1] + 7);
      char v251 = HIBYTE(v249->__r_.__value_.__r.__words[2]);
      v249->__r_.__value_.__l.__size_ = 0;
      v249->__r_.__value_.__r.__words[2] = 0;
      v249->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v409) < 0) {
        operator delete(v408);
      }
      v408 = v250;
      *(void *)&long long v409 = __str.__r_.__value_.__r.__words[0];
      *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7);
      HIBYTE(v409) = v251;
      if (SHIBYTE(v431.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v431.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v430.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v430.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v428.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v428.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v413.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v413.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v414.__r_.__value_.__r.__words[2]) < 0)
      {
        v252 = (void *)v414.__r_.__value_.__r.__words[0];
LABEL_455:
        operator delete(v252);
      }
LABEL_456:
      v256 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v256, OS_LOG_TYPE_ERROR))
      {
        int v339 = &v408;
        if (v409 < 0) {
          int v339 = v408;
        }
        LODWORD(v431.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v431.__r_.__value_.__r.__words + 4) = (std::string::size_type)v339;
        _os_log_error_impl((void *)&_mh_execute_header, v256, OS_LOG_TYPE_ERROR, "Failed to parse severity: %{public}s", (uint8_t *)&v431, 0xCu);
      }
LABEL_457:
      if (SHIBYTE(v409) < 0)
      {
        *(void *)&long long v409 = 0;
        int v257 = v408;
      }
      else
      {
        HIBYTE(v409) = 0;
        int v257 = &v408;
      }
      *int v257 = 0;
      CFNumberRef v258 = (const __CFNumber *)CFDictionaryGetValue(v117, @"Certainty");
      CFNumberRef v259 = v258;
      if (!v258 || (CFTypeID v260 = CFGetTypeID(v258), v260 != CFNumberGetTypeID()))
      {
        memset(&v431, 0, sizeof(v431));
        ctu::cf::assign();
        std::string v430 = v431;
        int v273 = std::string::insert(&v430, 0, "Missing key: ", 0xDuLL);
LABEL_489:
        v274 = (void *)v273->__r_.__value_.__r.__words[0];
        v428.__r_.__value_.__r.__words[0] = v273->__r_.__value_.__l.__size_;
        *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v273->__r_.__value_.__r.__words[1] + 7);
        char v275 = HIBYTE(v273->__r_.__value_.__r.__words[2]);
        v273->__r_.__value_.__l.__size_ = 0;
        v273->__r_.__value_.__r.__words[2] = 0;
        v273->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v409) < 0) {
          operator delete(v408);
        }
        v408 = v274;
        *(void *)&long long v409 = v428.__r_.__value_.__r.__words[0];
        *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7);
        HIBYTE(v409) = v275;
        if ((SHIBYTE(v430.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_494;
        }
        v272 = (void *)v430.__r_.__value_.__r.__words[0];
        goto LABEL_493;
      }
      if (!CFNumberGetValue(v259, kCFNumberIntType, &__val[10]))
      {
        memset(&v431, 0, sizeof(v431));
        ctu::cf::assign();
        std::string v430 = v431;
        int v273 = std::string::insert(&v430, 0, "Failed to read key: ", 0x14uLL);
        goto LABEL_489;
      }
      if (__val[10] < 6u) {
        goto LABEL_495;
      }
      sub_100058DB0(&v414, "Invalid value for [");
      memset(&v431, 0, sizeof(v431));
      ctu::cf::assign();
      std::string v413 = v431;
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v261 = &v413;
      }
      else {
        int v261 = (std::string *)v413.__r_.__value_.__r.__words[0];
      }
      if ((v413.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v262 = HIBYTE(v413.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v262 = v413.__r_.__value_.__l.__size_;
      }
      int v263 = std::string::append(&v414, (const std::string::value_type *)v261, v262);
      long long v264 = *(_OWORD *)&v263->__r_.__value_.__l.__data_;
      v428.__r_.__value_.__r.__words[2] = v263->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v428.__r_.__value_.__l.__data_ = v264;
      v263->__r_.__value_.__l.__size_ = 0;
      v263->__r_.__value_.__r.__words[2] = 0;
      v263->__r_.__value_.__r.__words[0] = 0;
      int v265 = std::string::append(&v428, "]: ", 3uLL);
      long long v266 = *(_OWORD *)&v265->__r_.__value_.__l.__data_;
      v430.__r_.__value_.__r.__words[2] = v265->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v430.__r_.__value_.__l.__data_ = v266;
      v265->__r_.__value_.__l.__size_ = 0;
      v265->__r_.__value_.__r.__words[2] = 0;
      v265->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v431, __val[10]);
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v267 = &v431;
      }
      else {
        int v267 = (std::string *)v431.__r_.__value_.__r.__words[0];
      }
      if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v268 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v268 = v431.__r_.__value_.__l.__size_;
      }
      int v269 = std::string::append(&v430, (const std::string::value_type *)v267, v268);
      v270 = (void *)v269->__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = v269->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v269->__r_.__value_.__r.__words[1] + 7);
      char v271 = HIBYTE(v269->__r_.__value_.__r.__words[2]);
      v269->__r_.__value_.__l.__size_ = 0;
      v269->__r_.__value_.__r.__words[2] = 0;
      v269->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v409) < 0) {
        operator delete(v408);
      }
      v408 = v270;
      *(void *)&long long v409 = __str.__r_.__value_.__r.__words[0];
      *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7);
      HIBYTE(v409) = v271;
      if (SHIBYTE(v431.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v431.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v430.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v430.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v428.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v428.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v413.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v413.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v414.__r_.__value_.__r.__words[2]) < 0)
      {
        v272 = (void *)v414.__r_.__value_.__r.__words[0];
LABEL_493:
        operator delete(v272);
      }
LABEL_494:
      v276 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v276, OS_LOG_TYPE_ERROR))
      {
        v340 = &v408;
        if (v409 < 0) {
          v340 = v408;
        }
        LODWORD(v431.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v431.__r_.__value_.__r.__words + 4) = (std::string::size_type)v340;
        _os_log_error_impl((void *)&_mh_execute_header, v276, OS_LOG_TYPE_ERROR, "Failed to parse certainty: %{public}s", (uint8_t *)&v431, 0xCu);
      }
LABEL_495:
      int v277 = CFDictionaryGetValue(v117, @"Headline");
      if (v277 && (CFTypeID v278 = CFGetTypeID(v277), v278 == CFStringGetTypeID()))
      {
        memset(&v431, 0, sizeof(v431));
        ctu::cf::assign();
        v430.__r_.__value_.__r.__words[0] = v431.__r_.__value_.__l.__size_;
        int v279 = (void *)v431.__r_.__value_.__r.__words[0];
        *(std::string::size_type *)((char *)v430.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v431.__r_.__value_.__r.__words[1] + 7);
        char v280 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(v421[2]) < 0) {
          operator delete(v421[0]);
        }
        v421[0] = v279;
        v421[1] = v430.__r_.__value_.__l.__data_;
        *(void **)((char *)&v421[1] + 7) = *(void **)((char *)v430.__r_.__value_.__r.__words + 7);
        HIBYTE(v421[2]) = v280;
      }
      else
      {
        int v281 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v281, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v431.__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v281, OS_LOG_TYPE_ERROR, "Failed to parse headline", (uint8_t *)&v431, 2u);
        }
      }
      v282 = CFDictionaryGetValue(v117, @"Instruction");
      if (v282 && (CFTypeID v283 = CFGetTypeID(v282), v283 == CFStringGetTypeID()))
      {
        memset(&v431, 0, sizeof(v431));
        ctu::cf::assign();
        v430.__r_.__value_.__r.__words[0] = v431.__r_.__value_.__l.__size_;
        v284 = (void *)v431.__r_.__value_.__r.__words[0];
        *(std::string::size_type *)((char *)v430.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v431.__r_.__value_.__r.__words[1] + 7);
        char v285 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(v422) < 0) {
          operator delete(v421[3]);
        }
        v421[3] = v284;
        *(void *)&long long v422 = v430.__r_.__value_.__r.__words[0];
        *(void *)((char *)&v422 + 7) = *(std::string::size_type *)((char *)v430.__r_.__value_.__r.__words + 7);
        HIBYTE(v422) = v285;
      }
      else
      {
        v286 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v286, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v431.__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v286, OS_LOG_TYPE_ERROR, "Failed to parse instruction", (uint8_t *)&v431, 2u);
        }
      }
      int v287 = CFDictionaryGetValue(v117, @"Description");
      if (v287 && (CFTypeID v288 = CFGetTypeID(v287), v288 == CFStringGetTypeID()))
      {
        memset(&v431, 0, sizeof(v431));
        ctu::cf::assign();
        v430.__r_.__value_.__r.__words[0] = v431.__r_.__value_.__l.__size_;
        std::string::size_type v289 = v431.__r_.__value_.__r.__words[0];
        *(std::string::size_type *)((char *)v430.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v431.__r_.__value_.__r.__words[1] + 7);
        char v290 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
        if ((v423[23] & 0x80000000) != 0) {
          operator delete(*(void **)v423);
        }
        *(void *)int v423 = v289;
        *(void *)&v423[8] = v430.__r_.__value_.__r.__words[0];
        *(void *)&v423[15] = *(std::string::size_type *)((char *)v430.__r_.__value_.__r.__words + 7);
        v423[23] = v290;
      }
      else
      {
        int v291 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v291, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v431.__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v291, OS_LOG_TYPE_ERROR, "Failed to parse description", (uint8_t *)&v431, 2u);
        }
      }
      memset(&__str, 0, sizeof(__str));
      CFDictionaryGetValue(v117, @"ExpiryTimestamp");
      memset(&v407, 0, sizeof(v407));
      ctu::cf::assign();
      std::string __str = v407;
      memset(&v407, 0, sizeof(v407));
      std::string::size_type v292 = __str.__r_.__value_.__l.__size_;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v292 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      }
      if (v292)
      {
        std::string::operator=((std::string *)&v425, &__str);
        memset(&v406, 0, sizeof(v406));
        CFDictionaryGetValue(v117, @"EffectiveTimestamp");
        memset(&v405, 0, sizeof(v405));
        ctu::cf::assign();
        std::string v406 = v405;
        memset(&v405, 0, sizeof(v405));
        std::string::size_type v293 = v406.__r_.__value_.__l.__size_;
        if ((v406.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v293 = HIBYTE(v406.__r_.__value_.__r.__words[2]);
        }
        if (v293)
        {
          std::string::operator=((std::string *)&v423[24], &v406);
          CFDictionaryRef v294 = (const __CFDictionary *)CFDictionaryGetValue(v117, @"Parameters");
          CFDictionaryRef v295 = v294;
          if (v294 && (CFTypeID v296 = CFGetTypeID(v294), v296 == CFDictionaryGetTypeID()))
          {
            if (SHIBYTE(v409) < 0)
            {
              *(void *)&long long v409 = 0;
              int v297 = v408;
            }
            else
            {
              HIBYTE(v409) = 0;
              int v297 = &v408;
            }
            *int v297 = 0;
            CFNumberRef v344 = (const __CFNumber *)CFDictionaryGetValue(v295, @"WeaHandlingType");
            CFNumberRef v345 = v344;
            if (v344 && (CFTypeID v346 = CFGetTypeID(v344), v346 == CFNumberGetTypeID()))
            {
              if (CFNumberGetValue(v345, kCFNumberIntType, &v426[3]))
              {
                if (v426[3] >= 7u)
                {
                  sub_100058DB0(&v414, "Invalid value for [");
                  memset(&v431, 0, sizeof(v431));
                  ctu::cf::assign();
                  std::string v413 = v431;
                  if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    int v347 = &v413;
                  }
                  else {
                    int v347 = (std::string *)v413.__r_.__value_.__r.__words[0];
                  }
                  if ((v413.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    std::string::size_type v348 = HIBYTE(v413.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    std::string::size_type v348 = v413.__r_.__value_.__l.__size_;
                  }
                  int v349 = std::string::append(&v414, (const std::string::value_type *)v347, v348);
                  long long v350 = *(_OWORD *)&v349->__r_.__value_.__l.__data_;
                  v428.__r_.__value_.__r.__words[2] = v349->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&v428.__r_.__value_.__l.__data_ = v350;
                  v349->__r_.__value_.__l.__size_ = 0;
                  v349->__r_.__value_.__r.__words[2] = 0;
                  v349->__r_.__value_.__r.__words[0] = 0;
                  int v351 = std::string::append(&v428, "]: ", 3uLL);
                  long long v352 = *(_OWORD *)&v351->__r_.__value_.__l.__data_;
                  v430.__r_.__value_.__r.__words[2] = v351->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&v430.__r_.__value_.__l.__data_ = v352;
                  v351->__r_.__value_.__l.__size_ = 0;
                  v351->__r_.__value_.__r.__words[2] = 0;
                  v351->__r_.__value_.__r.__words[0] = 0;
                  std::to_string(&v431, v426[3]);
                  if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    int v353 = &v431;
                  }
                  else {
                    int v353 = (std::string *)v431.__r_.__value_.__r.__words[0];
                  }
                  if ((v431.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    std::string::size_type v354 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    std::string::size_type v354 = v431.__r_.__value_.__l.__size_;
                  }
                  int v355 = std::string::append(&v430, (const std::string::value_type *)v353, v354);
                  v356 = (void *)v355->__r_.__value_.__r.__words[0];
                  v429[0] = v355->__r_.__value_.__l.__size_;
                  *(void *)((char *)v429 + 7) = *(std::string::size_type *)((char *)&v355->__r_.__value_.__r.__words[1]
                                                                            + 7);
                  char v357 = HIBYTE(v355->__r_.__value_.__r.__words[2]);
                  v355->__r_.__value_.__l.__size_ = 0;
                  v355->__r_.__value_.__r.__words[2] = 0;
                  v355->__r_.__value_.__r.__words[0] = 0;
                  if (SHIBYTE(v409) < 0) {
                    operator delete(v408);
                  }
                  v408 = v356;
                  *(void *)&long long v409 = v429[0];
                  *(void *)((char *)&v409 + 7) = *(void *)((char *)v429 + 7);
                  HIBYTE(v409) = v357;
                  if (SHIBYTE(v431.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v431.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v430.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v430.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v428.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v428.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v413.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v413.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v414.__r_.__value_.__r.__words[2]) < 0)
                  {
                    v358 = (void *)v414.__r_.__value_.__r.__words[0];
                    goto LABEL_667;
                  }
                  goto LABEL_668;
                }
                goto LABEL_669;
              }
              memset(&v431, 0, sizeof(v431));
              ctu::cf::assign();
              std::string v430 = v431;
              v380 = std::string::insert(&v430, 0, "Failed to read key: ", 0x14uLL);
              int v381 = (void *)v380->__r_.__value_.__r.__words[0];
              v428.__r_.__value_.__r.__words[0] = v380->__r_.__value_.__l.__size_;
              *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v380->__r_.__value_.__r.__words[1] + 7);
              char v361 = HIBYTE(v380->__r_.__value_.__r.__words[2]);
              v380->__r_.__value_.__l.__size_ = 0;
              v380->__r_.__value_.__r.__words[2] = 0;
              v380->__r_.__value_.__r.__words[0] = 0;
              if (SHIBYTE(v409) < 0) {
                operator delete(v408);
              }
              v408 = v381;
              *(void *)&long long v409 = v428.__r_.__value_.__r.__words[0];
              uint64_t v362 = *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7);
            }
            else
            {
              memset(&v431, 0, sizeof(v431));
              ctu::cf::assign();
              std::string v430 = v431;
              int v359 = std::string::insert(&v430, 0, "Missing key: ", 0xDuLL);
              v360 = (void *)v359->__r_.__value_.__r.__words[0];
              v428.__r_.__value_.__r.__words[0] = v359->__r_.__value_.__l.__size_;
              *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v359->__r_.__value_.__r.__words[1] + 7);
              char v361 = HIBYTE(v359->__r_.__value_.__r.__words[2]);
              v359->__r_.__value_.__l.__size_ = 0;
              v359->__r_.__value_.__r.__words[2] = 0;
              v359->__r_.__value_.__r.__words[0] = 0;
              if (SHIBYTE(v409) < 0) {
                operator delete(v408);
              }
              v408 = v360;
              *(void *)&long long v409 = v428.__r_.__value_.__r.__words[0];
              uint64_t v362 = *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7);
            }
            *(void *)((char *)&v409 + 7) = v362;
            HIBYTE(v409) = v361;
            if (SHIBYTE(v430.__r_.__value_.__r.__words[2]) < 0)
            {
              v358 = (void *)v430.__r_.__value_.__r.__words[0];
LABEL_667:
              operator delete(v358);
            }
LABEL_668:
            int v363 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v363, OS_LOG_TYPE_ERROR))
            {
              v382 = &v408;
              if (v409 < 0) {
                v382 = v408;
              }
              LODWORD(v431.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)v431.__r_.__value_.__r.__words + 4) = (std::string::size_type)v382;
              _os_log_error_impl((void *)&_mh_execute_header, v363, OS_LOG_TYPE_ERROR, "Failed to parse Wea handling: %s", (uint8_t *)&v431, 0xCu);
            }
LABEL_669:
            v364 = CFDictionaryGetValue(v295, @"CmamText");
            if (v364 && (CFTypeID v365 = CFGetTypeID(v364), v365 == CFStringGetTypeID()))
            {
              memset(&v431, 0, sizeof(v431));
              ctu::cf::assign();
              v430.__r_.__value_.__r.__words[0] = v431.__r_.__value_.__l.__size_;
              v366 = (void *)v431.__r_.__value_.__r.__words[0];
              *(std::string::size_type *)((char *)v430.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v431.__r_.__value_.__r.__words[1] + 7);
              char v367 = HIBYTE(v431.__r_.__value_.__r.__words[2]);
              if (SHIBYTE(v418) < 0) {
                operator delete(v417[3]);
              }
              v417[3] = v366;
              *(void *)&long long v418 = v430.__r_.__value_.__r.__words[0];
              *(void *)((char *)&v418 + 7) = *(std::string::size_type *)((char *)v430.__r_.__value_.__r.__words + 7);
              HIBYTE(v418) = v367;
              v368 = CFDictionaryGetValue(v295, @"CmamLongText");
              if (v368 && (CFTypeID v369 = CFGetTypeID(v368), v369 == CFStringGetTypeID()))
              {
                memset(&v431, 0, sizeof(v431));
                ctu::cf::assign();
                v430.__r_.__value_.__r.__words[0] = v431.__r_.__value_.__l.__size_;
                v370 = (void *)v431.__r_.__value_.__r.__words[0];
                *(std::string::size_type *)((char *)v430.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v431.__r_.__value_.__r.__words[1] + 7);
                int v371 = (void *)HIBYTE(v431.__r_.__value_.__r.__words[2]);
                if (SHIBYTE(v417[2]) < 0) {
                  operator delete(v417[0]);
                }
                v417[0] = v370;
                v417[1] = v430.__r_.__value_.__l.__data_;
                *(void **)((char *)&v417[1] + 7) = *(void **)((char *)v430.__r_.__value_.__r.__words + 7);
                HIBYTE(v417[2]) = (_BYTE)v371;
                uint64_t v372 = HIBYTE(v418);
                if (v418 < 0) {
                  uint64_t v372 = v418;
                }
                if (v372 || ((char)v371 >= 0 ? (int v373 = v371) : (int v373 = v417[1]), v373))
                {
                  sub_1004AB928(&v410, (uint64_t)buf);
                  *(_OWORD *)&v431.__r_.__value_.__l.__data_ = 0uLL;
                  sub_1004AB97C(*(Registry **)(a1 + 240), &v431);
                  if (v431.__r_.__value_.__r.__words[0])
                  {
                    v430.__r_.__value_.__r.__words[0] = 0;
                    v374 = CFDictionaryGetValue(v117, @"Area");
                    int v375 = v374;
                    if (v374)
                    {
                      CFTypeID v376 = CFGetTypeID(v374);
                      if (v376 == CFDictionaryGetTypeID()) {
                        int v377 = v375;
                      }
                      else {
                        int v377 = 0;
                      }
                    }
                    else
                    {
                      int v377 = 0;
                    }
                    sub_10004EFAC(&v430, v377);
                    if (v430.__r_.__value_.__r.__words[0]) {
                      int v383 = sub_100080778;
                    }
                    else {
                      int v383 = 0;
                    }
                    if (v383)
                    {
                      std::string::size_type v384 = v431.__r_.__value_.__r.__words[0];
                      sub_100058198(&v404, (const void **)&v430.__r_.__value_.__l.__data_);
                      (*(void (**)(std::string::size_type, const void **, void **, void **))(*(void *)v384 + 96))(v384, &v404, &v417[3], v417);
                      sub_100057D78(&v404);
                    }
                    else
                    {
                      int v385 = *(NSObject **)(a1 + 40);
                      if (os_log_type_enabled(v385, OS_LOG_TYPE_DEFAULT))
                      {
                        LOWORD(v428.__r_.__value_.__l.__data_) = 0;
                        _os_log_impl((void *)&_mh_execute_header, v385, OS_LOG_TYPE_DEFAULT, "#I Missing area in safety alert...", (uint8_t *)&v428, 2u);
                      }
                    }
                    sub_100057D78((const void **)&v430.__r_.__value_.__l.__data_);
                  }
                  if (v431.__r_.__value_.__l.__size_) {
                    sub_10004D2C8((std::__shared_weak_count *)v431.__r_.__value_.__l.__size_);
                  }
                  int v299 = 0;
                  goto LABEL_695;
                }
                v386 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v386, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v431.__r_.__value_.__l.__data_) = 0;
                  int v301 = v386;
                  v302 = "Missing CMAM text and CMAM long text";
LABEL_693:
                  _os_log_error_impl((void *)&_mh_execute_header, v301, OS_LOG_TYPE_ERROR, v302, (uint8_t *)&v431, 2u);
                }
              }
              else
              {
                int v379 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v379, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v431.__r_.__value_.__l.__data_) = 0;
                  int v301 = v379;
                  v302 = "Invalid CMAM long text";
                  goto LABEL_693;
                }
              }
            }
            else
            {
              v378 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v378, OS_LOG_TYPE_ERROR))
              {
                LOWORD(v431.__r_.__value_.__l.__data_) = 0;
                int v301 = v378;
                v302 = "Invalid CMAM text";
                goto LABEL_693;
              }
            }
          }
          else
          {
            v300 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v300, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v431.__r_.__value_.__l.__data_) = 0;
              int v301 = v300;
              v302 = "Missing parameters dict";
              goto LABEL_693;
            }
          }
        }
        else
        {
          int v303 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v303, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v431.__r_.__value_.__l.__data_) = 0;
            int v301 = v303;
            v302 = "Missing effective timestamp string";
            goto LABEL_693;
          }
        }
        int v299 = 1;
        uint64_t v8 = 0x1600000001;
LABEL_695:
        if (SHIBYTE(v406.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v406.__r_.__value_.__l.__data_);
        }
        goto LABEL_697;
      }
      v298 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v298, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v431.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v298, OS_LOG_TYPE_ERROR, "Missing expiry timestamp string", (uint8_t *)&v431, 2u);
      }
      int v299 = 1;
      uint64_t v8 = 0x1600000001;
LABEL_697:
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      if (v299) {
        goto LABEL_169;
      }
      CFIndex v113 = v402 + 1;
      if (v402 + 1 == Count) {
        goto LABEL_724;
      }
    }
    memset(&v431, 0, sizeof(v431));
    ctu::cf::assign();
    std::string v430 = v431;
    uint64_t v134 = std::string::insert(&v430, 0, "Missing key: ", 0xDuLL);
LABEL_261:
    __int16 v135 = (void *)v134->__r_.__value_.__r.__words[0];
    v428.__r_.__value_.__r.__words[0] = v134->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v134->__r_.__value_.__r.__words[1] + 7);
    char v136 = HIBYTE(v134->__r_.__value_.__r.__words[2]);
    v134->__r_.__value_.__l.__size_ = 0;
    v134->__r_.__value_.__r.__words[2] = 0;
    v134->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v409) < 0) {
      operator delete(v408);
    }
    v408 = v135;
    *(void *)&long long v409 = v428.__r_.__value_.__r.__words[0];
    *(void *)((char *)&v409 + 7) = *(std::string::size_type *)((char *)v428.__r_.__value_.__r.__words + 7);
    HIBYTE(v409) = v136;
    if ((SHIBYTE(v430.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_266;
    }
    __int16 v133 = (void *)v430.__r_.__value_.__r.__words[0];
    goto LABEL_265;
  }
  if (!v74) {
    goto LABEL_207;
  }
  int v393 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v393, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v431.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v393, OS_LOG_TYPE_DEFAULT, "#I No action taken for this alert", (uint8_t *)&v431, 2u);
  }
LABEL_735:
  uint64_t v8 = 0;
LABEL_169:
  if (SHIBYTE(v409) < 0) {
    operator delete(v408);
  }
LABEL_72:
  sub_1004AD738((uint64_t)buf);
  *(void *)std::string buf = &v410;
  sub_1004AD838((void ***)buf);
  return v8;
}

void sub_1004AB144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,const void *a55,uint64_t a56,uint64_t a57,uint64_t a58,void *__p,uint64_t a60,int a61,__int16 a62,char a63)
{
  sub_100057D78(&a55);
  sub_100057D78((const void **)(v73 - 160));
  CFTypeID v75 = *(std::__shared_weak_count **)(v73 - 120);
  if (v75) {
    sub_10004D2C8(v75);
  }
  if (a64 < 0) {
    operator delete(__p);
  }
  if (SLOBYTE(STACK[0x257]) < 0) {
    operator delete((void *)STACK[0x240]);
  }
  if (a72 < 0) {
    operator delete(a69);
  }
  sub_1004AD738((uint64_t)&STACK[0x260]);
  STACK[0x260] = (unint64_t)&a73;
  sub_1004AD838((void ***)&STACK[0x260]);
  _Unwind_Resume(a1);
}

void sub_1004AB61C(std::string *a1, Registry *this, uint64_t *a3, uint64_t a4)
{
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  int v28 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(this);
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  int v32 = (std::string **)v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v32);
  if (v13)
  {
    uint64_t v15 = v13[3];
    unsigned int v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  unsigned int v14 = 0;
  char v16 = 1;
LABEL_9:
  int v17 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 88))(v15);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  int v28 = v17;
  uint64_t v18 = *a3;
  uint64_t v19 = a3[1];
  v27[0] = &v28;
  v27[1] = a4;
  v27[2] = &v29;
  if (v18 != v19)
  {
    while (!sub_1004AFF84((uint64_t)v27, v18))
    {
      v18 += 336;
      if (v18 == v19)
      {
        uint64_t v18 = v19;
        goto LABEL_21;
      }
    }
    if (v18 != v19)
    {
      for (uint64_t i = v18 + 336; i != v19; i += 336)
      {
        if (!sub_1004AFF84((uint64_t)v27, i))
        {
          sub_1004ACC84(v18, i);
          v18 += 336;
        }
      }
    }
  }
LABEL_21:
  uint64_t v21 = a3[1];
  if (v18 != v21)
  {
    uint64_t v22 = sub_1004ACC2C(v21, a3[1], v18);
    uint64_t v23 = a3[1];
    if (v23 != v22)
    {
      uint64_t v24 = v23 - 336;
      uint64_t v25 = v23 - 336;
      do
      {
        (*(void (**)(uint64_t))(*(void *)v25 + 16))(v25);
        v24 -= 336;
        BOOL v26 = v25 == v22;
        v25 -= 336;
      }
      while (!v26);
    }
    a3[1] = v22;
  }
  sub_100062B40(v29, v30, ",", 1uLL, a1);
  int v32 = &v29;
  sub_100047F64((void ***)&v32);
}

void sub_1004AB858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void **a16)
{
  a16 = (void **)&a13;
  sub_100047F64(&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_1004AB898(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1004ACC2C(a2 + 336, *(void *)(a1 + 8), a2);
  uint64_t v4 = result;
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5 != result)
  {
    uint64_t v6 = v5 - 336;
    uint64_t v7 = v5 - 336;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
      v6 -= 336;
      BOOL v8 = v7 == v4;
      v7 -= 336;
    }
    while (!v8);
  }
  *(void *)(a1 + 8) = v4;
  return result;
}

uint64_t sub_1004AB928(int64x2_t *a1, uint64_t a2)
{
  unint64_t v3 = a1->u64[1];
  if (v3 >= a1[1].i64[0])
  {
    uint64_t result = sub_1004ACF24(a1, a2);
  }
  else
  {
    sub_1004AD23C(a1->i64[1], a2);
    uint64_t result = v3 + 336;
    a1->i64[1] = v3 + 336;
  }
  a1->i64[1] = result;
  return result;
}

void sub_1004AB974(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1004AB97C(Registry *a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1);
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v12);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v4);
  *a2 = v11;
  a2[1] = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
}

void sub_1004ABA48(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 128);
  unint64_t v3 = *(char **)(a1 + 136);
  if (v2 != v3)
  {
    char v4 = 0;
    do
    {
      while (1)
      {
        unsigned __int8 v5 = (*(uint64_t (**)(void, char *))(**(void **)(a1 + 176) + 32))(*(void *)(a1 + 176), v2 + 40);
        if (!(v5 | (*(unsigned __int8 (**)(void, char *))(**(void **)(a1 + 176) + 32))(*(void *)(a1 + 176), v2 + 16)))break; {
        uint64_t v18 = 0;
        }
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        uint64_t v18 = Mutable;
        if (Mutable) {
          uint64_t v7 = sub_1000C06D0;
        }
        else {
          uint64_t v7 = 0;
        }
        if (!v7)
        {
          char v16 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)xpc_object_t value = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to allocate dictionary for notification", value, 2u);
          }
          sub_10005717C((const void **)&v18);
          return;
        }
        sub_1004A5A1C(value, v2);
        CFDictionarySetValue(Mutable, @"kCTSMSAppleSafetyAlertData", *(const void **)value);
        sub_100057D78((const void **)value);
        unsigned int v8 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)xpc_object_t value = 138543362;
          *(void *)&value[4] = v18;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Sending Apple safety alert message notification: %{public}@", value, 0xCu);
        }
        ctu::cf_to_xpc((uint64_t *)value, v18, v9);
        xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
        if (v10 || (xpc_object_t v10 = xpc_null_create()) != 0)
        {
          if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_retain(v10);
            xpc_object_t v11 = v10;
          }
          else
          {
            xpc_object_t v11 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v11 = xpc_null_create();
          xpc_object_t v10 = 0;
        }
        xpc_release(v10);
        xpc_object_t object = v11;
        if (v11) {
          xpc_retain(v11);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_1000452AC(28, (xpc_object_t *)value, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v11);
        xpc_release(*(xpc_object_t *)value);
        ctu::cf_to_xpc((uint64_t *)value, v18, v12);
        xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
        if (v13 || (xpc_object_t v13 = xpc_null_create()) != 0)
        {
          if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_retain(v13);
            xpc_object_t v14 = v13;
          }
          else
          {
            xpc_object_t v14 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v14 = xpc_null_create();
          xpc_object_t v13 = 0;
        }
        xpc_release(v13);
        xpc_object_t object = v14;
        if (v14) {
          xpc_retain(v14);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_1000452AC(27, (xpc_object_t *)value, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v14);
        xpc_release(*(xpc_object_t *)value);
        sub_10005717C((const void **)&v18);
        v2 += 336;
        char v4 = 1;
        if (v2 == v3) {
          return;
        }
      }
      v2 += 336;
    }
    while (v2 != v3);
    if (v4) {
      return;
    }
  }
  uint64_t v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)xpc_object_t value = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Apple safety alert did not match any WEA", value, 2u);
  }
}

void sub_1004ABE40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, char a12, xpc_object_t a13)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void CellBroadcastConfig::updateWeaWithAppleSafetyAlert_sync(void *a1, __CFDictionary **a2, void **a3)
{
  uint64_t v6 = (Registry *)a1[30];
  uint64_t v7 = (std::__shared_weak_count *)a1[31];
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)std::string buf = 86400;
  sub_1004AB61C(&__p, v6, a1 + 16, (uint64_t)buf);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  uint64_t v21 = a2;
  if (v7) {
    sub_10004D2C8(v7);
  }
  unsigned int v8 = (char *)a1[16];
  uint64_t v9 = (char *)a1[17];
  if (v9 != v8)
  {
    xpc_object_t v10 = a1[5];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      xpc_object_t v11 = (void *)*((unsigned __int8 *)a3 + 23);
      int v12 = (char)v11;
      if ((char)v11 < 0) {
        xpc_object_t v11 = a3[1];
      }
      if (v12 >= 0) {
        xpc_object_t v13 = a3;
      }
      else {
        xpc_object_t v13 = *a3;
      }
      *(_DWORD *)std::string buf = 134218242;
      *(void *)&uint8_t buf[4] = v11;
      __int16 v26 = 2082;
      uint64_t v27 = v13;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Searching in Apple safety alerts: [content size: %lu] [content: %{public}s]", buf, 0x16u);
      unsigned int v8 = (char *)a1[16];
      uint64_t v9 = (char *)a1[17];
    }
    if (v8 != v9)
    {
      for (uint64_t i = v8; ; i += 336)
      {
        if (*((char *)a3 + 23) < 0)
        {
          sub_10004FC84(__dst, *a3, (unint64_t)a3[1]);
        }
        else
        {
          *(_OWORD *)std::string __dst = *(_OWORD *)a3;
          uint64_t v23 = a3[2];
        }
        int v15 = (*(uint64_t (**)(char *, void **))(*(void *)v8 + 8))(v8, __dst);
        if (SHIBYTE(v23) < 0) {
          operator delete(__dst[0]);
        }
        char v16 = a1[5];
        BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
        if (v15) {
          break;
        }
        if (v17)
        {
          sub_1004A5C6C(buf, (uint64_t)v8);
          if (v28 >= 0) {
            uint64_t v18 = buf;
          }
          else {
            uint64_t v18 = *(unsigned char **)buf;
          }
          *(_DWORD *)uint64_t v29 = 136446210;
          uint64_t v30 = v18;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Did not match : %{public}s", v29, 0xCu);
          if (v28 < 0) {
            operator delete(*(void **)buf);
          }
        }
        v8 += 336;
        if (v8 == v9) {
          return;
        }
      }
      if (v17)
      {
        sub_1004A5C6C(buf, (uint64_t)v8);
        uint64_t v19 = v28 >= 0 ? buf : *(unsigned char **)buf;
        *(_DWORD *)uint64_t v29 = 136446210;
        uint64_t v30 = v19;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Matched : %{public}s", v29, 0xCu);
        if (v28 < 0) {
          operator delete(*(void **)buf);
        }
      }
      CFTypeID v20 = *v21;
      sub_1004A5A1C(buf, v8);
      CFDictionarySetValue(v20, @"kCTSMSAppleSafetyAlertData", *(const void **)buf);
      sub_100057D78((const void **)buf);
    }
  }
}

void sub_1004AC214(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,const void *a22)
{
}

void CellBroadcastConfig::getEarthquakeAlertsConfiguration(CellBroadcastConfig *this@<X0>, void *a2@<X8>)
{
  char v4 = this;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_1004B0134;
  void v5[3] = &unk_1019D3EA0;
  void v5[4] = (char *)this + 8;
  void v5[5] = &v4;
  uint64_t v6 = v5;
  unint64_t v3 = (char *)this + 24;
  uint64_t v2 = *((void *)this + 3);
  if (*((void *)v3 + 1))
  {
    *a2 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_1004B01B8;
    xpc_object_t v10 = &unk_1019D3EE0;
    xpc_object_t v11 = a2;
    int v12 = &v6;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    *a2 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_1004B0140;
    xpc_object_t v10 = &unk_1019D3EC0;
    xpc_object_t v11 = a2;
    int v12 = &v6;
    dispatch_sync(v2, &block);
  }
}

const void **CellBroadcastConfig::getEarthquakeAlertsConfiguration_sync@<X0>(CellBroadcastConfig *this@<X0>, void *a2@<X8>)
{
  CFDictionaryRef theDict = 0;
  uint64_t v31 = 0;
  char v29 = 0;
  CellBroadcastConfig::getAppleSafetyAlertConfig_sync(this, &v26);
  if (v26) {
    char v4 = sub_100080778;
  }
  else {
    char v4 = 0;
  }
  BOOL v5 = v4 != 0;
  sub_100057D78((const void **)&v26);
  BOOL EnhancedDeliverySwitchState_sync = CellBroadcastConfig::getEnhancedDeliverySwitchState_sync((uint64_t)this, &v31, (const void **)&theDict);
  if (v31) {
    uint64_t v7 = sub_1000810B8;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7)
  {
    subscriber::makeSimSlotRange();
    uint64_t v9 = (unsigned int *)v26;
    uint64_t v8 = (unsigned int *)v27;
    if (v26 != v27)
    {
      xpc_object_t v10 = v28;
      while ((v10(*v9) & 1) == 0)
      {
        if (++v9 == v8)
        {
          uint64_t v9 = v8;
          break;
        }
      }
      xpc_object_t v11 = (unsigned int *)v27;
LABEL_14:
      while (v9 != v11)
      {
        char CellBroadcastSettingForAlertType_sync = CellBroadcastConfig::getCellBroadcastSettingForAlertType_sync((uint64_t)this, *v9, v31, &v29);
        char v13 = v29 ? CellBroadcastSettingForAlertType_sync : 0;
        if (v13) {
          break;
        }
        xpc_object_t v14 = v9 + 1;
        uint64_t v9 = v8;
        if (v14 != v8)
        {
          uint64_t v9 = v14;
          while ((v10(*v9) & 1) == 0)
          {
            if (++v9 == v8)
            {
              uint64_t v9 = v8;
              goto LABEL_14;
            }
          }
        }
      }
    }
  }
  if (theDict) {
    int v15 = sub_100080778;
  }
  else {
    int v15 = 0;
  }
  BOOL v17 = v15 == 0;
  BOOL v16 = v15 != 0;
  BOOL v17 = v17 || !v16;
  uint64_t v18 = (uint64_t *)&kCFBooleanFalse;
  if (!v17)
  {
    if (CFDictionaryContainsKey(theDict, @"EnableEnhancedDelivery")) {
      uint64_t v18 = (uint64_t *)&kCFBooleanTrue;
    }
    else {
      uint64_t v18 = (uint64_t *)&kCFBooleanFalse;
    }
  }
  *(void *)uint64_t v25 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFTypeID v20 = *(__CFDictionary **)v25;
    *(void *)uint64_t v25 = Mutable;
    __int16 v26 = v20;
    sub_10005717C((const void **)&v26);
  }
  if (v29) {
    CFBooleanRef v21 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v21 = kCFBooleanFalse;
  }
  sub_10012C97C(*(__CFDictionary **)v25, @"EmergencyAlertsPref", (uint64_t)v21);
  if (EnhancedDeliverySwitchState_sync) {
    CFBooleanRef v22 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v22 = kCFBooleanFalse;
  }
  sub_10012C97C(*(__CFDictionary **)v25, @"EnhancedDeliveryPref", (uint64_t)v22);
  sub_10012C97C(*(__CFDictionary **)v25, @"EnhancedDeliveryAvailability", *v18);
  if (v5) {
    CFBooleanRef v23 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v23 = kCFBooleanFalse;
  }
  sub_10012C97C(*(__CFDictionary **)v25, @"AppleSafetyAlertsAvailability", (uint64_t)v23);
  sub_10004EFE4(a2, (CFTypeRef *)v25);
  sub_10005717C((const void **)v25);
  sub_100057D78((const void **)&theDict);
  return sub_1000558F4(&v31);
}

void sub_1004AC608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, const void *);
  sub_100057D78((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1004AC648(uint64_t a1)
{
  sub_1004AD738(a1);

  operator delete();
}

void sub_1004AC680(uint64_t a1)
{
  *(void *)a1 = &off_1019D3D50;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

uint64_t sub_1004AC700(uint64_t a1, uint64_t a2, char *__s)
{
  uint64_t v3 = a1;
  if (a1 != a2)
  {
    size_t v6 = strlen(__s);
    while (1)
    {
      uint64_t v7 = *(unsigned __int8 *)(v3 + 23);
      int v8 = (char)v7;
      if ((v7 & 0x80u) != 0) {
        uint64_t v7 = *(void *)(v3 + 8);
      }
      if (v7 == v6)
      {
        uint64_t v9 = v8 >= 0 ? (const void *)v3 : *(const void **)v3;
        if (!memcmp(v9, __s, v6)) {
          break;
        }
      }
      v3 += 24;
      if (v3 == a2) {
        return a2;
      }
    }
  }
  return v3;
}

uint64_t *sub_1004AC790(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = v2 + v5;
      *(void *)(v6 - 64) = &off_1019D3D50;
      *(void *)(v6 - 56) = *(void *)(v2 + v5 - 56);
      long long v8 = *(_OWORD *)(v2 + v5 - 48);
      *(void *)(v6 - 32) = *(void *)(v2 + v5 - 32);
      *(_OWORD *)(v6 - 48) = v8;
      *(void *)(v7 - 40) = 0;
      *(void *)(v7 - 32) = 0;
      *(void *)(v7 - 48) = 0;
      long long v9 = *(_OWORD *)(v2 + v5 - 24);
      *(void *)(v6 - 8) = *(void *)(v2 + v5 - 8);
      *(_OWORD *)(v6 - 24) = v9;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      *(void *)(v7 - 24) = 0;
      v5 -= 64;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v10 = *result;
  *uint64_t result = v4;
  a2[1] = v10;
  uint64_t v11 = result[1];
  result[1] = a2[2];
  a2[2] = v11;
  uint64_t v12 = result[2];
  result[2] = a2[3];
  a2[3] = v12;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1004AC858(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void *)(i - 64);
    *(void *)(a1 + 16) = i - 64;
    (*(void (**)(void))(v4 + 16))();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1004AC8C4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_1019D3D50;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  if (*(char *)(a2 + 39) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 16), *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = v4;
  }
  uint64_t v5 = (unsigned char *)(a1 + 40);
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)uint64_t v5 = v6;
  }
  return a1;
}

void sub_1004AC974(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004AC990(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    long long v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      long long v6 = v4 - 64;
      uint64_t v7 = v4 - 64;
      long long v8 = v4 - 64;
      do
      {
        uint64_t v9 = *(void *)v8;
        v8 -= 64;
        (*(void (**)(char *))(v9 + 16))(v7);
        v6 -= 64;
        BOOL v10 = v7 == v2;
        uint64_t v7 = v8;
      }
      while (!v10);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1004ACA50(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24))
  {
    sub_100057D78((const void **)(a1 + 8));
    sub_100057D78((const void **)a1);
  }
  return a1;
}

unsigned char *sub_1004ACA8C(unsigned char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 58) {
      sub_10006A748();
    }
    long long v6 = result;
    uint64_t result = sub_10016063C(a4);
    uint64_t v7 = result;
    *long long v6 = result;
    v6[1] = result;
    void v6[2] = &result[64 * v8];
    if (a2 != a3)
    {
      uint64_t v9 = 0;
      do
      {
        BOOL v10 = &v7[v9];
        *BOOL v10 = &off_1019D3D50;
        v10[1] = *(void *)(a2 + v9 + 8);
        uint64_t v11 = &v7[v9 + 16];
        uint64_t v12 = (void **)(a2 + v9 + 16);
        if (*(char *)(a2 + v9 + 39) < 0)
        {
          sub_10004FC84(v11, *v12, *(void *)(a2 + v9 + 24));
        }
        else
        {
          long long v13 = *(_OWORD *)v12;
          *(void *)&v7[v9 + 32] = *(void *)(a2 + v9 + 32);
          *(_OWORD *)uint64_t v11 = v13;
        }
        uint64_t result = &v7[v9 + 40];
        xpc_object_t v14 = (void **)(a2 + v9 + 40);
        if (*(char *)(a2 + v9 + 63) < 0)
        {
          uint64_t result = sub_10004FC84(result, *v14, *(void *)(a2 + v9 + 48));
        }
        else
        {
          long long v15 = *(_OWORD *)v14;
          *(void *)&v7[v9 + 56] = *(void *)(a2 + v9 + 56);
          *(_OWORD *)uint64_t result = v15;
        }
        v9 += 64;
      }
      while (a2 + v9 != a3);
      v7 += v9;
    }
    v6[1] = v7;
  }
  return result;
}

void sub_1004ACBB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_1004ACC2C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      sub_1004ACC84(a3, v5);
      v5 += 336;
      a3 += 336;
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t sub_1004ACC84(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  uint64_t v4 = a1 + 16;
  uint64_t v5 = (long long *)(a2 + 16);
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)v4);
  }
  long long v6 = *v5;
  *(void *)(v4 + 16) = *((void *)v5 + 2);
  *(_OWORD *)uint64_t v4 = v6;
  *(unsigned char *)(a2 + 39) = 0;
  *(unsigned char *)(a2 + 16) = 0;
  uint64_t v7 = (void **)(a1 + 40);
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*v7);
  }
  long long v8 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)uint64_t v7 = v8;
  *(unsigned char *)(a2 + 63) = 0;
  *(unsigned char *)(a2 + 40) = 0;
  uint64_t v9 = (void **)(a1 + 64);
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*v9);
  }
  long long v10 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(_OWORD *)uint64_t v9 = v10;
  *(unsigned char *)(a2 + 87) = 0;
  *(unsigned char *)(a2 + 64) = 0;
  uint64_t v11 = (void **)(a1 + 88);
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*v11);
  }
  long long v12 = *(_OWORD *)(a2 + 88);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(_OWORD *)uint64_t v11 = v12;
  *(unsigned char *)(a2 + 111) = 0;
  *(unsigned char *)(a2 + 88) = 0;
  long long v13 = (void **)(a1 + 112);
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*v13);
  }
  long long v14 = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(_OWORD *)long long v13 = v14;
  *(unsigned char *)(a2 + 135) = 0;
  *(unsigned char *)(a2 + 112) = 0;
  long long v15 = (void **)(a1 + 136);
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*v15);
  }
  long long v16 = *(_OWORD *)(a2 + 136);
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  *(_OWORD *)long long v15 = v16;
  *(unsigned char *)(a2 + 159) = 0;
  *(unsigned char *)(a2 + 136) = 0;
  BOOL v17 = (void **)(a1 + 160);
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*v17);
  }
  long long v18 = *(_OWORD *)(a2 + 160);
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  *(_OWORD *)BOOL v17 = v18;
  *(unsigned char *)(a2 + 183) = 0;
  *(unsigned char *)(a2 + 160) = 0;
  uint64_t v19 = (void **)(a1 + 184);
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*v19);
  }
  long long v20 = *(_OWORD *)(a2 + 184);
  *(void *)(a1 + 200) = *(void *)(a2 + 200);
  *(_OWORD *)uint64_t v19 = v20;
  *(unsigned char *)(a2 + 207) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  CFBooleanRef v21 = (void **)(a1 + 208);
  if (*(char *)(a1 + 231) < 0) {
    operator delete(*v21);
  }
  long long v22 = *(_OWORD *)(a2 + 208);
  *(void *)(a1 + 224) = *(void *)(a2 + 224);
  *(_OWORD *)CFBooleanRef v21 = v22;
  *(unsigned char *)(a2 + 231) = 0;
  *(unsigned char *)(a2 + 208) = 0;
  int v23 = *(_DWORD *)(a2 + 240);
  uint64_t v24 = *(void **)(a1 + 248);
  *(void *)(a1 + 232) = *(void *)(a2 + 232);
  *(_DWORD *)(a1 + 240) = v23;
  if (v24)
  {
    *(void *)(a1 + 256) = v24;
    operator delete(v24);
    *(void *)(a1 + 248) = 0;
    *(void *)(a1 + 256) = 0;
    *(void *)(a1 + 264) = 0;
  }
  *(_OWORD *)(a1 + 248) = *(_OWORD *)(a2 + 248);
  *(void *)(a1 + 264) = *(void *)(a2 + 264);
  *(void *)(a2 + 256) = 0;
  *(void *)(a2 + 264) = 0;
  *(void *)(a2 + 248) = 0;
  *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
  uint64_t v25 = *(void **)(a1 + 288);
  if (v25)
  {
    *(void *)(a1 + 296) = v25;
    operator delete(v25);
    *(void *)(a1 + 288) = 0;
    *(void *)(a1 + 296) = 0;
    *(void *)(a1 + 304) = 0;
  }
  *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
  *(void *)(a1 + 304) = *(void *)(a2 + 304);
  *(void *)(a2 + 288) = 0;
  *(void *)(a2 + 296) = 0;
  *(void *)(a2 + 304) = 0;
  __int16 v26 = *(void **)(a1 + 312);
  if (v26)
  {
    *(void *)(a1 + 320) = v26;
    operator delete(v26);
    *(void *)(a1 + 312) = 0;
    *(void *)(a1 + 320) = 0;
    *(void *)(a1 + 328) = 0;
  }
  uint64_t v27 = *(void *)(a2 + 320);
  *(void *)(a1 + 312) = *(void *)(a2 + 312);
  *(void *)(a1 + 320) = v27;
  *(void *)(a1 + 328) = *(void *)(a2 + 328);
  *(void *)(a2 + 312) = 0;
  *(void *)(a2 + 320) = 0;
  *(void *)(a2 + 328) = 0;
  return a1;
}

uint64_t sub_1004ACF24(int64x2_t *a1, uint64_t a2)
{
  unint64_t v2 = 0xCF3CF3CF3CF3CF3DLL * ((a1->i64[1] - a1->i64[0]) >> 4);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xC30C30C30C30C3) {
    sub_10006A748();
  }
  if (0x9E79E79E79E79E7ALL * ((a1[1].i64[0] - a1->i64[0]) >> 4) > v3) {
    unint64_t v3 = 0x9E79E79E79E79E7ALL * ((a1[1].i64[0] - a1->i64[0]) >> 4);
  }
  if (0xCF3CF3CF3CF3CF3DLL * ((a1[1].i64[0] - a1->i64[0]) >> 4) >= 0x61861861861861) {
    unint64_t v6 = 0xC30C30C30C30C3;
  }
  else {
    unint64_t v6 = v3;
  }
  BOOL v38 = a1 + 1;
  if (v6)
  {
    if (v6 > 0xC30C30C30C30C3) {
      sub_10006A7CC();
    }
    uint64_t v7 = (char *)operator new(336 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v35 = v7;
  v36.i64[0] = (uint64_t)&v7[336 * v2];
  int v37 = &v7[336 * v6];
  sub_1004AD23C(v36.i64[0], a2);
  uint64_t v8 = v36.i64[0];
  uint64_t v9 = v36.i64[0] + 336;
  v36.i64[1] = v36.i64[0] + 336;
  uint64_t v11 = a1->i64[0];
  unint64_t v10 = a1->u64[1];
  if (v10 == a1->i64[0])
  {
    int64x2_t v32 = vdupq_n_s64(v10);
  }
  else
  {
    uint64_t v12 = 0;
    do
    {
      uint64_t v13 = v8 + v12;
      uint64_t v14 = v10 + v12;
      *(_DWORD *)(v8 + v12 - 328) = *(_DWORD *)(v10 + v12 - 328);
      *(void *)(v8 + v12 - 336) = &off_1019D3D20;
      uint64_t v15 = v8 + v12 - 320;
      uint64_t v16 = v10 + v12 - 320;
      long long v17 = *(_OWORD *)v16;
      *(void *)(v15 + 16) = *(void *)(v10 + v12 - 304);
      *(_OWORD *)uint64_t v15 = v17;
      *(void *)(v16 + 8) = 0;
      *(void *)(v16 + 16) = 0;
      *(void *)uint64_t v16 = 0;
      uint64_t v18 = v8 + v12 - 296;
      uint64_t v19 = v10 + v12 - 296;
      long long v20 = *(_OWORD *)v19;
      *(void *)(v18 + 16) = *(void *)(v10 + v12 - 280);
      *(_OWORD *)uint64_t v18 = v20;
      *(void *)(v19 + 8) = 0;
      *(void *)(v19 + 16) = 0;
      *(void *)uint64_t v19 = 0;
      uint64_t v21 = v10 + v12 - 272;
      long long v22 = *(_OWORD *)v21;
      *(void *)(v13 - 256) = *(void *)(v10 + v12 - 256);
      *(_OWORD *)(v8 + v12 - 272) = v22;
      *(void *)(v14 - 256) = 0;
      *(void *)uint64_t v21 = 0;
      *(void *)(v21 + 8) = 0;
      long long v23 = *(_OWORD *)(v10 + v12 - 248);
      *(void *)(v13 - 232) = *(void *)(v10 + v12 - 232);
      *(_OWORD *)(v13 - 248) = v23;
      *(void *)(v14 - 248) = 0;
      *(void *)(v14 - 240) = 0;
      long long v24 = *(_OWORD *)(v10 + v12 - 224);
      uint64_t v25 = *(void *)(v10 + v12 - 208);
      *(void *)(v14 - 232) = 0;
      *(void *)(v13 - 208) = v25;
      *(_OWORD *)(v13 - 224) = v24;
      *(void *)(v14 - 224) = 0;
      *(void *)(v14 - 216) = 0;
      *(void *)(v14 - 208) = 0;
      long long v26 = *(_OWORD *)(v10 + v12 - 200);
      *(void *)(v13 - 184) = *(void *)(v10 + v12 - 184);
      *(_OWORD *)(v13 - 200) = v26;
      *(void *)(v14 - 200) = 0;
      *(void *)(v14 - 192) = 0;
      *(void *)(v14 - 184) = 0;
      long long v27 = *(_OWORD *)(v10 + v12 - 176);
      *(void *)(v13 - 160) = *(void *)(v10 + v12 - 160);
      *(_OWORD *)(v13 - 176) = v27;
      *(void *)(v14 - 176) = 0;
      *(void *)(v14 - 168) = 0;
      *(void *)(v14 - 160) = 0;
      long long v28 = *(_OWORD *)(v10 + v12 - 152);
      *(void *)(v13 - 136) = *(void *)(v10 + v12 - 136);
      *(_OWORD *)(v13 - 152) = v28;
      *(void *)(v14 - 152) = 0;
      *(void *)(v14 - 144) = 0;
      *(void *)(v14 - 136) = 0;
      long long v29 = *(_OWORD *)(v10 + v12 - 128);
      *(void *)(v13 - 112) = *(void *)(v10 + v12 - 112);
      *(_OWORD *)(v13 - 128) = v29;
      *(void *)(v14 - 128) = 0;
      *(void *)(v14 - 120) = 0;
      *(void *)(v14 - 112) = 0;
      uint64_t v30 = *(void *)(v10 + v12 - 104);
      *(_DWORD *)(v13 - 96) = *(_DWORD *)(v10 + v12 - 96);
      *(void *)(v13 - 104) = v30;
      *(void *)(v13 - 80) = 0;
      *(void *)(v13 - 72) = 0;
      *(void *)(v13 - 88) = 0;
      *(_OWORD *)(v13 - 88) = *(_OWORD *)(v10 + v12 - 88);
      *(void *)(v13 - 72) = *(void *)(v10 + v12 - 72);
      *(void *)(v14 - 80) = 0;
      *(void *)(v14 - 72) = 0;
      long long v31 = *(_OWORD *)(v10 + v12 - 64);
      *(void *)(v14 - 88) = 0;
      *(_OWORD *)(v13 - 64) = v31;
      *(void *)(v13 - 40) = 0;
      *(void *)(v13 - 32) = 0;
      *(void *)(v13 - 48) = 0;
      *(_OWORD *)(v13 - 48) = *(_OWORD *)(v10 + v12 - 48);
      *(void *)(v13 - 32) = *(void *)(v10 + v12 - 32);
      *(void *)(v14 - 48) = 0;
      *(void *)(v14 - 40) = 0;
      *(void *)(v14 - 32) = 0;
      *(void *)(v13 - 24) = 0;
      *(void *)(v13 - 16) = 0;
      *(void *)(v13 - 8) = 0;
      *(_OWORD *)(v13 - 24) = *(_OWORD *)(v10 + v12 - 24);
      *(void *)(v13 - 8) = *(void *)(v10 + v12 - 8);
      *(void *)(v14 - 24) = 0;
      *(void *)(v14 - 16) = 0;
      *(void *)(v14 - 8) = 0;
      v12 -= 336;
    }
    while (v10 + v12 != v11);
    int64x2_t v32 = *a1;
    uint64_t v9 = v36.i64[1];
    v8 += v12;
  }
  a1->i64[0] = v8;
  a1->i64[1] = v9;
  int64x2_t v36 = v32;
  CFTypeID v33 = (char *)a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)v37;
  int v37 = v33;
  uint64_t v35 = (char *)v32.i64[0];
  sub_1004AD6C8((uint64_t)&v35);
  return v9;
}

void sub_1004AD228(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004AD6C8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1004AD23C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(void *)a1 = &off_1019D3D20;
  if (*(char *)(a2 + 39) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 16), *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = v4;
  }
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v5;
  }
  if (*(char *)(a2 + 87) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 64), *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = v6;
  }
  if (*(char *)(a2 + 111) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 88), *(void **)(a2 + 88), *(void *)(a2 + 96));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 88);
    *(void *)(a1 + 104) = *(void *)(a2 + 104);
    *(_OWORD *)(a1 + 88) = v7;
  }
  if (*(char *)(a2 + 135) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 112), *(void **)(a2 + 112), *(void *)(a2 + 120));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 112);
    *(void *)(a1 + 128) = *(void *)(a2 + 128);
    *(_OWORD *)(a1 + 112) = v8;
  }
  if (*(char *)(a2 + 159) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 136), *(void **)(a2 + 136), *(void *)(a2 + 144));
  }
  else
  {
    long long v9 = *(_OWORD *)(a2 + 136);
    *(void *)(a1 + 152) = *(void *)(a2 + 152);
    *(_OWORD *)(a1 + 136) = v9;
  }
  if (*(char *)(a2 + 183) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 160), *(void **)(a2 + 160), *(void *)(a2 + 168));
  }
  else
  {
    long long v10 = *(_OWORD *)(a2 + 160);
    *(void *)(a1 + 176) = *(void *)(a2 + 176);
    *(_OWORD *)(a1 + 160) = v10;
  }
  if (*(char *)(a2 + 207) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 184), *(void **)(a2 + 184), *(void *)(a2 + 192));
  }
  else
  {
    long long v11 = *(_OWORD *)(a2 + 184);
    *(void *)(a1 + 200) = *(void *)(a2 + 200);
    *(_OWORD *)(a1 + 184) = v11;
  }
  if (*(char *)(a2 + 231) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 208), *(void **)(a2 + 208), *(void *)(a2 + 216));
  }
  else
  {
    long long v12 = *(_OWORD *)(a2 + 208);
    *(void *)(a1 + 224) = *(void *)(a2 + 224);
    *(_OWORD *)(a1 + 208) = v12;
  }
  uint64_t v13 = *(void *)(a2 + 232);
  int v14 = *(_DWORD *)(a2 + 240);
  *(void *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 240) = v14;
  *(void *)(a1 + 232) = v13;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  uint64_t v16 = *(unsigned char **)(a2 + 248);
  uint64_t v15 = *(unsigned char **)(a2 + 256);
  int64_t v17 = v15 - v16;
  if (v15 != v16)
  {
    if (v17 < 0) {
      sub_10006A748();
    }
    uint64_t v18 = (char *)sub_1000492A8(v17 >> 2);
    *(void *)(a1 + 248) = v18;
    *(void *)(a1 + 256) = v18;
    *(void *)(a1 + 264) = &v18[4 * v19];
    memmove(v18, v16, v17);
    *(void *)(a1 + 256) = &v18[4 * (v17 >> 2)];
  }
  *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 288) = 0;
  uint64_t v21 = *(unsigned char **)(a2 + 288);
  long long v20 = *(unsigned char **)(a2 + 296);
  int64_t v22 = v20 - v21;
  if (v20 != v21)
  {
    if (v22 < 0) {
      sub_10006A748();
    }
    long long v23 = (char *)sub_1000492A8(v22 >> 2);
    *(void *)(a1 + 288) = v23;
    *(void *)(a1 + 296) = v23;
    *(void *)(a1 + 304) = &v23[4 * v24];
    memmove(v23, v21, v22);
    *(void *)(a1 + 296) = &v23[4 * (v22 >> 2)];
  }
  *(void *)(a1 + 312) = 0;
  *(void *)(a1 + 320) = 0;
  *(void *)(a1 + 328) = 0;
  long long v26 = *(unsigned char **)(a2 + 312);
  uint64_t v25 = *(unsigned char **)(a2 + 320);
  int64_t v27 = v25 - v26;
  if (v25 != v26)
  {
    if (v27 < 0) {
      sub_10006A748();
    }
    long long v28 = (char *)sub_1000492A8(v27 >> 2);
    *(void *)(a1 + 312) = v28;
    *(void *)(a1 + 320) = v28;
    *(void *)(a1 + 328) = &v28[4 * v29];
    memmove(v28, v26, v27);
    *(void *)(a1 + 320) = &v28[4 * (v27 >> 2)];
  }
  return a1;
}

void sub_1004AD590(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, void **a11, void **a12, void **a13, void **a14, void **a15, void **a16)
{
  if (v16[207] < 0) {
    operator delete(*v17);
  }
  if (v16[183] < 0) {
    operator delete(*a10);
  }
  if (v16[159] < 0) {
    operator delete(*a11);
  }
  if (v16[135] < 0) {
    operator delete(*a12);
  }
  if (v16[111] < 0) {
    operator delete(*a13);
  }
  if (v16[87] < 0) {
    operator delete(*a14);
  }
  if (v16[63] < 0) {
    operator delete(*a15);
  }
  if (v16[39] < 0) {
    operator delete(*a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004AD6C8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 336;
    (*(void (**)(void))(*(void *)(i - 336) + 16))();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1004AD738(uint64_t a1)
{
  *(void *)a1 = &off_1019D3D20;
  unint64_t v2 = *(void **)(a1 + 312);
  if (v2)
  {
    *(void *)(a1 + 320) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 288);
  if (v3)
  {
    *(void *)(a1 + 296) = v3;
    operator delete(v3);
  }
  long long v4 = *(void **)(a1 + 248);
  if (v4)
  {
    *(void *)(a1 + 256) = v4;
    operator delete(v4);
  }
  if (*(char *)(a1 + 231) < 0) {
    operator delete(*(void **)(a1 + 208));
  }
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1004AD838(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    long long v4 = (char *)v1[1];
    long long v5 = **a1;
    if (v4 != v2)
    {
      long long v6 = v4 - 336;
      long long v7 = v4 - 336;
      do
      {
        (*(void (**)(char *))(*(void *)v7 + 16))(v7);
        v6 -= 336;
        BOOL v8 = v7 == v2;
        v7 -= 336;
      }
      while (!v8);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1004AD8F8(uint64_t a1, void **a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 24 * a3;
    do
    {
      sub_1004AD97C((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 3;
      v6 -= 24;
    }
    while (v6);
  }
  return a1;
}

void sub_1004AD964(_Unwind_Exception *a1)
{
  sub_10005CD2C(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1004AD97C(uint64_t **a1, uint64_t a2, void **a3, uint64_t a4)
{
  uint64_t v9 = 0;
  long long v10 = 0;
  uint64_t v6 = (uint64_t **)sub_1000C6D50(a1, a2, &v10, &v9, a3);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1004ADA0C((uint64_t)a1, a4, v8);
    sub_100046C38(a1, (uint64_t)v10, v6, v8[0]);
    return v8[0];
  }
  return result;
}

void *sub_1004ADA0C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  uint64_t v6 = a3 + 1;
  long long v7 = (char *)operator new(0x38uLL);
  *a3 = v7;
  *uint64_t v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = v7 + 32;
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t result = sub_10004FC84(result, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t result = *(_OWORD *)a2;
    result[2] = *(void *)(a2 + 16);
  }
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_1004ADA9C(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_1000C6EE8(v2, v3);
  _Unwind_Resume(a1);
}

unint64_t sub_1004ADAB8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 8);
  if (CFDictionaryContainsKey(**(CFDictionaryRef **)v1, @"Earthquake"))
  {
    CFDictionaryRef Value = CFDictionaryGetValue(**(CFDictionaryRef **)v1, @"Earthquake");
    if (Value && (uint64_t v4 = Value, v5 = CFGetTypeID(Value), v5 == CFDictionaryGetTypeID()))
    {
      unint64_t v182 = v4;
      CFRetain(v4);
      CFDictionaryRef v181 = (CFDictionaryRef)v4;
      CFRetain(v4);
    }
    else
    {
      CFDictionaryRef v181 = 0;
      unint64_t v182 = 0;
    }
    *(_OWORD *)CFTypeRef cf = 0u;
    long long v200 = 0u;
    uint64_t v6 = (Registry **)(v2 + 240);
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 240));
    BOOL v8 = ServiceMap;
    if (v9 < 0)
    {
      long long v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v9;
    uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
    if (v13)
    {
      uint64_t v15 = v13[3];
      int v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
        if (!v15)
        {
LABEL_12:
          int64_t v17 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Carrier settings interface missing", buf, 2u);
          }
          LOBYTE(cf[0]) = 0;
          BYTE8(v200) = 0;
          uint64_t v18 = 22;
          if (v16) {
            goto LABEL_263;
          }
          int v19 = 1;
          goto LABEL_87;
        }
LABEL_22:
        *(_OWORD *)&v198.__r_.__value_.__l.__data_ = 0uLL;
        Registry::getMobileHelper((uint64_t *)&v198, *v6);
        if (!v198.__r_.__value_.__r.__words[0])
        {
          char v45 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "MobileHelperInterface is absent", buf, 2u);
          }
          LOBYTE(cf[0]) = 0;
          BYTE8(v200) = 0;
          uint64_t v18 = 22;
          int v19 = 1;
LABEL_84:
          if (v198.__r_.__value_.__l.__size_) {
            sub_10004D2C8((std::__shared_weak_count *)v198.__r_.__value_.__l.__size_);
          }
          if (v16)
          {
LABEL_88:
            if (v19) {
              goto LABEL_263;
            }
            if (!BYTE8(v200))
            {
              CFNumberRef v71 = *(NSObject **)(v2 + 40);
              if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)std::string buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "Uknown error while reading settings for Earthquake", buf, 2u);
              }
              uint64_t v18 = 22;
              goto LABEL_263;
            }
            int v203 = (int *)cf[0];
            if (cf[0])
            {
              CFRetain(cf[0]);
              v202 = 0;
              if (!BYTE8(v200)) {
                sub_10016C840();
              }
            }
            v202 = (int *)cf[1];
            if (cf[1])
            {
              CFRetain(cf[1]);
              uint64_t v201 = 0;
              if (!BYTE8(v200)) {
                sub_10016C840();
              }
            }
            uint64_t v201 = 60 * v200;
            if (v203) {
              std::string::size_type v56 = sub_100080778;
            }
            else {
              std::string::size_type v56 = 0;
            }
            if (!v56 || (v202 ? (uint64_t v57 = sub_100080778) : (uint64_t v57 = 0), !v57))
            {
              CFDictionaryRef v70 = *(NSObject **)(v2 + 40);
              if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)std::string buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_ERROR, "Uknown error while parsing Earthquake warnings dictionary", buf, 2u);
              }
              uint64_t v18 = 22;
              goto LABEL_262;
            }
            memset(&v198, 0, sizeof(v198));
            CFBooleanRef v58 = *(Registry **)(v2 + 240);
            char v59 = *(std::__shared_weak_count **)(v2 + 248);
            if (v59) {
              atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            memset(buf, 0, sizeof(buf));
            LODWORD(v196) = 0;
            int v60 = (std::mutex *)Registry::getServiceMap(v58);
            unint64_t v61 = v60;
            if (v62 < 0)
            {
              char v63 = (unsigned __int8 *)(v62 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v64 = 5381;
              do
              {
                uint64_t v62 = v64;
                unsigned int v65 = *v63++;
                uint64_t v64 = (33 * v64) ^ v65;
              }
              while (v65);
            }
            std::mutex::lock(v60);
            *(void *)&long long v204 = v62;
            CFIndex v66 = sub_10004D37C(&v61[1].__m_.__sig, (unint64_t *)&v204);
            if (v66)
            {
              uint64_t v68 = v66[3];
              uint64_t v67 = (std::__shared_weak_count *)v66[4];
              if (v67)
              {
                atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v61);
                atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v67);
                char v69 = 0;
                goto LABEL_118;
              }
            }
            else
            {
              uint64_t v68 = 0;
            }
            std::mutex::unlock(v61);
            uint64_t v67 = 0;
            char v69 = 1;
LABEL_118:
            int v72 = (*(uint64_t (**)(uint64_t))(*(void *)v68 + 88))(v68);
            if ((v69 & 1) == 0) {
              sub_10004D2C8(v67);
            }
            LODWORD(v196) = v72;
            uint64_t v73 = *(void *)(v2 + 152);
            uint64_t v74 = *(void *)(v2 + 160);
            *(void *)&long long v204 = &v196;
            *((void *)&v204 + 1) = &v201;
            uint64_t v205 = buf;
            if (v73 != v74)
            {
              while (!sub_1004AF7A4((uint64_t)&v204, v73))
              {
                v73 += 64;
                if (v73 == v74)
                {
                  uint64_t v73 = v74;
                  goto LABEL_134;
                }
              }
              if (v73 != v74)
              {
                for (uint64_t i = v73 + 64; i != v74; i += 64)
                {
                  if (!sub_1004AF7A4((uint64_t)&v204, i))
                  {
                    *(void *)(v73 + 8) = *(void *)(i + 8);
                    std::string::size_type v76 = (void **)(v73 + 16);
                    if (*(char *)(v73 + 39) < 0) {
                      operator delete(*v76);
                    }
                    long long v77 = *(_OWORD *)(i + 16);
                    *(void *)(v73 + 32) = *(void *)(i + 32);
                    *(_OWORD *)std::string::size_type v76 = v77;
                    *(unsigned char *)(i + 39) = 0;
                    *(unsigned char *)(i + 16) = 0;
                    long long v78 = (void **)(v73 + 40);
                    if (*(char *)(v73 + 63) < 0) {
                      operator delete(*v78);
                    }
                    long long v79 = *(_OWORD *)(i + 40);
                    *(void *)(v73 + 56) = *(void *)(i + 56);
                    *(_OWORD *)long long v78 = v79;
                    *(unsigned char *)(i + 63) = 0;
                    *(unsigned char *)(i + 40) = 0;
                    v73 += 64;
                  }
                }
              }
            }
LABEL_134:
            uint64_t v80 = *(void *)(v2 + 160);
            if (v73 != v80)
            {
              uint64_t v81 = (void *)(v80 - 64);
              std::string::size_type v82 = v81;
              CFTypeID v83 = v81;
              do
              {
                uint64_t v84 = *v83;
                v83 -= 8;
                (*(void (**)(void *))(v84 + 16))(v82);
                v81 -= 8;
                BOOL v43 = v82 == (void *)v73;
                std::string::size_type v82 = v83;
              }
              while (!v43);
              *(void *)(v2 + 160) = v73;
            }
            sub_100062B40(*(std::string **)buf, *(std::string **)&buf[8], ",", 1uLL, &v198);
            *(void *)&long long v196 = buf;
            sub_100047F64((void ***)&v196);
            if (v59) {
              sub_10004D2C8(v59);
            }
            std::string::size_type size = HIBYTE(v198.__r_.__value_.__r.__words[2]);
            int v86 = SHIBYTE(v198.__r_.__value_.__r.__words[2]);
            if ((v198.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type size = v198.__r_.__value_.__l.__size_;
            }
            if (size)
            {
              uint64_t v87 = *(NSObject **)(v2 + 40);
              if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
              {
                __int16 v88 = (std::string *)v198.__r_.__value_.__r.__words[0];
                if (v86 >= 0) {
                  __int16 v88 = &v198;
                }
                *(_DWORD *)std::string buf = 136446210;
                *(void *)&uint8_t buf[4] = v88;
                _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "#I Deleted expired earthquake alerts: %{public}s", buf, 0xCu);
              }
            }
            CFDictionaryGetValue(v181, @"UniqueID");
            long long v196 = 0uLL;
            CFNumberRef v197 = 0;
            ctu::cf::assign();
            long long v204 = v196;
            uint64_t v205 = v197;
            CFNumberRef v197 = 0;
            long long v196 = 0uLL;
            if (SHIBYTE(v205) >= 0) {
              uint64_t v89 = HIBYTE(v205);
            }
            else {
              uint64_t v89 = *((void *)&v204 + 1);
            }
            if (v89)
            {
              uint64_t v90 = *(void *)(v2 + 152);
              uint64_t v91 = *(void *)(v2 + 160);
              if (v90 != v91)
              {
                if (SHIBYTE(v205) >= 0) {
                  uint64_t v92 = &v204;
                }
                else {
                  uint64_t v92 = (long long *)v204;
                }
                do
                {
                  uint64_t v93 = *(unsigned __int8 *)(v90 + 63);
                  if ((v93 & 0x80u) == 0) {
                    uint64_t v94 = *(unsigned __int8 *)(v90 + 63);
                  }
                  else {
                    uint64_t v94 = *(void *)(v90 + 48);
                  }
                  if (v94 == v89)
                  {
                    if ((v93 & 0x80) != 0)
                    {
                      if (!memcmp(*(const void **)(v90 + 40), v92, *(void *)(v90 + 48)))
                      {
LABEL_244:
                        std::string::size_type v138 = *(NSObject **)(v2 + 40);
                        if (os_log_type_enabled(v138, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)std::string buf = 136446210;
                          *(void *)&uint8_t buf[4] = v92;
                          _os_log_error_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_ERROR, "Invalid Safety alert: Repeated unique ID: %{public}s", buf, 0xCu);
                        }
                        uint64_t v18 = 94;
                        goto LABEL_258;
                      }
                    }
                    else
                    {
                      if (!*(unsigned char *)(v90 + 63)) {
                        goto LABEL_244;
                      }
                      uint64_t v95 = 0;
                      while (*(unsigned __int8 *)(v90 + v95 + 40) == *((unsigned __int8 *)v92 + v95))
                      {
                        if (v93 == ++v95) {
                          goto LABEL_244;
                        }
                      }
                    }
                  }
                  v90 += 64;
                }
                while (v90 != v91);
              }
              CFArrayRef v96 = (const __CFArray *)CFDictionaryGetValue(v181, @"Info");
              CFArrayRef v97 = v96;
              if (v96)
              {
                CFTypeID v98 = CFGetTypeID(v96);
                if (v98 == CFArrayGetTypeID())
                {
                  CFIndex Count = CFArrayGetCount(v97);
                  unint64_t v100 = *(NSObject **)(v2 + 40);
                  if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)std::string buf = 134217984;
                    *(void *)&uint8_t buf[4] = Count;
                    _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#I Received %ld info array", buf, 0xCu);
                  }
                  CFArrayRef v193 = 0;
                  CFTypeID v194 = 0;
                  uint64_t v195 = 0;
                  theDict[0] = 0;
                  theDict[1] = 0;
                  uint64_t v192 = 0;
                  subscriber::makeSimSlotRange();
                  uint32_t v102 = *(unsigned int **)buf;
                  uint64_t v101 = *(unsigned int **)&buf[8];
                  if (*(void *)buf != *(void *)&buf[8])
                  {
                    int v103 = *(uint64_t (**)(void))&buf[16];
                    do
                    {
                      if (v103(*v102)) {
                        goto LABEL_177;
                      }
                      ++v102;
                    }
                    while (v102 != v101);
                    uint32_t v102 = v101;
LABEL_177:
                    uint64_t v104 = *(unsigned int **)&buf[8];
                    while (v102 != v104)
                    {
                      CellBroadcastConfig::getPrimaryBroadcastLanguages_sync(v2, *v102, (uint64_t *)v189);
                      sub_10005CBB4((uint64_t *)theDict);
                      *(_OWORD *)CFDictionaryRef theDict = *(_OWORD *)v189;
                      uint64_t v192 = v190;
                      v189[1] = 0;
                      uint64_t v190 = 0;
                      v189[0] = 0;
                      *(void *)&long long v187 = v189;
                      sub_100047F64((void ***)&v187);
                      if (theDict[0] != theDict[1]) {
                        break;
                      }
                      int v105 = v102 + 1;
                      uint32_t v102 = v101;
                      if (v105 != v101)
                      {
                        uint32_t v102 = v105;
                        do
                        {
                          if (v103(*v102)) {
                            goto LABEL_184;
                          }
                          ++v102;
                        }
                        while (v102 != v101);
                        uint32_t v102 = v101;
                      }
LABEL_184:
                      ;
                    }
                  }
                  buf[0] = 0;
                  uint64_t v106 = sub_1000D8740((uint64_t)theDict[0], (uint64_t)theDict[1], (unsigned __int8 **)(v2 + 456));
                  if (Count < 1)
                  {
LABEL_305:
                    char v162 = v193;
                    int v163 = v194;
                    if (v194 == v193)
                    {
                      CFNumberRef v174 = *(NSObject **)(v2 + 40);
                      if (os_log_type_enabled(v174, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)std::string buf = 0;
                        _os_log_error_impl((void *)&_mh_execute_header, v174, OS_LOG_TYPE_ERROR, "No earthquake warning to send notification", buf, 2u);
                      }
                    }
                    else
                    {
                      uint64_t v164 = (void *)(v2 + 152);
                      int v165 = (unint64_t *)(v2 + 168);
                      unint64_t v166 = *(void *)(v2 + 160);
                      do
                      {
                        if (v166 >= *v165)
                        {
                          uint64_t v167 = (uint64_t)(v166 - *v164) >> 6;
                          if ((unint64_t)(v167 + 1) >> 58) {
                            sub_10006A748();
                          }
                          uint64_t v168 = *v165 - *v164;
                          uint64_t v169 = v168 >> 5;
                          if (v168 >> 5 <= (unint64_t)(v167 + 1)) {
                            uint64_t v169 = v167 + 1;
                          }
                          if ((unint64_t)v168 >= 0x7FFFFFFFFFFFFFC0) {
                            unint64_t v170 = 0x3FFFFFFFFFFFFFFLL;
                          }
                          else {
                            unint64_t v170 = v169;
                          }
                          uint64_t v208 = v2 + 168;
                          if (v170) {
                            unint64_t v170 = (unint64_t)sub_10016063C(v170);
                          }
                          else {
                            uint64_t v171 = 0;
                          }
                          *(void *)std::string buf = v170;
                          *(void *)&uint8_t buf[8] = v170 + (v167 << 6);
                          *(void *)&uint8_t buf[16] = *(void *)&buf[8];
                          unint64_t v207 = v170 + (v171 << 6);
                          sub_1004AC8C4(*(uint64_t *)&buf[8], (uint64_t)v162);
                          *(void *)&buf[16] += 64;
                          sub_1004AC790((uint64_t *)(v2 + 152), buf);
                          unint64_t v166 = *(void *)(v2 + 160);
                          sub_1004AC858((uint64_t)buf);
                        }
                        else
                        {
                          sub_1004AC8C4(v166, (uint64_t)v162);
                          v166 += 64;
                          *(void *)(v2 + 160) = v166;
                        }
                        *(void *)(v2 + 160) = v166;
                        v162 += 64;
                      }
                      while (v162 != v163);
                      sub_100058198(&valuePtr, (const void **)&v203);
                      sub_100058198(&v183, (const void **)&v202);
                      sub_1004A7488(v2, (uint64_t)v193, (uint64_t)v194, &valuePtr, &v183);
                      sub_100057D78(&v183);
                      sub_100057D78(&valuePtr);
                    }
                    uint64_t v18 = 0;
                    goto LABEL_340;
                  }
                  CFDictionaryRef v107 = (const __CFDictionary *)v106;
                  CFIndex v108 = 0;
                  CFDictionaryRef v180 = theDict[1];
                  uint64_t v18 = 94;
                  while (1)
                  {
                    CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(v97, v108);
                    CFArrayRef v110 = ValueAtIndex;
                    if (!ValueAtIndex || (CFTypeID v111 = CFGetTypeID(ValueAtIndex), v111 != CFArrayGetTypeID()))
                    {
                      CFNumberRef v172 = *(NSObject **)(v2 + 40);
                      if (!os_log_type_enabled(v172, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_339;
                      }
                      *(_WORD *)std::string buf = 0;
                      CFTypeID v173 = "Invalid info block element: Not an array";
LABEL_337:
                      v176 = v172;
                      uint32_t v177 = 2;
                      goto LABEL_338;
                    }
                    if (CFArrayGetCount(v110) != 2)
                    {
                      int v175 = *(NSObject **)(v2 + 40);
                      if (!os_log_type_enabled(v175, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_339;
                      }
                      *(_DWORD *)std::string buf = 134218240;
                      *(void *)&uint8_t buf[4] = Count;
                      *(_WORD *)&unsigned char buf[12] = 1024;
                      *(_DWORD *)&buf[14] = 2;
                      CFTypeID v173 = "Invalid Info block element: Size: %ld != %u";
                      v176 = v175;
                      uint32_t v177 = 18;
LABEL_338:
                      _os_log_error_impl((void *)&_mh_execute_header, v176, OS_LOG_TYPE_ERROR, v173, buf, v177);
LABEL_339:
                      uint64_t v18 = 22;
LABEL_340:
                      *(void *)std::string buf = theDict;
                      sub_100047F64((void ***)buf);
                      *(void *)std::string buf = &v193;
                      sub_1004AC990((void ***)buf);
LABEL_258:
                      if (SHIBYTE(v205) < 0) {
                        operator delete((void *)v204);
                      }
                      if (SHIBYTE(v198.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v198.__r_.__value_.__l.__data_);
                      }
LABEL_262:
                      sub_100057D78((const void **)&v202);
                      sub_100057D78((const void **)&v203);
LABEL_263:
                      sub_1004ACA50((uint64_t)cf);
                      unint64_t v40 = (v18 << 32) | 1;
                      sub_100057D78((const void **)&v181);
                      int v44 = &v182;
LABEL_264:
                      sub_100057D78(v44);
                      return v40;
                    }
                    CFNumberRef v112 = (const __CFNumber *)CFArrayGetValueAtIndex(v110, 0);
                    CFNumberRef v113 = v112;
                    if (v112)
                    {
                      CFTypeID v114 = CFGetTypeID(v112);
                      if (v114 == CFNumberGetTypeID()) {
                        CFNumberRef v115 = v113;
                      }
                      else {
                        CFNumberRef v115 = 0;
                      }
                    }
                    else
                    {
                      CFNumberRef v115 = 0;
                    }
                    LODWORD(valuePtr) = 0;
                    if (!CFNumberGetValue(v115, kCFNumberIntType, &valuePtr))
                    {
                      CFNumberRef v172 = *(NSObject **)(v2 + 40);
                      if (!os_log_type_enabled(v172, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_339;
                      }
                      *(_WORD *)std::string buf = 0;
                      CFTypeID v173 = "Failed to read the CFNumber for language ";
                      goto LABEL_337;
                    }
                    if (!valuePtr)
                    {
                      CFNumberRef v172 = *(NSObject **)(v2 + 40);
                      if (!os_log_type_enabled(v172, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_339;
                      }
                      *(_WORD *)std::string buf = 0;
                      CFTypeID v173 = "Unhandled language in info block";
                      goto LABEL_337;
                    }
                    v189[0] = 0;
                    v189[1] = 0;
                    uint64_t v190 = 0;
                    CFArrayGetValueAtIndex(v110, 1);
                    long long v187 = 0uLL;
                    uint64_t v188 = 0;
                    ctu::cf::assign();
                    *(_OWORD *)std::string::size_type v189 = v187;
                    uint64_t v190 = v188;
                    uint64_t v188 = 0;
                    long long v187 = 0uLL;
                    CFDictionaryRef v116 = v189[1];
                    if (v190 >= 0) {
                      CFDictionaryRef v116 = (CFDictionaryRef)HIBYTE(v190);
                    }
                    if (v116)
                    {
                      if (v107 != v180)
                      {
                        CFDictionaryRef v117 = theDict[1];
                        int v118 = (int)valuePtr;
                        CFNumberRef v119 = "???";
                        if (valuePtr == 1) {
                          CFNumberRef v119 = "en";
                        }
                        CFNumberRef v120 = valuePtr == 2 ? "es" : (char *)v119;
                        if ((CFDictionaryRef)sub_1004AC700((uint64_t)theDict[0], (uint64_t)theDict[1], v120) == v117)
                        {
                          uint64_t v134 = *(NSObject **)(v2 + 40);
                          if (os_log_type_enabled(v134, OS_LOG_TYPE_DEFAULT))
                          {
                            __int16 v135 = "???";
                            if (v118 == 1) {
                              __int16 v135 = "en";
                            }
                            if (v118 == 2) {
                              __int16 v135 = "es";
                            }
                            *(_DWORD *)std::string buf = 136315138;
                            *(void *)&uint8_t buf[4] = v135;
                            __int16 v131 = v134;
                            char v132 = "#I Earthquake warning not allowed for language: %s";
                            uint32_t v133 = 12;
LABEL_228:
                            _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, v132, buf, v133);
                          }
LABEL_229:
                          int v129 = 22;
                          goto LABEL_236;
                        }
                      }
                      unint64_t v121 = (*(uint64_t (**)(void, CFDictionaryRef *))(**(void **)(v2 + 176) + 32))(*(void *)(v2 + 176), v189);
                      sub_1004A5724(buf, *v6);
                      int v122 = (*(uint64_t (**)(void))(**(void **)buf + 88))(*(void *)buf);
                      if (*(void *)&buf[8]) {
                        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
                      }
                      if ((_BYTE)v121)
                      {
                        unint64_t v123 = HIDWORD(v121);
                        unsigned __int16 v124 = *(NSObject **)(v2 + 40);
                        if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)std::string buf = 67109376;
                          *(_DWORD *)&uint8_t buf[4] = v122;
                          *(_WORD *)&uint8_t buf[8] = 1024;
                          *(_DWORD *)&buf[10] = v123;
                          _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, "#I Earthquake warning recently displayed via WEA [now:%u WEA:%u]", buf, 0xEu);
                        }
                        if (v201 >= (v122 - v123))
                        {
                          uint64_t v130 = *(NSObject **)(v2 + 40);
                          if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_WORD *)std::string buf = 0;
                            __int16 v131 = v130;
                            char v132 = "#I Assuming EQ warning matches WEA";
                            uint32_t v133 = 2;
                            goto LABEL_228;
                          }
                          goto LABEL_229;
                        }
                      }
                      long long v125 = *(Registry **)(v2 + 240);
                      int v126 = *(std::__shared_weak_count **)(v2 + 248);
                      if (v126) {
                        atomic_fetch_add_explicit(&v126->__shared_owners_, 1uLL, memory_order_relaxed);
                      }
                      int v127 = (int)valuePtr;
                      if (SHIBYTE(v190) < 0)
                      {
                        sub_10004FC84(__p, v189[0], (unint64_t)v189[1]);
                      }
                      else
                      {
                        *(_OWORD *)std::string __p = *(_OWORD *)v189;
                        uint64_t v186 = v190;
                      }
                      sub_1004A633C((uint64_t)buf, v125, v126, v127, (long long *)__p, &v204);
                      sub_1004A72AC((uint64_t *)&v193, (uint64_t)buf);
                      sub_1004A7428((uint64_t)buf);
                      if (SHIBYTE(v186) < 0) {
                        operator delete(__p[0]);
                      }
                      if (v126) {
                        sub_10004D2C8(v126);
                      }
                      int v129 = 0;
                    }
                    else
                    {
                      int v128 = *(NSObject **)(v2 + 40);
                      if (os_log_type_enabled(v128, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)std::string buf = 0;
                        _os_log_error_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_ERROR, "Invalid text in info block.", buf, 2u);
                      }
                      uint64_t v18 = 22;
                      int v129 = 1;
                    }
LABEL_236:
                    if (SHIBYTE(v190) < 0) {
                      operator delete(v189[0]);
                    }
                    if (v129 != 22 && v129) {
                      goto LABEL_340;
                    }
                    if (Count == ++v108) {
                      goto LABEL_305;
                    }
                  }
                }
              }
              char v136 = *(NSObject **)(v2 + 40);
              if (!os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
              {
LABEL_257:
                uint64_t v18 = 22;
                goto LABEL_258;
              }
              *(_WORD *)std::string buf = 0;
              __int16 v137 = "Failed to parse info array";
            }
            else
            {
              char v136 = *(NSObject **)(v2 + 40);
              if (!os_log_type_enabled(v136, OS_LOG_TYPE_ERROR)) {
                goto LABEL_257;
              }
              *(_WORD *)std::string buf = 0;
              __int16 v137 = "Missing Unique ID string";
            }
            _os_log_error_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_ERROR, v137, buf, 2u);
            goto LABEL_257;
          }
LABEL_87:
          sub_10004D2C8(v14);
          goto LABEL_88;
        }
        CFArrayRef v193 = 0;
        theDict[0] = 0;
        if (!CellBroadcastConfig::getEnhancedDeliverySwitchState_sync(v2, (const void **)&v193, (const void **)theDict))
        {
          std::string::size_type v50 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I Enhanced delivery disabled by user", buf, 2u);
          }
          LOBYTE(cf[0]) = 0;
          BYTE8(v200) = 0;
          int v19 = 1;
          uint64_t v18 = 1;
          goto LABEL_83;
        }
        if (v193) {
          long long v23 = sub_1000810B8;
        }
        else {
          long long v23 = 0;
        }
        if (v23)
        {
          if (theDict[0]) {
            uint64_t v24 = sub_100080778;
          }
          else {
            uint64_t v24 = 0;
          }
          if (v24)
          {
            uint64_t v25 = CFDictionaryGetValue(theDict[0], @"AlertConfiguration");
            long long v26 = v25;
            if (v25)
            {
              CFTypeID v27 = CFGetTypeID(v25);
              if (v27 == CFStringGetTypeID())
              {
                key = v26;
                v189[0] = 0;
                subscriber::makeSimSlotRange();
                uint64_t v29 = *(unsigned int **)buf;
                long long v28 = *(unsigned int **)&buf[8];
                if (*(void *)buf != *(void *)&buf[8])
                {
                  uint64_t v30 = *(uint64_t (**)(void))&buf[16];
                  do
                  {
                    if (v30(*v29)) {
                      goto LABEL_39;
                    }
                    ++v29;
                  }
                  while (v29 != v28);
                  uint64_t v29 = v28;
LABEL_39:
                  long long v31 = *(unsigned int **)&buf[8];
                  while (v29 != v31)
                  {
                    uint64_t v32 = *v29;
                    CFTypeID v33 = operator new(0x10uLL);
                    *((void *)&v204 + 1) = v33 + 2;
                    uint64_t v205 = (uint8_t *)(v33 + 2);
                    *CFTypeID v33 = @"CellBroadcast";
                    v33[1] = @"AlertConfigurations";
                    *(void *)&long long v204 = v33;
                    (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, long long *, void, void))(*(void *)v15 + 104))(__p, v15, v32, 2, &v204, 0, 0);
                    sub_10004EFE4(&v187, (CFTypeRef *)__p);
                    *(CFDictionaryRef *)&long long v196 = v189[0];
                    v189[0] = (CFDictionaryRef)v187;
                    *(void *)&long long v187 = 0;
                    sub_100057D78((const void **)&v196);
                    sub_100057D78((const void **)&v187);
                    sub_1000577C4((const void **)__p);
                    if ((void)v204)
                    {
                      *((void *)&v204 + 1) = v204;
                      operator delete((void *)v204);
                    }
                    if (v189[0]) {
                      uint64_t v34 = sub_100080778;
                    }
                    else {
                      uint64_t v34 = 0;
                    }
                    if (v34) {
                      break;
                    }
                    uint64_t v35 = v29 + 1;
                    uint64_t v29 = v28;
                    if (v35 != v28)
                    {
                      uint64_t v29 = v35;
                      do
                      {
                        if (v30(*v29)) {
                          goto LABEL_51;
                        }
                        ++v29;
                      }
                      while (v29 != v28);
                      uint64_t v29 = v28;
                    }
LABEL_51:
                    ;
                  }
                }
                *(void *)&long long v187 = 0;
                int64x2_t v36 = CFDictionaryGetValue(v189[0], key);
                int v37 = v36;
                if (v36 && (CFTypeID v38 = CFGetTypeID(v36), v38 == CFDictionaryGetTypeID()))
                {
                  *(void *)&long long v187 = v37;
                  CFRetain(v37);
                  uint64_t v39 = v187;
                }
                else
                {
                  uint64_t v39 = 0;
                  *(void *)&long long v187 = 0;
                }
                if (v39) {
                  CFArrayRef v139 = sub_100080778;
                }
                else {
                  CFArrayRef v139 = 0;
                }
                if (v139)
                {
                  __p[0] = 0;
                  CFArrayRef v140 = CFDictionaryGetValue(theDict[0], @"AlertType");
                  CFTypeID v141 = v140;
                  if (v140)
                  {
                    CFTypeID v142 = CFGetTypeID(v140);
                    if (v142 == CFDictionaryGetTypeID()) {
                      CFIndex v143 = v141;
                    }
                    else {
                      CFIndex v143 = 0;
                    }
                  }
                  else
                  {
                    CFIndex v143 = 0;
                  }
                  sub_10004EFAC(__p, v143);
                  if (__p[0]) {
                    CFTypeID v146 = sub_100080778;
                  }
                  else {
                    CFTypeID v146 = 0;
                  }
                  if (v146)
                  {
                    uint64_t v178 = *(void *)(v2 + 256);
                    int v203 = 0;
                    subscriber::makeSimSlotRange();
                    int v149 = *(unsigned int **)buf;
                    int v148 = *(unsigned int **)&buf[8];
                    if (*(void *)buf != *(void *)&buf[8])
                    {
                      v150 = *(uint64_t (**)(void))&buf[16];
                      do
                      {
                        if (v150(*v149)) {
                          goto LABEL_279;
                        }
                        ++v149;
                      }
                      while (v149 != v148);
                      int v149 = v148;
LABEL_279:
                      int v151 = *(unsigned int **)&buf[8];
                      while (v149 != v151)
                      {
                        uint64_t v152 = *v149;
                        unint64_t v153 = operator new(0x18uLL);
                        *((void *)&v204 + 1) = v153 + 3;
                        uint64_t v205 = (uint8_t *)(v153 + 3);
                        *unint64_t v153 = @"CellBroadcast";
                        v153[1] = @"DuplicateDetectionParameters";
                        v153[2] = @"DuplicationWindowForEnhancedDeliveryInMinutes";
                        *(void *)&long long v204 = v153;
                        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, uint64_t, long long *, void, void))(*(void *)v15 + 104))(&v201, v15, v152, 2, &v204, 0, 0);
                        sub_1000842D0(&v202, (CFTypeRef *)&v201);
                        *(void *)&long long v196 = v203;
                        uint64_t v154 = v202;
                        v202 = 0;
                        int v203 = v154;
                        sub_1000570E8((const void **)&v196);
                        sub_1000570E8((const void **)&v202);
                        sub_1000577C4((const void **)&v201);
                        if ((void)v204)
                        {
                          *((void *)&v204 + 1) = v204;
                          operator delete((void *)v204);
                        }
                        if (v203) {
                          BOOL v155 = sub_100081E58;
                        }
                        else {
                          BOOL v155 = 0;
                        }
                        if (v155) {
                          break;
                        }
                        unint64_t v156 = v149 + 1;
                        int v149 = v148;
                        if (v156 != v148)
                        {
                          int v149 = v156;
                          do
                          {
                            if (v150(*v149)) {
                              goto LABEL_291;
                            }
                            ++v149;
                          }
                          while (v149 != v148);
                          int v149 = v148;
                        }
LABEL_291:
                        ;
                      }
                    }
                    if (v203) {
                      uint64_t v157 = sub_100081E58;
                    }
                    else {
                      uint64_t v157 = 0;
                    }
                    if (v157)
                    {
                      *(_DWORD *)std::string buf = 0;
                      ctu::cf::assign((ctu::cf *)buf, v203, v147);
                      uint64_t v158 = *(unsigned int *)buf;
                      int v159 = *(NSObject **)(v2 + 40);
                      if (os_log_type_enabled(v159, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)std::string buf = 67109120;
                        *(_DWORD *)&uint8_t buf[4] = v158;
                        _os_log_error_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_ERROR, "Using bundle controlled timeout: %u min", buf, 8u);
                      }
                    }
                    else
                    {
                      uint64_t v158 = v178;
                    }
                    sub_100058198((const void **)buf, (const void **)&v187);
                    int v161 = sub_100058198((const void **)&buf[8], (const void **)__p);
                    *(_OWORD *)CFTypeRef cf = *(_OWORD *)buf;
                    *(void *)std::string buf = 0;
                    *(void *)&uint8_t buf[8] = 0;
                    *(void *)&uint8_t buf[16] = v158;
                    *(void *)&long long v200 = v158;
                    BYTE8(v200) = 1;
                    sub_100057D78(v161);
                    sub_100057D78((const void **)buf);
                    sub_1000570E8((const void **)&v203);
                    int v19 = 0;
                  }
                  else
                  {
                    uint32_t v160 = *(NSObject **)(v2 + 40);
                    if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)std::string buf = 138412290;
                      *(void *)&uint8_t buf[4] = @"AlertType";
                      _os_log_error_impl((void *)&_mh_execute_header, v160, OS_LOG_TYPE_ERROR, "Misconfigured bundle: CustomPreferences[].%@", buf, 0xCu);
                    }
                    LOBYTE(cf[0]) = 0;
                    BYTE8(v200) = 0;
                    int v19 = 1;
                  }
                  sub_100057D78((const void **)__p);
                }
                else
                {
                  CFNumberRef v145 = *(NSObject **)(v2 + 40);
                  if (os_log_type_enabled(v145, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)std::string buf = 138412546;
                    *(void *)&uint8_t buf[4] = @"AlertConfigurations";
                    *(_WORD *)&unsigned char buf[12] = 2112;
                    *(void *)&buf[14] = key;
                    _os_log_error_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_ERROR, "Misconfigured bundle: CellBroadcast.%@.%@", buf, 0x16u);
                  }
                  LOBYTE(cf[0]) = 0;
                  BYTE8(v200) = 0;
                  int v19 = 1;
                }
                sub_100057D78((const void **)&v187);
                sub_100057D78((const void **)v189);
                uint64_t v18 = 22;
                goto LABEL_83;
              }
            }
            unint64_t v53 = *(NSObject **)(v2 + 40);
            if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
              goto LABEL_82;
            }
            *(_DWORD *)std::string buf = 138412290;
            *(void *)&uint8_t buf[4] = @"AlertConfiguration";
            long long v52 = "Misconfigured bundle: CustomPreferences[]..%@";
            long long v54 = v53;
            uint32_t v55 = 12;
            goto LABEL_323;
          }
          unint64_t v51 = *(NSObject **)(v2 + 40);
          if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          {
LABEL_82:
            LOBYTE(cf[0]) = 0;
            BYTE8(v200) = 0;
            uint64_t v18 = 22;
            int v19 = 1;
LABEL_83:
            sub_100057D78((const void **)theDict);
            sub_1000558F4((const void **)&v193);
            goto LABEL_84;
          }
          *(_WORD *)std::string buf = 0;
          long long v52 = "Unknown error: Unable to find custom pref dict for alert";
        }
        else
        {
          unint64_t v51 = *(NSObject **)(v2 + 40);
          if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
            goto LABEL_82;
          }
          *(_WORD *)std::string buf = 0;
          long long v52 = "Unknown error: Unable to find root key name holding the alert";
        }
        long long v54 = v51;
        uint32_t v55 = 2;
LABEL_323:
        _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, v52, buf, v55);
        goto LABEL_82;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    int v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_12;
    }
    goto LABEL_22;
  }
  if (CFDictionaryContainsKey(**(CFDictionaryRef **)v1, @"WEA"))
  {
    long long v20 = CFDictionaryGetValue(**(CFDictionaryRef **)v1, @"WEA");
    if (v20 && (uint64_t v21 = v20, v22 = CFGetTypeID(v20), v22 == CFDictionaryGetTypeID()))
    {
      *(void *)std::string buf = v21;
      CFRetain(v21);
      cf[0] = v21;
      CFRetain(v21);
    }
    else
    {
      *(void *)std::string buf = 0;
      cf[0] = 0;
    }
    unint64_t v40 = sub_1004A78A8(v2, (CFDictionaryRef *)cf);
    char v42 = v41;
    sub_100057D78(cf);
    if (HIDWORD(v40)) {
      BOOL v43 = 0;
    }
    else {
      BOOL v43 = v42 == 0;
    }
    if (v43) {
      sub_1004ABA48(v2);
    }
    int v44 = (const void **)buf;
    goto LABEL_264;
  }
  CFNumberRef v46 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Attempting to handle legacy Apple safety alert", buf, 2u);
  }
  sub_100058198((const void **)buf, *(const void ***)v1);
  unint64_t v40 = sub_1004A78A8(v2, (CFDictionaryRef *)buf);
  char v48 = v47;
  sub_100057D78((const void **)buf);
  if (HIDWORD(v40)) {
    BOOL v49 = 0;
  }
  else {
    BOOL v49 = v48 == 0;
  }
  if (v49) {
    sub_1004ABA48(v2);
  }
  return v40;
}

void sub_1004AF420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, const void *a17, const void *a18, const void *a19, const void *a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45,char a46)
{
  sub_100057D78(&a19);
  sub_100057D78(&a20);
  a27 = &a31;
  sub_100047F64((void ***)&a27);
  a31 = (uint64_t)&a34;
  sub_1004AC990((void ***)&a31);
  if ((*(unsigned char *)(v46 - 185) & 0x80) != 0) {
    operator delete(*(void **)(v46 - 208));
  }
  if (a45 < 0) {
    operator delete(__p);
  }
  sub_100057D78((const void **)(v46 - 224));
  sub_100057D78((const void **)(v46 - 216));
  sub_1004ACA50((uint64_t)&a46);
  sub_100057D78(&a17);
  sub_100057D78(&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_1004AF72C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1004AF768(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

BOOL sub_1004AF7A4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (**(_DWORD **)a1 - *(_DWORD *)(a2 + 8));
  uint64_t v3 = **(void **)(a1 + 8);
  if (v3 <= v2)
  {
    uint64_t v4 = *(uint64_t **)(a1 + 16);
    (**(void (***)(void **__return_ptr, uint64_t))a2)(__p, a2);
    unint64_t v5 = v4[1];
    unint64_t v6 = v4[2];
    if (v5 >= v6)
    {
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *v4) >> 3);
      unint64_t v9 = v8 + 1;
      if (v8 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_1000D8578();
      }
      unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - *v4) >> 3);
      if (2 * v10 > v9) {
        unint64_t v9 = 2 * v10;
      }
      if (v10 >= 0x555555555555555) {
        unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v11 = v9;
      }
      v20[4] = v4 + 2;
      if (v11) {
        unsigned int v12 = (char *)sub_10004812C((uint64_t)(v4 + 2), v11);
      }
      else {
        unsigned int v12 = 0;
      }
      uint64_t v13 = &v12[24 * v8];
      v20[0] = v12;
      v20[1] = v13;
      v20[3] = &v12[24 * v11];
      long long v14 = *(_OWORD *)__p;
      *((void *)v13 + 2) = v19;
      *(_OWORD *)uint64_t v13 = v14;
      __p[1] = 0;
      uint64_t v19 = 0;
      __p[0] = 0;
      _OWORD v20[2] = v13 + 24;
      sub_100048204(v4, v20);
      uint64_t v15 = v4[1];
      sub_100048174((uint64_t)v20);
      int v16 = SHIBYTE(v19);
      v4[1] = v15;
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      long long v7 = *(_OWORD *)__p;
      *(void *)(v5 + 16) = v19;
      *(_OWORD *)unint64_t v5 = v7;
      v4[1] = v5 + 24;
    }
  }
  return v3 <= v2;
}

void sub_1004AF928(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1004AF954(uint64_t a1)
{
  *(void *)a1 = off_1019D3E20;
  sub_100057D78((const void **)(a1 + 48));
  sub_100057D78((const void **)(a1 + 40));
  uint64_t v3 = (void **)(a1 + 16);
  sub_1004AC990(&v3);
  return a1;
}

void sub_1004AF9B8(uint64_t a1)
{
  *(void *)a1 = off_1019D3E20;
  sub_100057D78((const void **)(a1 + 48));
  sub_100057D78((const void **)(a1 + 40));
  uint64_t v2 = (void **)(a1 + 16);
  sub_1004AC990(&v2);
  operator delete();
}

void *sub_1004AFA30(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  void *v2 = off_1019D3E20;
  sub_1004AFED8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1004AFA84(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004AFA98(uint64_t a1, void *a2)
{
  *a2 = off_1019D3E20;
  return sub_1004AFED8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1004AFAC4(uint64_t a1)
{
}

void sub_1004AFACC(void *a1)
{
  sub_1004AFF3C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1004AFB08(uint64_t a1, uint64_t *a2, unsigned __int8 *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  uint64_t v22 = *a2;
  *a2 = 0;
  a2[1] = 0;
  int v5 = *a3;
  unint64_t v6 = *(void **)(a1 + 8);
  long long v7 = v6[5];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Power assertion completed.", buf, 2u);
  }
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = *(void *)(a1 + 24);
  if (v8 != v9)
  {
    if (v5) {
      unint64_t v10 = "true";
    }
    else {
      unint64_t v10 = "false";
    }
    uint64_t v21 = v10;
    do
    {
      CFMutableDictionaryRef theDict = 0;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        CFMutableDictionaryRef v12 = theDict;
        CFMutableDictionaryRef theDict = Mutable;
        *(void *)std::string buf = v12;
        sub_10005717C((const void **)buf);
      }
      if (theDict) {
        uint64_t v13 = sub_1000C06D0;
      }
      else {
        uint64_t v13 = 0;
      }
      if (v13)
      {
        CFDictionarySetValue(theDict, @"AlertConfiguration", *(const void **)(a1 + 40));
        CFDictionarySetValue(theDict, @"AlertType", *(const void **)(a1 + 48));
        xpc_object_t value = 0;
        long long v14 = (const char *)(v8 + 16);
        if (*(char *)(v8 + 39) < 0) {
          long long v14 = *(const char **)v14;
        }
        uint64_t v15 = (void *)CFStringCreateWithCString(kCFAllocatorDefault, v14, 0x8000100u);
        xpc_object_t value = v15;
        if (v15) {
          int v16 = sub_1000810B8;
        }
        else {
          int v16 = 0;
        }
        if (v16)
        {
          if (v4) {
            atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          int64_t v17 = (std::__shared_weak_count *)v6[34];
          v6[33] = v22;
          v6[34] = v4;
          if (v17)
          {
            sub_10004D2C8(v17);
            uint64_t v15 = value;
          }
          CFDictionarySetValue(theDict, @"kCTSMSCellBroadcastString", v15);
          uint64_t v18 = v6[5];
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = v21;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Power assertion for Earthquake warning result: %s", buf, 0xCu);
          }
          CFMutableDictionaryRef v23 = theDict;
          if (theDict) {
            CFRetain(theDict);
          }
          CellBroadcastConfig::sendCmasNotification_sync((uint64_t)v6, &v23);
          sub_10005717C((const void **)&v23);
        }
        else
        {
          long long v20 = v6[5];
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to allocate string for broadcasted message", buf, 2u);
          }
        }
        sub_1000558F4((const void **)&value);
      }
      else
      {
        uint64_t v19 = v6[5];
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to allocate dictionary for notification", buf, 2u);
        }
      }
      sub_10005717C((const void **)&theDict);
      v8 += 64;
    }
    while (v8 != v9);
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_1004AFE38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004AFE8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004AFECC()
{
}

uint64_t sub_1004AFED8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  sub_1004ACA8C((unsigned char *)(a1 + 8), *(void *)(a2 + 8), *(void *)(a2 + 16), (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 6);
  sub_100058198((const void **)(a1 + 32), (const void **)(a2 + 32));
  sub_100058198((const void **)(a1 + 40), (const void **)(a2 + 40));
  return a1;
}

void sub_1004AFF3C(uint64_t a1)
{
  sub_100057D78((const void **)(a1 + 40));
  sub_100057D78((const void **)(a1 + 32));
  uint64_t v2 = (void **)(a1 + 8);
  sub_1004AC990(&v2);
}

BOOL sub_1004AFF84(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (**(_DWORD **)a1 - *(_DWORD *)(a2 + 8));
  uint64_t v3 = **(void **)(a1 + 8);
  if (v3 <= v2)
  {
    uint64_t v4 = *(uint64_t **)(a1 + 16);
    (**(void (***)(void **__return_ptr, uint64_t))a2)(__p, a2);
    unint64_t v5 = v4[1];
    unint64_t v6 = v4[2];
    if (v5 >= v6)
    {
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *v4) >> 3);
      unint64_t v9 = v8 + 1;
      if (v8 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_1000D8578();
      }
      unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - *v4) >> 3);
      if (2 * v10 > v9) {
        unint64_t v9 = 2 * v10;
      }
      if (v10 >= 0x555555555555555) {
        unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v11 = v9;
      }
      v20[4] = v4 + 2;
      if (v11) {
        CFMutableDictionaryRef v12 = (char *)sub_10004812C((uint64_t)(v4 + 2), v11);
      }
      else {
        CFMutableDictionaryRef v12 = 0;
      }
      uint64_t v13 = &v12[24 * v8];
      v20[0] = v12;
      v20[1] = v13;
      v20[3] = &v12[24 * v11];
      long long v14 = *(_OWORD *)__p;
      *((void *)v13 + 2) = v19;
      *(_OWORD *)uint64_t v13 = v14;
      __p[1] = 0;
      uint64_t v19 = 0;
      __p[0] = 0;
      _OWORD v20[2] = v13 + 24;
      sub_100048204(v4, v20);
      uint64_t v15 = v4[1];
      sub_100048174((uint64_t)v20);
      int v16 = SHIBYTE(v19);
      v4[1] = v15;
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      long long v7 = *(_OWORD *)__p;
      *(void *)(v5 + 16) = v19;
      *(_OWORD *)unint64_t v5 = v7;
      v4[1] = v5 + 24;
    }
  }
  return v3 <= v2;
}

void sub_1004B0108(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

const void **sub_1004B0134@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return CellBroadcastConfig::getEarthquakeAlertsConfiguration_sync(**(CellBroadcastConfig ***)(a1 + 40), a2);
}

const void **sub_1004B0140(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    void *v2 = 0;
    unint64_t v6 = v3;
    void *v2 = v5;
    unint64_t v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

const void **sub_1004B01B8(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    void *v2 = 0;
    unint64_t v6 = v3;
    void *v2 = v5;
    unint64_t v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

uint64_t sub_1004B0230@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  uint64_t result = capabilities::ct::getBasebandBootStrategy(a1);
  if (result < 2) {
    operator new();
  }
  if (result == 2) {
    operator new();
  }
  return result;
}

void sub_1004B0434()
{
}

void sub_1004B04E4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1004B051C(uint64_t a1)
{
}

uint64_t sub_1004B0538(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1004B057C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1004B05A8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1004B0628(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[8], v1, (dispatch_function_t)sub_1004B0700);
  __cxa_rethrow();
}

void sub_1004B0650(_Unwind_Exception *a1)
{
}

void sub_1004B0668(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1004B06A0(uint64_t a1)
{
}

uint64_t sub_1004B06BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1004B0700(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1004B072C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D3FE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004B074C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D3FE8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004B07A0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1004B07C8()
{
}

void *sub_1004B0850(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_1019D4150;
  v6[1] = &v5;
  void v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_1004B08F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1004B0910(CTXPCDeviceManagementNotificationSenderInterface *this)
{
  *(void *)this = off_1019D4098;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CTXPCDeviceManagementNotificationSenderInterface::~CTXPCDeviceManagementNotificationSenderInterface(this);
}

void sub_1004B096C(CTXPCDeviceManagementNotificationSenderInterface *this)
{
  *(void *)this = off_1019D4098;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CTXPCDeviceManagementNotificationSenderInterface::~CTXPCDeviceManagementNotificationSenderInterface(this);

  operator delete();
}

void sub_1004B09DC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1004B0A44(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004B0A80(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004B0AB8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1004B0AE8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1004B0B30()
{
}

void *sub_1004B0B44(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1019D4150;
  result[1] = v3;
  return result;
}

uint64_t sub_1004B0B8C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D4150;
  a2[1] = v2;
  return result;
}

void sub_1004B0BB8(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 didChangeDeviceManagementSettings:v3];
}

void sub_1004B0C2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1004B0C4C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004B0C8C()
{
}

void sub_1004B0C98(void *a1@<X0>, std::__shared_weak_count **a2@<X8>)
{
  id v4 = (std::__shared_weak_count *)operator new(0x48uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_1019D42B0;
  int v5 = v4 + 1;
  sub_1004B0D8C(&v4[1].__vftable, a1);
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)off_1019D4300;
  shared_weak_owners = (std::__shared_weak_count *)v4[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v4[1].__shared_owners_ = (uint64_t)v5;
    v4[1].__shared_weak_owners_ = (uint64_t)v4;
    goto LABEL_5;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v4[1].__shared_owners_ = (uint64_t)v5;
    v4[1].__shared_weak_owners_ = (uint64_t)v4;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
LABEL_5:
    sub_10004D2C8(v4);
  }
  *a2 = v5;
  a2[1] = v4;
}

void sub_1004B0D74(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void *sub_1004B0D8C(void *a1, void *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v6, kCtLoggingSystemName, "carrier.space.factory");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, &v6);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 3), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v6);
  *a1 = off_1019D41D0;
  a1[4] = *a2;
  uint64_t v4 = a2[1];
  a1[5] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_1004B0E5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)v2 + 2);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  CarrierSpaceFactoryInterface::~CarrierSpaceFactoryInterface(v2);
  _Unwind_Resume(a1);
}

void sub_1004B0E9C(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v4);
    if (v4)
    {
      if (*(void *)(a1 + 32)) {
        sub_10040DEB8();
      }
    }
  }
  *a2 = 0;
  a2[1] = 0;
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_1004B0F18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

double sub_1004B0F30@<D0>(CCPreferences *a1@<X0>, _OWORD *a2@<X8>)
{
  CCPreferences::create((uint64_t *)&v4, a1);
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

void sub_1004B0F68(uint64_t a1@<X0>, void *a2@<X8>)
{
  long long v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4 && (uint64_t v5 = std::__shared_weak_count::lock(v4)) != 0)
  {
    if (*(void *)(a1 + 32))
    {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100DC779C();
    }
    *a2 = 0;
    a2[1] = 0;
    sub_10004D2C8(v5);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1004B1038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_1004B1058(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  OsLogContext v6 = *(std::__shared_weak_count **)(a1 + 40);
  if (v6 && (unint64_t v9 = std::__shared_weak_count::lock(v6)) != 0)
  {
    uint64_t v10 = *(void *)(a1 + 32);
    if (v10)
    {
      v14[0] = 0;
      v14[1] = 0;
      uint64_t v12 = v10;
      uint64_t v13 = v9;
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      dispatch_object_t object = *a2;
      *a2 = 0;
      sub_100F58270((uint64_t)&v12, &object, v14);
      if (object) {
        dispatch_release(object);
      }
      if (v13) {
        sub_10004D2C8(v13);
      }
      *a3 = 0;
      a3[1] = 0;
      operator new();
    }
    *a4 = 0;
    a4[1] = 0;
    sub_10004D2C8(v9);
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
  }
}

void sub_1004B1198(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

void sub_1004B11E0(uint64_t a1@<X0>, void *a2@<X8>)
{
  long long v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4 && (uint64_t v5 = std::__shared_weak_count::lock(v4)) != 0)
  {
    if (*(void *)(a1 + 32)) {
      sub_100E2A83C();
    }
    *a2 = 0;
    a2[1] = 0;
    sub_10004D2C8(v5);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1004B126C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1004B1280(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  OsLogContext v6 = *(std::__shared_weak_count **)(a1 + 40);
  if (v6 && (unint64_t v9 = std::__shared_weak_count::lock(v6)) != 0)
  {
    uint64_t v10 = *(void *)(a1 + 32);
    if (v10)
    {
      v14[0] = 0;
      v14[1] = 0;
      uint64_t v12 = v10;
      uint64_t v13 = v9;
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      dispatch_object_t object = *a2;
      *a2 = 0;
      sub_101306B80(&v12, &object, v14);
      if (object) {
        dispatch_release(object);
      }
      if (v13) {
        sub_10004D2C8(v13);
      }
      *a3 = 0;
      a3[1] = 0;
      operator new();
    }
    *a4 = 0;
    a4[1] = 0;
    sub_10004D2C8(v9);
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
  }
}

void sub_1004B13C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

void sub_1004B1408(uint64_t a1@<X0>, void *a2@<X8>)
{
  long long v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4 && (uint64_t v5 = std::__shared_weak_count::lock(v4)) != 0)
  {
    if (*(void *)(a1 + 32))
    {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      CarrierSpaceDataPlanMetricsProvider::create();
    }
    *a2 = 0;
    a2[1] = 0;
    sub_10004D2C8(v5);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1004B14A8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1004B14C4(void *a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = (std::__shared_weak_count *)a1[5];
  if (!v5)
  {
    uint64_t v7 = 0;
    goto LABEL_13;
  }
  uint64_t v7 = std::__shared_weak_count::lock(v5);
  if (!v7 || (unint64_t v8 = (Registry *)a1[4]) == 0)
  {
LABEL_13:
    *a3 = 0;
    a3[1] = 0;
    if (!v7) {
      return;
    }
    goto LABEL_14;
  }
  CFStringRef v31 = @"DONE";
  CFRetain(@"DONE");
  CFTypeRef cf = @"PLAN_CHANGE_SUCCESS";
  CFRetain(@"PLAN_CHANGE_SUCCESS");
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8);
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (v15)
  {
    uint64_t v17 = v15[3];
    int v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      if (!v17) {
        goto LABEL_10;
      }
LABEL_18:
      uint64_t v20 = kCBMessageLocalizationTable;
      (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v17 + 40))(&v29, v17, kCBMessageLocalizationTable, v31, v31);
      *(void *)std::string buf = v31;
      CFStringRef v31 = v29;
      CFStringRef v29 = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&v29);
      (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, CFTypeRef, CFTypeRef))(*(void *)v17 + 40))(&v29, v17, v20, cf, cf);
      *(void *)std::string buf = cf;
      CFStringRef v21 = v29;
      CFStringRef v29 = 0;
      CFTypeRef cf = v21;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&v29);
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  int v16 = 0;
  char v18 = 1;
  if (v17) {
    goto LABEL_18;
  }
LABEL_10:
  uint64_t v19 = a1[3];
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Unable to fetch LocalizationInterface from Registry!", buf, 2u);
  }
LABEL_19:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  CFStringRef v22 = (const __CFString *)cf;
  CFTypeRef v28 = cf;
  if (cf) {
    CFRetain(cf);
  }
  CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, v22);
  sub_1000558F4(&v28);
  CFStringRef v29 = Copy;
  CFStringRef v27 = CFStringCreateWithFormat(0, 0, Copy, *a2);
  uint64_t v25 = 0;
  uint64_t v24 = operator new(0x48uLL);
  v24[1] = 0;
  v24[2] = 0;
  *uint64_t v24 = off_1019AB758;
  sub_1001D7704((uint64_t)(v24 + 3), (const void **)&v27, &v25, (const void **)&v31);
  *(void *)std::string buf = v24 + 3;
  *(void *)&uint8_t buf[8] = v24;
  sub_1000B3BC8((uint64_t)buf, v24 + 4, (uint64_t)(v24 + 3));
  *(_OWORD *)a3 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  sub_1000558F4(&v25);
  sub_1000558F4((const void **)&v27);
  sub_1000558F4((const void **)&v29);
  sub_1000558F4(&cf);
  sub_1000558F4((const void **)&v31);
  if (v7) {
LABEL_14:
  }
    sub_10004D2C8(v7);
}

void sub_1004B17FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v13 = va_arg(va1, const void *);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void sub_1004B1878(void *a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = (std::__shared_weak_count *)a1[5];
  if (!v5)
  {
    uint64_t v7 = 0;
    goto LABEL_13;
  }
  uint64_t v7 = std::__shared_weak_count::lock(v5);
  if (!v7 || (unint64_t v8 = (Registry *)a1[4]) == 0)
  {
LABEL_13:
    *a3 = 0;
    a3[1] = 0;
    if (!v7) {
      return;
    }
    goto LABEL_14;
  }
  CFStringRef v30 = @"OK";
  CFRetain(@"OK");
  CFTypeRef cf = @"PLAN_CHANGE_FAILURE";
  CFRetain(@"PLAN_CHANGE_FAILURE");
  CFStringRef v28 = @"CONTACT_CARRIER_FOR_DETAILS";
  CFRetain(@"CONTACT_CARRIER_FOR_DETAILS");
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8);
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (v15)
  {
    uint64_t v17 = v15[3];
    int v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      if (!v17) {
        goto LABEL_10;
      }
LABEL_18:
      uint64_t v20 = kCBMessageLocalizationTable;
      (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v17 + 40))(&v27, v17, kCBMessageLocalizationTable, v30, v30);
      *(void *)std::string buf = v30;
      CFStringRef v30 = v27;
      CFStringRef v27 = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&v27);
      (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, CFTypeRef, CFTypeRef))(*(void *)v17 + 40))(&v27, v17, v20, cf, cf);
      *(void *)std::string buf = cf;
      CFTypeRef cf = v27;
      CFStringRef v27 = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&v27);
      (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v17 + 40))(&v27, v17, v20, v28, v28);
      *(void *)std::string buf = v28;
      CFStringRef v21 = v27;
      CFStringRef v27 = 0;
      CFStringRef v28 = v21;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&v27);
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  int v16 = 0;
  char v18 = 1;
  if (v17) {
    goto LABEL_18;
  }
LABEL_10:
  uint64_t v19 = a1[3];
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Unable to fetch LocalizationInterface from Registry!", buf, 2u);
  }
LABEL_19:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  CFStringRef v22 = (const __CFString *)cf;
  CFTypeRef v26 = cf;
  if (cf) {
    CFRetain(cf);
  }
  CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, v22);
  sub_1000558F4(&v26);
  CFStringRef v27 = Copy;
  CFStringRef v25 = CFStringCreateWithFormat(0, 0, Copy, *a2);
  sub_100201D40((const void **)&v25, (const void **)&v28, (const void **)&v30, buf);
  *(_OWORD *)a3 = *(_OWORD *)buf;
  sub_1000558F4((const void **)&v25);
  sub_1000558F4((const void **)&v27);
  sub_1000558F4((const void **)&v28);
  sub_1000558F4(&cf);
  sub_1000558F4((const void **)&v30);
  if (v7) {
LABEL_14:
  }
    sub_10004D2C8(v7);
}

void sub_1004B1BD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va2, a9);
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v13 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v15 = va_arg(va2, const void *);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void sub_1004B1C58(void *a1@<X0>, NSObject **a2@<X1>, void *a3@<X2>, void *a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  unint64_t v8 = (std::__shared_weak_count *)a1[5];
  if (!v8)
  {
    uint64_t v13 = 0;
    goto LABEL_14;
  }
  uint64_t v13 = std::__shared_weak_count::lock(v8);
  if (!v13 || (unsigned int v14 = (Registry *)a1[4]) == 0 || !*(void *)(a5 + 24))
  {
LABEL_14:
    *a6 = 0;
    a6[1] = 0;
    if (!v13) {
      return;
    }
    goto LABEL_15;
  }
  CFTypeRef cf = @"PLAN_PURCHASE_CONFIRM";
  CFRetain(@"PLAN_PURCHASE_CONFIRM");
  CFStringRef v41 = @"CANCEL";
  CFRetain(@"CANCEL");
  CFStringRef v40 = @"CONTINUE";
  CFRetain(@"CONTINUE");
  ServiceMap = (std::mutex *)Registry::getServiceMap(v14);
  int v16 = ServiceMap;
  if (v17 < 0)
  {
    char v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v19 = 5381;
    do
    {
      uint64_t v17 = v19;
      unsigned int v20 = *v18++;
      uint64_t v19 = (33 * v19) ^ v20;
    }
    while (v20);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v17;
  CFStringRef v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)buf);
  if (v21)
  {
    uint64_t v34 = a5;
    CFStringRef v22 = a2;
    CFMutableDictionaryRef v23 = a3;
    uint64_t v24 = a4;
    uint64_t v26 = v21[3];
    CFStringRef v25 = (std::__shared_weak_count *)v21[4];
    if (v25)
    {
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v16);
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      CFStringRef v27 = v25;
      sub_10004D2C8(v25);
      char v28 = 0;
      a4 = v24;
      a3 = v23;
      a2 = v22;
      a5 = v34;
      if (!v26) {
        goto LABEL_11;
      }
      goto LABEL_20;
    }
    a4 = v24;
    a3 = v23;
    a2 = v22;
    a5 = v34;
  }
  else
  {
    uint64_t v26 = 0;
  }
  std::mutex::unlock(v16);
  CFStringRef v27 = 0;
  char v28 = 1;
  if (!v26)
  {
LABEL_11:
    CFStringRef v29 = a1[3];
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Unable to fetch LocalizationInterface from Registry!", buf, 2u);
    }
    goto LABEL_21;
  }
LABEL_20:
  uint64_t v30 = kCBMessageLocalizationTable;
  (*(void (**)(NSObject **__return_ptr, uint64_t, void, CFTypeRef, CFTypeRef))(*(void *)v26 + 40))(&v43, v26, kCBMessageLocalizationTable, cf, cf);
  *(void *)std::string buf = cf;
  CFTypeRef cf = v43;
  BOOL v43 = 0;
  sub_1000558F4((const void **)buf);
  sub_1000558F4((const void **)&v43);
  (*(void (**)(NSObject **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v26 + 40))(&v43, v26, v30, v41, v41);
  *(void *)std::string buf = v41;
  CFStringRef v41 = (const __CFString *)v43;
  BOOL v43 = 0;
  sub_1000558F4((const void **)buf);
  sub_1000558F4((const void **)&v43);
  (*(void (**)(NSObject **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v26 + 40))(&v43, v26, v30, v40, v40);
  *(void *)std::string buf = v40;
  CFStringRef v40 = (const __CFString *)v43;
  BOOL v43 = 0;
  sub_1000558F4((const void **)buf);
  sub_1000558F4((const void **)&v43);
LABEL_21:
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  CFStringRef v31 = (const __CFString *)cf;
  CFTypeRef v39 = cf;
  if (cf) {
    CFRetain(cf);
  }
  CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, v31);
  sub_1000558F4(&v39);
  CFStringRef v38 = Copy;
  CFStringRef v37 = CFStringCreateWithFormat(0, 0, Copy, *a3, *a4);
  uint64_t v35 = 0;
  CFTypeID v33 = operator new(0x78uLL);
  v33[1] = 0;
  v33[2] = 0;
  *CFTypeID v33 = off_1019AE920;
  BOOL v43 = *a2;
  *a2 = 0;
  sub_1001D7AC4((uint64_t)(v33 + 3), (const void **)&v37, &v35, (const void **)&v40, (const void **)&v41, &v43, a5);
  if (v43) {
    dispatch_release(v43);
  }
  *(void *)std::string buf = v33 + 3;
  *(void *)&uint8_t buf[8] = v33;
  sub_1000B3BC8((uint64_t)buf, v33 + 4, (uint64_t)(v33 + 3));
  *(_OWORD *)a6 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  sub_1000558F4(&v35);
  sub_1000558F4((const void **)&v37);
  sub_1000558F4((const void **)&v38);
  sub_1000558F4((const void **)&v40);
  sub_1000558F4((const void **)&v41);
  sub_1000558F4(&cf);
LABEL_15:
  sub_10004D2C8(v13);
}

void sub_1004B2080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va2, a11);
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v15 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v17 = va_arg(va2, const void *);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_1004B212C(uint64_t a1@<X0>, void *a2@<X8>)
{
  long long v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4 && (uint64_t v5 = std::__shared_weak_count::lock(v4)) != 0)
  {
    if (*(void *)(a1 + 32)) {
      sub_1003AF008();
    }
    *a2 = 0;
    a2[1] = 0;
    sub_10004D2C8(v5);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1004B21F4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1004B2208(void *a1)
{
  *a1 = off_1019D41D0;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  CarrierSpaceFactoryInterface::~CarrierSpaceFactoryInterface((CarrierSpaceFactoryInterface *)a1);
}

void sub_1004B2278(void *a1)
{
  *a1 = off_1019D41D0;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  CarrierSpaceFactoryInterface::~CarrierSpaceFactoryInterface((CarrierSpaceFactoryInterface *)a1);

  operator delete();
}

void sub_1004B22FC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D42B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004B231C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D42B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004B2370(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1004B2398(void *a1)
{
  *a1 = off_1019D41D0;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  CarrierSpaceFactoryInterface::~CarrierSpaceFactoryInterface((CarrierSpaceFactoryInterface *)a1);
}

void sub_1004B2408(void *a1)
{
  *a1 = off_1019D41D0;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  CarrierSpaceFactoryInterface::~CarrierSpaceFactoryInterface((CarrierSpaceFactoryInterface *)a1);

  operator delete();
}

uint64_t sub_1004B248C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1004B24BC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_1004B250C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    unint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11)
      {
        *(_OWORD *)unsigned int v14 = *(_OWORD *)a3;
        uint64_t v15 = *(void *)(a3 + 16);
        *(void *)a3 = 0;
        *(void *)(a3 + 8) = 0;
        *(void *)(a3 + 16) = 0;
        *(_OWORD *)std::string __p = *(_OWORD *)a4;
        uint64_t v13 = *(void *)(a4 + 16);
        *(void *)(a4 + 8) = 0;
        *(void *)(a4 + 16) = 0;
        *(void *)a4 = 0;
        (*(void (**)(uint64_t, uint64_t, void **, void **))(*(void *)v11 + 16))(v11, a2, v14, __p);
        if (SHIBYTE(v13) < 0) {
          operator delete(__p[0]);
        }
        if (v14[0])
        {
          v14[1] = v14[0];
          operator delete(v14[0]);
        }
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_1004B25F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_1004B2628(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    unint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 24))(v11, a2, a3, a4);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_1004B26D8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004B26EC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1004B271C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_1004B276C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 16))(v9, a2, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1004B2808(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1004B281C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 24))(v9, a2, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1004B28B8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1004B28CC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      long long v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 32))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1004B294C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1004B2960()
{
}

void sub_1004B2CC8(_Unwind_Exception *a1)
{
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v4);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1004B2D60(uint64_t a1)
{
  return a1;
}

void sub_1004B2D8C(uint64_t a1)
{
  operator delete();
}

void *sub_1004B2DD8(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019D4428;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1004B2E30(uint64_t a1, void *a2)
{
  *a2 = off_1019D4428;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1004B2E78(uint64_t a1)
{
}

void sub_1004B2E80(id *a1)
{
  operator delete(a1);
}

void sub_1004B2EBC(uint64_t a1, unsigned char *a2)
{
  if (*a2)
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
  }
  id v4 = (id)v3;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_1004B2F48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1004B2F5C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019D4488)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1004B2F9C()
{
  return &off_1019D4488;
}

void sub_1004B2FA8(Registry **a1, uint64_t a2, uint64_t a3)
{
  char v6 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  uint64_t v7 = dispatch_queue_create("StewieAlert", v6);
  if (!a2 || !a3) {
    goto LABEL_23;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  v20[0] = v10;
  unsigned int v14 = sub_10004D37C(&v9[1].__m_.__sig, v20);
  if (!v14)
  {
    std::mutex::unlock(v9);
    goto LABEL_23;
  }
  uint64_t v16 = v14[3];
  uint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v9);
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v15);
    if (!v16)
    {
LABEL_22:
      sub_10004D2C8(v15);
      goto LABEL_23;
    }
  }
  else
  {
    std::mutex::unlock(v9);
    if (!v16) {
      goto LABEL_23;
    }
  }
  CFMutableDictionaryRef v23 = 0;
  uint64_t v17 = kBifrostLocalizationTable;
  (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, void))(*(void *)v16 + 40))(&v23, v16, kBifrostLocalizationTable, a2, 0);
  CFStringRef v22 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, void))(*(void *)v16 + 40))(&v22, v16, v17, a3, 0);
  if (v23) {
    char v18 = sub_1000810B8;
  }
  else {
    char v18 = 0;
  }
  if (v18)
  {
    if (v22 ? sub_1000810B8 : 0)
    {
      CFStringRef v21 = 0;
      (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v16 + 40))(&v21, v16, v17, @"BIFROST_ALERT_OK", @"OK");
      sub_100201D40(&v23, &v22, &v21, v20);
      operator new();
    }
  }
  sub_1000558F4(&v22);
  sub_1000558F4(&v23);
  if (v15) {
    goto LABEL_22;
  }
LABEL_23:
  if (v7) {
    dispatch_release(v7);
  }
}

void sub_1004B326C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v7 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v4) {
    dispatch_release(v4);
  }
  _Unwind_Resume(a1);
}

void sub_1004B32CC(const void *a1, const void *a2, const void *a3)
{
  char v6 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  uint64_t v7 = dispatch_queue_create("StewieAlertWithoutLocalization", v6);
  if (a1 && a2 && a3)
  {
    unint64_t v8 = operator new(0x48uLL);
    v8[1] = 0;
    void v8[2] = 0;
    *unint64_t v8 = off_1019AB758;
    uint64_t v12 = a1;
    CFRetain(a1);
    uint64_t v11 = a2;
    CFRetain(a2);
    uint64_t v10 = a3;
    CFRetain(a3);
    sub_1001D7704((uint64_t)(v8 + 3), &v12, &v11, &v10);
    sub_1000558F4(&v10);
    sub_1000558F4(&v11);
    sub_1000558F4(&v12);
    v9[0] = v8 + 3;
    v9[1] = v8;
    sub_1000B3BC8((uint64_t)v9, v8 + 4, (uint64_t)(v8 + 3));
    operator new();
  }
  if (v7) {
    dispatch_release(v7);
  }
}

void sub_1004B344C(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004B3464(Registry **a1, uint64_t a2, long long *a3, int a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  v31[0] = (void *)v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)v31);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_9:
    std::mutex::unlock(v8);
    unsigned int v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_31;
    }
    goto LABEL_10;
  }
  uint64_t v15 = v13[3];
  unsigned int v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (!v15) {
    goto LABEL_31;
  }
LABEL_10:
  uint64_t v33 = 0;
  memset(&v31[1], 0, 64);
  long long v36 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  uint64_t v34 = 23;
  qmemcpy((char *)&v31[2] + 7, "\tStewie", 7);
  LOBYTE(v31[1]) = 121;
  v31[0] = *(void **)"Telephony";
  HIBYTE(v31[5]) = 6;
  uint64_t v17 = *(void **)(a2 + 16);
  *(_OWORD *)&v31[6] = *(_OWORD *)a2;
  *(unsigned char *)(a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  long long v18 = *a3;
  uint64_t v19 = *((void *)a3 + 2);
  v31[8] = v17;
  uint64_t v33 = v19;
  long long v32 = v18;
  *((unsigned char *)a3 + 23) = 0;
  *(unsigned char *)a3 = 0;
  CFStringRef v37 = &v34;
  int v38 = 0;
  sub_10019E478((uint64_t)&v37, 5uLL);
  uint64_t v20 = 7;
  if (a4) {
    uint64_t v20 = 23;
  }
  v34 |= v20;
  sub_1000DB86C((char *)__dst, (long long *)v31);
  v39[3] = 0;
  (*(void (**)(uint64_t, void **, void *))(*(void *)v15 + 16))(v15, __dst, v39);
  sub_1000DBADC(v39);
  if (v30 < 0) {
    operator delete(__p);
  }
  if (v28 < 0) {
    operator delete(v27);
  }
  if (v26 < 0) {
    operator delete(v25);
  }
  if (v24 < 0) {
    operator delete(v23);
  }
  if (v22 < 0) {
    operator delete(__dst[0]);
  }
  if (SBYTE7(v36) < 0) {
    operator delete((void *)v35);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete((void *)v32);
  }
  if (SHIBYTE(v31[8]) < 0) {
    operator delete(v31[6]);
  }
  if (SHIBYTE(v31[5]) < 0) {
    operator delete(v31[3]);
  }
  if ((SHIBYTE(v31[2]) & 0x80000000) == 0)
  {
LABEL_31:
    if (v16) {
      return;
    }
    goto LABEL_32;
  }
  operator delete(v31[0]);
  if (v16) {
    return;
  }
LABEL_32:
  sub_10004D2C8(v14);
}

void sub_1004B3750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  sub_1000DBADC((void *)(v29 - 120));
  sub_1001278A0((uint64_t)&a10);
  sub_1001278A0((uint64_t)&a27);
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_1004B37A0(void *a1)
{
  uint64_t v2 = a1;
  (*(void (**)(void))(*(void *)*a1 + 16))(*a1);
  return sub_1000E3958((uint64_t *)&v2);
}

void sub_1004B37F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000E3958((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1004B380C(void *a1)
{
  uint64_t v2 = a1;
  (*(void (**)(void))(*(void *)*a1 + 16))(*a1);
  return sub_1000E3958((uint64_t *)&v2);
}

void sub_1004B3864(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000E3958((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1004B3878(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 360));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v4;
  unint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
  if (!v10)
  {
LABEL_7:
    unsigned int v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "TelephonyAnalytics service not found!", buf, 2u);
    }
    goto LABEL_32;
  }
LABEL_11:
  xpc_object_t v26 = 0;
  xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v14 = v13;
  if (v13)
  {
    xpc_object_t v26 = v13;
  }
  else
  {
    xpc_object_t v14 = xpc_null_create();
    xpc_object_t v26 = v14;
    if (!v14)
    {
      xpc_object_t v15 = xpc_null_create();
      xpc_object_t v14 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v14) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v15 = xpc_null_create();
LABEL_18:
    xpc_object_t v26 = v15;
    goto LABEL_19;
  }
  xpc_retain(v14);
LABEL_19:
  xpc_release(v14);
  unsigned int v16 = *(_DWORD *)(a1 + 256) - 1;
  if (v16 > 2) {
    uint64_t v17 = "CCStwSuspendReasonUnknown";
  }
  else {
    uint64_t v17 = off_1019D4558[v16];
  }
  xpc_object_t v24 = xpc_string_create(v17);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  *(void *)std::string buf = &v26;
  CFMutableDictionaryRef v23 = (std::__shared_weak_count *)"reason";
  sub_100035E70((uint64_t)buf, &v24, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v24);
  xpc_object_t v24 = 0;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 360));
  int64_t v18 = ((***(uint64_t (****)(void))buf)(*(void *)buf) - *(void *)(a1 + 232)) / 1000000;
  if (v23) {
    sub_10004D2C8(v23);
  }
  xpc_object_t v20 = xpc_int64_create(v18);
  if (!v20) {
    xpc_object_t v20 = xpc_null_create();
  }
  *(void *)std::string buf = &v26;
  CFMutableDictionaryRef v23 = (std::__shared_weak_count *)"duration";
  sub_100035E70((uint64_t)buf, &v20, &v21);
  xpc_release(v21);
  xpc_object_t v21 = 0;
  xpc_release(v20);
  xpc_object_t v19 = v26;
  xpc_object_t v20 = 0;
  if (v26) {
    xpc_retain(v26);
  }
  else {
    xpc_object_t v19 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v10 + 16))(v10, "metricCCStwSuspendState", &v19);
  xpc_release(v19);
  xpc_object_t v19 = 0;
  xpc_release(v26);
LABEL_32:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_1004B3BB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v16 - 56));
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(a1);
}

void StewieController::submitStewieRequestMetric(uint64_t a1, int a2, int a3, BOOL a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)(a1 + 1928));
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    unsigned int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v11;
  char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (v15)
  {
    uint64_t v17 = v15[3];
    uint64_t v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      if (!v17) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  uint64_t v16 = 0;
  char v18 = 1;
  if (!v17)
  {
LABEL_7:
    xpc_object_t v19 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "TelephonyAnalytics service not found!", buf, 2u);
    }
    goto LABEL_71;
  }
LABEL_11:
  xpc_object_t v60 = 0;
  xpc_object_t v20 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v21 = v20;
  if (v20)
  {
    xpc_object_t v60 = v20;
  }
  else
  {
    xpc_object_t v21 = xpc_null_create();
    xpc_object_t v60 = v21;
    if (!v21)
    {
      xpc_object_t v22 = xpc_null_create();
      xpc_object_t v21 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v21) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v22 = xpc_null_create();
LABEL_18:
    xpc_object_t v60 = v22;
    goto LABEL_19;
  }
  xpc_retain(v21);
LABEL_19:
  xpc_release(v21);
  xpc_object_t v58 = xpc_BOOL_create(a4);
  if (!v58) {
    xpc_object_t v58 = xpc_null_create();
  }
  *(void *)std::string buf = &v60;
  *(void *)&uint8_t buf[8] = "result";
  sub_100035E70((uint64_t)buf, &v58, &v59);
  xpc_release(v59);
  xpc_object_t v59 = 0;
  xpc_release(v58);
  xpc_object_t v58 = 0;
  if ((a2 - 1) > 9) {
    CFMutableDictionaryRef v23 = "CCStwRequestReasonUnknown";
  }
  else {
    CFMutableDictionaryRef v23 = off_1019D4570[a2 - 1];
  }
  sub_100058DB0(&v53, v23);
  if (a3) {
    xpc_object_t v24 = "TryOut";
  }
  else {
    xpc_object_t v24 = "";
  }
  if (a3) {
    std::string::size_type v25 = 6;
  }
  else {
    std::string::size_type v25 = 0;
  }
  xpc_object_t v26 = std::string::append(&v53, v24, v25);
  long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  int64_t v55 = v26->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string buf = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  if (v55 >= 0) {
    char v28 = buf;
  }
  else {
    char v28 = *(uint8_t **)buf;
  }
  xpc_object_t v56 = xpc_string_create((const char *)v28);
  if (!v56) {
    xpc_object_t v56 = xpc_null_create();
  }
  v52[0] = &v60;
  v52[1] = "requestReason";
  sub_100035E70((uint64_t)v52, &v56, &v57);
  xpc_release(v57);
  xpc_object_t v57 = 0;
  xpc_release(v56);
  xpc_object_t v56 = 0;
  if (SHIBYTE(v55) < 0) {
    operator delete(*(void **)buf);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  xpc_object_t v50 = xpc_BOOL_create(*(unsigned char *)(a1 + 2024) == 1);
  if (!v50) {
    xpc_object_t v50 = xpc_null_create();
  }
  *(void *)std::string buf = &v60;
  *(void *)&uint8_t buf[8] = "preconditionsSatisfied";
  sub_100035E70((uint64_t)buf, &v50, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v50);
  xpc_object_t v50 = 0;
  unsigned int v29 = *(unsigned __int8 *)(a1 + 2025) - 1;
  if (v29 > 9) {
    char v30 = "CCStwPreconditionsStatusReasonUnspecified";
  }
  else {
    char v30 = off_1019D45C0[(char)v29];
  }
  xpc_object_t v48 = xpc_string_create(v30);
  if (!v48) {
    xpc_object_t v48 = xpc_null_create();
  }
  *(void *)std::string buf = &v60;
  *(void *)&uint8_t buf[8] = "preconditionsStatusReason";
  sub_100035E70((uint64_t)buf, &v48, &v49);
  xpc_release(v49);
  xpc_object_t v49 = 0;
  xpc_release(v48);
  xpc_object_t v48 = 0;
  uint64_t v31 = *(void *)(a1 + 2280);
  if (v31) {
    int64_t v32 = *(void *)(v31 + 16);
  }
  else {
    int64_t v32 = 0;
  }
  xpc_object_t v46 = xpc_int64_create(v32);
  if (!v46) {
    xpc_object_t v46 = xpc_null_create();
  }
  *(void *)std::string buf = &v60;
  *(void *)&uint8_t buf[8] = "hasActiveSim";
  sub_100035E70((uint64_t)buf, &v46, &v47);
  xpc_release(v47);
  xpc_object_t v47 = 0;
  xpc_release(v46);
  xpc_object_t v46 = 0;
  uint64_t v33 = *(void *)(a1 + 2232);
  if (v33)
  {
    char v34 = (*(uint64_t (**)(uint64_t))(*(void *)v33 + 64))(v33);
    xpc_object_t v44 = xpc_BOOL_create(v34);
    if (!v44) {
      xpc_object_t v44 = xpc_null_create();
    }
    *(void *)std::string buf = &v60;
    *(void *)&uint8_t buf[8] = "didUseTryOutAtLeastOnce";
    sub_100035E70((uint64_t)buf, &v44, &v45);
    xpc_release(v45);
    xpc_object_t v45 = 0;
    xpc_release(v44);
    xpc_object_t v44 = 0;
  }
  unint64_t v35 = *(char *)(a1 + 1969);
  if (v35 > 2) {
    long long v36 = "CCStwCellServiceStatusUnknown";
  }
  else {
    long long v36 = off_1019D4610[v35];
  }
  xpc_object_t v42 = xpc_string_create(v36);
  if (!v42) {
    xpc_object_t v42 = xpc_null_create();
  }
  *(void *)std::string buf = &v60;
  *(void *)&uint8_t buf[8] = "cellServiceStatus";
  sub_100035E70((uint64_t)buf, &v42, &v43);
  xpc_release(v43);
  xpc_object_t v43 = 0;
  xpc_release(v42);
  xpc_object_t v42 = 0;
  if (*(unsigned char *)(a1 + 2800))
  {
    Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 1928));
    uint64_t v37 = (***(uint64_t (****)(void))buf)(*(void *)buf);
    if (!*(unsigned char *)(a1 + 2800)) {
      sub_10016C840();
    }
    int64_t v38 = (v37 - *(void *)(a1 + 2792)) / 1000000;
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    xpc_object_t v40 = xpc_int64_create(v38);
    if (!v40) {
      xpc_object_t v40 = xpc_null_create();
    }
    *(void *)std::string buf = &v60;
    *(void *)&uint8_t buf[8] = "timeSinceLastRequest";
    sub_100035E70((uint64_t)buf, &v40, &v41);
    xpc_release(v41);
    xpc_object_t v41 = 0;
    xpc_release(v40);
    xpc_object_t v40 = 0;
  }
  xpc_object_t v39 = v60;
  if (v60) {
    xpc_retain(v60);
  }
  else {
    xpc_object_t v39 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v17 + 16))(v17, "metricCCStwRequest", &v39);
  xpc_release(v39);
  xpc_object_t v39 = 0;
  xpc_release(v60);
LABEL_71:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
}

void sub_1004B42A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31)
{
  xpc_release(*(xpc_object_t *)(v33 - 88));
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v31);
  }
  _Unwind_Resume(a1);
}

void StewieDataController::submitCPSummaryMetric(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    unsigned int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_7:
    unsigned int v14 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "TelephonyAnalytics service not found!", buf, 2u);
    }
    goto LABEL_39;
  }
LABEL_11:
  xpc_object_t v35 = 0;
  xpc_object_t v15 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v16 = v15;
  if (v15)
  {
    xpc_object_t v35 = v15;
  }
  else
  {
    xpc_object_t v16 = xpc_null_create();
    xpc_object_t v35 = v16;
    if (!v16)
    {
      xpc_object_t v17 = xpc_null_create();
      xpc_object_t v16 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v16) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v17 = xpc_null_create();
LABEL_18:
    xpc_object_t v35 = v17;
    goto LABEL_19;
  }
  xpc_retain(v16);
LABEL_19:
  xpc_release(v16);
  xpc_object_t v33 = xpc_int64_create(*(unsigned __int8 *)(a2 + 30));
  if (!v33) {
    xpc_object_t v33 = xpc_null_create();
  }
  *(void *)std::string buf = &v35;
  char v32 = "pendingIMessageLiteTotalCount";
  sub_100035E70((uint64_t)buf, &v33, &v34);
  xpc_release(v34);
  xpc_object_t v34 = 0;
  xpc_release(v33);
  xpc_object_t v33 = 0;
  xpc_object_t v29 = xpc_int64_create(*(unsigned __int8 *)(a2 + 31));
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  *(void *)std::string buf = &v35;
  char v32 = "pendingSatSmsTotalCount";
  sub_100035E70((uint64_t)buf, &v29, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
  unint64_t v18 = *(char *)(a2 + 56);
  if (v18 > 5) {
    xpc_object_t v19 = "CCStwSatSmsAuthStatusUnknown";
  }
  else {
    xpc_object_t v19 = off_1019D4628[v18];
  }
  xpc_object_t v27 = xpc_string_create(v19);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  *(void *)std::string buf = &v35;
  char v32 = "authStatusForSimConfig0";
  sub_100035E70((uint64_t)buf, &v27, &v28);
  xpc_release(v28);
  xpc_object_t v28 = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  unint64_t v20 = *(char *)(a2 + 57);
  if (v20 > 5) {
    xpc_object_t v21 = "CCStwSatSmsAuthStatusUnknown";
  }
  else {
    xpc_object_t v21 = off_1019D4628[v20];
  }
  xpc_object_t v25 = xpc_string_create(v21);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  *(void *)std::string buf = &v35;
  char v32 = "authStatusForSimConfig1";
  sub_100035E70((uint64_t)buf, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_object_t v23 = xpc_int64_create((uint64_t)(*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 4);
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  *(void *)std::string buf = &v35;
  char v32 = "numThreadsWithPendingIMessageLite";
  sub_100035E70((uint64_t)buf, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
  xpc_object_t v22 = v35;
  xpc_object_t v23 = 0;
  if (v35) {
    xpc_retain(v35);
  }
  else {
    xpc_object_t v22 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v12 + 16))(v12, "metricCCStwCPSummary", &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v35);
LABEL_39:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1004B4780(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 72));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(a1);
}

void StewieDataController::submitMessageIncomingMetric(uint64_t a1, int a2, unsigned int a3, int a4, BOOL a5, BOOL a6, unsigned int *a7)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  xpc_object_t v15 = ServiceMap;
  if (v16 < 0)
  {
    xpc_object_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v16;
  unint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
  if (v20)
  {
    uint64_t v21 = v20[3];
    xpc_object_t v22 = (std::__shared_weak_count *)v20[4];
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v15);
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v22);
      char v23 = 0;
      if (!v21) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  std::mutex::unlock(v15);
  xpc_object_t v22 = 0;
  char v23 = 1;
  if (!v21)
  {
LABEL_7:
    xpc_object_t v24 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "TelephonyAnalytics service not found!", buf, 2u);
    }
    goto LABEL_47;
  }
LABEL_11:
  v50[0] = 0;
  xpc_object_t v25 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v26 = v25;
  if (v25)
  {
    v50[0] = v25;
  }
  else
  {
    xpc_object_t v26 = xpc_null_create();
    v50[0] = v26;
    if (!v26)
    {
      xpc_object_t v27 = xpc_null_create();
      xpc_object_t v26 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v26) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v27 = xpc_null_create();
LABEL_18:
    v50[0] = v27;
    goto LABEL_19;
  }
  xpc_retain(v26);
LABEL_19:
  xpc_release(v26);
  xpc_object_t v28 = sub_1004B4DD8(a2);
  xpc_object_t v48 = xpc_string_create(v28);
  if (!v48) {
    xpc_object_t v48 = xpc_null_create();
  }
  *(void *)std::string buf = v50;
  xpc_object_t v47 = "messageType";
  sub_100035E70((uint64_t)buf, &v48, &v49);
  xpc_release(v49);
  xpc_object_t v49 = 0;
  xpc_release(v48);
  xpc_object_t v48 = 0;
  xpc_object_t v44 = xpc_int64_create(a3);
  if (!v44) {
    xpc_object_t v44 = xpc_null_create();
  }
  *(void *)std::string buf = v50;
  xpc_object_t v47 = "messageSize";
  sub_100035E70((uint64_t)buf, &v44, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v44);
  xpc_object_t v44 = 0;
  xpc_object_t v29 = "CCStwTransportTypeUnknown";
  if (a4 == 1) {
    xpc_object_t v29 = "CCStwTransportTypeBB";
  }
  if (a4 == 2) {
    char v30 = "CCStwTransportTypeIDS";
  }
  else {
    char v30 = v29;
  }
  xpc_object_t v42 = xpc_string_create(v30);
  if (!v42) {
    xpc_object_t v42 = xpc_null_create();
  }
  *(void *)std::string buf = v50;
  xpc_object_t v47 = "transportType";
  sub_100035E70((uint64_t)buf, &v42, &v43);
  xpc_release(v43);
  xpc_object_t v43 = 0;
  xpc_release(v42);
  xpc_object_t v42 = 0;
  xpc_object_t v40 = xpc_BOOL_create(a5);
  if (!v40) {
    xpc_object_t v40 = xpc_null_create();
  }
  *(void *)std::string buf = v50;
  xpc_object_t v47 = "parsedSuccessfully";
  sub_100035E70((uint64_t)buf, &v40, &v41);
  xpc_release(v41);
  xpc_object_t v41 = 0;
  xpc_release(v40);
  xpc_object_t v40 = 0;
  xpc_object_t v38 = xpc_BOOL_create(a6);
  if (!v38) {
    xpc_object_t v38 = xpc_null_create();
  }
  *(void *)std::string buf = v50;
  xpc_object_t v47 = "requiresDecompression";
  sub_100035E70((uint64_t)buf, &v38, &v39);
  xpc_release(v39);
  xpc_object_t v39 = 0;
  xpc_release(v38);
  xpc_object_t v38 = 0;
  if (a6)
  {
    xpc_object_t v36 = xpc_int64_create(0);
    if (!v36) {
      xpc_object_t v36 = xpc_null_create();
    }
    *(void *)std::string buf = v50;
    xpc_object_t v47 = "assetVersion";
    sub_100035E70((uint64_t)buf, &v36, &v37);
    xpc_release(v37);
    xpc_object_t v37 = 0;
    xpc_release(v36);
    xpc_object_t v36 = 0;
    if (*((unsigned char *)a7 + 16))
    {
      xpc_object_t v34 = xpc_int64_create(*a7);
      if (!v34) {
        xpc_object_t v34 = xpc_null_create();
      }
      *(void *)std::string buf = v50;
      xpc_object_t v47 = "bytesSavedWithCompression";
      sub_100035E70((uint64_t)buf, &v34, &v35);
      xpc_release(v35);
      xpc_object_t v35 = 0;
      xpc_release(v34);
      xpc_object_t v34 = 0;
      xpc_object_t v32 = xpc_int64_create(a7[2]);
      if (!v32) {
        xpc_object_t v32 = xpc_null_create();
      }
      *(void *)std::string buf = v50;
      xpc_object_t v47 = "codecId";
      sub_100035E70((uint64_t)buf, &v32, &v33);
      xpc_release(v33);
      xpc_object_t v33 = 0;
      xpc_release(v32);
      xpc_object_t v32 = 0;
    }
  }
  xpc_object_t v31 = v50[0];
  if (v50[0]) {
    xpc_retain(v50[0]);
  }
  else {
    xpc_object_t v31 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v21 + 16))(v21, "metricCCStwMessageIncoming", &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_release(v50[0]);
LABEL_47:
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v22);
  }
}

void sub_1004B4D54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 96));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(a1);
}

const char *sub_1004B4DD8(int a1)
{
  if ((a1 - 1) > 0x12) {
    return "CCStwMessageTypeUnknown";
  }
  else {
    return off_1019D4658[a1 - 1];
  }
}

void StewieDataController::submitMessageOutgoingMetric(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  unsigned int v9 = ServiceMap;
  if (v10 < 0)
  {
    char v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v10;
  unsigned int v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (v14)
  {
    uint64_t v16 = v14[3];
    xpc_object_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      if (!v16) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  xpc_object_t v15 = 0;
  char v17 = 1;
  if (!v16)
  {
LABEL_7:
    uint64_t v18 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "TelephonyAnalytics service not found!", buf, 2u);
    }
    goto LABEL_69;
  }
LABEL_11:
  xpc_object_t v59 = 0;
  xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v20 = v19;
  if (v19)
  {
    xpc_object_t v59 = v19;
  }
  else
  {
    xpc_object_t v20 = xpc_null_create();
    xpc_object_t v59 = v20;
    if (!v20)
    {
      xpc_object_t v21 = xpc_null_create();
      xpc_object_t v20 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v20) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v21 = xpc_null_create();
LABEL_18:
    xpc_object_t v59 = v21;
    goto LABEL_19;
  }
  xpc_retain(v20);
LABEL_19:
  xpc_release(v20);
  if (a4 >= 2)
  {
    if (a4 == 3)
    {
      xpc_object_t v53 = xpc_string_create("Canceled");
      if (!v53) {
        xpc_object_t v53 = xpc_null_create();
      }
      *(void *)std::string buf = &v59;
      xpc_object_t v56 = (std::__shared_weak_count *)"messageSendResult";
      sub_100035E70((uint64_t)buf, &v53, &v54);
      xpc_release(v54);
      xpc_object_t v54 = 0;
      xpc_release(v53);
      xpc_object_t v53 = 0;
    }
    else if (a4 == 2)
    {
      xpc_object_t v57 = xpc_string_create("Sent");
      if (!v57) {
        xpc_object_t v57 = xpc_null_create();
      }
      *(void *)std::string buf = &v59;
      xpc_object_t v56 = (std::__shared_weak_count *)"messageSendResult";
      sub_100035E70((uint64_t)buf, &v57, &v58);
      xpc_release(v58);
      xpc_object_t v58 = 0;
      xpc_release(v57);
      xpc_object_t v57 = 0;
    }
    uint64_t v22 = *(void *)(a2 + 8) + *(void *)(**(void **)(a2 + 8) - 48);
    int v23 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 8))(v22);
    xpc_object_t v24 = sub_1004B4DD8(v23);
    xpc_object_t v51 = xpc_string_create(v24);
    if (!v51) {
      xpc_object_t v51 = xpc_null_create();
    }
    *(void *)std::string buf = &v59;
    xpc_object_t v56 = (std::__shared_weak_count *)"messageType";
    sub_100035E70((uint64_t)buf, &v51, &v52);
    xpc_release(v52);
    xpc_object_t v52 = 0;
    xpc_release(v51);
    xpc_object_t v51 = 0;
    xpc_object_t v49 = xpc_int64_create(*(unsigned int *)(a2 + 48));
    if (!v49) {
      xpc_object_t v49 = xpc_null_create();
    }
    *(void *)std::string buf = &v59;
    xpc_object_t v56 = (std::__shared_weak_count *)"messageSize";
    sub_100035E70((uint64_t)buf, &v49, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v49);
    xpc_object_t v49 = 0;
    xpc_object_t v25 = "CCStwTransportTypeUnknown";
    if (a3 == 1) {
      xpc_object_t v25 = "CCStwTransportTypeBB";
    }
    if (a3 == 2) {
      xpc_object_t v26 = "CCStwTransportTypeIDS";
    }
    else {
      xpc_object_t v26 = v25;
    }
    xpc_object_t v47 = xpc_string_create(v26);
    if (!v47) {
      xpc_object_t v47 = xpc_null_create();
    }
    *(void *)std::string buf = &v59;
    xpc_object_t v56 = (std::__shared_weak_count *)"transportType";
    sub_100035E70((uint64_t)buf, &v47, &v48);
    xpc_release(v48);
    xpc_object_t v48 = 0;
    xpc_release(v47);
    xpc_object_t v47 = 0;
    xpc_object_t v45 = xpc_int64_create(*(unsigned int *)(a2 + 88));
    if (!v45) {
      xpc_object_t v45 = xpc_null_create();
    }
    *(void *)std::string buf = &v59;
    xpc_object_t v56 = (std::__shared_weak_count *)"numSendAttemptsOverBB";
    sub_100035E70((uint64_t)buf, &v45, &v46);
    xpc_release(v46);
    xpc_object_t v46 = 0;
    xpc_release(v45);
    xpc_object_t v45 = 0;
    xpc_object_t v43 = xpc_int64_create(*(unsigned int *)(a2 + 92));
    if (!v43) {
      xpc_object_t v43 = xpc_null_create();
    }
    *(void *)std::string buf = &v59;
    xpc_object_t v56 = (std::__shared_weak_count *)"numSuspendedSendAttemptsOverBB";
    sub_100035E70((uint64_t)buf, &v43, &v44);
    xpc_release(v44);
    xpc_object_t v44 = 0;
    xpc_release(v43);
    xpc_object_t v43 = 0;
    xpc_object_t v41 = xpc_int64_create(*(unsigned int *)(a2 + 96));
    if (!v41) {
      xpc_object_t v41 = xpc_null_create();
    }
    *(void *)std::string buf = &v59;
    xpc_object_t v56 = (std::__shared_weak_count *)"numSendAttemptsOverIDS";
    sub_100035E70((uint64_t)buf, &v41, &v42);
    xpc_release(v42);
    xpc_object_t v42 = 0;
    xpc_release(v41);
    xpc_object_t v41 = 0;
    if (*(unsigned char *)(a2 + 112))
    {
      Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 64));
      uint64_t v27 = (***(uint64_t (****)(void))buf)(*(void *)buf);
      if (!*(unsigned char *)(a2 + 112)) {
        sub_10016C840();
      }
      int64_t v28 = (v27 - *(void *)(a2 + 104)) / 1000000;
      if (v56) {
        sub_10004D2C8(v56);
      }
      xpc_object_t v39 = xpc_int64_create(v28);
      if (!v39) {
        xpc_object_t v39 = xpc_null_create();
      }
      *(void *)std::string buf = &v59;
      xpc_object_t v56 = (std::__shared_weak_count *)"messageSendLatency";
      sub_100035E70((uint64_t)buf, &v39, &v40);
      xpc_release(v40);
      xpc_object_t v40 = 0;
      xpc_release(v39);
      xpc_object_t v39 = 0;
    }
    xpc_object_t v37 = xpc_BOOL_create(*(unsigned char *)(a2 + 120));
    if (!v37) {
      xpc_object_t v37 = xpc_null_create();
    }
    *(void *)std::string buf = &v59;
    xpc_object_t v56 = (std::__shared_weak_count *)"compressionAttempted";
    sub_100035E70((uint64_t)buf, &v37, &v38);
    xpc_release(v38);
    xpc_object_t v38 = 0;
    xpc_release(v37);
    xpc_object_t v37 = 0;
    if (*(unsigned char *)(a2 + 120))
    {
      xpc_object_t v35 = xpc_int64_create(0);
      if (!v35) {
        xpc_object_t v35 = xpc_null_create();
      }
      *(void *)std::string buf = &v59;
      xpc_object_t v56 = (std::__shared_weak_count *)"assetVersion";
      sub_100035E70((uint64_t)buf, &v35, &v36);
      xpc_release(v36);
      xpc_object_t v36 = 0;
      xpc_release(v35);
      xpc_object_t v35 = 0;
      if (*(unsigned char *)(a2 + 144))
      {
        xpc_object_t v33 = xpc_int64_create(*(unsigned int *)(a2 + 128));
        if (!v33) {
          xpc_object_t v33 = xpc_null_create();
        }
        *(void *)std::string buf = &v59;
        xpc_object_t v56 = (std::__shared_weak_count *)"bytesSavedWithCompression";
        sub_100035E70((uint64_t)buf, &v33, &v34);
        xpc_release(v34);
        xpc_object_t v34 = 0;
        xpc_release(v33);
        xpc_object_t v33 = 0;
        xpc_object_t v31 = xpc_int64_create(*(unsigned int *)(a2 + 136));
        if (!v31) {
          xpc_object_t v31 = xpc_null_create();
        }
        *(void *)std::string buf = &v59;
        xpc_object_t v56 = (std::__shared_weak_count *)"codecId";
        sub_100035E70((uint64_t)buf, &v31, &v32);
        xpc_release(v32);
        xpc_object_t v32 = 0;
        xpc_release(v31);
        xpc_object_t v31 = 0;
      }
      else
      {
        *(void *)std::string buf = &v59;
        xpc_object_t v56 = (std::__shared_weak_count *)"bytesSavedWithCompression";
        sub_10021ACC8((uint64_t)buf, &v30);
        xpc_release(v30);
        xpc_object_t v30 = 0;
      }
    }
    xpc_object_t v29 = v59;
    if (v59) {
      xpc_retain(v59);
    }
    else {
      xpc_object_t v29 = xpc_null_create();
    }
    (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v16 + 16))(v16, "metricCCStwMessageOutgoing", &v29);
    xpc_release(v29);
    xpc_object_t v29 = 0;
  }
  xpc_release(v59);
LABEL_69:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_1004B55F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  xpc_release(*(xpc_object_t *)(v11 - 88));
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void StewieDataController::submitStewieExitMetric(uint64_t a1, int a2, unsigned int a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  unsigned int v7 = ServiceMap;
  if (v8 < 0)
  {
    unsigned int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unsigned int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unsigned int v13 = 0;
  char v15 = 1;
  if (!v14)
  {
LABEL_7:
    uint64_t v16 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "TelephonyAnalytics service not found!", buf, 2u);
    }
    goto LABEL_101;
  }
LABEL_11:
  xpc_object_t v88 = 0;
  xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v18 = v17;
  if (v17)
  {
    xpc_object_t v88 = v17;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
    xpc_object_t v88 = v18;
    if (!v18)
    {
      xpc_object_t v19 = xpc_null_create();
      xpc_object_t v18 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v18) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v19 = xpc_null_create();
LABEL_18:
    xpc_object_t v88 = v19;
    goto LABEL_19;
  }
  xpc_retain(v18);
LABEL_19:
  xpc_release(v18);
  Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 64));
  uint64_t v20 = (***(uint64_t (****)(void))buf)(*(void *)buf);
  if (v87) {
    sub_10004D2C8(v87);
  }
  xpc_object_t v84 = xpc_BOOL_create(*(unsigned char *)(a1 + 552));
  if (!v84) {
    xpc_object_t v84 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"didSyncAtLeastOnce";
  sub_100035E70((uint64_t)buf, &v84, &v85);
  xpc_release(v85);
  xpc_object_t v85 = 0;
  xpc_release(v84);
  xpc_object_t v84 = 0;
  xpc_object_t v82 = xpc_BOOL_create(*(unsigned char *)(a1 + 553));
  if (!v82) {
    xpc_object_t v82 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"didRegisterAtLeastOnce";
  sub_100035E70((uint64_t)buf, &v82, &v83);
  xpc_release(v83);
  xpc_object_t v83 = 0;
  xpc_release(v82);
  xpc_object_t v82 = 0;
  if (*(unsigned char *)(a1 + 553))
  {
    xpc_object_t v80 = xpc_int64_create((*(void *)(a1 + 560) - *(void *)(a1 + 544)) / 1000000);
    if (!v80) {
      xpc_object_t v80 = xpc_null_create();
    }
    *(void *)std::string buf = &v88;
    uint64_t v87 = (std::__shared_weak_count *)"initialRegistrationLatency";
    sub_100035E70((uint64_t)buf, &v80, &v81);
    xpc_release(v81);
    xpc_object_t v81 = 0;
    xpc_release(v80);
    xpc_object_t v80 = 0;
  }
  xpc_object_t v78 = xpc_int64_create(*(unsigned int *)(a1 + 568));
  if (!v78) {
    xpc_object_t v78 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"numMessagesSentOverBB";
  sub_100035E70((uint64_t)buf, &v78, &v79);
  xpc_release(v79);
  xpc_object_t v79 = 0;
  xpc_release(v78);
  xpc_object_t v78 = 0;
  xpc_object_t v76 = xpc_int64_create(*(unsigned int *)(a1 + 572));
  if (!v76) {
    xpc_object_t v76 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"numMessagesSentOverIDS";
  sub_100035E70((uint64_t)buf, &v76, &v77);
  xpc_release(v77);
  xpc_object_t v77 = 0;
  xpc_release(v76);
  xpc_object_t v76 = 0;
  xpc_object_t v74 = xpc_int64_create(*(unsigned int *)(a1 + 576));
  if (!v74) {
    xpc_object_t v74 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"numMessageSendAttemptsOverBB";
  sub_100035E70((uint64_t)buf, &v74, &v75);
  xpc_release(v75);
  xpc_object_t v75 = 0;
  xpc_release(v74);
  xpc_object_t v74 = 0;
  xpc_object_t v72 = xpc_int64_create(*(unsigned int *)(a1 + 580));
  if (!v72) {
    xpc_object_t v72 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"numSuspendedSendAttemptsOverBB";
  sub_100035E70((uint64_t)buf, &v72, &v73);
  xpc_release(v73);
  xpc_object_t v73 = 0;
  xpc_release(v72);
  xpc_object_t v72 = 0;
  xpc_object_t v70 = xpc_int64_create(*(unsigned int *)(a1 + 584));
  if (!v70) {
    xpc_object_t v70 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"numMessageSendAttemptsOverIDS";
  sub_100035E70((uint64_t)buf, &v70, &v71);
  xpc_release(v71);
  xpc_object_t v71 = 0;
  xpc_release(v70);
  xpc_object_t v70 = 0;
  xpc_object_t v68 = xpc_int64_create(*(unsigned int *)(a1 + 588));
  if (!v68) {
    xpc_object_t v68 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"numUniqueMessageSendAttemptsOverBB";
  sub_100035E70((uint64_t)buf, &v68, &v69);
  xpc_release(v69);
  xpc_object_t v69 = 0;
  xpc_release(v68);
  xpc_object_t v68 = 0;
  xpc_object_t v66 = xpc_int64_create(*(unsigned int *)(a1 + 592));
  if (!v66) {
    xpc_object_t v66 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"numUniqueMessageSendAttemptsOverIDS";
  sub_100035E70((uint64_t)buf, &v66, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v66);
  xpc_object_t v66 = 0;
  xpc_object_t v64 = xpc_int64_create(*(unsigned int *)(a1 + 596));
  if (!v64) {
    xpc_object_t v64 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"totalNumUniqueMessageSendAttempts";
  sub_100035E70((uint64_t)buf, &v64, &v65);
  xpc_release(v65);
  xpc_object_t v65 = 0;
  xpc_release(v64);
  xpc_object_t v64 = 0;
  xpc_object_t v62 = xpc_int64_create(*(unsigned int *)(a1 + 600));
  if (!v62) {
    xpc_object_t v62 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"totalBytesSent";
  sub_100035E70((uint64_t)buf, &v62, &v63);
  xpc_release(v63);
  xpc_object_t v63 = 0;
  xpc_release(v62);
  xpc_object_t v62 = 0;
  xpc_object_t v60 = xpc_int64_create(*(unsigned int *)(a1 + 604));
  if (!v60) {
    xpc_object_t v60 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"numMessagesReceivedOverBB";
  sub_100035E70((uint64_t)buf, &v60, &v61);
  xpc_release(v61);
  xpc_object_t v61 = 0;
  xpc_release(v60);
  xpc_object_t v60 = 0;
  xpc_object_t v58 = xpc_int64_create(*(unsigned int *)(a1 + 608));
  if (!v58) {
    xpc_object_t v58 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"numMessagesReceivedOverIDS";
  sub_100035E70((uint64_t)buf, &v58, &v59);
  xpc_release(v59);
  xpc_object_t v59 = 0;
  xpc_release(v58);
  xpc_object_t v58 = 0;
  xpc_object_t v56 = xpc_int64_create(*(unsigned int *)(a1 + 612));
  if (!v56) {
    xpc_object_t v56 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"totalBytesReceived";
  sub_100035E70((uint64_t)buf, &v56, &v57);
  xpc_release(v57);
  xpc_object_t v57 = 0;
  xpc_release(v56);
  xpc_object_t v56 = 0;
  if ((a2 - 1) > 0xF) {
    xpc_object_t v21 = "CCStwExitReasonUnknown";
  }
  else {
    xpc_object_t v21 = off_1019D46F0[a2 - 1];
  }
  xpc_object_t v54 = xpc_string_create(v21);
  if (!v54) {
    xpc_object_t v54 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"reason";
  sub_100035E70((uint64_t)buf, &v54, &v55);
  xpc_release(v55);
  xpc_object_t v55 = 0;
  xpc_release(v54);
  xpc_object_t v54 = 0;
  xpc_object_t v52 = xpc_int64_create((v20 - *(void *)(a1 + 544)) / 1000000);
  if (!v52) {
    xpc_object_t v52 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"totalDuration";
  sub_100035E70((uint64_t)buf, &v52, &v53);
  xpc_release(v53);
  xpc_object_t v53 = 0;
  xpc_release(v52);
  xpc_object_t v52 = 0;
  int64_t v22 = *(void *)(a1 + 640);
  if (*(unsigned char *)(a1 + 302) == 1 && *(unsigned char *)(a1 + 632))
  {
    Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 64));
    uint64_t v23 = (***(uint64_t (****)(void))buf)(*(void *)buf);
    if (!*(unsigned char *)(a1 + 632)) {
      sub_10016C840();
    }
    v22 += (v23 - *(void *)(a1 + 624)) / 1000000;
    if (v87) {
      sub_10004D2C8(v87);
    }
  }
  xpc_object_t v50 = xpc_int64_create(v22);
  if (!v50) {
    xpc_object_t v50 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"durationOnBB";
  sub_100035E70((uint64_t)buf, &v50, &v51);
  xpc_release(v51);
  xpc_object_t v51 = 0;
  xpc_release(v50);
  xpc_object_t v50 = 0;
  if (*(unsigned char *)(a1 + 656))
  {
    xpc_object_t v48 = xpc_int64_create((*(void *)(a1 + 648) - *(void *)(a1 + 544)) / 1000000);
    if (!v48) {
      xpc_object_t v48 = xpc_null_create();
    }
    *(void *)std::string buf = &v88;
    uint64_t v87 = (std::__shared_weak_count *)"durationFromRequestToFirstFwdMessage";
    sub_100035E70((uint64_t)buf, &v48, &v49);
    xpc_release(v49);
    xpc_object_t v49 = 0;
    xpc_release(v48);
    xpc_object_t v48 = 0;
  }
  if (*(unsigned char *)(a1 + 672))
  {
    xpc_object_t v46 = xpc_int64_create((*(void *)(a1 + 664) - *(void *)(a1 + 544)) / 1000000);
    if (!v46) {
      xpc_object_t v46 = xpc_null_create();
    }
    *(void *)std::string buf = &v88;
    uint64_t v87 = (std::__shared_weak_count *)"durationFromRequestToFirstBBActivation";
    sub_100035E70((uint64_t)buf, &v46, &v47);
    xpc_release(v47);
    xpc_object_t v47 = 0;
    xpc_release(v46);
    xpc_object_t v46 = 0;
  }
  xpc_object_t v44 = xpc_uint64_create(a3);
  if (!v44) {
    xpc_object_t v44 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"activeBeforeExitServicesMask";
  sub_100035E70((uint64_t)buf, &v44, &v45);
  xpc_release(v45);
  xpc_object_t v45 = 0;
  xpc_release(v44);
  xpc_object_t v44 = 0;
  xpc_object_t v42 = xpc_uint64_create(*(unsigned __int16 *)(a1 + 416));
  if (!v42) {
    xpc_object_t v42 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"activeAfterExitServicesMask";
  sub_100035E70((uint64_t)buf, &v42, &v43);
  xpc_release(v43);
  xpc_object_t v43 = 0;
  xpc_release(v42);
  xpc_object_t v42 = 0;
  xpc_object_t v40 = xpc_uint64_create(*(unsigned __int16 *)(a1 + 420));
  if (!v40) {
    xpc_object_t v40 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"subscriptionDeterminedServicesMask";
  sub_100035E70((uint64_t)buf, &v40, &v41);
  xpc_release(v41);
  xpc_object_t v41 = 0;
  xpc_release(v40);
  xpc_object_t v40 = 0;
  xpc_object_t v38 = xpc_uint64_create(*(unsigned __int16 *)(a1 + 422));
  if (!v38) {
    xpc_object_t v38 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"subscribedServicesMask";
  sub_100035E70((uint64_t)buf, &v38, &v39);
  xpc_release(v39);
  xpc_object_t v39 = 0;
  xpc_release(v38);
  xpc_object_t v38 = 0;
  xpc_object_t v36 = xpc_uint64_create(*(unsigned __int16 *)(a1 + 616));
  if (!v36) {
    xpc_object_t v36 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"activatedSinceInitialRequestServicesMask";
  sub_100035E70((uint64_t)buf, &v36, &v37);
  xpc_release(v37);
  xpc_object_t v37 = 0;
  xpc_release(v36);
  xpc_object_t v36 = 0;
  uint64_t v24 = (*(_DWORD *)(a1 + 620) - 1);
  if (v24 >= 4) {
    uint64_t v25 = 1;
  }
  else {
    uint64_t v25 = v24 + 2;
  }
  xpc_object_t v34 = xpc_uint64_create(v25);
  if (!v34) {
    xpc_object_t v34 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"maxCongestionStatusSeen";
  sub_100035E70((uint64_t)buf, &v34, &v35);
  xpc_release(v35);
  xpc_object_t v35 = 0;
  xpc_release(v34);
  xpc_object_t v34 = 0;
  uint64_t v26 = (*(_DWORD *)(a1 + 800) - 1);
  if (v26 >= 4) {
    uint64_t v27 = 1;
  }
  else {
    uint64_t v27 = v26 + 2;
  }
  xpc_object_t v32 = xpc_uint64_create(v27);
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"recentCongestionStatus";
  sub_100035E70((uint64_t)buf, &v32, &v33);
  xpc_release(v33);
  xpc_object_t v33 = 0;
  xpc_release(v32);
  xpc_object_t v32 = 0;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  BOOL v28 = sub_10025B63C(a1 + 712, 0) == 1;
  xpc_object_t v30 = xpc_BOOL_create(v28);
  if (!v30) {
    xpc_object_t v30 = xpc_null_create();
  }
  *(void *)std::string buf = &v88;
  uint64_t v87 = (std::__shared_weak_count *)"didUseTryOutAtLeastOnce";
  sub_100035E70((uint64_t)buf, &v30, &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_release(v30);
  xpc_object_t v29 = v88;
  xpc_object_t v30 = 0;
  if (v88) {
    xpc_retain(v88);
  }
  else {
    xpc_object_t v29 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v14 + 16))(v14, "metricCCStwExit", &v29);
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_release(v88);
LABEL_101:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_1004B62F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(*(xpc_object_t *)(v12 - 88));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(a1);
}

void StewieController::setupQueryableMetrics(StewieController *this)
{
  dispatch_assert_queue_V2(*((dispatch_queue_t *)this + 4));
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *((Registry **)this + 241));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v5;
  unsigned int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
  if (!v11)
  {
LABEL_7:
    unsigned int v13 = *((void *)this + 6);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "TelephonyAnalytics service not found!", buf, 2u);
    }
    goto LABEL_35;
  }
LABEL_11:
  sub_10003E168(buf, (void *)this + 2);
  uint64_t v15 = *(void *)buf;
  uint64_t v14 = (std::__shared_weak_count *)v25;
  if (v25)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v14);
  }
  uint64_t v16 = *((void *)this + 4);
  if (v16) {
    dispatch_retain(*((dispatch_object_t *)this + 4));
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_1004B68AC;
  aBlock[3] = &unk_1019D44A8;
  aBlock[4] = this;
  if (v16)
  {
    xpc_object_t v17 = _Block_copy(aBlock);
    xpc_object_t v18 = v17;
    dispatch_object_t v31 = v16;
    *(void *)std::string buf = _NSConcreteStackBlock;
    uint64_t v25 = 1174405120;
    uint64_t v26 = sub_1004B7698;
    uint64_t v27 = &unk_1019D44F8;
    uint64_t v28 = v15;
    xpc_object_t v29 = v14;
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    if (v17) {
      xpc_object_t v19 = _Block_copy(v17);
    }
    else {
      xpc_object_t v19 = 0;
    }
    xpc_object_t v30 = v19;
    (*(void (**)(uint64_t, const char *, uint64_t, dispatch_object_t *, uint8_t *))(*(void *)v11 + 40))(v11, "metricCCStwProvisioning", 1, &v31, buf);
    if (v31) {
      dispatch_release(v31);
    }
    if (v30) {
      _Block_release(v30);
    }
    if (v29) {
      std::__shared_weak_count::__release_weak(v29);
    }
    if (v18) {
      _Block_release(v18);
    }
  }
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  uint64_t v20 = *((void *)this + 254);
  uint64_t v21 = v11;
  int64_t v22 = v10;
  if ((v12 & 1) == 0) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v20 + 208))(v20, &v21);
  if (v22) {
    sub_10004D2C8(v22);
  }
LABEL_35:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_1004B682C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a22) {
    std::__shared_weak_count::__release_weak(a22);
  }
  xpc_object_t v29 = *(NSObject **)(v27 - 72);
  if (v29) {
    dispatch_release(v29);
  }
  if (v25) {
    _Block_release(v25);
  }
  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004B68AC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 32));
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)(v1 + 1928));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v5;
  unsigned int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
  if (!v11)
  {
LABEL_7:
    unsigned int v13 = *(NSObject **)(v1 + 48);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "TelephonyAnalytics service not found!", buf, 2u);
    }
    goto LABEL_44;
  }
LABEL_11:
  xpc_object_t v37 = 0;
  xpc_object_t v14 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v15 = v14;
  if (v14)
  {
    xpc_object_t v37 = v14;
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
    xpc_object_t v37 = v15;
    if (!v15)
    {
      xpc_object_t v16 = xpc_null_create();
      xpc_object_t v15 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v15) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v16 = xpc_null_create();
LABEL_18:
    xpc_object_t v37 = v16;
    goto LABEL_19;
  }
  xpc_retain(v15);
LABEL_19:
  xpc_release(v15);
  xpc_object_t v35 = xpc_BOOL_create(*(unsigned char *)(v1 + 1992));
  if (!v35) {
    xpc_object_t v35 = xpc_null_create();
  }
  *(void *)std::string buf = &v37;
  xpc_object_t v34 = "isProvisioned";
  sub_100035E70((uint64_t)buf, &v35, &v36);
  xpc_release(v36);
  xpc_object_t v36 = 0;
  xpc_release(v35);
  xpc_object_t v35 = 0;
  if (*(unsigned char *)(v1 + 2737))
  {
    xpc_object_t v31 = xpc_BOOL_create(*(unsigned char *)(v1 + 2736));
    if (!v31) {
      xpc_object_t v31 = xpc_null_create();
    }
    *(void *)std::string buf = &v37;
    xpc_object_t v34 = "isSatSmsProvisioned";
    sub_100035E70((uint64_t)buf, &v31, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v31);
    xpc_object_t v31 = 0;
  }
  xpc_object_t v29 = xpc_uint64_create(*(unsigned __int16 *)(v1 + 2324));
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  *(void *)std::string buf = &v37;
  xpc_object_t v34 = "subscriptionDeterminedServicesMask";
  sub_100035E70((uint64_t)buf, &v29, &v30);
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_object_t v27 = xpc_uint64_create(*(unsigned __int16 *)(v1 + 2326));
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  *(void *)std::string buf = &v37;
  xpc_object_t v34 = "subscribedServicesMask";
  sub_100035E70((uint64_t)buf, &v27, &v28);
  xpc_release(v28);
  xpc_object_t v28 = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_object_t v25 = xpc_BOOL_create(*(unsigned char *)(v1 + 2024) == 1);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  *(void *)std::string buf = &v37;
  xpc_object_t v34 = "preconditionsSatisfied";
  sub_100035E70((uint64_t)buf, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  unint64_t v17 = *(char *)(v1 + 2025);
  if (v17 > 0xA) {
    uint64_t v18 = 11;
  }
  else {
    uint64_t v18 = *(void *)&asc_1014AD230[8 * v17];
  }
  xpc_object_t v23 = xpc_uint64_create(v18);
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  *(void *)std::string buf = &v37;
  xpc_object_t v34 = "preconditionsStatusReason";
  sub_100035E70((uint64_t)buf, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
  xpc_object_t v23 = 0;
  uint64_t v19 = *(void *)(v1 + 2232);
  if (v19)
  {
    char v20 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 64))(v19);
    xpc_object_t v21 = xpc_BOOL_create(v20);
    if (!v21) {
      xpc_object_t v21 = xpc_null_create();
    }
    *(void *)std::string buf = &v37;
    xpc_object_t v34 = "didUseTryOutAtLeastOnce";
    sub_100035E70((uint64_t)buf, &v21, &v22);
    xpc_release(v22);
    xpc_object_t v22 = 0;
    xpc_release(v21);
    xpc_object_t v21 = 0;
  }
  *(void *)std::string buf = v37;
  if (v37) {
    xpc_retain(v37);
  }
  else {
    *(void *)std::string buf = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, uint8_t *))(*(void *)v11 + 16))(v11, "metricCCStwProvisioning", buf);
  xpc_release(*(xpc_object_t *)buf);
  *(void *)std::string buf = 0;
  xpc_release(v37);
LABEL_44:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_1004B6D5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,xpc_object_t object)
{
  xpc_release(*(xpc_object_t *)(v23 - 56));
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(a1);
}

void stewie::StewieConnectionAssistant::submitEntryPointMetric(uint64_t a1, const char *a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (*(void *)(a1 + 160))
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (a2[23] >= 0) {
        uint64_t v5 = a2;
      }
      else {
        uint64_t v5 = *(const char **)a2;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Submitting entry point metric for '%s'", (uint8_t *)&buf, 0xCu);
    }
    xpc_object_t v15 = 0;
    xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v7 = v6;
    if (v6)
    {
      xpc_object_t v15 = v6;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v15 = v7;
      if (!v7)
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v7 = 0;
        goto LABEL_19;
      }
    }
    if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v7);
LABEL_20:
      xpc_release(v7);
      if (a2[23] >= 0) {
        uint64_t v10 = a2;
      }
      else {
        uint64_t v10 = *(const char **)a2;
      }
      xpc_object_t v13 = xpc_string_create(v10);
      if (!v13) {
        xpc_object_t v13 = xpc_null_create();
      }
      *(void *)&long long buf = &v15;
      *((void *)&buf + 1) = "entryPoint";
      sub_100035E70((uint64_t)&buf, &v13, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v13);
      uint64_t v11 = *(void *)(a1 + 160);
      xpc_object_t v12 = v15;
      xpc_object_t v13 = 0;
      if (v15) {
        xpc_retain(v15);
      }
      else {
        xpc_object_t v12 = xpc_null_create();
      }
      (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v11 + 16))(v11, "metricCCStwEntryPoint", &v12);
      xpc_release(v12);
      xpc_object_t v12 = 0;
      xpc_release(v15);
      return;
    }
    xpc_object_t v9 = xpc_null_create();
LABEL_19:
    xpc_object_t v15 = v9;
    goto LABEL_20;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    if (a2[23] >= 0) {
      unsigned int v8 = a2;
    }
    else {
      unsigned int v8 = *(const char **)a2;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v8;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to submit entry point metric for '%s', fAnalytics is not set", (uint8_t *)&buf, 0xCu);
  }
}

void sub_1004B704C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, xpc_object_t a12)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void stewie::StewieConnectionAssistant::setupQueryableMetrics(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  sub_10003E168(&v15, (void *)(a1 + 8));
  xpc_object_t v6 = v15;
  uint64_t v5 = (std::__shared_weak_count *)v16;
  if (v16)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v5);
  }
  xpc_object_t v7 = *(NSObject **)(a1 + 24);
  if (v7) {
    dispatch_retain(*(dispatch_object_t *)(a1 + 24));
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 1174405120;
  aBlock[2] = sub_1004B72FC;
  aBlock[3] = &unk_1019D44C8;
  uint64_t v9 = *a2;
  unsigned int v8 = (std::__shared_weak_count *)a2[1];
  aBlock[4] = a1;
  void aBlock[5] = v9;
  xpc_object_t v14 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v7)
  {
    uint64_t v10 = _Block_copy(aBlock);
    uint64_t v11 = v10;
    dispatch_object_t v22 = v7;
    xpc_object_t v15 = _NSConcreteStackBlock;
    uint64_t v16 = 1174405120;
    unint64_t v17 = sub_1004B77C4;
    uint64_t v18 = &unk_1019D4528;
    uint64_t v19 = v6;
    char v20 = v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    if (v10) {
      xpc_object_t v12 = _Block_copy(v10);
    }
    else {
      xpc_object_t v12 = 0;
    }
    xpc_object_t v21 = v12;
    (*(void (**)(uint64_t, const char *, uint64_t, dispatch_object_t *, void ***))(*(void *)v4 + 40))(v4, "metricCCStwOffGridBannerShown", 1, &v22, &v15);
    if (v22) {
      dispatch_release(v22);
    }
    if (v21) {
      _Block_release(v21);
    }
    if (v20) {
      std::__shared_weak_count::__release_weak(v20);
    }
    if (v11) {
      _Block_release(v11);
    }
  }
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
}

void sub_1004B729C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a22) {
    std::__shared_weak_count::__release_weak(a22);
  }
  xpc_object_t v27 = *(NSObject **)(v25 - 72);
  if (v27) {
    dispatch_release(v27);
  }
  if (v24) {
    _Block_release(v24);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  if (v23) {
    std::__shared_weak_count::__release_weak(v23);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004B72FC(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v1 = a1[5];
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 24));
  uint64_t v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Submitting (and resetting) offer metric", buf, 2u);
  }
  xpc_object_t v18 = 0;
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    xpc_object_t v18 = v5;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v18 = v6;
    if (!v6)
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_12;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    goto LABEL_13;
  }
  xpc_object_t v7 = xpc_null_create();
LABEL_12:
  xpc_object_t v18 = v7;
LABEL_13:
  xpc_release(v6);
  xpc_object_t v16 = xpc_uint64_create(*(void *)(v2 + 776));
  if (!v16) {
    xpc_object_t v16 = xpc_null_create();
  }
  *(void *)long long buf = &v18;
  xpc_object_t v15 = "offgridBannerShownLockedCnt";
  sub_100035E70((uint64_t)buf, &v16, &v17);
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_object_t v12 = xpc_uint64_create(*(void *)(v2 + 784));
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  *(void *)long long buf = &v18;
  xpc_object_t v15 = "offgridBannerChosenLockedCnt";
  sub_100035E70((uint64_t)buf, &v12, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_object_t v10 = xpc_uint64_create(*(void *)(v2 + 792));
  if (!v10) {
    xpc_object_t v10 = xpc_null_create();
  }
  *(void *)long long buf = &v18;
  xpc_object_t v15 = "offgridBannerShownUnlockedCnt";
  sub_100035E70((uint64_t)buf, &v10, &v11);
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_release(v10);
  xpc_object_t v10 = 0;
  xpc_object_t v8 = xpc_uint64_create(*(void *)(v2 + 800));
  if (!v8) {
    xpc_object_t v8 = xpc_null_create();
  }
  *(void *)long long buf = &v18;
  xpc_object_t v15 = "offgridBannerChosenUnlockedCnt";
  sub_100035E70((uint64_t)buf, &v8, &v9);
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_release(v8);
  xpc_object_t v8 = 0;
  *(_OWORD *)(v2 + 776) = 0u;
  *(_OWORD *)(v2 + 792) = 0u;
  *(void *)long long buf = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    *(void *)long long buf = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, uint8_t *))(*(void *)v1 + 16))(v1, "metricCCStwOffGridBannerShown", buf);
  xpc_release(*(xpc_object_t *)buf);
  *(void *)long long buf = 0;
  xpc_release(v18);
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_1004B75F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v16 - 40));
  if (v15) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1004B766C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1004B7688(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1004B7698(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    xpc_object_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      xpc_object_t v6 = v5;
      if (a1[4]) {
        sub_10041DE0C(a1 + 6, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1004B7710(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_1004B7724(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  id result = (void *)a2[6];
  if (result) {
    id result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_1004B7770(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_1004B77C4(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    xpc_object_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      xpc_object_t v6 = v5;
      if (a1[4]) {
        sub_10041DE0C(a1 + 6, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1004B783C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_1004B7850(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  id result = (void *)a2[6];
  if (result) {
    id result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_1004B789C(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void RegistrationController::create()
{
  v1[0] = off_1019D49A0;
  v1[3] = v1;
  inactive = dispatch_workloop_create_inactive("RegistrationController");
  sub_100136200((uint64_t)v1, (uint64_t)inactive);
  dispatch_activate(inactive);
  sub_1001362D0(v1);
  operator new();
}

void sub_1004B84A8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, ctu::OsLogLogger *a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,dispatch_object_t object,dispatch_object_t a29,uint64_t a30,uint64_t a31,dispatch_object_t a32,dispatch_object_t a33,dispatch_object_t a34,dispatch_object_t a35,dispatch_object_t a36,dispatch_object_t a37,dispatch_object_t a38)
{
  sub_10008863C((void *)(v38 - 128));
  operator delete();
}

void sub_1004B8A0C()
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v2 - 160));
  sub_100087E88(v1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(v2 - 128));
  if (v0) {
    dispatch_release(v0);
  }
  JUMPOUT(0x1004B8818);
}

void sub_1004B8A48()
{
  if (v0) {
    dispatch_release(v0);
  }
  JUMPOUT(0x1004B8880);
}

void sub_1004B8A5C()
{
  sub_1001362D0((void *)(v0 - 192));
  JUMPOUT(0x1004B8880);
}

const char *sub_1004B8A6C(int a1)
{
  uint64_t v1 = "reg.ctr.?";
  if (a1 == 2) {
    uint64_t v1 = "reg.ctr.2";
  }
  if (a1 == 1) {
    return "reg.ctr.1";
  }
  else {
    return v1;
  }
}

void *sub_1004B8A98(uint64_t a1)
{
  sub_10003FB28(a1 + 32, *(void **)(a1 + 40));

  return sub_1004C3894((void *)a1);
}

void *sub_1004B8AD8(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_1004C3918((void *)a1);
}

void *sub_1004B8B18(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_1004C399C((void *)a1);
}

void sub_1004B8B58(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 88);
  xpc_object_t v5 = *(NSObject **)(a1 + 40);
  dispatch_group_t group = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(group);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v4 + 32))(v4, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  (*(void (**)(void))(**(void **)(v2 + 344) + 24))(*(void *)(v2 + 344));
  (*(void (**)(void))(**(void **)(v2 + 104) + 24))(*(void *)(v2 + 104));
  uint64_t v6 = *(void *)(v2 + 296);
  xpc_object_t v7 = *(NSObject **)(a1 + 40);
  dispatch_group_t object = v7;
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_group_enter(object);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v6 + 32))(v6, &object);
  if (object)
  {
    dispatch_group_leave(object);
    if (object) {
      dispatch_release(object);
    }
  }
  uint64_t v8 = *(void *)(v2 + 232);
  xpc_object_t v9 = *(NSObject **)(a1 + 40);
  dispatch_group_t v18 = v9;
  if (v9)
  {
    dispatch_retain(v9);
    dispatch_group_enter(v18);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v8 + 16))(v8, &v18);
  if (v18)
  {
    dispatch_group_leave(v18);
    if (v18) {
      dispatch_release(v18);
    }
  }
  xpc_object_t v10 = *(void **)(v2 + 64);
  if (v10 != (void *)(v2 + 72))
  {
    do
    {
      uint64_t v11 = v10[5];
      xpc_object_t v12 = *(NSObject **)(a1 + 40);
      dispatch_group_t v17 = v12;
      if (v12)
      {
        dispatch_retain(v12);
        if (v17) {
          dispatch_group_enter(v17);
        }
      }
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v11 + 32))(v11, &v17);
      if (v17)
      {
        dispatch_group_leave(v17);
        if (v17) {
          dispatch_release(v17);
        }
      }
      xpc_object_t v13 = (void *)v10[1];
      if (v13)
      {
        do
        {
          xpc_object_t v14 = v13;
          xpc_object_t v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          xpc_object_t v14 = (void *)v10[2];
          BOOL v15 = *v14 == (void)v10;
          xpc_object_t v10 = v14;
        }
        while (!v15);
      }
      xpc_object_t v10 = v14;
    }
    while (v14 != (void *)(v2 + 72));
  }
  (*(void (**)(void))(**(void **)(v2 + 360) + 24))(*(void *)(v2 + 360));
  for (uint64_t i = *(void *)(v2 + 408); i != v2 + 400; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));
  sub_100160A84((atomic_uint **)(v2 + 400));
}

void sub_1004B8E48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_group_t a9, dispatch_group_t group, dispatch_group_t a11, dispatch_group_t a12)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004B8EC0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(NSObject **)(a2 + 40);
  *(void *)(a1 + 40) = v3;
  if (v3)
  {
    dispatch_retain(v3);
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (v4)
    {
      dispatch_group_enter(v4);
    }
  }
}

void sub_1004B8F14(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (v3)
    {
      dispatch_release(v3);
    }
  }
}

void sub_1004B8F64(uint64_t a1, dispatch_object_t object)
{
  uint64_t v3 = (void *)(a1 + 8);
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v3);
  operator new();
}

void sub_1004B905C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", (uint8_t *)&buf, 2u);
  }
  *(void *)xpc_object_t v43 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v1 + 136));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v5;
  xpc_object_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    xpc_object_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  xpc_object_t v10 = 0;
  char v12 = 1;
LABEL_11:
  if (!v11)
  {
    xpc_object_t v14 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not restore enable only home network", (uint8_t *)&buf, 2u);
      if (v12) {
        goto LABEL_26;
      }
    }
    else if (v12)
    {
      goto LABEL_26;
    }
    sub_10004D2C8(v10);
    goto LABEL_26;
  }
  sub_100058DB0(&buf, "EURQMIC2KRegistrationController::fEnableOnlyHomeNetwork");
  char v13 = (*(uint64_t (**)(uint64_t, long long *, uint8_t *))(*(void *)v11 + 24))(v11, &buf, v43);
  if ((SBYTE7(v47) & 0x80000000) == 0)
  {
    if (v12) {
      goto LABEL_14;
    }
LABEL_20:
    sub_10004D2C8(v10);
    if ((v13 & 1) == 0) {
      goto LABEL_26;
    }
    goto LABEL_21;
  }
  operator delete((void *)buf);
  if ((v12 & 1) == 0) {
    goto LABEL_20;
  }
LABEL_14:
  if ((v13 & 1) == 0)
  {
LABEL_26:
    dispatch_group_t v18 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "EURQMIC2KRegistrationController::fEnableOnlyHomeNetwork";
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not restore %s key", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_28;
  }
LABEL_21:
  uint64_t v15 = *(void *)v43;
  *(unsigned char *)(v1 + 376) = *(void *)v43 != 0;
  uint64_t v16 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    dispatch_group_t v17 = "false";
    if (v15) {
      dispatch_group_t v17 = "true";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N Restored enable only home network to: %s", (uint8_t *)&buf, 0xCu);
  }
LABEL_28:
  (*(void (**)(void))(**(void **)(v1 + 88) + 24))(*(void *)(v1 + 88));
  uint64_t v19 = *(void **)(v1 + 64);
  if (v19 != (void *)(v1 + 72))
  {
    do
    {
      (*(void (**)(void))(*(void *)v19[5] + 24))(v19[5]);
      long long v48 = 0u;
      long long v49 = 0u;
      long long buf = 0u;
      long long v47 = 0u;
      (*(void (**)(uint8_t *__return_ptr))(*(void *)v19[5] + 440))(v43);
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v19[5] + 448))(&v40);
      MCCAndMNC::MCCAndMNC((MCCAndMNC *)&buf, (const MCC *)v43, (const MNC *)&v40);
      if (v42 < 0) {
        operator delete(__p);
      }
      if (v45 < 0) {
        operator delete(v44);
      }
      MCCAndMNC::getMcc((uint64_t *)v43, (MCCAndMNC *)&buf);
      if (MCC::valid((MCC *)v43))
      {
        MCCAndMNC::getMnc(&v40, (MCCAndMNC *)&buf);
        int v20 = MCC::valid((MCC *)&v40);
        if (v42 < 0) {
          operator delete(__p);
        }
      }
      else
      {
        int v20 = 0;
      }
      if (v45 < 0)
      {
        operator delete(v44);
        if (!v20)
        {
LABEL_48:
          xpc_object_t v27 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), *((unsigned int *)v19 + 8));
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)xpc_object_t v43 = 0;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#N Could not get valid last visible PLMN", v43, 2u);
          }
          goto LABEL_50;
        }
      }
      else if (!v20)
      {
        goto LABEL_48;
      }
      uint64_t v21 = *(void *)(v1 + 344);
      uint64_t v22 = *((unsigned int *)v19 + 8);
      (*(void (**)(void **__return_ptr))(*(void *)v19[5] + 440))(v38);
      (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v21 + 280))(v21, v22, v38);
      if (v39 < 0) {
        operator delete(v38[1]);
      }
      uint64_t v23 = *(void *)(v1 + 344);
      uint64_t v24 = *((unsigned int *)v19 + 8);
      (*(void (**)(void **__return_ptr))(*(void *)v19[5] + 448))(v36);
      (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v23 + 288))(v23, v24, v36);
      if (v37 < 0) {
        operator delete(v36[1]);
      }
      uint64_t v25 = *(void *)(v1 + 344);
      uint64_t v26 = *((unsigned int *)v19 + 8);
      MCCAndMNC::getMcc(v34, (MCCAndMNC *)&buf);
      MCCAndMNC::getMnc(v32, (MCCAndMNC *)&buf);
      (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t *))(*(void *)v25 + 264))(v25, v26, v34, v32);
      if (v33 < 0) {
        operator delete((void *)v32[1]);
      }
      if (v35 < 0) {
        operator delete((void *)v34[1]);
      }
LABEL_50:
      if (SHIBYTE(v49) < 0) {
        operator delete(*((void **)&v48 + 1));
      }
      if (SHIBYTE(v47) < 0) {
        operator delete(*((void **)&buf + 1));
      }
      xpc_object_t v28 = (void *)v19[1];
      if (v28)
      {
        do
        {
          xpc_object_t v29 = v28;
          xpc_object_t v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          xpc_object_t v29 = (void *)v19[2];
          BOOL v30 = *v29 == (void)v19;
          uint64_t v19 = v29;
        }
        while (!v30);
      }
      uint64_t v19 = v29;
    }
    while (v29 != (void *)(v1 + 72));
  }
  (*(void (**)(void))(**(void **)(v1 + 296) + 48))(*(void *)(v1 + 296));
  (*(void (**)(dispatch_object_t *__return_ptr))(**(void **)(v1 + 232) + 32))(&object);
  if (object) {
    dispatch_release(object);
  }
}

void sub_1004B975C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if (*(char *)(v54 - 137) < 0) {
    operator delete(*(void **)(v54 - 160));
  }
  if ((v53 & 1) == 0) {
    sub_10004D2C8(v52);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1004B9874(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[4];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

uint64_t sub_1004B98BC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void RegistrationController::send5GStandaloneEnabledSettingFromPreference_sync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 3)
  {
    subscriber::makeSimSlotRange();
    uint64_t v5 = v13;
    if (v13 != v14)
    {
      while ((v15(LODWORD(v5->__vftable)) & 1) == 0)
      {
        uint64_t v5 = (std::__shared_weak_count *)((char *)v5 + 4);
        if (v5 == v14)
        {
          uint64_t v5 = v14;
          break;
        }
      }
LABEL_6:
      while (v5 != v14)
      {
        uint64_t v6 = (std::__shared_weak_count *)((char *)&v5->__vftable + 4);
        RegistrationController::send5GStandaloneEnabledSettingFromPreference_sync(a1, LODWORD(v5->__vftable), a3);
        uint64_t v5 = v14;
        if (v6 != v14)
        {
          uint64_t v5 = v6;
          while ((v15(LODWORD(v5->__vftable)) & 1) == 0)
          {
            uint64_t v5 = (std::__shared_weak_count *)((char *)v5 + 4);
            if (v5 == v14)
            {
              uint64_t v5 = v14;
              goto LABEL_6;
            }
          }
        }
      }
    }
  }
  else
  {
    unsigned int v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    char v13 = 0;
    xpc_object_t v14 = 0;
    RegistrationController::getModel_sync(a1, a2, &v13);
    if (v13)
    {
      unsigned __int16 v9 = ((uint64_t (*)(std::__shared_weak_count *))v13->__vftable[20].__on_zero_shared_weak)(v13);
      if (v9 >= 0x100u)
      {
        (*(void (**)(void, uint64_t, BOOL, uint64_t))(**(void **)(a1 + 88) + 80))(*(void *)(a1 + 88), a2, v9 != 0, a3);
      }
      else
      {
        xpc_object_t v10 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)char v12 = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I 5G Standalone support not yet known", v12, 2u);
        }
      }
    }
    else
    {
      uint64_t v11 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)char v12 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Could not get model for sending 5G Standalone enabled setting", v12, 2u);
      }
    }
    if (v14) {
      sub_10004D2C8(v14);
    }
  }
}

void sub_1004B9B18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RegistrationController::update5GSACapabilityRestProperty_sync(capabilities::ct *a1, uint64_t a2)
{
  uint64_t result = capabilities::ct::supports5G(a1);
  if (result)
  {
    v22[0] = 1;
    long long v23 = 0u;
    uint64_t v24 = 0;
    v22[1] = (char *)a1 + 880;
    sub_10005DF14((uint64_t *)&v23, (uint64_t)a1 + 912);
    subscriber::makeSimSlotRange();
    uint64_t v6 = v19;
    uint64_t v5 = v20;
    if (v19 != v20)
    {
      uint64_t v7 = v21;
      while ((v21(*v6) & 1) == 0)
      {
        if (++v6 == v20)
        {
          uint64_t v6 = v20;
          break;
        }
      }
      unsigned int v8 = v20;
      while (v6 != v8)
      {
        int v18 = 0;
        int v18 = *v6;
        uint64_t v16 = 0;
        dispatch_group_t v17 = 0;
        RegistrationController::getModel_sync((uint64_t)a1, v18, &v16);
        if (v16)
        {
          unsigned int v9 = (*(unsigned __int16 (**)(uint64_t))(*(void *)v16 + 832))(v16);
          if (v9 <= 0x100) {
            char v10 = 0;
          }
          else {
            char v10 = v9;
          }
          char NRDisableStatus_sync = RegistrationController::getNRDisableStatus_sync((uint64_t)a1, v18);
          int v12 = NRDisableStatus_sync & 1;
          if (v10) {
            BOOL v13 = (NRDisableStatus_sync & 1) == 0;
          }
          else {
            BOOL v13 = 0;
          }
          xpc_object_t v14 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(**((void **)a1 + 6) + 16))(*((void **)a1 + 6), a2);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109632;
            *(_DWORD *)&uint8_t buf[4] = v10 != 0;
            __int16 v26 = 1024;
            int v27 = v12;
            __int16 v28 = 1024;
            BOOL v29 = v13;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I saEnabled %d, disabledByBB %d, saCapability %d", buf, 0x14u);
          }
          *(void *)long long buf = &v18;
          *((unsigned char *)sub_10005CE78((uint64_t **)&v23, &v18, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = v13;
        }
        if (v17) {
          sub_10004D2C8(v17);
        }
        uint64_t v15 = v6 + 1;
        uint64_t v6 = v5;
        if (v15 != v5)
        {
          uint64_t v6 = v15;
          while ((v7(*v6) & 1) == 0)
          {
            if (++v6 == v5)
            {
              uint64_t v6 = v5;
              break;
            }
          }
        }
      }
    }
    return sub_1004CB9C8((uint64_t)v22);
  }
  return result;
}

void sub_1004B9DB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_1004CB9C8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1004B9DF0(uint64_t a1, xpc_object_t object, NSObject **a3)
{
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_null_create();
  }
  uint64_t v5 = *a3;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  long long v6 = 0uLL;
  sub_10003E168(&v6, (void *)(a1 + 8));
  xpc_null_create();
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  long long v6 = 0uLL;
  operator new();
}

void RegistrationController::~RegistrationController(RegistrationController *this)
{
  *(void *)this = off_101A6A138;
  sub_1000346F8((uint64_t)this + 1320, *((void **)this + 166));
  sub_1000346F8((uint64_t)this + 1296, *((void **)this + 163));
  sub_1000346F8((uint64_t)this + 1272, *((void **)this + 160));
  sub_10030AAD0((uint64_t)this + 1248, *((void **)this + 157));
  PersonalitiesTracker::~PersonalitiesTracker((RegistrationController *)((char *)this + 1080));
  sub_1000346F8((uint64_t)this + 1048, *((void **)this + 132));
  sub_1000346F8((uint64_t)this + 1024, *((void **)this + 129));
  sub_1000346F8((uint64_t)this + 1000, *((void **)this + 126));
  sub_10003FB28((uint64_t)this + 976, *((void **)this + 123));
  sub_1004C3894((void *)this + 118);
  sub_1000346F8((uint64_t)this + 912, *((void **)this + 115));
  sub_10041A760((void *)this + 110);
  sub_1000346F8((uint64_t)this + 856, *((void **)this + 108));
  sub_1004C3918((void *)this + 103);
  sub_1000346F8((uint64_t)this + 792, *((void **)this + 100));
  sub_1004C399C((void *)this + 95);
  sub_10019D5B8((uint64_t)this + 728, *((void **)this + 92));
  sub_1000346F8((uint64_t)this + 704, *((void **)this + 89));
  sub_10005CD2C((uint64_t)this + 680, *((char **)this + 86));
  sub_10005CD2C((uint64_t)this + 648, *((char **)this + 82));
  sub_10005CD2C((uint64_t)this + 624, *((char **)this + 79));
  sub_1000346F8((uint64_t)this + 592, *((void **)this + 75));
  sub_100087F94((uint64_t)this + 560, *((void **)this + 71));
  sub_100087F94((uint64_t)this + 536, *((void **)this + 68));
  sub_1000346F8((uint64_t)this + 512, *((void **)this + 65));
  uint64_t v24 = (void **)((char *)this + 488);
  sub_10008A88C(&v24);
  sub_10005CD2C((uint64_t)this + 448, *((char **)this + 57));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 54);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100160A84((atomic_uint **)this + 50);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 49);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 46);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 44);
  if (v5) {
    sub_10004D2C8(v5);
  }
  long long v6 = (std::__shared_weak_count *)*((void *)this + 42);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 40);
  if (v7) {
    sub_10004D2C8(v7);
  }
  unsigned int v8 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v8) {
    sub_10004D2C8(v8);
  }
  unsigned int v9 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v9) {
    sub_10004D2C8(v9);
  }
  char v10 = (std::__shared_weak_count *)*((void *)this + 34);
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 32);
  if (v11) {
    sub_10004D2C8(v11);
  }
  int v12 = (std::__shared_weak_count *)*((void *)this + 30);
  if (v12) {
    sub_10004D2C8(v12);
  }
  BOOL v13 = (std::__shared_weak_count *)*((void *)this + 28);
  if (v13) {
    sub_10004D2C8(v13);
  }
  xpc_object_t v14 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v14) {
    sub_10004D2C8(v14);
  }
  uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 24);
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v16 = (std::__shared_weak_count *)*((void *)this + 22);
  if (v16) {
    sub_10004D2C8(v16);
  }
  dispatch_group_t v17 = (std::__shared_weak_count *)*((void *)this + 20);
  if (v17) {
    sub_10004D2C8(v17);
  }
  int v18 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v18) {
    sub_10004D2C8(v18);
  }
  uint64_t v19 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v19) {
    sub_10004D2C8(v19);
  }
  int v20 = (std::__shared_weak_count *)*((void *)this + 14);
  if (v20) {
    sub_10004D2C8(v20);
  }
  uint64_t v21 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v21) {
    sub_10004D2C8(v21);
  }
  sub_10005D0E4((uint64_t)this + 64, *((void **)this + 9));
  uint64_t v22 = *((void *)this + 7);
  if (v22) {
    dispatch_release(v22);
  }
  uint64_t v23 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  ctu::OsLogLogger::~OsLogLogger((RegistrationController *)((char *)this + 40));
  sub_100087E88((void *)this + 1);
  RegistrationInterface::~RegistrationInterface(this);
}

{
  uint64_t vars8;

  RegistrationController::~RegistrationController(this);

  operator delete();
}

void RegistrationController::e911StateReady(uint64_t a1, char a2, int a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_1004BA3E4;
  void v5[3] = &unk_1019D47C0;
  void v5[4] = a1;
  char v7 = a2;
  int v6 = a3;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  uint64_t v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v10;
  unsigned int v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

uint64_t sub_1004BA3E4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(*(void *)(a1 + 32) + 344) + 192))(*(void *)(*(void *)(a1 + 32) + 344), *(unsigned __int8 *)(a1 + 44), *(unsigned int *)(a1 + 40));
}

void RegistrationController::e911ChosenSlot(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_1004BA52C;
  uint64_t v4[3] = &unk_1019D47E0;
  void v4[4] = a1;
  void v4[5] = a2;
  uint64_t v7 = 0;
  unsigned int v8 = 0;
  sub_10003E168(&v7, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v7;
  int v6 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

uint64_t sub_1004BA52C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 32) + 344) + 200))(*(void *)(*(void *)(a1 + 32) + 344), *(void *)(a1 + 40));
}

void RegistrationController::e911ScanFailed(uint64_t a1, int a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_1004BA66C;
  uint64_t v4[3] = &unk_1019D4800;
  void v4[4] = a1;
  int v5 = a2;
  uint64_t v8 = 0;
  unsigned int v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v8;
  uint64_t v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

uint64_t sub_1004BA66C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 32) + 344) + 208))(*(void *)(*(void *)(a1 + 32) + 344), *(unsigned int *)(a1 + 40));
}

void RegistrationController::e911StateExitCompleted(RegistrationController *this)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  void v3[2] = sub_1004BA7AC;
  v3[3] = &unk_1019D4820;
  v3[4] = this;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  sub_10003E168(&v6, (void *)this + 1);
  uint64_t v2 = *((void *)this + 3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v6;
  int v5 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v3;
  dispatch_async(v2, block);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

uint64_t sub_1004BA7AC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 344) + 216))();
}

void RegistrationController::t3402TimerChange(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void RegistrationController::handleSubscriptionChangeIndication(uint64_t a1, int a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_1004BA9D4;
  uint64_t v4[3] = &unk_1019D4840;
  void v4[4] = a1;
  int v5 = a2;
  uint64_t v8 = 0;
  unsigned int v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v8;
  uint64_t v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

uint64_t sub_1004BA9D4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 32) + 344) + 152))(*(void *)(*(void *)(a1 + 32) + 344), *(unsigned int *)(a1 + 40));
}

void RegistrationController::handleCipherDomain(uint64_t a1, int a2, int a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_1004BAB1C;
  void v5[3] = &unk_1019D4860;
  void v5[4] = a1;
  int v6 = a2;
  int v7 = a3;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  uint64_t v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v10;
  unsigned int v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

uint64_t sub_1004BAB1C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(*(void *)(a1 + 32) + 344) + 256))(*(void *)(*(void *)(a1 + 32) + 344), *(unsigned int *)(a1 + 40), *(unsigned int *)(a1 + 44));
}

void RegistrationController::handleEncryptionStatus(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void RegistrationController::handleSetCampOnlyModeResult(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

BOOL RegistrationController::supports5GNSA_sync(uint64_t a1)
{
  CFBooleanRef v3 = 0;
  (*(void (**)(CFBooleanRef *__return_ptr))(**(void **)(a1 + 248) + 80))(&v3);
  BOOL v1 = v3 == kCFBooleanTrue;
  sub_1000577C4((const void **)&v3);
  return v1;
}

void RegistrationController::handleNRDisableStatus(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void RegistrationController::handleGeoPlmnInfo(uint64_t a1, int a2, MCC *a3)
{
  MCC::MCC((MCC *)&v5, a3);
  MCC::MCC((MCC *)&v6, (MCC *)((char *)a3 + 32));
  v7[0] = 0;
  v7[1] = 0;
  sub_10003E168(v7, (void *)(a1 + 8));
  operator new();
}

void sub_1004BB008(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (*(char *)(v17 + 47) < 0) {
    operator delete(*(void **)(v17 + 24));
  }
  sub_10006A6AC(a1);
}

void RegistrationController::handleGeoMccFetchIndication(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

uint64_t RegistrationController::checkAndSetSmsServiceMask_sync(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v68 = 0;
  xpc_object_t v69 = 0;
  Model_sync = (capabilities::ct *)RegistrationController::getModel_sync(a1, a2, &v68);
  uint64_t v10 = v68;
  if (!v68)
  {
    uint64_t v24 = *v8;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not get model for setting SMS over IMS service mask", buf, 2u);
    }
    goto LABEL_67;
  }
  if (*a3 == a3[1])
  {
    uint64_t v25 = *v8;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I No data connection - SMS over IMS is not available", buf, 2u);
    }
    goto LABEL_67;
  }
  if (!capabilities::ct::requiresIMSFeatureMasking(Model_sync))
  {
    uint64_t v23 = a4;
    goto LABEL_33;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
  int v12 = ServiceMap;
  if (v13 < 0)
  {
    xpc_object_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (!v17)
  {
    uint64_t v19 = 0;
LABEL_19:
    std::mutex::unlock(v12);
    int v18 = 0;
    char v20 = 1;
    if (!v19) {
      goto LABEL_10;
    }
LABEL_20:
    CFDictionaryRef theDict = 0;
    uint64_t v67 = 0;
    (*(void (**)(CFDictionaryRef *__return_ptr, uint64_t, uint64_t))(*(void *)v19 + 8))(&theDict, v19, a2);
    if (theDict)
    {
      __int16 v26 = sub_100046F68(a1 + 624, (void **)theDict + 3);
      if ((void **)(a1 + 632) != v26)
      {
        uint64_t v23 = v26[7] & a4;
        if (v23 != a4)
        {
          log = *v8;
          if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v53 = sd::asString();
            uint64_t v54 = sd::asString();
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v53;
            __int16 v71 = 2080;
            uint64_t v72 = v54;
            _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I IMS Pref service mask is adjusted: [%s] -> [%s]", buf, 0x16u);
          }
          int v22 = 0;
LABEL_28:
          if (v67) {
            sub_10004D2C8(v67);
          }
          if (v20)
          {
LABEL_32:
            if (v22) {
              goto LABEL_67;
            }
LABEL_33:
            if ((v23 & 2) != 0)
            {
              uint64_t v38 = *v8;
              if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I SMS over IMS is supported and set by baseband", buf, 2u);
              }
              goto LABEL_66;
            }
            CFDictionaryRef theDict = 0;
            __int16 v28 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
            BOOL v29 = v28;
            if (v30 < 0)
            {
              xpc_object_t v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v32 = 5381;
              do
              {
                uint64_t v30 = v32;
                unsigned int v33 = *v31++;
                uint64_t v32 = (33 * v32) ^ v33;
              }
              while (v33);
            }
            std::mutex::lock(v28);
            *(void *)long long buf = v30;
            xpc_object_t v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)buf);
            if (v34)
            {
              uint64_t v36 = v34[3];
              char v35 = (std::__shared_weak_count *)v34[4];
              if (v35)
              {
                atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v29);
                atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v35);
                char v37 = 0;
                goto LABEL_44;
              }
            }
            else
            {
              uint64_t v36 = 0;
            }
            std::mutex::unlock(v29);
            char v35 = 0;
            char v37 = 1;
LABEL_44:
            (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v36 + 96))(&v65, v36, a2, 1, @"IMSConfig", 0, 0);
            sub_10004EFE4(&theDict, &v65);
            sub_1000577C4(&v65);
            if ((v37 & 1) == 0) {
              sub_10004D2C8(v35);
            }
            if (theDict) {
              char v39 = sub_100080778;
            }
            else {
              char v39 = 0;
            }
            if (v39)
            {
              CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"SMS");
              CFDictionaryRef v41 = Value;
              if (Value)
              {
                CFTypeID v42 = CFGetTypeID(Value);
                if (v42 == CFDictionaryGetTypeID())
                {
                  if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 128))(v10) == 4
                    && (CFBooleanRef v43 = (const __CFBoolean *)CFDictionaryGetValue(v41, @"SMSBundleToVoiceRoaming"),
                        (CFBooleanRef v44 = v43) != 0)
                    && (CFTypeID v45 = CFGetTypeID(v43), v45 == CFBooleanGetTypeID())
                    || (CFBooleanRef v46 = (const __CFBoolean *)CFDictionaryGetValue(v41, @"SMSBundleToVoice"),
                        (CFBooleanRef v44 = v46) != 0)
                    && (CFTypeID v47 = CFGetTypeID(v46), v47 == CFBooleanGetTypeID()))
                  {
                    CFBooleanRef v48 = kCFBooleanFalse;
                    if (kCFBooleanFalse == v44)
                    {
                      long long v49 = *v8;
                      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#N SMS support is explicitly not bundled to Voice.", buf, 2u);
                      }
                      goto LABEL_77;
                    }
                  }
                  else
                  {
                    CFBooleanRef v48 = kCFBooleanFalse;
                  }
                  CFBooleanRef v44 = v48;
                  if ((v23 & 1) == 0)
                  {
                    xpc_object_t v50 = *v8;
                    if (!os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_65;
                    }
                    *(_WORD *)long long buf = 0;
                    xpc_object_t v51 = "#N IMS Voice feature is not supported and SMS support is bundled - dropping SMS as well";
                    goto LABEL_64;
                  }
LABEL_77:
                  CFDictionaryRef v55 = (const __CFDictionary *)CFDictionaryGetValue(v41, @"SupportedDomains");
                  CFDictionaryRef v56 = v55;
                  if (v55)
                  {
                    CFTypeID v57 = CFGetTypeID(v55);
                    if (v57 == CFDictionaryGetTypeID())
                    {
                      switch(*(_DWORD *)*a3)
                      {
                        case 0xFFFFFFFE:
                        case 0xFFFFFFFF:
                        case 0:
                          xpc_object_t v58 = *v8;
                          if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_WORD *)long long buf = 0;
                            xpc_object_t v59 = "#I SMS over IMS is not supported when no data available";
                            goto LABEL_107;
                          }
                          break;
                        case 1:
                        case 2:
                          if (CFDictionaryContainsKey(v56, @"GSM"))
                          {
                            CFBooleanRef v60 = (const __CFBoolean *)CFDictionaryGetValue(v56, @"GSM");
                            CFBooleanRef v44 = v60;
                            if (v60) {
                              goto LABEL_102;
                            }
                          }
                          break;
                        case 3:
                        case 4:
                        case 5:
                          if (CFDictionaryContainsKey(v56, @"UMTS"))
                          {
                            CFBooleanRef v60 = (const __CFBoolean *)CFDictionaryGetValue(v56, @"UMTS");
                            CFBooleanRef v44 = v60;
                            if (v60) {
                              goto LABEL_102;
                            }
                          }
                          break;
                        case 0xA:
                        case 0xB:
                        case 0xC:
                        case 0xF:
                          xpc_object_t v58 = *v8;
                          if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_WORD *)long long buf = 0;
                            xpc_object_t v59 = "#I SMS over IMS is not supported in CDMA data mode";
                            goto LABEL_107;
                          }
                          break;
                        case 0xD:
                          if (CFDictionaryContainsKey(v56, @"EHRPD"))
                          {
                            CFBooleanRef v60 = (const __CFBoolean *)CFDictionaryGetValue(v56, @"EHRPD");
                            CFBooleanRef v44 = v60;
                            if (v60) {
                              goto LABEL_102;
                            }
                          }
                          break;
                        case 0xE:
                        case 0x10:
                          if (CFDictionaryContainsKey(v56, @"LTE"))
                          {
                            CFBooleanRef v60 = (const __CFBoolean *)CFDictionaryGetValue(v56, @"LTE");
                            CFBooleanRef v44 = v60;
                            if (v60) {
                              goto LABEL_102;
                            }
                          }
                          break;
                        case 0x11:
                          if (CFDictionaryContainsKey(v56, @"NR"))
                          {
                            CFBooleanRef v60 = (const __CFBoolean *)CFDictionaryGetValue(v56, @"NR");
                            CFBooleanRef v44 = v60;
                            if (v60)
                            {
LABEL_102:
                              CFTypeID v61 = CFGetTypeID(v60);
                              if (v61 != CFBooleanGetTypeID()) {
                                CFBooleanRef v44 = 0;
                              }
                            }
                          }
                          break;
                        case 0x12:
                          xpc_object_t v58 = *v8;
                          if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_WORD *)long long buf = 0;
                            xpc_object_t v59 = "#I SMS over IMS is not supported in LTEiTech data mode";
LABEL_107:
                            _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, v59, buf, 2u);
                          }
                          break;
                        default:
                          break;
                      }
                      if (kCFBooleanTrue == v44)
                      {
                        xpc_object_t v62 = *v8;
                        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v63 = asString();
                          *(_DWORD *)long long buf = 136315138;
                          *(void *)&uint8_t buf[4] = v63;
                          _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I SMS over IMS is supported in %s mode - adding service mask", buf, 0xCu);
                        }
                        uint64_t v23 = v23 | 2;
                      }
                      goto LABEL_65;
                    }
                  }
                  xpc_object_t v50 = *v8;
                  if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    xpc_object_t v51 = "#N Could not read SupportedDomains in IMSConfig preferences - assuming SMS is not supported";
                    goto LABEL_64;
                  }
LABEL_65:
                  sub_100057D78((const void **)&theDict);
LABEL_66:
                  a4 = v23;
                  goto LABEL_67;
                }
              }
              xpc_object_t v50 = *v8;
              if (!os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_65;
              }
              *(_WORD *)long long buf = 0;
              xpc_object_t v51 = "#N Could not read SMS subsection of IMSConfig in preferences - assuming SMS is not supported";
            }
            else
            {
              xpc_object_t v50 = *v8;
              if (!os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_65;
              }
              *(_WORD *)long long buf = 0;
              xpc_object_t v51 = "#N Could not read IMSConfig section from preferences - assuming SMS is not supported";
            }
LABEL_64:
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, v51, buf, 2u);
            goto LABEL_65;
          }
LABEL_31:
          sub_10004D2C8(v18);
          goto LABEL_32;
        }
      }
      int v22 = 0;
    }
    else
    {
      int v27 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Could not get personality info for setting SMS over IMS service mask", buf, 2u);
      }
      int v22 = 1;
    }
    uint64_t v23 = a4;
    goto LABEL_28;
  }
  uint64_t v19 = v17[3];
  int v18 = (std::__shared_weak_count *)v17[4];
  if (!v18) {
    goto LABEL_19;
  }
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v12);
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v18);
  char v20 = 0;
  if (v19) {
    goto LABEL_20;
  }
LABEL_10:
  uint64_t v21 = *v8;
  if (!os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
  {
    if (v20) {
      goto LABEL_67;
    }
    goto LABEL_12;
  }
  *(_WORD *)long long buf = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not get personality shop for setting SMS over IMS service mask", buf, 2u);
  if ((v20 & 1) == 0)
  {
LABEL_12:
    int v22 = 1;
    uint64_t v23 = a4;
    goto LABEL_31;
  }
LABEL_67:
  if (v69) {
    sub_10004D2C8(v69);
  }
  return a4;
}

void sub_1004BBADC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(a1);
}

void RegistrationController::imsPreferenceUpdate(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v6 = (void *)(a1 + 8);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 1174405120;
  void v8[2] = sub_1004BBD1C;
  void v8[3] = &unk_1019D4880;
  int v12 = a2;
  void v8[4] = a1;
  std::string __p = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_1003FB56C(&__p, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  int v13 = a4;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  sub_10003E168(&v16, v6);
  int v7 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v16;
  uint64_t v15 = v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v8;
  dispatch_async(v7, block);
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (__p)
  {
    uint64_t v10 = __p;
    operator delete(__p);
  }
}

void sub_1004BBD1C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CFBooleanRef v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(a1 + 64));
  uint64_t v41 = 0;
  CFTypeID v42 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(a1 + 64), &v41);
  uint64_t v4 = v41;
  if (!v41)
  {
    uint64_t v21 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find model for IMS preference update", buf, 2u);
    }
    goto LABEL_36;
  }
  uint64_t v5 = *(const void **)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  std::string __p = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  sub_1003FB56C(&__p, v5, v6, (v6 - (uint64_t)v5) >> 2);
  int v40 = *(_DWORD *)(a1 + 68);
  (*(void (**)(uint64_t, void **))(*(void *)v4 + 760))(v4, &__p);
  if (__p)
  {
    uint64_t v38 = __p;
    operator delete(__p);
  }
  unsigned int v7 = RegistrationController::checkAndSetSmsServiceMask_sync(v2, *(unsigned int *)(a1 + 64), (void *)(a1 + 40), *(unsigned int *)(a1 + 68));
  uint64_t v8 = *(void *)(v2 + 344);
  uint64_t v9 = *(unsigned int *)(a1 + 64);
  char v35 = 0;
  uint64_t v36 = 0;
  xpc_object_t v34 = 0;
  sub_1003FB56C(&v34, *(const void **)(a1 + 40), *(void *)(a1 + 48), (uint64_t)(*(void *)(a1 + 48) - *(void *)(a1 + 40)) >> 2);
  (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)v8 + 96))(v8, v9, &v34, v7);
  uint64_t v10 = (capabilities::ct *)v34;
  if (v34)
  {
    char v35 = v34;
    operator delete(v34);
  }
  if ((capabilities::ct::supports5G(v10) & 1) == 0) {
    goto LABEL_36;
  }
  uint64_t v32 = 0;
  unsigned int v33 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 136));
  int v12 = ServiceMap;
  if (v13 < 0)
  {
    xpc_object_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (!v17)
  {
    uint64_t v19 = 0;
    goto LABEL_16;
  }
  uint64_t v19 = v17[3];
  int v18 = (std::__shared_weak_count *)v17[4];
  if (!v18)
  {
LABEL_16:
    std::mutex::unlock(v12);
    int v18 = 0;
    char v20 = 1;
    goto LABEL_17;
  }
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v12);
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v18);
  char v20 = 0;
LABEL_17:
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void))(*(void *)v19 + 8))(&v32, v19, *(unsigned int *)(a1 + 64));
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  if (v32)
  {
    int v22 = sub_100046F68(v2 + 648, (void **)(v32 + 24));
    uint64_t v23 = v22;
    if ((void **)(v2 + 656) != v22 && *((_DWORD *)v22 + 14) == 1)
    {
      uint64_t v25 = *(_DWORD **)(a1 + 40);
      uint64_t v24 = *(_DWORD **)(a1 + 48);
      if (v25 == v24)
      {
LABEL_25:
        uint64_t v25 = *(_DWORD **)(a1 + 48);
      }
      else
      {
        while (*v25 != *((_DWORD *)v22 + 18))
        {
          if (++v25 == v24) {
            goto LABEL_25;
          }
        }
      }
      if (v24 != v25)
      {
        if (v7 & 1) != 0 && (*((unsigned char *)v22 + 60))
        {
          BOOL v29 = *v3;
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Sending IMS registration status update for new VoPS update while already registered for voice", buf, 2u);
          }
          uint64_t v30 = *(unsigned int *)(a1 + 64);
          uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 464))(v4);
          (*(void (**)(uint64_t, uint64_t, uint64_t, void, void, void))(*(void *)v2 + 408))(v2, v30, v31, *((unsigned int *)v23 + 18), *((unsigned int *)v23 + 15), 0);
        }
        else
        {
          __int16 v26 = *v3;
          if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v27 = asStringBool(*((_DWORD *)v23 + 15) & 1);
            uint64_t v28 = sd::asString();
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v27;
            __int16 v44 = 2080;
            uint64_t v45 = v28;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Not sending IMS registration status update for new IMS preference update. Registered for voice: %s, VoPS=[%s]", buf, 0x16u);
          }
        }
      }
    }
  }
  if (v33) {
    sub_10004D2C8(v33);
  }
LABEL_36:
  if (v42) {
    sub_10004D2C8(v42);
  }
}

void sub_1004BC194(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a20) {
    sub_10004D2C8(a20);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1004BC21C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  uint64_t v2 = (void *)(a1 + 40);
  v2[2] = 0;
  return sub_1003FB56C(v2, *(const void **)(a2 + 40), *(void *)(a2 + 48), (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 2);
}

void sub_1004BC238(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void RegistrationController::ecbmStatus(uint64_t a1, int a2, __int16 a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_1004BC368;
  void v5[3] = &unk_1019D48B0;
  void v5[4] = a1;
  __int16 v7 = a3;
  int v6 = a2;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  uint64_t v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v10;
  uint64_t v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_1004BC368(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(a1 + 44))
  {
    int v2 = *(unsigned __int8 *)(a1 + 45);
    if (v2 != (*(unsigned int (**)(void))(**(void **)(v1 + 104) + 88))(*(void *)(v1 + 104)))
    {
      (*(void (**)(void, BOOL))(**(void **)(v1 + 104) + 96))(*(void *)(v1 + 104), v2 != 0);
      CFBooleanRef v3 = *(void (**)(void))(**(void **)(v1 + 344) + 32);
      v3();
    }
  }
  else
  {
    sub_100058DB0(&v4, "Resetting due to inconsistent ECBM state!");
    rest::ResetPayload::ResetPayload();
    sub_1004BC4DC();
    if (v7 < 0) {
      operator delete(__p);
    }
    if (v5 < 0) {
      operator delete(v4);
    }
  }
}

void sub_1004BC4A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004BC4DC()
{
  xpc_object_t v3 = 0;
  rest::write_rest_value();
  sub_100058DB0(&__p, "/cc/events/reset_request");
  xpc_object_t object = v3;
  xpc_object_t v3 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_1004BC570(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void RegistrationController::setProvisioningModeComplete(RegistrationController *this)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  void v3[2] = sub_1004BC6C0;
  v3[3] = &unk_1019D48D0;
  v3[4] = this;
  uint64_t v6 = 0;
  char v7 = 0;
  sub_10003E168(&v6, (void *)this + 1);
  char v2 = *((void *)this + 3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v6;
  char v5 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v3;
  dispatch_async(v2, block);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1004BC6C0()
{
  sub_100058DB0(&v0, "Resetting baseband after toggling provisioning mode");
  rest::ResetPayload::ResetPayload();
  sub_1004BC4DC();
  if (v3 < 0) {
    operator delete(__p);
  }
  if (v1 < 0) {
    operator delete(v0);
  }
}

void sub_1004BC734(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::enable3GResult(uint64_t a1, uint64_t a2, char a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_1004BC878;
  void v5[3] = &unk_1019D48F0;
  void v5[4] = a1;
  char v6 = a3;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_10003E168(&v9, (void *)(a1 + 8));
  uint64_t v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v9;
  uint64_t v8 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_1004BC878(uint64_t a1)
{
  char v2 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 40)) {
      char v3 = "true";
    }
    else {
      char v3 = "false";
    }
    int v4 = 136315138;
    char v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Enable 3G result: %s", (uint8_t *)&v4, 0xCu);
  }
}

void RegistrationController::handleDataRoamingSettingResult(uint64_t a1, int a2, char a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_1004BCA4C;
  void v5[3] = &unk_1019D4910;
  void v5[4] = a1;
  int v6 = a2;
  char v7 = a3;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  int v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v10;
  uint64_t v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_1004BCA4C(uint64_t a1)
{
  char v2 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 32) + 48) + 16))(*(void *)(*(void *)(a1 + 32) + 48), *(unsigned int *)(a1 + 40));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 44)) {
      char v3 = "true";
    }
    else {
      char v3 = "false";
    }
    int v4 = 136315138;
    char v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Data Roaming result: %s", (uint8_t *)&v4, 0xCu);
  }
}

void RegistrationController::networkRegistrationDriverStatus(RegistrationController *this, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_1004BCC48;
  uint64_t v4[3] = &unk_1019D4930;
  void v4[4] = this;
  char v5 = a2;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  sub_10003E168(&v8, (void *)this + 1);
  char v3 = *((void *)this + 3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v8;
  char v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_1004BCC48(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(a1 + 40))
  {
    (*(void (**)(void, uint64_t))(**(void **)(v1 + 88) + 112))(*(void *)(v1 + 88), 3);
    RegistrationController::sendGetServingSystemReq_sync((RegistrationController *)v1);
    RegistrationController::pollSignalStrength_sync(v1, 3);
    EncryptionStatus_sync = (capabilities::ct *)RegistrationController::getEncryptionStatus_sync((RegistrationController *)v1);
    int v3 = capabilities::ct::supports5G(EncryptionStatus_sync);
    int v4 = *(NSObject **)(v1 + 40);
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Command driver has come up, sending down the 5G, LTE, and 3G preference is required", buf, 2u);
      }
      RegistrationController::send5GEnabledSettingFromPreference_sync(v1, 3, 3);
      RegistrationController::send5GStandaloneEnabledSettingFromPreference_sync(v1, 3, 3);
    }
    else if (v5)
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Command driver has come up, sending down the LTE, and 3G preference is required", v9, 2u);
    }
    RegistrationController::sendLteEnabledSettingFromPreference_sync(v1, 3, 3);
    RegistrationController::send3GEnabledSettingFromPreference_sync(v1, 3, 3);
    if (capabilities::ct::supportsBB2GMitigation(v7)) {
      RegistrationController::send2GEnabledSettingFromPreference_sync(v1, 3u);
    }
    sub_1004BDC7C((capabilities::ct *)v1);
    RegistrationController::sendCampOnlyModeSetting_sync((RegistrationController *)v1);
    if (capabilities::ct::supportsOnlineModeDueToUserPowerCycle(v8)) {
      (*(void (**)(void, void))(**(void **)(v1 + 88) + 264))(*(void *)(v1 + 88), *(unsigned int *)(v1 + 752));
    }
  }
  else
  {
    int v6 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Network Registration Driver went down", v11, 2u);
    }
  }
}

void RegistrationController::pollSignalStrength_sync(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
  BOOL v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    char v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v16);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
LABEL_11:
      (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 16))(v12, a2);
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (v12) {
    goto LABEL_11;
  }
LABEL_7:
  xpc_object_t v14 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v15 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Missing SignalStrengthInterface to poll for signal strength!", v15, 2u);
  }
LABEL_12:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1004BCF78(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RegistrationController::getEncryptionStatus_sync(RegistrationController *this)
{
  uint64_t result = capabilities::ct::supportsSecurityStatus(this);
  if (result)
  {
    uint64_t result = subscriber::makeSimSlotRange();
    int v3 = v5;
    if (v5 != v6)
    {
      while (1)
      {
        uint64_t result = v7(*v3);
        if (result) {
          break;
        }
        if (++v3 == v6)
        {
          int v3 = v6;
          break;
        }
      }
LABEL_6:
      while (v3 != v6)
      {
        int v4 = v3 + 1;
        uint64_t result = (*(uint64_t (**)(void, void))(**((void **)this + 11) + 272))(*((void *)this + 11), *v3);
        int v3 = v6;
        if (v4 != v6)
        {
          int v3 = v4;
          while (1)
          {
            uint64_t result = v7(*v3);
            if (result) {
              break;
            }
            if (++v3 == v6)
            {
              int v3 = v6;
              goto LABEL_6;
            }
          }
        }
      }
    }
  }
  return result;
}

void RegistrationController::send5GEnabledSettingFromPreference_sync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != 3)
  {
    uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
    uint64_t v10 = ServiceMap;
    if (v11 < 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
        if (!v17) {
          goto LABEL_18;
        }
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unint64_t v16 = 0;
    char v18 = 1;
    if (!v17)
    {
LABEL_18:
      uint64_t v19 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not get Max Data Rate Manager to send 5G enabled setting to baseband", buf, 2u);
      }
LABEL_28:
      if ((v18 & 1) == 0) {
        sub_10004D2C8(v16);
      }
      return;
    }
LABEL_22:
    *(void *)long long buf = 0;
    uint64_t v24 = 0;
    RegistrationController::getModel_sync(a1, a2, buf);
    if (*(void *)buf)
    {
      uint64_t v27 = 0;
      char v20 = operator new(0x28uLL);
      *char v20 = off_1019D51D8;
      v20[1] = a1;
      *((_DWORD *)v20 + 4) = a2;
      unint64_t v20[3] = v8;
      *((unsigned char *)v20 + 32) = a3;
      uint64_t v27 = v20;
      (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 56))(v17, a2, v26);
      sub_1004CACEC(v26);
    }
    else
    {
      uint64_t v21 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int v22 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not get model for sending 5G enabled setting", v22, 2u);
      }
    }
    if (v24) {
      sub_10004D2C8(v24);
    }
    goto LABEL_28;
  }
  subscriber::makeSimSlotRange();
  BOOL v5 = *(std::__shared_weak_count **)buf;
  if (*(std::__shared_weak_count **)buf != v24)
  {
    while ((v25(LODWORD(v5->__vftable)) & 1) == 0)
    {
      BOOL v5 = (std::__shared_weak_count *)((char *)v5 + 4);
      if (v5 == v24)
      {
        BOOL v5 = v24;
        break;
      }
    }
LABEL_6:
    while (v5 != v24)
    {
      RegistrationController::send5GEnabledSettingFromPreference_sync(a1, LODWORD(v5->__vftable), a3);
      unint64_t v6 = (std::__shared_weak_count *)((char *)&v5->__vftable + 4);
      BOOL v5 = v24;
      if (v6 != v24)
      {
        BOOL v5 = v6;
        while ((v25(LODWORD(v5->__vftable)) & 1) == 0)
        {
          BOOL v5 = (std::__shared_weak_count *)((char *)v5 + 4);
          if (v5 == v24)
          {
            BOOL v5 = v24;
            goto LABEL_6;
          }
        }
      }
    }
  }
}

void sub_1004BD37C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1004CACEC((uint64_t *)va);
  if (a5) {
    sub_10004D2C8(a5);
  }
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v6);
  }
  _Unwind_Resume(a1);
}

void RegistrationController::sendLteEnabledSettingFromPreference_sync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != 3)
  {
    uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
    uint64_t v10 = ServiceMap;
    if (v11 < 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
        if (!v17) {
          goto LABEL_18;
        }
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unint64_t v16 = 0;
    char v18 = 1;
    if (!v17)
    {
LABEL_18:
      uint64_t v19 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not get Max Data Rate Manager to send LTE enabled setting to baseband", buf, 2u);
      }
LABEL_33:
      if ((v18 & 1) == 0) {
        sub_10004D2C8(v16);
      }
      return;
    }
LABEL_22:
    *(void *)long long buf = 0;
    __int16 v26 = 0;
    RegistrationController::getModel_sync(a1, a2, buf);
    char v20 = *(std::__shared_weak_count **)buf;
    if (*(void *)buf)
    {
      uint64_t v21 = v26;
      if (v26) {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      BOOL v29 = 0;
      int v22 = operator new(0x38uLL);
      *int v22 = off_1019D5268;
      v22[1] = a1;
      void v22[2] = v8;
      *((_DWORD *)v22 + 6) = a2;
      uint8_t v22[4] = v20;
      v22[5] = v21;
      if (v21) {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *((unsigned char *)v22 + 48) = a3;
      BOOL v29 = v22;
      (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 64))(v17, a2, v28);
      sub_1004CACEC(v28);
      if (v21) {
        sub_10004D2C8(v21);
      }
    }
    else
    {
      uint64_t v23 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v24 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not get model for sending LTE enabled setting", v24, 2u);
      }
    }
    if (v26) {
      sub_10004D2C8(v26);
    }
    goto LABEL_33;
  }
  subscriber::makeSimSlotRange();
  BOOL v5 = *(std::__shared_weak_count **)buf;
  if (*(std::__shared_weak_count **)buf != v26)
  {
    while ((v27(LODWORD(v5->__vftable)) & 1) == 0)
    {
      BOOL v5 = (std::__shared_weak_count *)((char *)v5 + 4);
      if (v5 == v26)
      {
        BOOL v5 = v26;
        break;
      }
    }
LABEL_6:
    while (v5 != v26)
    {
      RegistrationController::sendLteEnabledSettingFromPreference_sync(a1, LODWORD(v5->__vftable), a3);
      unint64_t v6 = (std::__shared_weak_count *)((char *)&v5->__vftable + 4);
      BOOL v5 = v26;
      if (v6 != v26)
      {
        BOOL v5 = v6;
        while ((v27(LODWORD(v5->__vftable)) & 1) == 0)
        {
          BOOL v5 = (std::__shared_weak_count *)((char *)v5 + 4);
          if (v5 == v26)
          {
            BOOL v5 = v26;
            goto LABEL_6;
          }
        }
      }
    }
  }
}

void sub_1004BD6F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1004CACEC((uint64_t *)va);
  if (v7)
  {
    sub_10004D2C8(v7);
    sub_10004D2C8(v7);
  }
  if ((v8 & 1) == 0) {
    sub_10004D2C8(v6);
  }
  _Unwind_Resume(a1);
}

void RegistrationController::send3GEnabledSettingFromPreference_sync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != 3)
  {
    char v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
    uint64_t v10 = ServiceMap;
    if (v11 < 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
        if (!v17) {
          goto LABEL_18;
        }
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unint64_t v16 = 0;
    char v18 = 1;
    if (!v17)
    {
LABEL_18:
      uint64_t v19 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not get Max Data Rate Manager to send 3G enabled setting to baseband", buf, 2u);
      }
LABEL_28:
      if ((v18 & 1) == 0) {
        sub_10004D2C8(v16);
      }
      return;
    }
LABEL_22:
    *(void *)long long buf = 0;
    uint64_t v24 = 0;
    RegistrationController::getModel_sync(a1, a2, buf);
    if (*(void *)buf)
    {
      uint64_t v27 = 0;
      char v20 = operator new(0x20uLL);
      *char v20 = off_1019D52E8;
      v20[1] = a1;
      _OWORD v20[2] = v8;
      *((_DWORD *)v20 + 6) = a2;
      *((unsigned char *)v20 + 28) = a3;
      uint64_t v27 = v20;
      (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 72))(v17, a2, v26);
      sub_1004CACEC(v26);
    }
    else
    {
      uint64_t v21 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int v22 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not get model for sending 3G enabled setting", v22, 2u);
      }
    }
    if (v24) {
      sub_10004D2C8(v24);
    }
    goto LABEL_28;
  }
  subscriber::makeSimSlotRange();
  BOOL v5 = *(std::__shared_weak_count **)buf;
  if (*(std::__shared_weak_count **)buf != v24)
  {
    while ((v25(LODWORD(v5->__vftable)) & 1) == 0)
    {
      BOOL v5 = (std::__shared_weak_count *)((char *)v5 + 4);
      if (v5 == v24)
      {
        BOOL v5 = v24;
        break;
      }
    }
LABEL_6:
    while (v5 != v24)
    {
      RegistrationController::send3GEnabledSettingFromPreference_sync(a1, LODWORD(v5->__vftable), a3);
      unint64_t v6 = (std::__shared_weak_count *)((char *)&v5->__vftable + 4);
      BOOL v5 = v24;
      if (v6 != v24)
      {
        BOOL v5 = v6;
        while ((v25(LODWORD(v5->__vftable)) & 1) == 0)
        {
          BOOL v5 = (std::__shared_weak_count *)((char *)v5 + 4);
          if (v5 == v24)
          {
            BOOL v5 = v24;
            goto LABEL_6;
          }
        }
      }
    }
  }
}

void sub_1004BDA48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1004CACEC((uint64_t *)va);
  if (a5) {
    sub_10004D2C8(a5);
  }
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v6);
  }
  _Unwind_Resume(a1);
}

void RegistrationController::send2GEnabledSettingFromPreference_sync(uint64_t a1, unsigned int a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
  BOOL v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    char v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v15);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
LABEL_11:
      v16[0] = off_1019D5368;
      v16[1] = a1;
      v16[2] = a2;
      v16[3] = v16;
      (*(void (**)(uint64_t, void *))(*(void *)v12 + 80))(v12, v16);
      sub_1004CACEC(v16);
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (v12) {
    goto LABEL_11;
  }
LABEL_7:
  unsigned int v14 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v15) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not get Max Data Rate Manager to send 2G enabled setting to baseband", (uint8_t *)&v15, 2u);
  }
LABEL_12:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1004BDC48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004CACEC((uint64_t *)va);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void *sub_1004BDC7C(capabilities::ct *a1)
{
  uint64_t result = (void *)capabilities::ct::supportsSystemSelectionDataRoaming(a1);
  if (result)
  {
    char v3 = (void *)*((void *)a1 + 8);
    if (v3 != (void *)((char *)a1 + 72))
    {
      do
      {
        uint64_t v4 = *((void *)a1 + 27);
        uint64_t v5 = *((unsigned int *)v3 + 8);
        v9[0] = off_1019D5158;
        v9[1] = a1;
        void v9[2] = v5;
        void v9[3] = v9;
        (*(void (**)(uint64_t))(*(void *)v4 + 48))(v4);
        uint64_t result = sub_100060644(v9);
        unint64_t v6 = (void *)v3[1];
        if (v6)
        {
          do
          {
            char v7 = v6;
            unint64_t v6 = (void *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            char v7 = (void *)v3[2];
            BOOL v8 = *v7 == (void)v3;
            char v3 = v7;
          }
          while (!v8);
        }
        char v3 = v7;
      }
      while (v7 != (void *)((char *)a1 + 72));
    }
  }
  return result;
}

void sub_1004BDD90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100060644((uint64_t *)va);
  _Unwind_Resume(a1);
}

void RegistrationController::sendCampOnlyModeSetting_sync(RegistrationController *this)
{
  if (capabilities::ct::supportsCMASCampOnlyMode(this))
  {
    unsigned int v2 = *((_DWORD *)this + 110) - 1;
    char v3 = *((void *)this + 5);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = "Disabling";
      if (v2 < 2) {
        uint64_t v4 = "Enabling";
      }
      int v12 = 136315138;
      char v13 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s CMAS camp only setting", (uint8_t *)&v12, 0xCu);
    }
    uint64_t v5 = (RegistrationController *)*((void *)this + 8);
    if (v5 != (RegistrationController *)((char *)this + 72))
    {
      do
      {
        uint64_t v6 = *((unsigned int *)v5 + 8);
        uint64_t v7 = *((void *)v5 + 5);
        BOOL v8 = (std::__shared_weak_count *)*((void *)v5 + 6);
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, void))(*(void *)v7 + 928))(v7, 0);
        (*(void (**)(void, uint64_t, BOOL))(**((void **)this + 11) + 168))(*((void *)this + 11), v6, v2 < 2);
        if (v8) {
          sub_10004D2C8(v8);
        }
        unsigned int v9 = (RegistrationController *)*((void *)v5 + 1);
        if (v9)
        {
          do
          {
            uint64_t v10 = v9;
            unsigned int v9 = *(RegistrationController **)v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            uint64_t v10 = (RegistrationController *)*((void *)v5 + 2);
            BOOL v11 = *(void *)v10 == (void)v5;
            uint64_t v5 = v10;
          }
          while (!v11);
        }
        uint64_t v5 = v10;
      }
      while (v10 != (RegistrationController *)((char *)this + 72));
    }
  }
}

void sub_1004BDF50(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::enableLteResult(uint64_t a1, uint64_t a2, char a3, char a4)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = sub_1004BE07C;
  void v6[3] = &unk_1019D4950;
  void v6[4] = a1;
  char v7 = a3;
  char v8 = a4;
  uint64_t v11 = 0;
  int v12 = 0;
  sub_10003E168(&v11, (void *)(a1 + 8));
  uint64_t v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v11;
  uint64_t v10 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
}

void sub_1004BE07C(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 40);
  unsigned int v2 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v1)
  {
    if (!v3) {
      return;
    }
    int v5 = 136315138;
    uint64_t v6 = asString();
    uint64_t v4 = "#I Enable LTE result from %s succeeded";
  }
  else
  {
    if (!v3) {
      return;
    }
    int v5 = 136315138;
    uint64_t v6 = asString();
    uint64_t v4 = "#N Enable LTE from %s failed";
  }
  _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)&v5, 0xCu);
}

void RegistrationController::fetchNetworkList_sync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  RegistrationController::getModel_sync(a1, a2, &v37);
  uint64_t v7 = v37;
  if (!v37)
  {
    uint64_t v9 = 0x1600000001;
    uint64_t v19 = *v6;
    if (!os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_49;
    }
    *(_WORD *)long long buf = 0;
    char v20 = "Could not get model for fetching network list";
LABEL_42:
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v20, buf, 2u);
    goto LABEL_49;
  }
  uint64_t v8 = *(void *)(a1 + 232);
  if (v8 && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v8 + 72))(v8, a2))
  {
    if ((*(uint64_t (**)(void))(**(void **)(a1 + 104) + 144))(*(void *)(a1 + 104)))
    {
      if ((*(unsigned int (**)(void))(**(void **)(a1 + 104) + 56))(*(void *)(a1 + 104)))
      {
        uint64_t v9 = 0x2300000001;
        uint64_t v10 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Network list cannot be fetched since we are in airplane mode", buf, 2u);
        }
        goto LABEL_49;
      }
      if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 232) + 80))(*(void *)(a1 + 232), a2))
      {
        uint64_t v24 = v38;
        v36[0] = v7;
        v36[1] = v38;
        if (v38) {
          atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1004BE8F4(a1, v36);
        if (v24) {
          sub_10004D2C8(v24);
        }
        uint64_t v9 = 0;
        goto LABEL_49;
      }
    }
    else
    {
      uint64_t v23 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#N Network list cannot be fetched since baseband is not ready", buf, 2u);
      }
      (*(void (**)(void))(**(void **)(a1 + 312) + 56))(*(void *)(a1 + 312));
    }
    uint64_t v9 = 0x2300000001;
LABEL_49:
    sub_100060854(a3, v9);
    goto LABEL_50;
  }
  uint64_t v34 = 0;
  char v35 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 184) + 16))(&v34);
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v34 + 96))(v34))
  {
    if (v35) {
      sub_10004D2C8(v35);
    }
    uint64_t v21 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    uint64_t v9 = 0x2D00000001;
    uint64_t v19 = *v21;
    if (!os_log_type_enabled(*v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_49;
    }
    *(_WORD *)long long buf = 0;
    char v20 = "Network list fetch is not supported";
    goto LABEL_42;
  }
  (*(void (**)(uint64_t))(*(void *)v34 + 56))(v34);
  uint64_t v25 = a3;
  uint64_t v11 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  unint64_t v33 = 0;
  while (v11 < (*(unsigned int (**)(uint64_t))(*(void *)v34 + 24))(v34))
  {
    v29[0] = 0;
    v29[1] = 0;
    uint64_t v30 = 0;
    v27[0] = 0;
    v27[1] = 0;
    uint64_t v28 = 0;
    char v12 = (*(uint64_t (**)(uint64_t, uint64_t, void **, void **))(*(void *)v34 + 32))(v34, v11, v29, v27);
    char v13 = *v6;
    if (v12)
    {
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        int v14 = (*(uint64_t (**)(uint64_t))(*(void *)v34 + 24))(v34);
        unint64_t v15 = v29;
        if (v30 < 0) {
          unint64_t v15 = (void **)v29[0];
        }
        unint64_t v16 = v27;
        if (v28 < 0) {
          unint64_t v16 = (void **)v27[0];
        }
        *(_DWORD *)long long buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v11;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v14;
        *(_WORD *)&buf[14] = 2080;
        *(void *)&v40[0] = v15;
        WORD4(v40[0]) = 2080;
        *(void *)((char *)v40 + 10) = v16;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Adding NAI operator %d of %d: %s with code %s", buf, 0x22u);
      }
      uint64_t v46 = 0;
      *(_OWORD *)std::string __p = 0u;
      long long v45 = 0u;
      *(_OWORD *)CFTypeID v42 = 0u;
      long long v43 = 0u;
      long long v41 = 0u;
      *(_OWORD *)long long buf = 0u;
      memset(v40, 0, sizeof(v40));
      NetworkListOperator::NetworkListOperator((NetworkListOperator *)buf);
      NetworkListOperator::setName();
      NetworkListOperator::decodeKey();
      uint64_t v17 = v32;
      if ((unint64_t)v32 >= v33)
      {
        char v18 = (char *)sub_1004C3A20(&v31, (long long *)buf);
      }
      else
      {
        sub_1004C3B28(v32, (long long *)buf);
        char v18 = v17 + 136;
      }
      uint64_t v32 = v18;
      if (SBYTE7(v45) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v43) < 0) {
        operator delete(v42[1]);
      }
      if (SHIBYTE(v41) < 0) {
        operator delete(*((void **)&v40[1] + 1));
      }
      if (SBYTE7(v40[0]) < 0) {
        operator delete(*(void **)buf);
      }
    }
    else if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v11;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not get NAI operator info for index %d", buf, 8u);
    }
    if (SHIBYTE(v28) < 0) {
      operator delete(v27[0]);
    }
    if (SHIBYTE(v30) < 0) {
      operator delete(v29[0]);
    }
    uint64_t v11 = (v11 + 1);
  }
  uint64_t v22 = *(void *)(a1 + 312);
  memset(v26, 0, sizeof(v26));
  sub_1004C3DEC(v26, v31, (uint64_t)v32, 0xF0F0F0F0F0F0F0F1 * ((uint64_t)&v32[-v31] >> 3));
  (*(void (**)(uint64_t, uint64_t, void, void **))(*(void *)v22 + 64))(v22, a2, 0, v26);
  *(void *)long long buf = v26;
  sub_1004C3EF8((void ***)buf);
  sub_100060854(v25, 0);
  *(void *)long long buf = &v31;
  sub_1004C3EF8((void ***)buf);
  if (v35) {
    sub_10004D2C8(v35);
  }
LABEL_50:
  if (v38) {
    sub_10004D2C8(v38);
  }
}

void sub_1004BE834(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,std::__shared_weak_count *a38,uint64_t a39)
{
  if (v39) {
    sub_10004D2C8(v39);
  }
  if (a38) {
    sub_10004D2C8(a38);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004BE8F4(uint64_t a1, void *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)*a2 + 656))(*a2);
  uint64_t v5 = *(void *)(a1 + 232);
  if (v5 && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 72))(v5, v4))
  {
    uint64_t v6 = *(void *)(a1 + 232);
    uint64_t v7 = (*(uint64_t (**)(void))(*(void *)*a2 + 656))(*a2);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, v7);
  }
  uint64_t v8 = *(uint64_t (**)(void))(*(void *)*a2 + 520);

  return v8();
}

uint64_t sub_1004BEA24(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void RegistrationController::adjustReportedDataModeOnDataInfo_sync(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (*a3 == 14)
  {
    uint64_t v4 = *(void *)(a1 + 520);
    if (v4)
    {
      uint64_t v7 = a1 + 520;
      do
      {
        int v8 = *(_DWORD *)(v4 + 28);
        BOOL v9 = v8 < (int)a2;
        if (v8 >= (int)a2) {
          uint64_t v10 = (uint64_t *)v4;
        }
        else {
          uint64_t v10 = (uint64_t *)(v4 + 8);
        }
        if (!v9) {
          uint64_t v7 = v4;
        }
        uint64_t v4 = *v10;
      }
      while (*v10);
      if (v7 != a1 + 520
        && *(_DWORD *)(v7 + 28) <= (int)a2
        && ((hasDataUiModifierBit() & 1) != 0 || hasDataUiModifierBit()))
      {
        *a3 = 16;
        uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = 136315138;
          uint64_t v13 = asString();
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I reported data mode adjusted to %s (ui modifier)", (uint8_t *)&v12, 0xCu);
        }
      }
    }
  }
}

uint64_t RegistrationController::getReportedDataMode_sync(uint64_t a1, void *a2)
{
  unsigned int v6 = (*(uint64_t (**)(void))(*(void *)*a2 + 512))(*a2);
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)*a2 + 656))();
  RegistrationController::adjustReportedDataModeOnDataInfo_sync(a1, v4, &v6);
  return v6;
}

uint64_t RegistrationController::reevaluateDataMode_sync(uint64_t a1, void *a2)
{
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  v7[0] = *a2;
  v7[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  RegistrationController::getDataModeInternal_sync(a1, v7);
  if (v4) {
    sub_10004D2C8(v4);
  }
  RegistrationController::getReportedDataMode_sync(a1, a2);
  uint64_t v5 = *(uint64_t (**)(void))(*(void *)*a2 + 504);

  return v5();
}

void sub_1004BED48(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RegistrationController::getDataModeInternal_sync(uint64_t a1, void *a2)
{
  uint64_t ReportedDataMode_sync = RegistrationController::getReportedDataMode_sync(a1, a2);
  if (*(_DWORD *)(a1 + 440)) {
    return 4294967294;
  }
  uint64_t v5 = ReportedDataMode_sync;
  unsigned int v6 = *(void **)(a1 + 448);
  if (v6 == (void *)(a1 + 456)) {
    goto LABEL_25;
  }
  char v7 = 0;
  do
  {
    if (*((unsigned char *)v6 + 56)) {
      BOOL v8 = *((unsigned char *)v6 + 57) == 0;
    }
    else {
      BOOL v8 = 0;
    }
    char v9 = v8;
    v7 |= v9;
    if (v8) {
      break;
    }
    uint64_t v10 = (void *)v6[1];
    if (v10)
    {
      do
      {
        uint64_t v11 = v10;
        uint64_t v10 = (void *)*v10;
      }
      while (v10);
    }
    else
    {
      do
      {
        uint64_t v11 = (void *)v6[2];
        BOOL v8 = *v11 == (void)v6;
        unsigned int v6 = v11;
      }
      while (!v8);
    }
    unsigned int v6 = v11;
  }
  while (v11 != (void *)(a1 + 456));
  if ((v7 & 1) == 0)
  {
LABEL_25:
    uint64_t v14 = (*(uint64_t (**)(void))(*(void *)*a2 + 656))(*a2);
    unint64_t v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v14);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      return v5;
    }
    int v26 = 136315138;
    uint64_t v27 = asString();
    unint64_t v16 = "#I CS call not active, data mode is %s";
    uint64_t v17 = v15;
    uint32_t v18 = 12;
LABEL_31:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&v26, v18);
    return v5;
  }
  unsigned int v12 = (*(uint64_t (**)(void))(*(void *)*a2 + 464))(*a2);
  if (v12 <= 8 && ((1 << v12) & 0x139) != 0)
  {
    if (v5)
    {
      uint64_t v5 = 4294967294;
    }
    else
    {
      uint64_t v19 = (*(uint64_t (**)(void))(*(void *)*a2 + 656))(*a2);
      char v20 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        (*(void (**)(void))(*(void *)*a2 + 464))(*a2);
        int v26 = 136315394;
        uint64_t v27 = asString();
        __int16 v28 = 2080;
        uint64_t v29 = asString();
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s CS call active when no data available, keeping %s data mode", (uint8_t *)&v26, 0x16u);
        uint64_t v5 = 0;
      }
    }
  }
  uint64_t v21 = (*(uint64_t (**)(void))(*(void *)*a2 + 656))(*a2);
  uint64_t v22 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v21);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void))(*(void *)*a2 + 464))(*a2);
    uint64_t v23 = asString();
    uint64_t v24 = asString();
    int v26 = 136315394;
    uint64_t v27 = v23;
    __int16 v28 = 2080;
    uint64_t v29 = v24;
    unint64_t v16 = "#I %s CS call active, data mode is %s";
    uint64_t v17 = v22;
    uint32_t v18 = 22;
    goto LABEL_31;
  }
  return v5;
}

void RegistrationController::handleLastCallTypeChanged_sync(uint64_t a1)
{
  if (LastCallSubType::operator!=())
  {
    uint64_t v2 = *(unsigned __int8 *)(a1 + 472);
    uint64_t v8 = 0;
    char v9 = 0;
    RegistrationController::getModel_sync(a1, *(_DWORD *)(a1 + 476), &v8);
    uint64_t v3 = v8;
    if (v8)
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 368))(v8, v2);
      (*(void (**)(uint64_t))(*(void *)v3 + 352))(v3);
      uint64_t v4 = v9;
      v7[0] = v3;
      v7[1] = v9;
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      RegistrationController::reevaluateDataMode_sync(a1, v7);
      if (v4) {
        sub_10004D2C8(v4);
      }
    }
    else
    {
      uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 476));
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)unsigned int v6 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not find model for last call type change", v6, 2u);
      }
    }
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
}

void sub_1004BF2AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::handleCallStateChange_sync(uint64_t a1, uint64_t a2)
{
  void (***v18)(uint64_t *__return_ptr, void, uint64_t);
  char v19;
  uint64_t v20;
  void *v21;
  std::__shared_weak_count *v22;
  void *v23;
  void *v24;
  BOOL v25;
  uint64_t v26;
  NSObject *v27;
  const char *v28;
  const char *v29;
  const char *v30;
  NSObject *v31;
  NSObject *v32;
  void **v33;
  void **v34;
  const char *v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  void v41[2];
  uint64_t v42;
  std::__shared_weak_count *v43;
  unsigned char buf[12];
  __int16 v45;
  const char *v46;
  __int16 v47;
  const char *v48;

  uint64_t v2 = *(void ***)(a1 + 448);
  uint64_t v3 = (void **)(a1 + 456);
  if (v2 != (void **)(a1 + 456))
  {
    unsigned int v6 = (void **)(a2 + 8);
    char v7 = (void *)(a1 + 72);
    uint64_t v38 = a2 + 8;
    while (1)
    {
      uint64_t v8 = sub_100046F68(a2, v2 + 4);
      int v9 = *((unsigned __int8 *)v2 + 56);
      if (v6 == v8 || *((unsigned __int8 *)v8 + 56) != v9) {
        break;
      }
LABEL_48:
      unint64_t v33 = (void **)v2[1];
      if (v33)
      {
        do
        {
          uint64_t v34 = v33;
          unint64_t v33 = (void **)*v33;
        }
        while (v33);
      }
      else
      {
        do
        {
          uint64_t v34 = (void **)v2[2];
          uint64_t v25 = *v34 == v2;
          uint64_t v2 = v34;
        }
        while (!v25);
      }
      uint64_t v2 = v34;
      if (v34 == v3) {
        return;
      }
    }
    (*(void (**)(void, BOOL))(**(void **)(a1 + 104) + 80))(*(void *)(a1 + 104), v9 != 0);
    CFTypeID v42 = 0;
    long long v43 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
    uint64_t v11 = ServiceMap;
    if (v12 < 0)
    {
      uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v12;
    unint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
    if (v16)
    {
      uint32_t v18 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v16[3];
      uint64_t v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        unsigned int v6 = (void **)v38;
        sub_10004D2C8(v17);
        uint64_t v19 = 0;
LABEL_13:
        (**v18)(&v42, v18, (uint64_t)(v2 + 4));
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        char v20 = v42;
        if (v42)
        {
          uint64_t v21 = *(void **)(a1 + 64);
          if (v21 != v7)
          {
            do
            {
              uint64_t v22 = (std::__shared_weak_count *)v21[6];
              v41[0] = v21[5];
              v41[1] = v22;
              if (v22) {
                atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              RegistrationController::reevaluateDataMode_sync(a1, v41);
              if (v22) {
                sub_10004D2C8(v22);
              }
              uint64_t v23 = (void *)v21[1];
              if (v23)
              {
                do
                {
                  uint64_t v24 = v23;
                  uint64_t v23 = (void *)*v23;
                }
                while (v23);
              }
              else
              {
                do
                {
                  uint64_t v24 = (void *)v21[2];
                  uint64_t v25 = *v24 == (void)v21;
                  uint64_t v21 = v24;
                }
                while (!v25);
              }
              uint64_t v21 = v24;
            }
            while (v24 != v7);
            char v20 = v42;
          }
          uint64_t v39 = 0;
          int v40 = 0;
          RegistrationController::getModel_sync(a1, *(_DWORD *)(v20 + 52), &v39);
          int v26 = v39;
          if (v39)
          {
            uint64_t v27 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(v42 + 52));
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              if (*((unsigned char *)v2 + 56)) {
                __int16 v28 = "true";
              }
              else {
                __int16 v28 = "false";
              }
              if (*((unsigned char *)v2 + 57)) {
                uint64_t v29 = "true";
              }
              else {
                uint64_t v29 = "false";
              }
              if (*((unsigned char *)v2 + 58)) {
                uint64_t v30 = "true";
              }
              else {
                uint64_t v30 = "false";
              }
              *(_DWORD *)long long buf = 136315650;
              *(void *)&uint8_t buf[4] = v28;
              long long v45 = 2080;
              uint64_t v46 = v29;
              CFTypeID v47 = 2080;
              CFBooleanRef v48 = v30;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Call state is now active (%s) VoIP (%s) CS (%s)", buf, 0x20u);
            }
            (*(void (**)(uint64_t, void))(*(void *)v26 + 360))(v26, *((unsigned __int8 *)v2 + 56));
            (*(void (**)(uint64_t))(*(void *)v26 + 352))(v26);
          }
          else
          {
            uint64_t v32 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
            {
              char v35 = (const char *)(v42 + 24);
              uint64_t v36 = *(unsigned __int8 *)(v42 + 47);
              uint64_t v37 = (char)v36;
              if ((v36 & 0x80u) != 0) {
                uint64_t v36 = *(void *)(v42 + 32);
              }
              if (v37 < 0) {
                char v35 = *(const char **)(v42 + 24);
              }
              if (!v36) {
                char v35 = "<invalid>";
              }
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v35;
              _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Could not find model for personality %s", buf, 0xCu);
            }
          }
          if (v40) {
            sub_10004D2C8(v40);
          }
        }
        else
        {
          uint64_t v31 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Could not get personality info for call state change", buf, 2u);
          }
        }
        if (v43) {
          sub_10004D2C8(v43);
        }
        goto LABEL_48;
      }
    }
    else
    {
      uint32_t v18 = 0;
    }
    std::mutex::unlock(v11);
    uint64_t v17 = 0;
    uint64_t v19 = 1;
    goto LABEL_13;
  }
}

void sub_1004BF7A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  if (a20) {
    sub_10004D2C8(a20);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::handleNetworkListFetchComplete_sync(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  int v9 = 0;
  RegistrationController::getModel_sync(a1, a2, &v8);
  if (v8)
  {
    uint64_t v4 = v9;
    v7[0] = v8;
    v7[1] = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1004BE8F4(a1, v7);
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v11 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not find model (%s) for network list fetch complete", buf, 0xCu);
    }
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_1004BF92C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

const void **RegistrationController::handleNewServingNetwork_sync(uint64_t a1, void *a2)
{
  uint64_t v22 = 0;
  uint64_t v4 = *(void *)(a1 + 248);
  uint64_t v5 = (*(uint64_t (**)(void))(*(void *)*a2 + 656))(*a2);
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v4 + 80))(v18, v4, v5, 1, @"ECBMTimer", 0, 0);
  sub_1000842D0(&v22, v18);
  sub_1000577C4(v18);
  if (v22) {
    char v7 = sub_100081E58;
  }
  else {
    char v7 = 0;
  }
  if (v7)
  {
    LODWORD(v18[0]) = 0;
    ctu::cf::assign((ctu::cf *)v18, v22, v6);
    (*(void (**)(void, void))(**(void **)(a1 + 104) + 120))(*(void *)(a1 + 104), SLODWORD(v18[0]));
  }
  uint64_t v8 = *(void *)(a1 + 344);
  uint64_t v9 = (*(uint64_t (**)(void))(*(void *)*a2 + 656))(*a2);
  (*(void (**)(void **__return_ptr))(*(void *)*a2 + 424))(v16);
  (*(void (**)(void **__return_ptr))(*(void *)*a2 + 432))(v14);
  MCCAndMNC::MCCAndMNC((MCCAndMNC *)v18, (const MCC *)v16, (const MNC *)v14);
  uint64_t v10 = (*(uint64_t (**)(void))(*(void *)*a2 + 464))(*a2);
  uint64_t v11 = (*(uint64_t (**)(void))(*(void *)*a2 + 112))();
  uint64_t v12 = (*(uint64_t (**)(void))(*(void *)*a2 + 912))(*a2);
  (*(void (**)(uint64_t, uint64_t, const void **, uint64_t, uint64_t, uint64_t))(*(void *)v8 + 80))(v8, v9, v18, v10, v11, v12);
  if (v21 < 0) {
    operator delete(__p);
  }
  if (v19 < 0) {
    operator delete((void *)v18[1]);
  }
  if (v15 < 0) {
    operator delete(v14[1]);
  }
  if (v17 < 0) {
    operator delete(v16[1]);
  }
  return sub_1000570E8((const void **)&v22);
}

void sub_1004BFC44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  sub_1000570E8((const void **)(v24 - 56));
  _Unwind_Resume(a1);
}

void RegistrationController::handlePersonalityEvent_sync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned __int8 *)(a2 + 24) | 4) == 5)
  {
    uint64_t v5 = *(void *)(a1 + 216);
    uint64_t v6 = *(unsigned int *)(*(void *)a3 + 52);
    v12[0] = off_1019D5058;
    v12[1] = a1;
    v12[3] = v12;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v5 + 80))(v5, v6, v12);
    char v7 = (capabilities::ct *)sub_100060644(v12);
    if (capabilities::ct::supports5G(v7))
    {
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      RegistrationController::getModel_sync(a1, *(_DWORD *)(*(void *)a3 + 52), &v10);
      if (v10)
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 856))(v10))
        {
          RegistrationController::send5GStandaloneEnabledSettingFromPreference_sync(a1, *(unsigned int *)(*(void *)a3 + 52), 3);
          RegistrationController::update5GSACapabilityRestProperty_sync((capabilities::ct *)a1, *(unsigned int *)(*(void *)a3 + 52));
        }
      }
      else
      {
        uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(*(void *)a3 + 52));
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v9 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Could not find model to evaluate Personality event", v9, 2u);
        }
      }
      if (v11) {
        sub_10004D2C8(v11);
      }
    }
  }
}

void sub_1004BFE78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, char a12)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::sendLteEnabledSetting_sync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  RegistrationController::getModel_sync(a1, a2, &v11);
  if (v11)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v11 + 272))(v11, a3, a4);
    sub_1004BFFE0(a1, a2);
  }
  else
  {
    uint64_t v9 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v10 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not find model for sending LTE enabled setting", v10, 2u);
    }
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
}

void sub_1004BFFC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004BFFE0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  RegistrationController::getModel_sync(a1, a2, &v21);
  uint64_t v5 = v21;
  if (v21)
  {
    char v6 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 264))(v21);
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v20 = 0;
    PersonalityIdFromSlotId();
    char v7 = sub_100046F68(a1 + 648, __p);
    if ((void **)(a1 + 656) == v7)
    {
      int v9 = 0;
      int v8 = 0;
    }
    else
    {
      int v8 = *((_DWORD *)v7 + 14);
      int v9 = *((unsigned __int8 *)v7 + 64);
    }
    if (v6) {
      BOOL v11 = 0;
    }
    else {
      BOOL v11 = v8 == 1;
    }
    if (v11 && v9 == 0)
    {
      uint32_t v18 = *v4;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Disabling LTE when IMS context is on Cellular, we need to deactivate IMS context first", buf, 2u);
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 256))(v5, 1);
      *(_DWORD *)long long buf = a2;
      *(_DWORD *)&uint8_t buf[4] = 0;
      sub_1004C0384(a1 + 424, (int *)buf);
    }
    else
    {
      uint64_t v13 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Bringing down PDP is not required, sending the setting right away", buf, 2u);
      }
      uint64_t v14 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      *(void *)long long buf = 0;
      uint64_t v25 = 0;
      RegistrationController::getModel_sync(a1, a2, buf);
      if (*(void *)buf)
      {
        __int16 v15 = (*(uint64_t (**)(void))(**(void **)buf + 264))(*(void *)buf);
        int v16 = v15;
        (*(void (**)(void, uint64_t, BOOL, void))(**(void **)(a1 + 88) + 64))(*(void *)(a1 + 88), a2, v15 != 0, HIBYTE(v15));
        if ((byte_101B0D108 & 1) == 0 && v16)
        {
          byte_101B0D108 = 1;
          RegistrationController::setLTEToProvisioning_sync((Registry **)a1, 0, 0);
        }
      }
      else
      {
        char v17 = *v14;
        if (os_log_type_enabled(*v14, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v23 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not get model for sending LTE enabled setting finally", v23, 2u);
        }
      }
      if (v25) {
        sub_10004D2C8(v25);
      }
    }
    if (SHIBYTE(v20) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v10 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not get model for applying LTE enabled settings", (uint8_t *)__p, 2u);
    }
  }
  if (v22) {
    sub_10004D2C8(v22);
  }
}

void sub_1004C0334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004C0384(uint64_t a1, int *a2)
{
  xpc_object_t v5 = 0;
  sub_1004C9EE0(a2, &v5);
  sub_100058DB0(&__p, "/cc/events/bring_down_ims");
  xpc_object_t object = v5;
  xpc_object_t v5 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_1004C0418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void RegistrationController::handleImsRegistrationStarted_sync(uint64_t a1, uint64_t a2)
{
  void (***v14)(uint64_t *__return_ptr, void, uint64_t);
  char v15;
  uint64_t v16;
  NSObject **v17;
  void **v18;
  NSObject *v19;
  const char *v20;
  uint64_t v21;
  int v22;
  NSObject *v23;
  void **v24;
  void **v25;
  BOOL v26;
  uint64_t v27;
  void **v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  uint8_t v31[4];
  uint64_t v32;
  uint8_t buf[24];

  uint64_t v2 = *(void ***)(a1 + 680);
  uint64_t v3 = (void **)(a1 + 688);
  if (v2 != (void **)(a1 + 688))
  {
    __int16 v28 = (void **)(a2 + 8);
    do
    {
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
      char v7 = ServiceMap;
      if (v8 < 0)
      {
        int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v10 = 5381;
        do
        {
          uint64_t v8 = v10;
          unsigned int v11 = *v9++;
          uint64_t v10 = (33 * v10) ^ v11;
        }
        while (v11);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v8;
      uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
      if (v12)
      {
        uint64_t v14 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v12[3];
        uint64_t v13 = (std::__shared_weak_count *)v12[4];
        if (v13)
        {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v7);
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v13);
          __int16 v15 = 0;
          goto LABEL_11;
        }
      }
      else
      {
        uint64_t v14 = 0;
      }
      std::mutex::unlock(v7);
      uint64_t v13 = 0;
      __int16 v15 = 1;
LABEL_11:
      (**v14)(&v29, v14, (uint64_t)(v2 + 4));
      if ((v15 & 1) == 0) {
        sub_10004D2C8(v13);
      }
      if (!v29) {
        goto LABEL_33;
      }
      if (*(unsigned char *)(v29 + 49)) {
        uint64_t v16 = 0;
      }
      else {
        uint64_t v16 = *(unsigned int *)(v29 + 52);
      }
      char v17 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v16);
      uint32_t v18 = sub_100046F68(a2, v2 + 4);
      if (v28 == v18) {
        goto LABEL_27;
      }
      if (*((unsigned __int8 *)v2 + 56) != *((unsigned __int8 *)v18 + 56))
      {
        char v19 = *v17;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = (const char *)(v29 + 24);
          uint64_t v21 = *(unsigned __int8 *)(v29 + 47);
          uint64_t v22 = (char)v21;
          if ((v21 & 0x80u) != 0) {
            uint64_t v21 = *(void *)(v29 + 32);
          }
          if (v22 < 0) {
            uint64_t v20 = *(const char **)(v29 + 24);
          }
          if (!v21) {
            uint64_t v20 = "<invalid>";
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I IMS registration started for Personality %s", buf, 0xCu);
        }
LABEL_27:
        *(_OWORD *)long long buf = 0uLL;
        RegistrationController::getModel_sync(a1, v16, buf);
        if (*(void *)buf)
        {
          (*(void (**)(void, void))(**(void **)buf + 216))(*(void *)buf, *((unsigned __int8 *)v2 + 56));
          (*(void (**)(void, uint64_t))(**(void **)(a1 + 312) + 40))(*(void *)(a1 + 312), v16);
        }
        else
        {
          uint64_t v23 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            uint64_t v27 = subscriber::asString();
            *(_DWORD *)uint64_t v31 = 136315138;
            uint64_t v32 = v27;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find model %s for IMS registration start event", v31, 0xCu);
          }
        }
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
LABEL_33:
      if (v30) {
        sub_10004D2C8(v30);
      }
      uint64_t v24 = (void **)v2[1];
      if (v24)
      {
        do
        {
          uint64_t v25 = v24;
          uint64_t v24 = (void **)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          uint64_t v25 = (void **)v2[2];
          int v26 = *v25 == v2;
          uint64_t v2 = v25;
        }
        while (!v26);
      }
      uint64_t v2 = v25;
    }
    while (v25 != v3);
  }
}

void sub_1004C07D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::handleLazuliRegistrationStateChange_sync(uint64_t a1, int *a2)
{
  int v4 = *a2;
  xpc_object_t v5 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  RegistrationController::getModel_sync(a1, v4, &v9);
  uint64_t v6 = v9;
  if (v9)
  {
    (*(void (**)(uint64_t, void))(*(void *)v9 + 192))(v9, a2[1]);
    (*(void (**)(uint64_t))(*(void *)v6 + 352))(v6);
  }
  else
  {
    char v7 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v12 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Could not find model %s for Lazuli registration state change", buf, 0xCu);
    }
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_1004C09A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::handleImsRegistrationStateChange_sync(uint64_t a1, uint64_t a2)
{
  void (***v14)(uint64_t *__return_ptr, void, uint64_t);
  char v15;
  uint64_t v16;
  os_log_t *v17;
  void **v18;
  NSObject *v19;
  const char *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  BOOL v24;
  NSObject *v25;
  uint64_t v26;
  NSObject *v27;
  void **v28;
  void **v29;
  BOOL v30;
  void **v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  uint8_t v34[4];
  uint64_t v35;
  uint8_t buf[24];

  uint64_t v2 = *(void ***)(a1 + 648);
  uint64_t v3 = (void **)(a1 + 656);
  if (v2 != (void **)(a1 + 656))
  {
    uint64_t v31 = (void **)(a2 + 8);
    do
    {
      uint64_t v32 = 0;
      unint64_t v33 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
      char v7 = ServiceMap;
      if (v8 < 0)
      {
        uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v10 = 5381;
        do
        {
          uint64_t v8 = v10;
          unsigned int v11 = *v9++;
          uint64_t v10 = (33 * v10) ^ v11;
        }
        while (v11);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v8;
      uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
      if (v12)
      {
        uint64_t v14 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v12[3];
        uint64_t v13 = (std::__shared_weak_count *)v12[4];
        if (v13)
        {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v7);
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v13);
          __int16 v15 = 0;
          goto LABEL_11;
        }
      }
      else
      {
        uint64_t v14 = 0;
      }
      std::mutex::unlock(v7);
      uint64_t v13 = 0;
      __int16 v15 = 1;
LABEL_11:
      (**v14)(&v32, v14, (uint64_t)(v2 + 4));
      if ((v15 & 1) == 0) {
        sub_10004D2C8(v13);
      }
      if (!v32) {
        goto LABEL_41;
      }
      if (*(unsigned char *)(v32 + 49)) {
        uint64_t v16 = 0;
      }
      else {
        uint64_t v16 = *(unsigned int *)(v32 + 52);
      }
      char v17 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v16);
      uint32_t v18 = sub_100046F68(a2, v2 + 4);
      if (v31 == v18) {
        goto LABEL_27;
      }
      if (!sub_10047161C((uint64_t)(v2 + 7), (uint64_t)(v18 + 7)))
      {
        char v19 = *v17;
        if (os_log_type_enabled(*v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = (const char *)(v32 + 24);
          uint64_t v21 = *(unsigned __int8 *)(v32 + 47);
          uint64_t v22 = (char)v21;
          if ((v21 & 0x80u) != 0) {
            uint64_t v21 = *(void *)(v32 + 32);
          }
          if (v22 < 0) {
            uint64_t v20 = *(const char **)(v32 + 24);
          }
          if (!v21) {
            uint64_t v20 = "<invalid>";
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I IMS registration state for Personality %s changed", buf, 0xCu);
        }
LABEL_27:
        *(_OWORD *)long long buf = 0uLL;
        RegistrationController::getModel_sync(a1, v16, buf);
        uint64_t v23 = *(void *)buf;
        if (*(void *)buf)
        {
          if (*((unsigned char *)v2 + 64)) {
            uint64_t v24 = *((_DWORD *)v2 + 17) == 0;
          }
          else {
            uint64_t v24 = 0;
          }
          (*(void (**)(void, BOOL, BOOL, BOOL, BOOL))(**(void **)buf + 200))(*(void *)buf, *((_DWORD *)v2 + 14) == 1, *((_DWORD *)v2 + 14) == 2, *((unsigned char *)v2 + 64) != 0, v24);
          (*(void (**)(uint64_t, void))(*(void *)v23 + 232))(v23, *((unsigned int *)v2 + 15));
          (*(void (**)(uint64_t))(*(void *)v23 + 352))(v23);
          (*(void (**)(void, uint64_t))(**(void **)(a1 + 312) + 40))(*(void *)(a1 + 312), v16);
          if ((*(unsigned int (**)(uint64_t))(*(void *)v23 + 248))(v23)
            && (*((_DWORD *)v2 + 14) != 1 || *((unsigned char *)v2 + 64)))
          {
            uint64_t v27 = *v17;
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t v34 = 0;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I IMS over Cellular has been deregistered, set LTE setting to BB", v34, 2u);
            }
            (*(void (**)(uint64_t, void))(*(void *)v23 + 256))(v23, 0);
            sub_1004BFFE0(a1, v16);
          }
        }
        else
        {
          uint64_t v25 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            int v26 = subscriber::asString();
            *(_DWORD *)uint64_t v34 = 136315138;
            char v35 = v26;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find model %s for IMS registration state change", v34, 0xCu);
          }
        }
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
LABEL_41:
      if (v33) {
        sub_10004D2C8(v33);
      }
      __int16 v28 = (void **)v2[1];
      if (v28)
      {
        do
        {
          uint64_t v29 = v28;
          __int16 v28 = (void **)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          uint64_t v29 = (void **)v2[2];
          uint64_t v30 = *v29 == v2;
          uint64_t v2 = v29;
        }
        while (!v30);
      }
      uint64_t v2 = v29;
    }
    while (v29 != v3);
  }
}

void sub_1004C0E80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::setLTEToProvisioning_sync(Registry **this, int a2, int a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(this[17]);
  char v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_14;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
  if (!v14) {
    goto LABEL_14;
  }
LABEL_10:
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v14 + 168))(v14, 2))
  {
    uint64_t v16 = this[5];
    BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
    if (a2)
    {
      if (v17)
      {
        *(_WORD *)long long buf = 0;
        uint64_t v18 = 2;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I setLTEToProvisioning_sync: LTE provisioning attach APN is supported, toggling provisioning mode", buf, 2u);
      }
      else
      {
        uint64_t v18 = 2;
      }
    }
    else
    {
      if (v17)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I setLTEToProvisioning_sync: LTE provisioning attach APN is supported, switching provisioning mode off", buf, 2u);
      }
      uint64_t v18 = 1;
    }
    sub_10003E168(buf, this + 1);
    long long v21 = *(_OWORD *)buf;
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
      sub_10004D2C8(*((std::__shared_weak_count **)&v21 + 1));
    }
    uint64_t v22 = operator new(0x20uLL);
    *uint64_t v22 = off_1019D50D8;
    v22[1] = this;
    *((_OWORD *)v22 + 1) = v21;
    v23[3] = v22;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v14 + 64))(v14, 1, v18, v23);
    sub_10003B34C(v23);
    if ((v15 & 1) == 0) {
      goto LABEL_21;
    }
    return;
  }
LABEL_14:
  if (a3)
  {
    char v19 = this[5];
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = "true";
      if (a2) {
        uint64_t v20 = "false";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I setLTEToProvisioning_sync: LTE provisioning attach APN is not supported switching LTE to %s", buf, 0xCu);
    }
    RegistrationController::sendLteEnabledSetting_sync((uint64_t)this, 1, a2 ^ 1u, 2);
  }
  if ((v15 & 1) == 0) {
LABEL_21:
  }
    sub_10004D2C8(v13);
}

void sub_1004C11C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10003B34C(&a9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

uint64_t RegistrationController::getImsStateForBaseband_sync(uint64_t a1, uint64_t a2)
{
  int v4 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)CFNumberRef valuePtr = v7;
  unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)valuePtr);
  if (!v11)
  {
    std::mutex::unlock(v6);
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (!v12)
  {
    std::mutex::unlock(v6);
    if (v13) {
      goto LABEL_11;
    }
    return 0xFFFFFFFFLL;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  if (!v13)
  {
    uint64_t v14 = 0xFFFFFFFFLL;
LABEL_56:
    sub_10004D2C8(v12);
    return v14;
  }
LABEL_11:
  uint64_t v65 = 0;
  xpc_object_t v66 = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v13 + 8))(&v65, v13, a2);
  if (!v65)
  {
    uint64_t v14 = 0xFFFFFFFFLL;
    goto LABEL_53;
  }
  char v15 = sub_100046F68(a1 + 624, (void **)(v65 + 24));
  if ((void **)(a1 + 632) != v15)
  {
    unsigned int v16 = *((_DWORD *)v15 + 14);
    if (v16) {
      uint64_t v14 = 2;
    }
    else {
      uint64_t v14 = (v16 >> 1) & 1;
    }
    BOOL v17 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
    uint64_t v18 = v17;
    if (v19 < 0)
    {
      uint64_t v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        uint64_t v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(v17);
    *(void *)CFNumberRef valuePtr = v19;
    uint64_t v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)valuePtr);
    if (v23)
    {
      uint64_t v25 = v23[3];
      uint64_t v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        char v26 = 0;
LABEL_32:
        uint64_t v37 = v65;
        uint64_t v67 = 0;
        *(_DWORD *)CFNumberRef valuePtr = v14;
        uint64_t v38 = (int *)CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, valuePtr);
        if (v38)
        {
          uint64_t v39 = v67;
          uint64_t v67 = v38;
          *(void *)CFNumberRef valuePtr = v39;
          sub_1000570E8((const void **)valuePtr);
        }
        int v40 = v67;
        xpc_object_t v64 = v67;
        uint64_t v67 = 0;
        sub_1000570E8((const void **)&v67);
        (*(void (**)(uint64_t, uint64_t, const __CFString *, int *, const __CFString *, void, uint64_t, void, int *))(*(void *)v25 + 16))(v25, v37 + 24, @"lastKnownIMSFeatureState", v40, @"RegistrationController", 0, 1, 0, v64);
        sub_1000570E8((const void **)&v64);
        if ((v26 & 1) == 0) {
          sub_10004D2C8(v24);
        }
        long long v41 = *v4;
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v42 = asString();
          *(_DWORD *)CFNumberRef valuePtr = 136315138;
          *(void *)&valuePtr[4] = v42;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I report IMS feature state as %s", valuePtr, 0xCu);
        }
        goto LABEL_53;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    std::mutex::unlock(v18);
    uint64_t v24 = 0;
    char v26 = 1;
    goto LABEL_32;
  }
  uint64_t v27 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
  __int16 v28 = v27;
  if (v29 < 0)
  {
    uint64_t v30 = (unsigned __int8 *)(v29 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v31 = 5381;
    do
    {
      uint64_t v29 = v31;
      unsigned int v32 = *v30++;
      uint64_t v31 = (33 * v31) ^ v32;
    }
    while (v32);
  }
  std::mutex::lock(v27);
  *(void *)CFNumberRef valuePtr = v29;
  unint64_t v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)valuePtr);
  if (!v33)
  {
    uint64_t v35 = 0;
LABEL_39:
    std::mutex::unlock(v28);
    uint64_t v34 = 0;
    char v36 = 1;
    if (!v35) {
      goto LABEL_51;
    }
    goto LABEL_40;
  }
  uint64_t v35 = v33[3];
  uint64_t v34 = (std::__shared_weak_count *)v33[4];
  if (!v34) {
    goto LABEL_39;
  }
  atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v28);
  atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v34);
  char v36 = 0;
  if (!v35) {
    goto LABEL_51;
  }
LABEL_40:
  (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v35 + 96))(valuePtr, v35, a2, 1, @"OnLineMandatoryImsState", kCFBooleanFalse, 0);
  long long v43 = *(BOOL **)valuePtr;
  LOBYTE(v67) = 0;
  if (!*(void *)valuePtr)
  {
    sub_1000577C4((const void **)valuePtr);
    goto LABEL_51;
  }
  CFTypeID v44 = CFGetTypeID(*(CFTypeRef *)valuePtr);
  if (v44 == CFBooleanGetTypeID()) {
    ctu::cf::assign((ctu::cf *)&v67, v43, v45);
  }
  int v46 = v67;
  sub_1000577C4((const void **)valuePtr);
  if (!v46)
  {
LABEL_51:
    uint64_t v14 = 0xFFFFFFFFLL;
    if (v36) {
      goto LABEL_53;
    }
    goto LABEL_52;
  }
  uint64_t v67 = 0;
  CFTypeID v47 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
  CFBooleanRef v48 = v47;
  if (v49 < 0)
  {
    xpc_object_t v50 = (unsigned __int8 *)(v49 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v51 = 5381;
    do
    {
      uint64_t v49 = v51;
      unsigned int v52 = *v50++;
      uint64_t v51 = (33 * v51) ^ v52;
    }
    while (v52);
  }
  std::mutex::lock(v47);
  *(void *)CFNumberRef valuePtr = v49;
  uint64_t v53 = sub_10004D37C(&v48[1].__m_.__sig, (unint64_t *)valuePtr);
  if (v53)
  {
    uint64_t v55 = v53[3];
    uint64_t v54 = (std::__shared_weak_count *)v53[4];
    if (v54)
    {
      atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v48);
      atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v54);
      char v56 = 0;
      goto LABEL_60;
    }
  }
  else
  {
    uint64_t v55 = 0;
  }
  std::mutex::unlock(v48);
  uint64_t v54 = 0;
  char v56 = 1;
LABEL_60:
  (*(void (**)(int **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v55 + 24))(&v64, v55, v65 + 24, @"lastKnownIMSFeatureState", @"RegistrationController", 0, 1);
  sub_1000842D0(&v67, (CFTypeRef *)&v64);
  sub_1000577C4((const void **)&v64);
  if ((v56 & 1) == 0) {
    sub_10004D2C8(v54);
  }
  if (v67) {
    xpc_object_t v59 = sub_100081E58;
  }
  else {
    xpc_object_t v59 = 0;
  }
  if (v59)
  {
    *(_DWORD *)CFNumberRef valuePtr = 0;
    ctu::cf::assign((ctu::cf *)valuePtr, v67, v58);
    uint64_t v14 = *(unsigned int *)valuePtr;
  }
  else
  {
    uint64_t v14 = 2;
  }
  CFBooleanRef v60 = *v4;
  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v61 = asString();
    xpc_object_t v62 = "from cache";
    if (v67) {
      uint64_t v63 = sub_100081E58;
    }
    else {
      uint64_t v63 = 0;
    }
    if (!v63) {
      xpc_object_t v62 = "artificially";
    }
    *(_DWORD *)CFNumberRef valuePtr = 136315394;
    *(void *)&valuePtr[4] = v61;
    __int16 v69 = 2080;
    xpc_object_t v70 = v62;
    _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I report IMS feature state %s %s", valuePtr, 0x16u);
  }
  sub_1000570E8((const void **)&v67);
  if ((v36 & 1) == 0) {
LABEL_52:
  }
    sub_10004D2C8(v34);
LABEL_53:
  if (v66) {
    sub_10004D2C8(v66);
  }
  if (v12) {
    goto LABEL_56;
  }
  return v14;
}

void sub_1004C189C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, ...)
{
  va_start(va, a4);
  sub_1000570E8((const void **)va);
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v5);
  }
  if (a4) {
    sub_10004D2C8(a4);
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t RegistrationController::getVoNRStateForBaseband_sync(uint64_t a1, uint64_t a2)
{
  int v4 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
  char v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v19 = v7;
  unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, &v19);
  if (!v11)
  {
    std::mutex::unlock(v6);
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v6);
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v12);
    if (!v13)
    {
      uint64_t v14 = 0xFFFFFFFFLL;
LABEL_19:
      sub_10004D2C8(v12);
      return v14;
    }
    goto LABEL_11;
  }
  std::mutex::unlock(v6);
  if (!v13) {
    return 0xFFFFFFFFLL;
  }
LABEL_11:
  unint64_t v19 = 0;
  uint64_t v20 = 0;
  (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v13 + 8))(&v19, v13, a2);
  if (!v19 || (char v15 = sub_100046F68(a1 + 624, (void **)(v19 + 24)), (void **)(a1 + 632) == v15))
  {
    uint64_t v14 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v14 = *((unsigned __int8 *)v15 + 64);
    unsigned int v16 = *v4;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v22 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I report VoNR state as %s", buf, 0xCu);
    }
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  if (v12) {
    goto LABEL_19;
  }
  return v14;
}

void sub_1004C1B80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::sendVolteEnabledSettingToBaseband_sync(uint64_t a1, uint64_t a2)
{
  int v4 = (capabilities::ct *)capabilities::ct::supportsVoLTE((capabilities::ct *)a1);
  if ((v4 & 1) != 0 || capabilities::ct::supportsSMSIMSStack(v4))
  {
    uint64_t ImsStateForBaseband_sync = RegistrationController::getImsStateForBaseband_sync(a1, a2);
    char v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    unint64_t v7 = v6;
    if (ImsStateForBaseband_sync == -1)
    {
      unsigned int v16 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I No valid IMS state - not reporting to baseband", buf, 2u);
      }
    }
    else
    {
      CFTypeRef cf = 0;
      (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 248) + 80))(&cf);
      uint64_t v8 = (BOOL *)cf;
      buf[0] = 1;
      if (cf
        && (CFTypeID v9 = CFGetTypeID(cf), v9 == CFBooleanGetTypeID())
        && (ctu::cf::assign((ctu::cf *)buf, v8, v10), !buf[0]))
      {
        uint64_t v17 = *v7;
        uint64_t v13 = (capabilities::ct *)os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
        if (v13)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Not reporting IMS state to baseband", buf, 2u);
        }
        if (ImsStateForBaseband_sync)
        {
          uint64_t v18 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
          uint64_t v34 = 0;
          uint64_t v35 = 0;
          RegistrationController::getModel_sync(a1, a2, &v34);
          if (v34)
          {
            *(_OWORD *)long long buf = 0u;
            long long v41 = 0u;
            (*(void (**)(uint8_t *__return_ptr))(*(void *)v34 + 752))(buf);
            uint64_t v31 = 0;
            unsigned int v32 = 0;
            uint64_t v33 = 0;
            sub_1003FB56C(&v31, *(const void **)buf, *(uint64_t *)&buf[8], (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 2);
            unsigned int v19 = RegistrationController::checkAndSetSmsServiceMask_sync(a1, a2, &v31, DWORD2(v41));
            uint64_t v20 = *v18;
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              asString();
              int v21 = SHIBYTE(v30);
              uint64_t v22 = (void **)__p;
              uint64_t v23 = sd::asString();
              p_p = &__p;
              if (v21 < 0) {
                p_p = v22;
              }
              *(_DWORD *)char v36 = 136315394;
              uint64_t v37 = p_p;
              __int16 v38 = 2080;
              uint64_t v39 = v23;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Sending IMS update from cache: dataModes=%s servicesMask=[%s]", v36, 0x16u);
              if (SHIBYTE(v30) < 0) {
                operator delete(__p);
              }
            }
            uint64_t v25 = *(void *)(a1 + 344);
            uint64_t v29 = 0;
            uint64_t v30 = 0;
            std::string __p = 0;
            sub_1003FB56C(&__p, v31, (uint64_t)v32, (v32 - (unsigned char *)v31) >> 2);
            (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)v25 + 96))(v25, a2, &__p, v19);
            if (__p)
            {
              uint64_t v29 = __p;
              operator delete(__p);
            }
            if (v31)
            {
              unsigned int v32 = v31;
              operator delete(v31);
            }
            if (*(void *)buf)
            {
              *(void *)&uint8_t buf[8] = *(void *)buf;
              operator delete(*(void **)buf);
            }
          }
          else
          {
            char v26 = *v18;
            if (os_log_type_enabled(*v18, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find model for IMS preference update from cache", buf, 2u);
            }
          }
          uint64_t v13 = (capabilities::ct *)v35;
          if (v35) {
            sub_10004D2C8(v35);
          }
        }
      }
      else
      {
        unsigned int v11 = *v7;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Reporting IMS state (%s) to baseband", buf, 0xCu);
        }
        uint64_t v13 = (capabilities::ct *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 88) + 224))(*(void *)(a1 + 88), a2, ImsStateForBaseband_sync);
      }
      if (capabilities::ct::supportsVoNR(v13))
      {
        uint64_t VoNRStateForBaseband_sync = RegistrationController::getVoNRStateForBaseband_sync(a1, a2);
        if (VoNRStateForBaseband_sync != -1) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 88) + 232))(*(void *)(a1 + 88), a2, VoNRStateForBaseband_sync);
        }
      }
      if (!ImsStateForBaseband_sync)
      {
        uint64_t v15 = *(void *)(a1 + 344);
        memset(buf, 0, sizeof(buf));
        *(void *)&long long v41 = 0;
        (*(void (**)(uint64_t, uint64_t, uint8_t *, void))(*(void *)v15 + 96))(v15, a2, buf, 0);
        if (*(void *)buf)
        {
          *(void *)&uint8_t buf[8] = *(void *)buf;
          operator delete(*(void **)buf);
        }
      }
      sub_1000577C4(&cf);
    }
  }
}

void sub_1004C20D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a17)
  {
    a18 = (uint64_t)a17;
    operator delete(a17);
  }
  if (a26)
  {
    a27 = (uint64_t)a26;
    operator delete(a26);
  }
  if (a21) {
    sub_10004D2C8(a21);
  }
  sub_1000577C4(&a10);
  _Unwind_Resume(a1);
}

uint64_t RegistrationController::setRatSelection_sync(uint64_t a1, uint64_t *a2, RatSelectionType *a3)
{
  uint64_t v7 = *a2;
  char v6 = (std::__shared_weak_count *)a2[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v8 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 568))(v7);
  CFTypeID v9 = (os_log_t *)(a1 + 40);
  CFBooleanRef v10 = *(NSObject **)(a1 + 40);
  BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    if (!v11)
    {
LABEL_13:
      uint64_t v18 = 0;
      goto LABEL_14;
    }
    LOWORD(v26) = 0;
    uint64_t v12 = "#N RAT selection is already in progress, cannot send another one";
    uint64_t v13 = v10;
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v26, 2u);
    goto LABEL_13;
  }
  if (v11)
  {
    LOWORD(v26) = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Setting system selection preference", (uint8_t *)&v26, 2u);
  }
  RatSelectionType::dumpState(a3, (const ctu::OsLogLogger *)(a1 + 40));
  uint64_t v14 = *(void *)(a1 + 88);
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 656))(v7);
  uint64_t Selection = RatSelectionType::getSelection(a3);
  Preferreduint64_t Selection = RatSelectionType::getPreferredSelection(a3);
  if ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v14 + 104))(v14, v15, Selection, PreferredSelection))
  {
    uint64_t v18 = 1;
    (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 560))(v7, 1);
    goto LABEL_14;
  }
  os_log_t v19 = *v9;
  uint64_t v18 = 0;
  if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v26) = 0;
    uint64_t v12 = "#N Set System Selection command to network registration driver failed";
    uint64_t v13 = v19;
    goto LABEL_12;
  }
LABEL_14:
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (v18)
  {
    uint64_t v20 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      int IsInternal = RatSelectionType::getIsInternal(a3);
      uint64_t v22 = "Non-internal";
      if (IsInternal) {
        uint64_t v22 = "Internal";
      }
      int v26 = 136315138;
      uint64_t v27 = v22;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s RAT selection event is in progress", (uint8_t *)&v26, 0xCu);
    }
    uint64_t v23 = *a2;
    uint64_t v24 = RatSelectionType::getIsInternal(a3);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v23 + 576))(v23, v24);
  }
  return v18;
}

void sub_1004C2478(_Unwind_Exception *exception_object)
{
}

void RegistrationController::subscriberMccMncComputed_sync(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 744))
  {
    int v4 = a2 + 1;
    xpc_object_t v5 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    char v6 = *(void **)(a1 + 728);
    while (*((_DWORD *)v5 + 8) == *((_DWORD *)v6 + 8) && rest::operator==())
    {
      uint64_t v7 = (void *)v5[1];
      int v8 = v5;
      if (v7)
      {
        do
        {
          xpc_object_t v5 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          xpc_object_t v5 = (void *)v8[2];
          BOOL v9 = *v5 == (void)v8;
          int v8 = v5;
        }
        while (!v9);
      }
      CFBooleanRef v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          BOOL v11 = v10;
          CFBooleanRef v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          BOOL v11 = (void *)v6[2];
          BOOL v9 = *v11 == (void)v6;
          char v6 = v11;
        }
        while (!v9);
      }
      char v6 = v11;
      if (v5 == v4) {
        return;
      }
    }
  }
  uint64_t v12 = *(void **)(a1 + 728);
  if (v12 != (void *)(a1 + 736))
  {
    uint64_t v13 = a2 + 1;
    while (1)
    {
      uint64_t v14 = v12 + 5;
      uint64_t v15 = *v13;
      uint64_t v16 = *((unsigned int *)v12 + 8);
      if (!*v13) {
        break;
      }
      uint64_t v17 = a2 + 1;
      do
      {
        int v18 = *(_DWORD *)(v15 + 32);
        BOOL v19 = v18 < (int)v16;
        if (v18 >= (int)v16) {
          uint64_t v20 = (uint64_t *)v15;
        }
        else {
          uint64_t v20 = (uint64_t *)(v15 + 8);
        }
        if (!v19) {
          uint64_t v17 = (uint64_t *)v15;
        }
        uint64_t v15 = *v20;
      }
      while (*v20);
      if (v17 == v13 || (int)v16 < *((_DWORD *)v17 + 8)) {
        break;
      }
      uint64_t v34 = v17 + 5;
      if (rest::operator!=())
      {
        uint64_t v35 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v12 + 8));
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)v17 + 63) < 0) {
            uint64_t v34 = (void *)*v34;
          }
          char v36 = v17 + 8;
          if (*((char *)v17 + 87) < 0) {
            char v36 = (void *)*v36;
          }
          if (*((char *)v12 + 63) < 0) {
            uint64_t v14 = (void *)*v14;
          }
          uint64_t v37 = v12 + 8;
          if (*((char *)v12 + 87) < 0) {
            uint64_t v37 = (void *)*v37;
          }
          *(_DWORD *)long long buf = 136446978;
          *(void *)&uint8_t buf[4] = v34;
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v36;
          __int16 v41 = 2082;
          uint64_t v42 = v14;
          __int16 v43 = 2082;
          CFTypeID v44 = v37;
          uint64_t v23 = v35;
          uint64_t v24 = "#I Computed MCC/MNC changing from %{public}s-%{public}s to %{public}s-%{public}s";
          uint32_t v25 = 42;
LABEL_36:
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v24, buf, v25);
        }
LABEL_37:
        uint64_t v38 = 0;
        uint64_t v39 = 0;
        RegistrationController::getModel_sync(a1, *((_DWORD *)v12 + 8), &v38);
        uint64_t v26 = v38;
        if (v38)
        {
          uint64_t v27 = v39;
          *(void *)long long buf = v38;
          *(void *)&uint8_t buf[8] = v39;
          if (v39) {
            atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_10000F1D8(a1, buf);
          if (v27) {
            sub_10004D2C8(v27);
          }
          uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 72))(v26);
          uint64_t v29 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 464))(v26);
          uint64_t v30 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 112))(v26);
          (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)v26 + 648))(v26, v28, v29, 0, v30);
        }
        else
        {
          uint64_t v31 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v12 + 8));
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Could not find model for MCC/MNC computed change", buf, 2u);
          }
        }
        if (v39) {
          sub_10004D2C8(v39);
        }
      }
      unsigned int v32 = (void *)v12[1];
      if (v32)
      {
        do
        {
          uint64_t v33 = v32;
          unsigned int v32 = (void *)*v32;
        }
        while (v32);
      }
      else
      {
        do
        {
          uint64_t v33 = (void *)v12[2];
          BOOL v9 = *v33 == (void)v12;
          uint64_t v12 = v33;
        }
        while (!v9);
      }
      uint64_t v12 = v33;
      if (v33 == (void *)(a1 + 736)) {
        return;
      }
    }
    int v21 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v16);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)v12 + 63) < 0) {
        uint64_t v14 = (void *)*v14;
      }
      uint64_t v22 = v12 + 8;
      if (*((char *)v12 + 87) < 0) {
        uint64_t v22 = (void *)*v22;
      }
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = v14;
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v22;
      uint64_t v23 = v21;
      uint64_t v24 = "#I Computed MCC/MNC changed to %{public}s-%{public}s";
      uint32_t v25 = 22;
      goto LABEL_36;
    }
    goto LABEL_37;
  }
}

void sub_1004C2960(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::setECBM_sync(RegistrationController *this, uint64_t a2)
{
  int v4 = *((void *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v5 = "Disabled";
    if (a2) {
      xpc_object_t v5 = "Enable";
    }
    int v11 = 136315138;
    uint64_t v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Emergency Call Back Mode %s ", (uint8_t *)&v11, 0xCu);
  }
  int v6 = (*(uint64_t (**)(void))(**((void **)this + 13) + 88))(*((void *)this + 13));
  if (v6 == a2)
  {
    int v7 = v6;
    int v8 = *((void *)this + 5);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v9 = "false";
      if (a2) {
        CFBooleanRef v10 = "true";
      }
      else {
        CFBooleanRef v10 = "false";
      }
      if (v7) {
        BOOL v9 = "true";
      }
      int v11 = 136315394;
      uint64_t v12 = v10;
      __int16 v13 = 2080;
      uint64_t v14 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Not setting ECBM mode to %s as it's already %s", (uint8_t *)&v11, 0x16u);
    }
  }
  else
  {
    (*(void (**)(void, uint64_t))(**((void **)this + 11) + 40))(*((void *)this + 11), a2);
  }
}

void RegistrationController::persistEnableOnlyHomeNetwork(Registry **this@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, this[17]);
  int v4 = ServiceMap;
  if (v5 < 0)
  {
    int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v5;
  BOOL v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)__p);
  if (v9)
  {
    uint64_t v11 = v9[3];
    CFBooleanRef v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_7;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  CFBooleanRef v10 = 0;
  char v12 = 1;
  if (!v11)
  {
LABEL_7:
    __int16 v13 = this[5];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Unable to persist enable only home network", (uint8_t *)__p, 2u);
      if (v12) {
        return;
      }
      goto LABEL_14;
    }
LABEL_13:
    if (v12) {
      return;
    }
    goto LABEL_14;
  }
LABEL_12:
  sub_100058DB0(__p, "EURQMIC2KRegistrationController::fEnableOnlyHomeNetwork");
  (*(void (**)(uint64_t, void **, void))(*(void *)v11 + 64))(v11, __p, *((unsigned __int8 *)this + 376));
  if ((v15 & 0x80000000) == 0) {
    goto LABEL_13;
  }
  operator delete(__p[0]);
  if (v12) {
    return;
  }
LABEL_14:
  sub_10004D2C8(v10);
}

void sub_1004C2CB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RegistrationController::setEnableOnlyHomeNetwork_sync@<X0>(RegistrationController *this@<X0>, char a2@<W1>, uint64_t *a3@<X8>)
{
  *((unsigned char *)this + 376) = a2;
  RegistrationController::persistEnableOnlyHomeNetwork((Registry **)this, a3);
  return sub_10051513C((wis::MetricFactory *)0x80067);
}

const void **RegistrationController::sendEnableOnlyHomeNetwork_sync(RegistrationController *this)
{
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr))(**((void **)this + 31) + 40))(&cf);
  uint64_t v2 = (BOOL *)cf;
  LOBYTE(buf) = 0;
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)&buf, v2, v4);
    }
    int v5 = buf;
  }
  else
  {
    int v5 = 0;
  }
  int v6 = *((void *)this + 5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v8 = " ";
    if (!v5) {
      unsigned int v8 = " NOT ";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Voice roaming switch is%ssupported", (uint8_t *)&buf, 0xCu);
  }
  if (!v5)
  {
    *((unsigned char *)this + 376) = 0;
    RegistrationController::persistEnableOnlyHomeNetwork((Registry **)this, v7);
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 0x40000000;
    uint64_t v35 = sub_10051531C;
    char v36 = &unk_1019DD8E8;
    uint64_t v37 = this;
    sub_10051513C((wis::MetricFactory *)0x80067);
  }
  CFTypeRef v32 = 0;
  uint64_t TypeID = (uint64_t)(*(void *(**)(CFTypeRef *__return_ptr))(**((void **)this + 31) + 40))(&v32);
  CFBooleanRef v10 = (BOOL *)v32;
  LOBYTE(buf) = 0;
  if (!v32) {
    goto LABEL_25;
  }
  CFTypeID v11 = CFGetTypeID(v32);
  uint64_t TypeID = CFBooleanGetTypeID();
  if (v11 == TypeID) {
    uint64_t TypeID = ctu::cf::assign((ctu::cf *)&buf, v10, v12);
  }
  if (!(_BYTE)buf)
  {
LABEL_25:
    unsigned int v25 = 28;
    goto LABEL_39;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)buf, *((Registry **)this + 17));
  uint64_t v14 = ServiceMap;
  if (v15 < 0)
  {
    uint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v15;
  BOOL v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)&buf);
  if (!v19)
  {
    uint64_t v21 = 0;
LABEL_27:
    std::mutex::unlock(v14);
    uint64_t v20 = 0;
    char v22 = 1;
    if (!v21) {
      goto LABEL_22;
    }
LABEL_28:
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v21 + 8))(&buf, v21, 1);
    int v24 = ((*(unsigned int (**)(void, uint64_t))(*(void *)buf + 56))(buf, 2) >> 16);
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
    goto LABEL_30;
  }
  uint64_t v21 = v19[3];
  uint64_t v20 = (std::__shared_weak_count *)v19[4];
  if (!v20) {
    goto LABEL_27;
  }
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v14);
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v20);
  char v22 = 0;
  if (v21) {
    goto LABEL_28;
  }
LABEL_22:
  uint64_t v23 = *((void *)this + 5);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not get PhoneServices to check VoLTE switch user setting", (uint8_t *)&buf, 2u);
  }
  int v24 = 0;
LABEL_30:
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  uint64_t v26 = *((void *)this + 5);
  uint64_t TypeID = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
  if (TypeID)
  {
    uint64_t v27 = "";
    if (!v24) {
      uint64_t v27 = "not";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v27;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Carrier prefers GWL with voice roaming switch, VoLTE user preference is %s enabled", (uint8_t *)&buf, 0xCu);
  }
  if (v24) {
    unsigned int v25 = 31;
  }
  else {
    unsigned int v25 = 28;
  }
LABEL_39:
  if (*((unsigned char *)this + 376)) {
    BOOL v28 = v5 == 0;
  }
  else {
    BOOL v28 = 1;
  }
  uint64_t v29 = v28;
  if (v28)
  {
    uint64_t TypeID = capabilities::ct::supportsCapabilityC2KDevice((capabilities::ct *)TypeID);
    if (TypeID) {
      unsigned int v25 = 31;
    }
    else {
      unsigned int v25 = 19;
    }
  }
  if (capabilities::ct::supports5G((capabilities::ct *)TypeID)) {
    uint64_t v30 = v25 | 0xC0;
  }
  else {
    uint64_t v30 = v25;
  }
  (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 11) + 96))(*((void *)this + 11), v30, v29);
  sub_1000577C4(&v32);
  return sub_1000577C4(&cf);
}

void sub_1004C3200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  sub_1000577C4(&a9);
  sub_1000577C4(&a10);
  _Unwind_Resume(a1);
}

void RegistrationController::setRegNotificationStatus(RegistrationController *this, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_1004C3384;
  uint64_t v4[3] = &unk_1019D4970;
  void v4[4] = this;
  char v5 = a2;
  uint64_t v8 = 0;
  BOOL v9 = 0;
  sub_10003E168(&v8, (void *)this + 1);
  CFTypeID v3 = *((void *)this + 3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v8;
  uint64_t v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

uint64_t sub_1004C3384(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 32) + 88) + 160))(*(void *)(*(void *)(a1 + 32) + 88), *(unsigned __int8 *)(a1 + 40));
}

void RegistrationController::submitSearchingTimeMetric_sync(uint64_t a1, const void **a2, uint64_t a3, uint64_t a4)
{
  if (capabilities::ct::getProvisioningProfileSupport((capabilities::ct *)a1) == 1)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
    BOOL v9 = ServiceMap;
    if (v10 < 0)
    {
      CFTypeID v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v10;
    uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        if (!v16) {
          goto LABEL_8;
        }
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    if (!v16)
    {
LABEL_8:
      unsigned int v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to send bootstrap searching time metric : (no analytics interface)", buf, 2u);
      }
LABEL_55:
      if ((v17 & 1) == 0) {
        sub_10004D2C8(v15);
      }
      return;
    }
LABEL_12:
    xpc_object_t v40 = 0;
    xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v20 = v19;
    if (v19)
    {
      xpc_object_t v40 = v19;
    }
    else
    {
      xpc_object_t v20 = xpc_null_create();
      xpc_object_t v40 = v20;
      if (!v20)
      {
        xpc_object_t v21 = xpc_null_create();
        xpc_object_t v20 = 0;
        goto LABEL_19;
      }
    }
    if (xpc_get_type(v20) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v20);
LABEL_20:
      xpc_release(v20);
      memset(buf, 0, sizeof(buf));
      int64_t v39 = 0;
      if (*((char *)a2 + 23) >= 0) {
        size_t v22 = *((unsigned __int8 *)a2 + 23);
      }
      else {
        size_t v22 = (size_t)a2[1];
      }
      memset(&v41, 0, sizeof(v41));
      uint64_t v23 = &v41;
      sub_1000C140C((uint64_t)&v41, v22 + 1);
      if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v23 = (std::string *)v41.__r_.__value_.__r.__words[0];
      }
      if (v22)
      {
        if (*((char *)a2 + 23) >= 0) {
          int v24 = a2;
        }
        else {
          int v24 = *a2;
        }
        memmove(v23, v24, v22);
      }
      *(_WORD *)((char *)&v23->__r_.__value_.__l.__data_ + v22) = 47;
      int v25 = *(char *)(a3 + 23);
      if (v25 >= 0) {
        uint64_t v26 = (const std::string::value_type *)a3;
      }
      else {
        uint64_t v26 = *(const std::string::value_type **)a3;
      }
      if (v25 >= 0) {
        std::string::size_type v27 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        std::string::size_type v27 = *(void *)(a3 + 8);
      }
      BOOL v28 = std::string::append(&v41, v26, v27);
      long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
      int64_t v39 = v28->__r_.__value_.__r.__words[2];
      *(_OWORD *)long long buf = v29;
      v28->__r_.__value_.__l.__size_ = 0;
      v28->__r_.__value_.__r.__words[2] = 0;
      v28->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v41.__r_.__value_.__l.__data_);
      }
      if (v39 >= 0) {
        uint64_t v30 = buf;
      }
      else {
        uint64_t v30 = *(uint8_t **)buf;
      }
      xpc_object_t v36 = xpc_string_create((const char *)v30);
      if (!v36) {
        xpc_object_t v36 = xpc_null_create();
      }
      v41.__r_.__value_.__r.__words[0] = (std::string::size_type)&v40;
      v41.__r_.__value_.__l.__size_ = (std::string::size_type)"carrierIdentifier";
      sub_100035E70((uint64_t)&v41, &v36, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v36);
      xpc_object_t v36 = 0;
      xpc_object_t v34 = xpc_uint64_create(a4);
      if (!v34) {
        xpc_object_t v34 = xpc_null_create();
      }
      v41.__r_.__value_.__r.__words[0] = (std::string::size_type)&v40;
      v41.__r_.__value_.__l.__size_ = (std::string::size_type)"searchingTime";
      sub_100035E70((uint64_t)&v41, &v34, &v35);
      xpc_release(v35);
      xpc_object_t v35 = 0;
      xpc_release(v34);
      xpc_object_t v34 = 0;
      uint64_t v31 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        CFTypeRef v32 = buf;
        if (v39 < 0) {
          CFTypeRef v32 = *(uint8_t **)buf;
        }
        LODWORD(v41.__r_.__value_.__l.__data_) = 134218242;
        *(std::string::size_type *)((char *)v41.__r_.__value_.__r.__words + 4) = a4;
        WORD2(v41.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v41.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v32;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I sent bootstrap searching time : %llu : %s", (uint8_t *)&v41, 0x16u);
      }
      xpc_object_t v33 = v40;
      if (v40) {
        xpc_retain(v40);
      }
      else {
        xpc_object_t v33 = xpc_null_create();
      }
      (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v16 + 16))(v16, "commCenterBootstrapUsageSummary", &v33);
      xpc_release(v33);
      xpc_object_t v33 = 0;
      if (SHIBYTE(v39) < 0) {
        operator delete(*(void **)buf);
      }
      xpc_release(v40);
      goto LABEL_55;
    }
    xpc_object_t v21 = xpc_null_create();
LABEL_19:
    xpc_object_t v40 = v21;
    goto LABEL_20;
  }
}

void sub_1004C37E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,xpc_object_t a22,uint64_t a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void *sub_1004C3894(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1004C3918(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1004C399C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1004C3A20(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xF0F0F0F0F0F0F0F1 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x1E1E1E1E1E1E1E1) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xF0F0F0F0F0F0F0F1 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0xF0F0F0F0F0F0F0) {
    unint64_t v9 = 0x1E1E1E1E1E1E1E1;
  }
  else {
    unint64_t v9 = v5;
  }
  char v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_100320E18(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  unsigned int v13 = v10;
  uint64_t v14 = &v10[136 * v4];
  uint64_t v16 = &v10[136 * v9];
  sub_1004C3B28(v14, a2);
  uint64_t v15 = v14 + 136;
  sub_1004C3C18(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1004C3D9C((uint64_t)&v13);
  return v11;
}

void sub_1004C3B14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004C3D9C((uint64_t)va);
  _Unwind_Resume(a1);
}

char *sub_1004C3B28(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  *((_DWORD *)__dst + 6) = *((_DWORD *)a2 + 6);
  MCC::MCC((MCC *)(__dst + 32), (const MCC *)(a2 + 2));
  MCC::MCC((MCC *)(__dst + 64), (const MCC *)(a2 + 4));
  unint64_t v5 = __dst + 96;
  if (*((char *)a2 + 119) < 0)
  {
    sub_10004FC84(v5, *((void **)a2 + 12), *((void *)a2 + 13));
  }
  else
  {
    long long v6 = a2[6];
    *((void *)__dst + 14) = *((void *)a2 + 14);
    *(_OWORD *)unint64_t v5 = v6;
  }
  *(_OWORD *)(__dst + 120) = *(long long *)((char *)a2 + 120);
  return __dst;
}

void sub_1004C3BCC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 95) < 0) {
    operator delete(*(void **)(v1 + 72));
  }
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*(void **)(v1 + 40));
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004C3C18(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1004C3C90((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1004C3C90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0;
  uint64_t v11 = a7 - 136;
  while (a3 + v10 != a5)
  {
    uint64_t v12 = (char *)(v11 + v10);
    v10 -= 136;
    sub_1004C3B28(v12, (long long *)(v10 + a3));
  }
  return a6;
}

void sub_1004C3D24(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

uint64_t sub_1004C3D9C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 136;
    sub_1004C3D24(i - 136);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_1004C3DEC(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_1003A0BE0(result, a4);
    uint64_t result = (void *)sub_1004C3E74((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1004C3E54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1004C3EF8(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1004C3E74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_1004C3B28((char *)(a4 + v7), (long long *)(a2 + v7));
      v7 += 136;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1004C3ED4(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 136;
    do
    {
      sub_1004C3D24(v4 + v2);
      v2 -= 136;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004C3EF8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 136;
        sub_1004C3D24(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1004C3F80()
{
}

void *sub_1004C3F94()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1019D49A0;
  return result;
}

void sub_1004C3FCC(uint64_t a1, void *a2)
{
  *a2 = off_1019D49A0;
}

void sub_1004C3FF4(uint64_t a1, dispatch_workloop_t *a2)
{
}

uint64_t sub_1004C4000(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004C4040()
{
}

void sub_1004C4050(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1004C4088(uint64_t a1)
{
}

uint64_t sub_1004C40A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1004C40E8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1004C4114(ServiceManager::Service *this)
{
  *(void *)this = off_1019D4B18;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1004C4170(ServiceManager::Service *this)
{
  *(void *)this = off_1019D4B18;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1004C41E0@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "RegistrationController");
}

unsigned char *sub_1004C41F0@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1004C4230(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1004B8F64(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_1004B8F64(v4, 0);
}

uint64_t sub_1004C42B4()
{
  return 1;
}

uint64_t sub_1004C42BC()
{
  return 1;
}

uint64_t sub_1004C42C4()
{
  return 2;
}

void sub_1004C42CC(uint64_t a1, xpc_object_t *a2, NSObject **a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  xpc_object_t v5 = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  uint64_t v6 = *a3;
  uint64_t v7 = v6;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(v6);
    sub_1004B9DF0(v4, v5, &v7);
  }
  sub_1004B9DF0(v4, v5, &v7);
}

void sub_1004C437C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  void v3[2] = sub_1004B905C;
  v3[3] = &unk_1019D47A0;
  v3[4] = v1;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  sub_10003E168(&v6, (void *)(v1 + 8));
  uint64_t v2 = *(NSObject **)(v1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v6;
  xpc_object_t v5 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v3;
  dispatch_async(v2, block);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1004C4488(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  dispatch_object_t object = 0;
  ServiceStage::holdOffStage((uint64_t *)&object, this);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 1174405120;
  void v5[2] = sub_1004B8B58;
  void v5[3] = &unk_1019D4770;
  void v5[4] = v3;
  dispatch_group_t group = object;
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(group);
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_10003E168(&v10, (void *)(v3 + 8));
  uint64_t v4 = *(NSObject **)(v3 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1000594F4;
  block[3] = &unk_1019D4BB8;
  block[5] = v10;
  uint64_t v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (object)
  {
    dispatch_group_leave(object);
    if (object) {
      dispatch_release(object);
    }
  }
}

void sub_1004C45F0(ServiceManager::Service *this)
{
  *(void *)this = off_1019D4B18;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1004C464C(ServiceManager::Service *this)
{
  *(void *)this = off_1019D4B18;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_1004C46BC()
{
  return 0;
}

uint64_t sub_1004C46C4()
{
  return 0;
}

void sub_1004C46D4()
{
}

uint64_t sub_1004C46E8(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_1004C46F4(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10005DF6C(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_1004C4734(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_1004C474C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  sub_1004C47A4((char *)a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_1004C478C(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *sub_1004C47A4(char *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    xpc_object_t v5 = (uint64_t **)result;
    uint64_t v6 = (uint64_t *)(result + 8);
    do
    {
      uint64_t result = sub_1004C4830(v5, v6, v4 + 7, (uint64_t)(v4 + 7));
      uint64_t v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

char *sub_1004C4830(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v6 = sub_10005CF3C(a1, a2, &v11, &v10, a3);
  uint64_t v7 = (char *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = (char *)operator new(0x30uLL);
    *(_OWORD *)(v7 + 28) = *(_OWORD *)a4;
    *((_DWORD *)v7 + 11) = *(_DWORD *)(a4 + 16);
    sub_100046C38(a1, (uint64_t)v11, v8, (uint64_t *)v7);
  }
  return v7;
}

void sub_1004C48C4(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 104);
  xpc_object_t v5 = *(std::__shared_weak_count **)(v2 + 352);
  *(void *)long long buf = *(void *)(v2 + 344);
  CFArrayRef v109 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 16))(v4, buf);
  if (v109) {
    sub_10004D2C8(v109);
  }
  RegistrationController::setupAwdCallbacks_sync((RegistrationController *)v2);
  sub_10003E168(buf, (void *)(v2 + 8));
  uint64_t v7 = *(void *)buf;
  uint64_t v6 = v109;
  if (v109)
  {
    atomic_fetch_add_explicit(&v109->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v6);
    uint64_t v8 = *(void *)(v2 + 104);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    uint64_t v8 = *(void *)(v2 + 104);
  }
  v111[0] = off_1019D4C18;
  v111[1] = v7;
  v111[2] = v6;
  v111[3] = v111;
  (*(void (**)(uint64_t, void *))(*(void *)v8 + 112))(v8, v111);
  sub_10003B34C(v111);
  uint64_t v9 = *(void *)(v2 + 360);
  uint64_t v10 = *(NSObject **)(v2 + 24);
  dispatch_object_t object = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  v110[0] = off_1019D4C98;
  v110[1] = v2;
  v110[3] = v110;
  (*(void (**)(uint64_t, dispatch_object_t *, void *))(*(void *)v9 + 16))(v9, &object, v110);
  sub_100060644(v110);
  if (object) {
    dispatch_release(object);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 136));
  uint64_t v12 = ServiceMap;
  if (v13 < 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v13;
  char v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (v17)
  {
    uint64_t v19 = v17[3];
    unsigned int v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  unsigned int v18 = 0;
LABEL_22:
  xpc_object_t v20 = *(std::__shared_weak_count **)(v2 + 224);
  *(void *)(v2 + 216) = v19;
  *(void *)(v2 + 224) = v18;
  if (v20) {
    sub_10004D2C8(v20);
  }
  xpc_object_t v21 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 136));
  size_t v22 = v21;
  if (v23 < 0)
  {
    int v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v25 = 5381;
    do
    {
      uint64_t v23 = v25;
      unsigned int v26 = *v24++;
      uint64_t v25 = (33 * v25) ^ v26;
    }
    while (v26);
  }
  std::mutex::lock(v21);
  *(void *)long long buf = v23;
  std::string::size_type v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)buf);
  if (v27)
  {
    uint64_t v29 = v27[3];
    BOOL v28 = (std::__shared_weak_count *)v27[4];
    if (v28)
    {
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v22);
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v28);
      goto LABEL_32;
    }
  }
  else
  {
    uint64_t v29 = 0;
  }
  std::mutex::unlock(v22);
  BOOL v28 = 0;
LABEL_32:
  uint64_t v30 = *(std::__shared_weak_count **)(v2 + 256);
  *(void *)(v2 + 248) = v29;
  *(void *)(v2 + 256) = v28;
  if (v30) {
    sub_10004D2C8(v30);
  }
  uint64_t v31 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 136));
  CFTypeRef v32 = v31;
  if (v33 < 0)
  {
    xpc_object_t v34 = (unsigned __int8 *)(v33 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v35 = 5381;
    do
    {
      uint64_t v33 = v35;
      unsigned int v36 = *v34++;
      uint64_t v35 = (33 * v35) ^ v36;
    }
    while (v36);
  }
  std::mutex::lock(v31);
  *(void *)long long buf = v33;
  uint64_t v37 = sub_10004D37C(&v32[1].__m_.__sig, (unint64_t *)buf);
  if (v37)
  {
    uint64_t v39 = v37[3];
    uint64_t v38 = (std::__shared_weak_count *)v37[4];
    if (v38)
    {
      atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v32);
      atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v38);
      goto LABEL_42;
    }
  }
  else
  {
    uint64_t v39 = 0;
  }
  std::mutex::unlock(v32);
  uint64_t v38 = 0;
LABEL_42:
  xpc_object_t v40 = *(std::__shared_weak_count **)(v2 + 288);
  *(void *)(v2 + 280) = v39;
  *(void *)(v2 + 288) = v38;
  if (v40) {
    sub_10004D2C8(v40);
  }
  std::string v41 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 136));
  uint64_t v42 = v41;
  if (v43 < 0)
  {
    CFTypeID v44 = (unsigned __int8 *)(v43 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v45 = 5381;
    do
    {
      uint64_t v43 = v45;
      unsigned int v46 = *v44++;
      uint64_t v45 = (33 * v45) ^ v46;
    }
    while (v46);
  }
  std::mutex::lock(v41);
  *(void *)long long buf = v43;
  CFTypeID v47 = sub_10004D37C(&v42[1].__m_.__sig, (unint64_t *)buf);
  if (v47)
  {
    uint64_t v49 = v47[3];
    CFBooleanRef v48 = (std::__shared_weak_count *)v47[4];
    if (v48)
    {
      atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v42);
      atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v48);
      goto LABEL_52;
    }
  }
  else
  {
    uint64_t v49 = 0;
  }
  std::mutex::unlock(v42);
  CFBooleanRef v48 = 0;
LABEL_52:
  xpc_object_t v50 = *(std::__shared_weak_count **)(v2 + 176);
  *(void *)(v2 + 168) = v49;
  *(void *)(v2 + 176) = v48;
  if (v50) {
    sub_10004D2C8(v50);
  }
  uint64_t v51 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 136));
  unsigned int v52 = v51;
  if (v53 < 0)
  {
    uint64_t v54 = (unsigned __int8 *)(v53 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v55 = 5381;
    do
    {
      uint64_t v53 = v55;
      unsigned int v56 = *v54++;
      uint64_t v55 = (33 * v55) ^ v56;
    }
    while (v56);
  }
  std::mutex::lock(v51);
  *(void *)long long buf = v53;
  CFTypeID v57 = sub_10004D37C(&v52[1].__m_.__sig, (unint64_t *)buf);
  if (v57)
  {
    uint64_t v59 = v57[3];
    CFNumberRef v58 = (std::__shared_weak_count *)v57[4];
    if (v58)
    {
      atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v52);
      atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v58);
      goto LABEL_62;
    }
  }
  else
  {
    uint64_t v59 = 0;
  }
  std::mutex::unlock(v52);
  CFNumberRef v58 = 0;
LABEL_62:
  CFBooleanRef v60 = *(std::__shared_weak_count **)(v2 + 272);
  *(void *)(v2 + 264) = v59;
  *(void *)(v2 + 272) = v58;
  if (v60) {
    sub_10004D2C8(v60);
  }
  uint64_t v61 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 136));
  xpc_object_t v62 = v61;
  if (v63 < 0)
  {
    xpc_object_t v64 = (unsigned __int8 *)(v63 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v65 = 5381;
    do
    {
      uint64_t v63 = v65;
      unsigned int v66 = *v64++;
      uint64_t v65 = (33 * v65) ^ v66;
    }
    while (v66);
  }
  std::mutex::lock(v61);
  *(void *)long long buf = v63;
  uint64_t v67 = sub_10004D37C(&v62[1].__m_.__sig, (unint64_t *)buf);
  if (v67)
  {
    uint64_t v69 = v67[3];
    uint64_t v68 = (std::__shared_weak_count *)v67[4];
    if (v68)
    {
      atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v62);
      atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v68);
      goto LABEL_72;
    }
  }
  else
  {
    uint64_t v69 = 0;
  }
  std::mutex::unlock(v62);
  uint64_t v68 = 0;
LABEL_72:
  xpc_object_t v70 = *(std::__shared_weak_count **)(v2 + 208);
  *(void *)(v2 + 200) = v69;
  *(void *)(v2 + 208) = v68;
  if (v70) {
    sub_10004D2C8(v70);
  }
  __int16 v71 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 136));
  uint64_t v72 = v71;
  if (v73 < 0)
  {
    xpc_object_t v74 = (unsigned __int8 *)(v73 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v75 = 5381;
    do
    {
      uint64_t v73 = v75;
      unsigned int v76 = *v74++;
      uint64_t v75 = (33 * v75) ^ v76;
    }
    while (v76);
  }
  std::mutex::lock(v71);
  *(void *)long long buf = v73;
  xpc_object_t v77 = sub_10004D37C(&v72[1].__m_.__sig, (unint64_t *)buf);
  if (v77)
  {
    uint64_t v79 = v77[3];
    xpc_object_t v78 = (std::__shared_weak_count *)v77[4];
    if (v78)
    {
      atomic_fetch_add_explicit(&v78->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v72);
      atomic_fetch_add_explicit(&v78->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v78);
      goto LABEL_82;
    }
  }
  else
  {
    uint64_t v79 = 0;
  }
  std::mutex::unlock(v72);
  xpc_object_t v78 = 0;
LABEL_82:
  xpc_object_t v80 = *(std::__shared_weak_count **)(v2 + 192);
  *(void *)(v2 + 184) = v79;
  *(void *)(v2 + 192) = v78;
  if (v80) {
    sub_10004D2C8(v80);
  }
  (*(void (**)(void))(**(void **)(v2 + 344) + 16))(*(void *)(v2 + 344));
  (*(void (**)(void))(**(void **)(v2 + 312) + 16))(*(void *)(v2 + 312));
  xpc_object_t v81 = *(void **)(v2 + 64);
  if (v81 != (void *)(v2 + 72))
  {
    do
    {
      uint64_t v82 = v81[5];
      xpc_object_t v83 = *(std::__shared_weak_count **)(v2 + 112);
      uint64_t v105 = *(void *)(v2 + 104);
      uint64_t v106 = v83;
      if (v83) {
        atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      xpc_object_t v84 = *(std::__shared_weak_count **)(v2 + 352);
      uint64_t v103 = *(void *)(v2 + 344);
      uint64_t v104 = v84;
      if (v84) {
        atomic_fetch_add_explicit(&v84->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      xpc_object_t v85 = *(std::__shared_weak_count **)(v2 + 304);
      uint64_t v101 = *(void *)(v2 + 296);
      uint32_t v102 = v85;
      if (v85) {
        atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v86 = *(std::__shared_weak_count **)(v2 + 208);
      uint64_t v99 = *(void *)(v2 + 200);
      unint64_t v100 = v86;
      if (v86) {
        atomic_fetch_add_explicit(&v86->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t *))(*(void *)v82 + 16))(v82, &v105, &v103, &v101, &v99);
      if (v100) {
        sub_10004D2C8(v100);
      }
      if (v102) {
        sub_10004D2C8(v102);
      }
      if (v104) {
        sub_10004D2C8(v104);
      }
      if (v106) {
        sub_10004D2C8(v106);
      }
      uint64_t v87 = (void *)v81[1];
      if (v87)
      {
        do
        {
          xpc_object_t v88 = v87;
          uint64_t v87 = (void *)*v87;
        }
        while (v87);
      }
      else
      {
        do
        {
          xpc_object_t v88 = (void *)v81[2];
          BOOL v89 = *v88 == (void)v81;
          xpc_object_t v81 = v88;
        }
        while (!v89);
      }
      xpc_object_t v81 = v88;
    }
    while (v88 != (void *)(v2 + 72));
  }
  uint64_t v90 = *(void *)(v2 + 296);
  uint64_t v91 = v1[1];
  dispatch_group_t group = v91;
  if (v91)
  {
    dispatch_retain(v91);
    dispatch_group_enter(group);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v90 + 40))(v90, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  uint64_t v92 = *(void *)(v2 + 232);
  uint64_t v93 = v1[1];
  dispatch_group_t v97 = v93;
  if (v93)
  {
    dispatch_retain(v93);
    dispatch_group_enter(v97);
  }
  (*(void (**)(uint64_t, uint64_t, dispatch_group_t *))(*(void *)v92 + 24))(v92, v2 + 296, &v97);
  if (v97)
  {
    dispatch_group_leave(v97);
    if (v97) {
      dispatch_release(v97);
    }
  }
  uint64_t v94 = v1[1];
  dispatch_group_t v96 = v94;
  if (v94)
  {
    dispatch_retain(v94);
    dispatch_group_enter(v96);
  }
  v95.var0.fObunint64_t j = (dispatch_object_s *)&v96;
  RegistrationController::setupEvents_sync((dispatch_object_t *)v2, v95);
}

void sub_1004C5518(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, dispatch_group_t group, dispatch_group_t object, dispatch_group_t a20,dispatch_group_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36,void *aBlock)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004C5728(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v1 + 136));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    xpc_object_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (!v8)
  {
    uint64_t v9 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    uint64_t v10 = 0;
    char v11 = 1;
    if (!v9) {
      goto LABEL_59;
    }
    goto LABEL_10;
  }
  uint64_t v9 = v8[3];
  uint64_t v10 = (std::__shared_weak_count *)v8[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v11 = 0;
  if (!v9) {
    goto LABEL_59;
  }
LABEL_10:
  uint64_t v12 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v1 + 136));
  uint64_t v13 = v12;
  if (v14 < 0)
  {
    uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      uint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(v12);
  *(void *)long long buf = v14;
  unsigned int v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
  if (v18)
  {
    uint64_t v19 = v18[3];
    xpc_object_t v20 = (std::__shared_weak_count *)v18[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v13);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v20);
      char v21 = 0;
      if (!v19) {
        goto LABEL_16;
      }
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v13);
  xpc_object_t v20 = 0;
  char v21 = 1;
  if (!v19)
  {
LABEL_16:
    size_t v22 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#N PersonalityShop is not ready", buf, 2u);
    }
    if (v21) {
      goto LABEL_59;
    }
LABEL_58:
    sub_10004D2C8(v20);
    goto LABEL_59;
  }
LABEL_22:
  char v39 = v21;
  char v40 = v11;
  uint64_t v37 = v20;
  uint64_t v38 = v10;
  subscriber::makeSimSlotRange();
  int v24 = *(unsigned int **)buf;
  uint64_t v23 = v46;
  if (*(unsigned int **)buf != v46)
  {
    uint64_t v25 = v47;
    while ((v25(*v24) & 1) == 0)
    {
      if (++v24 == v23)
      {
        int v24 = v23;
        break;
      }
    }
    unsigned int v26 = v46;
    if (v24 != v46)
    {
      std::string::size_type v27 = (uint64_t *)(v1 + 736);
      do
      {
        uint64_t v28 = *v24;
        uint64_t v43 = 0;
        CFTypeID v44 = 0;
        RegistrationController::getModel_sync(v1, v28, &v43);
        uint64_t v29 = v43;
        if (v43)
        {
          uint64_t v41 = 0;
          uint64_t v42 = 0;
          (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v19 + 8))(&v41, v19, v28);
          if (v41)
          {
            if (*(unsigned char *)(v41 + 48))
            {
              uint64_t v30 = *v27;
              if (*v27)
              {
                uint64_t v31 = v1 + 736;
                do
                {
                  int v32 = *(_DWORD *)(v30 + 32);
                  BOOL v33 = v32 < (int)v28;
                  if (v32 >= (int)v28) {
                    xpc_object_t v34 = (uint64_t *)v30;
                  }
                  else {
                    xpc_object_t v34 = (uint64_t *)(v30 + 8);
                  }
                  if (!v33) {
                    uint64_t v31 = v30;
                  }
                  uint64_t v30 = *v34;
                }
                while (*v34);
                if ((uint64_t *)v31 != v27 && (int)v28 >= *(_DWORD *)(v31 + 32))
                {
                  unsigned __int16 v36 = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 832))(v29);
                  if (v36 >= 0x100u && (_BYTE)v36) {
                    RegistrationController::getNRDisableStatus_sync(v1, v28);
                  }
                  operator new();
                }
              }
            }
          }
          if (v42) {
            sub_10004D2C8(v42);
          }
        }
        if (v44) {
          sub_10004D2C8(v44);
        }
        uint64_t v35 = v24 + 1;
        int v24 = v23;
        if (v35 != v23)
        {
          int v24 = v35;
          while ((v25(*v24) & 1) == 0)
          {
            if (++v24 == v23)
            {
              int v24 = v23;
              break;
            }
          }
        }
      }
      while (v24 != v26);
    }
  }
  xpc_object_t v20 = v37;
  uint64_t v10 = v38;
  char v11 = v40;
  if ((v39 & 1) == 0) {
    goto LABEL_58;
  }
LABEL_59:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_1004C5BA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, std::__shared_weak_count *a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (a21) {
    sub_10004D2C8(a21);
  }
  if (a23) {
    sub_10004D2C8(a23);
  }
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a10);
  }
  if ((a13 & 1) == 0) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1004C5C6C(void *a1)
{
  *a1 = off_1019D4C18;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1004C5CB8(void *a1)
{
  *a1 = off_1019D4C18;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_1004C5D24(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_1019D4C18;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1004C5D80(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019D4C18;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1004C5DB8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1004C5DC8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1004C5E08(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      xpc_object_t v5 = *(RegistrationController **)(a1 + 8);
      if (v5) {
        RegistrationController::handleECBMTimerExpired(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_1004C5E68(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004C5EA8()
{
}

void sub_1004C5EB8()
{
}

void *sub_1004C5ECC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1019D4C98;
  result[1] = v3;
  return result;
}

uint64_t sub_1004C5F14(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D4C98;
  a2[1] = v2;
  return result;
}

void sub_1004C5F40(uint64_t a1, unsigned __int8 *a2)
{
}

uint64_t sub_1004C5F4C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004C5F8C()
{
}

void sub_1004C5F98(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D4D18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004C5FB8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D4D18;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004C600C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1004C6034(NetworkRegistrationDriverEventHandlerInterface *this)
{
  *(void *)this = off_1019D4D68;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  NetworkRegistrationDriverEventHandlerInterface::~NetworkRegistrationDriverEventHandlerInterface(this);
}

void sub_1004C6090(NetworkRegistrationDriverEventHandlerInterface *this)
{
  *(void *)this = off_1019D4D68;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  NetworkRegistrationDriverEventHandlerInterface::~NetworkRegistrationDriverEventHandlerInterface(this);

  operator delete();
}

void sub_1004C6100(uint64_t a1, char a2)
{
}

void sub_1004C6108(uint64_t a1, int a2, __int16 a3)
{
}

void sub_1004C6114(uint64_t a1, int a2, int a3, char a4, int a5)
{
}

void sub_1004C611C(uint64_t a1, int a2, char a3, char a4)
{
}

void sub_1004C6124(uint64_t a1, int a2)
{
}

void sub_1004C612C(uint64_t a1)
{
}

void sub_1004C6134(uint64_t a1, int a2, long long *a3)
{
  uint64_t v4 = (uint64_t *)(a1 + 8);
  sub_1003FB348((char *)__dst, a3);
  sub_1003FA654(v4, a2, (long long *)__dst);
  if (v18 < 0) {
    operator delete(__p);
  }
  if (v16 && v15 < 0) {
    operator delete(v14);
  }
  if (v13 && v12 < 0) {
    operator delete(v11);
  }
  if (v10 < 0) {
    operator delete(v9);
  }
  if (v8 < 0) {
    operator delete(v7);
  }
  if (v6 < 0) {
    operator delete(__dst[0]);
  }
}

void sub_1004C61EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1003FB4D8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1004C6200(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v6 = *(_OWORD *)(a3 + 48);
  void v8[2] = *(_OWORD *)(a3 + 32);
  void v8[3] = v6;
  uint64_t v9 = *(void *)(a3 + 64);
  long long v7 = *(_OWORD *)(a3 + 16);
  v8[0] = *(_OWORD *)a3;
  v8[1] = v7;
  sub_100026914((MCC *)&v10, (const MCC *)(a3 + 72));
  sub_1000268AC((MCC *)&v14, (const MCC *)(a3 + 112));
  sub_1003FA760((uint64_t *)(a1 + 8), a2, (uint64_t)v8);
  if (v17 && v16 < 0) {
    operator delete(__p);
  }
  if (v13)
  {
    if (v12 < 0) {
      operator delete(v11);
    }
  }
}

void sub_1004C62AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25)
{
}

void sub_1004C62E0(uint64_t a1)
{
}

void sub_1004C62E8(uint64_t a1, uint64_t a2, char a3, char a4)
{
}

void sub_1004C62F0(uint64_t a1, uint64_t a2, char a3)
{
}

void sub_1004C62F8(uint64_t a1, int a2, char a3)
{
}

void sub_1004C6300(uint64_t a1, int a2, uint64_t a3, int a4)
{
  long long v6 = (uint64_t *)(a1 + 8);
  std::string __p = 0;
  char v8 = 0;
  uint64_t v9 = 0;
  sub_1003FB56C(&__p, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  sub_1003FAAE0(v6, a2, (uint64_t)&__p, a4);
  if (__p)
  {
    char v8 = __p;
    operator delete(__p);
  }
}

void sub_1004C6378(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004C6394(uint64_t a1, char a2, int a3)
{
}

void sub_1004C639C(uint64_t a1, uint64_t a2)
{
}

void sub_1004C63A4(uint64_t a1, int a2)
{
}

void sub_1004C63AC(uint64_t a1)
{
}

void sub_1004C63B4(uint64_t a1)
{
}

void sub_1004C63BC(uint64_t a1, int a2)
{
}

void sub_1004C63C4(uint64_t a1, int a2, int a3)
{
}

void sub_1004C63CC(uint64_t a1)
{
}

void sub_1004C63D8(uint64_t a1)
{
}

void sub_1004C63E0(uint64_t a1)
{
}

void sub_1004C640C(uint64_t a1, int a2, MCC *a3)
{
}

void sub_1004C6414(uint64_t a1)
{
}

void *sub_1004C641C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1003FB63C((uint64_t)v6, a3);
  sub_1003FB1D4((uint64_t *)(a1 + 8), a2, (uint64_t)v6);
  return sub_1003FB6D4(v6);
}

void sub_1004C6498(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1003FB6D4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1004C64B4(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    xpc_object_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      long long v6 = v5;
      if (a1[4]) {
        sub_10041DE0C(a1 + 6, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1004C652C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_1004C6540(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = (void *)a2[6];
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_1004C658C(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *sub_1004C65E0(void *a1)
{
  *a1 = off_1019D4EB8;
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[5];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

void sub_1004C6644(void *a1)
{
  *a1 = off_1019D4EB8;
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[5];
  if (v4) {
    sub_10004D2C8(v4);
  }

  operator delete();
}

void *sub_1004C66C8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x50uLL);
  void *v2 = off_1019D4EB8;
  sub_1004C69A4((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_1004C671C(uint64_t a1, void *a2)
{
  *a2 = off_1019D4EB8;
  return sub_1004C69A4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1004C6748(uint64_t a1)
{
}

void sub_1004C6750(void *a1)
{
  sub_1004C6A00(a1 + 1);

  operator delete(a1);
}

void sub_1004C678C(uint64_t a1, _DWORD *a2)
{
  if (*a2 == 4)
  {
    uint64_t v3 = **(NSObject ***)(a1 + 8);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)char v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I 5G Auto enablement after upgrade not needed", v11, 2u);
    }
  }
  else
  {
    uint64_t v4 = *(os_log_t **)(a1 + 24);
    xpc_object_t v5 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)char v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I 5G Auto enablement after upgrade needed", v11, 2u);
      uint64_t v4 = *(os_log_t **)(a1 + 24);
    }
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    uint64_t v9 = *(void *)(a1 + 48);
    char v8 = *(std::__shared_weak_count **)(a1 + 56);
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    char v12 = 0;
    uint64_t v10 = operator new(0x28uLL);
    *(void *)uint64_t v10 = off_1019D4F38;
    int v10[2] = v7;
    *((void *)v10 + 2) = v4;
    *((void *)v10 + 3) = v9;
    *((void *)v10 + 4) = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    char v12 = v10;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint8_t *))(*(void *)v6 + 24))(v6, v7, 4, v11);
    sub_100449214(v11);
    if (v8) {
      sub_10004D2C8(v8);
    }
  }
}

void sub_1004C6930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100449214(&a9);
  if (v9) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1004C6958(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1004C6998()
{
}

uint64_t sub_1004C69A4(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = *(void *)a2;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 32);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(result + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a2 + 64);
  *(void *)(result + 56) = *(void *)(a2 + 56);
  *(void *)(result + 64) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1004C6A00(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[4];
  if (v4)
  {
    sub_10004D2C8(v4);
  }
}

void *sub_1004C6A5C(void *a1)
{
  *a1 = off_1019D4F38;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1004C6AA8(void *a1)
{
  *a1 = off_1019D4F38;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_1004C6B14(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_1019D4F38;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1004C6B78(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019D4F38;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1004C6BB8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1004C6BC8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_1004C6C08(uint64_t a1, _DWORD *a2)
{
  if (*a2)
  {
    uint64_t v3 = **(NSObject ***)(a1 + 16);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)xpc_object_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Failed to enable 5G Auto after upgrade", v5, 2u);
    }
  }
  else
  {
    (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 24) + 48))(*(void *)(a1 + 24), *(unsigned int *)(a1 + 8), 1);
    uint64_t v4 = **(NSObject ***)(a1 + 16);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I 5G Auto has been enabled after upgrade", buf, 2u);
    }
  }
}

uint64_t sub_1004C6CEC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019D4FA8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1004C6D2C()
{
  return &off_1019D4FA8;
}

void *sub_1004C6D38(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *sub_1004C6DBC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 32);
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = *(NSObject **)(v1 + 16);
    if (v3)
    {
      dispatch_group_leave(v3);
      uint64_t v4 = *(NSObject **)(v1 + 16);
      if (v4) {
        dispatch_release(v4);
      }
    }
    xpc_release(*(xpc_object_t *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

uint64_t *sub_1004C6E38(std::__shared_weak_count **a1)
{
  uint32_t v102 = a1;
  uint64_t v2 = *a1;
  *(void *)long long buf = a1 + 1;
  *(void *)&uint8_t buf[8] = "kIsEraseInstall";
  sub_100048BAC((uint64_t)buf, v114);
  int v4 = xpc::dyn_cast_or_default((xpc *)v114, 0, v3);
  xpc_release(*(xpc_object_t *)v114);
  if (v4)
  {
    shared_weak_owners = v2[1].__shared_weak_owners_;
    if (os_log_type_enabled(shared_weak_owners, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, shared_weak_owners, OS_LOG_TYPE_DEFAULT, "#N Erase-install, skipping migration", buf, 2u);
    }
    return sub_1004C6DBC((uint64_t *)&v102);
  }
  uint64_t v7 = (std::__shared_weak_count *)v2[2].__shared_weak_owners_;
  char v8 = (std::__shared_weak_count **)&v2[3];
  if (v7 != &v2[3])
  {
    do
    {
      uint64_t v9 = v7[1].__shared_weak_owners_;
      uint64_t v10 = a1[2];
      dispatch_group_t group = v10;
      if (v10)
      {
        dispatch_retain(v10);
        if (group) {
          dispatch_group_enter(group);
        }
      }
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v9 + 40))(v9, &group);
      xpc_object_t v5 = (capabilities::ct *)group;
      if (group)
      {
        dispatch_group_leave(group);
        xpc_object_t v5 = (capabilities::ct *)group;
        if (group) {
          dispatch_release(group);
        }
      }
      shared_owners = (std::__shared_weak_count *)v7->__shared_owners_;
      if (shared_owners)
      {
        do
        {
          char v12 = (std::__shared_weak_count **)shared_owners;
          shared_owners = (std::__shared_weak_count *)shared_owners->__vftable;
        }
        while (shared_owners);
      }
      else
      {
        do
        {
          char v12 = (std::__shared_weak_count **)v7->__shared_weak_owners_;
          BOOL v84 = *v12 == v7;
          uint64_t v7 = (std::__shared_weak_count *)v12;
        }
        while (!v84);
      }
      uint64_t v7 = (std::__shared_weak_count *)v12;
    }
    while (v12 != v8);
  }
  char v13 = (const void **)capabilities::ct::supports5G(v5);
  uint64_t v101 = v2;
  if (v13)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)v2[5].__shared_weak_owners_);
    char v15 = ServiceMap;
    if (v16 < 0)
    {
      char v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v18 = 5381;
      do
      {
        uint64_t v16 = v18;
        unsigned int v19 = *v17++;
        uint64_t v18 = (33 * v18) ^ v19;
      }
      while (v19);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v16;
    xpc_object_t v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
    if (v20)
    {
      uint64_t v21 = v20[3];
      size_t v22 = (std::__shared_weak_count *)v20[4];
      if (v22)
      {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v15);
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v22);
        char v93 = 0;
        if (!v21) {
          goto LABEL_24;
        }
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v15);
    size_t v22 = 0;
    char v93 = 1;
    if (!v21)
    {
LABEL_24:
      uint64_t v23 = v2[1].__shared_weak_owners_;
      char v13 = (const void **)os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
      if (v13)
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Unable to retrieve CFPreferencesInterface. Fail to check and enable 5G Auto on upgrade", buf, 2u);
      }
LABEL_101:
      if ((v93 & 1) == 0) {
        sub_10004D2C8(v22);
      }
      goto LABEL_103;
    }
LABEL_28:
    int v24 = (std::mutex *)Registry::getServiceMap((Registry *)v2[5].__shared_weak_owners_);
    uint64_t v25 = v24;
    if (v26 < 0)
    {
      std::string::size_type v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v28 = 5381;
      do
      {
        uint64_t v26 = v28;
        unsigned int v29 = *v27++;
        uint64_t v28 = (33 * v28) ^ v29;
      }
      while (v29);
    }
    std::mutex::lock(v24);
    *(void *)long long buf = v26;
    uint64_t v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)buf);
    if (v30)
    {
      uint64_t v31 = (std::__shared_weak_count *)v30[4];
      uint64_t v97 = v30[3];
      if (v31)
      {
        p_shared_owners = &v31->__shared_owners_;
        atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
        BOOL v33 = v25;
        xpc_object_t v34 = v31;
        std::mutex::unlock(v33);
        atomic_fetch_add_explicit(p_shared_owners, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v34);
        char v98 = 0;
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v97 = 0;
    }
    std::mutex::unlock(v25);
    xpc_object_t v34 = 0;
    char v98 = 1;
LABEL_36:
    group_session v95 = v34;
    if (!v97)
    {
      unsigned int v46 = v2[1].__shared_weak_owners_;
      char v13 = (const void **)os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
      if (v13)
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Unable to retrieve SaveDataModeInterface. Fail to check and enable 5G Auto on upgrade", buf, 2u);
      }
      goto LABEL_99;
    }
    uint64_t v35 = (std::mutex *)Registry::getServiceMap((Registry *)v2[5].__shared_weak_owners_);
    unsigned __int16 v36 = v35;
    if (v37 < 0)
    {
      uint64_t v38 = (unsigned __int8 *)(v37 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v39 = 5381;
      do
      {
        uint64_t v37 = v39;
        unsigned int v40 = *v38++;
        uint64_t v39 = (33 * v39) ^ v40;
      }
      while (v40);
    }
    std::mutex::lock(v35);
    *(void *)long long buf = v37;
    uint64_t v41 = sub_10004D37C(&v36[1].__m_.__sig, (unint64_t *)buf);
    if (v41)
    {
      uint64_t v42 = (std::__shared_weak_count *)v41[4];
      unint64_t v100 = (void *)v41[3];
      if (v42)
      {
        uint64_t v43 = &v42->__shared_owners_;
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        CFTypeID v44 = v36;
        uint64_t v45 = v42;
        std::mutex::unlock(v44);
        atomic_fetch_add_explicit(v43, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v45);
        char v92 = 0;
LABEL_47:
        uint64_t v94 = v45;
        if (v100)
        {
          CFTypeID v47 = (std::__shared_weak_count **)v2[2].__shared_weak_owners_;
          if (v47 != v8)
          {
            while (1)
            {
              CFBooleanRef v48 = (NSObject **)(*((uint64_t (**)(std::__shared_weak_count_vtbl *, void))v2[2].~__shared_weak_count
                                  + 2))(v2[2].__vftable, *((unsigned int *)v47 + 8));
              uint64_t v49 = *((int *)v47 + 8);
              CFStringRef v50 = @"k5GAutoCheckedAfterUpgrade_1";
              if (v49 <= 3) {
                CFStringRef v50 = (const __CFString *)qword_1019D53D8[v49];
              }
              (*(void (**)(unsigned char *__return_ptr))(*(void *)v2[10].__shared_owners_ + 96))(v114);
              uint64_t v51 = *(BOOL **)v114;
              v104[0] = 0;
              if (!*(void *)v114) {
                break;
              }
              CFTypeID v52 = CFGetTypeID(*(CFTypeRef *)v114);
              if (v52 == CFBooleanGetTypeID()) {
                ctu::cf::assign((ctu::cf *)v104, v51, v53);
              }
              int v54 = v104[0];
              sub_1000577C4((const void **)v114);
              if (!v54) {
                goto LABEL_71;
              }
              *(void *)CFTypeID v114 = 0;
              (*(void (**)(unsigned char *__return_ptr, uint64_t, const __CFString *, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v21 + 40))(v114, v21, v50, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
              if (*(const CFBooleanRef *)v114 == kCFBooleanTrue)
              {
                CFNumberRef v58 = *v48;
                if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)uint64_t v104 = 0;
                  _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I 5G Auto check was already done on previous upgrade", v104, 2u);
                }
                char v13 = sub_1000577C4((const void **)v114);
              }
              else
              {
                sub_1000577C4((const void **)v114);
                (*(void (**)(uint64_t, const __CFString *, const CFBooleanRef, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v21 + 16))(v21, v50, kCFBooleanTrue, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
                (*(void (**)(uint64_t, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v21 + 48))(v21, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
                *(_OWORD *)&v114[16] = 0u;
                long long v115 = 0u;
                *(_OWORD *)CFTypeID v114 = 0u;
                *(_DWORD *)CFTypeID v114 = *((_DWORD *)v47 + 8);
                *(void *)&v114[8] = v48;
                *(void *)&v114[16] = v100;
                *(void *)&v114[24] = v94;
                if ((v92 & 1) == 0) {
                  atomic_fetch_add_explicit(&v94->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                *(void *)&long long v115 = v97;
                *((void *)&v115 + 1) = v95;
                if ((v98 & 1) == 0) {
                  atomic_fetch_add_explicit(&v95->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v55 = *((unsigned int *)v47 + 8);
                *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)v114;
                *(void *)long long buf = v48;
                uint64_t v106 = v100;
                CFDictionaryRef v107 = v94;
                if (v94) {
                  atomic_fetch_add_explicit(&v94->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v108 = v97;
                CFArrayRef v109 = v95;
                if (v95) {
                  atomic_fetch_add_explicit(&v95->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v110 = v97;
                CFTypeID v111 = v95;
                if ((v98 & 1) == 0) {
                  atomic_fetch_add_explicit(&v95->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                CFNumberRef v113 = 0;
                unsigned int v56 = operator new(0x50uLL);
                void *v56 = off_1019D4EB8;
                v56[1] = v48;
                *((_OWORD *)v56 + 1) = *(_OWORD *)&buf[8];
                v56[4] = v100;
                v56[5] = v94;
                if (v94) {
                  atomic_fetch_add_explicit(&v94->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                v56[6] = v97;
                v56[7] = v95;
                if (v95)
                {
                  atomic_fetch_add_explicit(&v95->__shared_owners_, 1uLL, memory_order_relaxed);
                  v56[8] = v97;
                  v56[9] = v95;
                  atomic_fetch_add_explicit(&v95->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                else
                {
                  v56[8] = v97;
                  v56[9] = 0;
                }
                CFNumberRef v113 = v56;
                (*(void (**)(void *, uint64_t, void *))(*(void *)v100 + 32))(v100, v55, v112);
                sub_1004C6D38(v112);
                if (v111) {
                  sub_10004D2C8(v111);
                }
                if (v109) {
                  sub_10004D2C8(v109);
                }
                if (v107) {
                  sub_10004D2C8(v107);
                }
                if (*((void *)&v115 + 1)) {
                  sub_10004D2C8(*((std::__shared_weak_count **)&v115 + 1));
                }
                char v13 = *(const void ***)&v114[24];
                if (*(void *)&v114[24]) {
                  sub_10004D2C8(*(std::__shared_weak_count **)&v114[24]);
                }
              }
LABEL_88:
              uint64_t v59 = v47[1];
              if (v59)
              {
                do
                {
                  CFBooleanRef v60 = (std::__shared_weak_count **)v59;
                  uint64_t v59 = (std::__shared_weak_count *)v59->__vftable;
                }
                while (v59);
              }
              else
              {
                do
                {
                  CFBooleanRef v60 = (std::__shared_weak_count **)v47[2];
                  BOOL v84 = *v60 == (std::__shared_weak_count *)v47;
                  CFTypeID v47 = v60;
                }
                while (!v84);
              }
              CFTypeID v47 = v60;
              if (v60 == v8) {
                goto LABEL_97;
              }
            }
            sub_1000577C4((const void **)v114);
LABEL_71:
            CFTypeID v57 = *v48;
            if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)CFTypeID v114 = 138412546;
              *(void *)&v114[4] = @"Enable5GAutoAfterUpgrade";
              *(_WORD *)&v114[12] = 2112;
              *(void *)&v114[14] = v50;
              _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I '%@' is not present. Clearing any '%@'", v114, 0x16u);
            }
            (*(void (**)(uint64_t, const __CFString *, void, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v21 + 16))(v21, v50, 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
            char v13 = (const void **)(*(uint64_t (**)(uint64_t, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v21 + 48))(v21, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
            goto LABEL_88;
          }
        }
        else
        {
          uint64_t v61 = v2[1].__shared_weak_owners_;
          char v13 = (const void **)os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
          if (v13)
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "Unable to retrieve MaxDataRateInterface. Fail to check and enable 5G Auto on upgrade", buf, 2u);
          }
        }
LABEL_97:
        if ((v92 & 1) == 0) {
          sub_10004D2C8(v94);
        }
LABEL_99:
        if ((v98 & 1) == 0) {
          sub_10004D2C8(v95);
        }
        goto LABEL_101;
      }
    }
    else
    {
      unint64_t v100 = 0;
    }
    std::mutex::unlock(v36);
    uint64_t v45 = 0;
    char v92 = 1;
    goto LABEL_47;
  }
LABEL_103:
  if (!capabilities::ct::supports5G((capabilities::ct *)v13)) {
    return sub_1004C6DBC((uint64_t *)&v102);
  }
  xpc_object_t v62 = (std::mutex *)Registry::getServiceMap((Registry *)v2[5].__shared_weak_owners_);
  uint64_t v63 = v62;
  if (v64 < 0)
  {
    uint64_t v65 = (unsigned __int8 *)(v64 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v66 = 5381;
    do
    {
      uint64_t v64 = v66;
      unsigned int v67 = *v65++;
      uint64_t v66 = (33 * v66) ^ v67;
    }
    while (v67);
  }
  std::mutex::lock(v62);
  *(void *)long long buf = v64;
  uint64_t v68 = sub_10004D37C(&v63[1].__m_.__sig, (unint64_t *)buf);
  if (v68)
  {
    uint64_t v69 = v68[3];
    xpc_object_t v70 = (std::__shared_weak_count *)v68[4];
    if (v70)
    {
      atomic_fetch_add_explicit(&v70->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v63);
      atomic_fetch_add_explicit(&v70->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v70);
      char v99 = 0;
      goto LABEL_112;
    }
  }
  else
  {
    uint64_t v69 = 0;
  }
  std::mutex::unlock(v63);
  xpc_object_t v70 = 0;
  char v99 = 1;
LABEL_112:
  dispatch_group_t v96 = v70;
  if (v69)
  {
    __int16 v71 = (std::__shared_weak_count **)v2[2].__shared_weak_owners_;
    if (v71 != v8)
    {
      while (1)
      {
        uint64_t v72 = (NSObject **)(*((uint64_t (**)(std::__shared_weak_count_vtbl *, void))v2[2].~__shared_weak_count
                            + 2))(v2[2].__vftable, *((unsigned int *)v71 + 8));
        uint64_t v73 = *((int *)v71 + 8);
        CFStringRef v74 = @"k5GStandaloneCheckedAfterUpgrade_1";
        if (v73 <= 3) {
          CFStringRef v74 = (const __CFString *)qword_1019D53F8[v73];
        }
        (*(void (**)(unsigned char *__return_ptr))(*(void *)v2[10].__shared_owners_ + 96))(buf);
        uint64_t v75 = *(BOOL **)buf;
        v114[0] = 0;
        if (!*(void *)buf) {
          break;
        }
        CFTypeID v76 = CFGetTypeID(*(CFTypeRef *)buf);
        if (v76 == CFBooleanGetTypeID()) {
          ctu::cf::assign((ctu::cf *)v114, v75, v77);
        }
        int v78 = v114[0];
        sub_1000577C4((const void **)buf);
        if (!v78) {
          goto LABEL_130;
        }
        *(void *)long long buf = 0;
        (*(void (**)(unsigned char *__return_ptr, uint64_t, const __CFString *, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v69 + 40))(buf, v69, v74, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        uint64_t v2 = v101;
        if (*(const CFBooleanRef *)buf == kCFBooleanTrue)
        {
          BOOL v89 = *v72;
          if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)CFTypeID v114 = 0;
            _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "#I 5G Standalone check was already done on previous upgrade", v114, 2u);
          }
          sub_1000577C4((const void **)buf);
        }
        else
        {
          sub_1000577C4((const void **)buf);
          (*(void (**)(uint64_t, const __CFString *, const CFBooleanRef, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v69 + 16))(v69, v74, kCFBooleanTrue, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
          (*(void (**)(uint64_t, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v69 + 48))(v69, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
          unsigned __int16 v79 = ((uint64_t (*)(std::__shared_weak_count *))v71[5]->__vftable[20].__on_zero_shared_weak)(v71[5]);
          char v80 = v79;
          unsigned int v81 = v79;
          uint64_t v82 = *v72;
          BOOL v83 = os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT);
          BOOL v84 = v81 < 0x100 || v80 == 0;
          if (v84)
          {
            uint64_t v2 = v101;
            if (v83)
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I Enable 5G Standalone after upgrade", buf, 2u);
            }
            ((void (*)(std::__shared_weak_count *, uint64_t))v71[5]->__vftable[20].~__shared_weak_count)(v71[5], 1);
            int v85 = *((_DWORD *)v71 + 8);
            *(void *)long long buf = _NSConcreteStackBlock;
            *(void *)&uint8_t buf[8] = 0x40000000;
            *(void *)&uint8_t buf[16] = sub_100515678;
            uint64_t v106 = &unk_1019DD908;
            CFDictionaryRef v107 = v101;
            BYTE4(v108) = 1;
            LODWORD(v108) = v85;
            sub_100515498((wis::MetricFactory *)0x8012B);
            RegistrationController::send5GStandaloneEnabledSettingFromPreference_sync((uint64_t)v101, *((unsigned int *)v71 + 8), 2);
            RegistrationController::update5GSACapabilityRestProperty_sync((capabilities::ct *)v101, *((unsigned int *)v71 + 8));
          }
          else
          {
            uint64_t v2 = v101;
            if (v83)
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I 5G Standalone is already enabled. Automatic enablement on upgrade is not needed", buf, 2u);
            }
          }
        }
LABEL_133:
        uint64_t v87 = v71[1];
        if (v87)
        {
          do
          {
            xpc_object_t v88 = (std::__shared_weak_count **)v87;
            uint64_t v87 = (std::__shared_weak_count *)v87->__vftable;
          }
          while (v87);
        }
        else
        {
          do
          {
            xpc_object_t v88 = (std::__shared_weak_count **)v71[2];
            BOOL v84 = *v88 == (std::__shared_weak_count *)v71;
            __int16 v71 = v88;
          }
          while (!v84);
        }
        __int16 v71 = v88;
        if (v88 == v8) {
          goto LABEL_147;
        }
      }
      sub_1000577C4((const void **)buf);
LABEL_130:
      int v86 = *v72;
      if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = @"Enable5GStandaloneAfterUpgrade";
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v74;
        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "#I '%@' is not present. Clearing any '%@'", buf, 0x16u);
      }
      (*(void (**)(uint64_t, const __CFString *, void, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v69 + 16))(v69, v74, 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      uint64_t v2 = v101;
      (*(void (**)(uint64_t, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v69 + 48))(v69, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      goto LABEL_133;
    }
  }
  else
  {
    uint64_t v90 = v2[1].__shared_weak_owners_;
    if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_ERROR, "Unable to retrieve CFPreferencesInterface. Fail to check and enable 5G Standalone on upgrade", buf, 2u);
    }
  }
LABEL_147:
  if ((v99 & 1) == 0) {
    sub_10004D2C8(v96);
  }
  return sub_1004C6DBC((uint64_t *)&v102);
}

void sub_1004C7DBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, int a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,dispatch_group_t group,uint64_t a27,uint64_t a28,char a29)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

MCC *sub_1004C7EE8(MCC *a1, uint64_t a2)
{
  MCC::MCC(a1, (const MCC *)a2);
  MCC::MCC((MCC *)(v4 + 32), (const MCC *)(a2 + 32));
  return a1;
}

void sub_1004C7F20(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*(void **)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

void sub_1004C7F3C(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void, void))(**(void **)(**(void **)a1 + 344) + 144))(*(void *)(**(void **)a1 + 344), *(unsigned int *)(*(void *)a1 + 8), *(unsigned int *)(*(void *)a1 + 12));
  operator delete();
}

void sub_1004C7FB8()
{
}

void sub_1004C7FE4(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  BOOL v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)*a1 + 2));
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  RegistrationController::getModel_sync(v2, *((_DWORD *)v1 + 2), &v9);
  uint64_t v4 = v9;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 784))(v9);
    if ((operator==() & 1) == 0)
    {
      xpc_object_t v5 = *v3;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = asString();
        uint64_t v7 = asString();
        *(_DWORD *)long long buf = 136315394;
        uint64_t v12 = v6;
        __int16 v13 = 2080;
        uint64_t v14 = v7;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Encryption status is changing from %s to %s", buf, 0x16u);
      }
      (*(void (**)(uint64_t, void))(*(void *)v4 + 792))(v4, *((unsigned int *)v1 + 3));
      (*(void (**)(void, void, void))(**(void **)(v2 + 328) + 128))(*(void *)(v2 + 328), *((unsigned int *)v1 + 2), *((unsigned int *)v1 + 3));
    }
  }
  else
  {
    char v8 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Unable to find model when updating encryption status", buf, 2u);
    }
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  operator delete();
}

void sub_1004C821C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  operator delete();
}

void sub_1004C8260(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  BOOL v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)*a1 + 2));
  uint64_t v35 = 0;
  unsigned __int16 v36 = 0;
  RegistrationController::getModel_sync(v2, *((_DWORD *)v1 + 2), &v35);
  if (!v35)
  {
    uint64_t v9 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Unable to find model", buf, 2u);
    }
    goto LABEL_50;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v35 + 928))(v35, *((unsigned __int8 *)v1 + 12) | 0x100);
  switch(*(_DWORD *)(v2 + 440))
  {
    case 0:
    case 2:
      os_log_t v4 = *v3;
      if (!os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_50;
      }
      int v5 = *((unsigned __int8 *)v1 + 12);
      uint64_t v6 = asString();
      uint64_t v7 = "true";
      if (!v5) {
        uint64_t v7 = "false";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v7;
      __int16 v38 = 2080;
      uint64_t v39 = v6;
      char v8 = "#N Ignoring CMAS camp only result (%s) for mode (%s)";
      goto LABEL_19;
    case 1:
      if (*((_DWORD *)v1 + 4) == 2) {
        goto LABEL_21;
      }
      os_log_t v4 = *v3;
      if (!os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_50;
      }
      uint64_t v10 = asString();
      char v11 = "true";
      if (!*((unsigned char *)v1 + 12)) {
        char v11 = "false";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v10;
      __int16 v38 = 2080;
      uint64_t v39 = (uint64_t)v11;
      char v8 = "#N Ignoring enabling CMAS camp only expected mode %s result: %s";
      goto LABEL_19;
    case 3:
      if (!*((_DWORD *)v1 + 4)) {
        goto LABEL_21;
      }
      os_log_t v4 = *v3;
      if (!os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_50;
      }
      uint64_t v12 = asString();
      __int16 v13 = "true";
      if (!*((unsigned char *)v1 + 12)) {
        __int16 v13 = "false";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v12;
      __int16 v38 = 2080;
      uint64_t v39 = (uint64_t)v13;
      char v8 = "#N Ignoring disabling CMAS camp only expected mode %s result: %s";
LABEL_19:
      uint64_t v14 = v4;
      uint32_t v15 = 22;
      goto LABEL_20;
    default:
LABEL_21:
      if (*(void *)(v2 + 80) < 2uLL)
      {
        if (!*((unsigned char *)v1 + 12))
        {
          int v24 = *((_DWORD *)v1 + 4);
          if (v24)
          {
            if (v24 != 2) {
              goto LABEL_50;
            }
            sub_100058DB0(buf, "/cc/props/cmas_camp_only_mode");
            uint64_t v25 = asString();
            ctu::rest::detail::write_enum_string_value((uint64_t *)object, 0, v25, v26);
            ctu::RestModule::setProperty();
            xpc_release(object[0]);
          }
          else
          {
            sub_100058DB0(buf, "/cc/props/cmas_camp_only_mode");
            uint64_t v31 = asString();
            ctu::rest::detail::write_enum_string_value((uint64_t *)object, (ctu::rest::detail *)2, v31, v32);
            ctu::RestModule::setProperty();
            xpc_release(object[0]);
          }
          goto LABEL_45;
        }
      }
      else
      {
        uint64_t v16 = *(void **)(v2 + 64);
        if (v16 != (void *)(v2 + 72))
        {
          char v17 = 0;
          do
          {
            if ((*(unsigned __int16 (**)(void))(*(void *)v16[5] + 936))(v16[5]) <= 0xFFu)
            {
              uint64_t v30 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v16 + 8));
              if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                char v8 = "#I Camp only result not received";
                uint64_t v14 = v30;
                uint32_t v15 = 2;
LABEL_20:
                _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v8, buf, v15);
              }
              goto LABEL_50;
            }
            unsigned __int16 v18 = (*(uint64_t (**)(void))(*(void *)v16[5] + 936))(v16[5]);
            if (v18 <= 0xFFu) {
              sub_10016C840();
            }
            unsigned int v19 = (void *)v16[1];
            if (v19)
            {
              do
              {
                xpc_object_t v20 = v19;
                unsigned int v19 = (void *)*v19;
              }
              while (v19);
            }
            else
            {
              do
              {
                xpc_object_t v20 = (void *)v16[2];
                BOOL v21 = *v20 == (void)v16;
                uint64_t v16 = v20;
              }
              while (!v21);
            }
            v17 |= v18 == 0;
            uint64_t v16 = v20;
          }
          while (v20 != (void *)(v2 + 72));
          if (v17)
          {
            size_t v22 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Camp only result failed - Resetting!", buf, 2u);
            }
            sub_100058DB0(object, "Camp only request failure");
            rest::ResetPayload::ResetPayload();
            sub_1004BC4DC();
            if (v40 < 0) {
              operator delete(*(void **)buf);
            }
            if (v34 < 0)
            {
              xpc_object_t v23 = object[0];
              goto LABEL_47;
            }
            goto LABEL_50;
          }
        }
        if (!*((unsigned char *)v1 + 12)) {
          goto LABEL_50;
        }
      }
      sub_100058DB0(buf, "/cc/props/cmas_camp_only_mode");
      int v27 = *((_DWORD *)v1 + 4);
      uint64_t v28 = asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)object, (ctu::rest::detail *)v27, v28, v29);
      ctu::RestModule::setProperty();
      xpc_release(object[0]);
LABEL_45:
      object[0] = 0;
      if (v40 < 0)
      {
        xpc_object_t v23 = *(xpc_object_t *)buf;
LABEL_47:
        operator delete(v23);
      }
LABEL_50:
      if (v36) {
        sub_10004D2C8(v36);
      }
      operator delete();
  }
}

void sub_1004C8828(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004C893C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (int *)(*a1 + 1);
  uint64_t v3 = **a1;
  os_log_t v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *v2);
  int v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Received NR 5G disable status", buf, 2u);
  }
  uint64_t v6 = (_OWORD *)((char *)v1 + 12);
  NRDisableStatus::dumpState((NRDisableStatus *)((char *)v1 + 12), (const ctu::OsLogLogger *)v4);
  CFTypeID v52 = 0;
  CFBooleanRef v53 = 0;
  uint64_t v54 = 0;
  sub_1004C474C((uint64_t)&v52, v3 + 856);
  uint64_t v7 = v53;
  char v8 = (uint64_t *)&v53;
  if (!v53) {
    goto LABEL_14;
  }
  int v9 = *v2;
  uint64_t v10 = &v53;
  do
  {
    char v11 = v7;
    uint64_t v12 = v10;
    int v13 = *((_DWORD *)v7 + 7);
    if (v13 >= v9) {
      uint64_t v10 = (uint64_t **)v7;
    }
    else {
      ++v7;
    }
    uint64_t v7 = (uint64_t *)*v7;
  }
  while (v7);
  char v8 = (uint64_t *)&v53;
  if (v10 != &v53 && (v13 >= v9 ? (v14 = v11) : (v14 = v12), char v8 = (uint64_t *)v10, v9 >= v14[7]))
  {
    unsigned __int16 v18 = v12 + 4;
    unsigned int v19 = v11 + 4;
    if (v13 >= v9) {
      xpc_object_t v20 = v19;
    }
    else {
      xpc_object_t v20 = v18;
    }
    *xpc_object_t v20 = *v6;
  }
  else
  {
LABEL_14:
    *(void *)long long buf = 0;
    v50[0] = 0;
    uint32_t v15 = sub_10005CF3C(&v52, v8, (uint64_t **)buf, v50, v2);
    if (!*v15)
    {
      uint64_t v16 = operator new(0x30uLL);
      v16[7] = *v2;
      *((_OWORD *)v16 + 2) = *v6;
      uint64_t v17 = *(void *)buf;
      *(void *)uint64_t v16 = 0;
      *((void *)v16 + 1) = 0;
      *((void *)v16 + 2) = v17;
      *uint32_t v15 = (uint64_t)v16;
      if (*v52)
      {
        CFTypeID v52 = (uint64_t *)*v52;
        uint64_t v16 = (_DWORD *)*v15;
      }
      sub_100046C90(v53, (uint64_t *)v16);
      ++v54;
    }
  }
  if (*(void *)(v3 + 872) == v54)
  {
    BOOL v21 = *(void **)(v3 + 856);
    if (v21 == (void *)(v3 + 864)) {
      goto LABEL_87;
    }
    size_t v22 = v52;
    while (*((_DWORD *)v21 + 7) == *((_DWORD *)v22 + 7) && NRDisableStatus::operator==())
    {
      xpc_object_t v23 = (void *)v21[1];
      int v24 = v21;
      if (v23)
      {
        do
        {
          BOOL v21 = v23;
          xpc_object_t v23 = (void *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          BOOL v21 = (void *)v24[2];
          BOOL v25 = *v21 == (void)v24;
          int v24 = v21;
        }
        while (!v25);
      }
      uint64_t v26 = (uint64_t *)v22[1];
      if (v26)
      {
        do
        {
          int v27 = v26;
          uint64_t v26 = (uint64_t *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          int v27 = (uint64_t *)v22[2];
          BOOL v25 = *v27 == (void)v22;
          size_t v22 = v27;
        }
        while (!v25);
      }
      size_t v22 = v27;
      if (v21 == (void *)(v3 + 864)) {
        goto LABEL_87;
      }
    }
  }
  if ((uint64_t **)(v3 + 856) != &v52)
  {
    uint64_t v28 = (uint64_t **)v52;
    if (*(void *)(v3 + 872))
    {
      uint64_t v29 = *(void *)(v3 + 856);
      uint64_t v30 = (uint64_t **)(v3 + 864);
      *(void *)(v3 + 856) = v3 + 864;
      *(void *)(*(void *)(v3 + 864) + 16) = 0;
      *(void *)(v3 + 872) = 0;
      *(void *)(v3 + 864) = 0;
      if (*(void *)(v29 + 8)) {
        uint64_t v31 = *(void *)(v29 + 8);
      }
      else {
        uint64_t v31 = v29;
      }
      if (v31)
      {
        int v32 = sub_1000EA590(v31);
        if (v28 == &v53)
        {
          BOOL v33 = (void *)v31;
          uint64_t v39 = &v53;
        }
        else
        {
          do
          {
            BOOL v33 = v32;
            int v34 = *((_DWORD *)v28 + 7);
            *(_DWORD *)(v31 + 28) = v34;
            *(_OWORD *)(v31 + 32) = *((_OWORD *)v28 + 2);
            uint64_t v35 = *v30;
            unsigned __int16 v36 = (uint64_t **)(v3 + 864);
            uint64_t v37 = (uint64_t **)(v3 + 864);
            if (*v30)
            {
              do
              {
                while (1)
                {
                  unsigned __int16 v36 = (uint64_t **)v35;
                  if (v34 >= *((_DWORD *)v35 + 7)) {
                    break;
                  }
                  uint64_t v35 = (uint64_t *)*v35;
                  uint64_t v37 = v36;
                  if (!*v36) {
                    goto LABEL_52;
                  }
                }
                uint64_t v35 = (uint64_t *)v35[1];
              }
              while (v35);
              uint64_t v37 = v36 + 1;
            }
LABEL_52:
            sub_100046C38((uint64_t **)(v3 + 856), (uint64_t)v36, v37, (uint64_t *)v31);
            if (v32) {
              int v32 = sub_1000EA590((uint64_t)v32);
            }
            else {
              int v32 = 0;
            }
            __int16 v38 = v28[1];
            if (v38)
            {
              do
              {
                uint64_t v39 = (uint64_t **)v38;
                __int16 v38 = (uint64_t *)*v38;
              }
              while (v38);
            }
            else
            {
              do
              {
                uint64_t v39 = (uint64_t **)v28[2];
                BOOL v25 = *v39 == (uint64_t *)v28;
                uint64_t v28 = v39;
              }
              while (!v25);
            }
            if (!v33) {
              break;
            }
            uint64_t v31 = (uint64_t)v33;
            uint64_t v28 = v39;
          }
          while (v39 != &v53);
        }
        sub_1000346F8(v3 + 856, v33);
        if (v32)
        {
          for (uint64_t i = (void *)v32[2]; i; uint64_t i = (void *)i[2])
            int v32 = i;
          sub_1000346F8(v3 + 856, v32);
        }
      }
      else
      {
        uint64_t v39 = v28;
      }
    }
    else
    {
      uint64_t v39 = (uint64_t **)v52;
    }
    if (v39 != &v53)
    {
      uint64_t v41 = (uint64_t **)(v3 + 864);
      do
      {
        uint64_t v42 = (char *)operator new(0x30uLL);
        long long v43 = *(_OWORD *)((char *)v39 + 28);
        *((_DWORD *)v42 + 11) = *((_DWORD *)v39 + 11);
        *(_OWORD *)(v42 + 28) = v43;
        CFTypeID v44 = *v41;
        uint64_t v45 = (uint64_t **)(v3 + 864);
        unsigned int v46 = (uint64_t **)(v3 + 864);
        if (*v41)
        {
          do
          {
            while (1)
            {
              uint64_t v45 = (uint64_t **)v44;
              if (*((_DWORD *)v42 + 7) >= *((_DWORD *)v44 + 7)) {
                break;
              }
              CFTypeID v44 = (uint64_t *)*v44;
              unsigned int v46 = v45;
              if (!*v45) {
                goto LABEL_78;
              }
            }
            CFTypeID v44 = (uint64_t *)v44[1];
          }
          while (v44);
          unsigned int v46 = v45 + 1;
        }
LABEL_78:
        sub_100046C38((uint64_t **)(v3 + 856), (uint64_t)v45, v46, (uint64_t *)v42);
        CFTypeID v47 = v39[1];
        if (v47)
        {
          do
          {
            CFBooleanRef v48 = (uint64_t **)v47;
            CFTypeID v47 = (uint64_t *)*v47;
          }
          while (v47);
        }
        else
        {
          do
          {
            CFBooleanRef v48 = (uint64_t **)v39[2];
            BOOL v25 = *v48 == (uint64_t *)v39;
            uint64_t v39 = v48;
          }
          while (!v25);
        }
        uint64_t v39 = v48;
      }
      while (v48 != &v53);
    }
  }
  uint64_t v49 = *(void *)(v3 + 848);
  if (v49) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v49 + 48))(v49, v3 + 856);
  }
  int v51 = 0;
  v50[0] = 0;
  v50[1] = 0;
  RegistrationController::getNRStatus_sync(v3, *v2, (NRStatus *)v50);
  (*(void (**)(void, void, uint64_t *))(**(void **)(v3 + 328) + 144))(*(void *)(v3 + 328), *v2, v50);
  *(void *)long long buf = _NSConcreteStackBlock;
  uint64_t v56 = 0x40000000;
  CFTypeID v57 = sub_100515E08;
  CFNumberRef v58 = &unk_1019DD948;
  uint64_t v59 = v3;
  sub_100515C28((wis::MetricFactory *)0x80136);
  RegistrationController::update5GSACapabilityRestProperty_sync((capabilities::ct *)v3, *v2);
LABEL_87:
  sub_1000346F8((uint64_t)&v52, v53);
  operator delete();
}

void sub_1004C8EEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, void *a15)
{
}

uint64_t *sub_1004C8F38(unsigned int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v49 = a1;
  CFStringRef v50 = v1;
  uint64_t v2 = *(void **)v1;
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), v1[2]);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Received Geo Plmn info update", buf, 2u);
  }
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  CFNumberRef v58 = &v59;
  os_log_t v4 = (uint64_t *)v2[122];
  int v5 = (uint64_t **)(v2 + 123);
  if (v4 != v2 + 123)
  {
    do
    {
      int v6 = *((_DWORD *)v4 + 8);
      v61[0] = 0;
      uint64_t v64 = 0;
      uint64_t v7 = sub_1004C9628(&v58, (uint64_t *)&v59, v61, (uint64_t *)&v64, v6);
      if (!*v7)
      {
        char v8 = (uint64_t **)v7;
        *(void *)long long buf = 0;
        CFTypeID v52 = 0;
        CFBooleanRef v53 = 0;
        sub_1004C97B0(buf, (uint64_t)&v58, (_DWORD *)v4 + 8);
        int v9 = v61[0];
        uint64_t v10 = *(uint64_t **)buf;
        **(void **)long long buf = 0;
        v10[1] = 0;
        int v10[2] = (uint64_t)v9;
        *char v8 = v10;
        if (*v58)
        {
          CFNumberRef v58 = (uint64_t **)*v58;
          uint64_t v10 = *v8;
        }
        sub_100046C90(v59, v10);
        ++v60;
        *(void *)long long buf = 0;
        sub_10003FD44((uint64_t)buf, 0);
      }
      char v11 = (uint64_t *)v4[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = (uint64_t **)v11;
          char v11 = (uint64_t *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (uint64_t **)v4[2];
          BOOL v13 = *v12 == v4;
          os_log_t v4 = (uint64_t *)v12;
        }
        while (!v13);
      }
      os_log_t v4 = (uint64_t *)v12;
    }
    while (v12 != v5);
  }
  rest::GeoPlmn::GeoPlmn((rest::GeoPlmn *)buf, (const MCCAndMNC *)(v1 + 4));
  uint64_t v14 = v59;
  int v15 = v1[2];
  uint64_t v16 = (uint64_t *)&v59;
  if (!v59) {
    goto LABEL_25;
  }
  uint64_t v17 = &v59;
  do
  {
    unsigned __int16 v18 = v14;
    unsigned int v19 = v17;
    int v20 = *((_DWORD *)v14 + 8);
    if (v20 >= v15) {
      uint64_t v17 = (uint64_t **)v14;
    }
    else {
      ++v14;
    }
    uint64_t v14 = (uint64_t *)*v14;
  }
  while (v14);
  uint64_t v16 = (uint64_t *)&v59;
  if (v17 != &v59 && (v20 >= v15 ? (v21 = v18) : (v21 = v19), uint64_t v16 = (uint64_t *)v17, v15 >= v21[8]))
  {
    MCC::operator=();
    MCC::operator=();
  }
  else
  {
LABEL_25:
    uint64_t v63 = 0;
    uint64_t v64 = 0;
    size_t v22 = sub_1004C9628(&v58, v16, &v64, &v63, v15);
    if (!*v22)
    {
      xpc_object_t v23 = (uint64_t **)v22;
      uint64_t v62 = 0;
      int v24 = (uint64_t *)operator new(0x68uLL);
      v61[0] = v24;
      v61[1] = (uint64_t *)&v59;
      *((_DWORD *)v24 + 8) = v15;
      MCC::MCC((MCC *)(v24 + 5), (const MCC *)buf);
      MCC::MCC((MCC *)(v24 + 9), (const MCC *)&v55);
      LOBYTE(v62) = 1;
      BOOL v25 = v64;
      uint64_t v26 = v61[0];
      *v61[0] = 0;
      v26[1] = 0;
      v26[2] = (uint64_t)v25;
      *xpc_object_t v23 = v26;
      if (*v58)
      {
        CFNumberRef v58 = (uint64_t **)*v58;
        uint64_t v26 = *v23;
      }
      sub_100046C90(v59, v26);
      ++v60;
      v61[0] = 0;
      sub_10003FD44((uint64_t)v61, 0);
    }
  }
  if (v57 < 0) {
    operator delete(__p);
  }
  int v27 = (uint64_t ***)(v2 + 122);
  if (v54 < 0) {
    operator delete(v52);
  }
  if (v2[124] == v60)
  {
    uint64_t v28 = *v27;
    if (*v27 == v5) {
      goto LABEL_91;
    }
    uint64_t v29 = v58;
    while (*((_DWORD *)v28 + 8) == *((_DWORD *)v29 + 8) && MCCAndMNC::operator==())
    {
      uint64_t v30 = v28[1];
      uint64_t v31 = v28;
      if (v30)
      {
        do
        {
          uint64_t v28 = (uint64_t **)v30;
          uint64_t v30 = (uint64_t *)*v30;
        }
        while (v30);
      }
      else
      {
        do
        {
          uint64_t v28 = (uint64_t **)v31[2];
          BOOL v13 = *v28 == (uint64_t *)v31;
          uint64_t v31 = v28;
        }
        while (!v13);
      }
      int v32 = v29[1];
      if (v32)
      {
        do
        {
          BOOL v33 = (uint64_t **)v32;
          int v32 = (uint64_t *)*v32;
        }
        while (v32);
      }
      else
      {
        do
        {
          BOOL v33 = (uint64_t **)v29[2];
          BOOL v13 = *v33 == (uint64_t *)v29;
          uint64_t v29 = v33;
        }
        while (!v13);
      }
      uint64_t v29 = v33;
      if (v28 == v5) {
        goto LABEL_91;
      }
    }
  }
  if (v27 != &v58)
  {
    int v34 = v58;
    if (v2[124])
    {
      uint64_t v35 = *v27;
      *int v27 = v5;
      (*v5)[2] = 0;
      *int v5 = 0;
      v2[124] = 0;
      if (v35[1]) {
        unsigned __int16 v36 = v35[1];
      }
      else {
        unsigned __int16 v36 = (uint64_t *)v35;
      }
      *(void *)long long buf = v2 + 122;
      CFTypeID v52 = v36;
      CFBooleanRef v53 = v36;
      if (v36)
      {
        CFTypeID v52 = sub_1000EA590((uint64_t)v36);
        uint64_t v37 = &v59;
        if (v34 != &v59)
        {
          do
          {
            *((_DWORD *)v36 + 8) = *((_DWORD *)v34 + 8);
            MCC::operator=();
            MCC::operator=();
            __int16 v38 = *v5;
            uint64_t v39 = (uint64_t **)(v2 + 123);
            char v40 = (uint64_t **)(v2 + 123);
            if (*v5)
            {
              do
              {
                while (1)
                {
                  uint64_t v39 = (uint64_t **)v38;
                  if (*((_DWORD *)v53 + 8) >= *((_DWORD *)v38 + 8)) {
                    break;
                  }
                  __int16 v38 = (uint64_t *)*v38;
                  char v40 = v39;
                  if (!*v39) {
                    goto LABEL_64;
                  }
                }
                __int16 v38 = (uint64_t *)v38[1];
              }
              while (v38);
              char v40 = v39 + 1;
            }
LABEL_64:
            sub_100046C38((uint64_t **)v2 + 122, (uint64_t)v39, v40, v53);
            unsigned __int16 v36 = (uint64_t *)v52;
            CFBooleanRef v53 = (uint64_t *)v52;
            if (v52) {
              CFTypeID v52 = sub_1000EA590((uint64_t)v52);
            }
            uint64_t v41 = v34[1];
            if (v41)
            {
              do
              {
                uint64_t v37 = (uint64_t **)v41;
                uint64_t v41 = (uint64_t *)*v41;
              }
              while (v41);
            }
            else
            {
              do
              {
                uint64_t v37 = (uint64_t **)v34[2];
                BOOL v13 = *v37 == (uint64_t *)v34;
                int v34 = v37;
              }
              while (!v13);
            }
            if (!v36) {
              break;
            }
            int v34 = v37;
          }
          while (v37 != &v59);
        }
      }
      else
      {
        uint64_t v37 = v34;
      }
      sub_1004C9854((uint64_t)buf);
      int v34 = v37;
    }
    if (v34 != &v59)
    {
      do
      {
        *(void *)long long buf = 0;
        CFTypeID v52 = 0;
        CFBooleanRef v53 = 0;
        sub_1004C97B0(buf, (uint64_t)(v2 + 122), (_DWORD *)v34 + 8);
        uint64_t v42 = *v5;
        long long v43 = (uint64_t **)(v2 + 123);
        CFTypeID v44 = (uint64_t **)(v2 + 123);
        if (*v5)
        {
          do
          {
            while (1)
            {
              long long v43 = (uint64_t **)v42;
              if (*(_DWORD *)(*(void *)buf + 32) >= *((_DWORD *)v42 + 8)) {
                break;
              }
              uint64_t v42 = (uint64_t *)*v42;
              CFTypeID v44 = v43;
              if (!*v43) {
                goto LABEL_83;
              }
            }
            uint64_t v42 = (uint64_t *)v42[1];
          }
          while (v42);
          CFTypeID v44 = v43 + 1;
        }
LABEL_83:
        sub_100046C38((uint64_t **)v2 + 122, (uint64_t)v43, v44, *(uint64_t **)buf);
        *(void *)long long buf = 0;
        sub_10003FD44((uint64_t)buf, 0);
        uint64_t v45 = v34[1];
        if (v45)
        {
          do
          {
            unsigned int v46 = (uint64_t **)v45;
            uint64_t v45 = (uint64_t *)*v45;
          }
          while (v45);
        }
        else
        {
          do
          {
            unsigned int v46 = (uint64_t **)v34[2];
            BOOL v13 = *v46 == (uint64_t *)v34;
            int v34 = v46;
          }
          while (!v13);
        }
        int v34 = v46;
      }
      while (v46 != &v59);
    }
  }
  uint64_t v47 = v2[121];
  if (v47) {
    (*(void (**)(uint64_t, void *))(*(void *)v47 + 48))(v47, v2 + 122);
  }
LABEL_91:
  sub_10003FB28((uint64_t)&v58, v59);
  sub_1004C95C0((uint64_t *)&v50);
  return sub_100046B58((uint64_t *)&v49);
}

void sub_1004C951C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 a11, char a12, char a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,void *a28,uint64_t a29,char a30)
{
  if (*(char *)(v30 + 71) < 0) {
    operator delete(*(void **)(v30 + 48));
  }
  sub_10003FD44((uint64_t)&a30, 0);
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  sub_10003FB28((uint64_t)&a27, a28);
  sub_1004C95C0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1004C95C0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 79) < 0) {
      operator delete(*(void **)(v1 + 56));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1004C9628(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, int a5)
{
  int v5 = a1 + 1;
  if (a1 + 1 == a2 || (int v6 = *((_DWORD *)a2 + 8), v6 > a5))
  {
    uint64_t v7 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      int v9 = a2;
LABEL_18:
      if (v7)
      {
        *a3 = v9;
        return v9 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v7)
    {
      char v8 = (uint64_t *)*a2;
      do
      {
        int v9 = v8;
        char v8 = (uint64_t *)v8[1];
      }
      while (v8);
    }
    else
    {
      uint64_t v12 = a2;
      do
      {
        int v9 = (uint64_t *)v12[2];
        BOOL v13 = *v9 == (void)v12;
        uint64_t v12 = v9;
      }
      while (v13);
    }
    if (*((_DWORD *)v9 + 8) < a5) {
      goto LABEL_18;
    }
    uint64_t v14 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          int v15 = (uint64_t *)v14;
          int v16 = *(_DWORD *)(v14 + 32);
          if (v16 <= a5) {
            break;
          }
          uint64_t v14 = *v15;
          int v5 = v15;
          if (!*v15) {
            goto LABEL_43;
          }
        }
        if (v16 >= a5) {
          break;
        }
        int v5 = v15 + 1;
        uint64_t v14 = v15[1];
      }
      while (v14);
      goto LABEL_43;
    }
LABEL_42:
    int v15 = a1 + 1;
LABEL_43:
    *a3 = v15;
    return v5;
  }
  if (v6 >= a5)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v10 = a2[1];
  if (v10)
  {
    char v11 = (uint64_t *)a2[1];
    do
    {
      a4 = v11;
      char v11 = (uint64_t *)*v11;
    }
    while (v11);
  }
  else
  {
    uint64_t v17 = a2;
    do
    {
      a4 = (uint64_t *)v17[2];
      BOOL v13 = *a4 == (void)v17;
      uint64_t v17 = a4;
    }
    while (!v13);
  }
  if (a4 != v5 && *((_DWORD *)a4 + 8) <= a5)
  {
    uint64_t v18 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          int v15 = (uint64_t *)v18;
          int v19 = *(_DWORD *)(v18 + 32);
          if (v19 <= a5) {
            break;
          }
          uint64_t v18 = *v15;
          int v5 = v15;
          if (!*v15) {
            goto LABEL_43;
          }
        }
        if (v19 >= a5) {
          break;
        }
        int v5 = v15 + 1;
        uint64_t v18 = v15[1];
      }
      while (v18);
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  if (v10)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void sub_1004C97B0(void *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v5 = a2 + 8;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int v6 = operator new(0x68uLL);
  *a1 = v6;
  a1[1] = v5;
  *((unsigned char *)a1 + 16) = 0;
  char v6[8] = *a3;
  MCC::MCC((MCC *)(v6 + 10), (const MCC *)(a3 + 2));
  MCC::MCC((MCC *)(v6 + 18), (const MCC *)(a3 + 10));
  *((unsigned char *)a1 + 16) = 1;
}

void sub_1004C9824(_Unwind_Exception *a1)
{
  if (*(char *)(v2 + 71) < 0) {
    operator delete(*(void **)(v2 + 48));
  }
  sub_10003FD44(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1004C9854(uint64_t a1)
{
  sub_10003FB28(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_10003FB28(*(void *)a1, v2);
  }
  return a1;
}

void sub_1004C98AC(uint64_t *a1)
{
  int v6 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)*a1 + 48) + 16))(*(void *)(*(void *)*a1 + 48), *(unsigned int *)(*a1 + 8));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Received Geo MCC fetch update", buf, 2u);
  }
  int v3 = *(_DWORD *)(v1 + 8);
  xpc_object_t v10 = 0;
  uint64_t v4 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v10, (ctu::rest::detail *)v3, v4, v5);
  sub_100058DB0(buf, "/cc/events/geo_mcc_fetch");
  xpc_object_t object = v10;
  xpc_object_t v10 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  xpc_object_t object = 0;
  if (v9 < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(v10);
  operator delete();
}

void sub_1004C99EC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17)
{
  xpc_object_t object = 0;
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(a17);
  operator delete();
}

void *sub_1004C9A58(void *a1)
{
  *a1 = off_1019D4FD8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1004C9AA4(void *a1)
{
  *a1 = off_1019D4FD8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_1004C9B10(void *a1)
{
  uint64_t result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *uint64_t result = off_1019D4FD8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *sub_1004C9B74(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_1019D4FD8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void sub_1004C9BB4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1004C9BC4(void *a1)
{
  uint64_t v2 = a1[3];
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  v4[0] = a1[1];
  v4[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10000F1D8(v2, v4);
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_1004C9C38(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004C9C50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004C9C90()
{
}

void sub_1004C9CA0()
{
}

void *sub_1004C9CB4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1019D5058;
  result[1] = v3;
  return result;
}

uint64_t sub_1004C9CFC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D5058;
  a2[1] = v2;
  return result;
}

void sub_1004C9D28(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

uint64_t sub_1004C9E0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004C9E4C()
{
}

void sub_1004C9E58(capabilities::ct ***a1)
{
  uint64_t v1 = a1;
  if (*((unsigned char *)*a1 + 8)) {
    sub_1004BDC7C(**a1);
  }
  operator delete();
}

void sub_1004C9EB4()
{
}

void sub_1004C9EE0(int *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v16 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v16 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v16 = v6;
LABEL_9:
  xpc_release(v5);
  int v7 = *a1;
  uint64_t v8 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v14, (ctu::rest::detail *)v7, v8, v9);
  std::string __p = &v16;
  uint64_t v18 = "first";
  sub_100035E70((uint64_t)&__p, &v14, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v14);
  xpc_object_t v14 = 0;
  if (a1[1]) {
    xpc_object_t v10 = "kTemporary";
  }
  else {
    xpc_object_t v10 = "kPermanent";
  }
  sub_100058DB0(&__p, v10);
  ctu::rest::detail::write_enum_string_value();
  if (v19 < 0) {
    operator delete(__p);
  }
  std::string __p = &v16;
  uint64_t v18 = "second";
  sub_100035E70((uint64_t)&__p, &v12, &v13);
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_object_t v11 = v16;
  *a2 = v16;
  if (v11) {
    xpc_retain(v11);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v16);
}

void sub_1004CA08C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  _Unwind_Resume(a1);
}

void *sub_1004CA0D0(void *a1)
{
  *a1 = off_1019D50D8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1004CA11C(void *a1)
{
  *a1 = off_1019D50D8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1004CA188(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019D50D8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1004CA1EC(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019D50D8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1004CA22C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1004CA23C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1004CA27C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    xpc_object_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      xpc_object_t v5 = v4;
      if (a1[2])
      {
        xpc_object_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I setLTEToProvisioning_sync: new type is pushed", v7, 2u);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

uint64_t sub_1004CA310(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1004CA350()
{
}

void sub_1004CA360()
{
}

__n128 sub_1004CA374(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019D5158;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1004CA3C0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D5158;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1004CA3F0(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

uint64_t sub_1004CA4DC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1004CA51C()
{
}

void sub_1004CA528(uint64_t **a1)
{
  xpc_object_t v5 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)*a1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)v1 + 12)) {
      xpc_object_t v4 = "true";
    }
    else {
      xpc_object_t v4 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    int v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Setting Data Roaming setting to %s", buf, 0xCu);
  }
  (*(void (**)(void, void, void))(**(void **)(v2 + 88) + 240))(*(void *)(v2 + 88), *((unsigned int *)v1 + 2), *((unsigned __int8 *)v1 + 12));
  operator delete();
}

void sub_1004CA66C()
{
}

void sub_1004CA69C()
{
}

__n128 sub_1004CA6B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019D51D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004CA704(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D51D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1004CA73C(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

uint64_t sub_1004CA840(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004CA880()
{
}

void sub_1004CA88C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  xpc_object_t v4 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  uint64_t v5 = *(void *)(v2 + 544);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = v2 + 544;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < (int)v3;
    if (v7 >= (int)v3) {
      char v9 = (uint64_t *)v5;
    }
    else {
      char v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 == v2 + 544 || *(_DWORD *)(v6 + 32) > (int)v3)
  {
LABEL_11:
    xpc_object_t v10 = *v4;
    BOOL v11 = 0;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_15;
    }
    *(_WORD *)long long buf = 0;
    xpc_object_t v12 = "#N Carrier bundle info not found. Default 5G roaming to false";
    goto LABEL_13;
  }
  uint64_t v17 = *(void *)(v2 + 568);
  if (!v17) {
    goto LABEL_33;
  }
  uint64_t v18 = v2 + 568;
  do
  {
    int v19 = *(_DWORD *)(v17 + 32);
    BOOL v20 = v19 < (int)v3;
    if (v19 >= (int)v3) {
      BOOL v21 = (uint64_t *)v17;
    }
    else {
      BOOL v21 = (uint64_t *)(v17 + 8);
    }
    if (!v20) {
      uint64_t v18 = v17;
    }
    uint64_t v17 = *v21;
  }
  while (*v21);
  if (v18 == v2 + 568 || *(_DWORD *)(v18 + 32) > (int)v3)
  {
LABEL_33:
    xpc_object_t v10 = *v4;
    BOOL v11 = 0;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      xpc_object_t v12 = "#N Operator bundle info not found. Default 5G roaming to false";
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v12, buf, 2u);
      goto LABEL_14;
    }
LABEL_15:
    xpc_object_t v13 = *(NSObject **)v1[2];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = asString();
      int v15 = "false";
      if (v11) {
        int v15 = "true";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v14;
      __int16 v41 = 2080;
      uint64_t v42 = v15;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Extracted user preference of enable 5G: %s, enabled in roaming: %s", buf, 0x16u);
    }
    if (*((_DWORD *)v1 + 6) == 2) {
      uint64_t v16 = 3;
    }
    else {
      uint64_t v16 = 0;
    }
    (*(void (**)(void, void, uint64_t, void, BOOL))(**(void **)(v2 + 88) + 72))(*(void *)(v2 + 88), *((unsigned int *)v1 + 2), v16, *((unsigned __int8 *)v1 + 28), v11);
    operator delete();
  }
  uint64_t v22 = *(unsigned __int8 *)(v6 + 71);
  size_t v23 = *(void *)(v6 + 56);
  if ((v22 & 0x80u) == 0) {
    uint64_t v24 = *(unsigned __int8 *)(v6 + 71);
  }
  else {
    uint64_t v24 = *(void *)(v6 + 56);
  }
  uint64_t v25 = *(unsigned __int8 *)(v18 + 71);
  int v26 = (char)v25;
  if ((v25 & 0x80u) != 0) {
    uint64_t v25 = *(void *)(v18 + 56);
  }
  if (v24 == v25)
  {
    int v27 = (const void **)(v6 + 48);
    uint64_t v30 = *(unsigned __int8 **)(v18 + 48);
    uint64_t v28 = (unsigned __int8 *)(v18 + 48);
    uint64_t v29 = v30;
    if (v26 >= 0) {
      uint64_t v31 = v28;
    }
    else {
      uint64_t v31 = v29;
    }
    if ((v22 & 0x80) == 0)
    {
      if (v22)
      {
        BOOL v11 = 1;
        while (*(unsigned __int8 *)v27 == *v31)
        {
          int v27 = (const void **)((char *)v27 + 1);
          ++v31;
          if (!--v22) {
            goto LABEL_15;
          }
        }
        goto LABEL_51;
      }
LABEL_58:
      BOOL v11 = 1;
      goto LABEL_15;
    }
    if (!memcmp(*v27, v31, v23)) {
      goto LABEL_58;
    }
  }
LABEL_51:
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(v2 + 248) + 96))(buf);
  int v32 = *(BOOL **)buf;
  unsigned __int8 v39 = 0;
  if (!*(void *)buf || (CFTypeID v33 = CFGetTypeID(*(CFTypeRef *)buf), v33 != CFBooleanGetTypeID()))
  {
    sub_1000577C4((const void **)buf);
    goto LABEL_14;
  }
  ctu::cf::assign((ctu::cf *)&v39, v32, v34);
  int v35 = v39;
  sub_1000577C4((const void **)buf);
  if (!v35)
  {
LABEL_14:
    BOOL v11 = 0;
    goto LABEL_15;
  }
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(v2 + 248) + 96))(buf);
  unsigned __int16 v36 = *(BOOL **)buf;
  unsigned __int8 v39 = 0;
  if (*(void *)buf && (CFTypeID v37 = CFGetTypeID(*(CFTypeRef *)buf), v37 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&v39, v36, v38);
    BOOL v11 = v39 != 0;
  }
  else
  {
    BOOL v11 = 0;
  }
  sub_1000577C4((const void **)buf);
  goto LABEL_15;
}

void sub_1004CACAC(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  operator delete();
}

void *sub_1004CACEC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1004CAD70(void *a1)
{
  *a1 = off_1019D5268;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1004CADBC(void *a1)
{
  *a1 = off_1019D5268;
  uint64_t v1 = (std::__shared_weak_count *)a1[5];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_1004CAE28(uint64_t a1)
{
  __n128 result = (char *)operator new(0x38uLL);
  *(void *)__n128 result = off_1019D5268;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  *((_DWORD *)result + 6) = *(_DWORD *)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 40);
  *((void *)result + 4) = *(void *)(a1 + 32);
  *((void *)result + 5) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  result[48] = *(unsigned char *)(a1 + 48);
  return result;
}

uint64_t sub_1004CAE9C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019D5268;
  long long v2 = *(_OWORD *)(result + 8);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(result + 24);
  *(_OWORD *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 40) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a2 + 48) = *(unsigned char *)(result + 48);
  return result;
}

void sub_1004CAEEC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1004CAEFC(void *__p)
{
  long long v2 = (std::__shared_weak_count *)__p[5];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_1004CAF3C(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 8) + 8);
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, v1);
  operator new();
}

uint64_t sub_1004CB07C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004CB0BC()
{
}

uint64_t *sub_1004CB0C8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = **(NSObject ***)(v1 + 8);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v12 = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Extracted user preference of enable LTE: %s", buf, 0xCu);
  }
  unsigned int v4 = *(_DWORD *)(v1 + 16);
  if (v4 >= 2)
  {
    if (v4 != 2)
    {
      if (RegistrationController::carrierBlocksCallsOverCS_sync(v2, *(_DWORD *)(v1 + 20), 1))
      {
        uint64_t v5 = **(NSObject ***)(v1 + 8);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          uint64_t v6 = "#N CS calls are blocked for the current operator, ignoring LTE preference set to false";
LABEL_8:
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 2u);
        }
      }
      else
      {
        if ((*(unsigned int (**)(void))(**(void **)(v1 + 24) + 128))(*(void *)(v1 + 24)) != 5
          || !RegistrationController::carrierBlocksCallsOverCS_sync(v2, *(_DWORD *)(v1 + 20), 0))
        {
          uint64_t v7 = 0;
          goto LABEL_10;
        }
        uint64_t v5 = **(NSObject ***)(v1 + 8);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          uint64_t v6 = "#N CS calls are blocked for the current carrier, ignoring LTE preference set to false";
          goto LABEL_8;
        }
      }
    }
    uint64_t v7 = 1;
LABEL_10:
    RegistrationController::sendLteEnabledSetting_sync(v2, *(unsigned int *)(v1 + 20), v7, *(unsigned __int8 *)(v1 + 40));
  }
  sub_1004CB29C(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_1004CB280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1004CB29C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 32);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_1004CB2F4()
{
}

__n128 sub_1004CB308(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019D52E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1004CB35C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D52E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1004CB394(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, (void *)(v1 + 8));
  operator new();
}

uint64_t sub_1004CB498(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004CB4D8()
{
}

void sub_1004CB4E4(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(*a1)[1];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v6 = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Extracted user preference of enable 3G: %s", buf, 0xCu);
  }
  unsigned int v4 = *((_DWORD *)v1 + 4);
  if (v4 >= 2) {
    (*(void (**)(void, void, BOOL, void))(**(void **)(v2 + 88) + 56))(*(void *)(v2 + 88), *((unsigned int *)v1 + 5), v4 == 2, *((unsigned __int8 *)v1 + 24));
  }
  operator delete();
}

void sub_1004CB5F8()
{
}

void sub_1004CB628()
{
}

__n128 sub_1004CB63C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019D5368;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1004CB688(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D5368;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1004CB6B8(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

uint64_t sub_1004CB7A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004CB7E4()
{
}

void sub_1004CB7F0(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Extracted user preference of enable 2G: %s", (uint8_t *)&buf, 0xCu);
  }
  if (*((_DWORD *)v1 + 2) >= 2u)
  {
    subscriber::makeSimSlotRange();
    unsigned int v4 = (unsigned int *)*((void *)&buf + 1);
    uint64_t v5 = (unsigned int *)buf;
    if ((void)buf != *((void *)&buf + 1))
    {
      uint64_t v6 = v10;
      do
      {
        if (v6(*v5)) {
          goto LABEL_9;
        }
        ++v5;
      }
      while (v5 != v4);
      uint64_t v5 = v4;
LABEL_9:
      uint64_t v7 = (unsigned int *)*((void *)&buf + 1);
LABEL_10:
      while (v5 != v7)
      {
        (*(void (**)(void, void, BOOL, void))(**(void **)(v2 + 88) + 48))(*(void *)(v2 + 88), *v5, *((_DWORD *)v1 + 2) == 2, *((unsigned __int8 *)v1 + 12));
        BOOL v8 = v5 + 1;
        uint64_t v5 = v4;
        if (v8 != v4)
        {
          uint64_t v5 = v8;
          do
          {
            if (v6(*v5)) {
              goto LABEL_10;
            }
            ++v5;
          }
          while (v5 != v4);
          uint64_t v5 = v4;
        }
      }
    }
  }
  operator delete();
}

void sub_1004CB990()
{
}

uint64_t sub_1004CB9C8(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    uint64_t v3 = (void *)(a1 + 16);
    if (v2[6] == *(void *)(a1 + 32))
    {
      unsigned int v4 = (void *)v2[4];
      if (v4 == v2 + 5) {
        goto LABEL_24;
      }
      uint64_t v5 = (void *)*v3;
      while (1)
      {
        BOOL v6 = *((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7)
          && *((unsigned __int8 *)v4 + 32) == *((unsigned __int8 *)v5 + 32);
        if (!v6) {
          break;
        }
        uint64_t v7 = (void *)v4[1];
        BOOL v8 = v4;
        if (v7)
        {
          do
          {
            unsigned int v4 = v7;
            uint64_t v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            unsigned int v4 = (void *)v8[2];
            BOOL v6 = *v4 == (void)v8;
            BOOL v8 = v4;
          }
          while (!v6);
        }
        char v9 = (void *)v5[1];
        if (v9)
        {
          do
          {
            uint64_t v10 = v9;
            char v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            uint64_t v10 = (void *)v5[2];
            BOOL v6 = *v10 == (void)v5;
            uint64_t v5 = v10;
          }
          while (!v6);
        }
        uint64_t v5 = v10;
        if (v4 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    sub_10041F480((uint64_t)(v2 + 4), v3);
    uint64_t v11 = v2[3];
    if (v11) {
      (*(void (**)(uint64_t, void *))(*(void *)v11 + 48))(v11, v2 + 4);
    }
  }
LABEL_24:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_1004CBAFC(unsigned int *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v14 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v14 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v14 = v6;
LABEL_9:
  xpc_release(v5);
  xpc_object_t v12 = xpc_int64_create(*a1);
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  uint64_t v10 = &v14;
  uint64_t v11 = "tagToRectify";
  sub_100035E70((uint64_t)&v10, &v12, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_object_t v8 = xpc_int64_create(a1[1]);
  if (!v8) {
    xpc_object_t v8 = xpc_null_create();
  }
  uint64_t v10 = &v14;
  uint64_t v11 = "replacement";
  sub_100035E70((uint64_t)&v10, &v8, &v9);
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_release(v8);
  xpc_object_t v8 = 0;
  xpc_object_t v7 = v14;
  *a2 = v14;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v14);
}

void sub_1004CBC9C(_DWORD *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v9 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v9 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = &v9;
    xpc_object_t v7 = "tagToRectify";
    sub_100048BAC((uint64_t)&v6, &object);
    *a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, v4);
    xpc_release(object);
    xpc_object_t v6 = &v9;
    xpc_object_t v7 = "replacement";
    sub_100048BAC((uint64_t)&v6, &object);
    a1[1] = xpc::dyn_cast_or_default((xpc *)&object, 0, v5);
    xpc_release(object);
    xpc_object_t v3 = v9;
  }
  else
  {
    *(void *)a1 = 0;
  }
  xpc_release(v3);
}

void sub_1004CBDA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12)
{
}

void RoamingHandler::setupAwdMetricCallback_sync(RoamingHandler *this)
{
  sub_10017B514();
  if (capabilities::ct::supportsGemini(v1)) {
    sub_10017B514();
  }
}

void sub_1004CBED8(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 32) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

void sub_1004CBFB4(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 32) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

uint64_t sub_1004CC090(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    unsigned int v4 = (wis::MetricContainer *)v3;
    unsigned int v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    xpc_object_t v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_1004CC1EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

void sub_1004CC270(uint64_t a1, _DWORD *a2)
{
  unsigned int v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 32) + 56) + 16))(*(void *)(*(void *)(a1 + 32) + 56), *(unsigned int *)(a1 + 48));
  int v5 = **(unsigned __int8 **)(a1 + 40);
  xpc_object_t v6 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = "awd::metrics::kSwitchEnabled";
    if (!v5) {
      uint64_t v7 = "awd::metrics::kSwitchDisabled";
    }
    int v15 = 136315138;
    uint64_t v16 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Submitting the AWD metric for data roaming switch state: %s", (uint8_t *)&v15, 0xCu);
  }
  int v8 = *(_DWORD *)(a1 + 48);
  if (v8 == 2)
  {
    int v12 = a2[9];
    a2[9] = v12 | 8;
    a2[6] = v5;
    uint64_t v13 = *(void *)(a1 + 40);
    if (*(unsigned char *)(v13 + 2))
    {
      int v14 = *(unsigned __int8 *)(v13 + 1);
      a2[9] = v12 | 0x18;
      a2[7] = v14;
    }
  }
  else if (v8 == 1)
  {
    int v9 = a2[9];
    a2[9] = v9 | 2;
    a2[4] = v5;
    uint64_t v10 = *(void *)(a1 + 40);
    if (*(unsigned char *)(v10 + 2))
    {
      int v11 = *(unsigned __int8 *)(v10 + 1);
      a2[9] = v9 | 6;
      a2[5] = v11;
    }
  }
}

uint64_t sub_1004CC3D8(uint64_t result, int *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  uint64_t v3 = *(void **)(v2 + 64);
  unsigned int v4 = (void *)(v2 + 72);
  if (v3 != (void *)(v2 + 72))
  {
    xpc_object_t v6 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 4);
    do
    {
      int v7 = a2[7];
      uint64_t v8 = a2[6];
      if ((int)v8 >= v7)
      {
        if (v7 == a2[8])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v6, v7 + 1);
          int v7 = a2[7];
        }
        a2[7] = v7 + 1;
        operator new();
      }
      uint64_t v9 = *((void *)a2 + 2);
      a2[6] = v8 + 1;
      uint64_t v10 = *(void *)(v9 + 8 * v8);
      if (v10) {
        __n128 result = (*(uint64_t (**)(void, uint64_t))(*(void *)v3[5] + 112))(v3[5], v10);
      }
      int v11 = (void *)v3[1];
      if (v11)
      {
        do
        {
          int v12 = v11;
          int v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          int v12 = (void *)v3[2];
          BOOL v13 = *v12 == (void)v3;
          uint64_t v3 = v12;
        }
        while (!v13);
      }
      uint64_t v3 = v12;
    }
    while (v12 != v4);
  }
  return result;
}

void sub_1004CC504()
{
}

void sub_1004CC528(uint64_t **a1)
{
  uint64_t v1 = **a1;
  subscriber::makeSimSlotRange();
  uint64_t v3 = v11;
  uint64_t v2 = v12;
  if (v11 != v12)
  {
    unsigned int v4 = v13;
    do
    {
      if (v13(*v3)) {
        goto LABEL_6;
      }
      ++v3;
    }
    while (v3 != v12);
    uint64_t v3 = v12;
LABEL_6:
    int v5 = v12;
    while (v3 != v5)
    {
      unsigned int v6 = *v3;
      unsigned int DataRoamingSetting_sync = (unsigned __int16)RoamingHandler::getDataRoamingSetting_sync(v1, *v3);
      if (DataRoamingSetting_sync <= 0x100) {
        LOBYTE(DataRoamingSetting_sync) = 0;
      }
      BOOL v9 = DataRoamingSetting_sync != 0;
      __int16 v10 = 0;
      int v14 = _NSConcreteStackBlock;
      uint64_t v15 = 0x40000000;
      uint64_t v16 = sub_1004CC270;
      uint64_t v17 = &unk_1019D5458;
      unsigned int v20 = v6;
      uint64_t v18 = v1;
      int v19 = &v9;
      sub_1004CC090((wis::MetricFactory *)0x80065);
      uint64_t v8 = v3 + 1;
      uint64_t v3 = v2;
      if (v8 != v2)
      {
        uint64_t v3 = v8;
        do
        {
          if (v4(*v3)) {
            goto LABEL_14;
          }
          ++v3;
        }
        while (v3 != v2);
        uint64_t v3 = v2;
      }
LABEL_14:
      ;
    }
  }
  operator delete();
}

void sub_1004CC6B8()
{
}

void sub_1004CC6F8(wis::MetricFactory *a1)
{
  int v7 = a1;
  uint64_t v1 = **(void **)a1;
  uint64_t v8 = _NSConcreteStackBlock;
  uint64_t v9 = 0x40000000;
  __int16 v10 = sub_1004CC3D8;
  int v11 = &unk_1019D5478;
  uint64_t v12 = v1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x80088u);
  BOOL v13 = v3;
  if (v3)
  {
    unsigned int v4 = sub_10001C8F4(8);
    uint64_t v6 = *v4;
    int v5 = (std::__shared_weak_count *)v4[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6) {
      operator new();
    }
    if (v5) {
      sub_10004D2C8(v5);
    }
    if (v3)
    {
      wis::MetricContainer::~MetricContainer(v3);
      operator delete();
    }
  }
  operator delete();
}

void sub_1004CC8AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  operator delete();
}

void *sub_1004CC958(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, NSObject **a5, int a6)
{
  __int16 v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v19 = *a2;
  unsigned int v20 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v11 = *a5;
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  uint64_t v12 = "DATA.Connection.InternetProbe.X";
  int v13 = *(_DWORD *)(*(void *)a3 + 52);
  if (v13 == 2) {
    uint64_t v12 = "DATA.Connection.InternetProbe.2";
  }
  int v14 = "InternetProbe.X";
  if (v13 == 2) {
    int v14 = "InternetProbe.2";
  }
  if (v13 == 1) {
    uint64_t v15 = "DATA.Connection.InternetProbe.1";
  }
  else {
    uint64_t v15 = v12;
  }
  uint64_t v16 = "InternetProbe.1";
  if (v13 != 1) {
    uint64_t v16 = v14;
  }
  sub_1011B6014((uint64_t)a1, (uint64_t *)off_1019D5F08, &v19, a3, a4, &object, a6, v15, (uint64_t)v16);
  if (object) {
    dispatch_release(object);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  *a1 = off_1019D54D0;
  a1[8] = off_1019D5A20;
  a1[9] = off_1019D5CB0;
  a1[10] = off_1019D5EA0;
  return a1;
}

void sub_1004CCAE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  PersonalitySpecific::~PersonalitySpecific(v12);
  _Unwind_Resume(a1);
}

void sub_1004CCB14(uint64_t *a1)
{
  sub_1011B639C(a1, (uint64_t *)off_1019D5F08);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1004CCB44(uint64_t a1)
{
  sub_1011B639C((uint64_t *)(a1 - 64), (uint64_t *)off_1019D5F08);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1004CCB78(uint64_t a1)
{
  sub_1011B639C((uint64_t *)(a1 - 72), (uint64_t *)off_1019D5F08);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1004CCBAC(uint64_t a1)
{
  sub_1011B639C((uint64_t *)(a1 - 80), (uint64_t *)off_1019D5F08);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1004CCBE0(uint64_t *a1)
{
  sub_1011B639C(a1, (uint64_t *)off_1019D5F08);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_1004CCC24(uint64_t a1)
{
}

void sub_1004CCC2C(uint64_t a1)
{
}

void sub_1004CCC34(uint64_t a1)
{
}

__n128 sub_1004CCC3C@<Q0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  long long v2 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v2;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(a2 + 40) = result;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  return result;
}

uint64_t sub_1004CCC5C()
{
  return 0;
}

uint64_t sub_1004CCC6C()
{
  return 0;
}

uint64_t sub_1004CCC74(Registry **a1)
{
  return sub_10129EEF0(a1);
}

uint64_t sub_1004CCC90(uint64_t a1)
{
  return sub_10129EEF0((Registry **)(a1 - 72));
}

uint64_t sub_1004CCCB0()
{
  return 1;
}

uint64_t sub_1004CCCB8()
{
  return 1;
}

uint64_t sub_1004CCCC0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 384);
}

void NetworkRejectionMonitorMode::create(NSObject **a1@<X0>, void *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, CFDictionaryRef *a5@<X4>, int a6@<W5>, void *a7@<X8>)
{
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*a5, @"CellularDataPlanNotSubscribedErrors");
  long long v15 = 0uLL;
  if (Value)
  {
    CFArrayRef v16 = Value;
    CFTypeID v17 = CFGetTypeID(Value);
    if (v17 == CFArrayGetTypeID())
    {
      __dst[0] = 0;
      __dst[1] = 0;
      uint64_t v75 = 0;
      context[0] = __dst;
      v79.length = CFArrayGetCount(v16);
      v79.location = 0;
      CFArrayApplyFunction(v16, v79, (CFArrayApplierFunction)sub_1004CE630, context);
      long long v15 = *(_OWORD *)__dst;
      uint64_t v18 = v75;
    }
    else
    {
      uint64_t v18 = 0;
      long long v15 = 0uLL;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  *(_OWORD *)unsigned int v67 = v15;
  uint64_t v68 = v18;
  uint64_t v66 = 0;
  CFArrayRef v19 = (const __CFArray *)CFDictionaryGetValue(*a5, @"ExpirePlanOnNetworkRejectCauseCodes");
  CFArrayRef v20 = v19;
  long long v63 = 0u;
  if (v19 && (CFTypeID v21 = CFGetTypeID(v19), v21 == CFArrayGetTypeID()))
  {
    __dst[0] = 0;
    __dst[1] = 0;
    uint64_t v75 = 0;
    context[0] = __dst;
    v80.length = CFArrayGetCount(v20);
    v80.location = 0;
    CFArrayApplyFunction(v20, v80, (CFArrayApplierFunction)sub_1004CE630, context);
    long long v63 = *(_OWORD *)__dst;
    uint64_t v22 = v75;
  }
  else
  {
    uint64_t v22 = 0;
  }
  *(_OWORD *)std::string __p = v63;
  uint64_t v66 = v22;
  size_t v23 = (int *)CFDictionaryGetValue(*a5, @"DataPlanNetworkRejectionCause");
  uint64_t v24 = v23;
  LODWORD(__dst[0]) = 0;
  if (v23)
  {
    CFTypeID v25 = CFGetTypeID(v23);
    if (v25 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)__dst, v24, v26);
    }
    int v27 = (int)__dst[0];
    if (LODWORD(__dst[0]))
    {
      uint64_t v28 = (char *)*((void *)&v63 + 1);
      if (*((void *)&v63 + 1) >= (unint64_t)v66)
      {
        uint64_t v30 = (char *)v63;
        uint64_t v31 = (uint64_t)(*((void *)&v63 + 1) - v63) >> 2;
        unint64_t v32 = v31 + 1;
        if ((unint64_t)(v31 + 1) >> 62) {
          sub_10006A748();
        }
        uint64_t v33 = (uint64_t)&v66[-v63];
        if ((uint64_t)&v66[-v63] >> 1 > v32) {
          unint64_t v32 = v33 >> 1;
        }
        if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v34 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v34 = v32;
        }
        if (v34)
        {
          int v35 = (char *)sub_10005ECD8((uint64_t)&v66, v34);
          uint64_t v28 = (char *)*((void *)&v63 + 1);
          uint64_t v30 = (char *)v63;
        }
        else
        {
          int v35 = 0;
        }
        unsigned __int16 v36 = &v35[4 * v31];
        CFTypeID v37 = &v35[4 * v34];
        *(_DWORD *)unsigned __int16 v36 = v27;
        uint64_t v29 = (uint64_t)(v36 + 4);
        while (v28 != v30)
        {
          int v38 = *((_DWORD *)v28 - 1);
          v28 -= 4;
          *((_DWORD *)v36 - 1) = v38;
          v36 -= 4;
        }
        __p[0] = v36;
        uint64_t v66 = v37;
        if (v30) {
          operator delete(v30);
        }
      }
      else
      {
        **((_DWORD **)&v63 + 1) = __dst[0];
        uint64_t v29 = *((void *)&v63 + 1) + 4;
      }
      __p[1] = (void *)v29;
    }
  }
  unsigned __int8 v39 = v67[0];
  char v40 = v67[1];
  if (v67[0] != v67[1])
  {
    do
      *v39++ = gsmToCsiErrorWithCode();
    while (v39 != v40);
    goto LABEL_50;
  }
  if (__p[0] != __p[1])
  {
    if (v67[0] >= v68)
    {
      unint64_t v42 = (int64_t)((uint64_t)v68 - (unint64_t)v67[0]) >> 1;
      if (v42 <= 1) {
        unint64_t v42 = 1;
      }
      if ((unint64_t)v68 - (unint64_t)v67[0] >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v43 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v43 = v42;
      }
      CFTypeID v44 = sub_10005ECD8((uint64_t)&v68, v43);
      uint64_t v45 = (char *)v67[0];
      unsigned int v46 = (char *)v67[1];
      CFBooleanRef v48 = &v44[v47];
      _DWORD *v44 = 63;
      __int16 v41 = v44 + 1;
      while (v46 != v45)
      {
        int v49 = *((_DWORD *)v46 - 1);
        v46 -= 4;
        *--CFTypeID v44 = v49;
      }
      v67[0] = v44;
      v67[1] = v41;
      uint64_t v68 = v48;
      if (v45) {
        operator delete(v45);
      }
    }
    else
    {
      *(_DWORD *)v67[0] = 63;
      __int16 v41 = v39 + 1;
    }
    v67[1] = v41;
LABEL_50:
    CFStringRef v50 = *a1;
    int v51 = (char *)operator new(0x148uLL);
    *((void *)v51 + 1) = 0;
    *((void *)v51 + 2) = 0;
    *(void *)int v51 = off_1019D7608;
    if (v50) {
      dispatch_retain(v50);
    }
    uint64_t v52 = *a3;
    CFBooleanRef v53 = (std::__shared_weak_count *)a3[1];
    if (v53) {
      atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100058198((const void **)&theDict, (const void **)a5);
    CFBooleanRef v77 = v50;
    if (v50) {
      dispatch_retain(v50);
    }
    v76[0] = v52;
    v76[1] = v53;
    if (v53) {
      atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(char *)(a4 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a4, *(void *)(a4 + 8));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a4;
      uint64_t v75 = *(char **)(a4 + 16);
    }
    uint64_t v64 = v51 + 24;
    sub_10045E7FC((uint64_t)(v51 + 24), &v77, a2, v76, "mm.rej", (long long *)__dst);
    if (SHIBYTE(v75) < 0) {
      operator delete(__dst[0]);
    }
    if (v53) {
      sub_10004D2C8(v53);
    }
    if (v77) {
      dispatch_release(v77);
    }
    *((void *)v51 + 3) = off_1019D7558;
    sub_100058DB0(context, "mm.rej");
    dispatch_object_t v71 = v50;
    if (v50) {
      dispatch_retain(v50);
    }
    dispatch_object_t object = 0;
    ctu::RestModule::RestModule();
    if (object) {
      dispatch_release(object);
    }
    if (v71) {
      dispatch_release(v71);
    }
    if (v73 < 0) {
      operator delete(context[0]);
    }
    *((void *)v51 + 31) = v51 + 256;
    *((_DWORD *)v51 + 48) = 0;
    *((void *)v51 + 26) = 0;
    *((void *)v51 + 25) = v51 + 208;
    *((void *)v51 + 29) = 0;
    *((void *)v51 + 28) = v51 + 232;
    *((void *)v51 + 27) = 0;
    *((void *)v51 + 30) = 0;
    *((void *)v51 + 32) = 0;
    *((void *)v51 + 33) = 0;
    *((void *)v51 + 34) = 0;
    char v54 = v67[0];
    uint64_t v55 = v67[1];
    unint64_t v56 = ((char *)v67[1] - (char *)v67[0]) >> 2;
    *((void *)v51 + 35) = 0;
    *((void *)v51 + 36) = 0;
    sub_100448664((void *)v51 + 34, v54, (uint64_t)v55, v56);
    *((void *)v51 + 37) = 0;
    *((void *)v51 + 38) = 0;
    *((void *)v51 + 39) = 0;
    sub_100448664((void *)v51 + 37, __p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 2);
    if (a6
      && (char v57 = (BOOL *)CFDictionaryGetValue(theDict, @"ResetBBAfterSuccessfulPlanPurchase"),
          CFNumberRef v58 = v57,
          v78[0] = 0,
          v57)
      && (CFTypeID v59 = CFGetTypeID(v57), v59 == CFBooleanGetTypeID()))
    {
      ctu::cf::assign((ctu::cf *)v78, v58, v60);
      BOOL v61 = v78[0] != 0;
    }
    else
    {
      BOOL v61 = 0;
    }
    v51[320] = v61;
    v51[321] = 0;
    sub_100057D78((const void **)&theDict);
    if (v53) {
      sub_10004D2C8(v53);
    }
    if (v50) {
      dispatch_release(v50);
    }
    *((void *)v51 + 3) = off_1019D7658;
    uint64_t v62 = (std::__shared_weak_count *)*((void *)v51 + 5);
    if (v62)
    {
      if (v62->__shared_owners_ != -1) {
        goto LABEL_89;
      }
      atomic_fetch_add_explicit((atomic_ullong *volatile)v51 + 1, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit((atomic_ullong *volatile)v51 + 2, 1uLL, memory_order_relaxed);
      *((void *)v51 + 4) = v64;
      *((void *)v51 + 5) = v51;
      std::__shared_weak_count::__release_weak(v62);
    }
    else
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)v51 + 1, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit((atomic_ullong *volatile)v51 + 2, 1uLL, memory_order_relaxed);
      *((void *)v51 + 4) = v64;
      *((void *)v51 + 5) = v51;
    }
    sub_10004D2C8((std::__shared_weak_count *)v51);
LABEL_89:
    __dst[0] = 0;
    __dst[1] = 0;
    sub_10003E168(__dst, (void *)v51 + 4);
    operator new();
  }
  *a7 = 0;
  a7[1] = 0;
  if (__p[0]) {
    operator delete(__p[0]);
  }
  if (v67[0])
  {
    v67[1] = v67[0];
    operator delete(v67[0]);
  }
}

void sub_1004CD3E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CellularPlanProvisioningMonitorModeInterface *a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,dispatch_object_t object,dispatch_object_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (__p) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

CellularPlanProvisioningMonitorModeInterface *sub_1004CD560(uint64_t a1)
{
  *(void *)a1 = off_1019D7558;
  long long v2 = (ctu::RestModule *)(a1 + 152);
  sub_1004CD69C();
  sub_1004CD70C();
  sub_100058DB0(&__p, "/cc/props/network_rejects");
  ctu::RestModule::unobserveProperty();
  if (v8 < 0) {
    operator delete(__p);
  }
  sub_1004CD77C();
  ctu::RestModule::disconnect(v2);
  uint64_t v3 = *(void **)(a1 + 272);
  if (v3)
  {
    *(void *)(a1 + 280) = v3;
    operator delete(v3);
  }
  unsigned int v4 = *(void **)(a1 + 248);
  if (v4)
  {
    *(void *)(a1 + 256) = v4;
    operator delete(v4);
  }
  sub_100088048(a1 + 224, *(void **)(a1 + 232));
  sub_1000346F8(a1 + 200, *(void **)(a1 + 208));
  sub_1000886C0(a1 + 176, *(char **)(a1 + 184));
  int v5 = *(std::__shared_weak_count **)(a1 + 160);
  if (v5) {
    sub_10004D2C8(v5);
  }

  return sub_10045E9DC((CellularPlanProvisioningMonitorModeInterface *)a1);
}

void sub_1004CD678(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10006A6AC(a1);
}

void sub_1004CD69C()
{
  sub_100058DB0(&__p, "/cc/props/current_data_slot");
  ctu::RestModule::unobserveProperty();
  if (v1 < 0) {
    operator delete(__p);
  }
}

void sub_1004CD6F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004CD70C()
{
  sub_100058DB0(&__p, "/cc/props/internal_internet_connection_state");
  ctu::RestModule::unobserveProperty();
  if (v1 < 0) {
    operator delete(__p);
  }
}

void sub_1004CD760(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004CD77C()
{
  sub_100058DB0(&__p, "/cc/props/sims_in_use");
  ctu::RestModule::unobserveProperty();
  if (v1 < 0) {
    operator delete(__p);
  }
}

void sub_1004CD7D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004CD7F0(uint64_t a1)
{
  sub_1004CD560(a1);

  operator delete();
}

void sub_1004CD828(uint64_t a1)
{
  if (*(void *)(a1 + 112))
  {
    unint64_t v2 = sub_1004CDC10(a1, 3);
    if (!HIDWORD(v2)) {
      return;
    }
    uint64_t v3 = *(void *)(a1 + 184);
    if (!v3) {
      return;
    }
    uint64_t v4 = a1 + 184;
    do
    {
      int v5 = *(_DWORD *)(v3 + 32);
      BOOL v6 = v5 < (int)v2;
      if (v5 >= (int)v2) {
        int v7 = (uint64_t *)v3;
      }
      else {
        int v7 = (uint64_t *)(v3 + 8);
      }
      if (!v6) {
        uint64_t v4 = v3;
      }
      uint64_t v3 = *v7;
    }
    while (*v7);
    if (v4 == a1 + 184 || *(_DWORD *)(v4 + 32) > (int)v2) {
      return;
    }
    int v8 = *(_DWORD *)(v4 + 64);
    if (v8 != 3 && v8 != 0) {
      return;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    int v11 = ServiceMap;
    if ((v12 & 0x8000000000000000) != 0)
    {
      int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        unint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v23 = v12;
    CFArrayRef v16 = sub_10004D37C(&v11[1].__m_.__sig, &v23);
    if (v16)
    {
      uint64_t v18 = v16[3];
      CFTypeID v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    CFTypeID v17 = 0;
    char v19 = 1;
LABEL_29:
    if (v18)
    {
      uint64_t v20 = *(unsigned int *)(a1 + 168);
      sub_100058DB0(__p, "Connection Expiry Monitor Mode Start");
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void **, uint64_t, void))(*(void *)v18 + 80))(v18, v20, 1, 1, __p, 1, 0);
      if (v22 < 0) {
        operator delete(__p[0]);
      }
    }
    if ((v19 & 1) == 0) {
      sub_10004D2C8(v17);
    }
    return;
  }

  sub_1004CDA38(a1);
}

void sub_1004CDA04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004CDA38(uint64_t a1)
{
  unint64_t v2 = sub_1004CDC10(a1, 3);
  if (HIDWORD(v2))
  {
    if (*(unsigned char *)(a1 + 296) && !*(unsigned char *)(a1 + 297))
    {
      *(unsigned char *)(a1 + 297) = 1;
      sub_100058DB0(&v12, "New Data Plan");
      rest::ResetPayload::ResetPayload();
      sub_1004BC4DC();
      if (v15 < 0) {
        operator delete(__p);
      }
      if (v13 < 0) {
        operator delete(v12);
      }
    }
    else if (!*(void *)(a1 + 112))
    {
      uint64_t v3 = *(void *)(a1 + 208);
      if (v3)
      {
        uint64_t v4 = a1 + 208;
        do
        {
          int v5 = *(_DWORD *)(v3 + 28);
          BOOL v6 = v5 < (int)v2;
          if (v5 >= (int)v2) {
            int v7 = (uint64_t *)v3;
          }
          else {
            int v7 = (uint64_t *)(v3 + 8);
          }
          if (!v6) {
            uint64_t v4 = v3;
          }
          uint64_t v3 = *v7;
        }
        while (*v7);
        if (v4 != a1 + 208 && *(_DWORD *)(v4 + 28) <= (int)v2)
        {
          int v8 = *(_DWORD **)(a1 + 272);
          uint64_t v9 = *(_DWORD **)(a1 + 280);
          if (v8 != v9)
          {
            int v10 = *(unsigned __int8 *)(v4 + 32);
            while (*v8 != v10)
            {
              if (++v8 == v9) {
                return;
              }
            }
            int v11 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(__p) = 67109120;
              HIDWORD(__p) = v10;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Matched reject expiry: %d", (uint8_t *)&__p, 8u);
            }
            sub_10045EEC8(a1, 0x100u);
          }
        }
      }
    }
  }
}

void sub_1004CDBD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1004CDC10(uint64_t a1, int a2)
{
  uint64_t v3 = &__s1[1];
  long long v39 = 0u;
  memset(&__p, 0, sizeof(__p));
  *(_OWORD *)CFTypeID v37 = 0u;
  *(_OWORD *)int v38 = 0u;
  *(_OWORD *)__s1 = 0u;
  *(_OWORD *)__n = 0u;
  memset(v34, 0, sizeof(v34));
  long long v32 = 0u;
  *(_OWORD *)uint64_t v33 = 0u;
  if (a2 == 3)
  {
    uint64_t v4 = *(void **)(a1 + 224);
    int v5 = (void *)(a1 + 232);
    if (v4 == (void *)(a1 + 232)) {
      goto LABEL_58;
    }
    int v6 = *(char *)(a1 + 87);
    if (v6 >= 0) {
      uint64_t v7 = *(unsigned __int8 *)(a1 + 87);
    }
    else {
      uint64_t v7 = *(void *)(a1 + 72);
    }
    while (1)
    {
      uint64_t v8 = *((unsigned __int8 *)v4 + 135);
      if ((v8 & 0x80u) == 0) {
        uint64_t v9 = *((unsigned __int8 *)v4 + 135);
      }
      else {
        uint64_t v9 = v4[15];
      }
      if (v9 == v7)
      {
        if (v6 >= 0) {
          int v10 = (unsigned __int8 *)(a1 + 64);
        }
        else {
          int v10 = *(unsigned __int8 **)(a1 + 64);
        }
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp((const void *)v4[14], v10, v4[15]))
          {
LABEL_40:
            if (v4 != v5)
            {
              long long v32 = *(_OWORD *)(v4 + 5);
              if (&v32 != (long long *)(v4 + 5))
              {
                sub_10008A534((char *)v33, (char *)v4[7], v4[8], (uint64_t)(v4[8] - v4[7]) >> 2);
                sub_10008A640((uint64_t *)v34 + 1, v4[10], v4[11], 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v4[11] - v4[10]) >> 3));
              }
              LODWORD(__s1[0]) = *((_DWORD *)v4 + 26);
              WORD2(__s1[0]) = *((_WORD *)v4 + 54);
              std::string::operator=((std::string *)&__s1[1], (const std::string *)(v4 + 14));
              std::string::operator=((std::string *)v37, (const std::string *)(v4 + 17));
              std::string::operator=((std::string *)&v38[1], (const std::string *)(v4 + 20));
              std::string::operator=(&__p, (const std::string *)(v4 + 23));
              goto LABEL_44;
            }
            goto LABEL_58;
          }
        }
        else
        {
          if (!*((unsigned char *)v4 + 135)) {
            goto LABEL_40;
          }
          int v11 = (unsigned __int8 *)(v4 + 14);
          while (*v11 == *v10)
          {
            ++v11;
            ++v10;
            if (!--v8) {
              goto LABEL_40;
            }
          }
        }
      }
      unint64_t v12 = (void *)v4[1];
      if (v12)
      {
        do
        {
          char v13 = v12;
          unint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          char v13 = (void *)v4[2];
          BOOL v14 = *v13 == (void)v4;
          uint64_t v4 = v13;
        }
        while (!v14);
      }
      uint64_t v4 = v13;
      if (v13 == v5) {
        goto LABEL_58;
      }
    }
  }
  uint64_t v15 = *(void *)(a1 + 232);
  if (!v15) {
    goto LABEL_58;
  }
  uint64_t v16 = a1 + 232;
  do
  {
    int v17 = *(_DWORD *)(v15 + 32);
    BOOL v18 = v17 < a2;
    if (v17 >= a2) {
      char v19 = (uint64_t *)v15;
    }
    else {
      char v19 = (uint64_t *)(v15 + 8);
    }
    if (!v18) {
      uint64_t v16 = v15;
    }
    uint64_t v15 = *v19;
  }
  while (*v19);
  if (v16 == a1 + 232 || *(_DWORD *)(v16 + 32) > a2) {
    goto LABEL_58;
  }
  long long v32 = *(_OWORD *)(v16 + 40);
  if (&v32 != (long long *)(v16 + 40))
  {
    sub_10008A534((char *)v33, *(char **)(v16 + 56), *(void *)(v16 + 64), (uint64_t)(*(void *)(v16 + 64) - *(void *)(v16 + 56)) >> 2);
    sub_10008A640((uint64_t *)v34 + 1, *(void *)(v16 + 80), *(void *)(v16 + 88), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v16 + 88) - *(void *)(v16 + 80)) >> 3));
  }
  LODWORD(__s1[0]) = *(_DWORD *)(v16 + 104);
  WORD2(__s1[0]) = *(_WORD *)(v16 + 108);
  std::string::operator=((std::string *)&__s1[1], (const std::string *)(v16 + 112));
  std::string::operator=((std::string *)v37, (const std::string *)(v16 + 136));
  std::string::operator=((std::string *)&v38[1], (const std::string *)(v16 + 160));
  std::string::operator=(&__p, (const std::string *)(v16 + 184));
LABEL_44:
  uint64_t v20 = HIBYTE(__n[1]);
  if ((__n[1] & 0x8000000000000000) == 0) {
    size_t v21 = HIBYTE(__n[1]);
  }
  else {
    size_t v21 = __n[0];
  }
  uint64_t v22 = *(unsigned __int8 *)(a1 + 87);
  int v23 = (char)v22;
  if ((v22 & 0x80u) != 0) {
    uint64_t v22 = *(void *)(a1 + 72);
  }
  if (v21 != v22)
  {
LABEL_58:
    uint64_t v28 = 0;
    unsigned int v29 = 0;
    int v30 = 0;
    goto LABEL_59;
  }
  CFNumberRef v26 = *(unsigned __int8 **)(a1 + 64);
  CFTypeID v25 = (unsigned __int8 *)(a1 + 64);
  uint64_t v24 = v26;
  if (v23 >= 0) {
    int v27 = v25;
  }
  else {
    int v27 = v24;
  }
  if ((__n[1] & 0x8000000000000000) == 0)
  {
    if (HIBYTE(__n[1]))
    {
      while (*(unsigned __int8 *)v3 == *v27)
      {
        uint64_t v3 = (void **)((char *)v3 + 1);
        ++v27;
        if (!--v20) {
          goto LABEL_57;
        }
      }
      goto LABEL_58;
    }
LABEL_57:
    if (DWORD2(v32) != 5) {
      goto LABEL_58;
    }
LABEL_72:
    int v30 = v32 & 0xFFFFFF00;
    unsigned int v29 = v32;
    uint64_t v28 = &_mh_execute_header;
    goto LABEL_59;
  }
  unsigned int v29 = 0;
  uint64_t v28 = 0;
  if (!memcmp(__s1[1], v27, __n[0]))
  {
    int v30 = 0;
    if (DWORD2(v32) != 5) {
      goto LABEL_59;
    }
    goto LABEL_72;
  }
  int v30 = 0;
LABEL_59:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v39) < 0) {
    operator delete(v38[1]);
  }
  if (SHIBYTE(v38[0]) < 0) {
    operator delete(v37[0]);
  }
  if (SHIBYTE(__n[1]) < 0) {
    operator delete(__s1[1]);
  }
  __int16 v41 = (void **)v34 + 1;
  sub_10002E39C(&v41);
  if (v33[0])
  {
    v33[1] = v33[0];
    operator delete(v33[0]);
  }
  return (unint64_t)v28 | v30 | v29;
}

void sub_1004CDFF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1004CE014(void *a1)
{
  unint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (int *)a1[31];
    uint64_t v3 = (int *)a1[32];
    memset(&__p, 0, sizeof(__p));
    if (v4 != v3)
    {
      std::to_string(&v16, *v4);
      std::string __p = v16;
      for (uint64_t i = v4 + 1; i != v3; ++i)
      {
        *((unsigned char *)&v16.__r_.__value_.__s + 23) = 1;
        LOWORD(v16.__r_.__value_.__l.__data_) = 44;
        std::string::append(&__p, (const std::string::value_type *)&v16, 1uLL);
        if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v16.__r_.__value_.__l.__data_);
        }
        std::to_string(&v16, *i);
        if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          int v6 = &v16;
        }
        else {
          int v6 = (std::string *)v16.__r_.__value_.__r.__words[0];
        }
        if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v16.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v16.__r_.__value_.__l.__size_;
        }
        std::string::append(&__p, (const std::string::value_type *)v6, size);
        if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v16.__r_.__value_.__l.__data_);
        }
      }
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    LODWORD(v16.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v16.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Activation Expiry codes: {%s}", (uint8_t *)&v16, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    unint64_t v2 = a1[5];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = (int *)a1[34];
    uint64_t v9 = (int *)a1[35];
    memset(&__p, 0, sizeof(__p));
    if (v10 != v9)
    {
      std::to_string(&v16, *v10);
      std::string __p = v16;
      for (unint64_t j = v10 + 1; j != v9; ++j)
      {
        *((unsigned char *)&v16.__r_.__value_.__s + 23) = 1;
        LOWORD(v16.__r_.__value_.__l.__data_) = 44;
        std::string::append(&__p, (const std::string::value_type *)&v16, 1uLL);
        if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v16.__r_.__value_.__l.__data_);
        }
        std::to_string(&v16, *j);
        if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unint64_t v12 = &v16;
        }
        else {
          unint64_t v12 = (std::string *)v16.__r_.__value_.__r.__words[0];
        }
        if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v13 = HIBYTE(v16.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v13 = v16.__r_.__value_.__l.__size_;
        }
        std::string::append(&__p, (const std::string::value_type *)v12, v13);
        if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v16.__r_.__value_.__l.__data_);
        }
      }
    }
    BOOL v14 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      BOOL v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    LODWORD(v16.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v16.__r_.__value_.__r.__words + 4) = (std::string::size_type)v14;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Network Expiry codes: {%s}", (uint8_t *)&v16, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  sub_10045EC1C((uint64_t)a1);
}

void sub_1004CE2D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004CE328(uint64_t a1, unint64_t a2, char a3)
{
  if (*(void *)(a1 + 112)) {
    return;
  }
  if (!(sub_1004CDC10(a1, a2) >> 32)) {
    return;
  }
  if ((a3 & 1) == 0) {
    return;
  }
  int v6 = *(_DWORD **)(a1 + 248);
  uint64_t v7 = *(_DWORD **)(a1 + 256);
  if (v6 == v7) {
    return;
  }
  unint64_t v8 = HIDWORD(a2);
  while (*v6 != HIDWORD(a2))
  {
    if (++v6 == v7) {
      return;
    }
  }
  uint64_t v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Matched activation expiry: %d", buf, 8u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  int v11 = ServiceMap;
  if (v12 < 0)
  {
    std::string::size_type v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v12;
  std::string v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
  if (v16)
  {
    uint64_t v18 = v16[3];
    int v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  int v17 = 0;
  char v19 = 1;
LABEL_20:
  if (v18)
  {
    uint64_t v20 = *(unsigned int *)(a1 + 168);
    sub_100058DB0(__p, "Connection Expiry Monitor Mode Failure");
    (*(void (**)(uint64_t, uint64_t, uint64_t, void, void **, uint64_t, void))(*(void *)v18 + 80))(v18, v20, 1, 0, __p, 1, 0);
    if (v22 < 0) {
      operator delete(__p[0]);
    }
  }
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  sub_10045EEC8(a1, 0x100u);
}

void sub_1004CE53C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004CE588(uint64_t a1)
{
  unint64_t v2 = sub_1004CDC10(a1, 3);
  if (HIDWORD(v2))
  {
    uint64_t v3 = *(void *)(a1 + 184);
    if (v3)
    {
      uint64_t v4 = a1 + 184;
      do
      {
        int v5 = *(_DWORD *)(v3 + 32);
        BOOL v6 = v5 < (int)v2;
        if (v5 >= (int)v2) {
          uint64_t v7 = (uint64_t *)v3;
        }
        else {
          uint64_t v7 = (uint64_t *)(v3 + 8);
        }
        if (!v6) {
          uint64_t v4 = v3;
        }
        uint64_t v3 = *v7;
      }
      while (*v7);
      if (v4 != a1 + 184 && *(_DWORD *)(v4 + 32) <= (int)v2 && *(_DWORD *)(v4 + 64) == 2)
      {
        *(unsigned char *)(a1 + 297) = 1;
        sub_10045EEC8(a1, 0x101u);
      }
    }
  }
}

uint64_t *sub_1004CE630(void *a1, uint64_t *a2)
{
  int v7 = 0;
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)&v7, (int *)a1, v5);
    }
  }
  return sub_1004CE698(a2, &v7);
}

uint64_t *sub_1004CE698(uint64_t *a1, _DWORD *a2)
{
  uint64_t v4 = *a1;
  CFNumberRef v5 = *(_DWORD **)(*a1 + 8);
  BOOL v6 = (void *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    unint64_t v8 = *(_DWORD **)v4;
    uint64_t v9 = ((uint64_t)v5 - *(void *)v4) >> 2;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62) {
      sub_10006A748();
    }
    uint64_t v11 = *v6 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      std::string::size_type v13 = (char *)sub_10005ECD8((uint64_t)v6, v12);
      unint64_t v8 = *(_DWORD **)v4;
      CFNumberRef v5 = *(_DWORD **)(v4 + 8);
    }
    else
    {
      std::string::size_type v13 = 0;
    }
    uint64_t v14 = &v13[4 * v9];
    unsigned int v15 = &v13[4 * v12];
    *(_DWORD *)uint64_t v14 = *a2;
    int v7 = v14 + 4;
    while (v5 != v8)
    {
      int v16 = *--v5;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(void *)uint64_t v4 = v14;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *CFNumberRef v5 = *a2;
    int v7 = v5 + 1;
  }
  *(void *)(v4 + 8) = v7;
  return a1;
}

void sub_1004CE788(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D7608;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004CE7A8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D7608;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004CE7FC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1004CE828(uint64_t a1)
{
  sub_1004CD560(a1);

  operator delete();
}

void sub_1004CE860(uint64_t **a1)
{
  uint64_t v1 = **a1;
  Registry::createRestModuleOneTimeUseConnection(&v7, *(Registry **)(v1 + 48));
  ctu::RestModule::connect();
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_10041BCB4(v1 + 168);
  sub_100058DB0(__p, "/cc/props/internal_internet_connection_state");
  unint64_t v2 = operator new(0x28uLL);
  void *v2 = off_1019D76D8;
  v2[1] = v1 + 176;
  void v2[2] = v1;
  v2[3] = sub_1004CE588;
  void v2[4] = 0;
  unint64_t v12 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(v11);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/sims_in_use");
  uint64_t v3 = operator new(0x28uLL);
  void *v3 = off_1019D7758;
  v3[1] = v1 + 224;
  void v3[2] = v1;
  v3[3] = sub_1004CE584;
  v3[4] = 0;
  unint64_t v12 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(v11);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  if (*(void *)(v1 + 272) != *(void *)(v1 + 280))
  {
    sub_100058DB0(__p, "/cc/props/network_rejects");
    uint64_t v4 = operator new(0x28uLL);
    void *v4 = off_1019D77D8;
    v4[1] = v1 + 200;
    void v4[2] = v1;
    uint64_t v4[3] = sub_1004CDA38;
    void v4[4] = 0;
    unint64_t v12 = v4;
    ctu::RestModule::observeProperty();
    sub_10003F600(v11);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100058DB0(__p, "/cc/events/connection_activate_error");
  CFNumberRef v5 = operator new(0x20uLL);
  *CFNumberRef v5 = off_1019D7858;
  v5[1] = v1;
  void v5[2] = sub_1004CE328;
  void v5[3] = 0;
  unint64_t v12 = v5;
  ctu::RestModule::observeEvent();
  sub_10003F600(v11);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  BOOL v6 = operator new(0x20uLL);
  *BOOL v6 = off_1019D78D8;
  v6[1] = v1;
  void v6[2] = sub_1004CEC08;
  void v6[3] = 0;
  unint64_t v12 = v6;
  ctu::RestModule::observeEvent();
  sub_10003F600(v11);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  operator delete();
}

void sub_1004CEB80(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  operator delete();
}

uint64_t sub_1004CEC08(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 32))();
}

void sub_1004CEC30()
{
}

__n128 sub_1004CEC44(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)unint64_t v2 = off_1019D76D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004CEC98(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D76D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004CECD0(uint64_t *a1, xpc_object_t *a2)
{
  sub_1004CED98(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  CFNumberRef v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1004CED4C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004CED8C()
{
}

void sub_1004CED98(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_1000886C0(a1, *(char **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v12, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v11, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v13; i != v11[1] || v12 != v11[0]; uint64_t i = ++v13)
    {
      xpc_object_t v10 = 0;
      object[0] = &v12;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v10);
      if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v9 = 0;
        *(_OWORD *)dispatch_object_t object = 0u;
        long long v8 = 0u;
        sub_1004CF204(object);
        xpc_object_t v6 = v10;
        if (v10) {
          xpc_retain(v10);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_1004CF050((int *)object, &v6);
        xpc_release(v6);
        sub_1004CF28C((uint64_t **)a1, (int *)object, (uint64_t)object);
        if (SHIBYTE(v8) < 0) {
          operator delete(object[1]);
        }
      }
      xpc_release(v10);
    }
    xpc_release(v12);
    xpc_release(v12);
  }
  xpc_release(v3);
}

void sub_1004CEFA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, xpc_object_t a19, xpc_object_t a20)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v21 - 48));
  xpc_release(v20);
  _Unwind_Resume(a1);
}

void sub_1004CF050(int *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v9 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v9 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = &v9;
    uint64_t v7 = "first";
    sub_100048BAC((uint64_t)&v6, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v10 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v10, (int *)&object, v5);
      *a1 = v10;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    xpc_object_t v6 = &v9;
    uint64_t v7 = "second";
    sub_100048BAC((uint64_t)&v6, &object);
    read_rest_value();
    xpc_release(object);
    xpc_object_t v3 = v9;
  }
  xpc_release(v3);
}

void sub_1004CF1B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13)
{
}

_DWORD *sub_1004CF204(_DWORD *a1)
{
  *a1 = 0;
  sub_100058DB0(&__p, "");
  NetworkInterfaceInfo::NetworkInterfaceInfo();
  if (v4 < 0) {
    operator delete(__p);
  }
  return a1;
}

void sub_1004CF270(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **sub_1004CF28C(uint64_t **a1, int *a2, uint64_t a3)
{
  xpc_object_t v6 = a1 + 1;
  CFNumberRef v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        long long v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9) {
          break;
        }
        CFNumberRef v5 = *v8;
        xpc_object_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      CFNumberRef v5 = v8[1];
      if (!v5)
      {
        xpc_object_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    long long v8 = a1 + 1;
LABEL_10:
    int v10 = (char *)operator new(0x48uLL);
    *((_DWORD *)v10 + 8) = *(_DWORD *)a3;
    *(_OWORD *)(v10 + 40) = *(_OWORD *)(a3 + 8);
    *((void *)v10 + 7) = *(void *)(a3 + 24);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    *((_DWORD *)v10 + 16) = *(_DWORD *)(a3 + 32);
    *((_WORD *)v10 + 34) = *(_WORD *)(a3 + 36);
    sub_100046C38(a1, (uint64_t)v8, v6, (uint64_t *)v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void sub_1004CF374()
{
}

__n128 sub_1004CF388(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)unint64_t v2 = off_1019D7758;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004CF3DC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D7758;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1004CF414(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (std::string *)a1[1];
  long long v21 = 0uLL;
  uint64_t v22 = 0;
  sub_100089CF0((uint64_t *)&v21, a2);
  p_std::string::size_type size = &v3->__r_.__value_.__l.__size_;
  std::string::size_type size = (void *)v3->__r_.__value_.__l.__size_;
  uint64_t v18 = (void **)v3->__r_.__value_.__r.__words[0];
  char v19 = size;
  std::string::size_type v20 = v3->__r_.__value_.__r.__words[2];
  if (v20)
  {
    size[2] = &v19;
    v3->__r_.__value_.__r.__words[0] = (std::string::size_type)p_size;
    *p_std::string::size_type size = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
  }
  else
  {
    uint64_t v18 = (void **)&v19;
  }
  long long v16 = v21;
  uint64_t v17 = v22;
  uint64_t v22 = 0;
  long long v21 = 0uLL;
  sub_10008A04C(v3, (uint64_t *)&v16);
  int v23 = (void **)&v16;
  sub_10008A88C(&v23);
  if (v20 == v3->__r_.__value_.__r.__words[2])
  {
    xpc_object_t v6 = v18;
    if (v18 == (void **)&v19) {
      goto LABEL_24;
    }
    int v7 = (void *)v3->__r_.__value_.__r.__words[0];
    while (*((_DWORD *)v6 + 8) == *((_DWORD *)v7 + 8) && BasicSimInfo::operator==())
    {
      long long v8 = (void **)v6[1];
      int v9 = (void ***)v6;
      if (v8)
      {
        do
        {
          xpc_object_t v6 = v8;
          long long v8 = (void **)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          xpc_object_t v6 = v9[2];
          BOOL v10 = *v6 == v9;
          int v9 = (void ***)v6;
        }
        while (!v10);
      }
      uint64_t v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          unint64_t v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unint64_t v12 = (void *)v7[2];
          BOOL v10 = *v12 == (void)v7;
          int v7 = v12;
        }
        while (!v10);
      }
      int v7 = v12;
      if (v6 == (void **)&v19) {
        goto LABEL_24;
      }
    }
  }
  std::string::size_type v13 = (void (*)(void *))a1[3];
  uint64_t v14 = a1[4];
  unsigned int v15 = (void *)(a1[2] + (v14 >> 1));
  if (v14) {
    std::string::size_type v13 = *(void (**)(void *))(*v15 + v13);
  }
  v13(v15);
LABEL_24:
  sub_100088048((uint64_t)&v18, v19);
  uint64_t v18 = (void **)&v21;
  sub_10008A88C(&v18);
}

void sub_1004CF5D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, void *a13, uint64_t a14, char a15)
{
  a12 = (void **)&a15;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1004CF61C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004CF65C()
{
}

void sub_1004CF66C()
{
}

__n128 sub_1004CF680(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)unint64_t v2 = off_1019D77D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004CF6D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D77D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004CF70C(uint64_t *a1, xpc_object_t *a2)
{
  sub_1004CF7D4(a1[1], a2);
  xpc_object_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  CFNumberRef v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    xpc_object_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1004CF788(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004CF7C8()
{
}

void sub_1004CF7D4(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_1000346F8(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v11, object, 0);
    xpc_release(object[0]);
    xpc_object_t v7 = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t v7 = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(object, &v7, count);
    xpc_release(v7);
    for (uint64_t i = v12; i != object[1] || v11 != object[0]; uint64_t i = ++v12)
    {
      long long v8 = i;
      xpc_object_t v9 = 0;
      xpc_object_t v7 = &v11;
      sub_10003FBDC((uint64_t)&v7, &v9);
      if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
      {
        LODWORD(v8) = 11;
        xpc_object_t v6 = v9;
        xpc_object_t v7 = 0;
        if (v9) {
          xpc_retain(v9);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_1004CFA60((int *)&v7, &v6);
        xpc_release(v6);
        sub_100256DC0((uint64_t **)a1, (int *)&v7, (uint64_t)&v7);
      }
      xpc_release(v9);
    }
    xpc_release(v11);
    xpc_release(v11);
  }
  xpc_release(v3);
}

void sub_1004CF9D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t object, uint64_t a11, xpc_object_t a12, xpc_object_t a13, uint64_t a14, xpc_object_t a15)
{
  xpc_release(object);
  xpc_release(a15);
  xpc_release(v15);
  _Unwind_Resume(a1);
}

void sub_1004CFA60(int *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v9 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v9 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = &v9;
    xpc_object_t v7 = "first";
    sub_100048BAC((uint64_t)&v6, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v10 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v10, (int *)&object, v5);
      *a1 = v10;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    xpc_object_t v6 = &v9;
    xpc_object_t v7 = "second";
    sub_100048BAC((uint64_t)&v6, &object);
    rest::read_rest_value();
    xpc_release(object);
    xpc_object_t v3 = v9;
  }
  xpc_release(v3);
}

void sub_1004CFBC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13)
{
}

void sub_1004CFC18()
{
}

__n128 sub_1004CFC2C(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)unint64_t v2 = off_1019D7858;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1004CFC80(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D7858;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004CFCB8(void *a1)
{
  read_rest_value();
  unint64_t v2 = (uint64_t (*)(void *, void, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    unint64_t v2 = *(uint64_t (**)(void *, void, void))(*v4 + v2);
  }
  return v2(v4, 0, 0);
}

uint64_t sub_1004CFD38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004CFD78()
{
}

void sub_1004CFD88()
{
}

__n128 sub_1004CFD9C(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)unint64_t v2 = off_1019D78D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1004CFDF0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D78D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004CFE28(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1004CFE70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004CFEB0()
{
}

uint64_t sub_1004CFEBC(uint64_t a1)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "stw.env");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v4, &v3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)v4);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v4);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
  *(unsigned char *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  return a1;
}

void sub_1004CFF4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1004CFF70(uint64_t result, void *a2)
{
  if (!*(void *)(result + 8))
  {
    uint64_t v3 = *(NSObject **)result;
    if (os_log_type_enabled(*(os_log_t *)result, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Creating emergency environment...", v5, 2u);
    }
    uint64_t v4 = operator new(0x190uLL);
    v4[1] = 0;
    void v4[2] = 0;
    void *v4 = off_1019D7958;
    sub_100BDE518(v4 + 3, a2);
  }
  return result;
}

void sub_1004D0040(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1004D0058(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1)
  {
    uint64_t v3 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Tearing down emergency environment...", v5, 2u);
      uint64_t v1 = *(void *)(a1 + 8);
    }
    sub_100BDE9CC(v1);
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_1004D00E8(uint64_t result, void *a2)
{
  if (!*(void *)(result + 40))
  {
    uint64_t v3 = *(NSObject **)result;
    if (os_log_type_enabled(*(os_log_t *)result, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Creating Roadside environment...", v5, 2u);
    }
    uint64_t v4 = operator new(0x140uLL);
    v4[1] = 0;
    void v4[2] = 0;
    void *v4 = off_1019D79A8;
    sub_101117B20(v4 + 3, a2);
  }
  return result;
}

void sub_1004D01B8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1004D01D0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    uint64_t v3 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Tearing down Roadside environment...", v5, 2u);
      uint64_t v1 = *(void *)(a1 + 40);
    }
    sub_100BDE9CC(v1);
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_1004D0260(uint64_t result, void *a2)
{
  if (!*(void *)(result + 88))
  {
    uint64_t v3 = *(NSObject **)result;
    if (os_log_type_enabled(*(os_log_t *)result, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Creating SatSms environment...", v5, 2u);
    }
    uint64_t v4 = operator new(0xD8uLL);
    v4[1] = 0;
    void v4[2] = 0;
    void *v4 = off_1019D79F8;
    sub_1002B449C(v4 + 3, a2, "stw.sms.env");
  }
  return result;
}

void sub_1004D0390(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1004D03A8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1)
  {
    uint64_t v3 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Tearing down SatSms environment...", v5, 2u);
      uint64_t v1 = *(void *)(a1 + 88);
    }
    sub_1006BE6F0(v1);
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 96);
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0;
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_1004D0438(uint64_t result, void *a2)
{
  if (!*(void *)(result + 72))
  {
    uint64_t v3 = *(NSObject **)result;
    if (os_log_type_enabled(*(os_log_t *)result, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Creating IMessageLite environment...", v5, 2u);
    }
    uint64_t v4 = operator new(0x98uLL);
    v4[1] = 0;
    void v4[2] = 0;
    void *v4 = off_1019D7A48;
    sub_1002B449C(v4 + 3, a2, "stw.iml.env");
  }
  return result;
}

void sub_1004D0544(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1004D055C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  if (v1)
  {
    uint64_t v3 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Tearing down IMessageLite environment...", v5, 2u);
      uint64_t v1 = *(void *)(a1 + 72);
    }
    sub_1004FB780(v1);
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 80);
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_1004D05EC(uint64_t result, void *a2)
{
  if (!*(void *)(result + 56))
  {
    uint64_t v3 = *(NSObject **)result;
    if (os_log_type_enabled(*(os_log_t *)result, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Setting up LLC associated state...", v5, 2u);
    }
    uint64_t v4 = operator new(0xE0uLL);
    v4[1] = 0;
    void v4[2] = 0;
    void *v4 = off_1019D7A98;
    sub_1003CA2E4(v4 + 3, a2);
  }
  return result;
}

void sub_1004D06AC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1004D06C4(uint64_t a1)
{
  if (*(void *)(a1 + 56))
  {
    uint64_t v2 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Tearing down LLC associated state...", v4, 2u);
    }
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
    if (v3) {
      sub_10004D2C8(v3);
    }
  }
}

void sub_1004D0740(uint64_t a1, unsigned int a2)
{
  if (*(unsigned __int8 *)(a1 + 104) != a2)
  {
    unsigned int v2 = a2;
    *(unsigned char *)(a1 + 104) = a2;
    uint64_t v4 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      if (v2 > 3) {
        uint64_t v5 = "???";
      }
      else {
        uint64_t v5 = off_1019D7AD8[(char)v2];
      }
      int v7 = 136315138;
      long long v8 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Setting compression support to %s", (uint8_t *)&v7, 0xCu);
      unsigned int v2 = *(unsigned __int8 *)(a1 + 104);
    }
    if (v2 <= 2)
    {
      xpc_object_t v6 = *(std::__shared_weak_count **)(a1 + 32);
      *(void *)(a1 + 24) = 0;
      *(void *)(a1 + 32) = 0;
      if (v6) {
        sub_10004D2C8(v6);
      }
    }
  }
}

uint64_t sub_1004D0838(uint64_t a1, uint64_t *a2)
{
  if (!*a2) {
    return 0;
  }
  if (!_os_feature_enabled_impl()) {
    return 2;
  }
  unsigned int v4 = *(unsigned __int8 *)(a1 + 104);
  if (v4 == 2) {
    return 2;
  }
  if (!sub_10112599C(*a2)) {
    return 1;
  }
  if ((sub_101125A48(*a2) & 0xFF00000000) != 0) {
    return v4;
  }
  return 2;
}

void sub_1004D08C0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D7958;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004D08E0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D7958;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004D0934(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 32))();
}

void sub_1004D095C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D79A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004D097C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D79A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004D09D0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 32))();
}

void sub_1004D09F8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D79F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004D0A18(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D79F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004D0A6C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 32))();
}

void sub_1004D0A94(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D7A48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004D0AB4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D7A48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004D0B08(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 32))();
}

void sub_1004D0B30(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D7A98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004D0B50(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D7A98;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004D0BA4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 32))();
}

void sub_1004D0BCC(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1004D0C58(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004D0C94(void *a1, void *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_1019D7B08;
  a1[3] = *a2;
  uint64_t v2 = a2[1];
  a1[4] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  a1[5] = 0;
  a1[6] = 0;
  sub_1007174F0();
}

void sub_1004D0D30(_Unwind_Exception *a1)
{
  uint64_t v3 = (std::__shared_weak_count *)*((void *)v1 + 6);
  if (v3) {
    sub_10004D2C8(v3);
  }
  unsigned int v4 = (std::__shared_weak_count *)*((void *)v1 + 4);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)v1 + 2);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  DataWifiMonitorInterface::~DataWifiMonitorInterface(v1);
  _Unwind_Resume(a1);
}

void sub_1004D0D68(DataWifiMonitorInterface *this)
{
  *(void *)this = &off_1019D7B08;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v3) {
    sub_10004D2C8(v3);
  }
  unsigned int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  DataWifiMonitorInterface::~DataWifiMonitorInterface(this);
}

void sub_1004D0DE0(DataWifiMonitorInterface *a1)
{
  sub_1004D0D68(a1);

  operator delete();
}

uint64_t sub_1004D0E18(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 24))();
}

uint64_t sub_1004D0E40(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 32))();
}

void sub_1004D0E68(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1004D0EE8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004D0F24(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004D0F5C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1004D0F8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1004D0FD0(CFURLRef anURL@<X3>, os_log_t *a2@<X0>, Registry **a3@<X1>, const __CFString *a4@<X2>, uint8_t *a5@<X8>)
{
  *(void *)a5 = 0;
  if (a4 && anURL && CFURLHasDirectoryPath(anURL))
  {
    CFTypeRef cf = 0;
    copyURLAsString((uint64_t *)&cf, anURL);
    CFStringRef v77 = a4;
    long long buf = 0uLL;
    v96[0] = 0;
    ctu::cf::assign();
    uint64_t v90 = v96[0];
    *(_OWORD *)BOOL v89 = buf;
    int v10 = (const void *)kSysCountryBundleDir;
    xpc_object_t v11 = (char *)HIBYTE(v96[0]);
    CFArrayRef otherArray = 0;
    CFArrayRef theArray = 0;
    if (v96[0] >= 0) {
      unint64_t v12 = v89;
    }
    else {
      unint64_t v12 = (void **)v89[0];
    }
    int64_t v13 = strlen(kSysCountryBundleDir);
    CFTypeID v76 = a3;
    if (v13)
    {
      int64_t v14 = v13;
      if (v96[0] >= 0) {
        uint64_t v15 = HIBYTE(v96[0]);
      }
      else {
        uint64_t v15 = (uint64_t)v89[1];
      }
      long long v16 = (char *)v12 + v15;
      if (v15 >= v13)
      {
        int v28 = (char)*kSysCountryBundleDir;
        unsigned int v29 = v12;
        do
        {
          uint64_t v30 = v15 - v14;
          if (v30 == -1) {
            break;
          }
          uint64_t v31 = (char *)memchr(v29, v28, v30 + 1);
          if (!v31) {
            break;
          }
          uint64_t v17 = v31;
          if (!memcmp(v31, v10, v14)) {
            goto LABEL_13;
          }
          unsigned int v29 = (void **)(v17 + 1);
          uint64_t v15 = v16 - (v17 + 1);
        }
        while (v15 >= v14);
      }
      uint64_t v17 = v16;
LABEL_13:
      uint64_t v18 = v17 - (char *)v12;
      if (v17 == v16) {
        uint64_t v18 = -1;
      }
      uint64_t v78 = v18;
    }
    else
    {
      uint64_t v78 = 0;
    }
    std::string::size_type v20 = (const void *)kSysCBDir;
    int64_t v21 = strlen(kSysCBDir);
    if (v21)
    {
      int64_t v22 = v21;
      if ((char)v11 >= 0) {
        int v23 = v11;
      }
      else {
        int v23 = (char *)v89[1];
      }
      uint64_t v24 = &v23[(void)v12];
      if ((uint64_t)v23 >= v21)
      {
        int v32 = (char)*kSysCBDir;
        uint64_t v33 = v12;
        uint64_t v26 = v78;
        do
        {
          unint64_t v34 = &v23[-v22];
          if (v34 == (char *)-1) {
            break;
          }
          int v35 = (char *)memchr(v33, v32, (size_t)(v34 + 1));
          if (!v35) {
            break;
          }
          CFTypeID v25 = v35;
          if (!memcmp(v35, v20, v22)) {
            goto LABEL_38;
          }
          uint64_t v33 = (void **)(v25 + 1);
          int v23 = (char *)(v24 - (v25 + 1));
        }
        while ((uint64_t)v23 >= v22);
        CFTypeID v25 = v24;
      }
      else
      {
        CFTypeID v25 = &v23[(void)v12];
        uint64_t v26 = v78;
      }
LABEL_38:
      if (v25 == v24) {
        uint64_t v27 = -1;
      }
      else {
        uint64_t v27 = v25 - (char *)v12;
      }
    }
    else
    {
      uint64_t v27 = 0;
      uint64_t v26 = v78;
    }
    sub_1004D1B74(anURL, a2, (void **)v97);
    *(void *)&long long buf = theArray;
    CFArrayRef theArray = *(CFArrayRef *)v97;
    *(void *)uint64_t v97 = 0;
    sub_100044D00((const void **)&buf);
    sub_100044D00((const void **)v97);
    if (theArray) {
      unsigned __int16 v36 = sub_100083F10;
    }
    else {
      unsigned __int16 v36 = 0;
    }
    if (v36 && CFArrayGetCount(theArray) >= 1)
    {
      if (!v26)
      {
        CFMutableArrayRef MutableCopy = CFArrayCreateMutableCopy(0, 0, theArray);
        CFMutableArrayRef v38 = MutableCopy;
        *(void *)&long long buf = 0;
        if (MutableCopy)
        {
          CFTypeID v39 = CFGetTypeID(MutableCopy);
          if (v39 != CFArrayGetTypeID())
          {
            *(void *)&long long buf = 0;
            CFRelease(v38);
            CFMutableArrayRef v38 = (CFMutableArrayRef)buf;
          }
        }
        CFArrayRef v40 = otherArray;
        CFArrayRef otherArray = v38;
        *(void *)&long long buf = v40;
        sub_100044D00((const void **)&buf);
      }
      CFTypeRef v86 = cf;
      if (cf) {
        CFRetain(cf);
      }
      CFArrayRef v85 = theArray;
      if (theArray) {
        CFRetain(theArray);
      }
      sub_1004D1ECC((const void **)v97, a2, v77, &v86, &v85);
      if (v97 != a5)
      {
        *(void *)&long long buf = *(void *)a5;
        *(void *)a5 = *(void *)v97;
        *(void *)uint64_t v97 = 0;
        sub_100044D00((const void **)&buf);
      }
      sub_100044D00((const void **)v97);
      sub_100044D00((const void **)&v85);
      sub_1000558F4(&v86);
      if (*(void *)a5) {
        __int16 v41 = sub_100083F10;
      }
      else {
        __int16 v41 = 0;
      }
      if (v41 && CFArrayGetCount(*(CFArrayRef *)a5) > 0) {
        goto LABEL_151;
      }
      uint64_t v42 = HIBYTE(v90);
      if (v90 >= 0)
      {
        unint64_t v43 = v89;
      }
      else
      {
        uint64_t v42 = (uint64_t)v89[1];
        unint64_t v43 = (void **)v89[0];
      }
      if (v42 >= 15)
      {
        CFTypeID v44 = (char *)v43 + v42;
        uint64_t v45 = v43;
        while (1)
        {
          unsigned int v46 = (char *)memchr(v45, 67, v42 - 14);
          if (!v46) {
            goto LABEL_78;
          }
          if (*(void *)v46 == 0x2072656972726143 && *(void *)(v46 + 7) == 0x73656C646E754220) {
            break;
          }
          uint64_t v45 = (void **)(v46 + 1);
          uint64_t v42 = v44 - (char *)v45;
          if (v44 - (char *)v45 < 15) {
            goto LABEL_78;
          }
        }
        if (v46 != v44 && v46 - (char *)v43 != -1)
        {
          os_log_t v48 = *a2;
          if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            int v49 = "#I No potential candidates found in the cache for carrier bundles.";
            CFStringRef v50 = v48;
            uint32_t v51 = 2;
LABEL_122:
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, v49, (uint8_t *)&buf, v51);
            goto LABEL_151;
          }
          goto LABEL_151;
        }
      }
LABEL_78:
      uint64_t v52 = *a2;
      uint64_t v26 = v78;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = v43;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I No potential candidates found in the cache, scanning the directory %{public}s", (uint8_t *)&buf, 0xCu);
      }
    }
    CFBooleanRef v53 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      char v54 = v89;
      if (v90 < 0) {
        char v54 = (void **)v89[0];
      }
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = v54;
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I Rescan %{public}s", (uint8_t *)&buf, 0xCu);
    }
    if (v26 && v27)
    {
      copyDirectoryContentsInString(a2, v76, 1, v97);
      *(void *)&long long buf = theArray;
      CFArrayRef theArray = *(CFArrayRef *)v97;
      *(void *)uint64_t v97 = 0;
      sub_100044D00((const void **)&buf);
      sub_100044D00((const void **)v97);
    }
    else
    {
      memset(v96, 0, sizeof(v96));
      long long buf = 0u;
      os_log_t v55 = *a2;
      os_signpost_id_t v56 = os_signpost_id_generate(*a2);
      if (v56 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        char v57 = *a2;
        if (os_signpost_enabled(*a2))
        {
          CFNumberRef v58 = v89;
          if (v90 < 0) {
            CFNumberRef v58 = (void **)v89[0];
          }
          *(_DWORD *)uint64_t v97 = 136315138;
          *(void *)&v97[4] = v58;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v57, OS_SIGNPOST_INTERVAL_BEGIN, v56, "SystemCarrier CountryBundlesScan", "path=%{signpost.description:attribute}s", v97, 0xCu);
        }
      }
      *(void *)uint64_t v97 = off_1019D7BF8;
      char v98 = v97;
      *(void *)&long long buf = v56;
      *((void *)&buf + 1) = os_retain(v55);
      sub_1000336E8((uint64_t)v96, (uint64_t)v97);
      sub_100033A10(v97);
      *(_OWORD *)uint64_t v97 = 0uLL;
      sub_100058DB0(&__p, "scan carrier-country bundles");
      long long v93 = buf;
      sub_1000336E8((uint64_t)&v94, (uint64_t)v96);
      long long buf = 0uLL;
      sub_100033AF4(v96);
      Registry::createXpcJetsamAssertion();
      sub_1000339DC((uint64_t *)&v93);
      if (v84 < 0) {
        operator delete(__p);
      }
      copyDirectoryContentsInString(a2, v76, 0, &v82);
      CFArrayRef v92 = theArray;
      CFArrayRef theArray = v82;
      CFArrayRef v82 = 0;
      sub_100044D00((const void **)&v92);
      sub_100044D00((const void **)&v82);
      if (*(void *)&v97[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v97[8]);
      }
      sub_1000339DC((uint64_t *)&buf);
    }
    if (theArray) {
      CFTypeID v59 = sub_100083F10;
    }
    else {
      CFTypeID v59 = 0;
    }
    if (!v59) {
      goto LABEL_151;
    }
    if (!CFArrayGetCount(theArray))
    {
      os_log_t v63 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v64 = v89;
        if (v90 < 0) {
          uint64_t v64 = (void **)v89[0];
        }
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = v64;
        int v49 = "#N No contents found after scanning the directory, %{public}s";
        CFStringRef v50 = v63;
        uint32_t v51 = 12;
        goto LABEL_122;
      }
LABEL_151:
      sub_100044D00((const void **)&otherArray);
      sub_100044D00((const void **)&theArray);
      if (SHIBYTE(v90) < 0) {
        operator delete(v89[0]);
      }
      sub_1000558F4(&cf);
      return;
    }
    CFTypeRef v81 = cf;
    if (cf) {
      CFRetain(cf);
    }
    CFArrayRef v80 = theArray;
    if (theArray) {
      CFRetain(theArray);
    }
    sub_1004D1ECC((const void **)v97, a2, v77, &v81, &v80);
    if (v97 != a5)
    {
      *(void *)&long long buf = *(void *)a5;
      *(void *)a5 = *(void *)v97;
      *(void *)uint64_t v97 = 0;
      sub_100044D00((const void **)&buf);
    }
    sub_100044D00((const void **)v97);
    sub_100044D00((const void **)&v80);
    sub_1000558F4(&v81);
    if (*(void *)a5) {
      CFBooleanRef v60 = sub_100083F10;
    }
    else {
      CFBooleanRef v60 = 0;
    }
    if (!v60 || v26) {
      goto LABEL_151;
    }
    if (otherArray) {
      BOOL v61 = sub_100083F10;
    }
    else {
      BOOL v61 = 0;
    }
    if (v61) {
      uint64_t Count = CFArrayGetCount(otherArray);
    }
    else {
      uint64_t Count = 0;
    }
    *(void *)uint64_t v97 = 0;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      uint64_t v66 = *(void *)v97;
      *(void *)uint64_t v97 = Mutable;
      *(void *)&long long buf = v66;
      sub_1000440D4((const void **)&buf);
    }
    CFIndex v67 = CFArrayGetCount(*(CFArrayRef *)a5);
    if (v67 < 1)
    {
LABEL_142:
      if (CFArrayGetCount(*(CFArrayRef *)v97) >= 1)
      {
        if (Count >= 1)
        {
          v100.location = 0;
          v100.length = Count;
          CFArrayAppendArray(*(CFMutableArrayRef *)v97, otherArray, v100);
        }
        uint64_t v75 = *a2;
        if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#N Updating the country bundle cache with the potential candidates,", (uint8_t *)&buf, 2u);
        }
        CFRange v79 = *(const void **)v97;
        if (*(void *)v97) {
          CFRetain(*(CFTypeRef *)v97);
        }
        CountryBundleDevicePersistentSaveValue();
        sub_1000577C4(&v79);
      }
      sub_1000440D4((const void **)v97);
      goto LABEL_151;
    }
    CFIndex v68 = 0;
    while (1)
    {
      CFArrayRef ValueAtIndex = (const void **)CFArrayGetValueAtIndex(*(CFArrayRef *)a5, v68);
      xpc_object_t v70 = ValueAtIndex;
      if (ValueAtIndex)
      {
        CFTypeID v71 = CFGetTypeID(ValueAtIndex);
        if (v71 == CFURLGetTypeID()) {
          uint64_t v72 = v70;
        }
        else {
          uint64_t v72 = 0;
        }
      }
      else
      {
        uint64_t v72 = 0;
      }
      *(void *)&long long buf = 0;
      copyFileName(v72, (CFStringRef *)&buf);
      char v73 = (const void *)buf;
      if ((void)buf) {
        CFStringRef v74 = sub_1000810B8;
      }
      else {
        CFStringRef v74 = 0;
      }
      if (!v74) {
        goto LABEL_141;
      }
      if (Count < 1) {
        goto LABEL_140;
      }
      v99.location = 0;
      v99.length = Count;
      if (!CFArrayContainsValue(otherArray, v99, (const void *)buf)) {
        break;
      }
LABEL_141:
      sub_1000558F4((const void **)&buf);
      if (v67 == ++v68) {
        goto LABEL_142;
      }
    }
    char v73 = (const void *)buf;
LABEL_140:
    CFArrayAppendValue(*(CFMutableArrayRef *)v97, v73);
    goto LABEL_141;
  }
  char v19 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#N Input values are incorrect", (uint8_t *)&buf, 2u);
  }
}

void sub_1004D1A24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28,int a29,__int16 a30,char a31,char a32,int a33,__int16 a34,char a35,char a36,int a37,__int16 a38,char a39,char a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,char a51,uint64_t a52,char a53)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004D1B74(__CFURL *a1@<X1>, os_log_t *a2@<X0>, void **a3@<X8>)
{
  *a3 = 0;
  if (a1)
  {
    std::string::size_type v20 = 0;
    copyURLAsString((uint64_t *)&v20, a1);
    if (v20) {
      uint64_t v5 = sub_1000810B8;
    }
    else {
      uint64_t v5 = 0;
    }
    if (v5)
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v22 = 0;
      ctu::cf::assign();
      *(_OWORD *)uint64_t v18 = *(_OWORD *)buf;
      uint64_t v19 = v22;
      uint64_t v6 = *(void *)&buf[8];
      if (v22 < 0)
      {
        int v7 = *(void ***)buf;
      }
      else
      {
        uint64_t v6 = HIBYTE(v22);
        int v7 = v18;
      }
      if (v6 >= 14)
      {
        long long v8 = (char *)v7 + v6;
        xpc_object_t v9 = v7;
        do
        {
          int v10 = (char *)memchr(v9, 67, v6 - 13);
          if (!v10) {
            break;
          }
          if (*(void *)v10 == 0x427972746E756F43 && *(void *)(v10 + 6) == 0x73656C646E754279)
          {
            if (v10 != v8 && v10 - (char *)v7 != -1)
            {
              CountryBundleDevicePersistentCopyValue((uint64_t *)v23, v20, 0);
              sub_100044D6C(__p, (CFTypeRef *)v23);
              goto LABEL_24;
            }
            break;
          }
          xpc_object_t v9 = (void **)(v10 + 1);
          uint64_t v6 = v8 - (char *)v9;
        }
        while (v8 - (char *)v9 >= 14);
      }
      CarrierBundleDevicePersistentCopyValue((uint64_t *)v23, v20, 0);
      sub_100044D6C(__p, (CFTypeRef *)v23);
LABEL_24:
      if (__p != a3)
      {
        *(void *)long long buf = *a3;
        *a3 = __p[0];
        __p[0] = 0;
        sub_100044D00((const void **)buf);
      }
      sub_100044D00((const void **)__p);
      sub_1000577C4((const void **)v23);
      if (*a3) {
        int64_t v13 = sub_100083F10;
      }
      else {
        int64_t v13 = 0;
      }
      if (!v13)
      {
        int64_t v14 = *a2;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          memset(buf, 0, sizeof(buf));
          uint64_t v22 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = *(_OWORD *)buf;
          uint64_t v17 = v22;
          uint64_t v15 = __p;
          if (v22 < 0) {
            uint64_t v15 = *(void ***)buf;
          }
          *(_DWORD *)int v23 = 136446210;
          uint64_t v24 = v15;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#N No content in directory in cache: %{public}s", v23, 0xCu);
          if (SHIBYTE(v17) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      if (SHIBYTE(v19) < 0) {
        operator delete(v18[0]);
      }
    }
    sub_1000558F4((const void **)&v20);
  }
  else
  {
    unint64_t v12 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N Directory provided is NULL, cannot lookup the contents", buf, 2u);
    }
  }
}

void sub_1004D1E50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, const void *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  sub_1000577C4((const void **)(v26 - 80));
  if (a18 < 0) {
    operator delete(a13);
  }
  sub_1000558F4(&a19);
  sub_100044D00(v25);
  _Unwind_Resume(a1);
}

const void **sub_1004D1ECC(const void **a1, os_log_t *a2, const __CFString *a3, void *a4, CFArrayRef *a5)
{
  uint64_t v5 = a1;
  if (*a5) {
    uint64_t v6 = sub_100083F10;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6)
  {
    CFMutableArrayRef theArray = 0;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      CFMutableArrayRef v11 = theArray;
      CFMutableArrayRef theArray = Mutable;
      result.location = (CFIndex)v11;
      sub_1000440D4((const void **)&result);
    }
    if (theArray) {
      unint64_t v12 = sub_100289354;
    }
    else {
      unint64_t v12 = 0;
    }
    if (v12)
    {
      CFIndex Count = CFArrayGetCount(*a5);
      if (Count >= 1)
      {
        CFIndex v14 = 0;
        while (1)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*a5, v14);
          CFStringRef v16 = ValueAtIndex;
          if (!ValueAtIndex || (CFTypeID v17 = CFGetTypeID(ValueAtIndex), v17 != CFStringGetTypeID()))
          {
            int64_t v21 = *a2;
            if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(result.location) = 0;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#N Failed to get CFString format of the directory content", (uint8_t *)&result, 2u);
            }
            goto LABEL_29;
          }
          result.location = 0;
          result.length = 0;
          CFStringRef v27 = 0;
          v31.length = CFStringGetLength(v16);
          v31.location = 0;
          if (!CFStringFindWithOptions(v16, @"_", v31, 1uLL, &result)) {
            break;
          }
          v18.length = result.location;
          if (result.location != -1 && result.length == 1)
          {
            v18.location = 0;
            CFStringRef v19 = CFStringCreateWithSubstring(0, v16, v18);
            CFStringRef v20 = v27;
            CFStringRef v27 = v19;
            CFStringRef v30 = v20;
            sub_1000558F4((const void **)&v30);
LABEL_22:
            CFStringRef v22 = v27;
            if (v27) {
              int v23 = sub_1000810B8;
            }
            else {
              int v23 = 0;
            }
            if (v23)
            {
              v32.length = CFStringGetLength(a3);
              v32.location = 0;
              if (CFStringFindWithOptions(a3, v22, v32, 9uLL, 0))
              {
                CFStringRef v30 = 0;
                CFStringRef v30 = CFStringCreateWithFormat(0, 0, @"%@/%@", *a4, v16);
                xpc_object_t value = 0;
                copyURLForPath((uint64_t *)&value, v30);
                CFArrayAppendValue(theArray, value);
                sub_1000FE824((const void **)&value);
                sub_1000558F4((const void **)&v30);
              }
            }
          }
          sub_1000558F4((const void **)&v27);
LABEL_29:
          if (Count == ++v14) {
            goto LABEL_30;
          }
        }
        CFStringRef v30 = v16;
        sub_100013168((const void **)&v27, (CFTypeRef *)&v30);
        goto LABEL_22;
      }
LABEL_30:
      sub_100044D6C(v5, (CFTypeRef *)&theArray);
    }
    else
    {
      uint64_t v24 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(result.location) = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#N Failed to create array for potential candidates", (uint8_t *)&result, 2u);
      }
      *uint64_t v5 = 0;
    }
    return sub_1000440D4((const void **)&theArray);
  }
  else
  {
    *a1 = 0;
  }
  return a1;
}

void sub_1004D21B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_1000440D4((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1004D2210@<X0>(os_log_t *a1@<X0>, const __CFString *a2@<X2>, const __CFDictionary *a3@<X3>, void *a4@<X8>)
{
  CFMutableArrayRef theArray = 0;
  if (!a2)
  {
    os_log_t v19 = *a1;
    if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_51;
    }
    LOWORD(v33.__r_.__value_.__l.__data_) = 0;
    CFStringRef v20 = "#N Invalid match prefix was received";
    int64_t v21 = v19;
LABEL_50:
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&v33, 2u);
    goto LABEL_51;
  }
  int v7 = *a1;
  BOOL v8 = os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT);
  if (!a3)
  {
    if (!v8) {
      goto LABEL_51;
    }
    LOWORD(v33.__r_.__value_.__l.__data_) = 0;
    CFStringRef v20 = "#N Candidate dictionary is invalid";
    int64_t v21 = v7;
    goto LABEL_50;
  }
  if (v8)
  {
    memset(&v33, 0, sizeof(v33));
    ctu::cf::assign();
    memset(&__p, 0, sizeof(__p));
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = &__p;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Searching for candidates matching prefix: %s", (uint8_t *)&buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v10 = theArray;
  CFMutableArrayRef theArray = Mutable;
  v33.__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
  sub_1000440D4((const void **)&v33.__r_.__value_.__l.__data_);
  CFIndex Count = CFDictionaryGetCount(a3);
  long long buf = 0uLL;
  uint64_t v37 = 0;
  sub_10004EE3C(&buf, Count);
  values = 0;
  int v28 = 0;
  uint64_t v29 = 0;
  sub_10004EE3C(&values, Count);
  CFDictionaryGetKeysAndValues(a3, (const void **)buf, (const void **)values);
  if (Count >= 1)
  {
    uint64_t v12 = 0;
    while (1)
    {
      memset(&__s, 0, sizeof(__s));
      memset(&v33, 0, sizeof(v33));
      ctu::cf::assign();
      std::string __s = v33;
      memset(&__dst, 0, sizeof(__dst));
      if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        break;
      }
      sub_10004FC84(&__dst, __s.__r_.__value_.__l.__data_, __s.__r_.__value_.__l.__size_);
      size_t v13 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
      if ((SHIBYTE(__s.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_11;
      }
      size_t size = __s.__r_.__value_.__l.__size_;
      p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
      if (__s.__r_.__value_.__l.__size_)
      {
LABEL_12:
        CFStringRef v16 = memchr(p_s, 95, size);
        if (v16 && v16 - (unsigned char *)p_s != -1)
        {
          std::string::erase(&__s, v16 - (unsigned char *)p_s, 0xFFFFFFFFFFFFFFFFLL);
          LOBYTE(v13) = *((unsigned char *)&__s.__r_.__value_.__s + 23);
        }
      }
LABEL_15:
      CFStringRef v24 = 0;
      if ((v13 & 0x80) != 0) {
        sub_10004FC84(&v23, __s.__r_.__value_.__l.__data_, __s.__r_.__value_.__l.__size_);
      }
      else {
        std::string v23 = __s;
      }
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__p, v23.__r_.__value_.__l.__data_, v23.__r_.__value_.__l.__size_);
      }
      else {
        std::string __p = v23;
      }
      CFStringRef v31 = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v33, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      }
      else {
        std::string v33 = __p;
      }
      CFStringRef v34 = 0;
      if (ctu::cf::convert_copy())
      {
        CFStringRef v17 = v31;
        CFStringRef v31 = v34;
        CFStringRef v35 = v17;
        sub_1000558F4((const void **)&v35);
      }
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v33.__r_.__value_.__l.__data_);
      }
      CFStringRef v24 = v31;
      CFStringRef v31 = 0;
      sub_1000558F4((const void **)&v31);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v23.__r_.__value_.__l.__data_);
      }
      CFStringRef v18 = v24;
      v38.length = CFStringGetLength(a2);
      v38.location = 0;
      if (CFStringFindWithOptions(a2, v18, v38, 9uLL, 0)) {
        CFArrayAppendValue(theArray, *(const void **)(buf + 8 * v12));
      }
      sub_1000558F4((const void **)&v24);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__s.__r_.__value_.__l.__data_);
      }
      if (Count == ++v12) {
        goto LABEL_42;
      }
    }
    size_t v13 = HIBYTE(v33.__r_.__value_.__r.__words[2]);
    std::string __dst = __s;
LABEL_11:
    p_s = &__s;
    size_t size = v13;
    if (v13) {
      goto LABEL_12;
    }
    goto LABEL_15;
  }
LABEL_42:
  if (values)
  {
    int v28 = values;
    operator delete(values);
  }
  if ((void)buf)
  {
    *((void *)&buf + 1) = buf;
    operator delete((void *)buf);
  }
LABEL_51:
  sub_100044D6C(a4, (CFTypeRef *)&theArray);
  return sub_1000440D4((const void **)&theArray);
}

void sub_1004D265C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *__p,uint64_t a30,uint64_t a31,const void *a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (*(char *)(v41 - 121) < 0) {
    operator delete(*(void **)(v41 - 144));
  }
  sub_1000440D4(&a32);
  _Unwind_Resume(a1);
}

uint64_t sub_1004D276C(os_log_t *a1, Registry **a2, const void **a3)
{
  memset(&v77, 0, sizeof(v77));
  sub_100119B5C(&v76, a3);
  copyURLAsString();
  memset(&buf, 0, sizeof(buf));
  ctu::cf::assign();
  std::string v77 = buf;
  sub_1000558F4((const void **)&__dst.__r_.__value_.__l.__data_);
  sub_1000FE824(&v76);
  if ((v77.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t size = HIBYTE(v77.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t size = v77.__r_.__value_.__l.__size_;
  }
  v74[1] = 0;
  uint64_t v75 = 0;
  v74[0] = 0;
  uint64_t v6 = v74;
  sub_1000C140C((uint64_t)v74, size + 24);
  if (v75 < 0) {
    uint64_t v6 = (void **)v74[0];
  }
  if (size)
  {
    if ((v77.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v7 = &v77;
    }
    else {
      int v7 = (std::string *)v77.__r_.__value_.__r.__words[0];
    }
    memmove(v6, v7, size);
  }
  strcpy((char *)v6 + size, "/supported_devices.plist");
  uint64_t v72 = 0;
  char v73 = 0;
  Registry::getFileSystemInterface(&v72, *a2);
  if (((*(uint64_t (**)(uint64_t, void **))(*(void *)v72 + 88))(v72, v74) & 1) == 0)
  {
    uint64_t v13 = 1;
    goto LABEL_130;
  }
  CFDictionaryRef theDict = 0;
  sub_1007B946C(a1, a2, (const UInt8 *)v74, (const void **)&theDict);
  if (theDict) {
    BOOL v8 = sub_100080778;
  }
  else {
    BOOL v8 = 0;
  }
  if (!v8)
  {
    CFIndex v14 = *a1;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#E Failed to load the plist as a dictionary", (uint8_t *)&buf, 2u);
    }
    goto LABEL_63;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"SupportedSIMOverrides");
  CFDictionaryRef v10 = Value;
  if (Value)
  {
    CFTypeID v11 = CFGetTypeID(Value);
    if (v11 == CFDictionaryGetTypeID()) {
      CFDictionaryRef v12 = v10;
    }
    else {
      CFDictionaryRef v12 = 0;
    }
  }
  else
  {
    CFDictionaryRef v12 = 0;
  }
  uint64_t v15 = CFDictionaryGetValue(theDict, @"SupportedDevices");
  uint64_t v16 = (uint64_t)v15;
  if (v15)
  {
    CFTypeID v17 = CFGetTypeID(v15);
    if (v17 == CFArrayGetTypeID()) {
      uint64_t v13 = v16;
    }
    else {
      uint64_t v13 = 0;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  CFArrayRef TypeID = (const __CFArray *)CFDictionaryGetValue(theDict, @"SupportedDevicesExactMatch");
  CFArrayRef v19 = TypeID;
  if (TypeID)
  {
    CFTypeID v20 = CFGetTypeID(TypeID);
    CFArrayRef TypeID = (const __CFArray *)CFArrayGetTypeID();
    if ((const __CFArray *)v20 != TypeID) {
      CFArrayRef v19 = 0;
    }
  }
  if (v12)
  {
    memset(&__str, 0, sizeof(__str));
    LOBYTE(v21) = *((unsigned char *)&v77.__r_.__value_.__s + 23);
    if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(&__str, v77.__r_.__value_.__l.__data_, v77.__r_.__value_.__l.__size_);
      LOBYTE(v21) = *((unsigned char *)&v77.__r_.__value_.__s + 23);
      std::string::size_type v69 = 0;
      if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::size_type v21 = v77.__r_.__value_.__l.__size_;
        CFStringRef v22 = (std::string *)v77.__r_.__value_.__r.__words[0];
LABEL_37:
        std::string v23 = (char *)&v22[-1].__r_.__value_.__r.__words[2] + 7;
        do
        {
          if (!v21) {
            goto LABEL_46;
          }
          int v24 = v23[v21--];
        }
        while (v24 != 47);
        if (v21 == -1) {
          goto LABEL_46;
        }
        std::string::size_type v25 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v25 = __str.__r_.__value_.__l.__size_;
        }
        if (v21 >= v25)
        {
LABEL_46:
          uint64_t v26 = 0;
          goto LABEL_47;
        }
        std::string::basic_string(&v67, &__str, v21 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&buf);
        if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, v67.__r_.__value_.__l.__data_, v67.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = v67;
        }
        CFStringRef theString = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          std::string buf = __dst;
        }
        CFStringRef v81 = 0;
        if (ctu::cf::convert_copy())
        {
          CFStringRef v64 = theString;
          CFStringRef theString = v81;
          CFStringRef v82 = v64;
          sub_1000558F4((const void **)&v82);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        CFStringRef v68 = theString;
        CFStringRef theString = 0;
        sub_1000558F4((const void **)&theString);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        buf.__r_.__value_.__r.__words[0] = v69;
        CFStringRef v65 = v68;
        CFStringRef v68 = 0;
        std::string::size_type v69 = (std::string::size_type)v65;
        sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
        sub_1000558F4((const void **)&v68);
        if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v67.__r_.__value_.__l.__data_);
        }
        uint64_t v26 = (const void *)v69;
LABEL_47:
        CFDictionaryRef v27 = (const __CFDictionary *)CFDictionaryGetValue(v12, v26);
        CFDictionaryRef v28 = v27;
        if (v27)
        {
          CFTypeID v29 = CFGetTypeID(v27);
          if (v29 == CFDictionaryGetTypeID())
          {
            CFStringRef v30 = CFDictionaryGetValue(v28, @"SupportedDevices");
            CFStringRef v31 = v30;
            if (v30)
            {
              CFTypeID v32 = CFGetTypeID(v30);
              uint64_t v13 = v32 == CFArrayGetTypeID() ? (uint64_t)v31 : 0;
            }
            else
            {
              uint64_t v13 = 0;
            }
            CFArrayRef v33 = (const __CFArray *)CFDictionaryGetValue(v28, @"SupportedDevicesExactMatch");
            CFArrayRef v19 = v33;
            if (v33)
            {
              CFTypeID v34 = CFGetTypeID(v33);
              if (v34 != CFArrayGetTypeID()) {
                CFArrayRef v19 = 0;
              }
            }
          }
        }
        CFArrayRef TypeID = (const __CFArray *)sub_1000558F4((const void **)&v69);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        goto LABEL_60;
      }
    }
    else
    {
      std::string __str = v77;
      std::string::size_type v69 = 0;
    }
    std::string::size_type v21 = v21;
    CFStringRef v22 = &v77;
    goto LABEL_37;
  }
LABEL_60:
  if (!(v13 | (unint64_t)v19))
  {
LABEL_63:
    uint64_t v13 = 1;
    goto LABEL_129;
  }
  CFStringRef theString = 0;
  capabilities::ct::compatibleHardwareConfigurationString((uint64_t *)&__p, TypeID);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__dst, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else {
    std::string __dst = __p;
  }
  CFStringRef v81 = 0;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    std::string buf = __dst;
  }
  CFStringRef v82 = 0;
  if (ctu::cf::convert_copy())
  {
    CFStringRef v35 = v81;
    CFStringRef v81 = v82;
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v35;
    sub_1000558F4((const void **)&__str.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  CFStringRef theString = v81;
  CFStringRef v81 = 0;
  sub_1000558F4((const void **)&v81);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (!v13)
    {
LABEL_76:
      if (!v19) {
        goto LABEL_128;
      }
      goto LABEL_89;
    }
  }
  else if (!v13)
  {
    goto LABEL_76;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)v13);
  if (Count < 1)
  {
LABEL_88:
    uint64_t v13 = 0;
    if (!v19) {
      goto LABEL_128;
    }
    goto LABEL_89;
  }
  CFIndex v37 = 0;
  while (1)
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v13, v37);
    CFStringRef v39 = ValueAtIndex;
    if (!ValueAtIndex || (CFTypeID v40 = CFGetTypeID(ValueAtIndex), v40 != CFStringGetTypeID()))
    {
      uint64_t v42 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Found non-string value in the array", (uint8_t *)&buf, 2u);
      }
      goto LABEL_87;
    }
    CFStringRef v41 = theString;
    v83.length = CFStringGetLength(theString);
    v83.location = 0;
    if (CFStringFindWithOptions(v41, v39, v83, 9uLL, 0)) {
      break;
    }
LABEL_87:
    if (Count == ++v37) {
      goto LABEL_88;
    }
  }
  uint64_t v13 = 1;
  if (v19)
  {
LABEL_89:
    CFIndex v43 = CFArrayGetCount(v19);
    if (v43 < 1) {
      goto LABEL_128;
    }
    for (CFIndex i = 0; i != v43; ++i)
    {
      __str.__r_.__value_.__r.__words[0] = 0;
      uint64_t v45 = CFArrayGetValueAtIndex(v19, i);
      std::string::size_type v46 = (std::string::size_type)v45;
      if (!v45 || (CFTypeID v47 = CFGetTypeID(v45), v47 != CFStringGetTypeID()))
      {
        uint64_t v62 = *a1;
        if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I Found non-string value in the array", (uint8_t *)&buf, 2u);
        }
        continue;
      }
      __str.__r_.__value_.__r.__words[0] = v46;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)theString;
      sub_1000292E0((uint64_t)&buf);
      sub_1000292E0((uint64_t)&__dst);
      char v48 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v49 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v49 = buf.__r_.__value_.__l.__size_;
      }
      std::string::size_type v50 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      int v51 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v50 = __dst.__r_.__value_.__l.__size_;
      }
      if (v49 == v50)
      {
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_dst = &__dst;
        }
        else {
          p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        if ((*((unsigned char *)&buf.__r_.__value_.__s + 23) & 0x80) != 0)
        {
          BOOL v61 = memcmp(buf.__r_.__value_.__l.__data_, p_dst, buf.__r_.__value_.__l.__size_) == 0;
          if ((v51 & 0x80000000) == 0) {
            goto LABEL_111;
          }
        }
        else if (*((unsigned char *)&buf.__r_.__value_.__s + 23))
        {
          uint64_t v53 = HIBYTE(buf.__r_.__value_.__r.__words[2]) - 1;
          p_std::string buf = &buf;
          do
          {
            int v56 = p_buf->__r_.__value_.__s.__data_[0];
            p_std::string buf = (std::string *)((char *)p_buf + 1);
            int v55 = v56;
            int v58 = p_dst->__r_.__value_.__s.__data_[0];
            p_dst = (std::string *)((char *)p_dst + 1);
            int v57 = v58;
            BOOL v60 = v53-- != 0;
            BOOL v61 = v55 == v57;
          }
          while (v55 == v57 && v60);
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_111:
            if ((v48 & 0x80) == 0) {
              goto LABEL_112;
            }
            goto LABEL_118;
          }
        }
        else
        {
          BOOL v61 = 1;
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_111;
          }
        }
      }
      else
      {
        BOOL v61 = 0;
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_111;
        }
      }
      operator delete(__dst.__r_.__value_.__l.__data_);
      if ((v48 & 0x80) == 0)
      {
LABEL_112:
        if (v61) {
          goto LABEL_127;
        }
        continue;
      }
LABEL_118:
      operator delete(buf.__r_.__value_.__l.__data_);
      if (v61)
      {
LABEL_127:
        uint64_t v13 = 1;
        break;
      }
    }
  }
LABEL_128:
  sub_1000558F4((const void **)&theString);
LABEL_129:
  sub_100057D78((const void **)&theDict);
LABEL_130:
  if (v73) {
    sub_10004D2C8(v73);
  }
  if (SHIBYTE(v75) < 0) {
    operator delete(v74[0]);
  }
  if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v77.__r_.__value_.__l.__data_);
  }
  return v13;
}

void sub_1004D2FE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,const void *a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,const void *a29,uint64_t a30,std::__shared_weak_count *a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,const void *a45)
{
  sub_1000558F4(&a45);
  if (*(char *)(v45 - 137) < 0) {
    operator delete(*(void **)(v45 - 160));
  }
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a22);
  if (a28 < 0) {
    operator delete(a23);
  }
  sub_100057D78(&a29);
  if (a31) {
    sub_10004D2C8(a31);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  _Unwind_Resume(a1);
}

BOOL sub_1004D3178(os_log_t *a1, int a2, CFDictionaryRef theDict)
{
  if (!theDict) {
    return 1;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"SupportedDevices");
  if (Value)
  {
    CFArrayRef v6 = Value;
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFArrayGetTypeID()) {
      CFArrayRef v8 = v6;
    }
    else {
      CFArrayRef v8 = 0;
    }
  }
  else
  {
    CFArrayRef v8 = 0;
  }
  CFArrayRef TypeID = (const __CFArray *)CFDictionaryGetValue(theDict, @"SupportedDevicesExactMatch");
  if (TypeID)
  {
    CFArrayRef v11 = TypeID;
    CFTypeID v12 = CFGetTypeID(TypeID);
    CFArrayRef TypeID = (const __CFArray *)CFArrayGetTypeID();
    if ((const __CFArray *)v12 == TypeID)
    {
      BOOL v9 = v8 != 0;
      int v13 = 1;
      goto LABEL_13;
    }
  }
  BOOL v9 = 1;
  if (v8)
  {
    int v13 = 0;
    CFArrayRef v11 = 0;
LABEL_13:
    capabilities::ct::compatibleHardwareConfigurationString((uint64_t *)v43, TypeID);
    if (SHIBYTE(v44) < 0)
    {
      sub_10004FC84(__dst, v43[0], (unint64_t)v43[1]);
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)v43;
      uint64_t v48 = v44;
    }
    CFStringRef v46 = 0;
    if (SHIBYTE(v48) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)__dst;
      uint64_t v50 = v48;
    }
    CFStringRef v51 = 0;
    if (ctu::cf::convert_copy())
    {
      CFStringRef v14 = v46;
      CFStringRef v46 = v51;
      CFStringRef v52 = v14;
      sub_1000558F4((const void **)&v52);
    }
    if (SHIBYTE(v50) < 0) {
      operator delete(__p[0]);
    }
    CFStringRef theString = v46;
    CFStringRef v46 = 0;
    sub_1000558F4((const void **)&v46);
    if (SHIBYTE(v48) < 0) {
      operator delete(__dst[0]);
    }
    if (SHIBYTE(v44) < 0)
    {
      operator delete(v43[0]);
      if (!v9) {
        goto LABEL_39;
      }
    }
    else if (!v9)
    {
      goto LABEL_39;
    }
    CFIndex Count = CFArrayGetCount(v8);
    if (Count >= 1)
    {
      for (CFIndex i = 0; Count != i; ++i)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v8, i);
        CFStringRef v18 = ValueAtIndex;
        if (ValueAtIndex && (CFTypeID v19 = CFGetTypeID(ValueAtIndex), v19 == CFStringGetTypeID()))
        {
          CFStringRef v20 = theString;
          v53.length = CFStringGetLength(theString);
          v53.location = 0;
          if (CFStringFindWithOptions(v20, v18, v53, 9uLL, 0))
          {
            BOOL v9 = 1;
            if (!v13)
            {
LABEL_79:
              sub_1000558F4((const void **)&theString);
              return v9;
            }
LABEL_40:
            CFIndex v22 = CFArrayGetCount(v11);
            if (v22 < 1) {
              goto LABEL_79;
            }
            CFIndex v23 = 0;
            while (2)
            {
              CFStringRef v24 = (const __CFString *)CFArrayGetValueAtIndex(v11, v23);
              CFStringRef v25 = v24;
              if (!v24 || (CFTypeID v26 = CFGetTypeID(v24), v26 != CFStringGetTypeID()))
              {
                CFStringRef v41 = *a1;
                if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(__p[0]) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I Found non-string value in the array", (uint8_t *)__p, 2u);
                }
LABEL_74:
                if (++v23 == v22) {
                  goto LABEL_79;
                }
                continue;
              }
              break;
            }
            CFStringRef v52 = v25;
            __dst[0] = (void *)theString;
            sub_1000292E0((uint64_t)__p);
            sub_1000292E0((uint64_t)__dst);
            char v27 = HIBYTE(v50);
            if (v50 >= 0) {
              CFDictionaryRef v28 = (void *)HIBYTE(v50);
            }
            else {
              CFDictionaryRef v28 = __p[1];
            }
            CFTypeID v29 = (void *)HIBYTE(v48);
            int v30 = SHIBYTE(v48);
            if (v48 < 0) {
              CFTypeID v29 = __dst[1];
            }
            if (v28 == v29)
            {
              if (v48 >= 0) {
                CFStringRef v31 = __dst;
              }
              else {
                CFStringRef v31 = (void **)__dst[0];
              }
              if (v50 < 0)
              {
                BOOL v40 = memcmp(__p[0], v31, (size_t)__p[1]) == 0;
                goto LABEL_67;
              }
              if (HIBYTE(v50))
              {
                uint64_t v32 = HIBYTE(v50) - 1;
                CFArrayRef v33 = __p;
                do
                {
                  int v35 = *(unsigned __int8 *)v33;
                  CFArrayRef v33 = (void **)((char *)v33 + 1);
                  int v34 = v35;
                  int v37 = *(unsigned __int8 *)v31;
                  CFStringRef v31 = (void **)((char *)v31 + 1);
                  int v36 = v37;
                  BOOL v39 = v32-- != 0;
                  BOOL v40 = v34 == v36;
                }
                while (v34 == v36 && v39);
LABEL_67:
                if ((v30 & 0x80000000) == 0)
                {
LABEL_68:
                  if ((v27 & 0x80) == 0)
                  {
LABEL_69:
                    if (v40) {
                      goto LABEL_78;
                    }
                    goto LABEL_74;
                  }
LABEL_73:
                  operator delete(__p[0]);
                  if (v40)
                  {
LABEL_78:
                    BOOL v9 = 1;
                    goto LABEL_79;
                  }
                  goto LABEL_74;
                }
              }
              else
              {
                BOOL v40 = 1;
                if ((SHIBYTE(v48) & 0x80000000) == 0) {
                  goto LABEL_68;
                }
              }
            }
            else
            {
              BOOL v40 = 0;
              if ((SHIBYTE(v48) & 0x80000000) == 0) {
                goto LABEL_68;
              }
            }
            operator delete(__dst[0]);
            if ((v27 & 0x80) == 0) {
              goto LABEL_69;
            }
            goto LABEL_73;
          }
        }
        else
        {
          std::string::size_type v21 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Found non-string value in the array", (uint8_t *)__p, 2u);
          }
        }
      }
    }
    BOOL v9 = 0;
LABEL_39:
    if (!v13) {
      goto LABEL_79;
    }
    goto LABEL_40;
  }
  return v9;
}

void sub_1004D35A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, int a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

BOOL sub_1004D362C(Registry **a1, const __CFURL *a2)
{
  BOOL v2 = 0;
  if (!a2) {
    return v2;
  }
  uint64_t v3 = *a1;
  if (!v3) {
    return v2;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3);
  CFArrayRef v6 = ServiceMap;
  if (v7 < 0)
  {
    CFArrayRef v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v7;
  CFArrayRef v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)__p);
  if (!v11)
  {
    uint64_t v13 = 0;
    goto LABEL_10;
  }
  uint64_t v13 = v11[3];
  CFTypeID v12 = (std::__shared_weak_count *)v11[4];
  if (!v12)
  {
LABEL_10:
    std::mutex::unlock(v6);
    CFTypeID v12 = 0;
    char v14 = 1;
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
LABEL_11:
  CFStringRef v24 = 0;
  uint64_t v15 = (const void *)(*(uint64_t (**)(uint64_t, const __CFURL *))(*(void *)v13 + 48))(v13, a2);
  CFIndex v23 = 0;
  CFStringRef v24 = v15;
  asString(a2, (uint64_t)__p);
  if (v22 >= 0) {
    uint64_t v16 = __p;
  }
  else {
    uint64_t v16 = (void **)__p[0];
  }
  CFTypeID v17 = (const void *)(*(uint64_t (**)(uint64_t, void **))(*(void *)v13 + 24))(v13, v16);
  CFIndex v23 = v17;
  if (v22 < 0) {
    operator delete(__p[0]);
  }
  if (v24) {
    CFStringRef v18 = sub_1000810B8;
  }
  else {
    CFStringRef v18 = 0;
  }
  if (v18)
  {
    if (v17) {
      CFTypeID v19 = sub_1000810B8;
    }
    else {
      CFTypeID v19 = 0;
    }
    BOOL v2 = v19 != 0;
  }
  else
  {
    BOOL v2 = 0;
  }
  sub_1000558F4(&v23);
  sub_1000558F4(&v24);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  return v2;
}

void sub_1004D3804(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, const void *a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a17);
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  _Unwind_Resume(a1);
}

void sub_1004D383C()
{
  if (v0) {
    JUMPOUT(0x1004D3834);
  }
  JUMPOUT(0x1004D382CLL);
}

const void **sub_1004D384C@<X0>(const __CFDictionary *a1@<X0>, const void **a2@<X8>)
{
  *a2 = 0;
  CFArrayRef Value = CFDictionaryGetValue(a1, (const void *)qword_101B13ED0);
  uint64_t v5 = Value;
  if (Value)
  {
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFStringGetTypeID()) {
      uint64_t v7 = v5;
    }
    else {
      uint64_t v7 = 0;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  CFArrayRef v8 = CFDictionaryGetValue(a1, @"HomeBundleIdentifier");
  uint64_t v9 = v8;
  if (v8)
  {
    CFTypeID v10 = CFGetTypeID(v8);
    if (v10 == CFStringGetTypeID()) {
      CFArrayRef v11 = v9;
    }
    else {
      CFArrayRef v11 = 0;
    }
    if (!v7)
    {
      if (v11)
      {
        uint64_t v15 = v11;
        return sub_100013168(a2, &v15);
      }
      goto LABEL_15;
    }
LABEL_14:
    uint64_t v15 = v7;
    return sub_100013168(a2, &v15);
  }
  if (v7) {
    goto LABEL_14;
  }
LABEL_15:
  CFTypeRef v14 = CFDictionaryGetValue(a1, (const void *)qword_101B13EC0);
  uint64_t v15 = 0;
  sub_100056248(&v15, &v14);
  uint64_t v13 = *a2;
  *a2 = v15;
  uint64_t v15 = v13;
  return sub_1000558F4(&v15);
}

void sub_1004D395C(_Unwind_Exception *a1)
{
  sub_1000558F4(v1);
  _Unwind_Resume(a1);
}

CFDictionaryRef *sub_1004D3980@<X0>(CFDictionaryRef *result@<X0>, const __CFDictionary **a2@<X8>)
{
  BOOL v2 = result;
  CFDictionaryRef v4 = *result;
  if (*result) {
    uint64_t v5 = sub_100080778;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v5
    || (CFTypeID v6 = (const void *)qword_101B13EC0,
        CFRange result = (CFDictionaryRef *)CFDictionaryContainsKey(*result, (const void *)qword_101B13EC0),
        CFDictionaryRef v4 = *v2,
        !result))
  {
    *a2 = v4;
    CFDictionaryRef *v2 = 0;
    return result;
  }
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v4);
  CFArrayRef Value = CFDictionaryGetValue(*v2, v6);
  CFArrayRef v8 = Value;
  if (Value)
  {
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == CFStringGetTypeID())
    {
      char v22 = v8;
      sub_1000292E0((uint64_t)&__dst);
      sub_1000292E0((uint64_t)&__p);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      CFTypeID v12 = std::string::append(&__dst, (const std::string::value_type *)p_p, size);
      uint64_t v13 = (void *)v12->__r_.__value_.__r.__words[0];
      unint64_t v14 = v12->__r_.__value_.__l.__size_;
      v21[0] = v12->__r_.__value_.__r.__words[2];
      *(_DWORD *)((char *)v21 + 3) = *(_DWORD *)((char *)&v12->__r_.__value_.__r.__words[2] + 3);
      int v15 = SHIBYTE(v12->__r_.__value_.__r.__words[2]);
      v12->__r_.__value_.__l.__size_ = 0;
      v12->__r_.__value_.__r.__words[2] = 0;
      v12->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      uint64_t v16 = MutableCopy;
      if (v15 < 0)
      {
        sub_10004FC84(&v19, v13, v14);
        if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
        {
          sub_10004FC84(&__p, v19.__r_.__value_.__l.__data_, v19.__r_.__value_.__l.__size_);
          goto LABEL_23;
        }
      }
      else
      {
        v19.__r_.__value_.__r.__words[0] = (std::string::size_type)v13;
        v19.__r_.__value_.__l.__size_ = v14;
        LODWORD(v19.__r_.__value_.__r.__words[2]) = v21[0];
        *(_DWORD *)((char *)&v19.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v21 + 3);
        *((unsigned char *)&v19.__r_.__value_.__s + 23) = v15;
      }
      std::string __p = v19;
LABEL_23:
      CFStringRef v24 = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__dst, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = __p;
      }
      char v27 = 0;
      if (ctu::cf::convert_copy())
      {
        CFTypeID v17 = v24;
        CFStringRef v24 = v27;
        CFDictionaryRef v28 = v17;
        sub_1000558F4(&v28);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      char v18 = v24;
      CFStringRef v20 = v24;
      CFStringRef v24 = 0;
      sub_1000558F4(&v24);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      CFDictionarySetValue(v16, v6, v18);
      sub_1000558F4(&v20);
      if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v19.__r_.__value_.__l.__data_);
      }
      sub_10004EFE4(&__p, (CFTypeRef *)&MutableCopy);
      if (&__p != (std::string *)v2)
      {
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)*v2;
        CFDictionaryRef *v2 = (CFDictionaryRef)__p.__r_.__value_.__r.__words[0];
        __p.__r_.__value_.__r.__words[0] = 0;
        sub_100057D78((const void **)&__dst.__r_.__value_.__l.__data_);
      }
      sub_100057D78((const void **)&__p.__r_.__value_.__l.__data_);
      if (v15 < 0) {
        operator delete(v13);
      }
    }
  }
  sub_10004EFE4(a2, (CFTypeRef *)&MutableCopy);
  return (CFDictionaryRef *)sub_10005717C((const void **)&MutableCopy);
}

void sub_1004D3C50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, const void *a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (v35 < 0) {
    operator delete(v34);
  }
  sub_10005717C(&a18);
  _Unwind_Resume(a1);
}

void sub_1004D3D0C(os_log_t *a1@<X0>, Registry **a2@<X1>, const void **a3@<X2>, long long *a4@<X3>, unsigned char *a5@<X8>)
{
  v72[0] = 0;
  v72[1] = 0;
  uint64_t v73 = 0;
  xpc_object_t v70 = 0;
  key = 0;
  std::string::size_type v69 = 0;
  if (*a3) {
    uint64_t v5 = sub_100080778;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v5)
  {
    CFTypeID v10 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Cannot find GSMA configuration because of empty matching info.", buf, 2u);
    }
    sub_1004D4B6C(a5, (long long *)v72, (const void **)&key, &v70);
    goto LABEL_103;
  }
  sub_100058198((const void **)&theDict, a3);
  *(void *)CFTypeID v76 = 0;
  *(void *)std::string buf = CFDictionaryGetValue(theDict, @"MCC");
  sub_100056248(v76, (CFTypeRef *)buf);
  CFStringRef v7 = *(const __CFString **)v76;
  if (*(void *)v76) {
    CFArrayRef v8 = sub_1000810B8;
  }
  else {
    CFArrayRef v8 = 0;
  }
  if (v8) {
    goto LABEL_9;
  }
  str[0] = 0;
  *(void *)std::string buf = CFDictionaryGetValue(theDict, (const void *)qword_101B13EC0);
  sub_100056248(str, (CFTypeRef *)buf);
  if (str[0]) {
    CFArrayRef v11 = sub_1000810B8;
  }
  else {
    CFArrayRef v11 = 0;
  }
  if (v11)
  {
    v78.location = 0;
    v78.length = 3;
    CFStringRef v12 = CFStringCreateWithSubstring(kCFAllocatorDefault, str[0], v78);
    uint64_t v13 = *(void *)v76;
    *(void *)CFTypeID v76 = v12;
    *(void *)std::string buf = v13;
    sub_1000558F4((const void **)buf);
    if (*(void *)v76) {
      unint64_t v14 = sub_1000810B8;
    }
    else {
      unint64_t v14 = 0;
    }
    sub_1000558F4((const void **)str);
    if (v14)
    {
      CFStringRef v7 = *(const __CFString **)v76;
LABEL_9:
      IntCFArrayRef Value = (unsigned __int16)CFStringGetIntValue(v7);
      goto LABEL_24;
    }
  }
  else
  {
    sub_1000558F4((const void **)str);
  }
  IntCFArrayRef Value = 0;
LABEL_24:
  sub_1000558F4((const void **)v76);
  sub_100057D78((const void **)&theDict);
  int v15 = *a1;
  uint64_t v16 = *a1;
  if (IntValue)
  {
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = IntValue;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Finding sim look up file for mcc %03d", buf, 8u);
    }
    str[0] = 0;
    str[1] = 0;
    uint64_t v67 = 0;
    if (*((char *)a4 + 23) < 0)
    {
      sub_10004FC84(str, *(void **)a4, *((void *)a4 + 1));
    }
    else
    {
      *(_OWORD *)str = *a4;
      uint64_t v67 = *((void *)a4 + 2);
    }
    ctu::path_join_impl();
    CFDictionaryRef v65 = 0;
    sub_1007B946C(a1, a2, (const UInt8 *)str, (const void **)&v65);
    if (v65) {
      CFTypeID v17 = sub_100080778;
    }
    else {
      CFTypeID v17 = 0;
    }
    if (v17)
    {
      CFDictionaryGetValue(v65, @"DefaultFile");
      memset(buf, 0, 24);
      ctu::cf::assign();
      *(_OWORD *)std::string __p = *(_OWORD *)buf;
      *(void *)&__p[16] = *(void *)&buf[16];
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v65, @"MappingTable");
      CFArrayRef v19 = Value;
      if (Value)
      {
        CFTypeID v20 = CFGetTypeID(Value);
        if (v20 == CFArrayGetTypeID()) {
          CFArrayRef v21 = v19;
        }
        else {
          CFArrayRef v21 = 0;
        }
      }
      else
      {
        CFArrayRef v21 = 0;
      }
      CFIndex Count = CFArrayGetCount(v21);
      if (Count >= 1)
      {
        CFIndex v24 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v21, v24);
          CFDictionaryRef v26 = ValueAtIndex;
          if (ValueAtIndex)
          {
            CFTypeID v27 = CFGetTypeID(ValueAtIndex);
            if (v27 != CFDictionaryGetTypeID()) {
              CFDictionaryRef v26 = 0;
            }
          }
          CFDictionaryRef v28 = (int *)CFDictionaryGetValue(v26, @"StartMCC");
          CFTypeID v29 = v28;
          *(_DWORD *)std::string buf = 0;
          if (v28)
          {
            CFTypeID v30 = CFGetTypeID(v28);
            if (v30 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)buf, v29, v31);
            }
          }
          int v32 = *(_DWORD *)buf;
          CFArrayRef v33 = (int *)CFDictionaryGetValue(v26, @"EndMCC");
          int v34 = v33;
          *(_DWORD *)std::string buf = 0;
          if (v33)
          {
            CFTypeID v35 = CFGetTypeID(v33);
            if (v35 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)buf, v34, v36);
            }
          }
          if (v32 <= IntValue && *(int *)buf >= IntValue) {
            break;
          }
          if (Count == ++v24) {
            goto LABEL_63;
          }
        }
        CFDictionaryGetValue(v26, @"RegionFile");
        memset(buf, 0, 24);
        ctu::cf::assign();
        uint64_t v37 = *(void *)buf;
        *(void *)CFTypeID v76 = *(void *)&buf[8];
        *(void *)&v76[7] = *(void *)&buf[15];
        uint8_t v38 = buf[23];
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
        *(void *)std::string __p = v37;
        *(void *)&__p[8] = *(void *)v76;
        *(void *)&__p[15] = *(void *)&v76[7];
        __p[23] = v38;
      }
LABEL_63:
      if (__p[23] >= 0) {
        uint64_t v39 = __p[23];
      }
      else {
        uint64_t v39 = *(void *)&__p[8];
      }
      if (v39)
      {
        __dst[0] = 0;
        __dst[1] = 0;
        uint64_t v63 = 0;
        if (*((char *)a4 + 23) < 0)
        {
          sub_10004FC84(__dst, *(void **)a4, *((void *)a4 + 1));
        }
        else
        {
          *(_OWORD *)std::string __dst = *a4;
          uint64_t v63 = *((void *)a4 + 2);
        }
        ctu::path_join_impl();
        CFDictionaryRef v61 = 0;
        sub_1007B946C(a1, a2, (const UInt8 *)__dst, (const void **)&v61);
        if (v61) {
          CFStringRef v41 = sub_100080778;
        }
        else {
          CFStringRef v41 = 0;
        }
        if (v41)
        {
          CFDictionaryRef v60 = 0;
          *(void *)std::string buf = CFDictionaryGetValue(v61, @"MappingTable");
          sub_10004EFE4(&v60, (CFTypeRef *)buf);
          CFStringRef v59 = 0;
          sub_1004D384C((const __CFDictionary *)*a3, (const void **)&v59);
          long long v75 = 0u;
          memset(buf, 0, sizeof(buf));
          sub_1004D4824((CFDictionaryRef)*a3, (const void **)a1, a2, v59, v60, 1, buf);
          if (*(void *)&buf[40]) {
            uint64_t v42 = sub_1000810B8;
          }
          else {
            uint64_t v42 = 0;
          }
          if (v42)
          {
            sub_100083EB8((const void **)&key, (const void **)&buf[40]);
            *(void *)&long long v57 = CFDictionaryGetValue(v60, key);
            *(void *)CFTypeID v76 = 0;
            CFIndex v43 = (const void **)sub_100056248(v76, (CFTypeRef *)&v57);
            uint64_t v44 = v70;
            xpc_object_t v70 = *(const void **)v76;
            *(void *)CFTypeID v76 = v44;
            sub_1000558F4(v43);
            CFDictionaryGetValue(v61, @"GSMAFile");
            memset(v76, 0, sizeof(v76));
            uint64_t v77 = 0;
            ctu::cf::assign();
            int v55 = *(void **)v76;
            char v56 = HIBYTE(v77);
            int v45 = *((char *)a4 + 23);
            uint64_t v58 = 0;
            long long v57 = 0uLL;
            if (v45 < 0)
            {
              sub_10004FC84(&v57, *(void **)a4, *((void *)a4 + 1));
            }
            else
            {
              long long v57 = *a4;
              uint64_t v58 = *((void *)a4 + 2);
            }
            ctu::path_join_impl();
            if (SHIBYTE(v73) < 0) {
              operator delete(v72[0]);
            }
            *(_OWORD *)uint64_t v72 = v57;
            uint64_t v73 = v58;
            HIBYTE(v58) = 0;
            LOBYTE(v57) = 0;
            if (v56 < 0) {
              operator delete(v55);
            }
          }
          else
          {
            CFTypeID v47 = *a1;
            if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
            {
              uint64_t v48 = *a3;
              *(_DWORD *)CFTypeID v76 = 138412290;
              *(void *)&v76[4] = v48;
              _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "No match found for %@.", v76, 0xCu);
            }
          }
          sub_1004D4B6C(a5, (long long *)v72, (const void **)&key, &v70);
          if (*((void *)&v75 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v75 + 1));
          }
          sub_1000558F4((const void **)&buf[40]);
          if (*(void *)&buf[32]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[32]);
          }
          sub_1000558F4((const void **)buf);
          sub_1000558F4((const void **)&v59);
          sub_100057D78((const void **)&v60);
        }
        else
        {
          CFStringRef v46 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
          {
            uint64_t v50 = __p;
            if (__p[23] < 0) {
              uint64_t v50 = *(unsigned char **)__p;
            }
            *(_DWORD *)std::string buf = 136446210;
            *(void *)&uint8_t buf[4] = v50;
            _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Failed to load %{public}s.", buf, 0xCu);
          }
          sub_1004D4B6C(a5, (long long *)v72, (const void **)&key, &v70);
        }
        sub_100057D78((const void **)&v61);
        if (SHIBYTE(v63) < 0) {
          operator delete(__dst[0]);
        }
      }
      else
      {
        BOOL v40 = *a1;
        if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Sim look up file not found in GSMA bundle.", buf, 2u);
        }
        sub_1004D4B6C(a5, (long long *)v72, (const void **)&key, &v70);
      }
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
    }
    else
    {
      char v22 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Failed to load mccRangeLookUp.plist.", buf, 2u);
      }
      sub_1004D4B6C(a5, (long long *)v72, (const void **)&key, &v70);
    }
    sub_100057D78((const void **)&v65);
    if (SHIBYTE(v67) < 0) {
      operator delete((void *)str[0]);
    }
  }
  else
  {
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      std::string::size_type v49 = *a3;
      *(_DWORD *)std::string buf = 138412290;
      *(void *)&uint8_t buf[4] = v49;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "No valid MCC in matching info: %@", buf, 0xCu);
    }
    sub_1004D4B6C(a5, (long long *)v72, (const void **)&key, &v70);
  }
LABEL_103:
  sub_100057D78(&v69);
  sub_1000558F4(&v70);
  sub_1000558F4((const void **)&key);
  if (SHIBYTE(v73) < 0) {
    operator delete(v72[0]);
  }
}

void sub_1004D4680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,const void *a23,const void *a24,const void *a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,const void *a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,uint64_t a47,const void *a48,const void *a49,const void *a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_1004D49EC(v56 - 208);
  sub_1000558F4(&a23);
  sub_100057D78(&a24);
  sub_100057D78(&a25);
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  sub_100057D78(&a39);
  if (a45 < 0) {
    operator delete(a40);
  }
  sub_100057D78(&a48);
  sub_1000558F4(&a49);
  sub_1000558F4(&a50);
  if (a56 < 0) {
    operator delete(a51);
  }
  _Unwind_Resume(a1);
}

const void **sub_1004D4824@<X0>(CFDictionaryRef theDict@<X3>, const void **result@<X0>, Registry **a3@<X1>, const __CFString *a4@<X2>, const __CFDictionary *a5@<X4>, char a6@<W5>, _OWORD *a7@<X8>)
{
  a7[3] = 0u;
  a7[4] = 0u;
  a7[1] = 0u;
  a7[2] = 0u;
  *a7 = 0u;
  if (!a4 || !theDict || !a5) {
    return result;
  }
  CFStringRef v12 = (os_log_t *)result;
  CFArrayRef Value = CFDictionaryGetValue(theDict, (const void *)qword_101B13ED0);
  int v15 = Value;
  if (Value)
  {
    CFTypeID v16 = CFGetTypeID(Value);
    if (v16 == CFStringGetTypeID()) {
      CFTypeID v17 = v15;
    }
    else {
      CFTypeID v17 = 0;
    }
  }
  else
  {
    CFTypeID v17 = 0;
  }
  char v18 = CFDictionaryGetValue(theDict, @"HomeBundleIdentifier");
  if (!v18)
  {
    if (!v17) {
      goto LABEL_15;
    }
LABEL_14:
    sub_1004D4D60(a4, v12, a3, a5, (uint64_t)v21);
LABEL_16:
    sub_1004D65B8((uint64_t)a7, (uint64_t)v21);
    goto LABEL_17;
  }
  CFTypeID v19 = CFGetTypeID(v18);
  CFTypeID TypeID = CFStringGetTypeID();
  if (v17) {
    goto LABEL_14;
  }
  if (v19 != TypeID)
  {
LABEL_15:
    sub_1004D5864(v12, a3, a4, theDict, a5, a6, (uint64_t)v21);
    goto LABEL_16;
  }
  sub_1004D5234(a4, v12, a3, a5, (uint64_t)v21);
  sub_1004D65B8((uint64_t)a7, (uint64_t)v21);
LABEL_17:
  sub_1004D65B8((uint64_t)a7 + 40, (uint64_t)v23);
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_1000558F4(v23);
  if (v22) {
    sub_10004D2C8(v22);
  }
  return sub_1000558F4(v21);
}

void sub_1004D49C8(_Unwind_Exception *a1)
{
  sub_1004D49EC(v1);
  _Unwind_Resume(a1);
}

const void **sub_1004D49EC(uint64_t a1)
{
  BOOL v2 = (const void **)(a1 + 40);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1000558F4(v2);
  CFDictionaryRef v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4) {
    sub_10004D2C8(v4);
  }

  return sub_1000558F4((const void **)a1);
}

BOOL sub_1004D4A44(const __CFDictionary **a1)
{
  CFDictionaryRef v1 = *a1;
  if (v1) {
    BOOL v2 = sub_100080778;
  }
  else {
    BOOL v2 = 0;
  }
  if (!v2) {
    return 0;
  }
  CFStringRef str = 0;
  CFArrayRef Value = (void *)CFDictionaryGetValue(v1, (const void *)qword_101B13EC0);
  sub_100056248(&str, (CFTypeRef *)&Value);
  if (str) {
    uint64_t v3 = sub_1000810B8;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    v10.location = 0;
    v10.length = 3;
    CFStringRef v4 = CFStringCreateWithSubstring(kCFAllocatorDefault, str, v10);
    CFArrayRef Value = (void *)v4;
    if (v4) {
      uint64_t v5 = sub_1000810B8;
    }
    else {
      uint64_t v5 = 0;
    }
    if (v5) {
      BOOL v6 = CFStringCompare(v4, kITUDesignatedPrivateNetworkMCC, 1uLL) == kCFCompareEqualTo;
    }
    else {
      BOOL v6 = 0;
    }
    sub_1000558F4((const void **)&Value);
  }
  else
  {
    BOOL v6 = 0;
  }
  sub_1000558F4((const void **)&str);
  return v6;
}

void sub_1004D4B48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

unsigned char *sub_1004D4B6C(unsigned char *__dst, long long *a2, const void **a3, const void **a4)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v7 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v7;
  }
  sub_100083DA4((const void **)__dst + 3, a3);
  sub_100083DA4((const void **)__dst + 4, a4);
  return __dst;
}

const void **sub_1004D4BE4(uint64_t a1)
{
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }

  return sub_1000558F4((const void **)a1);
}

void sub_1004D4C28()
{
}

void *sub_1004D4C3C()
{
  CFRange result = operator new(0x10uLL);
  *CFRange result = off_1019D7BF8;
  return result;
}

void sub_1004D4C74(uint64_t a1, void *a2)
{
  *a2 = off_1019D7BF8;
}

void sub_1004D4C9C(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    CFStringRef v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "SystemCarrier CountryBundlesScan", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_1004D4D14(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004D4D54()
{
}

const void **sub_1004D4D60@<X0>(CFStringRef theString@<X2>, os_log_t *a2@<X0>, Registry **a3@<X1>, const __CFDictionary *a4@<X4>, uint64_t a5@<X8>)
{
  CFTypeRef v35 = 0;
  CFTypeRef cf = 0;
  if (theString && CFStringGetLength(theString) >= 1)
  {
    CFArrayRef theArray = 0;
    sub_1004D2210(a2, theString, a4, &theArray);
    if (theArray) {
      CFRange v10 = sub_100083F10;
    }
    else {
      CFRange v10 = 0;
    }
    if (v10)
    {
      if (CFArrayGetCount(theArray) == 1)
      {
        *(void *)uint64_t v37 = CFArrayGetValueAtIndex(theArray, 0);
        *(void *)std::string buf = 0;
        CFArrayRef v11 = (const void **)sub_100056248(buf, (CFTypeRef *)v37);
        CFTypeRef v12 = cf;
        CFTypeRef cf = *(CFTypeRef *)buf;
        *(void *)std::string buf = v12;
        sub_1000558F4(v11);
        sub_100083EB8(&v35, &cf);
        uint64_t v13 = *a2;
        if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
        {
          memset(buf, 0, sizeof(buf));
          uint64_t v44 = 0;
          ctu::cf::assign();
          *(_OWORD *)uint64_t v37 = *(_OWORD *)buf;
          uint64_t v38 = v44;
          CFTypeRef v14 = cf;
          if (v44 >= 0) {
            int v15 = v37;
          }
          else {
            int v15 = *(uint8_t **)v37;
          }
          CFTypeRef v30 = cf;
          if (cf)
          {
            CFRetain(cf);
            CFNumberRef v31 = v14;
            CFRetain(v14);
          }
          else
          {
            CFNumberRef v31 = 0;
          }
          memset(buf, 0, sizeof(buf));
          uint64_t v44 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = *(_OWORD *)buf;
          uint64_t v33 = v44;
          CFIndex v24 = __p;
          if (v44 < 0) {
            CFIndex v24 = (void **)__p[0];
          }
          *(_DWORD *)uint64_t v39 = 136446466;
          BOOL v40 = v15;
          __int16 v41 = 2082;
          uint64_t v42 = v24;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Best match for the given Carrier ID and prefix '%{public}s': '%{public}s'", v39, 0x16u);
          if (SHIBYTE(v33) < 0) {
            operator delete(__p[0]);
          }
          sub_1000558F4(&v31);
          sub_1000558F4(&v30);
          if (SHIBYTE(v38) < 0) {
            operator delete(*(void **)v37);
          }
        }
        double v17 = 50.0;
        goto LABEL_29;
      }
      os_log_t v22 = *a2;
      double v17 = 0.0;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        CFIndex Count = CFArrayGetCount(theArray);
        *(_DWORD *)std::string buf = 134217984;
        *(void *)&uint8_t buf[4] = Count;
        CFTypeID v19 = "#I No Unique match found for CarrierBundle = %zu";
        CFTypeID v20 = v22;
        uint32_t v21 = 12;
        goto LABEL_20;
      }
    }
    else
    {
      os_log_t v18 = *a2;
      double v17 = 0.0;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        CFTypeID v19 = "#I No candidates were found in the collection";
        CFTypeID v20 = v18;
        uint32_t v21 = 2;
LABEL_20:
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, buf, v21);
      }
    }
LABEL_29:
    sub_100044D00((const void **)&theArray);
    goto LABEL_30;
  }
  CFTypeID v16 = *a2;
  double v17 = 0.0;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Invalid prefix provided to search for best match with SIM Info", buf, 2u);
  }
LABEL_30:
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)a5 = 0u;
  CFTypeRef v29 = cf;
  if (cf) {
    CFRetain(cf);
  }
  CFTypeRef v28 = v35;
  if (v35) {
    CFRetain(v35);
  }
  sub_1004D6188(a5, a3, &v29, &v28, v17, v17);
  sub_1000558F4(&v28);
  sub_1000558F4(&v29);
  CFStringRef v25 = *a2;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    sub_1004D5F34((uint64_t *)a5, buf);
    if (v44 >= 0) {
      CFDictionaryRef v26 = buf;
    }
    else {
      CFDictionaryRef v26 = *(uint8_t **)buf;
    }
    *(_DWORD *)uint64_t v37 = 136446210;
    *(void *)&v37[4] = v26;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Returning bundle match: %{public}s", v37, 0xCu);
    if (SHIBYTE(v44) < 0) {
      operator delete(*(void **)buf);
    }
  }
  sub_1000558F4(&v35);
  return sub_1000558F4(&cf);
}

void sub_1004D5168(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,int a23,__int16 a24,char a25,char a26,int a27,__int16 a28,char a29,char a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1004D5234@<X0>(CFStringRef theString@<X2>, os_log_t *a2@<X0>, Registry **a3@<X1>, const __CFDictionary *a4@<X3>, uint64_t a5@<X8>)
{
  CFTypeRef v38 = 0;
  if (theString)
  {
    if (CFStringGetLength(theString) > 0)
    {
      CFArrayRef theArray = 0;
      sub_1004D2210(a2, theString, a4, &theArray);
      if (theArray) {
        CFRange v10 = sub_100083F10;
      }
      else {
        CFRange v10 = 0;
      }
      if (v10 && CFArrayGetCount(theArray) > 0)
      {
        CFIndex Count = CFArrayGetCount(theArray);
        double v12 = 0.0;
        if (Count >= 1)
        {
          CFIndex v13 = 0;
          while (1)
          {
            CFTypeRef cf = 0;
            __p[0] = (void *)CFArrayGetValueAtIndex(theArray, v13);
            sub_100056248(&cf, (CFTypeRef *)__p);
            CFTypeRef v30 = cf;
            CFStringRef theString2 = 0;
            if (cf)
            {
              CFRetain(cf);
              CFStringRef theString2 = (CFStringRef)v30;
              if (v30) {
                CFRetain(v30);
              }
            }
            else
            {
              CFStringRef theString2 = 0;
            }
            sub_1000558F4(&v30);
            CFTypeRef v14 = theString2 ? sub_1000810B8 : 0;
            if (v14 && CFStringCompare(theString, theString2, 1uLL) == kCFCompareEqualTo) {
              break;
            }
            sub_1000558F4((const void **)&theString2);
            sub_1000558F4(&cf);
            if (Count == ++v13) {
              goto LABEL_47;
            }
          }
          sub_100083EB8(&v38, &cf);
          uint32_t v21 = *a2;
          if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
          {
            CFTypeRef v22 = v38;
            CFTypeRef v28 = v38;
            if (v38) {
              CFRetain(v38);
            }
            CFTypeRef v29 = 0;
            sub_100056210(&v29, v22);
            __p[0] = 0;
            __p[1] = 0;
            uint64_t v40 = 0;
            ctu::cf::assign();
            *(_OWORD *)std::string buf = *(_OWORD *)__p;
            uint64_t v42 = v40;
            CFIndex v23 = buf;
            if (v40 < 0) {
              CFIndex v23 = (uint8_t *)__p[0];
            }
            *(_DWORD *)CFIndex v43 = 138543618;
            CFStringRef v44 = theString;
            __int16 v45 = 2082;
            CFStringRef v46 = v23;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Best match for the given Home Bundle Identifier '%{public}@': '%{public}s'", v43, 0x16u);
            if (SHIBYTE(v42) < 0) {
              operator delete(*(void **)buf);
            }
            sub_1000558F4(&v29);
            sub_1000558F4(&v28);
          }
          sub_1000558F4((const void **)&theString2);
          sub_1000558F4(&cf);
          double v12 = 50.0;
        }
LABEL_47:
        *(_OWORD *)(a5 + 48) = 0u;
        *(_OWORD *)(a5 + 64) = 0u;
        *(_OWORD *)(a5 + 16) = 0u;
        *(_OWORD *)(a5 + 32) = 0u;
        *(_OWORD *)a5 = 0u;
        CFTypeRef v27 = v38;
        if (v38)
        {
          CFRetain(v38);
          CFTypeRef v26 = v38;
          if (v38) {
            CFRetain(v38);
          }
        }
        else
        {
          CFTypeRef v26 = 0;
        }
        sub_1004D6188(a5, a3, &v27, &v26, v12, v12);
        sub_1000558F4(&v26);
        sub_1000558F4(&v27);
        os_log_t v18 = *a2;
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_58;
        }
        sub_1004D5F34((uint64_t *)a5, __p);
        if (v40 >= 0) {
          CFIndex v24 = __p;
        }
        else {
          CFIndex v24 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = v24;
        CFTypeID v20 = "#I Returning bundle match: %{public}s";
      }
      else
      {
        *(_OWORD *)(a5 + 48) = 0u;
        *(_OWORD *)(a5 + 64) = 0u;
        *(_OWORD *)(a5 + 16) = 0u;
        *(_OWORD *)(a5 + 32) = 0u;
        *(_OWORD *)a5 = 0u;
        CFTypeRef v34 = v38;
        if (v38)
        {
          CFRetain(v38);
          CFTypeRef v33 = v38;
          if (v38) {
            CFRetain(v38);
          }
        }
        else
        {
          CFTypeRef v33 = 0;
        }
        sub_1004D6188(a5, a3, &v34, &v33, 0.0, 0.0);
        sub_1000558F4(&v33);
        sub_1000558F4(&v34);
        os_log_t v18 = *a2;
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_58;
        }
        sub_1004D5F34((uint64_t *)a5, __p);
        if (v40 >= 0) {
          CFTypeID v19 = __p;
        }
        else {
          CFTypeID v19 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = v19;
        CFTypeID v20 = "#I No candidates were found in the collection. Returning bundle match: %{public}s";
      }
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v20, buf, 0xCu);
      if (SHIBYTE(v40) < 0) {
        operator delete(__p[0]);
      }
LABEL_58:
      sub_100044D00((const void **)&theArray);
      return sub_1000558F4(&v38);
    }
    CFTypeRef v17 = v38;
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_OWORD *)(a5 + 48) = 0u;
    *(_OWORD *)(a5 + 64) = 0u;
    uint64_t v37 = v17;
  }
  else
  {
    *(_OWORD *)(a5 + 48) = 0u;
    *(_OWORD *)(a5 + 64) = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_OWORD *)a5 = 0u;
    uint64_t v37 = 0;
  }
  CFNumberRef v36 = 0;
  sub_1004D6188(a5, a3, &v37, &v36, 0.0, 0.0);
  sub_1000558F4(&v36);
  sub_1000558F4(&v37);
  int v15 = *a2;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    sub_1004D5F34((uint64_t *)a5, __p);
    CFTypeID v16 = v40 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136446210;
    *(void *)&uint8_t buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Invalid homeBundleIdentifierFromMatchInfo provided to search for best match with SIM Info. Returning bundle match: %{public}s", buf, 0xCu);
    if (SHIBYTE(v40) < 0) {
      operator delete(__p[0]);
    }
  }
  return sub_1000558F4(&v38);
}

void sub_1004D5760(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,int a21,__int16 a22,char a23,char a24,int a25,__int16 a26,char a27,char a28,int a29,__int16 a30,char a31,char a32,int a33,__int16 a34,char a35,char a36,int a37,__int16 a38,char a39,char a40,int a41,__int16 a42,char a43,char a44,int a45,__int16 a46,char a47,char a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1004D5864@<X0>(os_log_t *a1@<X0>, Registry **a2@<X1>, const __CFString *a3@<X2>, const __CFDictionary *a4@<X3>, const __CFDictionary *a5@<X4>, char a6@<W5>, uint64_t a7@<X8>)
{
  CFTypeRef v43 = 0;
  CFTypeRef v44 = 0;
  CFTypeRef v14 = *a1;
  if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_3;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v46 = 0;
  ctu::cf::assign();
  *(_OWORD *)CFTypeRef cf = 0u;
  uint64_t v48 = 0;
  *(_DWORD *)std::string buf = 136315138;
  *(void *)&uint8_t buf[4] = cf;
  _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Provided match prefix to search based on SIM information: %s", buf, 0xCu);
  if (SHIBYTE(v48) < 0)
  {
    operator delete((void *)cf[0]);
    if (!a3) {
      goto LABEL_50;
    }
  }
  else
  {
LABEL_3:
    if (!a3) {
      goto LABEL_50;
    }
  }
  if (CFStringGetLength(a3) >= 1)
  {
    *(void *)std::string buf = 0;
    sub_1004D2210(a1, a3, a5, buf);
    if (*(void *)buf) {
      int v15 = sub_100083F10;
    }
    else {
      int v15 = 0;
    }
    if (v15)
    {
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)buf);
      if (Count >= 1)
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v46 = 0;
        cf[0] = 0;
        sub_1004D6618(__p, Count, cf);
        CFDictionaryRef Copy = 0;
        if (a4) {
          CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, a4);
        }
        CFIndex v17 = 0;
        double v18 = 0.0;
        double v19 = 0.0;
        double v20 = 0.0;
        double v21 = 0.0;
        do
        {
          cf[0] = 0;
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)buf, v17);
          sub_100056248(cf, (CFTypeRef *)&ValueAtIndex);
          CFTypeRef v40 = cf[0];
          CFStringRef ValueAtIndex = 0;
          if (cf[0])
          {
            CFRetain(cf[0]);
            CFStringRef ValueAtIndex = (const __CFString *)v40;
            if (v40) {
              CFRetain(v40);
            }
          }
          else
          {
            CFStringRef ValueAtIndex = 0;
          }
          sub_1000558F4(&v40);
          if (ValueAtIndex) {
            CFTypeRef v22 = sub_1000810B8;
          }
          else {
            CFTypeRef v22 = 0;
          }
          if (v22)
          {
            *(void *)uint64_t v39 = 0;
            sub_1006B3B08((CFDictionaryRef *)v39, a1, ValueAtIndex);
            double v23 = sub_1006B3F4C((CFDictionaryRef *)v39, &Copy);
            *((double *)__p[0] + v17) = v23;
            if (v23 != 0.0)
            {
              CFTypeRef v38 = cf[0];
              if (cf[0]) {
                CFRetain(cf[0]);
              }
              sub_1000558F4(&v38);
              double v23 = *((double *)__p[0] + v17);
            }
            if (v23 != 0.0)
            {
              if ((a6 & 1) == 0)
              {
                CFTypeRef v37 = cf[0];
                if (cf[0]) {
                  CFRetain(cf[0]);
                }
                sub_1000558F4(&v37);
                double v23 = *((double *)__p[0] + v17);
              }
              if (v23 > 0.0)
              {
                if (v23 > v19)
                {
                  double v19 = v23;
                  double v18 = (double)(int)v17;
                }
                if (v23 > v21)
                {
                  double v21 = v23;
                  double v20 = (double)(int)v17;
                }
              }
            }
            sub_1006B3F14((const void **)v39);
          }
          else
          {
            CFIndex v24 = *a1;
            if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t v39 = 0;
              _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Failed to get the candidate name", v39, 2u);
            }
          }
          sub_1000558F4((const void **)&ValueAtIndex);
          sub_1000558F4(cf);
          ++v17;
        }
        while (Count != v17);
        double v25 = 0.0;
        double v26 = 0.0;
        if (v20 >= 0.0 && v20 < (double)Count && v21 > 0.0)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)buf, (uint64_t)v20);
          cf[0] = 0;
          sub_100056248(cf, (CFTypeRef *)&ValueAtIndex);
          CFTypeRef v27 = v44;
          CFTypeRef v44 = cf[0];
          cf[0] = v27;
          sub_1000558F4(cf);
          double v26 = v21;
        }
        if (v18 >= 0.0 && v18 < (double)Count && v19 > 0.0)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)buf, (uint64_t)v18);
          cf[0] = 0;
          sub_100056248(cf, (CFTypeRef *)&ValueAtIndex);
          CFTypeRef v28 = v43;
          CFTypeRef v43 = cf[0];
          cf[0] = v28;
          sub_1000558F4(cf);
          double v25 = v19;
        }
        sub_1006B3F14((const void **)&Copy);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        goto LABEL_59;
      }
      CFTypeRef v30 = *a1;
      double v25 = 0.0;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        CFNumberRef v31 = "#I No candidates in the candidate list";
        goto LABEL_57;
      }
    }
    else
    {
      CFTypeRef v30 = *a1;
      double v25 = 0.0;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        CFNumberRef v31 = "#I No candidates were found in the collection";
LABEL_57:
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v31, (uint8_t *)__p, 2u);
      }
    }
    double v26 = 0.0;
LABEL_59:
    sub_100044D00((const void **)buf);
    goto LABEL_60;
  }
LABEL_50:
  CFTypeRef v29 = *a1;
  double v25 = 0.0;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Invalid prefix provided to search for best match with SIM Info", (uint8_t *)__p, 2u);
  }
  double v26 = 0.0;
LABEL_60:
  *(_OWORD *)(a7 + 48) = 0u;
  *(_OWORD *)(a7 + 64) = 0u;
  *(_OWORD *)(a7 + 16) = 0u;
  *(_OWORD *)(a7 + 32) = 0u;
  *(_OWORD *)a7 = 0u;
  CFTypeRef v36 = v44;
  if (v44) {
    CFRetain(v44);
  }
  CFTypeRef v35 = v43;
  if (v43) {
    CFRetain(v43);
  }
  sub_1004D6188(a7, a2, &v36, &v35, v26, v25);
  sub_1000558F4(&v35);
  sub_1000558F4(&v36);
  int v32 = *a1;
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    sub_1004D5F34((uint64_t *)a7, __p);
    if (v46 >= 0) {
      CFTypeRef v33 = __p;
    }
    else {
      CFTypeRef v33 = (void **)__p[0];
    }
    LODWORD(cf[0]) = 136315138;
    *(CFTypeRef *)((char *)cf + 4) = v33;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Returning bundle match: %s", (uint8_t *)cf, 0xCu);
    if (SHIBYTE(v46) < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1000558F4(&v43);
  return sub_1000558F4(&v44);
}

void sub_1004D5E44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, int a16, const void *a17, const void *a18, const void *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,const void *a31)
{
  if (__p)
  {
    a21 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100044D00(&a31);
  sub_1000558F4(&a18);
  sub_1000558F4(&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_1004D5F34@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  *(_OWORD *)CFIndex v17 = 0u;
  long long v18 = 0u;
  memset(v16, 0, sizeof(v16));
  sub_10004DE24((uint64_t)v16);
  CFStringRef v4 = sub_10004B96C(v16, (uint64_t)"Matchs: ", 8);
  sub_1004D6364(a1 + 5, v14);
  if ((v15 & 0x80u) == 0) {
    uint64_t v5 = v14;
  }
  else {
    uint64_t v5 = (void **)v14[0];
  }
  if ((v15 & 0x80u) == 0) {
    uint64_t v6 = v15;
  }
  else {
    uint64_t v6 = (uint64_t)v14[1];
  }
  long long v7 = sub_10004B96C(v4, (uint64_t)v5, v6);
  CFArrayRef v8 = sub_10004B96C(v7, (uint64_t)", ", 2);
  sub_1004D6364(a1, __p);
  if ((v13 & 0x80u) == 0) {
    CFTypeID v9 = __p;
  }
  else {
    CFTypeID v9 = (void **)__p[0];
  }
  if ((v13 & 0x80u) == 0) {
    uint64_t v10 = v13;
  }
  else {
    uint64_t v10 = (uint64_t)__p[1];
  }
  sub_10004B96C(v8, (uint64_t)v9, v10);
  if ((char)v13 < 0) {
    operator delete(__p[0]);
  }
  if ((char)v15 < 0) {
    operator delete(v14[0]);
  }
  sub_10004BC98((uint64_t)v16 + 8, a2);
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_1004D613C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  sub_1000C937C((uint64_t)&a21);
  _Unwind_Resume(a1);
}

uint64_t sub_1004D6188(uint64_t a1, Registry **a2, const void **a3, const void **a4, double a5, double a6)
{
  sub_100083DA4(&v13, a3);
  sub_1004D625C(a1, a2, &v13, 0, a5);
  sub_1000558F4(&v13);
  sub_100083DA4(&v12, a4);
  sub_1004D625C(a1 + 40, a2, &v12, 1, a6);
  sub_1000558F4(&v12);
  return a1;
}

void sub_1004D6230(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1000558F4(&a9);
  sub_1004D4BE4(v9);
  _Unwind_Resume(a1);
}

uint64_t sub_1004D625C(uint64_t a1, Registry **a2, const void **a3, char a4, double a5)
{
  uint64_t v9 = sub_100083DA4((const void **)a1, a3);
  *((double *)v9 + 1) = a5;
  *((unsigned char *)v9 + 16) = a4;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a2);
  CFArrayRef v11 = ServiceMap;
  if ((v12 & 0x8000000000000000) != 0)
  {
    unsigned __int8 v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      unint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v20 = v12;
  CFTypeID v16 = sub_10004D37C(&v11[1].__m_.__sig, &v20);
  if (v16)
  {
    uint64_t v18 = v16[3];
    CFIndex v17 = (std::__shared_weak_count *)v16[4];
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v18 = 0;
    CFIndex v17 = 0;
  }
  std::mutex::unlock(v11);
  *(void *)(a1 + 24) = v18;
  *(void *)(a1 + 32) = v17;
  if (v17)
  {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v17);
  }
  return a1;
}

void sub_1004D6350(_Unwind_Exception *a1)
{
  sub_1000558F4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004D6364@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  *(_OWORD *)CFIndex v17 = 0u;
  memset(v16, 0, sizeof(v16));
  sub_10004DE24((uint64_t)v16);
  CFStringRef v4 = sub_10004B96C(v16, (uint64_t)"[Name: ", 7);
  uint64_t v30 = *a1;
  sub_1000292E0((uint64_t)__p);
  if ((v15 & 0x80u) == 0) {
    uint64_t v5 = __p;
  }
  else {
    uint64_t v5 = (void **)__p[0];
  }
  if ((v15 & 0x80u) == 0) {
    uint64_t v6 = v15;
  }
  else {
    uint64_t v6 = (uint64_t)__p[1];
  }
  long long v7 = sub_10004B96C(v4, (uint64_t)v5, v6);
  sub_10004B96C(v7, (uint64_t)", Score: ", 9);
  CFArrayRef v8 = (void *)std::ostream::operator<<();
  uint64_t v9 = sub_10004B96C(v8, (uint64_t)", include cookie: ", 18);
  if (*((unsigned char *)a1 + 16)) {
    uint64_t v10 = "true";
  }
  else {
    uint64_t v10 = "false";
  }
  if (*((unsigned char *)a1 + 16)) {
    uint64_t v11 = 4;
  }
  else {
    uint64_t v11 = 5;
  }
  unint64_t v12 = sub_10004B96C(v9, (uint64_t)v10, v11);
  sub_10004B96C(v12, (uint64_t)"]", 1);
  if ((char)v15 < 0) {
    operator delete(__p[0]);
  }
  sub_10004BC98((uint64_t)v16 + 8, a2);
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_1004D6588(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t sub_1004D65B8(uint64_t a1, uint64_t a2)
{
  sub_100083EB8((const void **)a1, (const void **)a2);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 32);
  *(void *)(a1 + 24) = v5;
  *(void *)(a1 + 32) = v4;
  if (v6) {
    sub_10004D2C8(v6);
  }
  return a1;
}

void *sub_1004D6618(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1004D669C(a1, a2);
    uint64_t v6 = (void *)a1[1];
    long long v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1004D6680(_Unwind_Exception *exception_object)
{
  os_signpost_id_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1004D669C(void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_1004D66E0();
  }
  CFRange result = (char *)sub_10004EF74((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void sub_1004D66E0()
{
}

void sub_1004D6700()
{
}

void sub_1004D6768()
{
}

void *sub_1004D678C(void *a1, void *a2)
{
  uint64_t v4 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, "sfw.nw.cfg");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &v7);
  ctu::OsLogLogger::OsLogLogger(v4, (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  *a1 = off_1019D7CB0;
  a1[2] = *a2;
  uint64_t v5 = a2[1];
  a1[3] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_1004D6864(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  NetworkConfigInterface::~NetworkConfigInterface(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1004D6898(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) >= 0) {
    os_signpost_id_t v3 = a2;
  }
  else {
    os_signpost_id_t v3 = (uint64_t *)*a2;
  }
  return _network_config_set_interface_constrained(v3, a3);
}

uint64_t sub_1004D68B0(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) >= 0) {
    os_signpost_id_t v3 = a2;
  }
  else {
    os_signpost_id_t v3 = (uint64_t *)*a2;
  }
  return _network_config_set_interface_ultra_constrained(v3, a3);
}

uint64_t sub_1004D68C8(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) >= 0) {
    os_signpost_id_t v3 = a2;
  }
  else {
    os_signpost_id_t v3 = (uint64_t *)*a2;
  }
  return _network_config_set_interface_expensive(v3, a3);
}

uint64_t sub_1004D68E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_1004D6E44((uint64_t)v7, a5);
  uint64_t v5 = network_config_set_opportunistic_blocked();
  sub_1004D6DC0(v7);
  return v5;
}

void sub_1004D69C8(_Unwind_Exception *a1)
{
  sub_1004D6DC0(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004D69E4(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 56);
  char v6 = a2;
  uint64_t v5 = a3;
  if (!v3) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *, uint64_t *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

uint64_t sub_1004D6A40(uint64_t a1, uint64_t a2)
{
  return sub_1004D6E44(a1 + 32, a2 + 32);
}

void *sub_1004D6A4C(uint64_t a1)
{
  return sub_1004D6DC0((void *)(a1 + 32));
}

uint64_t sub_1004D6A54(uint64_t a1, uint64_t *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v4 = a2;
  int v5 = *((char *)a2 + 23);
  char v6 = (uint64_t *)*a2;
  uint64_t v7 = 125 * a3;
  uint64_t v8 = 125 * a4;
  uint64_t v9 = *(NSObject **)(a1 + 8);
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v5 < 0) {
    uint64_t v4 = v6;
  }
  if (v10)
  {
    int v12 = 136446978;
    unsigned __int8 v13 = v4;
    __int16 v14 = 2048;
    uint64_t v15 = v7;
    __int16 v16 = 2048;
    uint64_t v17 = v8;
    __int16 v18 = 2080;
    uint64_t v19 = rest::asString();
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Setting interface bandwidth for '%{public}s': uplink: %llu bps, downlink: %llu bps, rat: %s", (uint8_t *)&v12, 0x2Au);
  }
  network_config_set_interface_radio_type();
  return network_config_set_interface_estimated_throughput();
}