const void **sub_101214BA0(__CFDictionary *a1, void *cf, unsigned int a3, CFAllocatorRef allocator)
{
  CFNumberRef v7;
  BOOL v8;
  CFNumberRef v10;
  void *key;
  uint64_t valuePtr;

  key = cf;
  if (cf) {
    CFRetain(cf);
  }
  valuePtr = a3;
  v7 = CFNumberCreate(allocator, kCFNumberLongLongType, &valuePtr);
  v10 = v7;
  if (key) {
    v8 = v7 == 0;
  }
  else {
    v8 = 1;
  }
  if (!v8) {
    CFDictionaryAddValue(a1, key, v7);
  }
  sub_10010F494((const void **)&v10);
  return sub_10010F494((const void **)&key);
}

void sub_101214C30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  sub_10010F494((const void **)va);
  sub_10010F494((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_101214C58(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101214C90(uint64_t a1)
{
}

uint64_t sub_101214CAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101214CF0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_101214D1C(ServiceManager::Service *this)
{
  *(void *)this = off_101AA1160;
  v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_101214D78(ServiceManager::Service *this)
{
  *(void *)this = off_101AA1160;
  v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_101214DE8@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "BootstrapController");
}

unsigned char *sub_101214DF8@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 4;
  result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_101214E38(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_101213CAC(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_101213CAC(v4, 0);
}

uint64_t sub_101214EBC()
{
  return 0;
}

uint64_t sub_101214EC4()
{
  return 1;
}

uint64_t sub_101214ECC()
{
  return 0;
}

void sub_101214EDC(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_101214FF0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 48));
  sub_100088C88(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_101215038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_101215054(uint64_t *a1)
{
  uint64_t v1 = *a1;
  v10 = a1;
  uint64_t v11 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Boostrap Controller : started", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v12, *(Registry **)(v2 + 64));
  ctu::RestModule::connect();
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_100058DB0(__p, "/cc/props/vinyl_info");
  uint64_t v4 = operator new(0x28uLL);
  *uint64_t v4 = off_101AA11E0;
  v4[1] = v2 + 80;
  v4[2] = v2;
  v4[3] = sub_101213F64;
  v4[4] = 0;
  v17 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/internet_reachability_interface");
  v5 = operator new(0x28uLL);
  void *v5 = off_101AA1260;
  v5[1] = v2 + 333;
  v5[2] = v2;
  v5[3] = sub_101213ED4;
  v5[4] = 0;
  v17 = v5;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/internet_status");
  v6 = operator new(0x28uLL);
  void *v6 = off_101AA12E0;
  v6[1] = v2 + 332;
  v6[2] = v2;
  v6[3] = sub_101213F1C;
  v6[4] = 0;
  v17 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100664E98(v2 + 336);
  sub_100058DB0(__p, "/cc/props/sims_in_use");
  v7 = operator new(0x28uLL);
  void *v7 = off_101AA1360;
  v7[1] = v2 + 344;
  v7[2] = v2;
  v7[3] = sub_101214630;
  v7[4] = 0;
  v17 = v7;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  v8 = operator new(0x20uLL);
  void *v8 = off_101AA13E0;
  v8[1] = v2;
  v8[2] = sub_101214A28;
  v8[3] = 0;
  v17 = v8;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100088C88(&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_101215394(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_101215410()
{
}

__n128 sub_101215424(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA11E0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101215478(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA11E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1012154B0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = a1[1];
  long long v10 = 0uLL;
  uint64_t v11 = 0;
  sub_10010C4E0((uint64_t *)&v10, a2);
  long long v14 = 0u;
  memset(v13, 0, sizeof(v13));
  sub_100690AC0(v13, v3);
  long long v8 = v10;
  uint64_t v9 = v11;
  uint64_t v11 = 0;
  long long v10 = 0uLL;
  sub_100786618(v3, (uint64_t *)&v8);
  uint64_t v12 = (void **)&v8;
  sub_1000C56F4(&v12);
  int v4 = (BYTE8(v14) != 0) ^ (*(unsigned char *)(v3 + 216) != 0);
  if (BYTE8(v14) && *(unsigned char *)(v3 + 216)) {
    int v4 = VinylProfileDetails::operator!=();
  }
  if (v4)
  {
    v5 = (void (*)(void *, _OWORD *))a1[3];
    uint64_t v6 = a1[4];
    v7 = (void *)(a1[2] + (v6 >> 1));
    if (v6) {
      v5 = *(void (**)(void *, _OWORD *))(*v7 + v5);
    }
    v5(v7, v13);
  }
  if (BYTE8(v14)) {
    sub_1000C584C((uint64_t)v13);
  }
  *(void *)&v13[0] = &v10;
  sub_1000C56F4((void ***)v13);
}

void sub_101215620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  if (a44) {
    sub_1000C584C((uint64_t)&a17);
  }
  a17 = (void **)&a13;
  sub_1000C56F4(&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_101215668(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1012156A8()
{
}

void sub_1012156B8()
{
}

__n128 sub_1012156CC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA1260;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101215720(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA1260;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101215758(void *a1, xpc_object_t *a2)
{
  int v4 = (char *)a1[1];
  char v13 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    char v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned __int8 *)a2, v6);
    *int v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *int v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = (uint64_t (*)(void *, char *))a1[3];
  uint64_t v10 = a1[4];
  uint64_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, char *))(*v11 + v9);
  }
  return v9(v11, &v13);
}

uint64_t sub_101215854(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101215894()
{
}

void sub_1012158A4()
{
}

__n128 sub_1012158B8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA12E0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10121590C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA12E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101215944(void *a1, xpc_object_t *a2)
{
  int v4 = (char *)a1[1];
  char v13 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    char v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned __int8 *)a2, v6);
    *int v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *int v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = (uint64_t (*)(void *, char *))a1[3];
  uint64_t v10 = a1[4];
  uint64_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, char *))(*v11 + v9);
  }
  return v9(v11, &v13);
}

uint64_t sub_101215A40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101215A80()
{
}

void sub_101215A90()
{
}

__n128 sub_101215AA4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA1360;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101215AF8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA1360;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101215B30(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (uint64_t *)a1[1];
  long long v7 = *(_OWORD *)v3;
  uint64_t v8 = v3[2];
  uint64_t *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  sub_100089CF0(v3, a2);
  int v4 = (void (*)(void *, long long *))a1[3];
  uint64_t v5 = a1[4];
  uint64_t v6 = (void *)(a1[2] + (v5 >> 1));
  if (v5) {
    int v4 = *(void (**)(void *, long long *))(*v6 + v4);
  }
  v4(v6, &v7);
  uint64_t v9 = (void **)&v7;
  sub_10008A88C(&v9);
}

void sub_101215BD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_101215BF0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101215C30()
{
}

void sub_101215C40()
{
}

__n128 sub_101215C54(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101AA13E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101215CA8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA13E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101215CE0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_101215D28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101215D68()
{
}

uint64_t sub_101215D74(capabilities::ct *a1)
{
  uint64_t v1 = **((void **)a1 + 5);
  if (!*(unsigned char *)(v1 + 296)) {
    return 0;
  }
  if (*(unsigned char *)(v1 + 169)) {
    return 1;
  }
  if (capabilities::ct::dataOnlySingleSIMDevice(a1)
    && *(_DWORD *)(v1 + 336) != 1
    && *(unsigned char *)(v1 + 296)
    && !*(void *)(v1 + 376))
  {
    uint64_t v6 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315138;
      uint64_t v8 = printers::asString();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Bootstrap recommendation:%s", (uint8_t *)&v7, 0xCu);
    }
    BOOL v4 = *(unsigned __int16 *)(v1 + 368) < 0x100u;
    BOOL v5 = *(_WORD *)(v1 + 368) == 0;
  }
  else
  {
    uint64_t v3 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrap recommendation not-available", (uint8_t *)&v7, 2u);
    }
    BOOL v4 = 1;
    BOOL v5 = 1;
  }
  if (v4 || v5) {
    return 0;
  }
  else {
    return 2;
  }
}

uint64_t sub_101215ECC(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_101215F08(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

void *sub_101215F44(void *a1)
{
  *a1 = off_101AA14C0;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_101215F90(void *a1)
{
  *a1 = off_101AA14C0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_101215FFC(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101AA14C0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_101216060(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101AA14C0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1012160A0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1012160B0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1012160F0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    BOOL v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[2])
      {
        BOOL v5 = *(std::__shared_weak_count **)(v3 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_101216200(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101216240()
{
}

void sub_10121624C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Enabling recommendation now", buf, 2u);
  }
  uint64_t v3 = *(void *)(v1 + 376);
  *(void *)(v1 + 376) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  if (*(unsigned char *)(v1 + 333) == 1 || *(unsigned char *)(v1 + 370) || *(unsigned char *)(v1 + 371) || *(unsigned char *)(v1 + 332) == 1) {
    __int16 v4 = 256;
  }
  else {
    __int16 v4 = 257;
  }
  *(_WORD *)(v1 + 368) = v4;
  operator delete();
}

void sub_101216348(uint64_t **a1)
{
  int v7 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (*((unsigned char *)*a1 + 11)) {
    *(unsigned char *)(v2 + 370) = *((unsigned char *)v1 + 10);
  }
  if (*((unsigned char *)v1 + 9)) {
    *(unsigned char *)(v2 + 371) = *((unsigned char *)v1 + 8);
  }
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    uint64_t v9 = printers::asString((printers *)(v2 + 370), v4);
    __int16 v10 = 2080;
    uint64_t v11 = printers::asString((printers *)(v2 + 371), v5);
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Monitor Mode: Provisioning:%s Expiry:%s", buf, 0x16u);
  }
  if (*(unsigned char *)(v2 + 333) == 1 || *(unsigned char *)(v2 + 370) || *(unsigned char *)(v2 + 371) || *(unsigned char *)(v2 + 332) == 1) {
    __int16 v6 = 256;
  }
  else {
    __int16 v6 = 257;
  }
  *(_WORD *)(v2 + 368) = v6;
  operator delete();
}

void sub_10121648C()
{
}

uint64_t sub_1012164B8()
{
  sub_100058DB0(qword_101B13320, "sq-device-proxy-stage.apple.com");
  __cxa_atexit((void (*)(void *))&std::string::~string, qword_101B13320, (void *)&_mh_execute_header);
  sub_100058DB0(&qword_101B13320[3], "sq-device-proxy.apple.com");

  return __cxa_atexit((void (*)(void *))&std::string::~string, &qword_101B13320[3], (void *)&_mh_execute_header);
}

void BBDataDriverInterface::createDataDriverInstance(uint64_t *a1@<X4>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  uint64_t v2 = *a1;
  if (*a1)
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v9 = 0;
    __int16 v4 = (char *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 40))(v2);
    sub_100058DB0(__p, v4);
    BOOL v5 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      __int16 v6 = __p;
      if (v9 < 0) {
        __int16 v6 = (void **)__p[0];
      }
      int buf = 136315138;
      *(void *)buf_4 = v6;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Creating data driver for %s", (uint8_t *)&buf, 0xCu);
    }
    if (capabilities::ct::supportsCellRadio((capabilities::ct *)v5))
    {
      uint64_t v7 = a1[1];
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      BBDataDriver::create();
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Cannot create data driver", (uint8_t *)&buf, 2u);
    }
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_101216730(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void BBDataDriverInterface::initDataDriverInstance(uint64_t a1, void *a2, dispatch_object_t *a3, void *a4)
{
  uint64_t v4 = *a2;
  if (*a2)
  {
    uint64_t v15 = 0;
    v16 = 0;
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v4 + 344))(&v15);
    if (v15 && *a4)
    {
      BOOL v7 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT);
      if (v7)
      {
        *(_WORD *)int buf = 0;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Initializing data driver", buf, 2u);
      }
      uint64_t v8 = (capabilities::ct *)capabilities::ct::supportsCellRadio((capabilities::ct *)v7);
      if (v8)
      {
        unint64_t v9 = capabilities::ct::supportedPDPContextCount(v8);
        if (HIDWORD(v9)) {
          __assert_rtn("initDataDriverInstance", "BBDataDriverInterface.cpp", 81, "capabilities::ct::supportedPDPContextCount() <= std::numeric_limits<unsigned int>::max()");
        }
        int v11 = capabilities::ct::supportedPDPContextCount((capabilities::ct *)v9);
        (*(void (**)(void))(*(void *)*a2 + 296))(*a2);
        if (v11)
        {
          (*(void (**)(uint64_t *__return_ptr))(*(void *)(*a2 + *(void *)(*(void *)*a2 - 56)) + 16))(&v14);
          if (*a3) {
            dispatch_retain(*a3);
          }
          (*(void (**)(uint64_t *__return_ptr))(*(void *)(*a2 + *(void *)(*(void *)*a2 - 320)) + 248))(&v13);
          uint64_t v10 = a2[1];
          if (v10) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
          }
          if (v15) {
            (*(void (**)(uint64_t))(*(void *)v15 + 48))(v15);
          }
          operator new();
        }
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Cannot initialize data driver", buf, 2u);
      }
    }
    if (v16) {
      sub_10004D2C8(v16);
    }
  }
}

void sub_101216C28()
{
}

void sub_101216C64()
{
}

void sub_101216CDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  JUMPOUT(0x101216D38);
}

void sub_101216D40()
{
  if (!v0) {
    JUMPOUT(0x101216CA0);
  }
  JUMPOUT(0x101216C98);
}

void sub_101216D4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    sub_10004D2C8(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_101216D68(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101216DA0(uint64_t a1)
{
}

uint64_t sub_101216DBC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101216E00(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

ctu::OsLogLogger *sub_101216E2C(ctu::OsLogLogger *a1, void *a2, NSObject **a3, void *a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v12, kCtLoggingSystemName, "wea");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v13, &v12);
  ctu::OsLogLogger::OsLogLogger(a1, (const ctu::OsLogLogger *)v13);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v13);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v12);
  *((void *)a1 + 1) = *a2;
  uint64_t v8 = a2[1];
  *((void *)a1 + 2) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v9 = *a3;
  *((void *)a1 + 3) = *a3;
  if (v9) {
    dispatch_retain(v9);
  }
  *((void *)a1 + 4) = 0;
  *((void *)a1 + 5) = 0;
  *((void *)a1 + 6) = 0;
  *((void *)a1 + 7) = *a4;
  uint64_t v10 = a4[1];
  *((void *)a1 + 8) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_101216F08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

void sub_101216F2C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v5 = (void **)(a1 + 32);
  sub_10005CBF0(&v5);
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)a1);
}

uint64_t sub_101216F90(uint64_t result, void *a2, void *a3)
{
  *(void *)(result + 32) = 0;
  *(_OWORD *)uint64_t result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(_DWORD *)(result + 32) = 1065353216;
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = result;
    do
    {
      uint64_t v9 = 0;
      long long v7 = 0u;
      long long v8 = 0u;
      sub_100927274((uint64_t)&v7, *v4 + 80);
      for (i = (void *)v8; i; i = (void *)*i)
        sub_1009272EC(v5, i + 2, i + 2);
      uint64_t result = sub_1009277A8((uint64_t)&v7);
      v4 += 2;
    }
    while (v4 != a3);
  }
  return result;
}

void sub_101217034(_Unwind_Exception *a1)
{
  sub_1009277A8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101217058(uint64_t a1, void *a2)
{
  uint64_t v3 = *(uint64_t ***)(a1 + 32);
  uint64_t v4 = *(uint64_t ***)(a1 + 40);
  uint64_t v5 = (int64x2_t *)(a1 + 32);
  if (v3 != v4)
  {
    while (1)
    {
      int v6 = *(_DWORD *)(*a2 + 68);
      uint64_t v7 = (*v3)[8];
      long long v8 = (std::__shared_weak_count *)(*v3)[9];
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v6 == *(_DWORD *)(v7 + 68)) {
        break;
      }
      BOOL v12 = 0;
      if (v8) {
        goto LABEL_9;
      }
LABEL_10:
      if (v12)
      {
        v31 = *(NSObject **)a1;
        if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
        {
          sub_1010DDA90(v206);
          v32 = (SBYTE7(v206[1]) & 0x80u) == 0 ? v206 : *(_OWORD **)&v206[0];
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = v32;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %{public}s already being monitoried...", (uint8_t *)&buf, 0xCu);
          if (SBYTE7(v206[1]) < 0) {
            operator delete(*(void **)&v206[0]);
          }
        }
        sub_100926F98(*v3);
        return 1;
      }
      v3 += 2;
      if (v3 == v4) {
        goto LABEL_15;
      }
    }
    int v9 = *(_DWORD *)(*a2 + 72);
    uint64_t v11 = (*v3)[8];
    uint64_t v10 = (std::__shared_weak_count *)(*v3)[9];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v12 = v9 == *(_DWORD *)(v11 + 72);
      sub_10004D2C8(v10);
      if (!v8) {
        goto LABEL_10;
      }
    }
    else
    {
      BOOL v12 = v9 == *(_DWORD *)(v11 + 72);
      if (!v8) {
        goto LABEL_10;
      }
    }
LABEL_9:
    sub_10004D2C8(v8);
    goto LABEL_10;
  }
LABEL_15:
  uint64_t v13 = *(NSObject **)a1;
  BOOL v14 = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT);
  uint64_t v15 = *a2;
  if (v14)
  {
    sub_1010DDA90(v206);
    if ((SBYTE7(v206[1]) & 0x80u) == 0) {
      v16 = v206;
    }
    else {
      v16 = *(_OWORD **)&v206[0];
    }
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = v16;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %{public}s <-- New alert", (uint8_t *)&buf, 0xCu);
    if (SBYTE7(v206[1]) < 0) {
      operator delete(*(void **)&v206[0]);
    }
    uint64_t v15 = *a2;
  }
  long long __p = 0u;
  long long v200 = 0u;
  uint64_t v201 = 1065353216;
  v17 = (std::__shared_weak_count *)a2[1];
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = *(void *)(v15 + 16);
  v19 = *(std::__shared_weak_count **)(v15 + 24);
  uint64_t v207 = 1065353216;
  memset(v206, 0, sizeof(v206));
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long buf = 0uLL;
  *(void *)&long long v209 = 0;
  v185 = v17;
  sub_1012F8BC8(&buf, *(void **)(v18 + 48), *(void **)(v18 + 56), (uint64_t)(*(void *)(v18 + 56) - *(void *)(v18 + 48)) >> 4);
  if (v19) {
    sub_10004D2C8(v19);
  }
  long long __s1 = 0uLL;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
  v21 = ServiceMap;
  uint64_t v23 = v22;
  if (v22 < 0)
  {
    v24 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v25 = 5381;
    do
    {
      uint64_t v23 = v25;
      unsigned int v26 = *v24++;
      uint64_t v25 = (33 * v25) ^ v26;
    }
    while (v26);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v196 = v23;
  v27 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)&v196);
  v182 = v5;
  if (v27)
  {
    uint64_t v29 = v27[3];
    v28 = (std::__shared_weak_count *)v27[4];
    if (v28)
    {
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v21);
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v28);
      char v30 = 0;
      goto LABEL_43;
    }
  }
  else
  {
    uint64_t v29 = 0;
  }
  std::mutex::unlock(v21);
  v28 = 0;
  char v30 = 1;
LABEL_43:
  (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v29 + 136))(&__s1, v29);
  v183 = a2;
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v28);
  }
  uint64_t v35 = *((void *)&buf + 1);
  for (uint64_t i = buf; i != v35; i += 16)
  {
    long long __dst = 0uLL;
    uint64_t v36 = *(void *)(*(void *)i + 80);
    long long v196 = *(_OWORD *)(*(void *)i + 64);
    *(void *)&long long v197 = v36;
    long long v37 = __s1;
    v38 = operator new(0x98uLL);
    v39 = v38;
    v38[1] = 0;
    v38[2] = 0;
    void *v38 = off_101A5A9B8;
    long long v193 = v37;
    if (*((void *)&v37 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v37 + 1) + 16), 1uLL, memory_order_relaxed);
    }
    sub_100F8FC9C((uint64_t)(v38 + 3), &v193, (uint64_t)&v196);
    if (*((void *)&v37 + 1)) {
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v37 + 1));
    }
    *(void *)&long long __dst = v39 + 3;
    *((void *)&__dst + 1) = v39;
    sub_1000B3BC8((uint64_t)&__dst, v39 + 4, (uint64_t)(v39 + 3));
    sub_1009272EC((uint64_t)v206, (uint64_t *)&__dst, (uint64_t *)&__dst);
    double v40 = *(double *)(*(void *)i + 64);
    double v41 = *(double *)(*(void *)i + 72);
    double v42 = *(double *)(*(void *)i + 80);
    v43 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
    v44 = v43;
    uint64_t v45 = v22;
    if (v22 < 0)
    {
      v46 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v47 = 5381;
      do
      {
        uint64_t v45 = v47;
        unsigned int v48 = *v46++;
        uint64_t v47 = (33 * v47) ^ v48;
      }
      while (v48);
    }
    std::mutex::lock(v43);
    *(void *)&long long v196 = v45;
    v49 = sub_10004D37C(&v44[1].__m_.__sig, (unint64_t *)&v196);
    if (v49)
    {
      uint64_t v51 = v49[3];
      v50 = (std::__shared_weak_count *)v49[4];
      if (v50)
      {
        atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v44);
        atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v50);
        char v52 = 0;
        if (v51) {
          goto LABEL_59;
        }
        goto LABEL_61;
      }
    }
    else
    {
      uint64_t v51 = 0;
    }
    std::mutex::unlock(v44);
    v50 = 0;
    char v52 = 1;
    if (v51)
    {
LABEL_59:
      (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v51 + 152))(&v196, v51);
      (*(void (**)(void, double, double, double))(*(void *)v196 + 24))(v196, v40, v41, v42);
      if (*((void *)&v196 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v196 + 1));
      }
    }
LABEL_61:
    if ((v52 & 1) == 0) {
      sub_10004D2C8(v50);
    }
    if (*((void *)&__dst + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&__dst + 1));
    }
  }
  if (*((void *)&__s1 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&__s1 + 1));
  }
  *(void *)&long long v196 = &buf;
  sub_10005CBF0((void ***)&v196);
  sub_100928674((uint64_t)&__p);
  uint64_t v53 = *(void *)&v206[0];
  *(void *)&v206[0] = 0;
  v54 = (void *)__p;
  *(void *)&long long __p = v53;
  if (v54) {
    operator delete(v54);
  }
  unint64_t v55 = *((void *)&v206[0] + 1);
  *((void *)&v206[0] + 1) = 0;
  long long v200 = v206[1];
  LODWORD(v201) = v207;
  *((void *)&__p + 1) = v55;
  if (*((void *)&v206[1] + 1))
  {
    unint64_t v56 = *(void *)(*(void *)&v206[1] + 8);
    if ((v55 & (v55 - 1)) != 0)
    {
      if (v56 >= v55) {
        v56 %= v55;
      }
    }
    else
    {
      v56 &= v55 - 1;
    }
    *(void *)(__p + 8 * v56) = &v200;
    v206[1] = 0uLL;
  }
  sub_1009277A8((uint64_t)v206);
  if (v185) {
    sub_10004D2C8(v185);
  }
  uint64_t v198 = 0;
  long long v196 = 0u;
  long long v197 = 0u;
  uint64_t v57 = *a2;
  v58 = (std::__shared_weak_count *)a2[1];
  if (v58) {
    atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v59 = *(void *)(v57 + 16);
  v60 = *(std::__shared_weak_count **)(v57 + 24);
  long long v196 = 0uLL;
  long long v197 = 0uLL;
  uint64_t v198 = 1065353216;
  if (v60) {
    atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  memset(v206, 0, 24);
  sub_1012F8AB4(v206, *(void **)(v59 + 24), *(void **)(v59 + 32), (uint64_t)(*(void *)(v59 + 32) - *(void *)(v59 + 24)) >> 4);
  if (v60) {
    sub_10004D2C8(v60);
  }
  long long __s1 = 0uLL;
  v61 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
  v62 = v61;
  uint64_t v63 = v22;
  if (v22 < 0)
  {
    v64 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v65 = 5381;
    do
    {
      uint64_t v63 = v65;
      unsigned int v66 = *v64++;
      uint64_t v65 = (33 * v65) ^ v66;
    }
    while (v66);
  }
  std::mutex::lock(v61);
  *(void *)&long long buf = v63;
  v67 = sub_10004D37C(&v62[1].__m_.__sig, (unint64_t *)&buf);
  if (v67)
  {
    uint64_t v69 = v67[3];
    v68 = (std::__shared_weak_count *)v67[4];
    if (v68)
    {
      atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v62);
      atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v68);
      char v70 = 0;
      goto LABEL_92;
    }
  }
  else
  {
    uint64_t v69 = 0;
  }
  std::mutex::unlock(v62);
  v68 = 0;
  char v70 = 1;
LABEL_92:
  (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v69 + 136))(&__s1, v69);
  v184 = v58;
  if ((v70 & 1) == 0) {
    sub_10004D2C8(v68);
  }
  v71 = (uint64_t *)*((void *)&v206[0] + 1);
  for (j = *(uint64_t **)&v206[0]; j != v71; j += 2)
  {
    uint64_t v73 = *j;
    long long buf = 0uLL;
    *(void *)&long long v209 = 0;
    sub_1004081A4(&buf, *(const void **)(v73 + 64), *(void *)(v73 + 72), (uint64_t)(*(void *)(v73 + 72) - *(void *)(v73 + 64)) >> 4);
    long long __dst = 0uLL;
    long long v74 = __s1;
    v75 = operator new(0x98uLL);
    v76 = v75;
    v75[1] = 0;
    v75[2] = 0;
    void *v75 = off_101A5A9B8;
    long long v193 = v74;
    if (*((void *)&v74 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v74 + 1) + 16), 1uLL, memory_order_relaxed);
    }
    sub_100F8FDB4((uint64_t)(v75 + 3), &v193, (uint64_t *)&buf);
    if (*((void *)&v74 + 1)) {
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v74 + 1));
    }
    *(void *)&long long __dst = v76 + 3;
    *((void *)&__dst + 1) = v76;
    sub_1000B3BC8((uint64_t)&__dst, v76 + 4, (uint64_t)(v76 + 3));
    sub_1009272EC((uint64_t)&v196, (uint64_t *)&__dst, (uint64_t *)&__dst);
    if (*((void *)&buf + 1) == (void)buf) {
      goto LABEL_129;
    }
    double v78 = *(double *)buf;
    double v77 = *(double *)(buf + 8);
    v79 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
    v80 = v79;
    uint64_t v81 = v22;
    if (v22 < 0)
    {
      v82 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v83 = 5381;
      do
      {
        uint64_t v81 = v83;
        unsigned int v84 = *v82++;
        uint64_t v83 = (33 * v83) ^ v84;
      }
      while (v84);
    }
    std::mutex::lock(v79);
    *(void *)&long long v193 = v81;
    v85 = sub_10004D37C(&v80[1].__m_.__sig, (unint64_t *)&v193);
    if (v85)
    {
      uint64_t v87 = v85[3];
      v86 = (std::__shared_weak_count *)v85[4];
      if (v86)
      {
        atomic_fetch_add_explicit(&v86->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v80);
        atomic_fetch_add_explicit(&v86->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v86);
        char v88 = 0;
        goto LABEL_108;
      }
    }
    else
    {
      uint64_t v87 = 0;
    }
    std::mutex::unlock(v80);
    v86 = 0;
    char v88 = 1;
LABEL_108:
    v89 = (double *)*((void *)&buf + 1);
    v90 = (double *)buf;
    if ((void)buf != *((void *)&buf + 1))
    {
      int v91 = 0;
      double v92 = 0.0;
      double v93 = v77;
      double v94 = v78;
      double v95 = 0.0;
      do
      {
        double v96 = *v90;
        double v97 = v90[1];
        if (*v90 < v78) {
          double v78 = *v90;
        }
        if (v96 > v94) {
          double v94 = *v90;
        }
        if (v97 < v77) {
          double v77 = v90[1];
        }
        if (v97 > v93) {
          double v93 = v90[1];
        }
        if (v87)
        {
          (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v87 + 152))(&v193, v87);
          (*(void (**)(void, double, double, double))(*(void *)v193 + 24))(v193, v96, v97, 0.0);
          if (*((void *)&v193 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v193 + 1));
          }
        }
        double v95 = v95 + v96;
        double v92 = v92 + v97;
        v90 += 2;
        ++v91;
      }
      while (v90 != v89);
      if (!v87) {
        goto LABEL_127;
      }
LABEL_125:
      (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v87 + 152))(&v193, v87);
      (*(void (**)(void, double, double, double, double, double, double))(*(void *)v193 + 32))(v193, v95 / (double)v91, v92 / (double)v91, v94, v78, v93, v77);
      if (*((void *)&v193 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v193 + 1));
      }
      goto LABEL_127;
    }
    int v91 = 0;
    double v95 = 0.0;
    double v92 = 0.0;
    double v94 = v78;
    double v93 = v77;
    if (v87) {
      goto LABEL_125;
    }
LABEL_127:
    if ((v88 & 1) == 0) {
      sub_10004D2C8(v86);
    }
LABEL_129:
    if (*((void *)&__dst + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&__dst + 1));
    }
    if ((void)buf)
    {
      *((void *)&buf + 1) = buf;
      operator delete((void *)buf);
    }
  }
  if (*((void *)&__s1 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&__s1 + 1));
  }
  *(void *)&long long buf = v206;
  sub_10005CBF0((void ***)&buf);
  if (v184) {
    sub_10004D2C8(v184);
  }
  for (k = (void *)v197; k; k = (void *)*k)
    sub_1009272EC((uint64_t)&__p, k + 2, k + 2);
  sub_100928674((uint64_t)&v196);
  uint64_t v195 = 0;
  long long v193 = 0u;
  long long v194 = 0u;
  sub_100927274((uint64_t)&v189, (uint64_t)&__p);
  v99 = *(void **)(a1 + 32);
  v100 = *(void **)(a1 + 40);
  uint64_t v207 = 0;
  memset(v206, 0, sizeof(v206));
  sub_101216F90((uint64_t)v206, v99, v100);
  uint64_t v210 = 1065353216;
  long long buf = 0u;
  long long v209 = 0u;
  v101 = *(void **)&v206[1];
  if (*(void *)&v206[1])
  {
LABEL_141:
    v102 = (long long *)v191;
    if (!(void)v191) {
      goto LABEL_212;
    }
    v103 = v101 + 2;
    while (1)
    {
      uint64_t v104 = *((void *)v102 + 2);
      v105 = (std::__shared_weak_count *)*((void *)v102 + 3);
      if (v105) {
        atomic_fetch_add_explicit(&v105->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (*(char *)(v104 + 63) < 0)
      {
        sub_10004FC84(&__s1, *(void **)(v104 + 40), *(void *)(v104 + 48));
      }
      else
      {
        long long __s1 = *(_OWORD *)(v104 + 40);
        uint64_t v205 = *(void *)(v104 + 56);
      }
      uint64_t v106 = *v103;
      if (*(char *)(*v103 + 63) < 0)
      {
        sub_10004FC84(&__dst, *(void **)(v106 + 40), *(void *)(v106 + 48));
      }
      else
      {
        long long __dst = *(_OWORD *)(v106 + 40);
        uint64_t v203 = *(void *)(v106 + 56);
      }
      char v107 = HIBYTE(v205);
      if (v205 >= 0) {
        uint64_t v108 = HIBYTE(v205);
      }
      else {
        uint64_t v108 = *((void *)&__s1 + 1);
      }
      uint64_t v109 = HIBYTE(v203);
      int v110 = SHIBYTE(v203);
      if (v203 < 0) {
        uint64_t v109 = *((void *)&__dst + 1);
      }
      if (v108 == v109)
      {
        if (v203 >= 0) {
          p_dst = &__dst;
        }
        else {
          p_dst = (long long *)__dst;
        }
        if (SHIBYTE(v205) < 0)
        {
          BOOL v120 = memcmp((const void *)__s1, p_dst, *((size_t *)&__s1 + 1)) == 0;
          if ((v110 & 0x80000000) == 0) {
            goto LABEL_169;
          }
        }
        else if (HIBYTE(v205))
        {
          uint64_t v112 = HIBYTE(v205) - 1;
          p_s1 = &__s1;
          do
          {
            int v115 = *(unsigned __int8 *)p_s1;
            p_s1 = (long long *)((char *)p_s1 + 1);
            int v114 = v115;
            int v117 = *(unsigned __int8 *)p_dst;
            p_dst = (long long *)((char *)p_dst + 1);
            int v116 = v117;
            BOOL v119 = v112-- != 0;
            BOOL v120 = v114 == v116;
          }
          while (v114 == v116 && v119);
          if ((SHIBYTE(v203) & 0x80000000) == 0)
          {
LABEL_169:
            if ((v107 & 0x80) == 0) {
              goto LABEL_170;
            }
            goto LABEL_174;
          }
        }
        else
        {
          BOOL v120 = 1;
          if ((SHIBYTE(v203) & 0x80000000) == 0) {
            goto LABEL_169;
          }
        }
      }
      else
      {
        BOOL v120 = 0;
        if ((SHIBYTE(v203) & 0x80000000) == 0) {
          goto LABEL_169;
        }
      }
      operator delete((void *)__dst);
      if ((v205 & 0x8000000000000000) == 0)
      {
LABEL_170:
        if (v120) {
          goto LABEL_183;
        }
        goto LABEL_175;
      }
LABEL_174:
      operator delete((void *)__s1);
      if (v120)
      {
LABEL_183:
        int8x8_t v121 = v190;
        unint64_t v122 = *((void *)v102 + 1);
        uint8x8_t v123 = (uint8x8_t)vcnt_s8(v190);
        v123.i16[0] = vaddlv_u8(v123);
        if (v123.u32[0] > 1uLL)
        {
          if (v122 >= *(void *)&v190) {
            v122 %= *(void *)&v190;
          }
        }
        else
        {
          v122 &= *(void *)&v190 - 1;
        }
        v124 = *(long long **)v102;
        v125 = *(long long **)(v189 + 8 * v122);
        do
        {
          v126 = v125;
          v125 = *(long long **)v125;
        }
        while (v125 != v102);
        if (v126 == &v191) {
          goto LABEL_200;
        }
        unint64_t v127 = *((void *)v126 + 1);
        if (v123.u32[0] > 1uLL)
        {
          if (v127 >= *(void *)&v190) {
            v127 %= *(void *)&v190;
          }
        }
        else
        {
          v127 &= *(void *)&v190 - 1;
        }
        if (v127 == v122)
        {
LABEL_202:
          if (v124)
          {
            unint64_t v128 = *((void *)v124 + 1);
            goto LABEL_204;
          }
        }
        else
        {
LABEL_200:
          if (!v124) {
            goto LABEL_201;
          }
          unint64_t v128 = *((void *)v124 + 1);
          if (v123.u32[0] > 1uLL)
          {
            unint64_t v129 = *((void *)v124 + 1);
            if (v128 >= *(void *)&v190) {
              unint64_t v129 = v128 % *(void *)&v190;
            }
          }
          else
          {
            unint64_t v129 = v128 & (*(void *)&v190 - 1);
          }
          if (v129 != v122)
          {
LABEL_201:
            *(void *)(v189 + 8 * v122) = 0;
            v124 = *(long long **)v102;
            goto LABEL_202;
          }
LABEL_204:
          if (v123.u32[0] > 1uLL)
          {
            if (v128 >= *(void *)&v121) {
              v128 %= *(void *)&v121;
            }
          }
          else
          {
            v128 &= *(void *)&v121 - 1;
          }
          if (v128 != v122)
          {
            *(void *)(v189 + 8 * v128) = v126;
            v124 = *(long long **)v102;
          }
        }
        *(void *)v126 = v124;
        *(void *)v102 = 0;
        --*((void *)&v191 + 1);
        LOBYTE(v205) = 1;
        *(void *)&long long __s1 = 0;
        *((void *)&__s1 + 1) = &v191;
        sub_10092774C((uint64_t)&__s1 + 8, v102);
        sub_1009272EC((uint64_t)&buf, v101 + 2, v101 + 2);
        if (v105) {
          sub_10004D2C8(v105);
        }
LABEL_212:
        v101 = (void *)*v101;
        if (!v101)
        {
          for (m = (void *)v209; m; m = (void *)*m)
            sub_1009272EC((uint64_t)&v189, m + 2, m + 2);
          break;
        }
        goto LABEL_141;
      }
LABEL_175:
      if (v105) {
        sub_10004D2C8(v105);
      }
      v102 = *(long long **)v102;
      if (!v102) {
        goto LABEL_212;
      }
    }
  }
  uint64_t v131 = v189;
  int8x8_t v132 = v190;
  uint64_t v189 = 0;
  int8x8_t v190 = 0;
  *(void *)&long long v193 = v131;
  *((int8x8_t *)&v193 + 1) = v132;
  long long v194 = v191;
  LODWORD(v195) = v192;
  if (*((void *)&v191 + 1))
  {
    unint64_t v133 = *(void *)(v191 + 8);
    if ((*(void *)&v132 & (*(void *)&v132 - 1)) != 0)
    {
      if (v133 >= *(void *)&v132) {
        v133 %= *(void *)&v132;
      }
    }
    else
    {
      v133 &= *(void *)&v132 - 1;
    }
    *(void *)(v131 + 8 * v133) = &v194;
    long long v191 = 0uLL;
  }
  sub_1009277A8((uint64_t)&buf);
  sub_1009277A8((uint64_t)v206);
  sub_1009277A8((uint64_t)&v189);
  sub_100928674((uint64_t)&__p);
  v134 = (void *)v194;
  if (!(void)v194)
  {
LABEL_238:
    uint64_t v144 = *(void *)(a1 + 8);
    v145 = *(std::__shared_weak_count **)(a1 + 16);
    v146 = (std::__shared_weak_count *)operator new(0xC0uLL);
    v147 = v146;
    v146->__shared_owners_ = 0;
    v146->__shared_weak_owners_ = 0;
    v146->__vftable = (std::__shared_weak_count_vtbl *)off_101AA15C8;
    *(void *)&long long buf = v144;
    *((void *)&buf + 1) = v145;
    if (v145) {
      atomic_fetch_add_explicit(&v145->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v148 = (std::__shared_weak_count *)v183[1];
    *(void *)&long long __s1 = *v183;
    *((void *)&__s1 + 1) = v148;
    if (v148) {
      atomic_fetch_add_explicit(&v148->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v149 = &v146[1].__vftable;
    long long v150 = v193;
    long long v193 = 0uLL;
    v206[0] = v150;
    v206[1] = v194;
    LODWORD(v207) = v195;
    if (*((void *)&v194 + 1))
    {
      *(void *)(v150 + 8 * *((void *)&v150 + 1)) = &v206[1];
      long long v194 = 0uLL;
    }
    v151 = *(std::__shared_weak_count **)(a1 + 64);
    *(void *)&long long __dst = *(void *)(a1 + 56);
    *((void *)&__dst + 1) = v151;
    if (v151) {
      atomic_fetch_add_explicit(&v151->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100924DA8(&v146[1].__vftable, &buf, (NSObject **)(a1 + 24), &__s1, (uint64_t)v206, &__dst);
    if (v151) {
      sub_10004D2C8(v151);
    }
    sub_1009277A8((uint64_t)v206);
    if (v148) {
      sub_10004D2C8(v148);
    }
    if (v145) {
      sub_10004D2C8(v145);
    }
    shared_owners = (std::__shared_weak_count *)v147[1].__shared_owners_;
    if (shared_owners)
    {
      v153 = v182;
      if (shared_owners->__shared_owners_ != -1) {
        goto LABEL_257;
      }
      atomic_fetch_add_explicit(&v147->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v147->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v147[1].__vftable = (std::__shared_weak_count_vtbl *)&v147[1];
      v147[1].__shared_owners_ = (uint64_t)v147;
      std::__shared_weak_count::__release_weak(shared_owners);
    }
    else
    {
      atomic_fetch_add_explicit(&v147->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v147->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v147[1].__vftable = (std::__shared_weak_count_vtbl *)&v147[1];
      v147[1].__shared_owners_ = (uint64_t)v147;
      v153 = v182;
    }
    sub_10004D2C8(v147);
LABEL_257:
    sub_100928674((uint64_t)&v193);
    sub_100925F28((uint64_t)&v147[1]);
    unint64_t v154 = *(void *)(a1 + 48);
    v155 = *(void **)(a1 + 40);
    if ((unint64_t)v155 >= v154)
    {
      uint64_t v157 = ((uint64_t)v155 - v153->i64[0]) >> 4;
      unint64_t v158 = v157 + 1;
      if ((unint64_t)(v157 + 1) >> 60) {
        sub_10006A748();
      }
      uint64_t v159 = v154 - v153->i64[0];
      if (v159 >> 3 > v158) {
        unint64_t v158 = v159 >> 3;
      }
      if ((unint64_t)v159 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v160 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v160 = v158;
      }
      uint64_t v207 = a1 + 48;
      v161 = (char *)sub_10006A794(a1 + 48, v160);
      v162 = &v161[16 * v157];
      *((void *)&v206[1] + 1) = &v161[16 * v163];
      *(void *)v162 = v149;
      *((void *)v162 + 1) = v147;
      v156 = v162 + 16;
      *(void *)&v206[1] = v162 + 16;
      v165 = *(void **)(a1 + 32);
      v164 = *(void **)(a1 + 40);
      if (v164 == v165)
      {
        int64x2_t v167 = vdupq_n_s64((unint64_t)v164);
      }
      else
      {
        do
        {
          long long v166 = *((_OWORD *)v164 - 1);
          v164 -= 2;
          *((_OWORD *)v162 - 1) = v166;
          v162 -= 16;
          void *v164 = 0;
          v164[1] = 0;
        }
        while (v164 != v165);
        int64x2_t v167 = *v153;
        v156 = *(void **)&v206[1];
      }
      *(void *)(a1 + 32) = v162;
      *(void *)(a1 + 40) = v156;
      *(int64x2_t *)((char *)v206 + 8) = v167;
      uint64_t v168 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = *((void *)&v206[1] + 1);
      *((void *)&v206[1] + 1) = v168;
      *(void *)&v206[0] = v167.i64[0];
      sub_10019E528((uint64_t)v206);
    }
    else
    {
      void *v155 = v149;
      v155[1] = v147;
      v156 = v155 + 2;
      *(void *)(a1 + 40) = v155 + 2;
    }
    *(void *)(a1 + 40) = v156;
    v169 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
    v170 = v169;
    if (v171 < 0)
    {
      v172 = (unsigned __int8 *)(v171 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v173 = 5381;
      do
      {
        uint64_t v171 = v173;
        unsigned int v174 = *v172++;
        uint64_t v173 = (33 * v173) ^ v174;
      }
      while (v174);
    }
    std::mutex::lock(v169);
    *(void *)&v206[0] = v171;
    v175 = sub_10004D37C(&v170[1].__m_.__sig, (unint64_t *)v206);
    if (v175)
    {
      uint64_t v177 = v175[3];
      v176 = (std::__shared_weak_count *)v175[4];
      if (v176)
      {
        atomic_fetch_add_explicit(&v176->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v170);
        atomic_fetch_add_explicit(&v176->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v176);
        char v178 = 0;
        if (!v177) {
          goto LABEL_283;
        }
        goto LABEL_279;
      }
    }
    else
    {
      uint64_t v177 = 0;
    }
    std::mutex::unlock(v170);
    v176 = 0;
    char v178 = 1;
    if (!v177)
    {
LABEL_283:
      if ((v178 & 1) == 0) {
        sub_10004D2C8(v176);
      }
      uint64_t v33 = 1;
      goto LABEL_286;
    }
LABEL_279:
    v179 = (std::__shared_weak_count *)v183[1];
    uint64_t v187 = *v183;
    v188 = v179;
    if (v179) {
      atomic_fetch_add_explicit(&v179->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v177 + 120))(v177, &v187);
    if (v188) {
      sub_10004D2C8(v188);
    }
    goto LABEL_283;
  }
  while (1)
  {
    uint64_t v135 = v134[3];
    if (!v135 || *(void *)(v135 + 8))
    {
      os_log_t v136 = *(os_log_t *)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        sub_100F900D8(v134[2], v206);
        if ((SBYTE7(v206[1]) & 0x80u) == 0) {
          v137 = v206;
        }
        else {
          v137 = *(_OWORD **)&v206[0];
        }
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = v137;
        v138 = v136;
        v139 = "#I %{public}s Already being monitored...";
        goto LABEL_235;
      }
      goto LABEL_237;
    }
    BOOL v140 = sub_100F90AC8(v134[2]);
    v141 = *(NSObject **)a1;
    BOOL v142 = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT);
    if (!v140) {
      break;
    }
    if (v142)
    {
      sub_100F900D8(v134[2], v206);
      if ((SBYTE7(v206[1]) & 0x80u) == 0) {
        v143 = v206;
      }
      else {
        v143 = *(_OWORD **)&v206[0];
      }
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = v143;
      v138 = v141;
      v139 = "#I %{public}s Monitoring start triggered...";
LABEL_235:
      _os_log_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_DEFAULT, v139, (uint8_t *)&buf, 0xCu);
      if (SBYTE7(v206[1]) < 0) {
        operator delete(*(void **)&v206[0]);
      }
    }
LABEL_237:
    v134 = (void *)*v134;
    if (!v134) {
      goto LABEL_238;
    }
  }
  if (v142)
  {
    sub_100F900D8(v134[2], v206);
    v181 = (SBYTE7(v206[1]) & 0x80u) == 0 ? v206 : *(_OWORD **)&v206[0];
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = v181;
    _os_log_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_DEFAULT, "#I %{public}s Monitoring could not be started...", (uint8_t *)&buf, 0xCu);
    if (SBYTE7(v206[1]) < 0) {
      operator delete(*(void **)&v206[0]);
    }
  }
  uint64_t v33 = 0;
LABEL_286:
  sub_1009277A8((uint64_t)&v193);
  sub_1009277A8((uint64_t)&v196);
  sub_1009277A8((uint64_t)&__p);
  return v33;
}

void sub_101218400(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
}

void sub_1012186E0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)a2 + 160);
  uint64_t v3 = *(std::__shared_weak_count **)(*(void *)a2 + 168);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v75 = v3;
  double v96 = 0;
  uint64_t v97 = 0;
  double v95 = 0;
  sub_101093CD4(&v95, *(void **)(v2 + 8), *(void **)(v2 + 16), (uint64_t)(*(void *)(v2 + 16) - *(void *)(v2 + 8)) >> 4);
  double v92 = 0;
  double v93 = 0;
  uint64_t v94 = 0;
  v89 = 0;
  v90 = 0;
  uint64_t v91 = 0;
  uint64_t v4 = v95;
  uint64_t v5 = v96;
  if (v95 == v96) {
    goto LABEL_73;
  }
  do
  {
    long long v6 = *v4;
    uint64_t v7 = (std::__shared_weak_count *)*((void *)v4 + 1);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(unsigned char *)(v6 + 4)) {
      long long v8 = (uint64_t *)&v89;
    }
    else {
      long long v8 = (uint64_t *)&v92;
    }
    if (*(unsigned char *)(v6 + 4)) {
      int v9 = (unint64_t *)&v91;
    }
    else {
      int v9 = (unint64_t *)&v94;
    }
    uint64_t v10 = (void *)v8[1];
    unint64_t v11 = v8[2];
    if ((unint64_t)v10 >= v11)
    {
      long long v77 = v6;
      uint64_t v13 = ((uint64_t)v10 - *v8) >> 4;
      unint64_t v14 = v13 + 1;
      if ((unint64_t)(v13 + 1) >> 60) {
        sub_101093C84();
      }
      uint64_t v15 = v11 - *v8;
      if (v15 >> 3 > v14) {
        unint64_t v14 = v15 >> 3;
      }
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v16 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v14;
      }
      v102 = v9;
      v17 = (char *)sub_10006A794((uint64_t)v9, v16);
      uint64_t v18 = &v17[16 * v13];
      v100.__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
      v100.__r_.__value_.__l.__size_ = (std::string::size_type)v18;
      v101 = &v17[16 * v19];
      *(_OWORD *)uint64_t v18 = v77;
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v100.__r_.__value_.__r.__words[2] = (std::string::size_type)(v18 + 16);
      sub_101093DE8(v8, &v100);
      BOOL v12 = (void *)v8[1];
      sub_1006C59A4((void **)&v100.__r_.__value_.__l.__data_);
    }
    else
    {
      void *v10 = v6;
      v10[1] = v7;
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      BOOL v12 = v10 + 2;
      v8[1] = (uint64_t)(v10 + 2);
    }
    v8[1] = (uint64_t)v12;
    if (v7) {
      sub_10004D2C8(v7);
    }
    ++v4;
  }
  while (v4 != v5);
  v21 = v92;
  v20 = v93;
  if (v93 == v92) {
    goto LABEL_73;
  }
  v86 = 0;
  uint64_t v87 = 0;
  unint64_t v88 = 0;
  do
  {
    uint64_t v22 = (std::__shared_weak_count *)*((void *)v21 + 1);
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_101092D24(&buf);
    uint64_t v23 = v87;
    if ((unint64_t)v87 >= v88)
    {
      unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * (((char *)v87 - (char *)v86) >> 3);
      unint64_t v26 = v25 + 1;
      if (v25 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_1000D8578();
      }
      if (0x5555555555555556 * ((uint64_t)(v88 - (void)v86) >> 3) > v26) {
        unint64_t v26 = 0x5555555555555556 * ((uint64_t)(v88 - (void)v86) >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v88 - (void)v86) >> 3) >= 0x555555555555555) {
        unint64_t v27 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v27 = v26;
      }
      v102 = &v88;
      if (v27) {
        v28 = (char *)sub_10004812C((uint64_t)&v88, v27);
      }
      else {
        v28 = 0;
      }
      std::string::size_type v29 = (std::string::size_type)&v28[24 * v25];
      v100.__r_.__value_.__r.__words[0] = (std::string::size_type)v28;
      v100.__r_.__value_.__l.__size_ = v29;
      v101 = &v28[24 * v27];
      long long v30 = buf;
      *(void *)(v29 + 16) = v99;
      *(_OWORD *)std::string::size_type v29 = v30;
      std::string::size_type v99 = 0;
      long long buf = 0uLL;
      v100.__r_.__value_.__r.__words[2] = v29 + 24;
      sub_100048204((uint64_t *)&v86, &v100);
      v31 = v87;
      sub_100048174((uint64_t)&v100);
      uint64_t v87 = v31;
      if ((SHIBYTE(v99) & 0x80000000) == 0)
      {
        if (!v22) {
          goto LABEL_47;
        }
LABEL_46:
        sub_10004D2C8(v22);
        goto LABEL_47;
      }
      operator delete((void *)buf);
      if (v22) {
        goto LABEL_46;
      }
    }
    else
    {
      long long v24 = buf;
      v87->__r_.__value_.__r.__words[2] = v99;
      *(_OWORD *)&v23->__r_.__value_.__l.__data_ = v24;
      uint64_t v87 = v23 + 1;
      if (v22) {
        goto LABEL_46;
      }
    }
LABEL_47:
    v21 += 16;
  }
  while (v21 != v20);
  v32 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    sub_100062B40(v86, v87, " ", 1uLL, &v100);
    v34 = (v100.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &v100
        : (std::string *)v100.__r_.__value_.__r.__words[0];
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = v34;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Wham Alerts (Active Tuple) :- %{public}s", (uint8_t *)&buf, 0xCu);
    if (SHIBYTE(v100.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v100.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v83 = 0;
  unsigned int v84 = 0;
  uint64_t v85 = 0;
  sub_101093CD4(&v83, v92, v93, (v93 - v92) >> 4);
  uint64_t v35 = v83;
  uint64_t v36 = v84;
  while (v35 != v36)
  {
    long long v37 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      int v38 = **v35;
      int v39 = (*v35)[1];
      LODWORD(v100.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(v100.__r_.__value_.__r.__words[0]) = v38;
      LOWORD(v100.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&v100.__r_.__value_.__r.__words[1] + 2) = v39;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Processing Wham [%u, %u]..", (uint8_t *)&v100, 0xEu);
    }
    double v40 = *(uint64_t ***)(a1 + 32);
    double v41 = *(uint64_t ***)(a1 + 40);
    while (v40 != v41)
    {
      uint64_t v43 = (*v40)[8];
      double v42 = (std::__shared_weak_count *)(*v40)[9];
      if (v42)
      {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        int v44 = *(_DWORD *)(v43 + 68);
        sub_10004D2C8(v42);
        uint64_t v43 = (*v40)[8];
        uint64_t v45 = (std::__shared_weak_count *)(*v40)[9];
        if (v45)
        {
          atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
          int v46 = *(_DWORD *)(v43 + 72);
          sub_10004D2C8(v45);
          goto LABEL_67;
        }
      }
      else
      {
        int v44 = *(_DWORD *)(v43 + 68);
      }
      int v46 = *(_DWORD *)(v43 + 72);
LABEL_67:
      if (v46 == **v35 && v44 == (*v35)[1]) {
        sub_100926F98(*v40);
      }
      v40 += 2;
    }
    v35 += 2;
  }
  v100.__r_.__value_.__r.__words[0] = (std::string::size_type)&v83;
  sub_10005CBF0((void ***)&v100);
  v100.__r_.__value_.__r.__words[0] = (std::string::size_type)&v86;
  sub_100047F64((void ***)&v100);
LABEL_73:
  unsigned int v48 = v89;
  uint64_t v47 = v90;
  if (v90 == v89) {
    goto LABEL_123;
  }
  v86 = 0;
  uint64_t v87 = 0;
  unint64_t v88 = 0;
  while (2)
  {
    v49 = (std::__shared_weak_count *)*((void *)v48 + 1);
    if (v49) {
      atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_101092D24(&buf);
    v50 = v87;
    if ((unint64_t)v87 < v88)
    {
      long long v51 = buf;
      v87->__r_.__value_.__r.__words[2] = v99;
      *(_OWORD *)&v50->__r_.__value_.__l.__data_ = v51;
      uint64_t v87 = v50 + 1;
      if (!v49) {
        goto LABEL_92;
      }
      goto LABEL_91;
    }
    unint64_t v52 = 0xAAAAAAAAAAAAAAABLL * (((char *)v87 - (char *)v86) >> 3);
    unint64_t v53 = v52 + 1;
    if (v52 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1000D8578();
    }
    if (0x5555555555555556 * ((uint64_t)(v88 - (void)v86) >> 3) > v53) {
      unint64_t v53 = 0x5555555555555556 * ((uint64_t)(v88 - (void)v86) >> 3);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v88 - (void)v86) >> 3) >= 0x555555555555555) {
      unint64_t v54 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v54 = v53;
    }
    v102 = &v88;
    if (v54) {
      unint64_t v55 = (char *)sub_10004812C((uint64_t)&v88, v54);
    }
    else {
      unint64_t v55 = 0;
    }
    std::string::size_type v56 = (std::string::size_type)&v55[24 * v52];
    v100.__r_.__value_.__r.__words[0] = (std::string::size_type)v55;
    v100.__r_.__value_.__l.__size_ = v56;
    v101 = &v55[24 * v54];
    long long v57 = buf;
    *(void *)(v56 + 16) = v99;
    *(_OWORD *)std::string::size_type v56 = v57;
    std::string::size_type v99 = 0;
    long long buf = 0uLL;
    v100.__r_.__value_.__r.__words[2] = v56 + 24;
    sub_100048204((uint64_t *)&v86, &v100);
    v58 = v87;
    sub_100048174((uint64_t)&v100);
    uint64_t v87 = v58;
    if ((SHIBYTE(v99) & 0x80000000) == 0)
    {
      if (!v49) {
        goto LABEL_92;
      }
      goto LABEL_91;
    }
    operator delete((void *)buf);
    if (v49) {
LABEL_91:
    }
      sub_10004D2C8(v49);
LABEL_92:
    v48 += 16;
    if (v48 != v47) {
      continue;
    }
    break;
  }
  uint64_t v59 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    sub_100062B40(v86, v87, " ", 1uLL, &v100);
    v61 = (v100.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &v100
        : (std::string *)v100.__r_.__value_.__r.__words[0];
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = v61;
    _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I Wham Alerts (Active Tuple - Common warning area) :- %{public}s", (uint8_t *)&buf, 0xCu);
    if (SHIBYTE(v100.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v100.__r_.__value_.__l.__data_);
    }
  }
  v80 = 0;
  uint64_t v81 = 0;
  uint64_t v82 = 0;
  sub_101093CD4(&v80, v89, v90, (v90 - v89) >> 4);
  uint64_t v63 = *(long long **)(a1 + 32);
  v62 = *(long long **)(a1 + 40);
  memset(&v100, 0, sizeof(v100));
  if (v63 != v62)
  {
    while (1)
    {
      uint64_t v65 = *(void *)(*(void *)v63 + 64);
      v64 = *(std::__shared_weak_count **)(*(void *)v63 + 72);
      if (v64)
      {
        atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
        int v66 = *(_DWORD *)(v65 + 68);
        sub_10004D2C8(v64);
        uint64_t v65 = *(void *)(*(void *)v63 + 64);
        v67 = *(std::__shared_weak_count **)(*(void *)v63 + 72);
        if (v67)
        {
          atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
          int v68 = *(_DWORD *)(v65 + 72);
          sub_10004D2C8(v67);
          goto LABEL_108;
        }
      }
      else
      {
        int v66 = *(_DWORD *)(v65 + 68);
      }
      int v68 = *(_DWORD *)(v65 + 72);
LABEL_108:
      uint64_t v69 = v80;
      char v70 = v81;
      while (v69 != v70)
      {
        v71 = *v69;
        v72 = (std::__shared_weak_count *)v69[1];
        if (v72) {
          atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v68 == *v71 && v66 == v71[1]) {
          sub_100CE9234(&v100.__r_.__value_.__l.__data_, v63);
        }
        if (v72) {
          sub_10004D2C8(v72);
        }
        v69 += 2;
      }
      if (++v63 == v62)
      {
        std::string::size_type size = v100.__r_.__value_.__l.__size_;
        for (uint64_t i = (uint64_t **)v100.__r_.__value_.__r.__words[0]; i != (uint64_t **)size; i += 2)
          sub_100926F98(*i);
        break;
      }
    }
  }
  *(void *)&long long buf = &v100;
  sub_10005CBF0((void ***)&buf);
  v100.__r_.__value_.__r.__words[0] = (std::string::size_type)&v80;
  sub_10005CBF0((void ***)&v100);
  v100.__r_.__value_.__r.__words[0] = (std::string::size_type)&v86;
  sub_100047F64((void ***)&v100);
LABEL_123:
  sub_100058DB0(__p, "After Wham handling");
  sub_1012190B8(a1, (uint64_t *)__p);
  if (v79 < 0) {
    operator delete(__p[0]);
  }
  v100.__r_.__value_.__r.__words[0] = (std::string::size_type)&v89;
  sub_10005CBF0((void ***)&v100);
  v100.__r_.__value_.__r.__words[0] = (std::string::size_type)&v92;
  sub_10005CBF0((void ***)&v100);
  v100.__r_.__value_.__r.__words[0] = (std::string::size_type)&v95;
  sub_10005CBF0((void ***)&v100);
  if (v75) {
    sub_10004D2C8(v75);
  }
}

void sub_101218F6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char ***a26,uint64_t a27,uint64_t a28,char **a29,uint64_t a30,uint64_t a31,char *a32,uint64_t a33,uint64_t a34,char a35)
{
  *(void *)(v35 - 176) = &a26;
  sub_100047F64((void ***)(v35 - 176));
  a26 = &a29;
  sub_10005CBF0((void ***)&a26);
  a29 = &a32;
  sub_10005CBF0((void ***)&a29);
  a32 = &a35;
  sub_10005CBF0((void ***)&a32);
  if (a9) {
    sub_10004D2C8(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1012190B8(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 4;
    if (*((char *)a2 + 23) < 0) {
      a2 = (uint64_t *)*a2;
    }
    int v10 = 134218242;
    uint64_t v11 = v5;
    __int16 v12 = 2082;
    uint64_t v13 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I ====== %lu Active Alerts ======(%{public}s)", (uint8_t *)&v10, 0x16u);
  }
  long long v6 = *(void ***)(a1 + 32);
  uint64_t v7 = *(void ***)(a1 + 40);
  while (v6 != v7)
  {
    long long v8 = *v6;
    v6 += 2;
    sub_100926690(v8);
  }
  int v9 = *(NSObject **)a1;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10) = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I ===============================", (uint8_t *)&v10, 2u);
  }
}

void sub_1012191D8(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v4 = *(long long **)(a1 + 32);
  uint64_t v5 = *(long long **)(a1 + 40);
  while (v4 != v5)
  {
    if (sub_100926480(*(void *)v4)) {
      sub_100CE9234((char **)a2, v4);
    }
    ++v4;
  }
  sub_100058DB0(__p, "After checking any alert for dispatch");
  sub_1012190B8(a1, (uint64_t *)__p);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10121926C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10005CBF0((void ***)&a15);
  _Unwind_Resume(a1);
}

void sub_1012192A0(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 >= *(void *)(a1 + 40)) {
    return;
  }
  uint64_t v5 = *(uint64_t **)(a1 + 32);
  while (1)
  {
    uint64_t v6 = *(void *)(*v5 + 64);
    char v7 = *(std::__shared_weak_count **)(*v5 + 72);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(_DWORD *)(v6 + 68) != *(_DWORD *)(*(void *)a2 + 68))
    {
      BOOL v10 = 0;
      if (!v7) {
        goto LABEL_11;
      }
LABEL_10:
      sub_10004D2C8(v7);
      goto LABEL_11;
    }
    uint64_t v9 = *(void *)(*v5 + 64);
    long long v8 = *(std::__shared_weak_count **)(*v5 + 72);
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v10 = *(_DWORD *)(v9 + 72) == *(_DWORD *)(*(void *)a2 + 72);
      sub_10004D2C8(v8);
      if (v7) {
        goto LABEL_10;
      }
    }
    else
    {
      BOOL v10 = *(_DWORD *)(v9 + 72) == *(_DWORD *)(*(void *)a2 + 72);
      if (v7) {
        goto LABEL_10;
      }
    }
LABEL_11:
    if (v10) {
      break;
    }
    v5 += 2;
    v2 += 16;
    if ((unint64_t)v5 >= *(void *)(a1 + 40)) {
      return;
    }
  }
  sub_100926CD4(*v5);
  uint64_t v11 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    sub_1010DDA90(__p);
    __int16 v12 = v19 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136446210;
    v21 = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %{public}s <- Alert removed", buf, 0xCu);
    if (v19 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v13 = (long long *)(v2 + 16);
  unint64_t v14 = *(long long **)(a1 + 40);
  if ((long long *)(v2 + 16) != v14)
  {
    do
    {
      long long v15 = *v13;
      *(void *)uint64_t v13 = 0;
      *((void *)v13 + 1) = 0;
      unint64_t v16 = (std::__shared_weak_count *)*((void *)v13 - 1);
      *(v13 - 1) = v15;
      if (v16) {
        sub_10004D2C8(v16);
      }
      ++v13;
    }
    while (v13 != v14);
    unint64_t v2 = (unint64_t)(v13 - 1);
    uint64_t v13 = *(long long **)(a1 + 40);
  }
  while (v13 != (long long *)v2)
  {
    v17 = (std::__shared_weak_count *)*((void *)v13 - 1);
    if (v17) {
      sub_10004D2C8(v17);
    }
    --v13;
  }
  *(void *)(a1 + 40) = v2;
}

char **sub_1012194A4(char **result, long long *a2, long long *a3, uint64_t a4)
{
  char *result = 0;
  result[1] = 0;
  result[2] = 0;
  if (a2 == a3) {
    return result;
  }
  uint64_t v6 = a2;
  char v7 = result;
  do
  {
    uint64_t v24 = 0;
    long long v22 = 0u;
    long long v23 = 0u;
    sub_100927274((uint64_t)&v22, *(void *)v6 + 80);
    long long v8 = (void *)v23;
    if (!(void)v23) {
      goto LABEL_32;
    }
    while (1)
    {
      uint64_t v9 = v8[2];
      if (*(char *)(v9 + 63) < 0)
      {
        sub_10004FC84(__p, *(void **)(v9 + 40), *(void *)(v9 + 48));
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)(v9 + 40);
        uint64_t v21 = *(void *)(v9 + 56);
      }
      if (v21 >= 0) {
        BOOL v10 = (void *)HIBYTE(v21);
      }
      else {
        BOOL v10 = __p[1];
      }
      uint64_t v11 = (void *)*(unsigned __int8 *)(a4 + 23);
      int v12 = (char)v11;
      if ((char)v11 < 0) {
        uint64_t v11 = *(void **)(a4 + 8);
      }
      if (v10 != v11)
      {
        if (v21 < 0) {
          operator delete(__p[0]);
        }
        goto LABEL_29;
      }
      uint64_t v13 = v12 >= 0 ? (unsigned __int8 *)a4 : *(unsigned __int8 **)a4;
      if ((v21 & 0x8000000000000000) == 0) {
        break;
      }
      uint64_t v18 = __p[0];
      int v19 = memcmp(__p[0], v13, (size_t)__p[1]);
      operator delete(v18);
      if (!v19) {
        goto LABEL_31;
      }
LABEL_29:
      long long v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_32;
      }
    }
    if (HIBYTE(v21))
    {
      uint64_t v14 = 0;
      do
      {
        int v15 = *((unsigned __int8 *)__p + v14);
        int v16 = v13[v14];
      }
      while (v15 == v16 && HIBYTE(v21) - 1 != v14++);
      if (v15 != v16) {
        goto LABEL_29;
      }
    }
LABEL_31:
    sub_100CE9234(v7, v6);
LABEL_32:
    uint64_t result = (char **)sub_1009277A8((uint64_t)&v22);
    ++v6;
  }
  while (v6 != a3);
  return result;
}

void sub_10121961C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1009277A8((uint64_t)va);
  sub_10005CBF0((void ***)va);
  _Unwind_Resume(a1);
}

void sub_101219648(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void ***)(a1 + 32);
  uint64_t v4 = *(void ***)(a1 + 40);
  if (v3 == v4) {
    goto LABEL_16;
  }
  while (1)
  {
    uint64_t v6 = (*v3)[8];
    char v7 = (std::__shared_weak_count *)(*v3)[9];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(_DWORD *)(v6 + 68) != *(_DWORD *)(*(void *)a2 + 68))
    {
      BOOL v10 = 0;
      if (!v7) {
        goto LABEL_10;
      }
LABEL_9:
      sub_10004D2C8(v7);
      goto LABEL_10;
    }
    uint64_t v9 = (*v3)[8];
    long long v8 = (std::__shared_weak_count *)(*v3)[9];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v10 = *(_DWORD *)(v9 + 72) == *(_DWORD *)(*(void *)a2 + 72);
      sub_10004D2C8(v8);
      if (v7) {
        goto LABEL_9;
      }
    }
    else
    {
      BOOL v10 = *(_DWORD *)(v9 + 72) == *(_DWORD *)(*(void *)a2 + 72);
      if (v7) {
        goto LABEL_9;
      }
    }
LABEL_10:
    if (v10) {
      break;
    }
    v3 += 2;
    if (v3 == v4) {
      goto LABEL_16;
    }
  }
  sub_100926BDC(*v3);
LABEL_16:
  sub_100058DB0(__p, "After alert dispatch");
  sub_1012190B8(a1, (uint64_t *)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
}

void sub_101219768(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101219784(uint64_t a1@<X0>, unint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v2 = *(uint64_t **)(a1 + 32);
  for (uint64_t i = *(uint64_t **)(a1 + 40); v2 != i; v2 += 2)
  {
    uint64_t v5 = *v2;
    if (*(void *)(*v2 + 104))
    {
      uint64_t v7 = *(void *)(v5 + 64);
      uint64_t v6 = *(void *)(v5 + 72);
      *(void *)&long long v8 = v7;
      *((void *)&v8 + 1) = v6;
      if (v6) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
      }
      sub_101219834(a2, &v8);
      if (*((void *)&v8 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
      }
    }
  }
}

void sub_101219810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10005CBF0(&a9);
  _Unwind_Resume(a1);
}

unint64_t *sub_101219834(unint64_t *result, long long *a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  uint64_t v5 = (void *)result[1];
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v8 = *result;
    uint64_t v9 = (uint64_t)((uint64_t)v5 - *result) >> 4;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60) {
      sub_10006A748();
    }
    uint64_t v11 = v4 - v8;
    if (v11 >> 3 > v10) {
      unint64_t v10 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    long long v22 = result + 2;
    if (v12 >> 60) {
      sub_10006A7CC();
    }
    uint64_t v13 = (char *)operator new(16 * v12);
    uint64_t v14 = &v13[16 * v9];
    long long v15 = *a2;
    *(_OWORD *)uint64_t v14 = *a2;
    if (*((void *)&v15 + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v15 + 1) + 8), 1uLL, memory_order_relaxed);
      unint64_t v8 = *v3;
      uint64_t v5 = (void *)v3[1];
    }
    uint64_t v7 = v14 + 16;
    if (v5 == (void *)v8)
    {
      int64x2_t v17 = vdupq_n_s64(v8);
    }
    else
    {
      do
      {
        long long v16 = *((_OWORD *)v5 - 1);
        v5 -= 2;
        *((_OWORD *)v14 - 1) = v16;
        v14 -= 16;
        void *v5 = 0;
        v5[1] = 0;
      }
      while (v5 != (void *)v8);
      int64x2_t v17 = *(int64x2_t *)v3;
    }
    unint64_t *v3 = (unint64_t)v14;
    v3[1] = (unint64_t)v7;
    int64x2_t v20 = v17;
    unint64_t v18 = v3[2];
    v3[2] = (unint64_t)&v13[16 * v12];
    unint64_t v21 = v18;
    uint64_t v19 = v17.i64[0];
    uint64_t result = (unint64_t *)sub_10019E528((uint64_t)&v19);
  }
  else
  {
    void *v5 = *(void *)a2;
    uint64_t v6 = *((void *)a2 + 1);
    v5[1] = v6;
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v7 = v5 + 2;
  }
  v3[1] = (unint64_t)v7;
  return result;
}

uint64_t sub_101219978(void *a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t v23 = 0;
  long long v21 = 0u;
  long long v22 = 0u;
  sub_101216F90((uint64_t)&v21, *(void **)(a2 + 32), *(void **)(a2 + 40));
  for (uint64_t i = (void *)v22; i; uint64_t i = (void *)*i)
  {
    uint64_t v7 = i[2];
    if (*(char *)(v7 + 63) < 0)
    {
      sub_10004FC84(__p, *(void **)(v7 + 40), *(void *)(v7 + 48));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(v7 + 40);
      uint64_t v25 = *(void *)(v7 + 56);
    }
    if (v25 >= 0) {
      unint64_t v8 = (void *)HIBYTE(v25);
    }
    else {
      unint64_t v8 = __p[1];
    }
    uint64_t v9 = (void *)a3[23];
    int v10 = (char)v9;
    if ((char)v9 < 0) {
      uint64_t v9 = (void *)*((void *)a3 + 1);
    }
    if (v8 == v9)
    {
      if (v10 >= 0) {
        uint64_t v11 = a3;
      }
      else {
        uint64_t v11 = *(unsigned __int8 **)a3;
      }
      if (v25 < 0)
      {
        long long v16 = __p[0];
        int v17 = memcmp(__p[0], v11, (size_t)__p[1]);
        operator delete(v16);
        if (!v17) {
          goto LABEL_31;
        }
      }
      else
      {
        if (!HIBYTE(v25)) {
          goto LABEL_31;
        }
        uint64_t v12 = 0;
        do
        {
          int v13 = *((unsigned __int8 *)__p + v12);
          int v14 = v11[v12];
        }
        while (v13 == v14 && HIBYTE(v25) - 1 != v12++);
        if (v13 == v14)
        {
LABEL_31:
          uint64_t v20 = i[3];
          *a1 = i[2];
          a1[1] = v20;
          if (v20) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
          }
          return sub_1009277A8((uint64_t)&v21);
        }
      }
    }
    else if (v25 < 0)
    {
      operator delete(__p[0]);
    }
  }
  unint64_t v18 = *(NSObject **)a2;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    if ((char)a3[23] < 0) {
      a3 = *(unsigned __int8 **)a3;
    }
    LODWORD(__p[0]) = 136446210;
    *(void **)((char *)__p + 4) = a3;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%{public}s Failed to match shape...", (uint8_t *)__p, 0xCu);
  }
  *a1 = 0;
  a1[1] = 0;
  return sub_1009277A8((uint64_t)&v21);
}

void sub_101219B64(_Unwind_Exception *exception_object)
{
}

void sub_101219B80(uint64_t a1, void **a2)
{
  unint64_t v2 = a2;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    int v17 = a2[2];
  }
  unint64_t v18 = 0;
  uint64_t v19 = 0;
  sub_101219978(&v18, a1, (unsigned __int8 *)__p);
  if (SHIBYTE(v17) < 0) {
    operator delete(__p[0]);
  }
  unint64_t v4 = v18;
  if (v18)
  {
    int v13 = 0;
    int v14 = 0;
    uint64_t v15 = 0;
    if (*((char *)v2 + 23) < 0)
    {
      sub_10004FC84(__dst, *v2, (unint64_t)v2[1]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v2;
      uint64_t v12 = v2[2];
    }
    sub_1012194A4(&v13, *(long long **)(a1 + 32), *(long long **)(a1 + 40), (uint64_t)__dst);
    if (SHIBYTE(v12) < 0) {
      operator delete(__dst[0]);
    }
    if (v14 == v13)
    {
      unint64_t v8 = *(NSObject **)a1;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        if (*((char *)v2 + 23) < 0) {
          unint64_t v2 = (void **)*v2;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v2;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Empty Alert for :- %{public}s", buf, 0xCu);
      }
    }
    else
    {
      sub_100F90574(v4);
      uint64_t v5 = v19;
      uint64_t v19 = 0;
      if (v5) {
        sub_10004D2C8(v5);
      }
      uint64_t v6 = (uint64_t *)v13;
      uint64_t v7 = (uint64_t *)v14;
      while (v6 != v7)
      {
        sub_100927104(*v6);
        v6 += 2;
      }
      sub_100058DB0(v9, "After monitoring-did-start");
      sub_1012190B8(a1, (uint64_t *)v9);
      if (v10 < 0) {
        operator delete(v9[0]);
      }
    }
    *(void *)long long buf = &v13;
    sub_10005CBF0((void ***)buf);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
}

void sub_101219D68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  v32 = *(std::__shared_weak_count **)(v30 - 72);
  if (v32) {
    sub_10004D2C8(v32);
  }
  _Unwind_Resume(exception_object);
}

void sub_101219DEC(uint64_t a1, void **a2)
{
  unint64_t v2 = a2;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    v34 = a2[2];
  }
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  sub_101219978(&v35, a1, (unsigned __int8 *)__p);
  if (SHIBYTE(v34) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v4 = v35;
  if (v35)
  {
    uint64_t v30 = 0;
    v31 = 0;
    uint64_t v32 = 0;
    if (*((char *)v2 + 23) < 0)
    {
      sub_10004FC84(__dst, *v2, (unint64_t)v2[1]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v2;
      std::string::size_type v29 = v2[2];
    }
    sub_1012194A4(&v30, *(long long **)(a1 + 32), *(long long **)(a1 + 40), (uint64_t)__dst);
    if (SHIBYTE(v29) < 0) {
      operator delete(__dst[0]);
    }
    if (v31 == v30)
    {
      int v14 = *(NSObject **)a1;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        if (*((char *)v2 + 23) < 0) {
          unint64_t v2 = (void **)*v2;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v2;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Empty Alert for :- %{public}s", buf, 0xCu);
      }
      goto LABEL_46;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
    uint64_t v6 = ServiceMap;
    if (v7 < 0)
    {
      unint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        uint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
    if (v11)
    {
      uint64_t v12 = v11[3];
      int v13 = (std::__shared_weak_count *)v11[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        long long v22 = v13;
        sub_10004D2C8(v13);
        char v23 = 0;
LABEL_25:
        long long v16 = v30;
        for (uint64_t i = v31; v16 != i; v16 += 16)
        {
          uint64_t v18 = *(void *)(*(void *)v16 + 64);
          int v17 = *(std::__shared_weak_count **)(*(void *)v16 + 72);
          if (v17) {
            atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v19 = *(NSObject **)a1;
          if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            sub_1010DDA90(buf);
            uint64_t v20 = buf;
            if (v38 < 0) {
              uint64_t v20 = *(unsigned char **)buf;
            }
            *(_DWORD *)int v39 = 136446210;
            double v40 = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %{public}s will be dispatched because of geofence error", v39, 0xCu);
            if (v38 < 0) {
              operator delete(*(void **)buf);
            }
          }
          uint64_t v26 = v18;
          unint64_t v27 = v17;
          if (v17) {
            atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(uint64_t, uint64_t *))(*(void *)v12 + 128))(v12, &v26);
          if (v27) {
            sub_10004D2C8(v27);
          }
          sub_100926BDC(*(void **)v16);
          if (v17) {
            sub_10004D2C8(v17);
          }
        }
        sub_100F902A8(v4);
        long long v21 = v36;
        uint64_t v36 = 0;
        if (v21) {
          sub_10004D2C8(v21);
        }
        sub_100058DB0(v24, "After geofence-setup-error");
        sub_1012190B8(a1, (uint64_t *)v24);
        if (v25 < 0) {
          operator delete(v24[0]);
        }
        if ((v23 & 1) == 0) {
          sub_10004D2C8(v22);
        }
LABEL_46:
        *(void *)long long buf = &v30;
        sub_10005CBF0((void ***)buf);
        goto LABEL_47;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    std::mutex::unlock(v6);
    long long v22 = 0;
    char v23 = 1;
    goto LABEL_25;
  }
LABEL_47:
  if (v36) {
    sub_10004D2C8(v36);
  }
}

void sub_10121A1A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,std::__shared_weak_count *a42)
{
  if (a42) {
    sub_10004D2C8(a42);
  }
  _Unwind_Resume(exception_object);
}

void sub_10121A274(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = (uint64_t **)a2;
  v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, (void *)*a2, a2[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v30 = a2[2];
  }
  sub_1012194A4(&v31, *(long long **)(a1 + 32), *(long long **)(a1 + 40), (uint64_t)__p);
  if (SHIBYTE(v30) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v4 = v31;
  uint64_t v24 = v32;
  if (v32 != v31)
  {
    while (1)
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
      uint64_t v6 = ServiceMap;
      if (v7 < 0)
      {
        unint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v9 = 5381;
        do
        {
          uint64_t v7 = v9;
          unsigned int v10 = *v8++;
          uint64_t v9 = (33 * v9) ^ v10;
        }
        while (v10);
      }
      std::mutex::lock(ServiceMap);
      *(void *)v34 = v7;
      uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)v34);
      if (v11)
      {
        uint64_t v13 = v11[3];
        uint64_t v12 = (std::__shared_weak_count *)v11[4];
        if (v12)
        {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v6);
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v12);
          char v14 = 0;
          goto LABEL_15;
        }
      }
      else
      {
        uint64_t v13 = 0;
      }
      std::mutex::unlock(v6);
      uint64_t v12 = 0;
      char v14 = 1;
LABEL_15:
      uint64_t v15 = *(void *)v4;
      uint64_t v17 = *(void *)(*(void *)v4 + 64);
      long long v16 = *(std::__shared_weak_count **)(*(void *)v4 + 72);
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v15 = *(void *)v4;
      }
      uint64_t v18 = *(void *)(v15 + 104);
      uint64_t v19 = *(NSObject **)a1;
      BOOL v20 = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT);
      if (v18)
      {
        if (v20)
        {
          sub_1010DDA90(v34);
          long long v21 = v34;
          if (v35 < 0) {
            long long v21 = *(unsigned char **)v34;
          }
          *(_DWORD *)long long buf = 136446210;
          long long v37 = v21;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %{public}s will be dispatched because of monitoring failure", buf, 0xCu);
          if (v35 < 0) {
            operator delete(*(void **)v34);
          }
        }
        uint64_t v27 = v17;
        v28 = v16;
        if (v16) {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v13 + 128))(v13, &v27);
        if (v28) {
          sub_10004D2C8(v28);
        }
        sub_100926BDC(*(void **)v4);
      }
      else if (v20)
      {
        sub_1010DDA90(v34);
        long long v22 = v34;
        if (v35 < 0) {
          long long v22 = *(unsigned char **)v34;
        }
        *(_DWORD *)long long buf = 136446210;
        long long v37 = v22;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %{public}s is inactive.. no action for monitoringDidFail", buf, 0xCu);
        if (v35 < 0)
        {
          operator delete(*(void **)v34);
          if (!v16) {
            goto LABEL_34;
          }
LABEL_33:
          sub_10004D2C8(v16);
          goto LABEL_34;
        }
      }
      if (v16) {
        goto LABEL_33;
      }
LABEL_34:
      if ((v14 & 1) == 0) {
        sub_10004D2C8(v12);
      }
      v4 += 16;
      if (v4 == v24)
      {
        sub_100058DB0(v25, "After monitoring-did-fail");
        sub_1012190B8(a1, (uint64_t *)v25);
        if (v26 < 0) {
          operator delete(v25[0]);
        }
        goto LABEL_43;
      }
    }
  }
  char v23 = *(NSObject **)a1;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)v2 + 23) < 0) {
      unint64_t v2 = (uint64_t **)*v2;
    }
    *(_DWORD *)v34 = 136446210;
    *(void *)&v34[4] = v2;
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Empty Alert for :- %{public}s", v34, 0xCu);
  }
LABEL_43:
  *(void *)v34 = &v31;
  sub_10005CBF0((void ***)v34);
}

void sub_10121A610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
}

void sub_10121A6C4(uint64_t a1, void **a2, int a3)
{
  uint64_t v4 = a2;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v19 = a2[2];
  }
  uint64_t v20 = 0;
  long long v21 = 0;
  sub_101219978(&v20, a1, (unsigned __int8 *)__p);
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v6 = v20;
  if (v20)
  {
    uint64_t v15 = 0;
    long long v16 = 0;
    uint64_t v17 = 0;
    if (*((char *)v4 + 23) < 0)
    {
      sub_10004FC84(__dst, *v4, (unint64_t)v4[1]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v4;
      char v14 = v4[2];
    }
    sub_1012194A4(&v15, *(long long **)(a1 + 32), *(long long **)(a1 + 40), (uint64_t)__dst);
    if (SHIBYTE(v14) < 0) {
      operator delete(__dst[0]);
    }
    if (v16 == v15)
    {
      unsigned int v10 = *(NSObject **)a1;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        if (*((char *)v4 + 23) < 0) {
          uint64_t v4 = (void **)*v4;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v4;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Empty Alert for :- %{public}s", buf, 0xCu);
      }
    }
    else
    {
      sub_100F909DC(v6, a3);
      uint64_t v7 = v21;
      long long v21 = 0;
      if (v7) {
        sub_10004D2C8(v7);
      }
      unint64_t v8 = v15;
      uint64_t v9 = v16;
      while (v8 != v9)
      {
        sub_1009271B0(*(void **)v8);
        v8 += 16;
      }
      sub_100058DB0(v11, "After determine-state");
      sub_1012190B8(a1, (uint64_t *)v11);
      if (v12 < 0) {
        operator delete(v11[0]);
      }
    }
    *(void *)long long buf = &v15;
    sub_10005CBF0((void ***)buf);
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
}

void sub_10121A8B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v32 = *(std::__shared_weak_count **)(v30 - 72);
  if (v32) {
    sub_10004D2C8(v32);
  }
  _Unwind_Resume(exception_object);
}

void sub_10121A938(uint64_t a1, void **a2)
{
  unint64_t v2 = a2;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v17 = a2[2];
  }
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  sub_101219978(&v18, a1, (unsigned __int8 *)__p);
  if (SHIBYTE(v17) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v4 = v18;
  if (v18)
  {
    uint64_t v13 = 0;
    char v14 = 0;
    uint64_t v15 = 0;
    if (*((char *)v2 + 23) < 0)
    {
      sub_10004FC84(__dst, *v2, (unint64_t)v2[1]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v2;
      char v12 = v2[2];
    }
    sub_1012194A4(&v13, *(long long **)(a1 + 32), *(long long **)(a1 + 40), (uint64_t)__dst);
    if (SHIBYTE(v12) < 0) {
      operator delete(__dst[0]);
    }
    if (v14 == v13)
    {
      unint64_t v8 = *(NSObject **)a1;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        if (*((char *)v2 + 23) < 0) {
          unint64_t v2 = (void **)*v2;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v2;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Empty Alert for :- %{public}s", buf, 0xCu);
      }
    }
    else
    {
      sub_100F906EC(v4);
      uint64_t v5 = v19;
      uint64_t v19 = 0;
      if (v5) {
        sub_10004D2C8(v5);
      }
      uint64_t v6 = v13;
      uint64_t v7 = v14;
      while (v6 != v7)
      {
        sub_1009271B0(*(void **)v6);
        v6 += 16;
      }
      sub_100058DB0(v9, "After enter-region");
      sub_1012190B8(a1, (uint64_t *)v9);
      if (v10 < 0) {
        operator delete(v9[0]);
      }
    }
    *(void *)long long buf = &v13;
    sub_10005CBF0((void ***)buf);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
}

void sub_10121AB20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v32 = *(std::__shared_weak_count **)(v30 - 72);
  if (v32) {
    sub_10004D2C8(v32);
  }
  _Unwind_Resume(exception_object);
}

void sub_10121ABA4(uint64_t a1, void **a2)
{
  unint64_t v2 = a2;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v15 = a2[2];
  }
  long long v16 = 0;
  uint64_t v17 = 0;
  sub_101219978(&v16, a1, (unsigned __int8 *)__p);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  if (v16)
  {
    sub_100F90864(v16);
    if (v17) {
      sub_10004D2C8(v17);
    }
    uint64_t v11 = 0;
    char v12 = 0;
    uint64_t v13 = 0;
    if (*((char *)v2 + 23) < 0)
    {
      sub_10004FC84(__dst, *v2, (unint64_t)v2[1]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v2;
      char v10 = v2[2];
    }
    sub_1012194A4(&v11, *(long long **)(a1 + 32), *(long long **)(a1 + 40), (uint64_t)__dst);
    if (SHIBYTE(v10) < 0) {
      operator delete(__dst[0]);
    }
    uint64_t v5 = v11;
    uint64_t v4 = v12;
    if (v12 == v11)
    {
      uint64_t v6 = *(NSObject **)a1;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        if (*((char *)v2 + 23) < 0) {
          unint64_t v2 = (void **)*v2;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v2;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Empty Alert for :- %{public}s", buf, 0xCu);
      }
    }
    else
    {
      do
      {
        sub_1009271B0(*(void **)v5);
        v5 += 16;
      }
      while (v5 != v4);
      sub_100058DB0(v7, "After exit-region");
      sub_1012190B8(a1, (uint64_t *)v7);
      if (v8 < 0) {
        operator delete(v7[0]);
      }
    }
    *(void *)long long buf = &v11;
    sub_10005CBF0((void ***)buf);
  }
  else if (v17)
  {
    sub_10004D2C8(v17);
  }
}

void sub_10121AD80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
}

void sub_10121AE04(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101AA15C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10121AE24(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101AA15C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_10121AE78(uint64_t a1)
{
  return sub_100924F7C((void *)(a1 + 24));
}

void sub_10121AE84(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10121B268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t a9, dispatch_object_t a10, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t object)
{
  if (object) {
    (*((void (**)(dispatch_object_t))object->isa + 1))(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_10121B42C(uint64_t a1)
{
  *(void *)a1 = off_101AA1618;
  sub_10121D7D0(*(void **)(a1 + 184));
  sub_10010C0E0(a1 + 152, *(void **)(a1 + 160));
  uint64_t v5 = (void **)(a1 + 128);
  sub_100047F64(&v5);
  uint64_t v5 = (void **)(a1 + 104);
  sub_100047F64(&v5);
  sub_10071B1CC((NotifySubscription **)(a1 + 88), 0);
  sub_10071B1CC((NotifySubscription **)(a1 + 80), 0);
  unint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ManagedConfigurationInterface::~ManagedConfigurationInterface((ManagedConfigurationInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_10121B4F8(uint64_t a1)
{
  sub_10121B42C(a1);

  operator delete();
}

void sub_10121B530(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_10121B630(uint64_t a1)
{
  uint64_t v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10121DCD0;
  v6[3] = &unk_10199E4C0;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  uint64_t v7 = objc_retainBlock(v6);
  unint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_10121DD1C;
    uint64_t v11 = &unk_10199E470;
    char v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_10121DCE0;
    uint64_t v11 = &unk_10199E470;
    char v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_sync(v2, &block);
  }
  BOOL v3 = v14 != 0;

  return v3;
}

BOOL sub_10121B788(uint64_t a1)
{
  uint64_t v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10121DD58;
  v6[3] = &unk_10199E4C0;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  uint64_t v7 = objc_retainBlock(v6);
  unint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_10121DD1C;
    uint64_t v11 = &unk_10199E470;
    char v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_10121DCE0;
    uint64_t v11 = &unk_10199E470;
    char v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_sync(v2, &block);
  }
  BOOL v3 = v14 != 0;

  return v3;
}

void sub_10121B8E0(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10121DD68;
  v6[3] = &unk_101AA1820;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  uint64_t v7 = objc_retainBlock(v6);
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_10121DE08;
    uint64_t v11 = &unk_10199E470;
    char v12 = a2;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_10121DD98;
    uint64_t v11 = &unk_10199E470;
    char v12 = a2;
    uint64_t v13 = &v7;
    dispatch_sync(v4, &block);
  }
}

BOOL sub_10121BA2C(uint64_t a1, long long *a2)
{
  uint64_t v3 = a1 + 8;
  uint64_t v7 = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v9 = *((void *)a2 + 2);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_10121DE78;
  v10[3] = &unk_10199E4C0;
  v10[4] = v3;
  v10[5] = &v7;
  uint64_t v11 = objc_retainBlock(v10);
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    unsigned __int8 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 3221225472;
    char v14 = sub_10121DD1C;
    uint64_t v15 = &unk_10199E470;
    long long v16 = &v18;
    uint64_t v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    unsigned __int8 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 3221225472;
    char v14 = sub_10121DCE0;
    uint64_t v15 = &unk_10199E470;
    long long v16 = &v18;
    uint64_t v17 = &v11;
    dispatch_sync(v4, &block);
  }
  int v5 = v18;

  if (SHIBYTE(v9) < 0) {
    operator delete((void *)__p);
  }
  return v5 != 0;
}

void sub_10121BBC4(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10121DEC0;
  v6[3] = &unk_101AA1820;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  uint64_t v7 = objc_retainBlock(v6);
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_10121DE08;
    uint64_t v11 = &unk_10199E470;
    char v12 = a2;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_10121DD98;
    uint64_t v11 = &unk_10199E470;
    char v12 = a2;
    uint64_t v13 = &v7;
    dispatch_sync(v4, &block);
  }
}

BOOL sub_10121BD10(uint64_t a1, long long *a2)
{
  uint64_t v3 = a1 + 8;
  uint64_t v7 = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v9 = *((void *)a2 + 2);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_10121DEF0;
  v10[3] = &unk_10199E4C0;
  v10[4] = v3;
  v10[5] = &v7;
  uint64_t v11 = objc_retainBlock(v10);
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    unsigned __int8 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 3221225472;
    char v14 = sub_10121DD1C;
    uint64_t v15 = &unk_10199E470;
    long long v16 = &v18;
    uint64_t v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    unsigned __int8 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 3221225472;
    char v14 = sub_10121DCE0;
    uint64_t v15 = &unk_10199E470;
    long long v16 = &v18;
    uint64_t v17 = &v11;
    dispatch_sync(v4, &block);
  }
  int v5 = v18;

  if (SHIBYTE(v9) < 0) {
    operator delete((void *)__p);
  }
  return v5 != 0;
}

BOOL sub_10121BEA8(uint64_t a1, long long *a2)
{
  uint64_t v3 = a1 + 8;
  uint64_t v7 = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v9 = *((void *)a2 + 2);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_10121DF38;
  v10[3] = &unk_10199E4C0;
  v10[4] = v3;
  v10[5] = &v7;
  uint64_t v11 = objc_retainBlock(v10);
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    unsigned __int8 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 3221225472;
    char v14 = sub_10121DD1C;
    uint64_t v15 = &unk_10199E470;
    long long v16 = &v18;
    uint64_t v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    unsigned __int8 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 3221225472;
    char v14 = sub_10121DCE0;
    uint64_t v15 = &unk_10199E470;
    long long v16 = &v18;
    uint64_t v17 = &v11;
    dispatch_sync(v4, &block);
  }
  int v5 = v18;

  if (SHIBYTE(v9) < 0) {
    operator delete((void *)__p);
  }
  return v5 != 0;
}

BOOL sub_10121C040(uint64_t a1)
{
  uint64_t v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10121DF70;
  v6[3] = &unk_10199E4C0;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  uint64_t v7 = objc_retainBlock(v6);
  unint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_10121DD1C;
    uint64_t v11 = &unk_10199E470;
    char v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_10121DCE0;
    uint64_t v11 = &unk_10199E470;
    char v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_sync(v2, &block);
  }
  BOOL v3 = v14 != 0;

  return v3;
}

BOOL sub_10121C198(uint64_t a1)
{
  uint64_t v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10121DF80;
  v6[3] = &unk_10199E4C0;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  uint64_t v7 = objc_retainBlock(v6);
  unint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_10121DD1C;
    uint64_t v11 = &unk_10199E470;
    char v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_10121DCE0;
    uint64_t v11 = &unk_10199E470;
    char v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_sync(v2, &block);
  }
  BOOL v3 = v14 != 0;

  return v3;
}

uint64_t sub_10121C2F0(uint64_t a1)
{
  uint64_t v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10121DF90;
  v6[3] = &unk_101AA1840;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  uint64_t v7 = objc_retainBlock(v6);
  unint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    unsigned __int16 v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_10121DFDC;
    uint64_t v11 = &unk_10199E470;
    char v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    unsigned __int16 v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_10121DFA0;
    uint64_t v11 = &unk_10199E470;
    char v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_sync(v2, &block);
  }
  uint64_t v3 = v14;

  return v3;
}

void sub_10121C440(void *a1, uint64_t a2, long long *a3, long long *a4)
{
  uint64_t v8 = a2;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&v9, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v9 = *a3;
    uint64_t v10 = *((void *)a3 + 2);
  }
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long __p = *a4;
    uint64_t v12 = *((void *)a4 + 2);
  }
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_10121E018;
  v13[3] = &unk_1019ADCC0;
  v13[4] = a2 + 8;
  v13[5] = &v8;
  unsigned __int16 v14 = objc_retainBlock(v13);
  uint64_t v7 = *(NSObject **)(a2 + 24);
  if (*(void *)(a2 + 32))
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v16 = 3221225472;
    uint64_t v17 = sub_10121E238;
    unsigned __int8 v18 = &unk_10199E470;
    uint64_t v19 = a1;
    uint64_t v20 = &v14;
    dispatch_async_and_wait(v7, &block);
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v16 = 3221225472;
    uint64_t v17 = sub_10121E1D4;
    unsigned __int8 v18 = &unk_10199E470;
    uint64_t v19 = a1;
    uint64_t v20 = &v14;
    dispatch_sync(v7, &block);
  }

  if (SHIBYTE(v12) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete((void *)v9);
  }
}

void sub_10121C614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10121C630(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  sub_100058DB0(__p, "DNN:");
  sub_10121C440(a3, a1, a2, (long long *)__p);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10121C69C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10121C6B8(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  sub_100058DB0(__p, "AppCategory:");
  sub_10121C440(a3, a1, a2, (long long *)__p);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10121C724(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10121C740(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  sub_1000DA470((uint64_t)&v8, a3);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10121C8E0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10121C8F0(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10121CA3C(uint64_t a1)
{
  unint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = "true";
    if (!*(unsigned char *)(a1 + 96)) {
      uint64_t v3 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    unint64_t v30 = (unint64_t)v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I eSimModificationAllowed: %s", buf, 0xCu);
    unint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "true";
    if (!*(unsigned char *)(a1 + 97)) {
      uint64_t v4 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    unint64_t v30 = (unint64_t)v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I eSimOutgoingTransferAllowed: %s", buf, 0xCu);
    unint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "true";
    if (!*(unsigned char *)(a1 + 200)) {
      uint64_t v5 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    unint64_t v30 = (unint64_t)v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I isSupervised: %s", buf, 0xCu);
    unint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = "true";
    if (!*(unsigned char *)(a1 + 201)) {
      uint64_t v6 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    unint64_t v30 = (unint64_t)v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I isRCSMessagingAllowed: %s", buf, 0xCu);
    unint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 203))
    {
      if (*(unsigned char *)(a1 + 202)) {
        char v7 = "true";
      }
      else {
        char v7 = "false";
      }
    }
    else
    {
      char v7 = "unknown";
    }
    *(_DWORD *)long long buf = 136315138;
    unint64_t v30 = (unint64_t)v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fIsSatelliteConnectionAllowed: %s", buf, 0xCu);
    unint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 112) - *(void *)(a1 + 104)) >> 3);
    *(_DWORD *)long long buf = 134217984;
    unint64_t v30 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %lu blocked bundle IDs", buf, 0xCu);
  }
  unint64_t v9 = *(void *)(a1 + 104);
  for (uint64_t i = *(void *)(a1 + 112); v9 != i; v9 += 24)
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v12 = v9;
      if (*(char *)(v9 + 23) < 0) {
        unint64_t v12 = *(void *)v9;
      }
      *(_DWORD *)long long buf = 136446210;
      unint64_t v30 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %{public}s", buf, 0xCu);
    }
  }
  unint64_t v13 = *(void *)(a1 + 128);
  uint64_t v14 = *(void *)(a1 + 136);
  if (v14 != v13)
  {
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - v13) >> 3);
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %lu managed bundle IDs", buf, 0xCu);
      unint64_t v13 = *(void *)(a1 + 128);
      uint64_t v14 = *(void *)(a1 + 136);
    }
    for (; v13 != v14; v13 += 24)
    {
      uint64_t v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v17 = v13;
        if (*(char *)(v13 + 23) < 0) {
          unint64_t v17 = *(void *)v13;
        }
        *(_DWORD *)long long buf = 136446210;
        unint64_t v30 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %{public}s", buf, 0xCu);
      }
    }
  }
  unint64_t v18 = *(void *)(a1 + 168);
  if (v18)
  {
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      unint64_t v30 = v18;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %lu managed slice bundle IDs", buf, 0xCu);
    }
    uint64_t v20 = *(void **)(a1 + 152);
    if (v20 != (void *)(a1 + 160))
    {
      do
      {
        long long v21 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          long long v22 = v20 + 4;
          if (*((char *)v20 + 55) < 0) {
            long long v22 = (void *)*v22;
          }
          char v23 = v20 + 7;
          if (*((char *)v20 + 79) < 0) {
            char v23 = (void *)*v23;
          }
          *(_DWORD *)long long buf = 136446466;
          unint64_t v30 = (unint64_t)v22;
          __int16 v31 = 2082;
          uint64_t v32 = v23;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %{public}s : %{public}s", buf, 0x16u);
        }
        uint64_t v24 = (void *)v20[1];
        if (v24)
        {
          do
          {
            char v25 = v24;
            uint64_t v24 = (void *)*v24;
          }
          while (v24);
        }
        else
        {
          do
          {
            char v25 = (void *)v20[2];
            BOOL v26 = *v25 == (void)v20;
            uint64_t v20 = v25;
          }
          while (!v26);
        }
        uint64_t v20 = v25;
      }
      while (v25 != (void *)(a1 + 160));
    }
  }
  unint64_t v27 = *(void *)(a1 + 192);
  if (v27)
  {
    v28 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      unint64_t v30 = v27;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %lu managed slice callbacks", buf, 0xCu);
    }
  }
}

void sub_10121CFD0(uint64_t a1)
{
  uint64_t v7 = 0;
  unint64_t v8 = 0;
  v12[0] = "ManagedConfiguration";
  sub_1002BFAE4(v12, (dispatch_object_t *)(a1 + 24), &v7);
  Registry::createRestModuleOneTimeUseMobileHelperConnection(&v5, *(Registry **)(a1 + 48));
  ctu::RestModule::connect();
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v3 = v7;
  unint64_t v2 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "/helper/requests/get_managed_configuration_info");
  xpc_object_t object = xpc_null_create();
  uint64_t v4 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v4 = off_101AA19F0;
  *((void *)v4 + 1) = a1;
  *((void *)v4 + 2) = v3;
  *((void *)v4 + 3) = v2;
  v12[3] = v4;
  ctu::RestModule::sendRequest();
  sub_10003F600(v12);
  xpc_release(object);
  xpc_object_t object = 0;
  if (v11 < 0) {
    operator delete(__p);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_10121D118(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10121D1B8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 128;
  if (v4 != a2 + 32) {
    sub_10005CA3C(v4, *(std::string **)(a2 + 32), *(long long **)(a2 + 40), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3));
  }
  *(unsigned char *)(a1 + 200) = *(unsigned char *)(a2 + 2);
  if (a1 + 152 != a2 + 56) {
    sub_100328AC0((uint64_t **)(a1 + 152), *(long long **)(a2 + 56), (long long *)(a2 + 64));
  }
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 136) - *(void *)(a1 + 128)) >> 3);
    uint64_t v7 = *(void *)(a1 + 168);
    int v8 = *(unsigned __int8 *)(a1 + 200);
    int v15 = 134218496;
    unint64_t v16 = v6;
    __int16 v17 = 2048;
    uint64_t v18 = v7;
    __int16 v19 = 1024;
    int v20 = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %lu managed bundleids; %lu managed slice bundleids, supervised = %d",
      (uint8_t *)&v15,
      0x1Cu);
  }
  unint64_t v9 = *(void **)(a1 + 176);
  uint64_t v10 = (void *)(a1 + 184);
  if (v9 != v10)
  {
    do
    {
      uint64_t v11 = v9[10];
      if (!v11) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t))(*(void *)v11 + 48))(v11);
      unint64_t v12 = (void *)v9[1];
      if (v12)
      {
        do
        {
          unint64_t v13 = v12;
          unint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          unint64_t v13 = (void *)v9[2];
          BOOL v14 = *v13 == (void)v9;
          unint64_t v9 = v13;
        }
        while (!v14);
      }
      unint64_t v9 = v13;
    }
    while (v13 != v10);
  }
}

void sub_10121D35C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10121D394(uint64_t a1)
{
}

uint64_t sub_10121D3B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10121D3F4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10121D420(ServiceManager::Service *this)
{
  *(void *)this = off_101AA17B0;
  unint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10121D47C(ServiceManager::Service *this)
{
  *(void *)this = off_101AA17B0;
  unint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10121D4EC@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "ManagedConfiguration");
}

unsigned char *sub_10121D4FC@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10121D53C(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_10121B530(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_10121B530(v4, 0);
}

uint64_t sub_10121D5C0()
{
  return 0;
}

uint64_t sub_10121D5C8()
{
  return 1;
}

uint64_t sub_10121D5D0()
{
  return 0;
}

void sub_10121D5DC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10121D6BC(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10121D7D0(void *a1)
{
  if (a1)
  {
    sub_10121D7D0(*a1);
    sub_10121D7D0(a1[1]);
    sub_10121D824((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_10121D824(uint64_t a1)
{
  sub_10003B34C((void *)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

uint64_t *sub_10121D874(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 64));
  sub_100088C88(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_10121D8BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10121D8D8(void **a1)
{
  uint64_t v1 = *a1;
  long long v21 = a1;
  long long v22 = v1;
  uint64_t v2 = *v1;
  sub_100058DB0(&__p, "/cc/events/dump_state");
  uint64_t v3 = operator new(0x20uLL);
  void *v3 = off_101AA1870;
  v3[1] = v2;
  v3[2] = sub_10121CA3C;
  v3[3] = 0;
  std::string::size_type v29 = v3;
  ctu::RestModule::observeEvent();
  sub_10003F600(&handler);
  if (v25 < 0) {
    operator delete(__p);
  }
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)&__p, *(Registry **)(v2 + 48));
  ctu::RestModule::connect();
  if (v24) {
    sub_10004D2C8(v24);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v4) {
    goto LABEL_14;
  }
  uint64_t v5 = *(void *)(v2 + 80);
  uint64_t v6 = *(void *)(v2 + 8);
  uint64_t v7 = std::__shared_weak_count::lock(v4);
  if (!v7) {
    goto LABEL_14;
  }
  int v8 = v7;
  atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v7);
  NotifySubscription::cancel((NotifySubscription *)v5);
  unint64_t v9 = (std::__shared_weak_count *)operator new(0x30uLL);
  v9->__shared_weak_owners_ = 0;
  v9->__shared_owners_ = 0;
  v9[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  v9->__vftable = (std::__shared_weak_count_vtbl *)off_101AA1920;
  v9[1].__shared_owners_ = v6;
  v9[1].__shared_weak_owners_ = (uint64_t)v8;
  uint64_t v10 = *(const char **)v5;
  uint64_t v11 = *(NSObject **)(v5 + 8);
  handler = _NSConcreteStackBlock;
  uint64_t v27 = 3321888768;
  v28 = sub_10121E720;
  std::string::size_type v29 = &unk_101AA18E0;
  unint64_t v30 = v9 + 1;
  __int16 v31 = v9;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v10, (int *)(v5 + 16), v11, &handler);
  if (v31) {
    sub_10004D2C8(v31);
  }
  sub_10004D2C8(v9);
  unint64_t v12 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v12
    || (v13 = *(void *)(v2 + 88), v14 = *(void *)(v2 + 8), (int v15 = std::__shared_weak_count::lock(v12)) == 0))
  {
LABEL_14:
    sub_100088B9C();
  }
  unint64_t v16 = v15;
  atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  NotifySubscription::cancel((NotifySubscription *)v13);
  __int16 v17 = (std::__shared_weak_count *)operator new(0x30uLL);
  v17->__shared_weak_owners_ = 0;
  v17->__shared_owners_ = 0;
  v17->__vftable = (std::__shared_weak_count_vtbl *)off_101AA19A0;
  v17[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  v17[1].__shared_owners_ = v14;
  v17[1].__shared_weak_owners_ = (uint64_t)v16;
  uint64_t v18 = *(const char **)v13;
  __int16 v19 = *(NSObject **)(v13 + 8);
  handler = _NSConcreteStackBlock;
  uint64_t v27 = 3321888768;
  v28 = sub_10121E85C;
  std::string::size_type v29 = &unk_101AA1960;
  unint64_t v30 = v17 + 1;
  __int16 v31 = v17;
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v18, (int *)(v13 + 16), v19, &handler);
  if (v31) {
    sub_10004D2C8(v31);
  }
  sub_10004D2C8(v17);
  sub_100088C88((uint64_t *)&v22);
  return sub_100046B58((uint64_t *)&v21);
}

void sub_10121DBC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    sub_10004D2C8(a22);
  }
  sub_10004D2C8(v22);
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10121DC50(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_10121CFD0(**a1);
  operator delete();
}

void sub_10121DCA4()
{
}

uint64_t sub_10121DCD0(uint64_t a1)
{
  return *(unsigned __int8 *)(**(void **)(a1 + 40) + 96);
}

uint64_t sub_10121DCE0(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10121DD1C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10121DD58(uint64_t a1)
{
  return *(unsigned __int8 *)(**(void **)(a1 + 40) + 97);
}

char *sub_10121DD68@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = **(void **)(a1 + 40);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  return sub_1000302C0((char *)a2, *(long long **)(v2 + 104), *(long long **)(v2 + 112), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v2 + 112) - *(void *)(v2 + 104)) >> 3));
}

void sub_10121DD98(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v3);
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  sub_10005CBB4(v2);
  *(_OWORD *)uint64_t v2 = v3;
  v2[2] = v4;
  long long v3 = 0uLL;
  uint64_t v4 = 0;
  uint64_t v5 = (void **)&v3;
  sub_100047F64(&v5);
}

void sub_10121DE08(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v3);
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  sub_10005CBB4(v2);
  *(_OWORD *)uint64_t v2 = v3;
  v2[2] = v4;
  long long v3 = 0uLL;
  uint64_t v4 = 0;
  uint64_t v5 = (void **)&v3;
  sub_100047F64(&v5);
}

BOOL sub_10121DE78(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 ***)(a1 + 40);
  uint64_t v2 = *v1;
  return sub_1000D8740(*((void *)*v1 + 13), *((void *)*v1 + 14), v1 + 1) != *((void *)v2 + 14);
}

char *sub_10121DEC0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = **(void **)(a1 + 40);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  return sub_1000302C0((char *)a2, *(long long **)(v2 + 128), *(long long **)(v2 + 136), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v2 + 136) - *(void *)(v2 + 128)) >> 3));
}

BOOL sub_10121DEF0(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 ***)(a1 + 40);
  uint64_t v2 = *v1;
  return sub_1000D8740(*((void *)*v1 + 16), *((void *)*v1 + 17), v1 + 1) != *((void *)v2 + 17);
}

BOOL sub_10121DF38(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 40);
  uint64_t v2 = (char *)*v1;
  return v2 + 160 != (char *)sub_100046F68((uint64_t)*v1 + 152, v1 + 1);
}

uint64_t sub_10121DF70(uint64_t a1)
{
  return *(unsigned __int8 *)(**(void **)(a1 + 40) + 200);
}

uint64_t sub_10121DF80(uint64_t a1)
{
  return *(unsigned __int8 *)(**(void **)(a1 + 40) + 201);
}

uint64_t sub_10121DF90(uint64_t a1)
{
  return *(unsigned __int16 *)(**(void **)(a1 + 40) + 202);
}

uint64_t sub_10121DFA0(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_WORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10121DFDC(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_WORD **)(a1 + 32) = result;
  return result;
}

std::string *sub_10121E018@<X0>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  long long v3 = *(uint64_t **)(a1 + 40);
  uint64_t v4 = (char *)*v3;
  uint64_t v5 = *v3 + 152;
  if (v4 + 160 != (char *)sub_100046F68((uint64_t)(v4 + 152), (void **)v3 + 1))
  {
    uint64_t v6 = sub_10005DDEC(v5, (void **)v3 + 1);
    uint64_t v7 = (const std::string *)v6;
    if (*((char *)v3 + 55) < 0) {
      std::string::size_type v8 = v3[5];
    }
    else {
      std::string::size_type v8 = *((unsigned __int8 *)v3 + 55);
    }
    std::string::size_type v9 = *(unsigned __int8 *)(v6 + 23);
    if ((v9 & 0x80u) != 0) {
      std::string::size_type v9 = *(void *)(v6 + 8);
    }
    if (v9 > v8)
    {
      std::string::basic_string(&__p, (const std::string *)v6, 0, v8, (std::allocator<char> *)&v22);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      uint64_t v11 = *((unsigned __int8 *)v3 + 55);
      int v12 = (char)v11;
      if ((v11 & 0x80u) != 0) {
        uint64_t v11 = v3[5];
      }
      if (size == v11)
      {
        if (v12 >= 0) {
          uint64_t v13 = (unsigned __int8 *)(v3 + 4);
        }
        else {
          uint64_t v13 = (unsigned __int8 *)v3[4];
        }
        if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
        {
          __int16 v19 = (void *)__p.__r_.__value_.__r.__words[0];
          int v20 = memcmp(__p.__r_.__value_.__l.__data_, v13, __p.__r_.__value_.__l.__size_);
          operator delete(v19);
          if (!v20) {
            return std::string::basic_string(a2, v7, v8, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__p);
          }
        }
        else
        {
          if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
            return std::string::basic_string(a2, v7, v8, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__p);
          }
          uint64_t v14 = 0;
          do
          {
            int v15 = __p.__r_.__value_.__s.__data_[v14];
            int v16 = v13[v14];
          }
          while (v15 == v16 && HIBYTE(__p.__r_.__value_.__r.__words[2]) - 1 != v14++);
          if (v15 == v16) {
            return std::string::basic_string(a2, v7, v8, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__p);
          }
        }
      }
      else if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      return (std::string *)sub_100058DB0(a2, "");
    }
  }

  return (std::string *)sub_100058DB0(a2, "");
}

__n128 sub_10121E1D4(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

__n128 sub_10121E238(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

uint64_t *sub_10121E29C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = *(void *)v1;
  __n128 v4 = (uint64_t **)(*(void *)v1 + 184);
  long long v3 = *v4;
  uint64_t v5 = v4;
  uint64_t v6 = v4;
  if (!*v4) {
    goto LABEL_10;
  }
  uint64_t v5 = (uint64_t **)(*(void *)v1 + 184);
  while (1)
  {
    while (1)
    {
      uint64_t v6 = (uint64_t **)v3;
      uint64_t v7 = v3 + 4;
      if ((sub_100046FE8((void *)(v1 + 8), (void **)v3 + 4) & 0x80) == 0) {
        break;
      }
      long long v3 = *v6;
      uint64_t v5 = v6;
      if (!*v6) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v7, (void **)(v1 + 8)) & 0x80) == 0) {
      break;
    }
    uint64_t v5 = v6 + 1;
    long long v3 = v6[1];
    if (!v3) {
      goto LABEL_10;
    }
  }
  std::string::size_type v8 = *v5;
  if (!*v5)
  {
LABEL_10:
    uint64_t v17 = 0;
    std::string::size_type v9 = (uint64_t *)operator new(0x58uLL);
    v16[0] = v9;
    v16[1] = v4;
    uint64_t v10 = v9 + 4;
    if (*(char *)(v1 + 31) < 0)
    {
      sub_10004FC84(v10, *(void **)(v1 + 8), *(void *)(v1 + 16));
    }
    else
    {
      long long v11 = *(_OWORD *)(v1 + 8);
      v9[6] = *(void *)(v1 + 24);
      *(_OWORD *)uint64_t v10 = v11;
    }
    v9[10] = 0;
    LOBYTE(v17) = 1;
    *std::string::size_type v9 = 0;
    v9[1] = 0;
    v9[2] = (uint64_t)v6;
    NSObject *v5 = v9;
    uint64_t v12 = **(void **)(v2 + 176);
    if (v12)
    {
      *(void *)(v2 + 176) = v12;
      std::string::size_type v9 = *v5;
    }
    sub_100046C90(*(uint64_t **)(v2 + 184), v9);
    ++*(void *)(v2 + 192);
    std::string::size_type v8 = (uint64_t *)v16[0];
    v16[0] = 0;
    sub_10121E488((uint64_t)v16);
  }
  sub_1003351AC(v8 + 7, v1 + 32);
  sub_10121E428(&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_10121E3FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_10121E488((uint64_t)va2);
  sub_10121E428((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_10121E428(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    sub_10003B34C((void *)(v1 + 32));
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

void sub_10121E488(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10121D824((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

uint64_t *sub_10121E4E0(void **a1)
{
  uint64_t v1 = *a1;
  int v16 = a1;
  uint64_t v17 = v1;
  __n128 v4 = (void *)*v1;
  uint64_t v2 = (void **)(v1 + 1);
  uint64_t v3 = v4;
  uint64_t v5 = v4 + 23;
  uint64_t v6 = (void *)v4[23];
  if (v6)
  {
    uint64_t v7 = v5;
    do
    {
      char v8 = sub_100046FE8(v6 + 4, v2);
      if (v8 >= 0) {
        std::string::size_type v9 = v6;
      }
      else {
        std::string::size_type v9 = v6 + 1;
      }
      if (v8 >= 0) {
        uint64_t v7 = v6;
      }
      uint64_t v6 = (void *)*v9;
    }
    while (*v9);
    if (v7 != v5 && (sub_100046FE8(v2, (void **)v7 + 4) & 0x80) == 0)
    {
      uint64_t v10 = (void *)v7[1];
      if (v10)
      {
        do
        {
          long long v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v12 = v7;
        do
        {
          long long v11 = (void *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          uint64_t v12 = v11;
        }
        while (!v13);
      }
      if ((void *)v3[22] == v7) {
        v3[22] = v11;
      }
      uint64_t v14 = (uint64_t *)v3[23];
      --v3[24];
      sub_10005EE6C(v14, v7);
      sub_10121D824((uint64_t)(v7 + 4));
      operator delete(v7);
    }
  }
  sub_1001102C4((uint64_t *)&v17);
  return sub_100046B58((uint64_t *)&v16);
}

void sub_10121E5EC()
{
}

__n128 sub_10121E600(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101AA1870;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10121E654(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA1870;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10121E68C(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10121E6D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10121E714()
{
}

void sub_10121E720(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    __n128 v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (v1[1]) {
        sub_10121CFD0(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10121E794(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10121E7A8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10121E7C4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10121E7D4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101AA1920;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10121E7F4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101AA1920;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10121E848(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10121E85C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    __n128 v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (v1[1])
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        v16[0] = "ManagedConfiguration";
        sub_1002BFAE4(v16, (dispatch_object_t *)(v3 + 24), &v11);
        Registry::createRestModuleOneTimeUseMobileHelperConnection(&v9, *(Registry **)(v3 + 48));
        ctu::RestModule::connect();
        if (v10) {
          sub_10004D2C8(v10);
        }
        uint64_t v6 = v11;
        uint64_t v7 = v12;
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058DB0(&__p, "/helper/requests/get_managed_configuration_info");
        xpc_object_t object = xpc_null_create();
        char v8 = (char *)operator new(0x20uLL);
        *(void *)char v8 = off_101AA1A70;
        *((void *)v8 + 1) = v3;
        *((void *)v8 + 2) = v6;
        *((void *)v8 + 3) = v7;
        v16[3] = v8;
        ctu::RestModule::sendRequest();
        sub_10003F600(v16);
        xpc_release(object);
        xpc_object_t object = 0;
        if (v15 < 0) {
          operator delete(__p);
        }
        if (v12) {
          sub_10004D2C8(v12);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10121EA10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10121EAB8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10121EAD4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10121EAE4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101AA19A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10121EB04(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101AA19A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10121EB58(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void *sub_10121EB6C(void *a1)
{
  *a1 = off_101AA19F0;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10121EBB8(void *a1)
{
  *a1 = off_101AA19F0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_10121EC24(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101AA19F0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10121EC88(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101AA19F0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10121ECC8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10121ECD8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_10121ED18(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  v32[2] = (void *)257;
  char v38 = 0;
  int v39 = 0;
  long long v37 = &v38;
  rest::read_rest_value();
  int v25 = 257;
  unsigned __int8 v26 = 0;
  long long v27 = 0u;
  uint64_t v28 = 0;
  long long v34 = 0uLL;
  long long v33 = 0uLL;
  long long v29 = 0uLL;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v30 = 0;
  __int16 v31 = &v38;
  v32[0] = v38;
  v32[1] = v39;
  if (v39)
  {
    v38[2] = v32;
    long long v37 = &v38;
    char v38 = 0;
    int v39 = 0;
  }
  else
  {
    __int16 v31 = v32;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  __n128 v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    rest::asString();
    uint64_t v5 = v43 >= 0 ? v40 : *(unsigned char **)v40;
    LODWORD(buf[0]) = 136315138;
    *(xpc_object_t *)((char *)buf + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I UPD get_managed_configuration_info: %s", (uint8_t *)buf, 0xCu);
    if (SHIBYTE(v43) < 0) {
      operator delete(*(void **)v40);
    }
  }
  *(_WORD *)(v3 + 96) = v25;
  if ((long long *)(v3 + 104) != &v27) {
    sub_10005CA3C(v3 + 104, (std::string *)v27, *((long long **)&v27 + 1), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v27 + 1) - v27) >> 3));
  }
  int v6 = HIBYTE(v25);
  *(unsigned char *)(v3 + 201) = HIBYTE(v25);
  *(_WORD *)(v3 + 202) = v26 | 0x100;
  uint64_t v7 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    char v8 = "true";
    if (*(unsigned char *)(v3 + 96)) {
      uint64_t v9 = "true";
    }
    else {
      uint64_t v9 = "false";
    }
    int v10 = *(unsigned __int8 *)(v3 + 97);
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v3 + 112) - *(void *)(v3 + 104)) >> 3);
    *(_DWORD *)double v40 = 136315906;
    if (v10) {
      uint64_t v12 = "true";
    }
    else {
      uint64_t v12 = "false";
    }
    *(void *)&v40[4] = v9;
    __int16 v41 = 2080;
    if (!v6) {
      char v8 = "false";
    }
    double v42 = v12;
    __int16 v43 = 2048;
    unint64_t v44 = v11;
    __int16 v45 = 2080;
    int v46 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I eSimModificationAllowed: %s - eSimOutgoingTransferAllowed: %s - %lu blocked bundleids - isRCSMessagingAllowed: %s", v40, 0x2Au);
  }
  sub_10121D1B8(v3, (uint64_t)&v25);
  if (!*(unsigned char *)(v3 + 96))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(v3 + 96), *(Registry **)(v3 + 48));
    uint64_t v14 = ServiceMap;
    if (v15 < 0)
    {
      int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    *(void *)double v40 = v15;
    __int16 v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)v40);
    if (v19)
    {
      uint64_t v21 = v19[3];
      int v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        if (!v21) {
          goto LABEL_29;
        }
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    int v20 = 0;
    char v22 = 1;
    if (!v21)
    {
LABEL_29:
      char v23 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)double v40 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "No followupController", v40, 2u);
      }
      goto LABEL_34;
    }
LABEL_33:
    (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 24))(v21, 3);
LABEL_34:
    if ((v22 & 1) == 0) {
      sub_10004D2C8(v20);
    }
  }
  sub_100058DB0(v40, "/cc/events/managed_configuration_changed");
  buf[0] = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(buf[0]);
  buf[0] = 0;
  if (SHIBYTE(v43) < 0) {
    operator delete(*(void **)v40);
  }
  sub_10010C0E0((uint64_t)&v31, v32[0]);
  *(void *)double v40 = &v29;
  sub_100047F64((void ***)v40);
  *(void *)double v40 = &v27;
  sub_100047F64((void ***)v40);
  sub_10010C0E0((uint64_t)&v37, v38);
  *(void *)double v40 = (char *)&v34 + 8;
  sub_100047F64((void ***)v40);
  *(void *)double v40 = &v33;
  sub_100047F64((void ***)v40);
  xpc_release(object);
}

void sub_10121F190(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32)
{
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v33);
  }
  sub_10010C0E0(a10, a20);
  sub_100047F64((void ***)&a32);
  sub_100047F64((void ***)&a32);
  sub_10010C0E0(v34, a30);
  sub_100047F64((void ***)&a32);
  sub_100047F64((void ***)&a32);
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_10121F260(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10121F2A0()
{
}

void *sub_10121F2AC(void *a1)
{
  *a1 = off_101AA1A70;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10121F2F8(void *a1)
{
  *a1 = off_101AA1A70;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_10121F364(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101AA1A70;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10121F3C8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101AA1A70;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10121F408(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10121F418(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_10121F458(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  v11[2] = (void *)257;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  BOOL v13 = &v14;
  rest::read_rest_value();
  int v4 = 257;
  char v5 = 0;
  long long v6 = 0u;
  uint64_t v7 = 0;
  memset(v12, 0, sizeof(v12));
  long long v8 = 0uLL;
  uint64_t v9 = 0;
  int v10 = &v14;
  v11[0] = v14;
  v11[1] = v15;
  if (v15)
  {
    v14[2] = v11;
    BOOL v13 = &v14;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
  }
  else
  {
    int v10 = v11;
  }
  sub_10121D1B8(*(void *)(a1 + 8), (uint64_t)&v4);
  sub_10010C0E0((uint64_t)&v10, v11[0]);
  int v16 = (void **)&v8;
  sub_100047F64(&v16);
  int v16 = (void **)&v6;
  sub_100047F64(&v16);
  sub_10010C0E0((uint64_t)&v13, v14);
  int v16 = (void **)&v12[1] + 1;
  sub_100047F64(&v16);
  int v16 = (void **)v12;
  sub_100047F64(&v16);
  xpc_release(object);
}

void sub_10121F5C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  sub_10010C0E0(v29, a18);
  *(void *)(v34 - 88) = v33;
  sub_100047F64((void ***)(v34 - 88));
  *(void *)(v34 - 88) = v32;
  sub_100047F64((void ***)(v34 - 88));
  sub_10010C0E0(v28, a28);
  *(void *)(v34 - 88) = v31;
  sub_100047F64((void ***)(v34 - 88));
  *(void *)(v34 - 88) = v30;
  sub_100047F64((void ***)(v34 - 88));
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_10121F630(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10121F670()
{
}

uint64_t sub_10121F67C()
{
  return byte_101B13350;
}

uint64_t sub_10121F6B4()
{
  return byte_101B13351;
}

uint64_t sub_10121F6EC()
{
  return ((byte_101B13350 | byte_101B13351) != 0) | (byte_101B13352 | byte_101B13353) & 1u;
}

uint64_t sub_10121F74C()
{
  return byte_101B13352;
}

uint64_t sub_10121F784()
{
  return byte_101B13353;
}

void sub_10121F7BC()
{
  *(_OWORD *)values = *(_OWORD *)off_101AA1AE0;
  CFStringRef v23 = @"ReleaseType";
  CFArrayRef v0 = CFArrayCreate(kCFAllocatorDefault, (const void **)values, 3, &kCFTypeArrayCallBacks);
  if (v0)
  {
    CFArrayRef v1 = v0;
    CFDictionaryRef v2 = (const __CFDictionary *)MGCopyMultipleAnswers();
    if (!v2)
    {
LABEL_24:
      CFRelease(v1);
      return;
    }
    CFDictionaryRef v3 = v2;
    Value = (void *)CFDictionaryGetValue(v2, @"CarrierInstallCapability");
    if (Value)
    {
      char v5 = Value;
      CFTypeID v6 = CFGetTypeID(Value);
      if (v6 == CFBooleanGetTypeID())
      {
        unsigned __int8 v21 = 0;
        CFTypeID v7 = CFGetTypeID(v5);
        CFTypeID TypeID = CFBooleanGetTypeID();
        char v10 = 0;
        if (v7 == TypeID)
        {
          ctu::cf::assign((ctu::cf *)&v21, (BOOL *)v5, v9);
          char v10 = v21;
        }
        byte_101B13351 = v10;
      }
    }
    unint64_t v11 = (void *)CFDictionaryGetValue(v3, @"InternalBuild");
    if (v11 && (uint64_t v12 = v11, v13 = CFGetTypeID(v11), v13 == CFBooleanGetTypeID()))
    {
      unsigned __int8 v21 = 0;
      CFTypeID v14 = CFGetTypeID(v12);
      CFTypeID v15 = CFBooleanGetTypeID();
      int v17 = 0;
      if (v14 == v15)
      {
        ctu::cf::assign((ctu::cf *)&v21, (BOOL *)v12, v16);
        int v17 = v21;
      }
      byte_101B13350 = v17;
      if (v17) {
        goto LABEL_23;
      }
    }
    else if (byte_101B13350)
    {
LABEL_23:
      CFRelease(v3);
      goto LABEL_24;
    }
    CFStringRef v18 = (const __CFString *)CFDictionaryGetValue(v3, @"ReleaseType");
    if (v18)
    {
      CFStringRef v19 = v18;
      CFTypeID v20 = CFGetTypeID(v18);
      if (v20 == CFStringGetTypeID())
      {
        if (CFStringCompare(v19, @"Desense", 0))
        {
          if (CFStringCompare(v19, @"Vendor", 0))
          {
            if (CFEqual(v19, @"VendorNonUI")) {
              byte_101B13353 = 1;
            }
          }
          else
          {
            byte_101B13352 = 1;
          }
        }
        else
        {
          byte_101B13350 = 1;
        }
      }
    }
    goto LABEL_23;
  }
}

void stewie::TargetFactory::create(uint64_t *a1@<X0>, os_log_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = *a1;
  if (v5)
  {
    *(_OWORD *)char v10 = 0u;
    long long v11 = 0u;
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v5 + 16))(v10);
    if (BYTE8(v11))
    {
      v9[0] = 0;
      v9[1] = 0;
      *(void *)long long v8 = v9;
      if (*(void *)v10 != *(void *)&v10[8]) {
        stewie::TargetData::create();
      }
      operator new();
    }
    CFTypeID v7 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to create targetCoords", v8, 2u);
    }
    *a3 = 0;
    a3[1] = 0;
    if (BYTE8(v11))
    {
      *(void *)long long v8 = v10;
      sub_100DDE4A0((void ***)v8);
    }
  }
  else
  {
    CFTypeID v6 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v10 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "targetCoordsFactory must be provided", v10, 2u);
    }
    *a3 = 0;
    a3[1] = 0;
  }
}

void sub_10121FD50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11, void *a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18)
{
  (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  sub_100119D90(a12);
  if (a18)
  {
    a11 = (void **)&a15;
    sub_100DDE4A0(&a11);
  }
  _Unwind_Resume(a1);
}

void sub_10121FDD0(void *a1)
{
  long long v51 = 0;
  uint64_t v52 = 0;
  v50 = &v51;
  CFDictionaryRef v2 = (void *)a1[4];
  if (v2)
  {
    CFDictionaryRef v3 = (void *)*v2;
    if ((void *)*v2 != v2 + 1)
    {
      do
      {
        int v4 = *((_DWORD *)v3 + 7);
        uint64_t v5 = &v51;
        CFTypeID v6 = &v51;
        if (!v51) {
          goto LABEL_11;
        }
        unsigned int v7 = *((_DWORD *)v3 + 8);
        long long v8 = v51;
        do
        {
          while (1)
          {
            CFTypeID v6 = (uint64_t **)v8;
            unsigned int v9 = *((_DWORD *)v8 + 7);
            if (v9 <= v7) {
              break;
            }
            long long v8 = *v6;
            uint64_t v5 = v6;
            if (!*v6) {
              goto LABEL_11;
            }
          }
          if (v9 >= v7)
          {
            char v10 = v6;
            goto LABEL_15;
          }
          long long v8 = v6[1];
        }
        while (v8);
        uint64_t v5 = v6 + 1;
LABEL_11:
        char v10 = operator new(0x28uLL);
        v10[7] = *((_DWORD *)v3 + 8);
        v10[8] = 0;
        *(void *)char v10 = 0;
        *((void *)v10 + 1) = 0;
        *((void *)v10 + 2) = v6;
        void *v5 = (uint64_t *)v10;
        long long v11 = (uint64_t *)v10;
        if (*v50)
        {
          v50 = (uint64_t **)*v50;
          long long v11 = *v5;
        }
        sub_100046C90(v51, v11);
        ++v52;
LABEL_15:
        v10[8] = v4;
        uint64_t v12 = (void *)v3[1];
        if (v12)
        {
          do
          {
            CFTypeID v13 = v12;
            uint64_t v12 = (void *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            CFTypeID v13 = (void *)v3[2];
            BOOL v14 = *v13 == (void)v3;
            CFDictionaryRef v3 = v13;
          }
          while (!v14);
        }
        CFDictionaryRef v3 = v13;
      }
      while (v13 != (void *)(a1[4] + 8));
    }
  }
  unsigned int v48 = 0;
  uint64_t v49 = 0;
  uint64_t v47 = &v48;
  CFTypeID v15 = (void *)a1[1];
  if (v15 == a1 + 2) {
LABEL_68:
  }
    stewie::Targets::create();
  while (1)
  {
    uint64_t v16 = a1[4];
    if (v16)
    {
      uint64_t v19 = *(void *)(v16 + 8);
      uint64_t v17 = v16 + 8;
      uint64_t v18 = v19;
      if (v19)
      {
        unsigned int v20 = *((_DWORD *)v15 + 8);
        uint64_t v21 = v17;
        do
        {
          unsigned int v22 = *(_DWORD *)(v18 + 28);
          BOOL v23 = v22 >= v20;
          if (v22 >= v20) {
            uint64_t v24 = (uint64_t *)v18;
          }
          else {
            uint64_t v24 = (uint64_t *)(v18 + 8);
          }
          if (v23) {
            uint64_t v21 = v18;
          }
          uint64_t v18 = *v24;
        }
        while (*v24);
        if (v21 != v17 && v20 >= *(_DWORD *)(v21 + 28))
        {
          unint64_t v34 = (unint64_t)*(unsigned int *)(v21 + 32) << 32;
          char v33 = 1;
          goto LABEL_45;
        }
      }
      int v25 = v51;
      if (v51)
      {
        unsigned int v26 = *((_DWORD *)v15 + 8);
        long long v27 = &v51;
        do
        {
          uint64_t v28 = v25;
          uint64_t v29 = v27;
          unsigned int v30 = *((_DWORD *)v25 + 7);
          uint64_t v31 = (uint64_t **)(v25 + 1);
          if (v30 >= v26)
          {
            uint64_t v31 = (uint64_t **)v28;
            long long v27 = (uint64_t **)v28;
          }
          int v25 = *v31;
        }
        while (v25);
        if (v27 != &v51)
        {
          uint64_t v32 = v30 >= v26 ? v28 : (uint64_t *)v29;
          if (v26 >= *((_DWORD *)v32 + 7))
          {
            if (v30 >= v26) {
              int v46 = (unsigned int *)v28;
            }
            else {
              int v46 = (unsigned int *)v29;
            }
            char v33 = 1;
            unint64_t v34 = ((unint64_t)v46[8] << 32) | 1;
            goto LABEL_45;
          }
        }
      }
    }
    char v33 = 0;
    unint64_t v34 = 0;
LABEL_45:
    unsigned int v35 = *((_DWORD *)v15 + 8);
    uint64_t v36 = (char *)operator new(0x28uLL);
    long long v37 = v36;
    *((void *)v36 + 1) = 0;
    *((void *)v36 + 2) = 0;
    *(void *)uint64_t v36 = off_101AA1BC8;
    *((_DWORD *)v36 + 6) = v35;
    char v38 = v36 + 24;
    *(void *)(v36 + 28) = v34;
    v36[36] = v33;
    *(_WORD *)(v36 + 37) = 0;
    v36[39] = 0;
    int v39 = &v48;
    double v40 = &v48;
    __int16 v41 = v48;
    if (!v48) {
      goto LABEL_52;
    }
    do
    {
      while (1)
      {
        double v40 = (uint64_t **)v41;
        unsigned int v42 = *((_DWORD *)v41 + 8);
        if (v42 <= v35) {
          break;
        }
        __int16 v41 = *v40;
        int v39 = v40;
        if (!*v40) {
          goto LABEL_52;
        }
      }
      if (v42 >= v35)
      {
        sub_10004D2C8((std::__shared_weak_count *)v36);
        goto LABEL_56;
      }
      __int16 v41 = v40[1];
    }
    while (v41);
    int v39 = v40 + 1;
LABEL_52:
    __int16 v43 = operator new(0x38uLL);
    v43[8] = v35;
    *((void *)v43 + 5) = v38;
    *((void *)v43 + 6) = v37;
    *(void *)__int16 v43 = 0;
    *((void *)v43 + 1) = 0;
    *((void *)v43 + 2) = v40;
    void *v39 = (uint64_t *)v43;
    if (*v47)
    {
      uint64_t v47 = (uint64_t **)*v47;
      __int16 v43 = *v39;
    }
    sub_100046C90(v48, (uint64_t *)v43);
    ++v49;
LABEL_56:
    unint64_t v44 = (void *)v15[1];
    if (v44)
    {
      do
      {
        __int16 v45 = v44;
        unint64_t v44 = (void *)*v44;
      }
      while (v44);
    }
    else
    {
      do
      {
        __int16 v45 = (void *)v15[2];
        BOOL v14 = *v45 == (void)v15;
        CFTypeID v15 = v45;
      }
      while (!v14);
    }
    CFTypeID v15 = v45;
    if (v45 == a1 + 2) {
      goto LABEL_68;
    }
  }
}

void sub_101220148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, void *a12, uint64_t a13, char a14, void *a15)
{
}

void sub_10122018C(uint64_t a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v5 = a1 + 16;
  uint64_t v6 = v7;
  if (!v7) {
    goto LABEL_12;
  }
  unsigned int v9 = *a2;
  uint64_t v10 = v5;
  do
  {
    unsigned int v11 = *(_DWORD *)(v6 + 32);
    BOOL v12 = v11 >= v9;
    if (v11 >= v9) {
      CFTypeID v13 = (uint64_t *)v6;
    }
    else {
      CFTypeID v13 = (uint64_t *)(v6 + 8);
    }
    if (v12) {
      uint64_t v10 = v6;
    }
    uint64_t v6 = *v13;
  }
  while (*v13);
  if (v10 != v5 && v9 >= *(_DWORD *)(v10 + 32))
  {
    uint64_t v15 = *(void *)(v10 + 40);
    BOOL v14 = *(std::__shared_weak_count **)(v10 + 48);
    uint64_t v16 = operator new(0x58uLL);
    uint64_t v17 = v16;
    v16[1] = 0;
    void v16[2] = 0;
    void *v16 = off_101AA1C18;
    uint64_t v18 = (char *)(v16 + 3);
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      v16[3] = off_1019AAF70;
      v16[4] = v15;
      v16[5] = v14;
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      long long v19 = *(_OWORD *)(a3 + 16);
      *((_OWORD *)v16 + 3) = *(_OWORD *)a3;
      *((_OWORD *)v16 + 4) = v19;
      v16[10] = *(void *)(a3 + 32);
      sub_10004D2C8(v14);
    }
    else
    {
      v16[3] = off_1019AAF70;
      v16[4] = v15;
      v16[5] = 0;
      long long v20 = *(_OWORD *)(a3 + 16);
      *((_OWORD *)v16 + 3) = *(_OWORD *)a3;
      *((_OWORD *)v16 + 4) = v20;
      v16[10] = *(void *)(a3 + 32);
    }
    *a4 = v18;
    a4[1] = v17;
  }
  else
  {
LABEL_12:
    *a4 = 0;
    a4[1] = 0;
  }
}

uint64_t sub_1012202C0(uint64_t a1)
{
  *(void *)a1 = off_101AA1B08;
  CFDictionaryRef v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100119D90(*(void **)(a1 + 16));
  return a1;
}

void sub_101220314(uint64_t a1)
{
  *(void *)a1 = off_101AA1B08;
  CFDictionaryRef v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100119D90(*(void **)(a1 + 16));

  operator delete();
}

void sub_10122038C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1012203C4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1012203F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_101220438(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101AA1BC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_101220458(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101AA1BC8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1012204B4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101AA1C18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1012204D4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101AA1C18;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101220528(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_101220550(uint64_t a1, void *a2)
{
  *a2 = 0;
  sub_10015949C();
}

void sub_1012205FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object)
{
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 8))(a11);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10122064C(uint64_t a1, void *a2)
{
  *a2 = 0;
  sub_1001049EC();
}

void sub_1012206F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object)
{
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 8))(a11);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101220748@<X0>(capabilities::ct *a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t result = capabilities::ct::getCDMASettingsSupport(a1);
  if (result == 1)
  {
    *a2 = 0;
    sub_100F80C4C();
  }
  if (result == 2)
  {
    *a2 = 0;
    sub_1011B392C();
  }
  *a3 = 0;
  a3[1] = 0;
  return result;
}

void sub_101220894(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t object, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_101220920(uint64_t a1@<X0>, NSObject **a2@<X1>, _OWORD *a3@<X8>)
{
  int v4 = (capabilities::ct *)(a1 + 8);
  uint64_t v5 = *a2;
  if (*a2) {
    dispatch_retain(v5);
  }
  sub_1003C648C(v4, &v6);
  *a3 = v6;
  long long v6 = 0uLL;
  if (v5) {
    dispatch_release(v5);
  }
}

void sub_101220990(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1012209A8(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_101020664();
}

void sub_101220A20(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101220A38(SettingsFactoryInterface *this)
{
  *(void *)this = off_101AA1C68;
  CFDictionaryRef v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  SettingsFactoryInterface::~SettingsFactoryInterface(this);
}

void sub_101220A94(SettingsFactoryInterface *this)
{
  *(void *)this = off_101AA1C68;
  CFDictionaryRef v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  SettingsFactoryInterface::~SettingsFactoryInterface(this);

  operator delete();
}

const char *sub_101220B14(PersonalitySpecificImpl *a1)
{
  if (PersonalitySpecificImpl::simSlot(a1) == 1) {
    return "DATA.tech.drv.1";
  }
  if (PersonalitySpecificImpl::simSlot(a1) == 2) {
    return "DATA.tech.drv.2";
  }
  return "DATA.tech.drv.?";
}

uint64_t *sub_101220B6C(uint64_t *a1)
{
  if (!sub_1002C7370(a1)) {
    __assert_rtn("~dynamic_bitset", "dynamic_bitset.hpp", 702, "m_check_invariants()");
  }
  CFDictionaryRef v2 = (void *)*a1;
  if (*a1)
  {
    a1[1] = (uint64_t)v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t TechDataDriver::TechDataDriver(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, void *a5, NSObject **a6)
{
  *(void *)(a1 + 1016) = off_101AA2EF8;
  *(void *)a1 = off_101AA3170;
  PersonalitySpecificImpl::PersonalitySpecificImpl();
  sub_100B77D00((uint64_t *)(a1 + 24), (uint64_t *)off_101AA2668, a2, a3);
  *(void *)a1 = off_101AA1D28;
  *(void *)(a1 + 1016) = off_101AA2408;
  *(void *)(a1 + 24) = off_101AA2080;
  unsigned int v11 = sub_101220B14((PersonalitySpecificImpl *)a1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v22, kCtLoggingSystemName, v11);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  BOOL v12 = *a6;
  *(void *)(a1 + 72) = *a6;
  if (v12) {
    dispatch_retain(v12);
  }
  *(void *)(a1 + 80) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v23, &v22);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 88), (const ctu::OsLogLogger *)v23);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v23);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v22);
  *(void *)a1 = off_101AA1D28;
  *(void *)(a1 + 1016) = off_101AA2408;
  *(void *)(a1 + 24) = off_101AA2080;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = *a5;
  uint64_t v13 = a5[1];
  *(void *)(a1 + 128) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(void *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 296) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(void *)(a1 + 304) = 3;
  BOOL v14 = (char *)sub_101220B14((PersonalitySpecificImpl *)a1);
  sub_100058DB0(&__p, v14);
  uint64_t v15 = *(NSObject **)(a1 + 72);
  long long v19 = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  uint64_t v16 = *(NSObject **)(a1 + 80);
  xpc_object_t object = v16;
  if (v16) {
    dispatch_retain(v16);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v19) {
    dispatch_release(v19);
  }
  if (v21 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 328) = 0;
  *(void *)(a1 + 336) = 0;
  *(unsigned char *)(a1 + 352) = 0;
  *(void *)(a1 + 344) = 0;
  sub_100058DB0((void *)(a1 + 360), "en0");
  *(unsigned char *)(a1 + 384) = 0;
  *(_OWORD *)(a1 + 400) = 0u;
  *(void *)(a1 + 392) = a1 + 400;
  *(_OWORD *)(a1 + 424) = 0u;
  *(void *)(a1 + 416) = a1 + 424;
  *(_OWORD *)(a1 + 440) = 0u;
  *(void *)(a1 + 456) = a1 + 456;
  *(void *)(a1 + 464) = a1 + 456;
  *(void *)(a1 + 472) = 0;
  *(void *)(a1 + 480) = a1 + 480;
  *(void *)(a1 + 488) = a1 + 480;
  *(unsigned char *)(a1 + 520) = 0;
  *(unsigned char *)(a1 + 720) = 0;
  *(_OWORD *)(a1 + 760) = 0u;
  *(_OWORD *)(a1 + 784) = 0u;
  *(unsigned char *)(a1 + 512) = 0;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_DWORD *)(a1 + 752) = 0;
  *(void *)(a1 + 744) = 0;
  *(_OWORD *)(a1 + 728) = 0u;
  *(void *)(a1 + 776) = a1 + 784;
  *(_DWORD *)(a1 + 800) = 0;
  *(unsigned char *)(a1 + 804) = 1;
  *(unsigned char *)(a1 + 808) = 0;
  *(unsigned char *)(a1 + 832) = 0;
  *(void *)(a1 + 848) = 0;
  *(void *)(a1 + 856) = 0;
  *(void *)(a1 + 840) = a1 + 848;
  *(void *)(a1 + 872) = 0;
  *(void *)(a1 + 880) = 0;
  *(void *)(a1 + 864) = a1 + 872;
  *(unsigned char *)(a1 + 889) = 1;
  *(void *)(a1 + 904) = 0;
  *(void *)(a1 + 912) = 0;
  *(void *)(a1 + 896) = a1 + 904;
  *(void *)(a1 + 936) = 0;
  *(void *)(a1 + 928) = 0;
  *(void *)(a1 + 920) = a1 + 928;
  *(void *)(a1 + 960) = 0;
  *(void *)(a1 + 952) = 0;
  *(void *)(a1 + 944) = a1 + 952;
  *(void *)(a1 + 968) = kDefaultT911Preferences;
  *(unsigned char *)(a1 + 976) = 0;
  *(void *)(a1 + 1000) = 0;
  *(void *)(a1 + 992) = 0;
  *(void *)(a1 + 984) = a1 + 992;
  *(unsigned char *)(a1 + 1008) = 0;
  return a1;
}

void sub_101220F6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, dispatch_object_t object, dispatch_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  sub_10008A88C((void ***)&a19);
  uint64_t v29 = (std::__shared_weak_count *)*((void *)v21 + 40);
  if (v29) {
    sub_10004D2C8(v29);
  }
  sub_1008FDE68((void *)v21 + 33);
  sub_101220B6C(v28);
  sub_101220B6C(v27);
  sub_101220B6C(v26);
  sub_101220B6C(v25);
  unsigned int v30 = (std::__shared_weak_count *)*((void *)v21 + 16);
  if (v30) {
    sub_10004D2C8(v30);
  }
  sub_10005CBF0((void ***)&a19);
  ctu::OsLogLogger::~OsLogLogger(v24);
  sub_100087E88(v23);
  sub_100B77DF4(v22, (uint64_t *)off_101AA2668);
  PersonalitySpecificImpl::~PersonalitySpecificImpl(v21);
  PersonalitySpecific::~PersonalitySpecific(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_101221078(PersonalitySpecificImpl *a1)
{
  uint64_t v1 = *((void *)a1 + 6);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = PersonalitySpecificImpl::simSlot(a1);
  CFDictionaryRef v3 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v1 + 376);

  return v3(v1, v2);
}

uint64_t sub_1012210F0(void *a1)
{
  return sub_101221078((PersonalitySpecificImpl *)((char *)a1 + *(void *)(*a1 - 168)));
}

void TechDataDriver::init(TechDataDriver *this)
{
  uint64_t v2 = *((void *)this + 11);
  BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    int buf = 136315138;
    buf_4 = "init";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: TechDataDriver initializing.", (uint8_t *)&buf, 0xCu);
  }
  unint64_t v4 = capabilities::ct::supportedPDPContextCount((capabilities::ct *)v3);
  if (v4 >> 31) {
    __assert_rtn("init", "IWLANDataDriver.cpp", 165, "capabilities::ct::supportedPDPContextCount() <= std::numeric_limits<int>::max()");
  }
  int v5 = capabilities::ct::supportedPDPContextCount((capabilities::ct *)v4);
  int v6 = v5;
  if (*((void *)this + 6) && v5 >= 1)
  {
    (*(void (**)(uint64_t *__return_ptr, TechDataDriver *))(*(void *)this + 16))(&v9, this);
    if (*((void *)this + 9)) {
      dispatch_retain(*((dispatch_object_t *)this + 9));
    }
    (*(void (**)(uint64_t *__return_ptr, char *, void))(*((void *)this + 3) + 248))(&v8, (char *)this + 24, 0);
    uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 8);
    if (v7)
    {
      if (std::__shared_weak_count::lock(v7)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  sub_10019E028((uint64_t *)this + 12);
  sub_10122157C((char **)this + 17, (char *)v6);
  sub_10122157C((char **)this + 29, (char *)v6);
  sub_10122157C((char **)this + 21, (char *)v6);
  sub_10122157C((char **)this + 25, (char *)v6);
}

void sub_10122147C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (v13) {
    dispatch_release(v13);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_101221484(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13)
{
  sub_10004D2C8(v14);
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (v13) {
    dispatch_release(v13);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  JUMPOUT(0x101221574);
}

void sub_10122148C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, dispatch_object_t object, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (object) {
    dispatch_release(object);
  }
  operator delete();
}

void sub_101221498(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    dispatch_barrier_async_f(v2[7], v2, (dispatch_function_t)sub_10122BFFC);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_1012214CC()
{
}

void sub_10122151C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10122152C()
{
  sub_10004D2C8(v0);
  JUMPOUT(0x101221538);
}

void sub_10122157C(char **a1, char *a2)
{
  unint64_t v4 = *a1;
  int v5 = a1[1];
  uint64_t v6 = v5 - *a1;
  uint64_t v7 = a2 & 0x3F;
  if ((a2 & 0x3F) != 0) {
    unint64_t v8 = ((unint64_t)a2 >> 6) + 1;
  }
  else {
    unint64_t v8 = (unint64_t)a2 >> 6;
  }
  if (v8 == v6 >> 3) {
    goto LABEL_21;
  }
  unint64_t v9 = v8 - (v6 >> 3);
  if (v8 <= v6 >> 3)
  {
    if (v8 >= v6 >> 3) {
      goto LABEL_21;
    }
    int v5 = &v4[8 * v8];
    goto LABEL_18;
  }
  uint64_t v10 = (uint64_t)(a1 + 2);
  unsigned int v11 = a1[2];
  if (v9 <= (v11 - v5) >> 3)
  {
    bzero(v5, ((8 * v8 - v6 - 8) & 0xFFFFFFFFFFFFFFF8) + 8);
    v5 += 8 * v9;
LABEL_18:
    a1[1] = v5;
    goto LABEL_21;
  }
  uint64_t v12 = v11 - v4;
  uint64_t v13 = v12 >> 2;
  if (v12 >> 2 <= v8) {
    uint64_t v13 = v8;
  }
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v14 = v13;
  }
  uint64_t v15 = (char *)sub_10004EF74(v10, v14);
  uint64_t v17 = v16;
  unint64_t v4 = &v15[8 * (v6 >> 3)];
  bzero(v4, ((8 * v8 - v6 - 8) & 0xFFFFFFFFFFFFFFF8) + 8);
  int v5 = &v15[8 * v8];
  uint64_t v18 = *a1;
  for (uint64_t i = a1[1]; i != v18; i -= 8)
  {
    uint64_t v20 = *((void *)i - 1);
    *((void *)v4 - 1) = v20;
    v4 -= 8;
  }
  *a1 = v4;
  a1[1] = v5;
  a1[2] = &v15[8 * v17];
  if (v18)
  {
    operator delete(v18);
    unint64_t v4 = *a1;
    int v5 = a1[1];
  }
LABEL_21:
  a1[3] = a2;
  if (v8 != (v5 - v4) >> 3) {
    __assert_rtn("m_zero_unused_bits", "dynamic_bitset.hpp", 2095, "num_blocks() == calc_num_blocks(m_num_bits)");
  }
  if (v7)
  {
    if (v5 == v4) {
      __assert_rtn("m_highest_block", "dynamic_bitset.hpp", 2025, "size() > 0 && num_blocks() > 0");
    }
    *((void *)v5 - 1) &= ~(-1 << v7);
  }
}

void sub_101221720(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2)
  {
    if (std::__shared_weak_count::lock(v2))
    {
      BOOL v3 = *(NSObject **)(a1 + 72);
      dispatch_retain(v3);
      *(_OWORD *)int buf = 0u;
      long long v5 = 0u;
      dispatch_retain(v3);
      dispatch_retain(v3);
      dispatch_retain(v3);
      uint64_t v6 = 0;
      dispatch_retain(v3);
      dispatch_retain(v3);
      dispatch_retain(v3);
      dispatch_retain(v3);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1012225B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char *a26,uint64_t a27)
{
  a26 = &a11;
  sub_100047F64((void ***)&a26);
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10122299C(uint64_t a1, uint64_t a2, const std::string **a3)
{
  memset(&v31, 0, sizeof(v31));
  if (*a3 != a3[1])
  {
    uint64_t v47 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    memset(buf, 0, sizeof(buf));
    sub_10004DE24((uint64_t)buf);
    sub_10004B96C(buf, (uint64_t)" on [", 5);
    uint64_t v6 = *a3;
    uint64_t v7 = a3[1];
    if (*a3 != v7)
    {
      do
      {
        memset(&__p, 0, sizeof(__p));
        if (SHIBYTE(v6->__r_.__value_.__r.__words[2]) < 0)
        {
          sub_10004FC84(&__p, v6->__r_.__value_.__l.__data_, v6->__r_.__value_.__l.__size_);
        }
        else
        {
          long long v8 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v8;
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
        }
        unsigned int v11 = sub_10004B96C(buf, (uint64_t)p_p, size);
        sub_10004B96C(v11, (uint64_t)",", 1);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        ++v6;
      }
      while (v6 != v7);
    }
    sub_10004BC98((uint64_t)&buf[8], &__p);
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v31.__r_.__value_.__l.__data_);
    }
    std::string v31 = __p;
    std::string::size_type v12 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v12 = __p.__r_.__value_.__l.__size_;
    }
    std::string::replace(&v31, v12 - 1, 1uLL, "]", 1uLL);
    if (SHIBYTE(v36) < 0) {
      operator delete(*((void **)&v35 + 1));
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
  }
  uint64_t v13 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v14 = "false";
    if (a2) {
      unint64_t v14 = "true";
    }
    *(_DWORD *)int buf = 136315650;
    *(void *)&uint8_t buf[4] = "handleWifiAvailable_sync";
    uint64_t v15 = &v31;
    if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v15 = (std::string *)v31.__r_.__value_.__r.__words[0];
    }
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v14;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&unsigned char buf[24] = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s: available = %s %s", buf, 0x20u);
  }
  *(unsigned char *)(a1 + 976) = a2;
  int v16 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  sub_100058DB0(v28, "Wifi Changed");
  *(_DWORD *)int buf = v16;
  uint8_t buf[4] = 0;
  if (SHIBYTE(v29) < 0)
  {
    sub_10004FC84(&buf[8], v28[0], (unint64_t)v28[1]);
  }
  else
  {
    *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)v28;
    *(void *)&unsigned char buf[24] = v29;
  }
  sub_10011AE40();
  if ((char)buf[31] < 0) {
    operator delete(*(void **)&buf[8]);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[0]);
  }
  uint64_t v17 = *(void *)(a1 + 48);
  if (v17)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 152))(v17, a2);
    uint64_t v18 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 264))(*(void *)(a1 + 48));
    long long v19 = *(uint64_t **)v18;
    uint64_t v20 = *(uint64_t **)(v18 + 8);
    if (*(uint64_t **)v18 != v20)
    {
      do
      {
        uint64_t v22 = *v19;
        char v21 = (std::__shared_weak_count *)v19[1];
        if (v21) {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 16))(&v26, a1);
        (*(void (**)(uint64_t, uint64_t *, uint64_t, const std::string **))(*(void *)v22 + 360))(v22, &v26, a2, a3);
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v21) {
          sub_10004D2C8(v21);
        }
        v19 += 2;
      }
      while (v19 != v20);
    }
    memset(&__p, 0, sizeof(__p));
    if ((a2 & 1) != 0 && *a3 != a3[1])
    {
      std::string::operator=(&__p, *a3);
      BOOL v23 = *(NSObject **)(a1 + 88);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = (void *)(a1 + 360);
        if (*(char *)(a1 + 383) < 0) {
          uint64_t v24 = (void *)*v24;
        }
        int v25 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          int v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)int buf = 136315650;
        *(void *)&uint8_t buf[4] = "handleWifiAvailable_sync";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v24;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&unsigned char buf[24] = v25;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s: fWifiInterfaceName changes from %s to %s", buf, 0x20u);
      }
      std::string::operator=((std::string *)(a1 + 360), &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v31.__r_.__value_.__l.__data_);
  }
}

void sub_101222F34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  _Unwind_Resume(exception_object);
}

void sub_101222FF8(void *a1, int a2)
{
  unint64_t v4 = a1[11];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136315394;
    uint64_t v13 = "handleTechKeepAlive_sync";
    __int16 v14 = 1024;
    int v15 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: got TechKeepAlive event on pdp %d", buf, 0x12u);
  }
  uint64_t v5 = a1[6];
  if (v5)
  {
    uint64_t v10 = 0;
    unsigned int v11 = 0;
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v5 + 248))(&v10);
    uint64_t v6 = v10;
    if (v10)
    {
      (*(void (**)(uint64_t *__return_ptr, void *))(*a1 + 16))(&v8, a1);
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 368))(v6, &v8);
      if (v9) {
        sub_10004D2C8(v9);
      }
    }
    else
    {
      uint64_t v7 = a1[11];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136315394;
        uint64_t v13 = "handleTechKeepAlive_sync";
        __int16 v14 = 1024;
        int v15 = a2;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: pdp ID %d is too large, not exist.", buf, 0x12u);
      }
    }
    if (v11) {
      sub_10004D2C8(v11);
    }
  }
}

void sub_1012231CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101223200(uint64_t result, char a2)
{
  *(unsigned char *)(result + 384) = a2;
  return result;
}

void sub_101223208(PersonalitySpecificImpl *this)
{
  uint64_t v2 = (_DWORD *)*((void *)this + 41);
  BOOL v3 = (_DWORD *)*((void *)this + 42);
  if (v2 == v3)
  {
    unint64_t v4 = *((void *)this + 11);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136315138;
      *(void *)std::string __p = "handleSimsChanged_sync";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: empty sim info.", buf, 0xCu);
    }
  }
  else
  {
    while (PersonalitySpecificImpl::simSlot(this) != *v2)
    {
      v2 += 42;
      if (v2 == v3) {
        return;
      }
    }
    int isSimReady = subscriber::isSimReady();
    if (*((unsigned __int8 *)this + 352) != isSimReady)
    {
      int v6 = isSimReady;
      *((unsigned char *)this + 352) = isSimReady;
      uint64_t v7 = *((void *)this + 11);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = "NOT Ready";
        if (v6) {
          uint64_t v8 = "Ready";
        }
        *(_DWORD *)int buf = 136315394;
        *(void *)std::string __p = "handleSimsChanged_sync";
        *(_WORD *)&__p[8] = 2080;
        *(void *)&__p[10] = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: SIM state changed to %s", buf, 0x16u);
      }
      int v9 = PersonalitySpecificImpl::simSlot(this);
      sub_100058DB0(v10, "SIM State Changed");
      *(_DWORD *)int buf = v9;
      __p[0] = 0;
      if (SHIBYTE(v11) < 0)
      {
        sub_10004FC84(&__p[4], v10[0], (unint64_t)v10[1]);
      }
      else
      {
        *(_OWORD *)&__p[4] = *(_OWORD *)v10;
        uint64_t v14 = v11;
      }
      sub_10011AE40();
      if (SHIBYTE(v14) < 0) {
        operator delete(*(void **)&__p[4]);
      }
      if (SHIBYTE(v11) < 0) {
        operator delete(v10[0]);
      }
    }
  }
}

void sub_1012233F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101223430(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 889);
  (*(void (**)(uint64_t))(*(void *)a1 + 288))(a1);
  int isFaceTimeAllowedOverCellByUser = DataUtils::isFaceTimeAllowedOverCellByUser();
  *(unsigned char *)(a1 + 889) = isFaceTimeAllowedOverCellByUser;
  if (v2 != isFaceTimeAllowedOverCellByUser)
  {
    int v4 = isFaceTimeAllowedOverCellByUser;
    uint64_t v5 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = "disallows";
      *(_DWORD *)int buf = 136315650;
      *(void *)std::string __p = "handleBlocklistedApps_sync";
      *(void *)&__p[10] = "Changing iWlan allowance over cellular";
      *(_WORD *)&__p[8] = 2080;
      if (v4) {
        int v6 = "allows";
      }
      *(_WORD *)&__p[18] = 2080;
      uint64_t v22 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: %s : %s", buf, 0x20u);
    }
    if ((*(uint64_t (**)(void))(**(void **)(a1 + 120) + 56))(*(void *)(a1 + 120)))
    {
      int v7 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      sub_100058DB0(v18, "Changing iWlan allowance over cellular");
      *(_DWORD *)int buf = v7;
      __p[0] = 0;
      if (SHIBYTE(v19) < 0)
      {
        sub_10004FC84(&__p[4], v18[0], (unint64_t)v18[1]);
      }
      else
      {
        *(_OWORD *)&__p[4] = *(_OWORD *)v18;
        uint64_t v22 = v19;
      }
      sub_10011AE40();
      if (SHIBYTE(v22) < 0) {
        operator delete(*(void **)&__p[4]);
      }
      if (SHIBYTE(v19) < 0) {
        operator delete(v18[0]);
      }
      uint64_t v10 = *(void *)(a1 + 48);
      if (v10)
      {
        uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 264))(v10);
        std::string::size_type v12 = *(uint64_t **)v11;
        uint64_t v13 = *(uint64_t **)(v11 + 8);
        if (*(uint64_t **)v11 != v13)
        {
          do
          {
            uint64_t v15 = *v12;
            uint64_t v14 = (std::__shared_weak_count *)v12[1];
            if (v14) {
              atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 16))(&v16, a1);
            (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v15 + 448))(v15, &v16, *(unsigned __int8 *)(a1 + 889));
            if (v17) {
              sub_10004D2C8(v17);
            }
            if (v14) {
              sub_10004D2C8(v14);
            }
            v12 += 2;
          }
          while (v12 != v13);
        }
      }
    }
    else
    {
      uint64_t v8 = *(NSObject **)(a1 + 88);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = *(unsigned __int8 *)(a1 + 889);
        *(_DWORD *)int buf = 136315394;
        *(void *)std::string __p = "handleBlocklistedApps_sync";
        *(_WORD *)&__p[8] = 1024;
        *(_DWORD *)&__p[10] = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: iWLan over cellular data not supported. Ignore iWLan allowed over cellular data changed event. Allowed: %d", buf, 0x12u);
      }
    }
  }
}

void sub_101223754(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1012237B8(uint64_t a1, uint64_t a2)
{
  BOOL v3 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136315138;
    *(void *)&uint8_t buf[4] = "handleWiFiPreferredRoaming_sync";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: VoWiFi provisioning state change reported", buf, 0xCu);
  }
  v42[0] = 0;
  v42[1] = 0;
  uint64_t v43 = 0;
  PersonalitySpecificImpl::personalityId((uint64_t *)v42, (PersonalitySpecificImpl *)a1);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v41 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 32));
  int v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    std::string::size_type v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  std::string::size_type v12 = 0;
  char v14 = 1;
LABEL_11:
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v13 + 144))(__p, v13);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  uint64_t v15 = *(void **)(a1 + 776);
  if (v15 != (void *)(a1 + 784))
  {
    uint64_t v16 = a2 + 8;
    while (1)
    {
      uint64_t v17 = (int *)(v15 + 7);
      uint64_t v18 = *(NSObject **)(a1 + 88);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = *((unsigned __int8 *)v15 + 55);
        BOOL v20 = (v19 & 0x80u) != 0;
        if ((v19 & 0x80u) != 0) {
          uint64_t v19 = v15[5];
        }
        if (v20) {
          char v21 = (const char *)v15[4];
        }
        else {
          char v21 = (const char *)(v15 + 4);
        }
        if (v19) {
          uint64_t v22 = v21;
        }
        else {
          uint64_t v22 = "<invalid>";
        }
        uint64_t v23 = asStringBool(*((_DWORD *)v15 + 14) != 0);
        uint64_t v24 = asString();
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = "handleWiFiPreferredRoaming_sync";
        __int16 v45 = 2080;
        *(void *)long long v46 = v22;
        *(_WORD *)&v46[8] = 2080;
        uint64_t v47 = v23;
        __int16 v48 = 2080;
        uint64_t v49 = v24;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s: VoWiFi provisioning state for PersonalityID: %s - %s (config: %s)", buf, 0x2Au);
      }
      uint64_t v25 = *((unsigned __int8 *)v15 + 55);
      if ((v25 & 0x80u) != 0) {
        uint64_t v25 = v15[5];
      }
      if (v25
        && (sub_10001D294((unsigned __int8 *)v42, (unsigned __int8 *)v15 + 32)
         || sub_10001D294((unsigned __int8 *)__p, (unsigned __int8 *)v15 + 32)))
      {
        uint64_t v26 = sub_100046F68(a2, (void **)v15 + 4);
        long long v27 = v26;
        if ((void **)v16 == v26) {
          goto LABEL_42;
        }
        if (*((_DWORD *)v26 + 14) != *v17
          || *((unsigned __int8 *)v26 + 60) != *((unsigned __int8 *)v15 + 60)
          || (sub_1005A0BB8((unsigned __int8 *)v26 + 64, (unsigned __int8 *)v15 + 64) & 1) == 0)
        {
          break;
        }
      }
      uint64_t v28 = (void *)v15[1];
      if (v28)
      {
        do
        {
          uint64_t v29 = v28;
          uint64_t v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          uint64_t v29 = (void *)v15[2];
          BOOL v30 = *v29 == (void)v15;
          uint64_t v15 = v29;
        }
        while (!v30);
      }
      uint64_t v15 = v29;
      if (v29 == (void *)(a1 + 784)) {
        goto LABEL_49;
      }
    }
    uint64_t v16 = (uint64_t)v27;
LABEL_42:
    std::string v31 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v32 = asStringBool(*(_DWORD *)(v16 + 56) != 0);
      uint64_t v33 = asStringBool(*v17 != 0);
      *(_DWORD *)int buf = 136315650;
      *(void *)&uint8_t buf[4] = "handleWiFiPreferredRoaming_sync";
      __int16 v45 = 2080;
      *(void *)long long v46 = v32;
      *(_WORD *)&v46[8] = 2080;
      uint64_t v47 = v33;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s: VoWiFi provisioning state changing from %s to %s", buf, 0x20u);
    }
    int v34 = *v17;
    *(unsigned char *)(a1 + 804) = *((unsigned char *)v15 + 60);
    *(_DWORD *)(a1 + 800) = v34;
    sub_100179AF8((std::string *)(a1 + 808), (const std::string *)(v15 + 8));
    BOOL v35 = *(unsigned char *)(a1 + 804) == 0;
    int v36 = *(_DWORD *)(a1 + 516);
    if (v36 != 2 * v35)
    {
      int v37 = 2 * v35;
      long long v38 = *(NSObject **)(a1 + 88);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136315650;
        *(void *)&uint8_t buf[4] = "handleWiFiPreferredRoaming_sync";
        __int16 v45 = 1024;
        *(_DWORD *)long long v46 = v36;
        *(_WORD *)&v46[4] = 1024;
        *(_DWORD *)&v46[6] = v37;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I %s: HandOver preferred type changed from %d to %d", buf, 0x18u);
      }
      *(_DWORD *)(a1 + 516) = v37;
      if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 312))(a1) & 1) == 0) {
        sub_101226608((PersonalitySpecificImpl *)a1);
      }
    }
  }
LABEL_49:
  if (SHIBYTE(v41) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v43) < 0) {
    operator delete(v42[0]);
  }
}

void sub_101223C88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_101223CF8(uint64_t *a1)
{
}

void sub_101223D00(PersonalitySpecificImpl *a1, int *a2)
{
  int v4 = *((void *)a1 + 11);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (a2[8] == -1) {
      uint64_t v5 = "reset";
    }
    else {
      uint64_t v5 = "valid";
    }
    if (*((char *)a2 + 31) >= 0) {
      int v6 = a2 + 2;
    }
    else {
      int v6 = (int *)*((void *)a2 + 1);
    }
    *(_DWORD *)int buf = 136315906;
    uint64_t v17 = "handleAttachApnChanged_sync";
    __int16 v18 = 2080;
    uint64_t v19 = v5;
    __int16 v20 = 2080;
    char v21 = v6;
    __int16 v22 = 2080;
    uint64_t v23 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: got attachAPNChange event %s with APN name %s slot %s", buf, 0x2Au);
  }
  int v7 = *a2;
  if (v7 == PersonalitySpecificImpl::simSlot(a1))
  {
    uint64_t v8 = *((void *)a1 + 6);
    if (v8)
    {
      uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 264))(v8);
      unsigned int v10 = *(uint64_t **)v9;
      uint64_t v11 = *(uint64_t **)(v9 + 8);
      if (*(uint64_t **)v9 != v11)
      {
        do
        {
          uint64_t v13 = *v10;
          std::string::size_type v12 = (std::__shared_weak_count *)v10[1];
          if (v12) {
            atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(uint64_t *__return_ptr, PersonalitySpecificImpl *))(*(void *)a1 + 16))(&v14, a1);
          (*(void (**)(uint64_t, uint64_t, uint64_t *, void, int *, int *, int *))(*(void *)v13 + 432))(v13, 1, &v14, a2[8], a2 + 2, a2 + 11, a2 + 29);
          if (v15) {
            sub_10004D2C8(v15);
          }
          if (v12) {
            sub_10004D2C8(v12);
          }
          v10 += 2;
        }
        while (v10 != v11);
      }
    }
  }
}

void sub_101223F28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

void sub_101223F5C(uint64_t a1, void *a2)
{
  long long v47 = 0uLL;
  uint64_t v48 = 0;
  PersonalitySpecificImpl::personalityId((uint64_t *)&v47, (PersonalitySpecificImpl *)a1);
  long long v46 = 0u;
  memset(v45, 0, sizeof(v45));
  sub_10122DBF8((uint64_t)v43, (void *)(a1 + 896));
  if (SHIBYTE(v48) < 0)
  {
    sub_10004FC84(&__p, (void *)v47, *((unint64_t *)&v47 + 1));
  }
  else
  {
    long long __p = v47;
    uint64_t v42 = v48;
  }
  int v4 = sub_100046F68((uint64_t)v43, (void **)&__p);
  if (&v44 == (void **)v4)
  {
    char v5 = 0;
    LOBYTE(v45[0]) = 0;
  }
  else
  {
    sub_1001A90AC((char *)v45, (long long *)(v4 + 7));
    char v5 = 1;
  }
  BYTE8(v46) = v5;
  if (SHIBYTE(v42) < 0) {
    operator delete((void *)__p);
  }
  sub_10019D460((uint64_t)v43, v44);
  long long v40 = 0u;
  memset(v39, 0, sizeof(v39));
  sub_10122DBF8((uint64_t)v37, a2);
  if (SHIBYTE(v48) < 0)
  {
    sub_10004FC84(__dst, (void *)v47, *((unint64_t *)&v47 + 1));
  }
  else
  {
    *(_OWORD *)long long __dst = v47;
    uint64_t v36 = v48;
  }
  int v6 = sub_100046F68((uint64_t)v37, __dst);
  if (&v38 == (void **)v6)
  {
    char v7 = 0;
    v39[0] = 0;
  }
  else
  {
    sub_1001A90AC(v39, (long long *)(v6 + 7));
    char v7 = 1;
  }
  BYTE8(v40) = v7;
  if (SHIBYTE(v36) < 0) {
    operator delete(__dst[0]);
  }
  sub_10019D460((uint64_t)v37, v38);
  uint64_t v8 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = HIBYTE(v48);
    if (v48 < 0) {
      uint64_t v9 = *((void *)&v47 + 1);
    }
    unsigned int v10 = (const char *)&v47;
    if (v48 < 0) {
      unsigned int v10 = (const char *)v47;
    }
    if (v9) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = "<invalid>";
    }
    int v12 = BYTE8(v40);
    if (BYTE8(v40))
    {
      uint64_t v13 = v33;
      sub_1005933FC((uint64_t)v39, v33);
      if (v34 < 0) {
        uint64_t v13 = (void **)v33[0];
      }
    }
    else
    {
      uint64_t v13 = (void **)"<empty>";
    }
    if (BYTE8(v46))
    {
      sub_1005933FC((uint64_t)v45, v31);
      if (v32 >= 0) {
        uint64_t v14 = v31;
      }
      else {
        uint64_t v14 = (void **)v31[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"handleImsInfoReadyChanged_sync";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v11;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      v50 = v13;
      __int16 v51 = 2080;
      uint64_t v52 = (const char *)v14;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: IMSInfo: %s: old: %s, new: %s", (uint8_t *)&buf, 0x2Au);
      if (v32 < 0) {
        operator delete(v31[0]);
      }
    }
    else
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"handleImsInfoReadyChanged_sync";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v11;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      v50 = v13;
      __int16 v51 = 2080;
      uint64_t v52 = "<empty>";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: IMSInfo: %s: old: %s, new: %s", (uint8_t *)&buf, 0x2Au);
    }
    if (v12 && v34 < 0) {
      operator delete(v33[0]);
    }
  }
  int v15 = BYTE8(v46);
  int v16 = BYTE8(v40);
  if (!BYTE8(v46) || !BYTE8(v40))
  {
    if ((BYTE8(v46) != 0) == (BYTE8(v40) != 0)) {
      goto LABEL_89;
    }
    goto LABEL_45;
  }
  if ((sub_100592DE4((unsigned __int8 *)v45, (unsigned __int8 *)v39) & 1) == 0)
  {
    int v15 = BYTE8(v46);
LABEL_45:
    uint64_t v17 = (void *)(a1 + 520);
    if (*(unsigned __int8 *)(a1 + 720) == v15)
    {
      if (*(unsigned char *)(a1 + 720)) {
        sub_1001A9310(a1 + 520, (uint64_t)v45);
      }
    }
    else
    {
      if (*(unsigned char *)(a1 + 720))
      {
        sub_10019D50C(a1 + 520);
        char v18 = 0;
      }
      else
      {
        sub_1001A90AC((char *)(a1 + 520), v45);
        char v18 = 1;
      }
      *(unsigned char *)(a1 + 720) = v18;
    }
    if (*(char *)(a1 + 751) < 0)
    {
      **(unsigned char **)(a1 + 728) = 0;
      *(void *)(a1 + 736) = 0;
    }
    else
    {
      *(unsigned char *)(a1 + 728) = 0;
      *(unsigned char *)(a1 + 751) = 0;
    }
    if (*(unsigned char *)(a1 + 720))
    {
      uint64_t v19 = (void **)(a1 + 592);
      if (*(char *)(a1 + 615) < 0)
      {
        char v21 = *(char **)(a1 + 592);
        int64_t v20 = *(void *)(a1 + 600);
      }
      else
      {
        int64_t v20 = *(unsigned __int8 *)(a1 + 615);
        char v21 = (char *)(a1 + 592);
      }
      __int16 v22 = (void **)(a1 + 728);
      if (v20 >= 1)
      {
        uint64_t v23 = &v21[v20];
        uint64_t v24 = v21;
        do
        {
          uint64_t v25 = (char *)memchr(v24, 64, v20);
          if (!v25) {
            break;
          }
          if (*v25 == 64)
          {
            if (v25 == v23) {
              std::string::size_type v26 = -1;
            }
            else {
              std::string::size_type v26 = v25 - v21;
            }
            if (v26 - 1 > 0xFFFFFFFFFFFFFFFDLL) {
              break;
            }
            std::string::basic_string(&buf, (const std::string *)(a1 + 592), 0, v26, (std::allocator<char> *)v31);
            if (*(char *)(a1 + 751) < 0) {
              operator delete(*v22);
            }
            *(_OWORD *)__int16 v22 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
            *(void *)(a1 + 744) = *((void *)&buf.__r_.__value_.__l + 2);
            goto LABEL_73;
          }
          uint64_t v24 = v25 + 1;
          int64_t v20 = v23 - (unsigned char *)v24;
        }
        while (v23 - (unsigned char *)v24 >= 1);
      }
      std::string::operator=((std::string *)(a1 + 728), (const std::string *)(a1 + 592));
LABEL_73:
      long long v27 = *(NSObject **)(a1 + 88);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 543) < 0) {
          uint64_t v17 = (void *)*v17;
        }
        if (*(char *)(a1 + 615) < 0) {
          uint64_t v19 = (void **)*v19;
        }
        if (*(char *)(a1 + 751) < 0) {
          __int16 v22 = (void **)*v22;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"handleImsInfoReadyChanged_sync";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v17;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
        v50 = v19;
        __int16 v51 = 2080;
        uint64_t v52 = (const char *)v22;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I %s: imsi: '%s', impi: '%s', fImpiUser: '%s'", (uint8_t *)&buf, 0x2Au);
      }
    }
    int v28 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    sub_100058DB0(v29, "Received IMPI");
    LODWORD(buf.__r_.__value_.__l.__data_) = v28;
    buf.__r_.__value_.__s.__data_[4] = 0;
    if (SHIBYTE(v30) < 0)
    {
      sub_10004FC84(&buf.__r_.__value_.__s.__data_[8], v29[0], (unint64_t)v29[1]);
    }
    else
    {
      *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = *(_OWORD *)v29;
      v50 = v30;
    }
    sub_10011AE40();
    if (SHIBYTE(v50) < 0) {
      operator delete((void *)buf.__r_.__value_.__l.__size_);
    }
    if (SHIBYTE(v30) < 0) {
      operator delete(v29[0]);
    }
  }
  int v16 = BYTE8(v40);
LABEL_89:
  if (v16) {
    sub_10019D50C((uint64_t)v39);
  }
  if (BYTE8(v46)) {
    sub_10019D50C((uint64_t)v45);
  }
  if (SHIBYTE(v48) < 0) {
    operator delete((void *)v47);
  }
}

void sub_101224560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  if (a50) {
    sub_10019D50C((uint64_t)&a25);
  }
  if (LOBYTE(STACK[0x248])) {
    sub_10019D50C((uint64_t)&a57);
  }
  if (*(char *)(v57 - 129) < 0) {
    operator delete(*(void **)(v57 - 152));
  }
  _Unwind_Resume(a1);
}

void sub_101224664(PersonalitySpecificImpl *this, uint64_t a2)
{
  int v2 = (char *)*((void *)this + 115);
  BOOL v3 = (char *)this + 928;
  if (v2 != (char *)this + 928)
  {
    char v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      int v7 = *((_DWORD *)v2 + 8);
      uint64_t v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < v7;
        if (v9 >= v7) {
          uint64_t v11 = (uint64_t *)v6;
        }
        else {
          uint64_t v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_15;
      }
      if ((rest::operator==() & 1) == 0) {
        break;
      }
LABEL_20:
      int v15 = (char *)*((void *)v2 + 1);
      if (v15)
      {
        do
        {
          int v16 = v15;
          int v15 = *(char **)v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          int v16 = (char *)*((void *)v2 + 2);
          BOOL v17 = *(void *)v16 == (void)v2;
          int v2 = v16;
        }
        while (!v17);
      }
      int v2 = v16;
      if (v16 == v3) {
        return;
      }
    }
    int v7 = *((_DWORD *)v2 + 8);
LABEL_15:
    if (PersonalitySpecificImpl::simSlot(this) == v7)
    {
      int v12 = v2[109];
      if (*((unsigned __int8 *)this + 1008) != v12)
      {
        *((unsigned char *)this + 1008) = v12;
        uint64_t v13 = *((void *)this + 11);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = asStringBool(v12 != 0);
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v19 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Is serving network satellite system changed to: %s", buf, 0xCu);
        }
        sub_101226608(this);
      }
    }
    goto LABEL_20;
  }
}

void sub_101224800(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 48))
  {
    int v2 = (PersonalitySpecificImpl *)a1;
    BOOL v3 = *(void **)(a1 + 944);
    if (*(void *)(a1 + 960) == a2[2])
    {
      uint64_t v4 = a1 + 952;
      if (v3 == (void *)(a1 + 952)) {
        return;
      }
      char v5 = (void *)*a2;
      while (*((_DWORD *)v3 + 8) == *((_DWORD *)v5 + 8))
      {
        a1 = operator==();
        if (!a1) {
          break;
        }
        uint64_t v6 = (void *)v3[1];
        int v7 = v3;
        if (v6)
        {
          do
          {
            BOOL v3 = v6;
            uint64_t v6 = (void *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            BOOL v3 = (void *)v7[2];
            BOOL v8 = *v3 == (void)v7;
            int v7 = v3;
          }
          while (!v8);
        }
        int v9 = (void *)v5[1];
        if (v9)
        {
          do
          {
            BOOL v10 = v9;
            int v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            BOOL v10 = (void *)v5[2];
            BOOL v8 = *v10 == (void)v5;
            char v5 = v10;
          }
          while (!v8);
        }
        char v5 = v10;
        if (v3 == (void *)v4) {
          return;
        }
      }
      BOOL v3 = (void *)*((void *)v2 + 118);
    }
    if (v3 != (void *)((char *)v2 + 952))
    {
      do
      {
        if (!*((unsigned char *)v3 + 68))
        {
          a1 = capabilities::ct::supportsGemini((capabilities::ct *)a1);
          if (!a1 || (int v13 = *((_DWORD *)v3 + 8), a1 = PersonalitySpecificImpl::simSlot(v2), v13 != a1))
          {
            int v14 = *((_DWORD *)v3 + 16);
            int v15 = *((_DWORD *)v2 + 188);
            if (v14 != v15)
            {
              int v16 = *((void *)v2 + 11);
              a1 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
              if (a1)
              {
                uint64_t v17 = asString();
                uint64_t v18 = asString();
                uint64_t v19 = subscriber::asString();
                *(_DWORD *)std::string buf = 136315650;
                uint64_t v33 = v17;
                __int16 v34 = 2080;
                uint64_t v35 = v18;
                __int16 v36 = 2080;
                uint64_t v37 = v19;
                _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I connectionState update: (change states): fInternetConnectionState: from %s to %s (%s)", buf, 0x20u);
                int v15 = *((_DWORD *)v2 + 188);
                int v14 = *((_DWORD *)v3 + 16);
              }
              *((_DWORD *)v2 + 188) = v14;
              if (v14 == 2)
              {
                a1 = (*(uint64_t (**)(void))(**((void **)v2 + 6) + 264))(*((void *)v2 + 6));
                int64_t v20 = *(uint64_t **)a1;
                char v21 = *(uint64_t **)(a1 + 8);
                while (v20 != v21)
                {
                  uint64_t v23 = *v20;
                  __int16 v22 = (std::__shared_weak_count *)v20[1];
                  if (v22) {
                    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  (*(void (**)(uint64_t *__return_ptr, PersonalitySpecificImpl *))(*(void *)v2 + 16))(&v30, v2);
                  (*(void (**)(uint64_t, uint64_t *))(*(void *)v23 + 336))(v23, &v30);
                  a1 = (uint64_t)v31;
                  if (v31) {
                    sub_10004D2C8(v31);
                  }
                  if (v22) {
                    sub_10004D2C8(v22);
                  }
                  v20 += 2;
                }
              }
              else if (v15 == 2)
              {
                a1 = (*(uint64_t (**)(void))(**((void **)v2 + 6) + 264))(*((void *)v2 + 6));
                uint64_t v25 = *(uint64_t **)a1;
                uint64_t v24 = *(uint64_t **)(a1 + 8);
                while (v25 != v24)
                {
                  uint64_t v27 = *v25;
                  std::string::size_type v26 = (std::__shared_weak_count *)v25[1];
                  if (v26) {
                    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  (*(void (**)(uint64_t *__return_ptr, PersonalitySpecificImpl *))(*(void *)v2 + 16))(&v28, v2);
                  (*(void (**)(uint64_t, uint64_t *))(*(void *)v27 + 344))(v27, &v28);
                  a1 = (uint64_t)v29;
                  if (v29) {
                    sub_10004D2C8(v29);
                  }
                  if (v26) {
                    sub_10004D2C8(v26);
                  }
                  v25 += 2;
                }
              }
            }
          }
        }
        uint64_t v11 = (void *)v3[1];
        if (v11)
        {
          do
          {
            int v12 = v11;
            uint64_t v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            int v12 = (void *)v3[2];
            BOOL v8 = *v12 == (void)v3;
            BOOL v3 = v12;
          }
          while (!v8);
        }
        BOOL v3 = v12;
      }
      while (v12 != (void *)((char *)v2 + 952));
    }
  }
}

void sub_101224BF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_101224C38(void *a1)
{
}

void sub_101224C58(void *a1)
{
  uint64_t v2 = a1[15];
  int v3 = (*(uint64_t (**)(void *))(*a1 + 312))(a1);
  *((_DWORD *)a1 + 129) = (*(uint64_t (**)(uint64_t, void))(*(void *)v2 + 88))(v2, v3 ^ 1u);
  uint64_t v4 = a1[6];
  if (v4)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 264))(v4);
    uint64_t v6 = *(uint64_t **)v5;
    int v7 = *(uint64_t **)(v5 + 8);
    while (v6 != v7)
    {
      uint64_t v8 = *v6;
      v6 += 2;
      (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 24))(v8, 1);
    }
  }
  sub_101223208((PersonalitySpecificImpl *)a1);
  int v9 = a1[11];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 136315138;
    uint64_t v11 = "startTechDriver";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s: started", (uint8_t *)&v10, 0xCu);
  }
}

void sub_101224DDC(void *a1)
{
}

void sub_101224DFC(uint64_t a1)
{
  *(void *)a1 = off_101AA1D28;
  *(void *)(a1 + 1016) = off_101AA2408;
  uint64_t v2 = (uint64_t *)(a1 + 24);
  *(void *)(a1 + 24) = off_101AA2080;
  sub_1000886C0(a1 + 984, *(char **)(a1 + 992));
  sub_1000886C0(a1 + 944, *(char **)(a1 + 952));
  sub_10003FB28(a1 + 920, *(void **)(a1 + 928));
  sub_10019D460(a1 + 896, *(void **)(a1 + 904));
  sub_10005CD2C(a1 + 864, *(char **)(a1 + 872));
  sub_10005CD2C(a1 + 840, *(char **)(a1 + 848));
  if (*(unsigned char *)(a1 + 832) && *(char *)(a1 + 831) < 0) {
    operator delete(*(void **)(a1 + 808));
  }
  sub_1007035FC(a1 + 776, *(void **)(a1 + 784));
  int v3 = *(std::__shared_weak_count **)(a1 + 768);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(char *)(a1 + 751) < 0) {
    operator delete(*(void **)(a1 + 728));
  }
  if (*(unsigned char *)(a1 + 720)) {
    sub_10019D50C(a1 + 520);
  }
  sub_1000558F4((const void **)(a1 + 504));
  sub_1001257B0((void *)(a1 + 480));
  sub_1001257B0((void *)(a1 + 456));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 448);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_1000346F8(a1 + 416, *(void **)(a1 + 424));
  sub_1000346F8(a1 + 392, *(void **)(a1 + 400));
  if (*(char *)(a1 + 383) < 0) {
    operator delete(*(void **)(a1 + 360));
  }
  int v16 = (void **)(a1 + 328);
  sub_10008A88C(&v16);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 320);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_1008FDE68((void *)(a1 + 264));
  uint64_t v6 = (void **)(a1 + 232);
  if (!sub_1002C7370((uint64_t *)(a1 + 232))) {
    __assert_rtn("~dynamic_bitset", "dynamic_bitset.hpp", 702, "m_check_invariants()");
  }
  int v7 = *v6;
  if (*v6)
  {
    *(void *)(a1 + 240) = v7;
    operator delete(v7);
  }
  uint64_t v8 = (void **)(a1 + 200);
  if (!sub_1002C7370((uint64_t *)(a1 + 200))) {
    __assert_rtn("~dynamic_bitset", "dynamic_bitset.hpp", 702, "m_check_invariants()");
  }
  int v9 = *v8;
  if (*v8)
  {
    *(void *)(a1 + 208) = v9;
    operator delete(v9);
  }
  int v10 = (void **)(a1 + 168);
  if (!sub_1002C7370((uint64_t *)(a1 + 168))) {
    __assert_rtn("~dynamic_bitset", "dynamic_bitset.hpp", 702, "m_check_invariants()");
  }
  uint64_t v11 = *v10;
  if (*v10)
  {
    *(void *)(a1 + 176) = v11;
    operator delete(v11);
  }
  int v12 = (void **)(a1 + 136);
  if (!sub_1002C7370((uint64_t *)(a1 + 136))) {
    __assert_rtn("~dynamic_bitset", "dynamic_bitset.hpp", 702, "m_check_invariants()");
  }
  int v13 = *v12;
  if (*v12)
  {
    *(void *)(a1 + 144) = v13;
    operator delete(v13);
  }
  int v14 = *(std::__shared_weak_count **)(a1 + 128);
  if (v14) {
    sub_10004D2C8(v14);
  }
  int v16 = (void **)(a1 + 96);
  sub_10005CBF0(&v16);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 88));
  sub_100087E88((void *)(a1 + 56));
  sub_100B77DF4(v2, (uint64_t *)off_101AA2668);
  PersonalitySpecificImpl::~PersonalitySpecificImpl((PersonalitySpecificImpl *)a1);

  PersonalitySpecific::~PersonalitySpecific(v15);
}

void sub_101225110(void *a1)
{
}

void sub_10122512C(uint64_t a1)
{
}

void sub_101225134(uint64_t a1)
{
  sub_101224DFC(a1);

  operator delete();
}

void sub_10122516C(void *a1)
{
  sub_101224DFC((uint64_t)a1 + *(void *)(*a1 - 24));

  operator delete();
}

void sub_1012251BC(uint64_t a1)
{
  sub_101224DFC(a1 - 24);

  operator delete();
}

void sub_1012251F8(void *a1, BOOL a2)
{
  uint64_t v4 = a1[11];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int v10 = 136315394;
    *(void *)&v10[4] = "airplaneModeChange";
    *(_WORD *)&v10[12] = 2080;
    *(void *)&v10[14] = asStringBool(a2);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: airplane mode %s", v10, 0x16u);
  }
  if (a2)
  {
    uint64_t v5 = (void *)a1[12];
    for (uint64_t i = (void *)a1[13]; v5 != i; v5 += 2)
    {
      uint64_t v7 = *v5;
      if (*v5)
      {
        *(void *)int v10 = 0;
        *(void *)&v10[8] = 0;
        (*(void (**)(unsigned char *__return_ptr))(*(void *)v7 + 224))(v10);
        BOOL v8 = !*(void *)v10 || !*(unsigned char *)(*(void *)v10 + 64);
        (*(void (**)(void, uint64_t, const char *, void, BOOL))(*(void *)*v5 + 424))(*v5, 1, "airplane mode", 0, v8);
        if (*(void *)&v10[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v10[8]);
        }
      }
      else
      {
        int v9 = a1[11];
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v10 = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I invalid settings upon AP change", v10, 2u);
        }
      }
    }
  }
}

void sub_1012253D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1012253F4(void *a1, BOOL a2)
{
}

uint64_t sub_101225414()
{
  return 1;
}

uint64_t sub_10122541C()
{
  return 1;
}

uint64_t sub_101225424@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 128);
  *a2 = *(void *)(result + 120);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_101225440@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = (char *)result + *(void *)(*result - 344);
  uint64_t v4 = *((void *)v2 + 15);
  uint64_t v3 = *((void *)v2 + 16);
  *a2 = v4;
  a2[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101225478(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 128);
  *(void *)(a1 + 120) = v3;
  *(void *)(a1 + 128) = v2;
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_1012254A4(void *a1, uint64_t *a2)
{
  uint64_t v2 = (char *)a1 + *(void *)(*a1 - 352);
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)v2 + 16);
  *((void *)v2 + 15) = v4;
  *((void *)v2 + 16) = v3;
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_1012254E8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
  }
  *(void *)(a1 + 304) = (*(unsigned int (**)(void, void))(**(void **)(a1 + 120) + 152))(*(void *)(a1 + 120), *(unsigned int *)(a1 + 304));
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)(a1 + 304), *(Registry **)(a1 + 32));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v10 = v9[3];
    uint64_t v11 = (std::__shared_weak_count *)v9[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v12 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v11 = 0;
  char v12 = 1;
LABEL_11:
  uint64_t v49 = v11;
  if (v10)
  {
    uint64_t v13 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    int v14 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 56))(v10, v13);
  }
  else
  {
    int v14 = 0;
  }
  uint64_t v15 = *(void *)(a1 + 48);
  if (v15)
  {
    int v16 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v15 + 264))(v15);
    uint64_t v17 = (v16[1] - *v16) >> 4;
  }
  else
  {
    LODWORD(v17) = 0;
  }
  uint64_t v18 = (uint64_t *)(a1 + 96);
  uint64_t v19 = (*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 4;
  if (v14 > (int)v17) {
    LODWORD(v17) = v14;
  }
  if ((int)v17 <= (int)v19) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = v17;
  }
  sub_10106B050((uint64_t *)(a1 + 96), (int)v20);
  char v50 = v12;
  uint64_t v52 = v20;
  if ((int)v20 >= 1)
  {
    uint64_t v21 = 0;
    uint64_t v53 = kIPsecInterfaceSettingsResource;
    while (1)
    {
      __int16 v22 = *(NSObject **)(a1 + 88);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v21;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s: for %d", buf, 0x12u);
      }
      if (!v10) {
        break;
      }
      uint64_t v23 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v10 + 72))(buf, v10, v23, v21);
      uint64_t v24 = *(void *)buf;
      uint64_t v25 = *(std::__shared_weak_count **)&buf[8];
      std::string::size_type v26 = *(NSObject **)(a1 + 88);
      if (!*(void *)buf) {
        goto LABEL_35;
      }
      if (*(void *)(*(void *)buf + 160))
      {
        if (os_log_type_enabled(*(os_log_t *)(a1 + 88), OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v21;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s: pushing %d", buf, 0x12u);
        }
        uint64_t v27 = *v18;
        uint64_t v28 = *(void *)(*v18 + 16 * v21);
        if (!v28)
        {
          uint64_t v29 = *(void *)(a1 + 48);
          if (v29)
          {
            uint64_t v30 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
            (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v29 + 280))(buf, v29, v30, v21);
            uint64_t v27 = *v18;
            long long v31 = *(_OWORD *)buf;
          }
          else
          {
            long long v31 = 0uLL;
          }
          uint64_t v36 = v27 + 16 * v21;
          *(void *)std::string buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          uint64_t v37 = *(std::__shared_weak_count **)(v36 + 8);
          *(_OWORD *)uint64_t v36 = v31;
          if (v37) {
            sub_10004D2C8(v37);
          }
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          uint64_t v28 = *(void *)(*v18 + 16 * v21);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v28 + 824))(v28, 1, v24, 0);
        long long v38 = (uint64_t *)(*v18 + 16 * v21);
        uint64_t v40 = *v38;
        long long v39 = (std::__shared_weak_count *)v38[1];
        if (v39) {
          atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        __int16 v51 = v39;
        memset(buf, 0, sizeof(buf));
        (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v40 + 296))(buf, v40, 1);
        uint64_t v41 = *(uint8_t **)buf;
        if (*(uint8_t **)buf == &buf[8]) {
LABEL_67:
        }
          operator new();
        while (1)
        {
          uint64_t v42 = *((void *)v41 + 4);
          uint64_t v43 = (std::__shared_weak_count *)*((void *)v41 + 5);
          if (v43) {
            atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v44 = (*(uint64_t (**)(uint64_t))(*(void *)v42 + 16))(v42);
          if (v43) {
            sub_10004D2C8(v43);
          }
          if (v44 == v53) {
            break;
          }
          __int16 v45 = (uint8_t *)*((void *)v41 + 1);
          if (v45)
          {
            do
            {
              long long v46 = v45;
              __int16 v45 = *(uint8_t **)v45;
            }
            while (v45);
          }
          else
          {
            do
            {
              long long v46 = (uint8_t *)*((void *)v41 + 2);
              BOOL v47 = *(void *)v46 == (void)v41;
              uint64_t v41 = v46;
            }
            while (!v47);
          }
          uint64_t v41 = v46;
          if (v46 == &buf[8]) {
            goto LABEL_67;
          }
        }
        sub_100103DF0((uint64_t)buf, *(void **)&buf[8]);
        if (v51) {
          sub_10004D2C8(v51);
        }
        goto LABEL_70;
      }
LABEL_37:
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s: APN info not present or does not support iWLan", buf, 0xCu);
      }
      uint64_t v32 = *(void *)(*v18 + 16 * v21);
      if (v32)
      {
        unsigned int v33 = (*(uint64_t (**)(uint64_t))(*(void *)v32 + 752))(v32);
        (*(void (**)(void, uint64_t, uint64_t, const char *, const char *))(**(void **)(*v18 + 16 * v21)
                                                                                     + 728))(*(void *)(*v18 + 16 * v21), 1, 27, "no APN for context", "CommCenter");
        (*(void (**)(void, uint64_t))(**(void **)(*v18 + 16 * v21) + 1088))(*(void *)(*v18 + 16 * v21), 1);
        __int16 v34 = (void *)(*v18 + 16 * v21);
        uint64_t v35 = (std::__shared_weak_count *)v34[1];
        void *v34 = 0;
        v34[1] = 0;
        if (v35) {
          sub_10004D2C8(v35);
        }
        if ((v33 & 0x80000000) == 0)
        {
          if (*(void *)(a1 + 160) > (unint64_t)v33) {
            sub_1002C6F8C((void *)(a1 + 136), v33);
          }
          if (*(void *)(a1 + 256) > (unint64_t)v33) {
            sub_1002C6F8C((void *)(a1 + 232), v33);
          }
        }
      }
LABEL_70:
      if (v25) {
        sub_10004D2C8(v25);
      }
      if (++v21 == v52) {
        goto LABEL_73;
      }
    }
    uint64_t v25 = 0;
    std::string::size_type v26 = *(NSObject **)(a1 + 88);
LABEL_35:
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v21;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s: APN info not present for %d", buf, 0x12u);
      std::string::size_type v26 = *(NSObject **)(a1 + 88);
    }
    goto LABEL_37;
  }
LABEL_73:
  sub_101225E8C((PersonalitySpecificImpl *)a1, *(void *)(a1 + 304));
  uint64_t v48 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
    _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I %s: stop", buf, 0xCu);
  }
  sub_101225F94(a1);
  if ((v50 & 1) == 0) {
    sub_10004D2C8(v49);
  }
}

void sub_101225D84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, int a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25)
{
  if ((v25 & 1) == 0) {
    sub_10004D2C8(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_101225E8C(PersonalitySpecificImpl *a1, uint64_t a2)
{
  uint64_t v4 = *((void *)a1 + 11);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    unsigned int v8 = "updateCurrentImsPrefOnAllConnections";
    __int16 v9 = 2048;
    uint64_t v10 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: %lu", (uint8_t *)&v7, 0x16u);
  }
  uint64_t v5 = *((void *)a1 + 6);
  if (v5)
  {
    uint64_t v6 = PersonalitySpecificImpl::simSlot(a1);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v5 + 320))(v5, v6, 1, a2);
  }
}

void sub_101225F94(uint64_t a1)
{
  bzero(v41, 0x240uLL);
  uint64_t v2 = *(uint64_t **)(a1 + 96);
  for (uint64_t i = *(uint64_t **)(a1 + 104); v2 != i; v2 += 2)
  {
    uint64_t v5 = *v2;
    uint64_t v4 = (std::__shared_weak_count *)v2[1];
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v5)
    {
      unint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 312))(v5, 1);
      for (uint64_t j = 0; j != 576; j += 16)
      {
        if ((v6 & 1) != 0 && !*(void *)&v41[j])
        {
          if (v4) {
            atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          unsigned int v8 = &v41[j];
          __int16 v9 = *(std::__shared_weak_count **)&v41[j + 8];
          void *v8 = v5;
          v8[1] = v4;
          if (v9) {
            sub_10004D2C8(v9);
          }
        }
        v6 >>= 1;
      }
    }
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
  int v40 = 0;
  memset(v39, 0, sizeof(v39));
  int v38 = 0;
  memset(v37, 0, sizeof(v37));
  sub_1000346F8(a1 + 392, *(void **)(a1 + 400));
  uint64_t v10 = 0;
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 392) = a1 + 400;
  uint64_t v11 = (long long *)v41;
  do
  {
    uint64_t v12 = *(void *)(a1 + 48);
    if (v12 && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v12 + 96))(v12, v10))
    {
      uint64_t v13 = *(uint64_t (****)(void, uint64_t, uint64_t, uint64_t, long long *, char *))(a1 + 48);
      uint64_t v14 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      long long v15 = *v11;
      long long v32 = v15;
      if (*((void *)&v15 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v15 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      v39[v10] = (**v13)(v13, 1, v14, v10, &v32, (char *)v37 + v10);
      if (*((void *)&v32 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v32 + 1));
      }
      if (*(void *)v11)
      {
        *(_DWORD *)std::string buf = 0;
        *(_DWORD *)std::string buf = DataiRatControllerInterface::getAppType();
        if (*(_DWORD *)buf <= 2u) {
          sub_10078C71C((uint64_t **)(a1 + 392), (int *)buf, buf);
        }
      }
    }
    else
    {
      int v16 = *(NSObject **)(a1 + 88);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = asString();
        *(_DWORD *)std::string buf = 136315394;
        __int16 v34 = "setupConfiguration";
        __int16 v35 = 2080;
        uint64_t v36 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s: %s is configured but not supported at this moment", buf, 0x16u);
      }
      v39[v10] = 0;
      uint64_t v18 = *(void (****)(void, uint64_t, uint64_t, uint64_t, uint64_t *, char *))(a1 + 48);
      if (v18)
      {
        uint64_t v19 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
        uint64_t v30 = 0;
        long long v31 = 0;
        (**v18)(v18, 1, v19, v10, &v30, (char *)v37 + v10);
        if (v31) {
          sub_10004D2C8(v31);
        }
      }
    }
    ++v10;
    ++v11;
  }
  while (v10 != 36);
  sub_101226608((PersonalitySpecificImpl *)a1);
  if (*(void *)(a1 + 48))
  {
    for (uint64_t k = 0; k != 36; ++k)
    {
      uint64_t v21 = *(void *)(a1 + 48);
      uint64_t v22 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      (*(void (**)(uint64_t, uint64_t, void, void, uint64_t))(*(void *)v21 + 40))(v21, v22, *((unsigned __int8 *)v37 + k), v39[k], k);
    }
    uint64_t v23 = *(void *)(a1 + 48);
    uint64_t v24 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    sub_100058DB0(__p, "Tech setup reconfigured");
    (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v23 + 88))(v23, v24, __p);
    if (v29 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v25 = 0;
  while (!*((unsigned char *)v37 + v25))
  {
    if (++v25 == 36) {
      goto LABEL_42;
    }
  }
  *(_DWORD *)std::string buf = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  sub_10106A300(a1 + 312, (int *)buf);
LABEL_42:
  sub_101225E8C((PersonalitySpecificImpl *)a1, *(void *)(a1 + 304));
  for (uint64_t m = 568; m != -8; m -= 16)
  {
    uint64_t v27 = *(std::__shared_weak_count **)&v41[m];
    if (v27) {
      sub_10004D2C8(v27);
    }
  }
}

void sub_101226400(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  uint64_t v40 = 568;
  while (1)
  {
    uint64_t v41 = *(std::__shared_weak_count **)(&a39 + v40);
    if (v41) {
      sub_10004D2C8(v41);
    }
    v40 -= 16;
    if (v40 == -8) {
      _Unwind_Resume(exception_object);
    }
  }
}

void sub_10122648C(void *a1)
{
}

void sub_1012264A8(void *a1)
{
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 39));
  uint64_t v2 = (std::__shared_weak_count *)a1[56];
  a1[55] = 0;
  a1[56] = 0;
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void sub_1012264F8(void *a1)
{
}

void sub_101226514(uint64_t *a1, uint64_t a2)
{
  sub_100B89560(a1 + 52, *(int **)a2, (int *)(a2 + 8));
  uint64_t v3 = a1[11];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    asString();
    if (v6 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)std::string buf = 136315138;
    unsigned int v8 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Added iRAT subscription info %s", buf, 0xCu);
    if (v6 < 0) {
      operator delete(__p);
    }
  }
  sub_101226608((PersonalitySpecificImpl *)a1);
}

void sub_101226608(PersonalitySpecificImpl *a1)
{
  v19[0] = 0;
  v19[1] = 0;
  uint64_t v17 = 0;
  uint64_t v18 = (uint64_t *)v19;
  uint64_t v16 = 0;
  uint64_t v2 = *((void *)a1 + 6);
  if (v2)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v2 + 104))(&v16);
    if (v16)
    {
      int v3 = sub_101226A40((uint64_t)a1);
      uint64_t v4 = (void *)*((void *)a1 + 49);
      if (v4 != (void *)((char *)a1 + 400))
      {
        do
        {
          LODWORD(v15) = *((_DWORD *)v4 + 7);
          HIDWORD(v15) = v3;
          sub_10122E168(&v18, v15, v3, &v15);
          uint64_t v5 = (void *)v4[1];
          if (v5)
          {
            do
            {
              char v6 = v5;
              uint64_t v5 = (void *)*v5;
            }
            while (v5);
          }
          else
          {
            do
            {
              char v6 = (void *)v4[2];
              BOOL v7 = *v6 == (void)v4;
              uint64_t v4 = v6;
            }
            while (!v7);
          }
          uint64_t v4 = v6;
        }
        while (v6 != (void *)((char *)a1 + 400));
      }
      unsigned int v8 = (void *)*((void *)a1 + 52);
      if (v8 != (void *)((char *)a1 + 424))
      {
        do
        {
          LODWORD(v15) = *((_DWORD *)v8 + 7);
          HIDWORD(v15) = v3;
          sub_10122E168(&v18, v15, v3, &v15);
          __int16 v9 = (void *)v8[1];
          if (v9)
          {
            do
            {
              uint64_t v10 = v9;
              __int16 v9 = (void *)*v9;
            }
            while (v9);
          }
          else
          {
            do
            {
              uint64_t v10 = (void *)v8[2];
              BOOL v7 = *v10 == (void)v8;
              unsigned int v8 = v10;
            }
            while (!v7);
          }
          unsigned int v8 = v10;
        }
        while (v10 != (void *)((char *)a1 + 424));
      }
      uint64_t v11 = v16;
      uint64_t v12 = PersonalitySpecificImpl::simSlot(a1);
      sub_10122E278((uint64_t)v13, &v18);
      (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v11 + 40))(v11, v12, v13);
      sub_1000346F8((uint64_t)v13, v14);
    }
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  sub_1000346F8((uint64_t)&v18, v19[0]);
}

void sub_1012267C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, char a16, void *a17)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  sub_1000346F8((uint64_t)&a16, a17);
  _Unwind_Resume(a1);
}

void sub_101226808(void *a1, uint64_t a2)
{
}

void sub_101226828(uint64_t **a1, void *a2)
{
  int v3 = a2 + 1;
  uint64_t v4 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    uint64_t v5 = a1 + 53;
    do
    {
      char v6 = *v5;
      if (*v5)
      {
        int v7 = *((_DWORD *)v4 + 7);
        unsigned int v8 = (uint64_t *)(a1 + 53);
        __int16 v9 = *v5;
        do
        {
          int v10 = *((_DWORD *)v9 + 7);
          BOOL v11 = v10 < v7;
          if (v10 >= v7) {
            uint64_t v12 = (uint64_t **)v9;
          }
          else {
            uint64_t v12 = (uint64_t **)(v9 + 1);
          }
          if (!v11) {
            unsigned int v8 = v9;
          }
          __int16 v9 = *v12;
        }
        while (*v12);
        if (v8 != (uint64_t *)v5 && *((_DWORD *)v8 + 7) <= v7)
        {
          uint64_t v13 = (uint64_t *)v8[1];
          uint64_t v14 = v8;
          if (v13)
          {
            do
            {
              uint64_t v15 = v13;
              uint64_t v13 = (uint64_t *)*v13;
            }
            while (v13);
          }
          else
          {
            do
            {
              uint64_t v15 = (uint64_t *)v14[2];
              BOOL v16 = *v15 == (void)v14;
              uint64_t v14 = v15;
            }
            while (!v16);
          }
          if (a1[52] == v8) {
            a1[52] = v15;
          }
          a1[54] = (uint64_t *)((char *)a1[54] - 1);
          sub_10005EE6C(v6, v8);
          operator delete(v8);
        }
      }
      uint64_t v17 = (void *)v4[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v4[2];
          BOOL v16 = *v18 == (void)v4;
          uint64_t v4 = v18;
        }
        while (!v16);
      }
      uint64_t v4 = v18;
    }
    while (v18 != v3);
  }
  uint64_t v19 = a1[11];
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    asString();
    if (v22 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v24 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Removed iRAT subscription info %s", buf, 0xCu);
    if (v22 < 0) {
      operator delete(__p);
    }
  }
  sub_101226608((PersonalitySpecificImpl *)a1);
}

void sub_101226A00(void *a1, void *a2)
{
}

void sub_101226A24(void *a1)
{
}

uint64_t sub_101226A40(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 120);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 128);
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v3 && (*(unsigned int (**)(uint64_t))(*(void *)v3 + 24))(v3) == 1 || *(unsigned char *)(a1 + 1008))
  {
    uint64_t v4 = 0;
  }
  else if (*(_DWORD *)(a1 + 972) == 1)
  {
    uint64_t v4 = 2;
  }
  else if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 312))(a1))
  {
    int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 312))(a1);
    uint64_t v4 = (*(uint64_t (**)(uint64_t, void))(*(void *)v3 + 88))(v3, v6 ^ 1u);
  }
  else
  {
    uint64_t v4 = *(unsigned int *)(a1 + 516);
  }
  if (v2) {
    sub_10004D2C8(v2);
  }
  return v4;
}

void sub_101226B80(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101226B9C(void *a1)
{
  return sub_101226A40((uint64_t)a1 + *(void *)(*a1 - 512));
}

uint64_t sub_101226BBC(uint64_t a1)
{
  if (!(*(unsigned int (**)(void))(**(void **)(a1 + 120) + 56))(*(void *)(a1 + 120))) {
    return 0;
  }
  if (!*(unsigned char *)(a1 + 889)) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 48);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 392))(v2);
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, void, void))(*(void *)v2 + 160);

  return v4(v2, v3, 0, 0);
}

uint64_t sub_101226C98(void *a1)
{
  return sub_101226BBC((uint64_t)a1 + *(void *)(*a1 - 544));
}

PersonalitySpecificImpl *sub_101226CB8@<X0>(PersonalitySpecificImpl *result@<X0>, uint64_t a2@<X8>)
{
  if (!*((void *)result + 6))
  {
    uint64_t v5 = "Driver not initialized";
    goto LABEL_9;
  }
  uint64_t v3 = result;
  if (capabilities::ct::supportsGemini(result))
  {
    int v4 = (*(uint64_t (**)(void *))(**((void **)v3 + 6) + 392))(*((void **)v3 + 6));
    uint64_t result = (PersonalitySpecificImpl *)PersonalitySpecificImpl::simSlot(v3);
    if (v4 == result)
    {
      uint64_t v5 = "Cannot use Internet of own SIM";
LABEL_9:
      *(_DWORD *)a2 = -3;
      *(void *)(a2 + 8) = v5;
      *(void *)(a2 + 16) = "";
      *(_DWORD *)(a2 + 24) = 0;
      *(unsigned char *)(a2 + 28) = 0;
      *(_DWORD *)(a2 + 32) = 1;
      *(void *)(a2 + 44) = 0;
      *(void *)(a2 + 36) = 0;
      *(_DWORD *)(a2 + 52) = 0;
      return result;
    }
  }
  int v6 = (void *)*((void *)v3 + 6);
  uint64_t v7 = (*(uint64_t (**)(void *))(*v6 + 392))(v6);
  unsigned int v8 = *(uint64_t (**)(void *, uint64_t, void))(*v6 + 168);

  return (PersonalitySpecificImpl *)v8(v6, v7, 0);
}

PersonalitySpecificImpl *sub_101226E04@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_101226CB8((PersonalitySpecificImpl *)((char *)a1 + *(void *)(*a1 - 552)), a2);
}

BOOL sub_101226E24(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 752);
  if (v1 != 2 && (capabilities::ct::supportsGemini((capabilities::ct *)a1) & 1) == 0)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    if (v3)
    {
      uint64_t v4 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      sub_100058DB0(__p, "Activate Internet Context For iWLan");
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v3 + 192))(v3, v4, 1, 1, __p, 0, 0);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  return v1 != 2;
}

void sub_101226EE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_101226F00(void *a1)
{
  return sub_101226E24((uint64_t)a1 + *(void *)(*a1 - 560));
}

void sub_101226F20(uint64_t a1@<X0>, void *a2@<X1>, int a3@<W3>, uint64_t a4@<X8>)
{
  char v85 = 0;
  __int16 v84 = 0;
  if (*a2)
  {
    if ((*(unsigned int (**)(void, uint64_t))(*(void *)*a2 + 232))(*a2, 1))
    {
      *(_DWORD *)a4 = 94;
      *(void *)(a4 + 8) = "FatalActivationBlocker: No Reconnection Allowed (tech1)";
      *(void *)(a4 + 16) = "";
      *(_DWORD *)(a4 + 24) = 0;
      *(unsigned char *)(a4 + 28) = 0;
      *(_DWORD *)(a4 + 32) = 1;
      *(void *)(a4 + 44) = 0;
      *(void *)(a4 + 36) = 0;
      *(_DWORD *)(a4 + 52) = 0;
      return;
    }
    uint64_t v82 = 0;
    uint64_t v83 = 0;
    (*(void (**)(uint64_t *__return_ptr))(*(void *)*a2 + 224))(&v82);
    if (v82)
    {
      if (!sub_1004FCA34(v82))
      {
        *(_DWORD *)a4 = 94;
        *(void *)(a4 + 8) = "ActivationBlocker: No Reconnection Allowed (tech2)";
        *(void *)(a4 + 16) = "";
        *(_DWORD *)(a4 + 24) = 0;
        *(unsigned char *)(a4 + 28) = 0;
        *(_DWORD *)(a4 + 32) = 1;
        *(void *)(a4 + 44) = 0;
        *(void *)(a4 + 36) = 0;
        *(_DWORD *)(a4 + 52) = 0;
LABEL_35:
        long long v31 = v83;
        if (!v83) {
          return;
        }
        goto LABEL_146;
      }
      uint64_t v23 = *(NSObject **)(a1 + 88);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = "canActivateDataContext";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s: ActivationBlocker: exists, but it can be passed through", buf, 0xCu);
      }
    }
    (*(void (**)(unsigned char *__return_ptr))(*(void *)*a2 + 64))(buf);
    long long v24 = *(_OWORD *)&buf[8];
    int v25 = v93;
    char v26 = v94;
    __int16 v84 = v95;
    char v85 = v96;
    unsigned int v8 = v99;
    if (*(_DWORD *)buf)
    {
      uint64_t v27 = v97;
      uint64_t v28 = v98;
      *(void *)a4 = *(void *)buf;
      *(_OWORD *)(a4 + 8) = v24;
      *(_DWORD *)(a4 + 24) = v25;
      *(unsigned char *)(a4 + 28) = v26;
      *(_WORD *)(a4 + 29) = v84;
      *(unsigned char *)(a4 + 31) = v85;
      *(void *)(a4 + 32) = v27;
      *(void *)(a4 + 40) = v28;
      *(void *)(a4 + 48) = v8;
      goto LABEL_35;
    }
    if (v83) {
      sub_10004D2C8(v83);
    }
  }
  else
  {
    unsigned int v8 = 0;
  }
  uint64_t v82 = 0;
  uint64_t v83 = 0;
  uint64_t v9 = *(void *)(a1 + 48);
  if (v9)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v9 + 248))(&v82);
    if (v82)
    {
      if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v82 + 152))(v82, 1)) {
        goto LABEL_15;
      }
    }
  }
  uint64_t v10 = *a2;
  BOOL v11 = (std::__shared_weak_count *)a2[1];
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v10)
  {
    char v16 = 1;
    if (!v11) {
      goto LABEL_14;
    }
LABEL_13:
    sub_10004D2C8(v11);
    goto LABEL_14;
  }
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v10 + 216))(v10, 1, 1, 0);
  uint64_t v13 = *(void *)(a1 + 48);
  if (v13)
  {
    uint64_t v14 = v12;
    uint64_t v15 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    char v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 296))(v13, 1, v15, v14);
    if (!v11) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  char v16 = 0;
  if (v11) {
    goto LABEL_13;
  }
LABEL_14:
  if ((v16 & 1) == 0)
  {
    int v29 = -1;
    uint64_t v30 = "TechDataContext: Status is not active and policy is not allowed";
    goto LABEL_31;
  }
LABEL_15:
  uint64_t v17 = v82;
  if (v82)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 16))(&v80, a1);
    (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t, uint64_t *, void))(*(void *)v17 + 544))(buf, v17, 1, &v80, 0);
    uint64_t v77 = *(void *)buf;
    *(_OWORD *)cf = *(_OWORD *)&buf[8];
    int v18 = v93;
    char v19 = v94;
    __int16 v84 = v95;
    char v85 = v96;
    uint64_t v20 = v97;
    uint64_t v22 = v98;
    uint64_t v21 = v99;
    uint64_t v98 = 0;
    std::string::size_type v99 = 0;
    if (v8)
    {
      sub_10004D2C8(v8);
      if (v99) {
        sub_10004D2C8(v99);
      }
    }
    if (v81) {
      sub_10004D2C8(v81);
    }
    if (v77)
    {
      unsigned int v8 = 0;
      *(void *)a4 = v77;
      *(_OWORD *)(a4 + 8) = *(_OWORD *)cf;
      *(_DWORD *)(a4 + 24) = v18;
      *(unsigned char *)(a4 + 28) = v19;
      *(_WORD *)(a4 + 29) = v84;
      *(unsigned char *)(a4 + 31) = v85;
      *(void *)(a4 + 32) = v20;
      *(void *)(a4 + 40) = v22;
LABEL_23:
      *(void *)(a4 + 48) = v21;
      goto LABEL_142;
    }
    unsigned int v8 = v21;
  }
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  BOOL v32 = sub_101227C34((capabilities::ct *)a1);
  BOOL v33 = v32;
  if (*(char *)(a1 + 751) < 0) {
    uint64_t v34 = *(void *)(a1 + 736);
  }
  else {
    uint64_t v34 = *(unsigned __int8 *)(a1 + 751);
  }
  uint64_t v78 = v34;
  v91[0] = off_101AA3C08;
  v91[1] = a1;
  v91[3] = v91;
  v89[0] = off_101AA3C98;
  v89[1] = a1;
  v90 = v89;
  if (v34) {
    BOOL v35 = v32;
  }
  else {
    BOOL v35 = 0;
  }
  if (v35) {
    goto LABEL_86;
  }
  CFDictionaryRef v87 = 0;
  CFDictionaryRef theDict = 0;
  (*(void (**)(const __CFDictionary **__return_ptr))(**(void **)(a1 + 120) + 40))(&v86);
  *(void *)std::string buf = theDict;
  CFDictionaryRef theDict = v86;
  CFDictionaryRef v86 = 0;
  sub_100057D78((const void **)buf);
  sub_100057D78((const void **)&v86);
  if (theDict) {
    uint64_t v36 = sub_100080778;
  }
  else {
    uint64_t v36 = 0;
  }
  if (!v36
    || (Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"IKE"), (CFDictionaryRef v38 = Value) == 0)
    || (CFTypeID v39 = CFGetTypeID(Value), v39 != CFDictionaryGetTypeID()))
  {
    CFStringRef v41 = 0;
LABEL_63:
    char v73 = 0;
    CFStringRef cfa = 0;
    BOOL v45 = v41 != 0;
    goto LABEL_64;
  }
  CFStringRef v40 = (const __CFString *)CFDictionaryGetValue(v38, @"LocalIdentifier");
  CFStringRef v41 = v40;
  if (v40)
  {
    CFTypeID v42 = CFGetTypeID(v40);
    if (v42 != CFStringGetTypeID()) {
      CFStringRef v41 = 0;
    }
  }
  CFStringRef v43 = (const __CFString *)CFDictionaryGetValue(v38, @"Username");
  CFStringRef cfa = v43;
  if (!v43) {
    goto LABEL_63;
  }
  CFTypeID v44 = CFGetTypeID(v43);
  if (v44 != CFStringGetTypeID()) {
    goto LABEL_63;
  }
  if (v41)
  {
LABEL_83:
    if (!v33)
    {
      if (CFStringFind(v41, @"$imsi", 1uLL).location != -1)
      {
        uint64_t v57 = "SIM is not ready (imsi)";
LABEL_95:
        int v58 = -1;
        goto LABEL_96;
      }
      if (cfa && CFStringFind(cfa, @"$imsi", 1uLL).location != -1)
      {
        uint64_t v57 = "SIM is not ready (username)";
        goto LABEL_95;
      }
    }
    if (!v78 && CFStringFind(v41, @"$impi_user", 1uLL).location != -1)
    {
      uint64_t v57 = "IMPI is not ready";
      goto LABEL_95;
    }
    sub_100057D78((const void **)&v87);
    sub_100057D78((const void **)&theDict);
LABEL_86:
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = "";
    *(void *)(a4 + 16) = "";
    *(_DWORD *)(a4 + 24) = 0;
    *(unsigned char *)(a4 + 28) = 0;
    *(void *)(a4 + 44) = 0;
    *(void *)(a4 + 36) = 0;
    *(_DWORD *)(a4 + 52) = 0;
    *(_DWORD *)(a4 + 32) = 1;
    goto LABEL_97;
  }
  BOOL v45 = 0;
  char v73 = 1;
LABEL_64:
  if (!v90) {
    sub_10007B600();
  }
  (*(void (**)(const __CFDictionary **__return_ptr))(*v90 + 48))(&v86);
  *(void *)std::string buf = v87;
  CFDictionaryRef v46 = v86;
  CFDictionaryRef v86 = 0;
  CFDictionaryRef v87 = v46;
  sub_100057D78((const void **)buf);
  sub_100057D78((const void **)&v86);
  if (v87) {
    BOOL v47 = sub_100080778;
  }
  else {
    BOOL v47 = 0;
  }
  if (v47)
  {
    CFDictionaryRef v48 = (const __CFDictionary *)CFDictionaryGetValue(v87, @"IKE");
    CFDictionaryRef v49 = v48;
    if (v48)
    {
      CFTypeID v50 = CFGetTypeID(v48);
      if (v50 == CFDictionaryGetTypeID())
      {
        if (!v45)
        {
          CFStringRef v51 = (const __CFString *)CFDictionaryGetValue(v49, @"LocalIdentifier");
          CFStringRef v41 = v51;
          if (v51)
          {
            CFTypeID v52 = CFGetTypeID(v51);
            if (v52 != CFStringGetTypeID()) {
              CFStringRef v41 = 0;
            }
          }
        }
        if ((v73 & 1) == 0)
        {
          CFStringRef v53 = (const __CFString *)CFDictionaryGetValue(v49, @"Username");
          CFStringRef v54 = v53;
          if (v53)
          {
            CFTypeID v55 = CFGetTypeID(v53);
            if (v55 == CFStringGetTypeID()) {
              CFStringRef v56 = v54;
            }
            else {
              CFStringRef v56 = 0;
            }
            CFStringRef cfa = v56;
          }
          else
          {
            CFStringRef cfa = 0;
          }
        }
      }
    }
  }
  if (v41) {
    goto LABEL_83;
  }
  uint64_t v57 = "Cannot find LocalIdentifier";
  int v58 = -8;
LABEL_96:
  *(_DWORD *)a4 = v58;
  *(void *)(a4 + 8) = v57;
  *(void *)(a4 + 16) = "";
  *(_DWORD *)(a4 + 24) = 0;
  *(unsigned char *)(a4 + 28) = 0;
  *(_DWORD *)(a4 + 32) = 1;
  *(void *)(a4 + 44) = 0;
  *(void *)(a4 + 36) = 0;
  *(_DWORD *)(a4 + 52) = 0;
  sub_100057D78((const void **)&v87);
  sub_100057D78((const void **)&theDict);
LABEL_97:
  sub_10122DFA4(v89);
  sub_10122DFA4(v91);
  if (*(_DWORD *)a4) {
    goto LABEL_142;
  }
  uint64_t v59 = *(std::__shared_weak_count **)(a4 + 48);
  if (v59) {
    sub_10004D2C8(v59);
  }
  if (*(unsigned char *)(a1 + 976))
  {
    if (v8)
    {
      sub_10004D2C8(v8);
      uint64_t v72 = 0;
      uint64_t cfb = 0;
      int v79 = 0;
      unsigned int v8 = 0;
    }
    else
    {
      uint64_t v72 = 0;
      uint64_t cfb = 0;
      int v79 = 0;
    }
    int v66 = 1;
    v64 = "";
    uint64_t v65 = "";
    goto LABEL_119;
  }
  uint64_t v60 = *a2;
  v61 = (std::__shared_weak_count *)a2[1];
  if (v61) {
    atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v60 && ((*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v60 + 160))(v60, 1, 0) & 1) != 0) {
    int v62 = 0;
  }
  else {
    int v62 = sub_101226BBC(a1);
  }
  if (v61) {
    sub_10004D2C8(v61);
  }
  if (!v62)
  {
    if (v8) {
      sub_10004D2C8(v8);
    }
    uint64_t v72 = 0;
    uint64_t cfb = 0;
    int v79 = 0;
    uint64_t v21 = 0;
    int v66 = 1;
    uint64_t v65 = "";
    int v63 = -5;
    v64 = "WiFi is not available and Over Cellular is not supported";
    goto LABEL_134;
  }
  sub_101226CB8((PersonalitySpecificImpl *)a1, (uint64_t)buf);
  int v63 = *(_DWORD *)buf;
  v64 = *(const char **)&buf[8];
  uint64_t v65 = *(const char **)&buf[16];
  HIDWORD(v72) = v93;
  int v71 = *(_DWORD *)&buf[4];
  LOBYTE(v72) = v94;
  __int16 v84 = v95;
  char v85 = v96;
  int v66 = v97;
  int v79 = HIDWORD(v97);
  uint64_t v21 = v99;
  uint64_t cfb = v98;
  uint64_t v98 = 0;
  std::string::size_type v99 = 0;
  if (v8)
  {
    sub_10004D2C8(v8);
    if (v99) {
      sub_10004D2C8(v99);
    }
  }
  unsigned int v8 = v21;
  if (v63)
  {
LABEL_134:
    unsigned int v8 = 0;
    *(_DWORD *)a4 = v63;
    *(_DWORD *)(a4 + 4) = v71;
    *(void *)(a4 + 8) = v64;
    *(void *)(a4 + 16) = v65;
    *(_DWORD *)(a4 + 24) = HIDWORD(v72);
    *(unsigned char *)(a4 + 28) = v72;
    *(_WORD *)(a4 + 29) = v84;
    *(unsigned char *)(a4 + 31) = v85;
    *(_DWORD *)(a4 + 32) = v66;
    *(_DWORD *)(a4 + 36) = v79;
    *(void *)(a4 + 40) = cfb;
    goto LABEL_23;
  }
LABEL_119:
  if (v82 && *a2)
  {
    (*(void (**)(unsigned char *__return_ptr))(*(void *)v82 + 488))(buf);
    if (*(void *)buf == *a2)
    {
      int v67 = 1;
      LOBYTE(v68) = 1;
      if ((*(uint64_t (**)(void, uint64_t))(**(void **)buf + 56))(*(void *)buf, 1)) {
        goto LABEL_136;
      }
    }
    else
    {
      int v67 = 1;
    }
  }
  else
  {
    int v67 = 0;
  }
  if ((a3 & 0x80000000) == 0 || !*a2)
  {
    int v68 = 0;
    if (!v67) {
      goto LABEL_129;
    }
LABEL_136:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    int v69 = v71;
    if ((v68 & 1) == 0) {
      goto LABEL_141;
    }
    goto LABEL_139;
  }
  int v68 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a2 + 56))(*a2, 1);
  if (v67) {
    goto LABEL_136;
  }
LABEL_129:
  int v69 = v71;
  if (v68)
  {
LABEL_139:
    uint64_t v70 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    if (((*(uint64_t (**)(void))(**(void **)(a1 + 120) + 184))(*(void *)(a1 + 120)) & 1) != 0
      || sub_10034F1A8((Registry **)(a1 + 32), v70))
    {
      goto LABEL_141;
    }
    int v29 = -2;
    uint64_t v30 = "WiFi calling is not allowed in roaming";
LABEL_31:
    *(_DWORD *)a4 = v29;
    *(void *)(a4 + 8) = v30;
    *(void *)(a4 + 16) = "";
    *(_DWORD *)(a4 + 24) = 0;
    *(unsigned char *)(a4 + 28) = 0;
    *(_DWORD *)(a4 + 32) = 1;
    *(void *)(a4 + 44) = 0;
    *(void *)(a4 + 36) = 0;
    *(_DWORD *)(a4 + 52) = 0;
    goto LABEL_142;
  }
LABEL_141:
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = v69;
  *(void *)(a4 + 8) = v64;
  *(void *)(a4 + 16) = v65;
  *(_DWORD *)(a4 + 24) = HIDWORD(v72);
  *(unsigned char *)(a4 + 28) = v72;
  *(_WORD *)(a4 + 29) = v84;
  *(unsigned char *)(a4 + 31) = v85;
  *(_DWORD *)(a4 + 32) = v66;
  *(_DWORD *)(a4 + 36) = v79;
  *(void *)(a4 + 40) = cfb;
  *(void *)(a4 + 48) = v8;
  unsigned int v8 = 0;
LABEL_142:
  if (v83) {
    sub_10004D2C8(v83);
  }
  if (v8)
  {
    long long v31 = v8;
LABEL_146:
    sub_10004D2C8(v31);
  }
}

void sub_101227B64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,char a21,int a22,__int16 a23,char a24,char a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,std::__shared_weak_count *a38)
{
  if (a38) {
    sub_10004D2C8(a38);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (v38) {
    sub_10004D2C8(v38);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_101227C34(capabilities::ct *a1)
{
  if (!capabilities::ct::supportsCellRadio(a1)) {
    return 1;
  }
  sub_1012294D8(a1, v4);
  if ((v5 & 0x80000000) == 0) {
    return v5 != 0;
  }
  BOOL v2 = v4[1] != 0;
  operator delete(v4[0]);
  return v2;
}

BOOL sub_101227CA0(uint64_t a1)
{
  if (*(char *)(a1 + 751) < 0) {
    uint64_t v1 = *(void *)(a1 + 736);
  }
  else {
    uint64_t v1 = *(unsigned __int8 *)(a1 + 751);
  }
  return v1 != 0;
}

void sub_101227CC0(void *a1@<X0>, void *a2@<X1>, int a3@<W3>, uint64_t a4@<X8>)
{
}

void *sub_101227CE0@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  if (!*((void *)a1 + 6)
    || capabilities::ct::supportsGemini(a1)
    && (int v4 = (*(uint64_t (**)(void))(**((void **)a1 + 6) + 392))(*((void *)a1 + 6)),
        v4 == PersonalitySpecificImpl::simSlot(a1)))
  {
    return sub_100058DB0(a2, "");
  }
  else
  {
    uint64_t v6 = *((void *)a1 + 6);
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 392))(v6);
    unsigned int v8 = *(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v6 + 176);
    return (void *)v8(v6, v7, 0);
  }
}

void *sub_101227E00@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return sub_101227CE0((capabilities::ct *)((char *)a1 + *(void *)(*a1 - 568)), a2);
}

void sub_101227E20(void *a1)
{
}

void sub_101227E40(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[6];
  if (v3)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 264))(v3);
    uint64_t v6 = *(uint64_t **)v5;
    uint64_t v7 = *(uint64_t **)(v5 + 8);
    if (*(uint64_t **)v5 != v7)
    {
      do
      {
        uint64_t v9 = *v6;
        unsigned int v8 = (std::__shared_weak_count *)v6[1];
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t *__return_ptr, void *))(*a1 + 16))(&v10, a1);
        (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, const char *))(*(void *)v9 + 248))(v9, 1, &v10, a2, "CommCenter");
        if (v11) {
          sub_10004D2C8(v11);
        }
        if (v8) {
          sub_10004D2C8(v8);
        }
        v6 += 2;
      }
      while (v6 != v7);
    }
  }
}

void sub_101227F68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101227F94(void *a1, uint64_t a2)
{
}

uint64_t sub_101227FB0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 296);
}

uint64_t sub_101227FB8(void *a1)
{
  return *(unsigned int *)((char *)a1 + *(void *)(*a1 - 248) + 296);
}

uint64_t sub_101227FD8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (!v2
    || (uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 264))(v2),
        int v4 = *(uint64_t **)v3,
        uint64_t v5 = *(uint64_t **)(v3 + 8),
        *(uint64_t **)v3 == v5))
  {
    uint64_t v6 = 0;
  }
  else
  {
    LODWORD(v6) = 0;
    do
    {
      uint64_t v7 = *v4;
      unsigned int v8 = (std::__shared_weak_count *)v4[1];
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 320))(v7, 1);
      if (v8) {
        sub_10004D2C8(v8);
      }
      uint64_t v6 = v6 + (v9 ^ 1);
      v4 += 2;
    }
    while (v4 != v5);
  }
  int v10 = *(_DWORD *)(a1 + 296);
  if (v10 != v6)
  {
    BOOL v11 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = 136315650;
      uint64_t v17 = "countActiveContexts";
      __int16 v18 = 1024;
      int v19 = v10;
      __int16 v20 = 1024;
      int v21 = v6;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s: activeContextsCnt changing from %d to %d", (uint8_t *)&v16, 0x18u);
    }
    *(_DWORD *)(a1 + 296) = v6;
    uint64_t v12 = *(void *)(a1 + 48);
    uint64_t v13 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    uint64_t v14 = (unsigned int *)(a1 + 296);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v12 + 344))(v12, v13, *v14);
    return *v14;
  }
  return v6;
}

void sub_1012281BC(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1012281DC(void *a1)
{
  return sub_101227FD8((uint64_t)a1 + *(void *)(*a1 - 240));
}

void sub_1012281F8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 512))
  {
    *(unsigned char *)(a1 + 512) = 0;
    sub_10122820C(a1);
  }
}

void sub_10122820C(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)(a1 + 168);
  uint64_t v3 = sub_10122E954(*(void *)(a1 + 168), *(void **)(a1 + 176), 0);
  if (*(v2 - 15)) {
    BOOL v4 = v3 == -1;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    unint64_t v5 = v3;
    do
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 48) + 248))(&v12);
      uint64_t v6 = v12;
      if (v12)
      {
        (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 16))(&v10, a1);
        (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v6 + 408))(v6, &v10, *(void *)(a1 + 504));
        if (v11) {
          sub_10004D2C8(v11);
        }
        unint64_t v5 = sub_10122A47C(v2, v5);
      }
      else
      {
        uint64_t v7 = *(NSObject **)(a1 + 88);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v8 = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 264))(*(void *)(a1 + 48));
          uint64_t v9 = (uint64_t)(v8[1] - *v8) >> 4;
          *(_DWORD *)std::string buf = 136315650;
          uint64_t v15 = "propagateSelectedEPDG";
          __int16 v16 = 2048;
          unint64_t v17 = v5;
          __int16 v18 = 2048;
          uint64_t v19 = v9;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: Index %lu out of boudary for PDP (%lu).", buf, 0x20u);
        }
      }
      if (v13) {
        sub_10004D2C8(v13);
      }
    }
    while (v6 && v5 != -1);
  }
}

void sub_10122842C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_101228464(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 192);
  if (*(unsigned char *)(v1 + 512))
  {
    *(unsigned char *)(v1 + 512) = 0;
    sub_10122820C(v1);
  }
}

void sub_101228490(void *a1)
{
  uint64_t v2 = a1[6];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_1012285D4;
  v8[3] = &unk_101AA26C8;
  v8[4] = a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[8];
  if (!v3 || (uint64_t v4 = a1[7], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  uint64_t v7 = a1[9];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10122E3E4;
  block[3] = &unk_101AA3D10;
  block[5] = v4;
  uint64_t v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

void sub_1012285D4(uint64_t a1)
{
}

void sub_1012285DC(void *a1)
{
}

void sub_1012285FC(void *a1)
{
  uint64_t v2 = a1[11];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315138;
    uint64_t v6 = "exitLowPower_sync";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: Exiting low power mode", (uint8_t *)&v5, 0xCu);
  }
  sub_10122E420(a1 + 33);
  uint64_t v3 = (void *)a1[29];
  uint64_t v4 = a1[30] - (void)v3;
  if (v4 >= 1) {
    bzero(v3, 8 * (((unint64_t)v4 >> 3) - ((unint64_t)v4 > 7)) + 8);
  }
}

void sub_1012286D4(void *a1)
{
}

void sub_1012286F4(PersonalitySpecificImpl *a1, uint64_t a2)
{
  uint64_t v4 = *((void *)a1 + 11);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "enterLowPower";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Entering low power mode", buf, 0xCu);
  }
  sub_10090994C((uint64_t)buf, a2);
  int v5 = (char *)a1 + 264;
  if (buf != (uint8_t *)((char *)a1 + 264))
  {
    uint64_t v6 = v29;
    uint64_t v7 = (char *)*((void *)a1 + 36);
    if (v29 == buf)
    {
      if (v7 == v5)
      {
        memset(v30, 0, sizeof(v30));
        (*(void (**)(uint8_t *, void *))(*(void *)buf + 24))(buf, v30);
        (*(void (**)(uint8_t *))(*(void *)v29 + 32))(v29);
        int v29 = 0;
        (*(void (**)(void, uint8_t *))(**((void **)a1 + 36) + 24))(*((void *)a1 + 36), buf);
        (*(void (**)(void))(**((void **)a1 + 36) + 32))(*((void *)a1 + 36));
        *((void *)a1 + 36) = 0;
        int v29 = buf;
        (*(void (**)(void *, uint64_t))(v30[0] + 24))(v30, (uint64_t)a1 + 264);
        (*(void (**)(void *))(v30[0] + 32))(v30);
      }
      else
      {
        (*(void (**)(uint8_t *, uint64_t))(*(void *)buf + 24))(buf, (uint64_t)a1 + 264);
        (*(void (**)(uint8_t *))(*(void *)v29 + 32))(v29);
        int v29 = (uint8_t *)*((void *)a1 + 36);
      }
      *((void *)a1 + 36) = v5;
    }
    else if (v7 == v5)
    {
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v5 + 24))((uint64_t)a1 + 264, buf);
      (*(void (**)(void))(**((void **)a1 + 36) + 32))(*((void *)a1 + 36));
      *((void *)a1 + 36) = v29;
      int v29 = buf;
    }
    else
    {
      int v29 = (uint8_t *)*((void *)a1 + 36);
      *((void *)a1 + 36) = v6;
    }
  }
  sub_1008FDE68(buf);
  unsigned int v8 = (void *)*((void *)a1 + 29);
  uint64_t v9 = *((void *)a1 + 30) - (void)v8;
  if (v9 >= 1) {
    bzero(v8, 8 * (((unint64_t)v9 >> 3) - ((unint64_t)v9 > 7)) + 8);
  }
  uint64_t v10 = *((void *)a1 + 6);
  if (v10)
  {
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 264))(v10);
    uint64_t v12 = *(uint64_t **)v11;
    uint64_t v13 = *(uint64_t **)(v11 + 8);
    if (*(uint64_t **)v11 != v13)
    {
      do
      {
        uint64_t v15 = *v12;
        uint64_t v14 = (std::__shared_weak_count *)v12[1];
        if (v14) {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t *__return_ptr, PersonalitySpecificImpl *))(*(void *)a1 + 16))(&v26, a1);
        int v16 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v15 + 392))(v15, &v26);
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v16)
        {
          int v17 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 72))(v15);
          sub_1002C6DE8((void *)a1 + 29, v17, 1);
        }
        if (v14) {
          sub_10004D2C8(v14);
        }
        v12 += 2;
      }
      while (v12 != v13);
    }
  }
  __int16 v18 = (unint64_t *)*((void *)a1 + 29);
  uint64_t v19 = *((void *)a1 + 30) - (void)v18;
  if (!v19)
  {
LABEL_34:
    sub_101228BCC(a1);
    return;
  }
  unint64_t v20 = v19 >> 3;
  if (v20 <= 1) {
    uint64_t v21 = 1;
  }
  else {
    uint64_t v21 = v20;
  }
  unint64_t v22 = *v18;
  if (!*v18)
  {
    uint64_t v23 = v18 + 1;
    uint64_t v24 = v21 - 1;
    while (v24 != v22)
    {
      if (v23[v22++])
      {
        if (v22 < v20) {
          return;
        }
        goto LABEL_34;
      }
    }
    goto LABEL_34;
  }
}

void sub_101228B88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

PersonalitySpecificImpl *sub_101228BCC(PersonalitySpecificImpl *result)
{
  if (*((void *)result + 36))
  {
    uint64_t v1 = result;
    uint64_t v2 = *((void *)result + 11);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136315138;
      uint64_t v6 = "callbackEnteredLowPower";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: Calling Low Power call back", (uint8_t *)&v5, 0xCu);
    }
    int v3 = PersonalitySpecificImpl::simSlot(v1);
    uint64_t v4 = (void *)((char *)v1 + 264);
    sub_1008FBA74((uint64_t)v4, v3);
    return (PersonalitySpecificImpl *)sub_10122E420(v4);
  }
  return result;
}

void sub_101228C9C(void *a1, uint64_t a2)
{
}

PersonalitySpecificImpl *sub_101228CBC(PersonalitySpecificImpl *a1, int a2)
{
  uint64_t result = (PersonalitySpecificImpl *)sub_1002C6F8C((void *)a1 + 29, a2);
  uint64_t v4 = (unint64_t *)*((void *)a1 + 29);
  uint64_t v5 = *((void *)a1 + 30) - (void)v4;
  if (!v5)
  {
LABEL_11:
    return sub_101228BCC(a1);
  }
  unint64_t v6 = v5 >> 3;
  if (v6 <= 1) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = v6;
  }
  unint64_t v8 = *v4;
  if (!*v4)
  {
    uint64_t v9 = v4 + 1;
    uint64_t v10 = v7 - 1;
    while (v10 != v8)
    {
      if (v9[v8++])
      {
        if (v8 < v6) {
          return result;
        }
        goto LABEL_11;
      }
    }
    goto LABEL_11;
  }
  return result;
}

PersonalitySpecificImpl *sub_101228D4C(void *a1, int a2)
{
  return sub_101228CBC((PersonalitySpecificImpl *)((char *)a1 + *(void *)(*a1 - 456)), a2);
}

BOOL sub_101228D6C(void *a1, int a2, int a3)
{
  unint64_t v8 = (unint64_t *)a1[17];
  uint64_t v7 = a1[18];
  unint64_t v6 = a1 + 17;
  uint64_t v9 = v7 - (void)v8;
  if (v9)
  {
    unint64_t v10 = v9 >> 3;
    if (v10 <= 1) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = v10;
    }
    unint64_t v12 = *v8;
    if (*v8)
    {
      BOOL v13 = 0;
    }
    else
    {
      uint64_t v14 = v8 + 1;
      while (v11 - 1 != v12)
      {
        if (v14[v12++]) {
          goto LABEL_13;
        }
      }
      unint64_t v12 = v11;
LABEL_13:
      BOOL v13 = v12 >= v10;
    }
  }
  else
  {
    BOOL v13 = 1;
  }
  unint64_t v16 = a1[20];
  if (v16 <= a2)
  {
    int v17 = a1[11];
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v19 = 136315650;
      *(void *)&v19[4] = "reportActivatingCheckFirst";
      *(_WORD *)&v19[12] = 1024;
      *(_DWORD *)&v19[14] = a2;
      __int16 v20 = 2048;
      unint64_t v21 = v16;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: pdpID %d out of boundary %lu.", v19, 0x1Cu);
    }
  }
  else
  {
    sub_1002C6DE8(v6, a2, 1);
    if (!a3 && !a1[95]) {
      sub_1011DEFFC(v19);
    }
  }
  return v13;
}

BOOL sub_101228F0C(void *a1, int a2, int a3)
{
  return sub_101228D6C((void *)((char *)a1 + *(void *)(*a1 - 360)), a2, a3);
}

void sub_101228F2C(uint64_t a1, int a2)
{
  uint64_t v4 = (void *)(a1 + 440);
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 160);
  if (v6 <= a2)
  {
    unint64_t v16 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = "clearActivating";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = a2;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v6;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s: pdpID %d out of boundary for Activating Contexts(%lu).", buf, 0x1Cu);
    }
  }
  else
  {
    sub_1002C6F8C((void *)(a1 + 136), a2);
    uint64_t v7 = *(unint64_t **)(a1 + 136);
    uint64_t v8 = *(void *)(a1 + 144) - (void)v7;
    if (v8)
    {
      unint64_t v9 = v8 >> 3;
      if (v9 <= 1) {
        uint64_t v10 = 1;
      }
      else {
        uint64_t v10 = v9;
      }
      unint64_t v11 = *v7;
      if (*v7) {
        goto LABEL_15;
      }
      unint64_t v12 = v7 + 1;
      uint64_t v13 = v10 - 1;
      while (v13 != v11)
      {
        if (v12[v11++])
        {
          if (v11 < v9) {
            goto LABEL_15;
          }
          break;
        }
      }
    }
    uint64_t v15 = *(std::__shared_weak_count **)(a1 + 768);
    v4[40] = 0;
    v4[41] = 0;
    if (v15) {
      sub_10004D2C8(v15);
    }
  }
LABEL_15:
  if (*(void *)(a1 + 224) <= v5) {
    goto LABEL_36;
  }
  sub_1002C6F8C((void *)(a1 + 200), v5);
  int v17 = *(unint64_t **)(a1 + 200);
  uint64_t v18 = *(void *)(a1 + 208) - (void)v17;
  if (v18)
  {
    unint64_t v19 = v18 >> 3;
    if (v19 <= 1) {
      uint64_t v20 = 1;
    }
    else {
      uint64_t v20 = v19;
    }
    unint64_t v21 = *v17;
    if (*v17)
    {
LABEL_21:
      memset(buf, 0, 24);
      sub_10122E4A8((void *)(a1 + 200), (std::string *)buf);
      unint64_t v22 = *(NSObject **)(a1 + 88);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v23 = buf;
        if (buf[23] < 0) {
          uint64_t v23 = *(unsigned char **)buf;
        }
        *(_DWORD *)CFTypeID v52 = 136315394;
        CFStringRef v53 = "clearActivating";
        __int16 v54 = 2080;
        CFTypeID v55 = v23;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s: WAN IP waiting list is still not empty (%s).", v52, 0x16u);
      }
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      goto LABEL_36;
    }
    uint64_t v24 = v17 + 1;
    uint64_t v25 = v20 - 1;
    while (v25 != v21)
    {
      if (v24[v21++])
      {
        if (v21 < v19) {
          goto LABEL_21;
        }
        break;
      }
    }
  }
  uint64_t v27 = *(void *)(a1 + 48);
  if (v27)
  {
    uint64_t v28 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v51 = 0;
    (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v27 + 64))(v27, v28, __p);
    if (SHIBYTE(v51) < 0) {
      operator delete(__p[0]);
    }
  }
  int v29 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "clearActivating";
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %s: WAN IP waiting list empty.", buf, 0xCu);
  }
LABEL_36:
  unint64_t v30 = *(void *)(a1 + 192);
  if (v30 <= v5)
  {
    CFTypeID v39 = *(NSObject **)(a1 + 88);
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_61;
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = "clearActivating";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = v30;
    CFStringRef v40 = "#I %s: pdpID %d out of boudary for DNS waiting Contexts(%lu).";
    CFStringRef v41 = v39;
    uint32_t v42 = 28;
    goto LABEL_60;
  }
  sub_1002C6F8C((void *)(a1 + 168), v5);
  long long v31 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "clearActivating";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s: removed context %d from DNS waiting list.", buf, 0x12u);
  }
  BOOL v32 = *(unint64_t **)(a1 + 168);
  uint64_t v33 = *(void *)(a1 + 176) - (void)v32;
  if (v33)
  {
    unint64_t v34 = v33 >> 3;
    if (v34 <= 1) {
      uint64_t v35 = 1;
    }
    else {
      uint64_t v35 = v34;
    }
    unint64_t v36 = *v32;
    if (*v32)
    {
LABEL_44:
      memset(buf, 0, 24);
      sub_10122E4A8((void *)(a1 + 168), (std::string *)buf);
      uint64_t v37 = *(NSObject **)(a1 + 88);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        CFDictionaryRef v38 = buf;
        if (buf[23] < 0) {
          CFDictionaryRef v38 = *(unsigned char **)buf;
        }
        *(_DWORD *)CFTypeID v52 = 136315394;
        CFStringRef v53 = "clearActivating";
        __int16 v54 = 2080;
        CFTypeID v55 = v38;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s: DNS waiting list is still not empty (%s).", v52, 0x16u);
      }
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      goto LABEL_61;
    }
    CFStringRef v43 = v32 + 1;
    uint64_t v44 = v35 - 1;
    while (v44 != v36)
    {
      if (v43[v36++])
      {
        if (v36 < v34) {
          goto LABEL_44;
        }
        break;
      }
    }
  }
  uint64_t v46 = *(void *)(a1 + 504);
  *(void *)(a1 + 504) = 0;
  *(void *)std::string buf = v46;
  sub_1000558F4((const void **)buf);
  BOOL v47 = *(std::__shared_weak_count **)(a1 + 448);
  *uint64_t v4 = 0;
  v4[1] = 0;
  if (v47) {
    sub_10004D2C8(v47);
  }
  CFDictionaryRef v48 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "clearActivating";
    CFStringRef v40 = "#I %s: DNS waiting list empty.";
    CFStringRef v41 = v48;
    uint32_t v42 = 12;
LABEL_60:
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, v40, buf, v42);
  }
LABEL_61:
  if (*(unsigned char *)(a1 + 512))
  {
    *(unsigned char *)(a1 + 512) = 0;
    uint64_t v49 = *(void *)(a1 + 504);
    *(void *)(a1 + 504) = 0;
    *(void *)std::string buf = v49;
    sub_1000558F4((const void **)buf);
    sub_10122820C(a1);
  }
}

void sub_10122946C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1012294A8(void *a1, int a2)
{
}

uint64_t sub_1012294C8()
{
  return 3;
}

uint64_t sub_1012294D0()
{
  return 3;
}

void *sub_1012294D8@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (!*((unsigned char *)result + 720)) {
    return sub_100058DB0(a2, "");
  }
  if (*((char *)result + 543) < 0) {
    return sub_10004FC84(a2, (void *)result[65], result[66]);
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 65);
  a2[2] = result[67];
  return result;
}

BOOL sub_101229520(void *a1)
{
  return sub_101227C34((capabilities::ct *)((char *)a1 + *(void *)(*a1 - 376)));
}

BOOL sub_101229540(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 384);
  if (v1[751] < 0) {
    uint64_t v2 = *((void *)v1 + 92);
  }
  else {
    uint64_t v2 = v1[751];
  }
  return v2 != 0;
}

void *sub_10122957C@<X0>(PersonalitySpecificImpl *a1@<X0>, uint64_t a2@<X8>)
{
  if (capabilities::ct::supportsCellRadio(a1))
  {
    uint64_t result = (void *)PersonalitySpecificImpl::simSlot(a1);
    uint64_t v5 = *((void *)a1 + 124);
    if (!v5) {
      goto LABEL_12;
    }
    unint64_t v6 = (void *)((char *)a1 + 992);
    do
    {
      int v7 = *(_DWORD *)(v5 + 32);
      BOOL v8 = v7 < (int)result;
      if (v7 >= (int)result) {
        unint64_t v9 = (uint64_t *)v5;
      }
      else {
        unint64_t v9 = (uint64_t *)(v5 + 8);
      }
      if (!v8) {
        unint64_t v6 = (void *)v5;
      }
      uint64_t v5 = *v9;
    }
    while (*v9);
    if (v6 != (void *)((char *)a1 + 992) && (int)result >= *((_DWORD *)v6 + 8))
    {
      if (*((char *)v6 + 63) < 0)
      {
        unint64_t v12 = (void *)v6[5];
        unint64_t v13 = v6[6];
        return sub_10004FC84((unsigned char *)a2, v12, v13);
      }
      else
      {
        long long v11 = *(_OWORD *)(v6 + 5);
        *(void *)(a2 + 16) = v6[7];
        *(_OWORD *)a2 = v11;
      }
    }
    else
    {
LABEL_12:
      uint64_t v10 = *((void *)a1 + 11);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v14 = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E IMEI is empty !", v14, 2u);
      }
      return sub_100058DB0((void *)a2, "");
    }
  }
  else
  {
    return sub_100058DB0((void *)a2, "");
  }
  return result;
}

void *sub_1012296B4@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_10122957C((PersonalitySpecificImpl *)((char *)a1 + *(void *)(*a1 - 392)), a2);
}

char *sub_1012296D4@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[751] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 91), *((void *)result + 92));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 728);
  *(void *)(a2 + 16) = *((void *)result + 93);
  return result;
}

void *sub_101229704@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (char *)result + *(void *)(*result - 400);
  if (v2[751] < 0) {
    return sub_10004FC84((unsigned char *)a2, *((void **)v2 + 91), *((void *)v2 + 92));
  }
  int v3 = v2 + 728;
  *(_OWORD *)a2 = *(_OWORD *)v3;
  *(void *)(a2 + 16) = *((void *)v3 + 2);
  return result;
}

void *sub_101229750@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return sub_1012294D8((void *)((char *)a1 + *(void *)(*a1 - 408)), a2);
}

void *sub_101229770@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (!*((unsigned char *)result + 720)) {
    return sub_100058DB0(a2, "");
  }
  if (*((char *)result + 567) < 0) {
    return sub_10004FC84(a2, (void *)result[68], result[69]);
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 34);
  a2[2] = result[70];
  return result;
}

void *sub_1012297B8@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return sub_101229770((void *)((char *)a1 + *(void *)(*a1 - 416)), a2);
}

void *sub_1012297D8@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (!*((unsigned char *)result + 720)) {
    return sub_100058DB0(a2, "");
  }
  if (*((char *)result + 591) < 0) {
    return sub_10004FC84(a2, (void *)result[71], result[72]);
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 71);
  a2[2] = result[73];
  return result;
}

void *sub_101229820@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return sub_1012297D8((void *)((char *)a1 + *(void *)(*a1 - 424)), a2);
}

void sub_101229840(PersonalitySpecificImpl *a1@<X0>, uint64_t *a2@<X8>)
{
  int v4 = PersonalitySpecificImpl::simSlot(a1);
  uint64_t v5 = *((void *)a1 + 116);
  if (!v5) {
    goto LABEL_15;
  }
  unint64_t v6 = (void *)((char *)a1 + 928);
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < v4;
    if (v7 >= v4) {
      unint64_t v9 = (uint64_t *)v5;
    }
    else {
      unint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      unint64_t v6 = (void *)v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 != (void *)((char *)a1 + 928) && v4 >= *((_DWORD *)v6 + 8) && *((unsigned char *)v6 + 108))
  {
    *(_OWORD *)long long __p = 0u;
    long long v11 = 0u;
    MCCAndMNC::getMcc((uint64_t *)__p, (MCCAndMNC *)(v6 + 5));
    MCC::getStringValue(a2, (MCC *)__p);
    if (SHIBYTE(v11) < 0) {
      operator delete(__p[1]);
    }
  }
  else
  {
LABEL_15:
    sub_100058DB0(a2, "");
  }
}

void sub_101229914(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101229930(void *a1@<X0>, uint64_t *a2@<X8>)
{
}

void sub_101229950(PersonalitySpecificImpl *a1@<X0>, uint64_t *a2@<X8>)
{
  int v4 = PersonalitySpecificImpl::simSlot(a1);
  uint64_t v5 = *((void *)a1 + 116);
  if (!v5) {
    goto LABEL_15;
  }
  unint64_t v6 = (void *)((char *)a1 + 928);
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < v4;
    if (v7 >= v4) {
      unint64_t v9 = (uint64_t *)v5;
    }
    else {
      unint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      unint64_t v6 = (void *)v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 != (void *)((char *)a1 + 928) && v4 >= *((_DWORD *)v6 + 8) && *((unsigned char *)v6 + 108))
  {
    *(_OWORD *)long long __p = 0u;
    long long v11 = 0u;
    MCCAndMNC::getMnc((uint64_t *)__p, (MCCAndMNC *)(v6 + 5));
    MCC::getStringValue(a2, (MCC *)__p);
    if (SHIBYTE(v11) < 0) {
      operator delete(__p[1]);
    }
  }
  else
  {
LABEL_15:
    sub_100058DB0(a2, "");
  }
}

void sub_101229A24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101229A40(void *a1@<X0>, uint64_t *a2@<X8>)
{
}

uint64_t sub_101229A60(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 384);
}

uint64_t sub_101229A68(void *a1)
{
  return *((unsigned __int8 *)a1 + *(void *)(*a1 - 448) + 384);
}

uint64_t sub_101229A8C(uint64_t a1, int a2)
{
  uint64_t v26 = 0;
  DevicePersistentCopyValue((uint64_t *)&cf, @"5wiRoutableLocalAddress", 0);
  __p[0] = (void *)cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v23 = 0;
  *(void *)std::string buf = 0;
  sub_100056248(buf, (CFTypeRef *)__p);
  if (*(void *)buf) {
    int v4 = sub_1000810B8;
  }
  else {
    int v4 = 0;
  }
  if (v4) {
    sub_100083EB8(&v23, (const void **)buf);
  }
  sub_1000558F4((const void **)buf);
  uint64_t v26 = v23;
  uint64_t v23 = 0;
  sub_1000558F4(&v23);
  sub_1000577C4((const void **)__p);
  sub_1000577C4(&cf);
  if (v26) {
    uint64_t v5 = sub_1000810B8;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5)
  {
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    *(_OWORD *)long long __p = *(_OWORD *)buf;
    uint64_t v29 = *(void *)&buf[16];
    unint64_t v6 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = __p;
      if (v29 < 0) {
        int v7 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "requestLocalRoutableAddress";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Found WAN IP override: %s", buf, 0x16u);
    }
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 1174405120;
    v18[2] = sub_101229FE8;
    v18[3] = &unk_101AA26E8;
    v18[4] = a1;
    if (SHIBYTE(v29) < 0)
    {
      sub_10004FC84(&v19, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long v19 = *(_OWORD *)__p;
      uint64_t v20 = v29;
    }
    long long v11 = *(std::__shared_weak_count **)(a1 + 64);
    if (!v11 || (uint64_t v12 = *(void *)(a1 + 56), (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v14 = v13;
    uint64_t v15 = *(NSObject **)(a1 + 72);
    *(void *)std::string buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 1174405120;
    *(void *)&uint8_t buf[16] = sub_10122E3E4;
    long long v31 = &unk_101AA3D10;
    uint64_t v33 = v12;
    unint64_t v34 = v14;
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v32 = v18;
    dispatch_async(v15, buf);
    if (v34) {
      sub_10004D2C8(v34);
    }
    sub_10004D2C8(v14);
    if (SHIBYTE(v20) < 0) {
      operator delete((void *)v19);
    }
    if (SHIBYTE(v29) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    *(void *)std::string buf = sub_101220B14((PersonalitySpecificImpl *)a1);
    sub_1002BFAE4((char **)buf, (dispatch_object_t *)(a1 + 72), &v23);
    Registry::createRestModuleOneTimeUseMobileHelperConnection(&v21, *(Registry **)(a1 + 32));
    ctu::RestModule::connect();
    if (v22) {
      sub_10004D2C8(v22);
    }
    unint64_t v9 = v23;
    BOOL v8 = v24;
    if (v24) {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100058DB0(__p, "/helper/requests/wan_ip_from_location");
    xpc_object_t object = xpc_null_create();
    uint64_t v10 = operator new(0x20uLL);
    void *v10 = off_101AA3D50;
    v10[1] = a1;
    v10[2] = v9;
    v10[3] = v8;
    long long v31 = v10;
    ctu::RestModule::sendRequest();
    sub_10003F600(buf);
    xpc_release(object);
    xpc_object_t object = 0;
    if (SHIBYTE(v29) < 0) {
      operator delete(__p[0]);
    }
    if (v24) {
      sub_10004D2C8(v24);
    }
  }
  sub_1002C6DE8((void *)(a1 + 200), a2, 1);
  unint64_t v16 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "requestLocalRoutableAddress";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s: Context %d is waiting on WAN IP aquisition.", buf, 0x12u);
  }
  sub_1000558F4(&v26);
  return 1;
}

void sub_101229ED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,char a22,int a23,const void *a24,xpc_object_t object,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a24);
  _Unwind_Resume(a1);
}

void sub_101229FE8(uint64_t a1)
{
}

void sub_101229FF8(uint64_t a1, void **a2)
{
  memset(v29, 0, sizeof(v29));
  CSIPacketAddress::CSIPacketAddress();
  char isZeroIP = CSIPacketAddress::isZeroIP((CSIPacketAddress *)v29);
  uint64_t v5 = *(NSObject **)(a1 + 88);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (isZeroIP)
  {
    if (v6)
    {
      *(_DWORD *)std::string buf = 136315138;
      long long v31 = "setLocalRoutableAddress";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: Empty WAN IP", buf, 0xCu);
    }
    uint64_t v7 = *(void *)(a1 + 48);
    if (v7)
    {
      uint64_t v8 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      v25[0] = 0;
      v25[1] = 0;
      uint64_t v26 = 0;
      (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v7 + 64))(v7, v8, v25);
      if (SHIBYTE(v26) < 0)
      {
        p_dst = (void **)v25;
LABEL_18:
        operator delete(*p_dst);
      }
    }
  }
  else
  {
    if (v6)
    {
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v10 = a2;
      }
      else {
        uint64_t v10 = *a2;
      }
      *(_DWORD *)std::string buf = 136315394;
      long long v31 = "setLocalRoutableAddress";
      __int16 v32 = 2080;
      unint64_t v33 = (unint64_t)v10;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: WAN IP acquired as %s", buf, 0x16u);
    }
    uint64_t v11 = *(void *)(a1 + 48);
    if (v11)
    {
      uint64_t v12 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      if (*((char *)a2 + 23) < 0)
      {
        sub_10004FC84(&__dst, *a2, (unint64_t)a2[1]);
      }
      else
      {
        long long __dst = *(_OWORD *)a2;
        uint64_t v28 = a2[2];
      }
      (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)v11 + 64))(v11, v12, &__dst);
      if (SHIBYTE(v28) < 0)
      {
        p_dst = (void **)&__dst;
        goto LABEL_18;
      }
    }
  }
  uint64_t v13 = sub_10122E954(*(void *)(a1 + 200), *(void **)(a1 + 208), 0);
  if (*(void *)(a1 + 48))
  {
    unint64_t v14 = v13;
    do
    {
      if (v14 == -1) {
        break;
      }
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 48) + 248))(&v23);
      uint64_t v15 = v23;
      if (v23)
      {
        (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 16))(&v21, a1);
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v15 + 416))(v15, &v21);
        if (v22) {
          sub_10004D2C8(v22);
        }
        unint64_t v14 = sub_10122A47C((uint64_t *)(a1 + 200), v14);
      }
      else
      {
        unint64_t v16 = *(NSObject **)(a1 + 88);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          int v17 = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 264))(*(void *)(a1 + 48));
          uint64_t v18 = (uint64_t)(v17[1] - *v17) >> 4;
          *(_DWORD *)std::string buf = 136315650;
          long long v31 = "setLocalRoutableAddress";
          __int16 v32 = 2048;
          unint64_t v33 = v14;
          __int16 v34 = 2048;
          uint64_t v35 = v18;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s: Index %lu out of boudary for PDP (%lu).", buf, 0x20u);
        }
      }
      if (v24) {
        sub_10004D2C8(v24);
      }
    }
    while (v15);
    long long v19 = *(void **)(a1 + 200);
    uint64_t v20 = *(void *)(a1 + 208) - (void)v19;
    if (v20 >= 1) {
      bzero(v19, 8 * (((unint64_t)v20 >> 3) - ((unint64_t)v20 > 7)) + 8);
    }
  }
}

void sub_10122A3E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10122A444(void *a1, int a2)
{
  return 1;
}

uint64_t sub_10122A47C(uint64_t *a1, unint64_t a2)
{
  uint64_t v2 = a1[3];
  if (v2) {
    BOOL v3 = v2 - 1 > a2;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3) {
    return -1;
  }
  unint64_t v5 = (a2 + 1) >> 6;
  if (*(void *)(*a1 + 8 * v5) >> (a2 + 1)) {
    return a2 + 1 + (int)sub_10122E9C8(*(void *)(*a1 + 8 * v5) >> (a2 + 1));
  }
  BOOL v6 = (void *)a1[1];
  uint64_t v7 = *a1;

  return sub_10122E954(v7, v6, v5 + 1);
}

void sub_10122A500(void *a1, void **a2)
{
}

void sub_10122A520(PersonalitySpecificImpl *a1)
{
  v23[0] = 0;
  v23[1] = 0;
  uint64_t v21 = 0;
  unint64_t v22 = (uint64_t *)v23;
  uint64_t v20 = 0;
  uint64_t v2 = *((void *)a1 + 6);
  if (v2)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v2 + 104))(&v20);
    if (v20)
    {
      BOOL v3 = (void *)*((void *)a1 + 49);
      if (v3 == (void *)((char *)a1 + 400))
      {
        char v4 = 0;
      }
      else
      {
        char v4 = 0;
        do
        {
          unsigned int v5 = *((_DWORD *)v3 + 7);
          BOOL v6 = v5 == 1;
          uint64_t v19 = v5 | 0x200000000;
          sub_10122E168(&v22, v5, 2, &v19);
          uint64_t v7 = (void *)v3[1];
          if (v7)
          {
            do
            {
              uint64_t v8 = v7;
              uint64_t v7 = (void *)*v7;
            }
            while (v7);
          }
          else
          {
            do
            {
              uint64_t v8 = (void *)v3[2];
              BOOL v9 = *v8 == (void)v3;
              BOOL v3 = v8;
            }
            while (!v9);
          }
          v4 |= v6;
          BOOL v3 = v8;
        }
        while (v8 != (void *)((char *)a1 + 400));
      }
      uint64_t v10 = (void *)*((void *)a1 + 52);
      if (v10 != (void *)((char *)a1 + 424))
      {
        do
        {
          unsigned int v11 = *((_DWORD *)v10 + 7);
          BOOL v12 = v11 == 1;
          uint64_t v19 = v11 | 0x200000000;
          sub_10122E168(&v22, v11, 2, &v19);
          uint64_t v13 = (void *)v10[1];
          if (v13)
          {
            do
            {
              unint64_t v14 = v13;
              uint64_t v13 = (void *)*v13;
            }
            while (v13);
          }
          else
          {
            do
            {
              unint64_t v14 = (void *)v10[2];
              BOOL v9 = *v14 == (void)v10;
              uint64_t v10 = v14;
            }
            while (!v9);
          }
          v4 |= v12;
          uint64_t v10 = v14;
        }
        while (v14 != (void *)((char *)a1 + 424));
      }
      if ((v4 & 1) == 0)
      {
        uint64_t v19 = 0x200000001;
        sub_10122E168(&v22, 1, 2, &v19);
      }
      uint64_t v15 = v20;
      uint64_t v16 = PersonalitySpecificImpl::simSlot(a1);
      sub_10122E278((uint64_t)v17, &v22);
      (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v15 + 40))(v15, v16, v17);
      sub_1000346F8((uint64_t)v17, v18);
    }
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  sub_1000346F8((uint64_t)&v22, v23[0]);
}

void sub_10122A724(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, char a16, void *a17)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  sub_1000346F8((uint64_t)&a16, a17);
  _Unwind_Resume(a1);
}

void sub_10122A770(void *a1)
{
}

const void **sub_10122A790@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, int a4@<W3>, unsigned char *a5@<X4>, char a6@<W5>, const void **a7@<X8>)
{
  if (*(void *)(a1 + 504)) {
    unsigned int v11 = sub_1000810B8;
  }
  else {
    unsigned int v11 = 0;
  }
  if (!v11 && !*(void *)(a1 + 440))
  {
    if (a2)
    {
      ctu::cf::assign();
      *(_OWORD *)long long __p = 0u;
      uint64_t v31 = 0;
      memset(buf, 0, sizeof(buf));
      if (a4)
      {
        if (*(char *)(a1 + 383) < 0)
        {
          sub_10004FC84(buf, *(void **)(a1 + 360), *(void *)(a1 + 368));
        }
        else
        {
          *(_OWORD *)std::string buf = *(_OWORD *)(a1 + 360);
          *(void *)&uint8_t buf[16] = *(void *)(a1 + 376);
        }
      }
      else
      {
        sub_101227CE0((capabilities::ct *)a1, buf);
      }
      *(unsigned char *)(a1 + 512) = 0;
      uint64_t v19 = *(std::__shared_weak_count **)(a1 + 64);
      if (!v19 || (v20 = *(void *)(a1 + 56), (uint64_t v21 = std::__shared_weak_count::lock(v19)) == 0)) {
        sub_100088B9C();
      }
      unint64_t v22 = v21;
      atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v21);
      uint64_t v23 = operator new(0x20uLL);
      *uint64_t v23 = off_101AA3DD0;
      v23[1] = v20;
      v23[2] = v22;
      *((unsigned char *)v23 + 24) = a6;
      v33[3] = v23;
      uint64_t v24 = *(NSObject **)(a1 + 72);
      dispatch_object_t object = v24;
      if (v24) {
        dispatch_retain(v24);
      }
      DNSResolver::resolve((Registry **)(a1 + 32), (uint64_t)__p, (uint64_t)v33, (uint64_t)&object, 5, (uint64_t)buf, 0, (uint64_t *)v32);
      long long v25 = *(_OWORD *)v32;
      *(void *)__int16 v32 = 0;
      *(void *)&v32[8] = 0;
      uint64_t v26 = *(std::__shared_weak_count **)(a1 + 448);
      *(_OWORD *)(a1 + 440) = v25;
      if (v26)
      {
        sub_10004D2C8(v26);
        if (*(void *)&v32[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v32[8]);
        }
      }
      if (object) {
        dispatch_release(object);
      }
      sub_10016D140(v33);
      if (!*(void *)(a1 + 440))
      {
        uint64_t v27 = *(NSObject **)(a1 + 88);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v28 = __p;
          if (v31 < 0) {
            uint64_t v28 = (void **)__p[0];
          }
          *(_DWORD *)__int16 v32 = 136315394;
          *(void *)&v32[4] = "getResolvedAddress";
          *(_WORD *)&v32[12] = 2080;
          *(void *)&v32[14] = v28;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I %s: Failed to resolve ePDG %s", v32, 0x16u);
        }
      }
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(v31) < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      uint64_t v18 = *(NSObject **)(a1 + 88);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = "getResolvedAddress";
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s: domainName is nullptr", buf, 0xCu);
      }
    }
  }
  if (*(void *)(a1 + 440))
  {
    *a5 = 1;
  }
  else
  {
    int v12 = *(unsigned __int8 *)(a1 + 512);
    *a5 = v12;
    if (!v12) {
      goto LABEL_12;
    }
  }
  uint64_t v13 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "getResolvedAddress";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = a3;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s: Context %d is waiting on DNS resolving.", buf, 0x12u);
  }
  sub_1002C6DE8((void *)(a1 + 168), a3, 1);
LABEL_12:
  if (!*(unsigned char *)(a1 + 512)) {
    return sub_100083DA4(a7, (const void **)(a1 + 504));
  }
  unint64_t v14 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "getResolvedAddress";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = a3;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: Context %d is waiting on first successful ePDG connection.", buf, 0x12u);
  }
  uint64_t result = (const void **)sub_1002C6DE8((void *)(a1 + 168), a3, 1);
  *a7 = 0;
  return result;
}

void sub_10122AB88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10122AC04@<X0>(void *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, int a4@<W3>, unsigned char *a5@<X4>, char a6@<W5>, const void **a7@<X8>)
{
  return sub_10122A790((uint64_t)a1 + *(void *)(*a1 - 480), a2, a3, a4, a5, a6, a7);
}

void sub_10122AC24(uint64_t a1@<X0>, const void **a2@<X8>)
{
  if (*(void *)(a1 + 472))
  {
    __dst[0] = 0;
    __dst[1] = 0;
    uint64_t v25 = 0;
    uint64_t v4 = *(void *)(a1 + 464);
    if (*(char *)(v4 + 39) < 0)
    {
      sub_10004FC84(__dst, *(void **)(v4 + 16), *(void *)(v4 + 24));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)(v4 + 16);
      uint64_t v25 = *(void *)(v4 + 32);
    }
    if (SHIBYTE(v25) < 0)
    {
      sub_10004FC84(v21, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)uint64_t v21 = *(_OWORD *)__dst;
      uint64_t v22 = v25;
    }
    if (SHIBYTE(v22) < 0)
    {
      sub_10004FC84(__p, v21[0], (unint64_t)v21[1]);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)v21;
      uint64_t v28 = v22;
    }
    uint64_t v26 = 0;
    if (SHIBYTE(v28) < 0)
    {
      sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)__p;
      *(void *)&uint8_t buf[16] = v28;
    }
    uint64_t v29 = 0;
    if (ctu::cf::convert_copy())
    {
      BOOL v6 = v26;
      uint64_t v26 = v29;
      unint64_t v30 = v6;
      sub_1000558F4(&v30);
    }
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v7 = v26;
    uint64_t v23 = v26;
    uint64_t v26 = 0;
    sub_1000558F4(&v26);
    if (SHIBYTE(v28) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v8 = (void *)(a1 + 504);
    if ((const void **)(a1 + 504) != &v23)
    {
      *(void *)std::string buf = *v8;
      void *v8 = v7;
      uint64_t v23 = 0;
      sub_1000558F4((const void **)buf);
    }
    sub_1000558F4(&v23);
    if (SHIBYTE(v22) < 0) {
      operator delete(v21[0]);
    }
    uint64_t v9 = *(void *)(a1 + 464);
    uint64_t v10 = *(void **)v9;
    v10[1] = *(void *)(v9 + 8);
    **(void **)(v9 + 8) = v10;
    --*(void *)(a1 + 472);
    sub_100125814(a1 + 456, (void **)v9);
    unsigned int v11 = *(NSObject **)(a1 + 88);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_58;
    }
    int v12 = __dst;
    if (v25 < 0) {
      int v12 = (void **)__dst[0];
    }
LABEL_57:
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "getNextResolvedAddress";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s: Try using %s as ePDGAddress.", buf, 0x16u);
LABEL_58:
    if (SHIBYTE(v25) < 0) {
      operator delete(__dst[0]);
    }
    sub_100083DA4(a2, (const void **)(a1 + 504));
    return;
  }
  if (*(void *)(a1 + 496))
  {
    __dst[0] = 0;
    __dst[1] = 0;
    uint64_t v25 = 0;
    uint64_t v5 = *(void *)(a1 + 488);
    if (*(char *)(v5 + 39) < 0)
    {
      sub_10004FC84(__dst, *(void **)(v5 + 16), *(void *)(v5 + 24));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)(v5 + 16);
      uint64_t v25 = *(void *)(v5 + 32);
    }
    if (SHIBYTE(v25) < 0)
    {
      sub_10004FC84(v19, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)uint64_t v19 = *(_OWORD *)__dst;
      uint64_t v20 = v25;
    }
    if (SHIBYTE(v20) < 0)
    {
      sub_10004FC84(__p, v19[0], (unint64_t)v19[1]);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)v19;
      uint64_t v28 = v20;
    }
    uint64_t v26 = 0;
    if (SHIBYTE(v28) < 0)
    {
      sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)__p;
      *(void *)&uint8_t buf[16] = v28;
    }
    uint64_t v29 = 0;
    if (ctu::cf::convert_copy())
    {
      unint64_t v14 = v26;
      uint64_t v26 = v29;
      unint64_t v30 = v14;
      sub_1000558F4(&v30);
    }
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v15 = v26;
    uint64_t v23 = v26;
    uint64_t v26 = 0;
    sub_1000558F4(&v26);
    if (SHIBYTE(v28) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v16 = (void *)(a1 + 504);
    if ((const void **)(a1 + 504) != &v23)
    {
      *(void *)std::string buf = *v16;
      void *v16 = v15;
      uint64_t v23 = 0;
      sub_1000558F4((const void **)buf);
    }
    sub_1000558F4(&v23);
    if (SHIBYTE(v20) < 0) {
      operator delete(v19[0]);
    }
    uint64_t v17 = *(void *)(a1 + 488);
    uint64_t v18 = *(void **)v17;
    v18[1] = *(void *)(v17 + 8);
    **(void **)(v17 + 8) = v18;
    --*(void *)(a1 + 496);
    sub_100125814(a1 + 480, (void **)v17);
    unsigned int v11 = *(NSObject **)(a1 + 88);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_58;
    }
    int v12 = __dst;
    if (v25 < 0) {
      int v12 = (void **)__dst[0];
    }
    goto LABEL_57;
  }
  uint64_t v13 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "getNextResolvedAddress";
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s: Failed to find working ePDG address", buf, 0xCu);
  }
  *a2 = 0;
}

void sub_10122B104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,const void *a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(a1);
}

void sub_10122B1D0(void *a1@<X0>, const void **a2@<X8>)
{
}

void sub_10122B1F0(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[6];
  if (v3)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 264))(v3);
    BOOL v6 = *(uint64_t **)v5;
    uint64_t v7 = *(uint64_t **)(v5 + 8);
    if (*(uint64_t **)v5 != v7)
    {
      do
      {
        uint64_t v9 = *v6;
        uint64_t v8 = (std::__shared_weak_count *)v6[1];
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t *__return_ptr, void *))(*a1 + 16))(&v10, a1);
        (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v9 + 400))(v9, &v10, a2);
        if (v11) {
          sub_10004D2C8(v11);
        }
        if (v8) {
          sub_10004D2C8(v8);
        }
        v6 += 2;
      }
      while (v6 != v7);
    }
  }
}

void sub_10122B310(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10122B33C(void *a1, uint64_t a2)
{
}

void sub_10122B35C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = sub_101220B14((PersonalitySpecificImpl *)a1);
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: -------------------------- %s --------------------------", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    uint64_t v3 = subscriber::asString();
    PersonalitySpecificImpl::personalityId((uint64_t *)&__p, (PersonalitySpecificImpl *)a1);
    uint64_t v4 = v40;
    if ((v40 & 0x80u) == 0)
    {
      p_p = (const char *)&__p;
    }
    else
    {
      uint64_t v4 = *((void *)&__p + 1);
      p_p = (const char *)__p;
    }
    if (v4) {
      BOOL v6 = p_p;
    }
    else {
      BOOL v6 = "<invalid>";
    }
    int v7 = *(_DWORD *)(a1 + 296);
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v6;
    *(_WORD *)&buf[22] = 1024;
    int v42 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t simSlot=%s personalityId=%s fActiveContextsCnt=%d", buf, 0x1Cu);
    if ((char)v40 < 0) {
      operator delete((void *)__p);
    }
    uint64_t v2 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 720))
    {
      sub_1005933FC(a1 + 520, buf);
      if ((buf[23] & 0x80u) == 0) {
        uint64_t v8 = buf;
      }
      else {
        uint64_t v8 = *(uint8_t **)buf;
      }
      LODWORD(__p) = 136315138;
      *(void *)((char *)&__p + 4) = v8;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fIMSInfo=%s", (uint8_t *)&__p, 0xCu);
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
    }
    else
    {
      LODWORD(__p) = 136315138;
      *(void *)((char *)&__p + 4) = "<empty>";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fIMSInfo=%s", (uint8_t *)&__p, 0xCu);
    }
    uint64_t v2 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = (void *)(a1 + 728);
    if (*(char *)(a1 + 751) < 0) {
      uint64_t v9 = (void *)*v9;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fImpiUser=%s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *(_DWORD *)(a1 + 516);
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fHOPreferredTypet=%d", buf, 8u);
    uint64_t v2 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = asStringBool(*(unsigned char *)(a1 + 512));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fePDGTryingToConnect=%s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = asStringBool(*(unsigned char *)(a1 + 976));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fWiFiAvailable=%s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = asStringBool(*(unsigned char *)(a1 + 384));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fIsWoWSupported=%s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = asString();
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v14;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fCurrentVoWiFiProv=%s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = asStringBool(*(unsigned char *)(a1 + 1008));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v15;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t Is serving network satellite system=%s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = (void *)(a1 + 360);
    if (*(char *)(a1 + 383) < 0) {
      uint64_t v16 = (void *)*v16;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fWifiInterfaceName = %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fePDGAddressPriorityHiList [", buf, 2u);
  }
  for (uint64_t i = *(void *)(a1 + 464); i != a1 + 456; uint64_t i = *(void *)(i + 8))
  {
    memset(buf, 0, sizeof(buf));
    if (*(char *)(i + 39) < 0)
    {
      sub_10004FC84(buf, *(void **)(i + 16), *(void *)(i + 24));
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)(i + 16);
      *(void *)&uint8_t buf[16] = *(void *)(i + 32);
    }
    uint64_t v18 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      if ((buf[23] & 0x80u) == 0) {
        uint64_t v19 = buf;
      }
      else {
        uint64_t v19 = *(uint8_t **)buf;
      }
      LODWORD(__p) = 136315138;
      *(void *)((char *)&__p + 4) = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\t %s", (uint8_t *)&__p, 0xCu);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
  uint64_t v20 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t ]", buf, 2u);
    uint64_t v20 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fePDGAddressPriorityLoList [", buf, 2u);
  }
  for (uint64_t j = *(void *)(a1 + 488); j != a1 + 480; uint64_t j = *(void *)(j + 8))
  {
    memset(buf, 0, sizeof(buf));
    if (*(char *)(j + 39) < 0)
    {
      sub_10004FC84(buf, *(void **)(j + 16), *(void *)(j + 24));
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)(j + 16);
      *(void *)&uint8_t buf[16] = *(void *)(j + 32);
    }
    uint64_t v22 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      if ((buf[23] & 0x80u) == 0) {
        uint64_t v23 = buf;
      }
      else {
        uint64_t v23 = *(uint8_t **)buf;
      }
      LODWORD(__p) = 136315138;
      *(void *)((char *)&__p + 4) = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\t %s", (uint8_t *)&__p, 0xCu);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
  uint64_t v24 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t ]", buf, 2u);
    uint64_t v24 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = *(void *)(a1 + 504);
    *(_DWORD *)std::string buf = 138412290;
    *(void *)&uint8_t buf[4] = v25;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fePDGAddress = %@", buf, 0xCu);
    uint64_t v24 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I DATA:: -------------- Tech DataContexts --------------", buf, 2u);
  }
  uint64_t v26 = *(void *)(a1 + 48);
  if (v26)
  {
    uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 264))(v26);
    uint64_t v28 = *(uint64_t **)v27;
    uint64_t v29 = *(uint64_t **)(v27 + 8);
    if (*(uint64_t **)v27 != v29)
    {
      do
      {
        uint64_t v30 = *v28;
        uint64_t v31 = (std::__shared_weak_count *)v28[1];
        if (v31) {
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v30 + 176))(v30, 1);
        if (v31) {
          sub_10004D2C8(v31);
        }
        v28 += 2;
      }
      while (v28 != v29);
    }
  }
  __int16 v32 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I DATA:: ", buf, 2u);
    __int16 v32 = *(NSObject **)(a1 + 88);
  }
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I DATA:: -------------- Tech DataSettings --------------", buf, 2u);
  }
  unint64_t v33 = *(uint64_t **)(a1 + 96);
  for (uint64_t k = *(uint64_t **)(a1 + 104); v33 != k; v33 += 2)
  {
    uint64_t v35 = *v33;
    unint64_t v36 = (std::__shared_weak_count *)v33[1];
    if (v36) {
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v35)
    {
      (*(void (**)(uint64_t))(*(void *)v35 + 664))(v35);
    }
    else
    {
      uint64_t v37 = *(NSObject **)(a1 + 88);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I DATA:: **Null DataSetting**", buf, 2u);
      }
    }
    if (v36) {
      sub_10004D2C8(v36);
    }
  }
  CFDictionaryRef v38 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I DATA:: ", buf, 2u);
  }
}

void sub_10122BD28(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10122BD4C(void *a1)
{
}

BOOL sub_10122BD6C(uint64_t a1)
{
  return *(_DWORD *)(a1 + 800) == 2;
}

BOOL sub_10122BD7C(void *a1)
{
  return *(_DWORD *)((char *)a1 + *(void *)(*a1 - 536) + 800) == 2;
}

void sub_10122BDA8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 96);
  for (uint64_t i = *(void **)(a1 + 104); v1 != i; v1 += 2)
  {
    uint64_t v3 = *v1;
    if (*v1)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 0;
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v3 + 224))(&v4);
      if (v4 && *(unsigned char *)(v4 + 100)) {
        (*(void (**)(void, uint64_t, const char *, void, void))(*(void *)*v1 + 424))(*v1, 1, "WiFiAPChanged", 0, 0);
      }
      if (v5) {
        sub_10004D2C8(v5);
      }
    }
  }
}

void sub_10122BE88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10122BEA0(void *a1)
{
}

uint64_t sub_10122BEC0()
{
  return 0;
}

uint64_t sub_10122BEC8()
{
  return 0;
}

uint64_t sub_10122BED0()
{
  return 0;
}

uint64_t sub_10122BEE4()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_10122BEEC()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_10122BEF4()
{
  return 0;
}

uint64_t sub_10122BEFC()
{
  return 0;
}

uint64_t sub_10122BF10()
{
  return 0;
}

uint64_t sub_10122BF18()
{
  return 0;
}

uint64_t sub_10122BF20()
{
  return 0;
}

uint64_t sub_10122BF34()
{
  return 0;
}

uint64_t sub_10122BF3C()
{
  return 0;
}

uint64_t sub_10122BF44()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_10122BF4C()
{
  return 0xFFFFFFFFLL;
}

void sub_10122BF64(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10122BF9C(uint64_t a1)
{
}

uint64_t sub_10122BFB8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10122BFFC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10122C028(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      if (*(void *)a2)
      {
        dispatch_release(**(dispatch_object_t **)a2);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x80000001015DF031 & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x80000001015DF031 & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
  return result;
}

void sub_10122C168(uint64_t *a1, uint64_t a2, long long **a3)
{
  uint64_t v3 = *a1;
  memset(v5, 0, 24);
  sub_1000302C0((char *)v5, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  long long v4 = *(_OWORD *)(v3 + 8);
  uint64_t v7 = *(void *)(v3 + 24);
  long long v6 = v4;
  v5[3] = (char *)off_101AA3598 + 1;
  sub_100168470();
}

void sub_10122C210(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100168C78((uint64_t *)va);
  sub_100047F64((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10122C230(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        *(_WORD *)(a2 + 8) = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x80000001015DF0F8 & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x80000001015DF0F8 & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(a2 + 16) = *(void *)(result + 16);
    *(_OWORD *)a2 = v5;
  }
  return result;
}

uint64_t sub_10122C2D8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(uint64_t (**)(void *))a1;
  uint64_t v3 = (void *)(*(void *)(a1 + 16) + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

void *sub_10122C320(void *a1)
{
  *a1 = off_101AA35E0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10122C36C(void *a1)
{
  *a1 = off_101AA35E0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_10122C3D8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_10122C488(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10122C4A0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_10122C4C0()
{
}

void *sub_10122C52C(void *a1)
{
  *a1 = off_101AA3630;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10122C578(void *a1)
{
  *a1 = off_101AA3630;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_10122C5E4()
{
}

uint64_t sub_10122C650(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      if (*(void *)a2)
      {
        dispatch_release(**(dispatch_object_t **)a2);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x80000001015DF2DALL & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x80000001015DF2DALL & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
  return result;
}

void sub_10122C790(uint64_t a1)
{
  long long v1 = *(_OWORD *)(*(void *)a1 + 8);
  uint64_t v4 = *(void *)(*(void *)a1 + 24);
  long long v3 = v1;
  uint64_t v2 = (char *)off_101AA36A0 + 1;
  operator new();
}

void sub_10122C8C4()
{
}

uint64_t sub_10122C8F8(uint64_t a1)
{
  sub_10081B9B0(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100A849B8(v2);
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    operator delete();
  }
  return result;
}

uint64_t sub_10122C97C(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        *(_WORD *)(a2 + 8) = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x80000001015DF33DLL & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x80000001015DF33DLL & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(a2 + 16) = *(void *)(result + 16);
    *(_OWORD *)a2 = v5;
  }
  return result;
}

uint64_t sub_10122CA24(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(uint64_t (**)(void *))a1;
  long long v3 = (void *)(*(void *)(a1 + 16) + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

uint64_t sub_10122CA6C(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      if (*(void *)a2)
      {
        dispatch_release(**(dispatch_object_t **)a2);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x80000001015DF3FFLL & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x80000001015DF3FFLL & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
  return result;
}

void sub_10122CBAC(uint64_t a1)
{
  long long v1 = *(_OWORD *)(*(void *)a1 + 8);
  uint64_t v4 = *(void *)(*(void *)a1 + 24);
  long long v3 = v1;
  uint64_t v2 = (char *)off_101AA3730 + 1;
  operator new();
}

void sub_10122CCE0()
{
}

uint64_t sub_10122CD14(uint64_t a1)
{
  sub_1003595BC(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100980A44(v2);
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    operator delete();
  }
  return result;
}

uint64_t sub_10122CD98(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        *(_WORD *)(a2 + 8) = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x80000001015DF462 & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x80000001015DF462 & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(a2 + 16) = *(void *)(result + 16);
    *(_OWORD *)a2 = v5;
  }
  return result;
}

uint64_t sub_10122CE40(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(uint64_t (**)(void *))a1;
  long long v3 = (void *)(*(void *)(a1 + 16) + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

void sub_10122CE8C()
{
}

__n128 sub_10122CEA0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA3790;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10122CEF4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA3790;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10122CF2C(uint64_t a1, xpc_object_t *a2)
{
  sub_100089CF0(*(uint64_t **)(a1 + 8), a2);
  long long v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  long long v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    long long v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10122CFA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10122CFE8()
{
}

void sub_10122CFF8()
{
}

__n128 sub_10122D00C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA3810;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10122D060(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA3810;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10122D098(uint64_t *a1, xpc_object_t *a2)
{
  sub_1000E4B84(a1[1], a2);
  long long v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  long long v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    long long v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10122D114(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10122D154()
{
}

void sub_10122D164()
{
}

__n128 sub_10122D178(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA3890;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10122D1CC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA3890;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10122D204(void *a1, xpc_object_t *a2)
{
  long long v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  long long v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  int v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100A5892C((uint64_t)v3, a2, "PersonalityID", "State");
  long long v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1007035FC((uint64_t)&v9, v10);
}

void sub_10122D2D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10122D2EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10122D32C()
{
}

void sub_10122D33C()
{
}

__n128 sub_10122D350(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA3910;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10122D3A4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA3910;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10122D3DC(uint64_t *a1, xpc_object_t *a2)
{
  sub_100169118(a1[1], a2);
  long long v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  long long v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    long long v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10122D458(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10122D498()
{
}

void sub_10122D4A8()
{
}

__n128 sub_10122D4BC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101AA3990;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10122D510(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA3990;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10122D548(void *a1)
{
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  *(_OWORD *)long long __p = 0u;
  long long v6 = 0u;
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)((char *)v7 + 12));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)((char *)&v7[2] + 4));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)((char *)&v7[3] + 12));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)((char *)&v7[5] + 4));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)((char *)&v7[6] + 12));
  read_rest_value();
  uint64_t v2 = (void (*)(void *, void **))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, void **))(*v4 + v2);
  }
  v2(v4, __p);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[1]);
  }
}

void sub_10122D634(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10122D654(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10122D694()
{
}

void sub_10122D6A4()
{
}

__n128 sub_10122D6B8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA3A10;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10122D70C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA3A10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10122D744(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  long long v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  int v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1001A89B8((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10019D460((uint64_t)&v9, v10);
}

void sub_10122D804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10122D81C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10122D85C()
{
}

void sub_10122D86C()
{
}

__n128 sub_10122D880(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA3A90;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10122D8D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA3A90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10122D90C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  long long v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  int v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1005BF770((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10003FB28((uint64_t)&v9, v10);
}

void sub_10122D9CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10122D9E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10122DA24()
{
}

void sub_10122DA34()
{
}

__n128 sub_10122DA48(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA3B10;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10122DA9C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA3B10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10122DAD4(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  int v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1004CED98((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000886C0((uint64_t)&v9, v10);
}

void sub_10122DB94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_10122DBAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10122DBEC()
{
}

uint64_t sub_10122DBF8(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  uint64_t v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      uint64_t v19 = 0;
      long long v6 = *(uint64_t **)(a1 + 8);
      if (*(uint64_t **)a1 == v3)
      {
        uint64_t v8 = v3;
        if (!v6) {
          goto LABEL_14;
        }
      }
      else
      {
        uint64_t v7 = v3;
        if (v6)
        {
          do
          {
            uint64_t v8 = v6;
            long long v6 = (uint64_t *)v6[1];
          }
          while (v6);
        }
        else
        {
          do
          {
            uint64_t v8 = (uint64_t *)v7[2];
            BOOL v9 = *v8 == (void)v7;
            uint64_t v7 = v8;
          }
          while (v9);
        }
        if ((sub_100046FE8(v8 + 4, (void **)v5 + 4) & 0x80) == 0)
        {
          int v10 = (uint64_t **)sub_100046ED4(a1, &v19, (void **)v5 + 4);
          goto LABEL_11;
        }
        if (!*v3)
        {
LABEL_14:
          uint64_t v19 = v3;
          int v10 = (uint64_t **)v3;
LABEL_15:
          uint64_t v18 = 0;
          uint64_t v11 = (uint64_t *)operator new(0x100uLL);
          uint64_t v12 = v11;
          v17[0] = v11;
          v17[1] = v3;
          if (*((char *)v5 + 55) < 0)
          {
            sub_10004FC84((unsigned char *)v11 + 32, (void *)v5[4], v5[5]);
          }
          else
          {
            long long v13 = *((_OWORD *)v5 + 2);
            v11[6] = v5[6];
            *((_OWORD *)v11 + 2) = v13;
          }
          sub_1001A90AC((char *)v12 + 56, (long long *)(v5 + 7));
          LOBYTE(v18) = 1;
          sub_100046C38((uint64_t **)a1, (uint64_t)v19, v10, v17[0]);
          v17[0] = 0;
          sub_1001A9054((uint64_t)v17, 0);
          goto LABEL_19;
        }
      }
      uint64_t v19 = v8;
      int v10 = (uint64_t **)(v8 + 1);
LABEL_11:
      if (!*v10) {
        goto LABEL_15;
      }
LABEL_19:
      uint64_t v14 = (void *)v5[1];
      if (v14)
      {
        do
        {
          uint64_t v15 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          uint64_t v15 = (void *)v5[2];
          BOOL v9 = *v15 == (void)v5;
          uint64_t v5 = v15;
        }
        while (!v9);
      }
      uint64_t v5 = v15;
    }
    while (v15 != v4);
  }
  return a1;
}

void sub_10122DDA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1001A9054((uint64_t)&a9, 0);
  sub_10019D460(v9, *(void **)(v9 + 8));
  _Unwind_Resume(a1);
}

void sub_10122DDF0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10122DE28(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10122DE58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10122DEA0()
{
}

void *sub_10122DEB4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA3C08;
  result[1] = v3;
  return result;
}

uint64_t sub_10122DEFC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA3C08;
  a2[1] = v2;
  return result;
}

uint64_t sub_10122DF28(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 8) + 120) + 40))(*(void *)(*(void *)(a1 + 8) + 120), 1);
}

uint64_t sub_10122DF58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10122DF98()
{
}

void *sub_10122DFA4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10122E02C()
{
}

void *sub_10122E040(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA3C98;
  result[1] = v3;
  return result;
}

uint64_t sub_10122E088(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA3C98;
  a2[1] = v2;
  return result;
}

const void **sub_10122E0B4@<X0>(uint64_t a1@<X0>, const char *a2@<X2>, void *a3@<X8>)
{
  DataUtils::loadPlistFromBundleResource((uint64_t *)&v5, (DataUtils *)(*(void *)(a1 + 8) + 88), (const ctu::OsLogLogger *)"default_tech", a2);
  sub_10004EFE4(a3, &v5);
  return sub_10005717C(&v5);
}

void sub_10122E108(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10122E11C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10122E15C()
{
}

uint64_t *sub_10122E168(uint64_t **a1, int a2, int a3, uint64_t *a4)
{
  uint64_t v10 = 0;
  uint64_t result = sub_10122E200((uint64_t)a1, &v10, a2, a3);
  if (!*result)
  {
    uint64_t v7 = (uint64_t **)result;
    uint64_t v8 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v8 + 28) = *a4;
    uint64_t v9 = v10;
    return sub_100046C38(a1, v9, v7, v8);
  }
  return result;
}

uint64_t *sub_10122E200(uint64_t a1, void *a2, int a3, int a4)
{
  long long v6 = *(uint64_t **)(a1 + 8);
  uint64_t result = (uint64_t *)(a1 + 8);
  uint64_t v5 = v6;
  if (v6)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = v5;
        int v8 = *((_DWORD *)v5 + 7);
        int v9 = *((_DWORD *)v7 + 8);
        BOOL v10 = v9 > a4;
        if (v8 != a3) {
          BOOL v10 = v8 > a3;
        }
        if (!v10) {
          break;
        }
        uint64_t v5 = (uint64_t *)*v7;
        uint64_t result = v7;
        if (!*v7) {
          goto LABEL_13;
        }
      }
      BOOL v11 = v9 < a4;
      BOOL v12 = v8 == a3;
      BOOL v13 = v8 < a3;
      if (v12) {
        BOOL v13 = v11;
      }
      if (!v13) {
        break;
      }
      uint64_t result = v7 + 1;
      uint64_t v5 = (uint64_t *)v7[1];
    }
    while (v5);
  }
  else
  {
    uint64_t v7 = result;
  }
LABEL_13:
  *a2 = v7;
  return result;
}

uint64_t sub_10122E278(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  uint64_t v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      int v6 = *((_DWORD *)v5 + 7);
      int v7 = *((_DWORD *)v5 + 8);
      uint64_t v20 = 0;
      uint64_t v8 = *(void *)(a1 + 8);
      uint64_t v9 = v3;
      if (*(void *)a1 == v3) {
        goto LABEL_10;
      }
      uint64_t v10 = *(void *)(a1 + 8);
      uint64_t v11 = v3;
      if (v8)
      {
        do
        {
          uint64_t v9 = v10;
          uint64_t v10 = *(void *)(v10 + 8);
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v9 = *(void *)(v11 + 16);
          BOOL v12 = *(void *)v9 == v11;
          uint64_t v11 = v9;
        }
        while (v12);
      }
      int v13 = *(_DWORD *)(v9 + 28);
      BOOL v12 = v13 == v6;
      BOOL v14 = v13 < v6;
      if (v12) {
        BOOL v14 = *(_DWORD *)(v9 + 32) < v7;
      }
      if (v14)
      {
LABEL_10:
        if (v8)
        {
          uint64_t v20 = v9;
          uint64_t v15 = (uint64_t *)(v9 + 8);
        }
        else
        {
          uint64_t v20 = v3;
          uint64_t v15 = (uint64_t *)v3;
        }
      }
      else
      {
        uint64_t v15 = sub_10122E200(a1, &v20, v6, v7);
      }
      if (!*v15)
      {
        uint64_t v16 = (uint64_t *)operator new(0x28uLL);
        *(uint64_t *)((char *)v16 + 28) = *(void *)((char *)v5 + 28);
        sub_100046C38((uint64_t **)a1, v20, (uint64_t **)v15, v16);
      }
      uint64_t v17 = (void *)v5[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v5[2];
          BOOL v12 = *v18 == (void)v5;
          uint64_t v5 = v18;
        }
        while (!v12);
      }
      uint64_t v5 = v18;
    }
    while (v18 != v4);
  }
  return a1;
}

void sub_10122E3CC(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_10122E3E4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10122E3F4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10122E410(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void *sub_10122E420(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

std::string *sub_10122E4A8(void *a1, std::string *a2)
{
  std::locale::locale(&v12);
  uint64_t v4 = std::locale::use_facet(&v12, &std::ctype<char>::id);
  std::locale::~locale(&v12);
  std::string::value_type v5 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v4->__vftable[2].~facet_0)(v4, 48);
  std::string::value_type v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v4->__vftable[2].~facet_0)(v4, 49);
  std::string::size_type v7 = a1[3];
  uint64_t result = std::string::assign(a2, v7, v5);
  if (v7)
  {
    unint64_t v9 = 0;
    std::string::size_type v10 = v7 - 1;
    do
    {
      if ((*(void *)(*a1 + ((v9 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v9))
      {
        if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v11 = a2;
        }
        else {
          uint64_t v11 = (std::string *)a2->__r_.__value_.__r.__words[0];
        }
        v11->__r_.__value_.__s.__data_[v10] = v6;
      }
      ++v9;
      --v10;
    }
    while (v10 != -1);
  }
  return result;
}

void sub_10122E5C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void *sub_10122E5D8(void *a1)
{
  *a1 = off_101AA3D50;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10122E624(void *a1)
{
  *a1 = off_101AA3D50;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_10122E690(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101AA3D50;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10122E6F4(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101AA3D50;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10122E734(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10122E744(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_10122E784(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  xpc::dyn_cast_or_default();
  long long __p = *(void **)buf;
  *(void *)uint64_t v8 = *(void *)&buf[8];
  *(void *)&v8[7] = *(void *)&buf[15];
  char v9 = v11;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(v3 + 88);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    p_p = &__p;
    if (v11 < 0) {
      p_p = *(void ***)buf;
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "operator()";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = p_p;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Received WAN IP from mobile helper: %s", buf, 0x16u);
  }
  sub_101229FF8(v3, &__p);
  if (v9 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
}

void sub_10122E8C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10122E908(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10122E948()
{
}

uint64_t sub_10122E954(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a2;
  if ((void *)(a1 + 8 * a3) != a2)
  {
    uint64_t v3 = (void *)(a1 + 8 * a3);
    while (!*v3)
    {
      if (++v3 == a2)
      {
        uint64_t v3 = a2;
        break;
      }
    }
  }
  uint64_t v4 = (uint64_t)v3 - a1;
  if (v4 >> 3 >= (unint64_t)(((uint64_t)a2 - a1) >> 3)) {
    return -1;
  }
  else {
    return 8 * v4 + (int)sub_10122E9C8(*(void *)(a1 + 8 * (v4 >> 3)));
  }
}

uint64_t sub_10122E9C8(uint64_t a1)
{
  if (!a1) {
    __assert_rtn("lowest_bit", "lowest_bit.hpp", 26, "x >= 1");
  }
  unint64_t v1 = -a1 & a1;
  if (v1 == 1) {
    return 0;
  }
  if (!v1) {
    __assert_rtn("integer_log2", "integer_log2.hpp", 96, "x > 0");
  }
  LODWORD(result) = 0;
  int v3 = 32;
  do
  {
    unint64_t v4 = v1 >> v3;
    if (v3 >= 0) {
      int v5 = v3;
    }
    else {
      int v5 = v3 + 1;
    }
    if (!v4) {
      int v3 = 0;
    }
    int v6 = v5 >> 1;
    if (v4) {
      unint64_t v1 = v4;
    }
    uint64_t result = (v3 + result);
    int v3 = v6;
  }
  while (v1 != 1);
  return result;
}

void *sub_10122EA70(void *a1)
{
  *a1 = off_101AA3DD0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10122EABC(void *a1)
{
  *a1 = off_101AA3DD0;
  unint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_10122EB28(uint64_t a1)
{
  uint64_t result = operator new(0x20uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_101AA3DD0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *((unsigned char *)result + 24) = *(unsigned char *)(a1 + 24);
  return result;
}

uint64_t sub_10122EB8C(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *(void *)a2 = off_101AA3DD0;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a2 + 24) = *(unsigned char *)(result + 24);
  return result;
}

void sub_10122EBCC(uint64_t a1)
{
  unint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10122EBDC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10122EC1C(uint64_t a1, long long **a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      int v6 = v5;
      std::string::size_type v7 = *(void **)(a1 + 8);
      if (v7)
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        sub_1000302C0((char *)&v17, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 3));
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        v13[2] = sub_10122EE70;
        v13[3] = &unk_101AA3E30;
        v13[4] = v7;
        BOOL v14 = v6;
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        memset(v15, 0, sizeof(v15));
        sub_1000302C0((char *)v15, v17, v18, 0xAAAAAAAAAAAAAAABLL * (((char *)v18 - (char *)v17) >> 3));
        char v16 = *(unsigned char *)(a1 + 24);
        uint64_t v8 = (std::__shared_weak_count *)v7[8];
        if (!v8 || (char v9 = (void **)v7[7], (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        char v11 = v10;
        std::locale v12 = v7[9];
        block[0] = _NSConcreteStackBlock;
        block[1] = (void **)1174405120;
        block[2] = (void **)sub_10122E3E4;
        block[3] = (void **)&unk_101AA3D10;
        block[5] = v9;
        uint64_t v21 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = (void **)v13;
        dispatch_async(v12, block);
        if (v21) {
          sub_10004D2C8(v21);
        }
        sub_10004D2C8(v11);
        block[0] = (void **)v15;
        sub_100047F64(block);
        if (v14) {
          sub_10004D2C8(v14);
        }
        block[0] = (void **)&v17;
        sub_100047F64(block);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10122EDE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,void **a22)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  a22 = (void **)&a19;
  sub_100047F64(&a22);
  sub_10004D2C8(v22);
  _Unwind_Resume(a1);
}

uint64_t sub_10122EE24(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10122EE64()
{
}

void sub_10122EE70(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 72);
  uint64_t v4 = (uint64_t *)(v2 + 456);
  sub_1001257B0((void *)(v2 + 456));
  int v5 = (uint64_t *)(v2 + 480);
  sub_1001257B0((void *)(v2 + 480));
  int v6 = *(uint64_t **)(v2 + 440);
  if (v6)
  {
    if (v3)
    {
      BOOL v7 = 0;
      goto LABEL_37;
    }
    v68[0] = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(v2 + 32));
    std::string::size_type v10 = ServiceMap;
    if (v11 < 0)
    {
      std::locale v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
    if (v15)
    {
      uint64_t v17 = v15[3];
      char v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        uint64_t v19 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)v2);
        (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, void, void, void))(*(void *)v17 + 80))(&cf, v17, v19, 1, kIWLANSettingsKey, 0, 0);
        __p[0] = (void *)cf;
        if (cf) {
          CFRetain(cf);
        }
        *(void *)long long __dst = 0;
        *(void *)std::string buf = 0;
        sub_10004EFE4(buf, (CFTypeRef *)__p);
        if (*(void *)buf) {
          uint64_t v20 = sub_100080778;
        }
        else {
          uint64_t v20 = 0;
        }
        if (v20) {
          sub_100058140((const void **)__dst, (const void **)buf);
        }
        sub_100057D78((const void **)buf);
        CFDictionaryRef v21 = *(const __CFDictionary **)__dst;
        v68[0] = *(void **)__dst;
        *(void *)long long __dst = 0;
        sub_100057D78((const void **)__dst);
        sub_1000577C4((const void **)__p);
        sub_1000577C4(&cf);
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        if (v21) {
          uint64_t v22 = sub_100080778;
        }
        else {
          uint64_t v22 = 0;
        }
        if (v22)
        {
          CFDictionaryRef Value = (BOOL *)CFDictionaryGetValue(v21, @"EPDGIPv4Priority");
          uint64_t v24 = Value;
          if (Value && (CFTypeID v25 = CFGetTypeID(Value), v25 == CFBooleanGetTypeID()))
          {
            buf[0] = 0;
            ctu::cf::assign((ctu::cf *)buf, v24, v26);
            BOOL v7 = buf[0] != 0;
          }
          else
          {
            BOOL v7 = 1;
          }
          uint64_t v27 = *(NSObject **)(v2 + 88);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v28 = asStringBool(v7);
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = "readCBePDGIPv4Priority";
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v28;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I %s: EPDGIPv4Priority=%s", buf, 0x16u);
          }
        }
        else
        {
          uint64_t v29 = *(NSObject **)(v2 + 88);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = "readCBePDGIPv4Priority";
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %s: no TechSettings dictionary can be found", buf, 0xCu);
          }
          BOOL v7 = 1;
        }
        sub_100057D78((const void **)v68);
LABEL_37:
        uint64_t v30 = *(long long **)(a1 + 48);
        for (i = *(long long **)(a1 + 56); v30 != i; uint64_t v30 = (long long *)((char *)v30 + 24))
        {
          memset(buf, 0, sizeof(buf));
          if (*((char *)v30 + 23) < 0)
          {
            sub_10004FC84(buf, *(void **)v30, *((void *)v30 + 1));
          }
          else
          {
            long long v32 = *v30;
            *(void *)&uint8_t buf[16] = *((void *)v30 + 2);
            *(_OWORD *)std::string buf = v32;
          }
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v73 = 0;
          CSIPacketAddress::CSIPacketAddress();
          if ((CSIPacketAddress::isZeroIP((CSIPacketAddress *)__p) & 1) == 0)
          {
            if ((v7 & CSIPacketAddress::isIPv4((CSIPacketAddress *)__p) & 1) != 0
              || ((v7 | CSIPacketAddress::isIPv4((CSIPacketAddress *)__p)) & 1) == 0)
            {
              CFDictionaryRef v38 = *(NSObject **)(v2 + 88);
              if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
              {
                CFTypeID v39 = buf;
                if ((buf[23] & 0x80u) != 0) {
                  CFTypeID v39 = *(uint8_t **)buf;
                }
                *(_DWORD *)long long __dst = 136315394;
                *(void *)&__dst[4] = "ePDGResolveCallback";
                *(_WORD *)&__dst[12] = 2080;
                *(void *)&__dst[14] = v39;
                _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I %s: Adding resolved ePDG address %s, priority 1.", __dst, 0x16u);
              }
              unsigned __int8 v40 = sub_1007E8A70(v2 + 456, 0, 0, (uint64_t)buf);
              v40[1] = v4;
              uint64_t v41 = *v4;
              *unsigned __int8 v40 = *v4;
              *(void *)(v41 + 8) = v40;
              *uint64_t v4 = (uint64_t)v40;
              uint64_t v37 = (void *)(v2 + 472);
            }
            else
            {
              unint64_t v33 = *(NSObject **)(v2 + 88);
              if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
              {
                __int16 v34 = buf;
                if ((buf[23] & 0x80u) != 0) {
                  __int16 v34 = *(uint8_t **)buf;
                }
                *(_DWORD *)long long __dst = 136315394;
                *(void *)&__dst[4] = "ePDGResolveCallback";
                *(_WORD *)&__dst[12] = 2080;
                *(void *)&__dst[14] = v34;
                _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I %s: Adding resolved ePDG address %s, priority 2.", __dst, 0x16u);
              }
              uint64_t v35 = sub_1007E8A70(v2 + 480, 0, 0, (uint64_t)buf);
              v35[1] = v5;
              uint64_t v36 = *v5;
              *uint64_t v35 = *v5;
              *(void *)(v36 + 8) = v35;
              uint64_t *v5 = (uint64_t)v35;
              uint64_t v37 = (void *)(v2 + 496);
            }
            ++*v37;
          }
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
        }
        if (*(void *)(v2 + 472))
        {
          memset(__dst, 0, sizeof(__dst));
          uint64_t v42 = *(void *)(v2 + 464);
          if (*(char *)(v42 + 39) < 0)
          {
            sub_10004FC84(__dst, *(void **)(v42 + 16), *(void *)(v42 + 24));
          }
          else
          {
            *(_OWORD *)long long __dst = *(_OWORD *)(v42 + 16);
            *(void *)&__dst[16] = *(void *)(v42 + 32);
          }
          if ((char)__dst[23] < 0)
          {
            sub_10004FC84(v68, *(void **)__dst, *(unint64_t *)&__dst[8]);
          }
          else
          {
            *(_OWORD *)int v68 = *(_OWORD *)__dst;
            uint64_t v69 = *(void *)&__dst[16];
          }
          if (SHIBYTE(v69) < 0)
          {
            sub_10004FC84(__p, v68[0], (unint64_t)v68[1]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)v68;
            uint64_t v73 = v69;
          }
          int v71 = 0;
          if (SHIBYTE(v73) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)__p;
            *(void *)&uint8_t buf[16] = v73;
          }
          long long v74 = 0;
          if (ctu::cf::convert_copy())
          {
            uint64_t v44 = v71;
            int v71 = v74;
            CFTypeRef cf = v44;
            sub_1000558F4(&cf);
          }
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          BOOL v45 = v71;
          uint64_t v70 = v71;
          int v71 = 0;
          sub_1000558F4(&v71);
          if (SHIBYTE(v73) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v46 = (void *)(v2 + 504);
          if ((const void **)(v2 + 504) != &v70)
          {
            *(void *)std::string buf = *v46;
            void *v46 = v45;
            uint64_t v70 = 0;
            sub_1000558F4((const void **)buf);
          }
          sub_1000558F4(&v70);
          if (SHIBYTE(v69) < 0) {
            operator delete(v68[0]);
          }
          uint64_t v47 = *(void *)(v2 + 464);
          CFDictionaryRef v48 = *(void **)v47;
          v48[1] = *(void *)(v47 + 8);
          **(void **)(v47 + 8) = v48;
          --*(void *)(v2 + 472);
          sub_100125814(v2 + 456, (void **)v47);
          uint64_t v49 = *(NSObject **)(v2 + 88);
          if (!os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_115;
          }
          CFTypeID v50 = "IPv6";
          if (v7) {
            CFTypeID v50 = "IPv4";
          }
          *(_DWORD *)std::string buf = 136315650;
          *(void *)&uint8_t buf[4] = "ePDGResolveCallback";
          uint64_t v51 = __dst;
          if ((__dst[23] & 0x80u) != 0) {
            uint64_t v51 = *(uint8_t **)__dst;
          }
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v50;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v77 = v51;
          CFTypeID v52 = "#I %s: Found an %s address %s, use as ePDGAddress.";
          CFStringRef v53 = v49;
          uint32_t v54 = 32;
        }
        else
        {
          if (!*(void *)(v2 + 496))
          {
LABEL_117:
            if (*(void *)(v2 + 504)) {
              int v62 = sub_1000810B8;
            }
            else {
              int v62 = 0;
            }
            if (!v62)
            {
              int v63 = *(NSObject **)(v2 + 88);
              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)std::string buf = 136315138;
                *(void *)&uint8_t buf[4] = "ePDGResolveCallback";
                _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "#I %s: No valid ePDG address resolved.", buf, 0xCu);
              }
            }
            v64 = *(std::__shared_weak_count **)(v2 + 448);
            *(void *)(v2 + 440) = 0;
            *(void *)(v2 + 448) = 0;
            if (v64) {
              sub_10004D2C8(v64);
            }
            if (*(void *)(v2 + 504)) {
              uint64_t v65 = sub_1000810B8;
            }
            else {
              uint64_t v65 = 0;
            }
            if (v65)
            {
              if (sub_10122E954(*(void *)(v2 + 168), *(void **)(v2 + 176), 0) != -1)
              {
                uint64_t v66 = *(void *)(v2 + 48);
                if (v66)
                {
                  *(void *)std::string buf = 0;
                  *(void *)&uint8_t buf[8] = 0;
                  (*(void (**)(uint8_t *__return_ptr))(*(void *)v66 + 248))(buf);
                  uint64_t v67 = *(void *)buf;
                  if (*(void *)buf)
                  {
                    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v2 + 16))(__p, v2);
                    (*(void (**)(uint64_t, void **, void))(*(void *)v67 + 408))(v67, __p, *(void *)(v2 + 504));
                    if (__p[1]) {
                      sub_10004D2C8((std::__shared_weak_count *)__p[1]);
                    }
                    *(unsigned char *)(v2 + 512) = 1;
                  }
                  if (*(void *)&buf[8]) {
                    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
                  }
                }
              }
            }
            else
            {
              sub_10122820C(v2);
            }
            return;
          }
          memset(__dst, 0, sizeof(__dst));
          uint64_t v43 = *(void *)(v2 + 488);
          if (*(char *)(v43 + 39) < 0)
          {
            sub_10004FC84(__dst, *(void **)(v43 + 16), *(void *)(v43 + 24));
          }
          else
          {
            *(_OWORD *)long long __dst = *(_OWORD *)(v43 + 16);
            *(void *)&__dst[16] = *(void *)(v43 + 32);
          }
          if ((char)__dst[23] < 0)
          {
            sub_10004FC84(v68, *(void **)__dst, *(unint64_t *)&__dst[8]);
          }
          else
          {
            *(_OWORD *)int v68 = *(_OWORD *)__dst;
            uint64_t v69 = *(void *)&__dst[16];
          }
          if (SHIBYTE(v69) < 0)
          {
            sub_10004FC84(__p, v68[0], (unint64_t)v68[1]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)v68;
            uint64_t v73 = v69;
          }
          int v71 = 0;
          if (SHIBYTE(v73) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)__p;
            *(void *)&uint8_t buf[16] = v73;
          }
          long long v74 = 0;
          if (ctu::cf::convert_copy())
          {
            CFTypeID v55 = v71;
            int v71 = v74;
            CFTypeRef cf = v55;
            sub_1000558F4(&cf);
          }
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          CFStringRef v56 = v71;
          uint64_t v70 = v71;
          int v71 = 0;
          sub_1000558F4(&v71);
          if (SHIBYTE(v73) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v57 = (void *)(v2 + 504);
          if ((const void **)(v2 + 504) != &v70)
          {
            *(void *)std::string buf = *v57;
            *uint64_t v57 = v56;
            uint64_t v70 = 0;
            sub_1000558F4((const void **)buf);
          }
          sub_1000558F4(&v70);
          if (SHIBYTE(v69) < 0) {
            operator delete(v68[0]);
          }
          uint64_t v58 = *(void *)(v2 + 488);
          uint64_t v59 = *(void **)v58;
          v59[1] = *(void *)(v58 + 8);
          **(void **)(v58 + 8) = v59;
          --*(void *)(v2 + 496);
          sub_100125814(v2 + 480, (void **)v58);
          uint64_t v60 = *(NSObject **)(v2 + 88);
          if (!os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
          {
LABEL_115:
            if ((char)__dst[23] < 0) {
              operator delete(*(void **)__dst);
            }
            goto LABEL_117;
          }
          v61 = __dst;
          if ((__dst[23] & 0x80u) != 0) {
            v61 = *(uint8_t **)__dst;
          }
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = "ePDGResolveCallback";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v61;
          CFTypeID v52 = "#I %s: Use %s as ePDGAddress.";
          CFStringRef v53 = v60;
          uint32_t v54 = 22;
        }
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, v52, buf, v54);
        goto LABEL_115;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    char v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  uint64_t v8 = *(NSObject **)(v2 + 88);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "ePDGResolveCallback";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: got callback without triggering DNS resolve?", buf, 0xCu);
  }
}

void sub_10122F9BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, const void *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  sub_1000558F4(&a19);
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  if (*(char *)(v34 - 105) < 0) {
    operator delete(*(void **)(v34 - 128));
  }
  _Unwind_Resume(a1);
}

char *sub_10122FAE0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  return sub_1000302C0((char *)(a1 + 48), *(long long **)(a2 + 48), *(long long **)(a2 + 56), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 56) - *(void *)(a2 + 48)) >> 3));
}

void sub_10122FB44(_Unwind_Exception *exception_object)
{
  int v3 = *(std::__shared_weak_count **)(v1 + 40);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10122FB5C(uint64_t a1)
{
  int v3 = (void **)(a1 + 48);
  sub_100047F64(&v3);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
}

uint64_t sub_10122FBA0(uint64_t a1, uint64_t *a2, long long **a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_100DC23DC((void *)a1, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  sub_10123260C((char *)(a1 + 24), *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  return a1;
}

void sub_10122FC20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10011FF94((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10122FC38(uint64_t a1, long long **a2)
{
  memset(v4, 0, sizeof(v4));
  sub_10122FBA0(a1, v4, a2);
  int v5 = (void **)v4;
  sub_10011FF94(&v5);
  return a1;
}

void sub_10122FC88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10011FF94((void ***)va);
  _Unwind_Resume(a1);
}

void sub_10122FCA0(uint64_t *a1, uint64_t *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_100DC23DC(a1, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  uint64_t v4 = (double *)a2[3];
  int v5 = (double *)a2[4];
  while (v4 != v5)
  {
    sub_101230888((char **)__p, v4, 0x14u);
    sub_100575E60(a1, (uint64_t)__p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v4 += 3;
  }
}

void sub_10122FD3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
  {
    a11 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_10011FF94((void ***)&__p);
  _Unwind_Resume(a1);
}

double *sub_10122FD6C(double *a1, const void **a2)
{
  *(_OWORD *)a1 = xmmword_1015E0CF0;
  a1[2] = 0.65;
  if (*a2) {
    int v3 = sub_100080778;
  }
  else {
    int v3 = 0;
  }
  if (v3)
  {
    double v16 = 0.0;
    double valuePtr = 0.0;
    double v15 = 0.0;
    sub_100058198((const void **)&theDict, a2);
    CFNumberRef v19 = 0;
    CFTypeRef Value = CFDictionaryGetValue(theDict, @"R");
    sub_1000842D0(&v19, &Value);
    if (v19) {
      int v5 = sub_100081E58;
    }
    else {
      int v5 = 0;
    }
    if (v5) {
      CFNumberGetValue(v19, kCFNumberDoubleType, &valuePtr);
    }
    sub_1000570E8((const void **)&v19);
    sub_100057D78((const void **)&theDict);
    sub_100058198((const void **)&v13, a2);
    CFNumberRef v19 = 0;
    CFTypeRef Value = CFDictionaryGetValue(v13, @"I");
    sub_1000842D0(&v19, &Value);
    if (v19) {
      int v6 = sub_100081E58;
    }
    else {
      int v6 = 0;
    }
    if (v6) {
      CFNumberGetValue(v19, kCFNumberDoubleType, &v16);
    }
    sub_1000570E8((const void **)&v19);
    sub_100057D78((const void **)&v13);
    sub_100058198((const void **)&v12, a2);
    CFNumberRef v19 = 0;
    CFTypeRef Value = CFDictionaryGetValue(v12, @"S");
    sub_1000842D0(&v19, &Value);
    if (v19) {
      BOOL v7 = sub_100081E58;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7) {
      CFNumberGetValue(v19, kCFNumberDoubleType, &v15);
    }
    sub_1000570E8((const void **)&v19);
    sub_100057D78((const void **)&v12);
    double v8 = valuePtr;
    if (valuePtr <= 0.0) {
      double v8 = a1[1];
    }
    a1[1] = v8;
    double v9 = v16;
    if (v16 <= 0.0 || v16 >= 1.0) {
      double v9 = *a1;
    }
    *a1 = v9;
    double v10 = v15;
    if (v15 <= 0.0 || v15 >= 1.0) {
      double v10 = a1[2];
    }
    a1[2] = v10;
  }
  return a1;
}

void sub_10122FF74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1000570E8((const void **)(v9 - 24));
  sub_100057D78(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10122FFD0@<X0>(void *a1@<X8>)
{
  uint64_t v21 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v10 = 0u;
  memset(v8, 0, sizeof(v8));
  long long v7 = 0u;
  sub_10004BD84((uint64_t)&v7);
  *(void *)((char *)v8 + *(void *)(v7 - 24)) = 2;
  *(_DWORD *)((char *)v8 + *(void *)(*(void *)&v8[0] - 24) + 8) = *(_DWORD *)((unsigned char *)v8
                                                                                  + *(void *)(*(void *)&v8[0] - 24)
                                                                                  + 8) & 0xFFFFFEFB | 4;
  sub_10004B96C(v8, (uint64_t)"{ I: ", 5);
  uint64_t v2 = (void *)std::ostream::operator<<();
  sub_10004B96C(v2, (uint64_t)" R: ", 4);
  int v3 = (void *)std::ostream::operator<<();
  sub_10004B96C(v3, (uint64_t)" S: ", 4);
  uint64_t v4 = (void *)std::ostream::operator<<();
  sub_10004B96C(v4, (uint64_t)" }", 2);
  sub_10004BC98((uint64_t)v8 + 8, a1);
  *(void *)((char *)&v8[-1]
  *(void *)&v8[0] = v5;
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10123020C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_101230220@<X0>(uint64_t *a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v36 = 0;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  *(_OWORD *)uint64_t v24 = 0u;
  long long v25 = 0u;
  memset(v23, 0, sizeof(v23));
  long long v22 = 0u;
  sub_10004BD84((uint64_t)&v22);
  *(_DWORD *)((char *)v23 + *(void *)(*(void *)&v23[0] - 24) + 8) = *(_DWORD *)((unsigned char *)v23
                                                                                    + *(void *)(*(void *)&v23[0]
                                                                                                - 24)
                                                                                    + 8) & 0xFFFFFEFB | 4;
  *(void *)((char *)v23 + *(void *)(v22 - 24)) = 6;
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  if (*a1 == v5)
  {
    uint64_t v7 = *a1;
  }
  else
  {
    int v6 = 1;
    do
    {
      std::ostream::operator<<();
      std::ostream::operator<<();
      std::ostream::operator<<();
      ++v6;
      v4 += 16;
    }
    while (v4 != v5);
    uint64_t v4 = *a1;
    uint64_t v7 = a1[1];
  }
  std::to_string(&v20, (v7 - v4) >> 4);
  double v8 = std::string::insert(&v20, 0, "P_", 2uLL);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  sub_10004BC98((uint64_t)v23 + 8, __p);
  unint64_t v10 = sub_100206390((uint64_t)&v18, (uint64_t)__p);
  std::to_string(&v19, v10 % 0xF4240);
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v11 = &v19;
  }
  else {
    long long v11 = (std::string *)v19.__r_.__value_.__r.__words[0];
  }
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v19.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v19.__r_.__value_.__l.__size_;
  }
  long long v13 = std::string::append(&v21, (const std::string::value_type *)v11, size);
  *a2 = *v13;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  *(void *)((char *)&v23[-1]
  *(void *)&v23[0] = v14;
  if (SHIBYTE(v25) < 0) {
    operator delete(v24[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_101230544(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,char a35)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  sub_10008248C((uint64_t)&a35);
  _Unwind_Resume(a1);
}

uint64_t sub_1012305BC@<X0>(std::string *a1@<X8>)
{
  uint64_t v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  memset(v11, 0, sizeof(v11));
  long long v10 = 0u;
  sub_10004BD84((uint64_t)&v10);
  *(void *)((char *)v11 + *(void *)(v10 - 24)) = 6;
  *(_DWORD *)((char *)v11 + *(void *)(*(void *)&v11[0] - 24) + 8) = *(_DWORD *)((unsigned char *)v11
                                                                                    + *(void *)(*(void *)&v11[0]
                                                                                                - 24)
                                                                                    + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<();
  std::ostream::operator<<();
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)v11 + 8, __p);
  unint64_t v2 = sub_100206390((uint64_t)&v8, (uint64_t)__p);
  std::to_string(&v9, v2 % 0xF4240);
  int v3 = std::string::insert(&v9, 0, "C_", 2uLL);
  *a1 = *v3;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  *(void *)((char *)&v11[-1]
  *(void *)&v11[0] = v4;
  if (SHIBYTE(v13) < 0) {
    operator delete(*((void **)&v12 + 1));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_101230840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  sub_10008248C((uint64_t)&a23);
  _Unwind_Resume(a1);
}

void sub_101230888(char **a1, double *a2, unsigned int a3)
{
  int v6 = (char *)operator new(0x34uLL);
  char v7 = v6;
  uint64_t v8 = 0;
  *((_DWORD *)v6 + 12) = 72;
  *(_OWORD *)int v6 = xmmword_1015E0DF4;
  *((_OWORD *)v6 + 1) = unk_1015E0E04;
  *((_OWORD *)v6 + 2) = xmmword_1015E0E14;
  while (1)
  {
    unsigned int v9 = *(_DWORD *)&v6[v8];
    if (v9 >= a3) {
      break;
    }
    v8 += 4;
    if (v8 == 52)
    {
      unsigned int v9 = 72;
      unsigned int v10 = 5;
      goto LABEL_6;
    }
  }
  unsigned int v10 = 0x168 / v9;
LABEL_6:
  long long v11 = 0;
  int v12 = 0;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  long long v13 = (unint64_t *)(a1 + 2);
  do
  {
    double v14 = sub_10123254C(*a2, a2[1], a2[2], (double)(v12 * v10));
    double v16 = v14;
    uint64_t v17 = v15;
    if ((unint64_t)v11 >= *v13)
    {
      long long v18 = (double *)*a1;
      uint64_t v19 = ((char *)v11 - *a1) >> 4;
      unint64_t v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 60) {
        sub_100408264();
      }
      uint64_t v21 = *v13 - (void)v18;
      if (v21 >> 3 > v20) {
        unint64_t v20 = v21 >> 3;
      }
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v22 = v20;
      }
      if (v22)
      {
        long long v23 = (char *)sub_10006A794((uint64_t)(a1 + 2), v22);
        long long v18 = (double *)*a1;
        long long v11 = (double *)a1[1];
      }
      else
      {
        long long v23 = 0;
      }
      uint64_t v24 = &v23[16 * v19];
      *(double *)uint64_t v24 = v16;
      *((void *)v24 + 1) = v17;
      long long v25 = v24;
      if (v11 != v18)
      {
        do
        {
          *((_OWORD *)v25 - 1) = *((_OWORD *)v11 - 1);
          v25 -= 16;
          v11 -= 2;
        }
        while (v11 != v18);
        long long v18 = (double *)*a1;
      }
      long long v11 = (double *)(v24 + 16);
      *a1 = v25;
      a1[1] = v24 + 16;
      a1[2] = &v23[16 * v22];
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      *long long v11 = v14;
      *((void *)v11 + 1) = v15;
      v11 += 2;
    }
    a1[1] = (char *)v11;
    ++v12;
  }
  while (v12 != v9);
  unint64_t v26 = *v13;
  double v27 = sub_10123254C(*a2, a2[1], a2[2], 0.0);
  double v29 = v27;
  uint64_t v30 = v28;
  if ((unint64_t)v11 >= v26)
  {
    long long v32 = (double *)*a1;
    uint64_t v33 = ((char *)v11 - *a1) >> 4;
    unint64_t v34 = v33 + 1;
    if ((unint64_t)(v33 + 1) >> 60) {
      sub_100408264();
    }
    if ((uint64_t)(v26 - (void)v32) >> 3 > v34) {
      unint64_t v34 = (uint64_t)(v26 - (void)v32) >> 3;
    }
    if (v26 - (unint64_t)v32 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v35 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v35 = v34;
    }
    if (v35)
    {
      uint64_t v36 = (char *)sub_10006A794((uint64_t)(a1 + 2), v35);
      long long v32 = (double *)*a1;
      long long v11 = (double *)a1[1];
    }
    else
    {
      uint64_t v36 = 0;
    }
    uint64_t v37 = &v36[16 * v33];
    CFDictionaryRef v38 = &v36[16 * v35];
    *(double *)uint64_t v37 = v29;
    *((void *)v37 + 1) = v30;
    long long v31 = v37 + 16;
    if (v11 != v32)
    {
      do
      {
        *((_OWORD *)v37 - 1) = *((_OWORD *)v11 - 1);
        v37 -= 16;
        v11 -= 2;
      }
      while (v11 != v32);
      long long v32 = (double *)*a1;
    }
    *a1 = v37;
    a1[1] = v31;
    a1[2] = v38;
    if (v32) {
      operator delete(v32);
    }
  }
  else
  {
    *long long v11 = v27;
    *((void *)v11 + 1) = v28;
    long long v31 = (char *)(v11 + 2);
  }
  a1[1] = v31;

  operator delete(v7);
}

void sub_101230B24(_Unwind_Exception *a1)
{
  xpc_object_t v4 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v4;
    operator delete(v4);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101230B50(uint64_t *a1, uint64_t *a2, uint64_t a3, const void **a4)
{
  if (*(char *)(a3 + 23) < 0)
  {
    **(unsigned char **)a3 = 0;
    *(void *)(a3 + 8) = 0;
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 23) = 0;
  }
  uint64_t v80 = 0;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  *(_OWORD *)int v68 = 0u;
  long long v69 = 0u;
  memset(v67, 0, sizeof(v67));
  long long v66 = 0u;
  sub_10004BD84((uint64_t)&v66);
  *(void *)((char *)v67 + *(void *)(v66 - 24)) = 2;
  *(_DWORD *)((char *)v67 + *(void *)(*(void *)&v67[0] - 24) + 8) = *(_DWORD *)((unsigned char *)v67
                                                                                    + *(void *)(*(void *)&v67[0]
                                                                                                - 24)
                                                                                    + 8) & 0xFFFFFEFB | 4;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v93 = 0;
  sub_10122FCA0((uint64_t *)__p, a1);
  __int16 v84 = 0;
  uint64_t v85 = 0;
  uint64_t v86 = 0;
  sub_10122FCA0((uint64_t *)&v84, a2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 3);
  if (v8 == 0xAAAAAAAAAAAAAAABLL * ((v85 - (uint64_t)v84) >> 3))
  {
    if (__p[1] == __p[0])
    {
LABEL_14:
      int v115 = (int64x2_t *)&v84;
      sub_10011FF94((void ***)&v115);
      __int16 v84 = __p;
      sub_10011FF94(&v84);
      sub_10003ECB8((std::string *)a3, "(SC=1.0) [Regions exactly same !]", 0x21uLL);
      uint64_t v21 = 0x3FF0000000000000;
      goto LABEL_88;
    }
    uint64_t v9 = 0;
    unsigned int v10 = 0;
    while (1)
    {
      uint64_t v11 = 3 * v9;
      double v14 = (uint64_t *)((char *)__p[0] + 24 * v9);
      uint64_t v12 = *v14;
      uint64_t v13 = v14[1];
      unint64_t v15 = (v13 - *v14) >> 4;
      uint64_t v17 = &v84[v11];
      double v16 = (double *)*v17;
      if (v15 != ((unsigned char *)v17[1] - (unsigned char *)*v17) >> 4) {
        break;
      }
      if (v13 != v12)
      {
        uint64_t v18 = 0;
        unsigned int v19 = 1;
        while (vabdd_f64(*(double *)(v12 + 16 * v18 + 8), v16[2 * v18 + 1]) <= 0.0001
             && vabdd_f64(*(double *)(v12 + 16 * v18), v16[2 * v18]) <= 0.0001)
        {
          uint64_t v18 = v19;
          if (v15 <= v19++) {
            goto LABEL_13;
          }
        }
        break;
      }
LABEL_13:
      uint64_t v9 = ++v10;
      if (v8 <= v10) {
        goto LABEL_14;
      }
    }
  }
  int v115 = (int64x2_t *)&v84;
  sub_10011FF94((void ***)&v115);
  __int16 v84 = __p;
  sub_10011FF94(&v84);
  memset(v65, 0, sizeof(v65));
  sub_100058198(&v64, a4);
  sub_10122FD6C(v65, &v64);
  sub_100057D78(&v64);
  uint64_t v106 = 0;
  v105 = 0;
  uint64_t v107 = 0;
  sub_100DC23DC(&v105, *a1, a1[1], 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3));
  long long v23 = (double *)a1[3];
  unint64_t v22 = (double *)a1[4];
  while (v23 != v22)
  {
    sub_101230888((char **)__p, v23, 0x48u);
    sub_100575E60((uint64_t *)&v105, (uint64_t)__p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v23 += 3;
  }
  v103 = 0;
  v102 = 0;
  uint64_t v104 = 0;
  sub_100DC23DC(&v102, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  long long v25 = (double *)a2[3];
  uint64_t v24 = (double *)a2[4];
  while (v25 != v24)
  {
    sub_101230888((char **)__p, v25, 0x48u);
    sub_100575E60((uint64_t *)&v102, (uint64_t)__p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v25 += 3;
  }
  std::string::size_type v99 = 0;
  std::string v100 = 0;
  uint64_t v101 = 0;
  sub_101232ED0(&v99, v105, v106);
  char v96 = 0;
  uint64_t v97 = 0;
  uint64_t v98 = 0;
  sub_101232ED0(&v96, v102, v103);
  uint8x8_t v123 = 0;
  v124 = 0;
  uint64_t v125 = 0;
  sub_1004081A4(&v123, v99, (uint64_t)v100, (v100 - (unsigned char *)v99) >> 4);
  v89 = 0;
  v90 = 0;
  uint64_t v91 = 0;
  __int16 v84 = (void **)&v89;
  uint64_t v85 = 0;
  v89 = operator new(0x18uLL);
  v90 = v89;
  uint64_t v91 = v89 + 3;
  v90 = sub_100DC2A10((uint64_t)&v91, (uint64_t)&v123, (uint64_t)&v126, v89);
  __int16 v84 = 0;
  uint64_t v85 = 0;
  uint64_t v86 = 0;
  sub_10122FBA0((uint64_t)__p, (uint64_t *)&v89, (long long **)&v84);
  BOOL v120 = 0;
  int8x8_t v121 = 0;
  uint64_t v122 = 0;
  sub_1004081A4(&v120, v96, (uint64_t)v97, (v97 - (unsigned char *)v96) >> 4);
  uint64_t v81 = 0;
  uint64_t v82 = 0;
  uint64_t v83 = 0;
  int v115 = (int64x2_t *)&v81;
  int v116 = 0;
  uint64_t v81 = operator new(0x18uLL);
  uint64_t v82 = v81;
  uint64_t v83 = v81 + 3;
  uint64_t v82 = sub_100DC2A10((uint64_t)&v83, (uint64_t)&v120, (uint64_t)&v123, v81);
  int v115 = 0;
  int v116 = 0;
  uint64_t v117 = 0;
  sub_10122FBA0((uint64_t)&v84, (uint64_t *)&v81, (long long **)&v115);
  int64x2_t v113 = 0uLL;
  uint64_t v114 = 0;
  sub_101232148(&v113, (uint64_t *)__p);
  int64x2_t v111 = 0uLL;
  uint64_t v112 = 0;
  sub_101232148(&v111, (uint64_t *)&v84);
  uint64_t v109 = 0;
  uint64_t v108 = 0;
  int v110 = 0;
  if (v113.i64[1] == v113.i64[0])
  {
    double v55 = 0.0;
  }
  else
  {
    uint64_t v26 = 0;
    if ((unint64_t)((v113.i64[1] - v113.i64[0]) / 48) <= 1) {
      uint64_t v27 = 1;
    }
    else {
      uint64_t v27 = (v113.i64[1] - v113.i64[0]) / 48;
    }
    do
    {
      uint64_t v28 = (uint64_t *)(v113.i64[0] + 48 * v26);
      int v115 = (int64x2_t *)&v115;
      int v116 = (long long **)&v115;
      uint64_t v117 = 0;
      double v29 = (uint64_t *)(v111.i64[0] + 48 * v26);
      *(_WORD *)BOOL v119 = 0;
      sub_10123798C(v28, v29, v119, (uint64_t *)&v115, &v118, (uint64_t)&v119[1]);
      *(void *)&v119[1] = 0x3FF0000000000000;
      double v30 = sub_1012326D8(v28, (double *)&v119[1]);
      *(void *)&v119[1] = 0x3FF0000000000000;
      double v31 = sub_1012326D8(v29, (double *)&v119[1]);
      double v32 = fabs(v30 * 40680631.6);
      double v33 = fabs(v31 * 40680631.6);
      if (v32 >= v33) {
        double v34 = v32;
      }
      else {
        double v34 = v33;
      }
      unint64_t v35 = v116;
      double v36 = 0.0;
      while (v35 != (long long **)&v115)
      {
        *(void *)&v119[1] = 0x3FF0000000000000;
        double v36 = v36 + fabs(sub_1012326D8((uint64_t *)v35 + 2, (double *)&v119[1]) * 40680631.6);
        unint64_t v35 = (long long **)v35[1];
      }
      double v37 = 1.0;
      if (fabs(v36 + -0.0001) > 0.0001) {
        double v37 = 1.0 - v36 / v34;
      }
      sub_10125ACB4((uint64_t *)&v115);
      CFDictionaryRef v38 = v109;
      if (v109 >= v110)
      {
        unsigned __int8 v40 = (double *)v108;
        uint64_t v41 = ((char *)v109 - (unsigned char *)v108) >> 3;
        unint64_t v42 = v41 + 1;
        if ((unint64_t)(v41 + 1) >> 61) {
          sub_1004D66E0();
        }
        uint64_t v43 = (char *)v110 - (unsigned char *)v108;
        if (((char *)v110 - (unsigned char *)v108) >> 2 > v42) {
          unint64_t v42 = v43 >> 2;
        }
        if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v44 = v42;
        }
        if (v44)
        {
          BOOL v45 = (char *)sub_10004EF74((uint64_t)&v110, v44);
          CFDictionaryRef v38 = v109;
          unsigned __int8 v40 = (double *)v108;
        }
        else
        {
          BOOL v45 = 0;
        }
        uint64_t v46 = (double *)&v45[8 * v41];
        double *v46 = v37;
        CFTypeID v39 = v46 + 1;
        while (v38 != v40)
        {
          uint64_t v47 = *((void *)v38-- - 1);
          *((void *)v46-- - 1) = v47;
        }
        uint64_t v108 = v46;
        uint64_t v109 = v39;
        int v110 = (double *)&v45[8 * v44];
        if (v40) {
          operator delete(v40);
        }
      }
      else
      {
        *uint64_t v109 = v37;
        CFTypeID v39 = v38 + 1;
      }
      uint64_t v109 = v39;
      ++v26;
    }
    while (v26 != v27);
    CFDictionaryRef v48 = (double *)((char *)v108 + 8);
    BOOL v49 = v108 == v39 || v48 == v39;
    CFTypeID v50 = (double *)v108;
    if (!v49)
    {
      double v51 = *(double *)v108;
      CFTypeID v50 = (double *)v108;
      CFTypeID v52 = (double *)((char *)v108 + 8);
      do
      {
        double v53 = *v52++;
        double v54 = v53;
        if (v51 < v53)
        {
          double v51 = v54;
          CFTypeID v50 = v48;
        }
        CFDictionaryRef v48 = v52;
      }
      while (v52 != v39);
    }
    double v55 = *v50;
    if (v108)
    {
      uint64_t v109 = (double *)v108;
      operator delete(v108);
    }
  }
  int v115 = &v111;
  sub_101237908((void ***)&v115);
  int v115 = &v113;
  sub_101237908((void ***)&v115);
  if (v87)
  {
    unint64_t v88 = v87;
    operator delete(v87);
  }
  int v115 = (int64x2_t *)&v84;
  sub_10011FF94((void ***)&v115);
  int v115 = (int64x2_t *)&v81;
  sub_10011FF94((void ***)&v115);
  if (v120)
  {
    int8x8_t v121 = v120;
    operator delete(v120);
  }
  if (v94)
  {
    __int16 v95 = v94;
    operator delete(v94);
  }
  __int16 v84 = __p;
  sub_10011FF94(&v84);
  __int16 v84 = (void **)&v89;
  sub_10011FF94(&v84);
  if (v123)
  {
    v124 = v123;
    operator delete(v123);
  }
  if (v96)
  {
    uint64_t v97 = v96;
    operator delete(v96);
  }
  if (v99)
  {
    std::string v100 = v99;
    operator delete(v99);
  }
  __p[0] = &v102;
  sub_10011FF94((void ***)__p);
  __p[0] = &v105;
  sub_10011FF94((void ***)__p);
  sub_10004B96C(v67, (uint64_t)"(isSimilar: ", 12);
  double v56 = 1.0 - v55;
  uint64_t v57 = (void *)std::ostream::operator<<();
  sub_10004B96C(v57, (uint64_t)" SC = ", 6);
  uint64_t v58 = (void *)std::ostream::operator<<();
  uint64_t v59 = sub_10004B96C(v58, (uint64_t)") ", 2);
  sub_10122FFD0(__p);
  if (v93 >= 0) {
    uint64_t v60 = __p;
  }
  else {
    uint64_t v60 = (void **)__p[0];
  }
  if (v93 >= 0) {
    uint64_t v61 = HIBYTE(v93);
  }
  else {
    uint64_t v61 = (uint64_t)__p[1];
  }
  sub_10004B96C(v59, (uint64_t)v60, v61);
  if (SHIBYTE(v93) < 0) {
    operator delete(__p[0]);
  }
  sub_10004BC98((uint64_t)v67 + 8, __p);
  if (*(char *)(a3 + 23) < 0) {
    operator delete(*(void **)a3);
  }
  *(_OWORD *)a3 = *(_OWORD *)__p;
  *(void *)(a3 + 16) = v93;
  uint64_t v21 = *(void *)&v56;
LABEL_88:
  *(void *)((char *)&v67[-1]
  *(void *)&v67[0] = v62;
  if (SHIBYTE(v69) < 0) {
    operator delete(v68[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  return v21;
}

void sub_101231570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_10008248C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_101231748(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  JUMPOUT(0x101231720);
}

void sub_101231760(uint64_t *a1@<X0>, double **a2@<X1>, const void **a3@<X2>, uint64_t a4@<X8>, double a5@<D0>, double a6@<D1>)
{
  uint64_t v66 = 0;
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  sub_100DC23DC(&v66, *a1, a1[1], 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3));
  uint64_t v11 = *a2;
  unsigned int v10 = a2[1];
  while (v11 != v10)
  {
    sub_101230888((char **)&__p, v11, 0x14u);
    sub_100575E60(&v66, (uint64_t)&__p);
    if ((void)__p)
    {
      *((void *)&__p + 1) = __p;
      operator delete((void *)__p);
    }
    v11 += 3;
  }
  int v63 = 0;
  v64 = 0;
  unint64_t v65 = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  unint64_t v62 = 0;
  uint64_t v12 = v66;
  uint64_t v54 = v67;
  if (v66 == v67) {
    goto LABEL_81;
  }
  double v52 = a6;
  double v53 = a5;
  do
  {
    double v59 = 0.0;
    *(_OWORD *)uint64_t v57 = 0u;
    long long v58 = 0u;
    sub_100058198(&cf, a3);
    uint64_t v82 = 0;
    uint64_t v83 = 0;
    uint64_t v84 = 0;
    sub_1004081A4(&v82, *(const void **)v12, *(void *)(v12 + 8), (uint64_t)(*(void *)(v12 + 8) - *(void *)v12) >> 4);
    double v69 = 0.0;
    double v70 = 0.0;
    long long v71 = 0;
    *(void *)&long long __p = &v69;
    *((void *)&__p + 1) = 0;
    double v69 = COERCE_DOUBLE(operator new(0x18uLL));
    double v70 = v69;
    long long v71 = (void *)(*(void *)&v69 + 24);
    double v70 = COERCE_DOUBLE(sub_100DC2A10((uint64_t)&v71, (uint64_t)&v82, (uint64_t)&v85, *(void **)&v69));
    long long __p = 0uLL;
    *(void *)&long long v79 = 0;
    sub_10122FBA0((uint64_t)&v72, (uint64_t *)&v69, (long long **)&__p);
    long long v76 = 0uLL;
    v77[0] = 0.0;
    sub_100DC23DC(&v76, v72, *((uint64_t *)&v72 + 1), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v72 + 1) - v72) >> 3));
    uint64_t v85 = 0;
    uint64_t v86 = 0;
    uint64_t v87 = 0;
    sub_10123260C((char *)&v85, (long long *)v74, v75, 0xAAAAAAAAAAAAAAABLL * (((char *)v75 - (unsigned char *)v74) >> 3));
    double v14 = (uint64_t **)*((void *)&v76 + 1);
    uint64_t v13 = (uint64_t **)v76;
    double v15 = 0.0;
    if (*((void *)&v76 + 1) != (void)v76)
    {
      do
      {
        long long v79 = 0u;
        long long v80 = 0u;
        long long __p = 0u;
        double v16 = *v13;
        uint64_t v17 = v13[1];
        if (*v13 != v17)
        {
          uint64_t v18 = 0;
          do
          {
            uint64_t v20 = *v16;
            uint64_t v19 = v16[1];
            if ((unint64_t)v18 >= (unint64_t)v79)
            {
              uint64_t v21 = (uint64_t)((uint64_t)v18 - __p) >> 4;
              if ((unint64_t)(v21 + 1) >> 60) {
                sub_10006A748();
              }
              unint64_t v22 = (uint64_t)(v79 - __p) >> 3;
              if (v22 <= v21 + 1) {
                unint64_t v22 = v21 + 1;
              }
              if ((void)v79 - (void)__p >= 0x7FFFFFFFFFFFFFF0uLL) {
                unint64_t v23 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v23 = v22;
              }
              if (v23) {
                unint64_t v23 = (unint64_t)sub_1009C886C(v23);
              }
              else {
                uint64_t v24 = 0;
              }
              long long v25 = (void *)(v23 + 16 * v21);
              *long long v25 = v19;
              v25[1] = v20;
              uint64_t v26 = (char *)*((void *)&__p + 1);
              uint64_t v27 = (char *)__p;
              uint64_t v28 = v25;
              if (*((void *)&__p + 1) != (void)__p)
              {
                do
                {
                  *((_OWORD *)v28 - 1) = *((_OWORD *)v26 - 1);
                  v28 -= 2;
                  v26 -= 16;
                }
                while (v26 != v27);
                uint64_t v26 = (char *)__p;
              }
              uint64_t v18 = v25 + 2;
              *(void *)&long long __p = v28;
              *((void *)&__p + 1) = v25 + 2;
              *(void *)&long long v79 = v23 + 16 * v24;
              if (v26) {
                operator delete(v26);
              }
            }
            else
            {
              *uint64_t v18 = v19;
              v18[1] = v20;
              v18 += 2;
            }
            *((void *)&__p + 1) = v18;
            v16 += 2;
          }
          while (v16 != v17);
        }
        uint64_t v81 = 0x3FF0000000000000;
        double v29 = sub_1012326D8((uint64_t *)&__p, (double *)&v81);
        uint64_t v81 = (uint64_t)&v79 + 8;
        sub_101232E40((void ***)&v81);
        if ((void)__p)
        {
          *((void *)&__p + 1) = __p;
          operator delete((void *)__p);
        }
        double v15 = v15 + v29;
        v13 += 3;
      }
      while (v13 != v14);
      double v15 = v15 * 40680631.6;
    }
    if (v86 != v85)
    {
      double v30 = v85;
      do
      {
        double v15 = v15 + v30[2] * v30[2] * 3.14159265;
        v30 += 3;
      }
      while (v30 != v86);
    }
    if (v85)
    {
      uint64_t v86 = v85;
      operator delete(v85);
    }
    *(void *)&long long __p = &v76;
    sub_10011FF94((void ***)&__p);
    if (v74)
    {
      long long v75 = (long long *)v74;
      operator delete(v74);
    }
    *(void *)&long long __p = &v72;
    sub_10011FF94((void ***)&__p);
    *(void *)&long long __p = &v69;
    sub_10011FF94((void ***)&__p);
    if (v82)
    {
      uint64_t v83 = v82;
      operator delete(v82);
    }
    uint64_t v85 = (double *)cf;
    if (cf)
    {
      CFRetain(cf);
      long long __p = 0uLL;
      *(void *)&long long v79 = 0;
      *(void *)&long long v72 = v85;
      if (v85) {
        CFRetain(v85);
      }
    }
    else
    {
      long long __p = 0uLL;
      *(void *)&long long v79 = 0;
      *(void *)&long long v72 = 0;
    }
    sub_10122FD6C((double *)&__p, (const void **)&v72);
    double v31 = fabs(v15);
    sub_100057D78((const void **)&v72);
    double v32 = *((double *)&__p + 1);
    double v33 = v32 / (pow(2.71828183, *(double *)&v79 * (*((double *)&__p + 1) * 0.5 - sqrt(v31 / 3.14159265) * 0.5)) + 1.0);
    sub_100057D78((const void **)&v85);
    long long __p = 0uLL;
    *(void *)&long long v79 = 0;
    unint64_t v35 = *(long long **)v12;
    double v34 = *(long long **)(v12 + 8);
    if (*(long long **)v12 == v34)
    {
      double v37 = 0;
      double v36 = 0;
    }
    else
    {
      do
      {
        long long v76 = *v35;
        v77[0] = v33;
        sub_101230888((char **)&v72, (double *)&v76, 8u);
        sub_100575E60((uint64_t *)&__p, (uint64_t)&v72);
        if ((void)v72)
        {
          *((void *)&v72 + 1) = v72;
          operator delete((void *)v72);
        }
        ++v35;
      }
      while (v35 != v34);
      double v37 = (uint64_t **)*((void *)&__p + 1);
      double v36 = (uint64_t **)__p;
    }
    sub_101232ED0(&v72, v36, v37);
    *(void *)&long long v76 = &__p;
    sub_10011FF94((void ***)&v76);
    *(_OWORD *)uint64_t v57 = v72;
    *(void *)&long long v58 = v73;
    *((double *)&v58 + 1) = v33;
    double v59 = v31;
    sub_100057D78(&cf);
    CFDictionaryRef v38 = v64;
    if ((unint64_t)v64 >= v65)
    {
      uint64_t v39 = sub_100578560((uint64_t *)&v63, (uint64_t)v57);
    }
    else
    {
      void *v64 = 0;
      v38[1] = 0;
      v38[2] = 0;
      sub_1004081A4(v38, v57[0], (uint64_t)v57[1], ((char *)v57[1] - (char *)v57[0]) >> 4);
      uint64_t v39 = (uint64_t)(v38 + 3);
    }
    v64 = (void *)v39;
    unsigned __int8 v40 = v61;
    if ((unint64_t)v61 >= v62)
    {
      unint64_t v42 = v60;
      uint64_t v43 = ((char *)v61 - (unsigned char *)v60) >> 3;
      unint64_t v44 = v43 + 1;
      if ((unint64_t)(v43 + 1) >> 61) {
        sub_1004D66E0();
      }
      uint64_t v45 = v62 - (void)v60;
      if ((uint64_t)(v62 - (void)v60) >> 2 > v44) {
        unint64_t v44 = v45 >> 2;
      }
      if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v46 = v44;
      }
      if (v46)
      {
        uint64_t v47 = (char *)sub_10004EF74((uint64_t)&v62, v46);
        unint64_t v42 = v60;
        unsigned __int8 v40 = v61;
      }
      else
      {
        uint64_t v47 = 0;
      }
      CFDictionaryRef v48 = &v47[8 * v43];
      *(void *)CFDictionaryRef v48 = *((void *)&v58 + 1);
      uint64_t v41 = v48 + 8;
      while (v40 != v42)
      {
        uint64_t v49 = *--v40;
        *((void *)v48 - 1) = v49;
        v48 -= 8;
      }
      uint64_t v60 = v48;
      uint64_t v61 = v41;
      unint64_t v62 = (unint64_t)&v47[8 * v46];
      if (v42) {
        operator delete(v42);
      }
    }
    else
    {
      void *v61 = *((void *)&v58 + 1);
      uint64_t v41 = v40 + 1;
    }
    uint64_t v61 = v41;
    if (v57[0])
    {
      v57[1] = v57[0];
      operator delete(v57[0]);
    }
    v12 += 24;
  }
  while (v12 != v54);
  uint64_t v50 = (uint64_t)v63;
  double v51 = v64;
  double v69 = v52;
  double v70 = v53;
  if (v63 == v64)
  {
LABEL_81:
    *(unsigned char *)a4 = 0;
    *(void *)(a4 + 16) = 0;
    *(void *)(a4 + 24) = 0;
    *(void *)(a4 + 8) = 0;
    sub_10125AD28((void *)(a4 + 8), v60, (uint64_t)v61, ((char *)v61 - (unsigned char *)v60) >> 3);
  }
  else
  {
    while (1)
    {
      v57[0] = 0;
      v57[1] = 0;
      *(void *)&long long v58 = 0;
      uint64_t v85 = 0;
      uint64_t v86 = 0;
      uint64_t v87 = 0;
      sub_1004081A4(&v85, *(const void **)v50, *(void *)(v50 + 8), (uint64_t)(*(void *)(v50 + 8) - *(void *)v50) >> 4);
      long long v76 = 0uLL;
      v77[0] = 0.0;
      *(void *)&long long v72 = &v76;
      *((void *)&v72 + 1) = 0;
      *(void *)&long long v76 = operator new(0x18uLL);
      *((void *)&v76 + 1) = v76;
      *(void *)&v77[0] = v76 + 24;
      *((void *)&v76 + 1) = sub_100DC2A10((uint64_t)v77, (uint64_t)&v85, (uint64_t)v88, (void *)v76);
      long long v72 = 0uLL;
      uint64_t v73 = 0;
      sub_10122FBA0((uint64_t)&__p, (uint64_t *)&v76, (long long **)&v72);
      sub_101232148((int64x2_t *)v57, (uint64_t *)&__p);
      if (*((void *)&v79 + 1))
      {
        *(void *)&long long v80 = *((void *)&v79 + 1);
        operator delete(*((void **)&v79 + 1));
      }
      *(void *)&long long v72 = &__p;
      sub_10011FF94((void ***)&v72);
      *(void *)&long long v72 = &v76;
      sub_10011FF94((void ***)&v72);
      if (v85)
      {
        uint64_t v86 = v85;
        operator delete(v85);
      }
      if (v57[1] != v57[0] && (int)sub_10124A234(&v69, (uint64_t)v57[0]) >= 1) {
        break;
      }
      *(void *)&long long __p = v57;
      sub_101237908((void ***)&__p);
      v50 += 24;
      if ((void *)v50 == v51) {
        goto LABEL_81;
      }
    }
    *(unsigned char *)a4 = 1;
    *(void *)(a4 + 16) = 0;
    *(void *)(a4 + 24) = 0;
    *(void *)(a4 + 8) = 0;
    sub_10125AD28((void *)(a4 + 8), v60, (uint64_t)v61, ((char *)v61 - (unsigned char *)v60) >> 3);
    *(void *)&long long __p = v57;
    sub_101237908((void ***)&__p);
  }
  if (v60)
  {
    uint64_t v61 = v60;
    operator delete(v60);
  }
  *(void *)&long long __p = &v63;
  sub_10011FF94((void ***)&__p);
  *(void *)&long long __p = &v66;
  sub_10011FF94((void ***)&__p);
}

void sub_101231F58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, char *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char **a47,uint64_t a48)
{
  a47 = &a19;
  sub_101237908((void ***)&a47);
  if (__p)
  {
    a26 = (uint64_t)__p;
    operator delete(__p);
  }
  a19 = &a28;
  sub_10011FF94((void ***)&a19);
  a19 = &a31;
  sub_10011FF94((void ***)&a19);
  _Unwind_Resume(a1);
}

void sub_101232148(int64x2_t *a1, uint64_t *a2)
{
  a1->i64[0] = 0;
  a1->i64[1] = 0;
  a1[1].i64[0] = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  sub_100DC23DC(&v39, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  xpc_object_t v4 = (double *)a2[3];
  uint64_t v5 = (double *)a2[4];
  while (v4 != v5)
  {
    sub_101230888((char **)__p, v4, 0x48u);
    sub_100575E60(&v39, (uint64_t)__p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v4 += 3;
  }
  uint64_t v6 = v39;
  for (uint64_t i = v40; v6 != i; v6 += 24)
  {
    memset(v38, 0, sizeof(v38));
    *(_OWORD *)long long __p = 0u;
    unint64_t v8 = *(uint64_t **)v6;
    uint64_t v9 = *(uint64_t **)(v6 + 8);
    if (*(uint64_t **)v6 != v9)
    {
      unsigned int v10 = 0;
      do
      {
        uint64_t v11 = *v8;
        uint64_t v12 = v8[1];
        if ((unint64_t)v10 >= *(void *)&v38[0])
        {
          uint64_t v13 = (v10 - (char *)__p[0]) >> 4;
          if ((unint64_t)(v13 + 1) >> 60) {
            sub_10006A748();
          }
          unint64_t v14 = (uint64_t)(*(void *)&v38[0] - (unint64_t)__p[0]) >> 3;
          if (v14 <= v13 + 1) {
            unint64_t v14 = v13 + 1;
          }
          if (*(void *)&v38[0] - (unint64_t)__p[0] >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v15 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v15 = v14;
          }
          if (v15) {
            unint64_t v15 = (unint64_t)sub_1009C886C(v15);
          }
          else {
            uint64_t v16 = 0;
          }
          uint64_t v17 = (char *)(v15 + 16 * v13);
          *(void *)uint64_t v17 = v12;
          *((void *)v17 + 1) = v11;
          uint64_t v19 = (char *)__p[0];
          uint64_t v18 = (char *)__p[1];
          uint64_t v20 = v17;
          if (__p[1] != __p[0])
          {
            do
            {
              *((_OWORD *)v20 - 1) = *((_OWORD *)v18 - 1);
              v20 -= 16;
              v18 -= 16;
            }
            while (v18 != v19);
            uint64_t v18 = (char *)__p[0];
          }
          unsigned int v10 = v17 + 16;
          __p[0] = v20;
          __p[1] = v17 + 16;
          *(void *)&v38[0] = v15 + 16 * v16;
          if (v18) {
            operator delete(v18);
          }
        }
        else
        {
          *(void *)unsigned int v10 = v12;
          *((void *)v10 + 1) = v11;
          v10 += 16;
        }
        __p[1] = v10;
        v8 += 2;
      }
      while (v8 != v9);
    }
    unint64_t v22 = a1->u64[1];
    unint64_t v21 = a1[1].u64[0];
    if (v22 >= v21)
    {
      unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - a1->i64[0]) >> 4);
      unint64_t v25 = v24 + 1;
      if (v24 + 1 > 0x555555555555555) {
        sub_10006A748();
      }
      unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v21 - a1->i64[0]) >> 4);
      if (2 * v26 > v25) {
        unint64_t v25 = 2 * v26;
      }
      if (v26 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v27 = 0x555555555555555;
      }
      else {
        unint64_t v27 = v25;
      }
      uint64_t v45 = a1 + 1;
      if (v27)
      {
        if (v27 > 0x555555555555555) {
          sub_10006A7CC();
        }
        uint64_t v28 = (void **)operator new(48 * v27);
      }
      else
      {
        uint64_t v28 = 0;
      }
      unint64_t v42 = v28;
      v43.i64[0] = (uint64_t)&v28[6 * v24];
      v43.i64[1] = v43.i64[0];
      unint64_t v44 = &v28[6 * v27];
      sub_10125AA90(v43.i64[0], (uint64_t)__p);
      uint64_t v29 = v43.i64[0];
      uint64_t v23 = v43.i64[1] + 48;
      v43.i64[1] += 48;
      uint64_t v31 = a1->i64[0];
      unint64_t v30 = a1->u64[1];
      if (v30 == a1->i64[0])
      {
        int64x2_t v35 = vdupq_n_s64(v30);
      }
      else
      {
        uint64_t v32 = 0;
        do
        {
          uint64_t v33 = v29 + v32;
          uint64_t v34 = v30 + v32;
          *(void *)(v33 - 48) = 0;
          *(void *)(v33 - 40) = 0;
          *(void *)(v33 - 32) = 0;
          *(_OWORD *)(v33 - 48) = *(_OWORD *)(v30 + v32 - 48);
          *(void *)(v33 - 32) = *(void *)(v30 + v32 - 32);
          *(void *)(v34 - 48) = 0;
          *(void *)(v34 - 40) = 0;
          *(void *)(v34 - 32) = 0;
          *(void *)(v33 - 24) = 0;
          *(void *)(v33 - 16) = 0;
          *(void *)(v33 - 8) = 0;
          *(_OWORD *)(v33 - 24) = *(_OWORD *)(v30 + v32 - 24);
          *(void *)(v33 - 8) = *(void *)(v30 + v32 - 8);
          *(void *)(v34 - 24) = 0;
          *(void *)(v34 - 16) = 0;
          *(void *)(v34 - 8) = 0;
          v32 -= 48;
        }
        while (v30 + v32 != v31);
        int64x2_t v35 = *a1;
        uint64_t v23 = v43.i64[1];
        v29 += v32;
      }
      a1->i64[0] = v29;
      a1->i64[1] = v23;
      int64x2_t v43 = v35;
      double v36 = (void **)a1[1].i64[0];
      a1[1].i64[0] = (uint64_t)v44;
      unint64_t v44 = v36;
      unint64_t v42 = (void **)v35.i64[0];
      sub_101233FB0((uint64_t)&v42);
    }
    else
    {
      sub_10125AA90((void *)a1->i64[1], (uint64_t)__p);
      uint64_t v23 = v22 + 48;
      a1->i64[1] = v23;
    }
    a1->i64[1] = v23;
    unint64_t v42 = (void **)v38 + 1;
    sub_101232E40(&v42);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  __p[0] = &v39;
  sub_10011FF94((void ***)__p);
}

void sub_1012324CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, char a20)
{
}

long double sub_10123254C(double a1, double a2, double a3, double a4)
{
  double v4 = a4 * 0.0174532925;
  double v5 = a3 / 6378.137;
  __double2 v6 = __sincos_stret(a1 * 0.0174532925);
  __double2 v7 = __sincos_stret(v5);
  __double2 v8 = __sincos_stret(v4);
  long double v9 = asin(v6.__cosval * v7.__sinval * v8.__cosval + v6.__sinval * v7.__cosval);
  long double v10 = sin(v9);
  atan2(v6.__cosval * (v7.__sinval * v8.__sinval), v7.__cosval - v6.__sinval * v10);
  return v9 * 57.2957795;
}

char *sub_10123260C(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    __double2 v6 = result;
    uint64_t result = sub_100DC2464(result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      long long v8 = *a2;
      *(void *)(v7 + 16) = *((void *)a2 + 2);
      *(_OWORD *)uint64_t v7 = v8;
      v7 += 24;
      a2 = (long long *)((char *)a2 + 24);
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_101232670(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10123268C(uint64_t a1)
{
  double v4 = (void **)(a1 + 24);
  sub_101232E40(&v4);
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

double sub_1012326D8(uint64_t *a1, double *a2)
{
  uint64_t v4 = *a1;
  double v5 = (double *)a1[1];
  double v6 = 0.0;
  double v7 = 0.0;
  if ((unint64_t)v5 - *a1 >= 0x40)
  {
    double v8 = *a2;
    long double v9 = (double *)(v4 + 16);
    if ((double *)(v4 + 16) == v5)
    {
      double v11 = 0.0;
    }
    else
    {
      unint64_t v10 = 0;
      double v11 = 0.0;
      do
      {
        double v12 = *(v9 - 2);
        double v13 = *v9;
        if (v12 != *v9)
        {
          if ((*(void *)&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
            || (*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_9;
          }
          double v15 = vabdd_f64(v12, v13);
          double v16 = fabs(v12);
          double v17 = fabs(v13);
          if (v16 < v17) {
            double v16 = v17;
          }
          double v18 = v16 >= 1.0 ? v16 * 2.22044605e-16 : 2.22044605e-16;
          if (v15 > v18)
          {
LABEL_9:
            double v11 = v11 + sub_101232970(v9 - 2, v9);
            v10 += sub_101232BC4(v9 - 2, v9);
          }
        }
        v9 += 2;
      }
      while (v9 != v5);
      if (v10)
      {
        double v19 = (double)((v10 >> 1) + 1);
        double v20 = fabs(v11);
        double v21 = -v20;
        double v22 = -(v20 - v19 * 6.28318531);
        double v23 = -(v21 + v19 * 6.28318531);
        if (v11 <= 0.0) {
          double v11 = v22;
        }
        else {
          double v11 = v23;
        }
      }
    }
    double v7 = v8 * v8 * v11;
  }
  unint64_t v25 = (uint64_t *)a1[3];
  unint64_t v24 = (uint64_t *)a1[4];
  if (v25 != v24)
  {
    double v6 = 0.0;
    do
    {
      uint64_t v26 = *v25;
      unint64_t v27 = (double *)v25[1];
      double v28 = 0.0;
      if ((unint64_t)v27 - *v25 >= 0x40)
      {
        double v29 = *a2;
        unint64_t v30 = (double *)(v26 + 16);
        if ((double *)(v26 + 16) == v27)
        {
          double v32 = 0.0;
        }
        else
        {
          unint64_t v31 = 0;
          double v32 = 0.0;
          do
          {
            double v33 = *(v30 - 2);
            double v34 = *v30;
            if (v33 != *v30)
            {
              if ((*(void *)&v33 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                || (*(void *)&v34 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
              {
                goto LABEL_35;
              }
              double v36 = vabdd_f64(v33, v34);
              double v37 = fabs(v33);
              double v38 = fabs(v34);
              if (v37 < v38) {
                double v37 = v38;
              }
              double v39 = v37 >= 1.0 ? v37 * 2.22044605e-16 : 2.22044605e-16;
              if (v36 > v39)
              {
LABEL_35:
                double v32 = v32 + sub_101232970(v30 - 2, v30);
                v31 += sub_101232BC4(v30 - 2, v30);
              }
            }
            v30 += 2;
          }
          while (v30 != v27);
          if (v31)
          {
            uint64_t v40 = (v31 >> 1) + 1;
            double v41 = fabs(v32);
            double v42 = -v41;
            double v43 = -(v41 - (double)(unint64_t)v40 * 6.28318531);
            if (v32 <= 0.0) {
              double v32 = v43;
            }
            else {
              double v32 = -(v42 + (double)(unint64_t)v40 * 6.28318531);
            }
          }
        }
        double v28 = v29 * v29 * v32;
        unint64_t v24 = (uint64_t *)a1[4];
      }
      double v6 = v6 + v28;
      v25 += 3;
    }
    while (v25 != v24);
  }
  return v7 + v6;
}

long double sub_101232970(double *a1, double *a2)
{
  double v2 = a1[1];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    unint64_t v25 = a2;
    double v29 = a1;
    int v16 = __cxa_guard_acquire(&qword_101B13360);
    a2 = v25;
    a1 = v29;
    if (v16)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      a2 = v25;
      a1 = v29;
    }
  }
  double v3 = *(double *)&qword_101B13358;
  double v4 = a2[1];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    uint64_t v26 = a2;
    unint64_t v30 = a1;
    double v17 = v3;
    int v18 = __cxa_guard_acquire(&qword_101B13360);
    double v3 = v17;
    int v19 = v18;
    a2 = v26;
    a1 = v30;
    if (v19)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      double v3 = v17;
      a2 = v26;
      a1 = v30;
    }
  }
  double v5 = *(double *)&qword_101B13358;
  double v6 = *a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    unint64_t v31 = a1;
    double v27 = v3;
    double v20 = v6;
    int v21 = __cxa_guard_acquire(&qword_101B13360);
    double v6 = v20;
    double v3 = v27;
    int v22 = v21;
    a1 = v31;
    if (v22)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      double v6 = v20;
      double v3 = v27;
      a1 = v31;
    }
  }
  double v7 = *(double *)&qword_101B13358;
  double v8 = *a1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    double v24 = v6;
    double v28 = v3;
    double v32 = v7;
    int v23 = __cxa_guard_acquire(&qword_101B13360);
    double v3 = v28;
    double v7 = v32;
    double v6 = v24;
    if (v23)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      double v3 = v28;
      double v7 = v32;
      double v6 = v24;
    }
  }
  double v9 = v6 * v7;
  double v10 = tan(v2 * v3 * 0.5);
  long double v11 = tan(v4 * v5 * 0.5);
  long double v12 = (v10 + v11) / (v10 * v11 + 1.0);
  long double v13 = tan((v9 - v8 * *(double *)&qword_101B13358) * 0.5);
  long double v14 = atan(v12 * v13);
  return v14 + v14;
}

BOOL sub_101232BC4(double *a1, double *a2)
{
  double v2 = *a1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    int v23 = a1;
    double v29 = a2;
    double v27 = v2;
    int v14 = __cxa_guard_acquire(&qword_101B13360);
    double v2 = v27;
    a2 = v29;
    int v15 = v14;
    a1 = v23;
    if (v15)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      double v2 = v27;
      a1 = v23;
      a2 = v29;
    }
  }
  double v3 = *(double *)&qword_101B13358;
  double v4 = *a1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    unint64_t v30 = a2;
    double v28 = v2;
    double v20 = v3;
    double v24 = v4;
    int v16 = __cxa_guard_acquire(&qword_101B13360);
    double v3 = v20;
    double v4 = v24;
    double v2 = v28;
    a2 = v30;
    if (v16)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      double v3 = v20;
      double v4 = v24;
      double v2 = v28;
      a2 = v30;
    }
  }
  double v5 = v2 * v3;
  double v6 = floor(v4 * *(double *)&qword_101B13358 / 6.28318531);
  double v7 = *a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    unint64_t v31 = a2;
    double v19 = v7;
    double v21 = v5;
    double v25 = v6;
    int v17 = __cxa_guard_acquire(&qword_101B13360);
    double v5 = v21;
    double v6 = v25;
    double v7 = v19;
    a2 = v31;
    if (v17)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      double v5 = v21;
      double v6 = v25;
      double v7 = v19;
      a2 = v31;
    }
  }
  double v8 = v5 - v6 * 6.28318531;
  double v9 = v7 * *(double *)&qword_101B13358;
  double v10 = *a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    double v22 = v8;
    double v32 = v9;
    double v26 = v10;
    int v18 = __cxa_guard_acquire(&qword_101B13360);
    double v8 = v22;
    double v10 = v26;
    double v9 = v32;
    if (v18)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      double v8 = v22;
      double v10 = v26;
      double v9 = v32;
    }
  }
  BOOL result = 0;
  double v12 = v9 - floor(v10 * *(double *)&qword_101B13358 / 6.28318531) * 6.28318531;
  if (v8 >= v12) {
    double v13 = v8;
  }
  else {
    double v13 = v12;
  }
  if (v12 < v8) {
    double v8 = v12;
  }
  if (v13 > 3.14159265 && v8 < 3.14159265) {
    return v13 - v8 > 3.14159265;
  }
  return result;
}

void sub_101232E40(void ***a1)
{
  uint64_t v1 = *a1;
  double v2 = (char *)**a1;
  if (v2)
  {
    double v4 = (char *)v1[1];
    double v5 = **a1;
    if (v4 != v2)
    {
      double v6 = (char *)v1[1];
      do
      {
        double v8 = (void *)*((void *)v6 - 3);
        v6 -= 24;
        double v7 = v8;
        if (v8)
        {
          *((void *)v4 - 2) = v7;
          operator delete(v7);
        }
        double v4 = v6;
      }
      while (v6 != v2);
      double v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_101232ED0(void *a1, uint64_t **a2, uint64_t **a3)
{
  int64x2_t v161 = 0uLL;
  v162 = 0;
  if (a2 == a3)
  {
    long long v160 = 0u;
    memset(v159, 0, sizeof(v159));
LABEL_53:
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    goto LABEL_304;
  }
  double v4 = a2;
  v156 = a1;
  do
  {
    long long v164 = 0u;
    long long v165 = 0u;
    *(_OWORD *)long long __p = 0u;
    double v5 = *v4;
    double v6 = v4[1];
    if (*v4 != v6)
    {
      double v7 = 0;
      do
      {
        uint64_t v8 = *v5;
        uint64_t v9 = v5[1];
        if ((unint64_t)v7 >= (unint64_t)v164)
        {
          uint64_t v10 = (v7 - (char *)__p[0]) >> 4;
          if ((unint64_t)(v10 + 1) >> 60) {
            sub_10006A748();
          }
          unint64_t v11 = (uint64_t)(v164 - (unint64_t)__p[0]) >> 3;
          if (v11 <= v10 + 1) {
            unint64_t v11 = v10 + 1;
          }
          if ((unint64_t)v164 - (unint64_t)__p[0] >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v12 = v11;
          }
          if (v12) {
            unint64_t v12 = (unint64_t)sub_1009C886C(v12);
          }
          else {
            uint64_t v13 = 0;
          }
          int v14 = (char *)(v12 + 16 * v10);
          *(void *)int v14 = v9;
          *((void *)v14 + 1) = v8;
          int v16 = (char *)__p[0];
          int v15 = (char *)__p[1];
          int v17 = v14;
          if (__p[1] != __p[0])
          {
            do
            {
              *((_OWORD *)v17 - 1) = *((_OWORD *)v15 - 1);
              v17 -= 16;
              v15 -= 16;
            }
            while (v15 != v16);
            int v15 = (char *)__p[0];
          }
          double v7 = v14 + 16;
          __p[0] = v17;
          __p[1] = v14 + 16;
          *(void *)&long long v164 = v12 + 16 * v13;
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          *(void *)double v7 = v9;
          *((void *)v7 + 1) = v8;
          v7 += 16;
        }
        __p[1] = v7;
        v5 += 2;
      }
      while (v5 != v6);
    }
    uint64_t v18 = v161.i64[1];
    if (v161.i64[1] >= (unint64_t)v162)
    {
      unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((v161.i64[1] - v161.i64[0]) >> 4);
      unint64_t v21 = v20 + 1;
      if (v20 + 1 > 0x555555555555555) {
        sub_10006A748();
      }
      if (0x5555555555555556 * (((uint64_t)v162 - v161.i64[0]) >> 4) > v21) {
        unint64_t v21 = 0x5555555555555556 * (((uint64_t)v162 - v161.i64[0]) >> 4);
      }
      if (0xAAAAAAAAAAAAAAABLL * (((uint64_t)v162 - v161.i64[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v22 = 0x555555555555555;
      }
      else {
        unint64_t v22 = v21;
      }
      *(void *)&long long v160 = &v162;
      if (v22)
      {
        if (v22 > 0x555555555555555) {
          sub_10006A7CC();
        }
        int v23 = (char *)operator new(48 * v22);
      }
      else
      {
        int v23 = 0;
      }
      v159[0] = v23;
      v159[1] = &v23[48 * v20];
      v159[2] = v159[1];
      v159[3] = &v23[48 * v22];
      sub_101233D58((void *)v159[1], (uint64_t)__p);
      double v24 = (char *)v159[1];
      double v19 = (char *)v159[2] + 48;
      v159[2] = (char *)v159[2] + 48;
      int64x2_t v25 = v161;
      if (v161.i64[1] == v161.i64[0])
      {
        int64x2_t v29 = vdupq_n_s64(v161.u64[1]);
      }
      else
      {
        uint64_t v26 = 0;
        do
        {
          double v27 = &v24[v26];
          uint64_t v28 = v25.i64[1] + v26;
          *((void *)v27 - 6) = 0;
          *((void *)v27 - 5) = 0;
          *((void *)v27 - 4) = 0;
          *((_OWORD *)v27 - 3) = *(_OWORD *)(v25.i64[1] + v26 - 48);
          *((void *)v27 - 4) = *(void *)(v25.i64[1] + v26 - 32);
          *(void *)(v28 - 48) = 0;
          *(void *)(v28 - 40) = 0;
          *(void *)(v28 - 32) = 0;
          *((void *)v27 - 3) = 0;
          *((void *)v27 - 2) = 0;
          *((void *)v27 - 1) = 0;
          *(_OWORD *)(v27 - 24) = *(_OWORD *)(v25.i64[1] + v26 - 24);
          *((void *)v27 - 1) = *(void *)(v25.i64[1] + v26 - 8);
          *(void *)(v28 - 24) = 0;
          *(void *)(v28 - 16) = 0;
          *(void *)(v28 - 8) = 0;
          v26 -= 48;
        }
        while (v25.i64[1] + v26 != v25.i64[0]);
        int64x2_t v29 = v161;
        double v19 = (char *)v159[2];
        v24 += v26;
      }
      v161.i64[0] = (uint64_t)v24;
      v161.i64[1] = (uint64_t)v19;
      *(int64x2_t *)&v159[1] = v29;
      unint64_t v30 = v162;
      v162 = v159[3];
      v159[3] = v30;
      v159[0] = (void *)v29.i64[0];
      sub_101233FB0((uint64_t)v159);
    }
    else
    {
      sub_101233D58((void *)v161.i64[1], (uint64_t)__p);
      double v19 = (char *)(v18 + 48);
    }
    v161.i64[1] = (uint64_t)v19;
    v159[0] = (char *)&v164 + 8;
    sub_101232E40((void ***)v159);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v4 += 3;
  }
  while (v4 != a3);
  unint64_t v31 = (float64x2_t **)v161.i64[0];
  long long v160 = 0u;
  memset(v159, 0, sizeof(v159));
  a1 = v156;
  if (v161.i64[0] == v161.i64[1]) {
    goto LABEL_53;
  }
  double v32 = (void *)v161.i64[0];
  while (*v32 == v32[1])
  {
    for (uint64_t i = (void *)v32[3]; i != (void *)v32[4]; i += 3)
    {
      if (*i != i[1]) {
        goto LABEL_54;
      }
    }
    v32 += 6;
    if (v32 == (void *)v161.i64[1]) {
      goto LABEL_53;
    }
  }
LABEL_54:
  uint64_t v167 = 0;
  long long v165 = 0u;
  *(_OWORD *)long long v166 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v164 = 0u;
  int v34 = 1;
  double v35 = 0.0;
  double v36 = 0.0;
  double v37 = (double **)v161.i64[0];
  float64x2_t v168 = 0uLL;
  do
  {
    double v38 = *v37;
    double v39 = v37[1];
    if (*v37 == v39) {
      goto LABEL_157;
    }
    uint64_t v40 = v38 + 2;
    double v41 = *v37;
    while (v40 != v39)
    {
      double v42 = *v40;
      double v43 = *v38;
      if (*v40 == *v38) {
        goto LABEL_59;
      }
      if ((*(void *)&v42 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (*(void *)&v43 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_70;
      }
      double v53 = vabdd_f64(v42, v43);
      double v54 = fabs(v42);
      double v55 = fabs(v43);
      if (v54 < v55) {
        double v54 = v55;
      }
      double v56 = v54 >= 1.0 ? v54 * 2.22044605e-16 : 2.22044605e-16;
      if (v53 <= v56)
      {
LABEL_59:
        double v44 = v40[1];
        double v45 = v38[1];
        if (v44 != v45)
        {
          if ((*(void *)&v44 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
            || (*(void *)&v45 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            if (v44 >= v45) {
              goto LABEL_72;
            }
LABEL_71:
            double v38 = v40;
            goto LABEL_72;
          }
          double v61 = fabs(v44);
          double v62 = fabs(v45);
          if (v61 < v62) {
            double v61 = v62;
          }
          if (v61 >= 1.0) {
            double v63 = v61 * 2.22044605e-16;
          }
          else {
            double v63 = 2.22044605e-16;
          }
          if (v44 < v45 && vabdd_f64(v44, v45) > v63) {
            goto LABEL_71;
          }
        }
      }
      else
      {
LABEL_70:
        if (v42 < v43) {
          goto LABEL_71;
        }
      }
LABEL_72:
      double v48 = *v41;
      if (*v41 != v42)
      {
        if ((*(void *)&v48 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v42 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_84;
        }
        double v57 = vabdd_f64(v48, v42);
        double v58 = fabs(v48);
        double v59 = fabs(v42);
        if (v58 < v59) {
          double v58 = v59;
        }
        double v60 = v58 >= 1.0 ? v58 * 2.22044605e-16 : 2.22044605e-16;
        if (v57 > v60)
        {
LABEL_84:
          if (v48 >= v42) {
            goto LABEL_86;
          }
LABEL_85:
          double v41 = v40;
          goto LABEL_86;
        }
      }
      double v49 = v41[1];
      double v50 = v40[1];
      if (v49 == v50) {
        goto LABEL_86;
      }
      if ((*(void *)&v49 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
        && (*(void *)&v50 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v64 = fabs(v49);
        double v65 = fabs(v50);
        if (v64 < v65) {
          double v64 = v65;
        }
        if (v64 >= 1.0) {
          double v66 = v64 * 2.22044605e-16;
        }
        else {
          double v66 = 2.22044605e-16;
        }
        if (v49 < v50 && vabdd_f64(v49, v50) > v66) {
          goto LABEL_85;
        }
      }
      else if (v49 < v50)
      {
        goto LABEL_85;
      }
LABEL_86:
      v40 += 2;
    }
    double v67 = *v38;
    if (v34)
    {
      double v36 = v38[1];
      double v35 = *v38;
      goto LABEL_119;
    }
    if (v67 == v35) {
      goto LABEL_121;
    }
    if ((*(void *)&v67 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v35 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_132;
    }
    double v80 = vabdd_f64(v67, v35);
    double v81 = fabs(v67);
    double v82 = fabs(v35);
    if (v81 < v82) {
      double v81 = v82;
    }
    double v83 = v81 >= 1.0 ? v81 * 2.22044605e-16 : 2.22044605e-16;
    if (v80 <= v83)
    {
LABEL_121:
      double v68 = v38[1];
      if (v68 != v36)
      {
        if ((*(void *)&v68 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (*(void *)&v36 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          double v84 = fabs(v68);
          double v85 = fabs(v36);
          if (v84 < v85) {
            double v84 = v85;
          }
          if (v84 >= 1.0) {
            double v86 = v84 * 2.22044605e-16;
          }
          else {
            double v86 = 2.22044605e-16;
          }
          if (v68 < v36 && vabdd_f64(v68, v36) > v86)
          {
LABEL_134:
            double v35 = *v38;
            double v36 = v68;
          }
        }
        else if (v68 < v36)
        {
          goto LABEL_134;
        }
      }
    }
    else
    {
LABEL_132:
      if (v67 < v35)
      {
        double v68 = v38[1];
        goto LABEL_134;
      }
    }
    double v71 = v168.f64[0];
    double v72 = *v41;
    if (v168.f64[0] != *v41)
    {
      if ((*(void *)&v168.f64[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (*(void *)&v72 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_155;
      }
      double v76 = vabdd_f64(v168.f64[0], v72);
      double v77 = fabs(v168.f64[0]);
      double v78 = fabs(v72);
      if (v77 < v78) {
        double v77 = v78;
      }
      double v79 = v77 >= 1.0 ? v77 * 2.22044605e-16 : 2.22044605e-16;
      if (v76 > v79)
      {
LABEL_155:
        if (v71 >= v72)
        {
LABEL_156:
          int v34 = 0;
          goto LABEL_157;
        }
LABEL_119:
        int v34 = 0;
        float64x2_t v168 = *(float64x2_t *)v41;
        goto LABEL_157;
      }
    }
    double v71 = v168.f64[1];
    double v72 = v41[1];
    if (v168.f64[1] == v72) {
      goto LABEL_156;
    }
    if ((*(void *)&v168.f64[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v72 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_155;
    }
    int v34 = 0;
    double v73 = fabs(v168.f64[1]);
    double v74 = fabs(v72);
    if (v73 < v74) {
      double v73 = v74;
    }
    if (v73 >= 1.0) {
      double v75 = v73 * 2.22044605e-16;
    }
    else {
      double v75 = 2.22044605e-16;
    }
    if (v168.f64[1] < v72 && vabdd_f64(v168.f64[1], v72) > v75) {
      goto LABEL_119;
    }
LABEL_157:
    v37 += 6;
  }
  while (v37 != (double **)v161.i64[1]);
  uint64_t v87 = 0;
  unint64_t v88 = 0;
  unint64_t v89 = 0;
  v90 = 0;
  f64 = 0;
  unint64_t v92 = 0;
  v93.f64[0] = v168.f64[0];
  float64x2_t v158 = v168;
  uint64_t v157 = (float64x2_t **)v161.i64[1];
  do
  {
    for (uint64_t j = *v31; j != v31[1]; ++j)
    {
      double v169 = 1.0;
      v172.f64[0] = v35;
      v172.f64[1] = v36;
      float64x2_t v170 = *j;
      float64x2_t v171 = v158;
      sub_101234054(&v172, &v171, &v170, &v169);
      if (v93.f64[0] != 0.0
        && ((*(void *)&v93.f64[0] & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
         || fabs(v93.f64[0]) > v169 * 2.22044605e-16))
      {
        if (v93.f64[0] <= 0.0)
        {
          if ((unint64_t)f64 >= v92)
          {
            uint64_t v99 = ((char *)f64 - (char *)v90) >> 4;
            unint64_t v100 = v99 + 1;
            if ((unint64_t)(v99 + 1) >> 60) {
LABEL_309:
            }
              sub_10006A748();
            if ((uint64_t)(v92 - (void)v90) >> 3 > v100) {
              unint64_t v100 = (uint64_t)(v92 - (void)v90) >> 3;
            }
            if (v92 - (unint64_t)v90 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v101 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v101 = v100;
            }
            if (v101) {
              unint64_t v101 = (unint64_t)sub_1009C886C(v101);
            }
            else {
              uint64_t v102 = 0;
            }
            uint64_t v106 = (float64x2_t *)(v101 + 16 * v99);
            float64x2_t v93 = *j;
            *uint64_t v106 = *j;
            if (f64 == v90)
            {
              uint64_t v108 = (double *)(v101 + 16 * v99);
            }
            else
            {
              unint64_t v107 = v101 + 16 * v99;
              do
              {
                float64x2_t v93 = *(float64x2_t *)(f64 - 2);
                uint64_t v108 = (double *)(v107 - 16);
                *(float64x2_t *)(v107 - 16) = v93;
                f64 -= 2;
                v107 -= 16;
              }
              while (f64 != v90);
            }
            unint64_t v92 = v101 + 16 * v102;
            f64 = v106[1].f64;
            if (v90) {
              operator delete(v90);
            }
            v90 = v108;
          }
          else
          {
            float64x2_t v93 = *j;
            *(float64x2_t *)f64 = *j;
            f64 += 2;
          }
        }
        else if ((unint64_t)v88 >= v89)
        {
          uint64_t v95 = ((char *)v88 - (char *)v87) >> 4;
          unint64_t v96 = v95 + 1;
          if ((unint64_t)(v95 + 1) >> 60) {
            goto LABEL_309;
          }
          if ((uint64_t)(v89 - (void)v87) >> 3 > v96) {
            unint64_t v96 = (uint64_t)(v89 - (void)v87) >> 3;
          }
          if (v89 - (unint64_t)v87 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v97 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v97 = v96;
          }
          if (v97) {
            unint64_t v97 = (unint64_t)sub_1009C886C(v97);
          }
          else {
            uint64_t v98 = 0;
          }
          v103 = (float64x2_t *)(v97 + 16 * v95);
          float64x2_t v93 = *j;
          float64x2_t *v103 = *j;
          if (v88 == v87)
          {
            v105 = (double *)(v97 + 16 * v95);
          }
          else
          {
            unint64_t v104 = v97 + 16 * v95;
            do
            {
              float64x2_t v93 = *(float64x2_t *)(v88 - 2);
              v105 = (double *)(v104 - 16);
              *(float64x2_t *)(v104 - 16) = v93;
              v88 -= 2;
              v104 -= 16;
            }
            while (v88 != v87);
          }
          unint64_t v89 = v97 + 16 * v98;
          unint64_t v88 = v103[1].f64;
          if (v87) {
            operator delete(v87);
          }
          uint64_t v87 = v105;
        }
        else
        {
          float64x2_t v93 = *j;
          *(float64x2_t *)unint64_t v88 = *j;
          v88 += 2;
        }
      }
    }
    v31 += 6;
  }
  while (v31 != v157);
  unint64_t v109 = 126 - 2 * __clz(((char *)v88 - (char *)v87) >> 4);
  if (v88 == v87) {
    uint64_t v110 = 0;
  }
  else {
    uint64_t v110 = v109;
  }
  unint64_t v111 = 126 - 2 * __clz(((char *)f64 - (char *)v90) >> 4);
  if (f64 == v90) {
    uint64_t v112 = 0;
  }
  else {
    uint64_t v112 = v111;
  }
  double v113 = sub_1012347F4(v90, f64, v112, 1, v93.f64[0]);
  sub_1012347F4(v87, v88, v110, 1, v113);
  uint64_t v114 = (double *)__p[1];
  if (__p[1] < (void *)v164)
  {
    *(double *)__p[1] = v35;
    v114[1] = v36;
    int v115 = v114 + 2;
    int v116 = (char **)v156;
    goto LABEL_243;
  }
  uint64_t v117 = (double *)__p[0];
  int64_t v118 = ((char *)__p[1] - (char *)__p[0]) >> 4;
  unint64_t v119 = v118 + 1;
  int v116 = (char **)v156;
  if ((unint64_t)(v118 + 1) >> 60) {
    goto LABEL_313;
  }
  uint64_t v120 = v164 - (unint64_t)__p[0];
  if ((uint64_t)(v164 - (unint64_t)__p[0]) >> 3 > v119) {
    unint64_t v119 = v120 >> 3;
  }
  if ((unint64_t)v120 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v121 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v121 = v119;
  }
  if (v121) {
    unint64_t v121 = (unint64_t)sub_1009C886C(v121);
  }
  else {
    uint64_t v122 = 0;
  }
  uint8x8_t v123 = (double *)(v121 + 16 * v118);
  *uint8x8_t v123 = v35;
  v123[1] = v36;
  int v115 = v123 + 2;
  if (v114 != v117)
  {
    do
    {
      *((_OWORD *)v123 - 1) = *((_OWORD *)v114 - 1);
      v123 -= 2;
      v114 -= 2;
    }
    while (v114 != v117);
    uint64_t v114 = v117;
  }
  __p[0] = v123;
  *(void *)&long long v164 = v121 + 16 * v122;
  if (v114) {
    operator delete(v114);
  }
LABEL_243:
  __p[1] = v115;
  if (f64 != v90)
  {
    v124 = (float64x2_t *)v90;
    do
      sub_101237320(v124++, __p);
    while (v124 != (float64x2_t *)f64);
  }
  sub_101237320(&v168, __p);
  uint64_t v125 = (double *)v165;
  if ((unint64_t)v165 < *((void *)&v165 + 1))
  {
    *(double *)long long v165 = v35;
    v125[1] = v36;
    uint64_t v126 = v125 + 2;
    goto LABEL_262;
  }
  unint64_t v127 = (double *)*((void *)&v164 + 1);
  uint64_t v128 = (uint64_t)(v165 - *((void *)&v164 + 1)) >> 4;
  unint64_t v129 = v128 + 1;
  if ((unint64_t)(v128 + 1) >> 60) {
LABEL_313:
  }
    sub_10006A748();
  uint64_t v130 = *((void *)&v165 + 1) - *((void *)&v164 + 1);
  if ((uint64_t)(*((void *)&v165 + 1) - *((void *)&v164 + 1)) >> 3 > v129) {
    unint64_t v129 = v130 >> 3;
  }
  if ((unint64_t)v130 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v131 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v131 = v129;
  }
  if (v131) {
    unint64_t v131 = (unint64_t)sub_1009C886C(v131);
  }
  else {
    uint64_t v132 = 0;
  }
  unint64_t v133 = (double *)(v131 + 16 * v128);
  *unint64_t v133 = v35;
  v133[1] = v36;
  uint64_t v126 = v133 + 2;
  if (v125 != v127)
  {
    do
    {
      *((_OWORD *)v133 - 1) = *((_OWORD *)v125 - 1);
      v133 -= 2;
      v125 -= 2;
    }
    while (v125 != v127);
    uint64_t v125 = v127;
  }
  *((void *)&v164 + 1) = v133;
  *((void *)&v165 + 1) = v131 + 16 * v132;
  if (v125) {
    operator delete(v125);
  }
LABEL_262:
  *(void *)&long long v165 = v126;
  if (v88 != v87)
  {
    v134 = (float64x2_t *)v87;
    do
      sub_10123759C(v134++, (void **)&v164 + 1);
    while (v134 != (float64x2_t *)v88);
  }
  sub_10123759C(&v168, (void **)&v164 + 1);
  if (v87) {
    operator delete(v87);
  }
  if (v90) {
    operator delete(v90);
  }
  os_log_t v136 = (_OWORD *)*((void *)&v164 + 1);
  uint64_t v135 = (_OWORD *)v165;
  *(void *)&v172.f64[0] = v159;
  if (*((void *)&v164 + 1) != (void)v165)
  {
    v137 = (_OWORD *)*((void *)&v164 + 1);
    do
      sub_101237818((void ***)&v172, v137++);
    while (v137 != v135);
  }
  v138 = __p[0];
  v139 = __p[1];
  if (__p[0] == __p[1]) {
    __assert_rtn("output_ranges", "graham_andrew.hpp", 289, "closed ? !boost::empty(second) : boost::size(second) > 1");
  }
  *(void *)&v172.f64[0] = v159;
  if ((char *)__p[1] - 16 != __p[0])
  {
    BOOL v140 = (char *)__p[1] - 32;
    do
      sub_101237818((void ***)&v172, v140);
    while (v140-- != (_OWORD *)v138);
  }
  if ((unint64_t)(v135 - v136 + ((v139 - v138) >> 4) - 1) <= 3)
  {
    *(void *)&v172.f64[0] = v159;
    sub_101237818((void ***)&v172, v136);
  }
  if (v166[0]) {
    operator delete(v166[0]);
  }
  if (v136) {
    operator delete(v136);
  }
  if (v138) {
    operator delete(v138);
  }
  BOOL v142 = (uint64_t *)v159[0];
  v143 = (uint64_t *)v159[1];
  v116[1] = 0;
  v116[2] = 0;
  *int v116 = 0;
  if (v142 != v143)
  {
    uint64_t v144 = 0;
    v145 = v116 + 2;
    do
    {
      uint64_t v146 = *v142;
      uint64_t v147 = v142[1];
      if ((unint64_t)v144 >= *v145)
      {
        v148 = *v116;
        uint64_t v149 = (v144 - *v116) >> 4;
        unint64_t v150 = v149 + 1;
        if ((unint64_t)(v149 + 1) >> 60) {
          sub_100408264();
        }
        uint64_t v151 = *v145 - (void)v148;
        if (v151 >> 3 > v150) {
          unint64_t v150 = v151 >> 3;
        }
        if ((unint64_t)v151 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v152 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v152 = v150;
        }
        if (v152)
        {
          v153 = (char *)sub_10006A794((uint64_t)(v116 + 2), v152);
          v148 = *v116;
          uint64_t v144 = v116[1];
        }
        else
        {
          v153 = 0;
        }
        unint64_t v154 = &v153[16 * v149];
        *(void *)unint64_t v154 = v147;
        *((void *)v154 + 1) = v146;
        v155 = v154;
        if (v144 != v148)
        {
          do
          {
            *((_OWORD *)v155 - 1) = *((_OWORD *)v144 - 1);
            v155 -= 16;
            v144 -= 16;
          }
          while (v144 != v148);
          v148 = *v116;
        }
        uint64_t v144 = v154 + 16;
        *int v116 = v155;
        v116[1] = v154 + 16;
        v116[2] = &v153[16 * v152];
        if (v148) {
          operator delete(v148);
        }
      }
      else
      {
        *(void *)uint64_t v144 = v147;
        *((void *)v144 + 1) = v146;
        v144 += 16;
      }
      v116[1] = v144;
      v142 += 2;
    }
    while (v142 != v143);
  }
LABEL_304:
  __p[0] = &v159[3];
  sub_101232E40((void ***)__p);
  if (v159[0])
  {
    v159[1] = v159[0];
    operator delete(v159[0]);
  }
  __p[0] = &v161;
  sub_101237908((void ***)__p);
}

void sub_101233C9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char *a23)
{
  if (v24) {
    operator delete(v24);
  }
  if (v23) {
    operator delete(v23);
  }
  sub_101234000((uint64_t)&a23);
  sub_10123268C((uint64_t)&a13);
  a23 = &a19;
  sub_101237908((void ***)&a23);
  _Unwind_Resume(a1);
}

void *sub_101233D58(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_101233EB4(a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  uint64_t v4 = *(void *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 32);
  int64_t v6 = v5 - v4;
  if (v5 != v4)
  {
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 3);
    if (v7 >= 0xAAAAAAAAAAAAAABLL) {
      sub_10006A748();
    }
    uint64_t v8 = operator new(v6);
    a1[5] = &v8[3 * v7];
    a1[3] = v8;
    a1[4] = v8;
    uint64_t v13 = v8;
    int v14 = v8;
    v11[0] = a1 + 5;
    v11[1] = &v13;
    v11[2] = &v14;
    uint64_t v12 = 0;
    uint64_t v9 = v8;
    do
    {
      *uint64_t v9 = 0;
      v9[1] = 0;
      v9[2] = 0;
      sub_101233EB4(v9, *(const void **)v4, *(void *)(v4 + 8), (uint64_t)(*(void *)(v4 + 8) - *(void *)v4) >> 4);
      uint64_t v9 = v14 + 3;
      v14 += 3;
      v4 += 24;
    }
    while (v4 != v5);
    LOBYTE(v12) = 1;
    sub_10011FF2C((uint64_t)v11);
    a1[4] = v9;
  }
  return a1;
}

void sub_101233E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_101232E40(&a9);
  unint64_t v11 = *(void **)v9;
  if (*(void *)v9)
  {
    *(void *)(v9 + 8) = v11;
    operator delete(v11);
  }
  _Unwind_Resume(a1);
}

void *sub_101233EB4(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v4 = result;
    if (a4 >> 60) {
      sub_10006A748();
    }
    BOOL result = sub_1009C886C(a4);
    unint64_t v7 = result;
    *uint64_t v4 = result;
    v4[1] = result;
    v4[2] = &result[2 * v8];
    size_t v9 = a3 - (void)a2;
    if (v9) {
      BOOL result = memmove(result, a2, v9);
    }
    v4[1] = (char *)v7 + v9;
  }
  return result;
}

void sub_101233F30(_Unwind_Exception *exception_object)
{
  double v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_101233F4C(uint64_t a1)
{
  double v3 = (void **)(a1 + 24);
  sub_101232E40(&v3);
  double v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
}

uint64_t sub_101233FB0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 48;
    sub_101233F4C(i - 48);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_101234000(uint64_t a1)
{
  double v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
  }
  return a1;
}

float64x2_t *sub_101234054(float64x2_t *result, float64x2_t *a2, float64x2_t *a3, double *a4)
{
  float64x2_t v4 = vsubq_f64(*a2, *a3);
  _Q20 = vsubq_f64(*result, *a3);
  double v6 = fabs(_Q20.f64[0]);
  double v7 = fabs(v4.f64[1]);
  double v8 = _Q20.f64[1];
  double v9 = fabs(_Q20.f64[1]);
  double v10 = fabs(v4.f64[0]);
  if (v6 < v7) {
    double v6 = v7;
  }
  if (v6 < v9) {
    double v6 = v9;
  }
  if (v6 < v10) {
    double v6 = v10;
  }
  if (v6 < 1.0) {
    double v6 = 1.0;
  }
  *a4 = v6;
  double v11 = vmuld_lane_f64(_Q20.f64[0], v4, 1);
  double v12 = vmuld_lane_f64(v4.f64[0], _Q20, 1);
  double v13 = fabs(v11) + fabs(v12);
  if (vabdd_f64(v11, v12) < v13 * 3.33066907e-16 && (v11 <= 0.0 || v12 > 0.0) && (v11 >= 0.0 || v12 < 0.0))
  {
    uint64_t v14 = 0;
    double v15 = -(v11 - _Q20.f64[0] * v4.f64[1]);
    double v16 = -(v12 - _Q20.f64[1] * v4.f64[0]);
    double v17 = v15 - v16;
    double v18 = v15 - (v15 - v16) - v16 + v15 - (v15 - v16 + v15 - (v15 - v16));
    double v19 = v11 + v17;
    double v20 = v17 - (v11 + v17 - v11) + v11 - (v11 + v17 - (v11 + v17 - v11));
    v110[0] = v18;
    v110[1] = v20 - (v20 - v12) - v12 + v20 - (v20 - v12 + v20 - (v20 - v12));
    v110[2] = v20 - v12 - (v19 + v20 - v12 - v19) + v19 - (v19 + v20 - v12 - (v19 + v20 - v12 - v19));
    v110[3] = v19 + v20 - v12;
    double v21 = 0.0;
    do
      double v21 = v21 + v110[v14++];
    while (v14 != 4);
    double v22 = fabs(v21);
    if (v22 < v13 * 2.22044605e-16)
    {
      float64x2_t v23 = vsubq_f64(*result, _Q20);
      float64x2_t v24 = vsubq_f64(*a2, v4);
      _Q17 = vaddq_f64(vsubq_f64(v24, *a3), vsubq_f64(*a2, vaddq_f64(v4, v24)));
      float64x2_t v26 = vaddq_f64(vsubq_f64(v23, *a3), vsubq_f64(*result, vaddq_f64(_Q20, v23)));
      if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(v26), (int32x4_t)vceqzq_f64(_Q17))))))
      {
        double v27 = v22 * 3.33066907e-16 + v13 * 1.10933565e-31;
        double v28 = v4.f64[1] * v26.f64[0];
        __asm { FMLA            D6, D20, V17.D[1] }
        double v33 = vmuld_lane_f64(v4.f64[0], v26, 1);
        if (fabs(v21 + _D6 - vmlad_n_f64(v33, _Q20.f64[1], _Q17.f64[0])) < v27)
        {
          double v34 = _Q17.f64[1];
          double v35 = v26.f64[1];
          memset(v109, 0, sizeof(v109));
          double v36 = -(v28 - v26.f64[0] * v4.f64[1]);
          double v37 = -(v33 - v26.f64[1] * v4.f64[0]);
          double v38 = v36 - v37;
          double v39 = v36 - (v36 - v37) - v37 + v36 - (v36 - v37 + v36 - (v36 - v37));
          double v40 = v28 + v38;
          double v41 = v38 - (v28 + v38 - v28) + v28 - (v28 + v38 - (v28 + v38 - v28));
          *(double *)&long long v99 = v39;
          *((double *)&v99 + 1) = v41 - (v41 - v33) - v33 + v41 - (v41 - v33 + v41 - (v41 - v33));
          *(double *)&long long v100 = v41 - v33 - (v40 + v41 - v33 - v40) + v40 - (v40 + v41 - v33 - (v40 + v41 - v33 - v40));
          *((double *)&v100 + 1) = v40 + v41 - v33;
          double v96 = _Q20.f64[0];
          double v97 = _Q17.f64[0];
          double v98 = v26.f64[0];
          int v42 = sub_101234650(v110, (double *)&v99, (double *)v109);
          memset(v108, 0, sizeof(v108));
          double v43 = -(v96 * v34 - v96 * v34);
          double v44 = -(v8 * v97 - v8 * v97);
          double v45 = v43 - v44;
          double v46 = v43 - (v43 - v44) - v44 + v43 - (v43 - v44 + v43 - (v43 - v44));
          double v47 = v96 * v34 + v45;
          double v48 = v45 - (v47 - v96 * v34) + v96 * v34 - (v47 - (v47 - v96 * v34));
          double v49 = v48 - v8 * v97;
          *(double *)&long long v99 = v46;
          *((double *)&v99 + 1) = v48 - v49 - v8 * v97 + v48 - (v49 + v48 - v49);
          *(double *)&long long v100 = v49 - (v47 + v49 - v47) + v47 - (v47 + v49 - (v47 + v49 - v47));
          *((double *)&v100 + 1) = v47 + v49;
          double v50 = -(v98 * v34 - v98 * v34);
          double v51 = -(v35 * v97 - v35 * v97);
          double v52 = v50 - v51;
          double v53 = v50 - (v50 - v51) - v51 + v50 - (v50 - v51 + v50 - (v50 - v51));
          double v54 = v98 * v34 + v52;
          double v55 = v52 - (v54 - v98 * v34) + v98 * v34 - (v54 - (v54 - v98 * v34));
          double v56 = v55 - v35 * v97;
          v107[0] = v53;
          v107[1] = v55 - v56 - v35 * v97 + v55 - (v56 + v55 - v56);
          v107[2] = v56 - (v54 + v56 - v54) + v54 - (v54 + v56 - (v54 + v56 - v54));
          v107[3] = v54 + v56;
          BOOL result = (float64x2_t *)sub_101234650((double *)&v99, v107, (double *)v108);
          int v57 = 0;
          long long v105 = 0u;
          long long v106 = 0u;
          long long v103 = 0u;
          long long v104 = 0u;
          long long v101 = 0u;
          long long v102 = 0u;
          long long v99 = 0u;
          long long v100 = 0u;
          double v58 = *(double *)v108;
          double v59 = fabs(*(double *)v108);
          double v60 = fabs(*(double *)v109);
          int v61 = v59 <= v60;
          uint64_t v62 = v59 > v60;
          if (v59 > v60) {
            double v58 = *(double *)v109;
          }
          if (v42 <= (int)v62 || (int)result <= v61)
          {
            double v71 = v58;
          }
          else
          {
            double v63 = *(double *)((unint64_t)v108 | (8 * (v59 <= v60)));
            double v64 = fabs(v63);
            double v65 = *(double *)((unint64_t)v109 | (8 * v62));
            double v66 = fabs(v65);
            if (v59 > v60) {
              int v67 = 1;
            }
            else {
              int v67 = 2;
            }
            double v68 = v58 + v63;
            double v69 = v58 + v63 - v63;
            if (v59 <= v60) {
              int v70 = 1;
            }
            else {
              int v70 = 2;
            }
            double v71 = v58 + v65;
            double v72 = v58 + v65 - v65;
            if (v64 > v66)
            {
              LODWORD(v62) = v70;
            }
            else
            {
              double v71 = v68;
              double v72 = v69;
              int v61 = v67;
            }
            double v73 = v58 - v72;
            if (v73 == 0.0)
            {
              int v57 = 0;
            }
            else
            {
              *(double *)&long long v99 = v73;
              int v57 = 1;
            }
            if (v61 < (int)result && (int)v62 < v42)
            {
              do
              {
                double v83 = *((double *)v108 + v61);
                double v84 = *((double *)v109 + (int)v62);
                BOOL v85 = fabs(v83) <= fabs(v84);
                double v86 = v71 + v83;
                double v87 = v71 + v83 - v71;
                double v88 = v71 + v83 - v87;
                double v89 = v83 - v87;
                double v90 = v71 + v84;
                double v91 = v71 + v84 - v71;
                double v92 = v71 + v84 - v91;
                double v93 = v84 - v91;
                if (!v85)
                {
                  double v88 = v92;
                  double v89 = v93;
                }
                double v94 = v71 - v88;
                if (v85) {
                  double v71 = v86;
                }
                else {
                  double v71 = v90;
                }
                if (v85) {
                  ++v61;
                }
                else {
                  LODWORD(v62) = v62 + 1;
                }
                double v95 = v89 + v94;
                if (v95 != 0.0) {
                  *((double *)&v99 + v57++) = v95;
                }
              }
              while ((int)v62 < v42 && v61 < (int)result);
            }
          }
          if ((int)v62 < v42)
          {
            double v74 = (double *)v109 + (int)v62;
            uint64_t v75 = v42 - (uint64_t)(int)v62;
            do
            {
              double v76 = v71;
              double v71 = v71 + *v74;
              double v77 = *v74 - (v71 - v76) + v76 - (v71 - (v71 - v76));
              if (v77 != 0.0) {
                *((double *)&v99 + v57++) = v77;
              }
              ++v74;
              --v75;
            }
            while (v75);
          }
          if (v61 < (int)result)
          {
            double v78 = (double *)v108 + v61;
            uint64_t v79 = (int)result - (uint64_t)v61;
            do
            {
              double v80 = v71;
              double v71 = v71 + *v78;
              double v81 = *v78 - (v71 - v80) + v80 - (v71 - (v71 - v80));
              if (v81 != 0.0) {
                *((double *)&v99 + v57++) = v81;
              }
              ++v78;
              --v79;
            }
            while (v79);
          }
          if (v71 != 0.0 || v57 == 0) {
            *((double *)&v99 + v57) = v71;
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_101234650(double *a1, double *a2, double *a3)
{
  double v4 = fabs(*a2);
  double v5 = *a1;
  double v6 = fabs(*a1);
  LODWORD(v7) = v4 > v6;
  if (v4 <= v6) {
    double v5 = *a2;
  }
  double v8 = a2[v4 <= v6];
  double v9 = fabs(v8);
  double v10 = a1[v4 > v6];
  double v11 = fabs(v10);
  if (v4 > v6) {
    int v12 = 1;
  }
  else {
    int v12 = 2;
  }
  double v13 = v8 + v5;
  double v14 = v8 + v5 - v8;
  BOOL v15 = v4 <= v6;
  if (v4 <= v6) {
    int v16 = 1;
  }
  else {
    int v16 = 2;
  }
  double v17 = v10 + v5;
  double v18 = v10 + v5 - v10;
  if (v9 > v11)
  {
    int v19 = v15;
  }
  else
  {
    double v17 = v13;
    double v18 = v14;
    int v19 = v12;
  }
  if (v9 > v11) {
    LODWORD(v7) = v16;
  }
  double v20 = v5 - v18;
  if (v20 == 0.0)
  {
    uint64_t result = 0;
  }
  else
  {
    *a3 = v20;
    uint64_t result = 1;
  }
  do
  {
    double v22 = a2[v19];
    double v23 = fabs(v22);
    double v24 = a1[(int)v7];
    double v25 = fabs(v24);
    BOOL v26 = v23 == v25;
    BOOL v27 = v23 < v25;
    double v28 = v17 + v22;
    double v29 = v17 + v22 - v17;
    double v30 = v17 + v22 - v29;
    double v31 = v22 - v29;
    double v32 = v17 + v24;
    double v33 = v17 + v24 - v17;
    double v34 = v17 + v24 - v33;
    double v35 = v24 - v33;
    if (!v27 && !v26)
    {
      double v30 = v34;
      double v31 = v35;
    }
    double v36 = v17 - v30;
    if (v27 || v26) {
      double v17 = v28;
    }
    else {
      double v17 = v32;
    }
    if (v27 || v26) {
      ++v19;
    }
    else {
      LODWORD(v7) = v7 + 1;
    }
    double v37 = v31 + v36;
    if (v37 != 0.0)
    {
      a3[(int)result] = v37;
      uint64_t result = (result + 1);
    }
  }
  while ((int)v7 <= 3 && v19 < 4);
  if ((int)v7 <= 3)
  {
    uint64_t v7 = (int)v7;
    do
    {
      double v38 = v17;
      double v39 = a1[v7];
      double v17 = v17 + v39;
      double v40 = v39 - (v17 - v38) + v38 - (v17 - (v17 - v38));
      if (v40 != 0.0)
      {
        a3[(int)result] = v40;
        uint64_t result = (result + 1);
      }
      ++v7;
    }
    while (v7 != 4);
  }
  if (v19 <= 3)
  {
    uint64_t v41 = v19;
    do
    {
      double v42 = v17;
      double v43 = a2[v41];
      double v17 = v17 + v43;
      double v44 = v43 - (v17 - v42) + v42 - (v17 - (v17 - v42));
      if (v44 != 0.0)
      {
        a3[(int)result] = v44;
        uint64_t result = (result + 1);
      }
      ++v41;
    }
    while (v41 != 4);
  }
  if (v17 != 0.0 || result == 0)
  {
    a3[(int)result] = v17;
    return (result + 1);
  }
  return result;
}

double sub_1012347F4(double *a1, double *a2, uint64_t a3, char a4, double result)
{
double sub_101236220(double *a1, double *a2, double *a3)
{
  *(double *)&long long v3 = *a2;
  double v4 = *a1;
  if (*a2 == *a1) {
    goto LABEL_2;
  }
  if (((unint64_t)v3 & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL
    && (*(void *)&v4 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v16 = vabdd_f64(*(double *)&v3, v4);
    double v17 = fabs(*(double *)&v3);
    double v18 = fabs(v4);
    if (v17 < v18) {
      double v17 = v18;
    }
    double v19 = v17 >= 1.0 ? v17 * 2.22044605e-16 : 2.22044605e-16;
    if (v16 <= v19)
    {
LABEL_2:
      double v5 = a2[1];
      double v6 = a1[1];
      if (v5 != v6)
      {
        if ((*(void *)&v5 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          double v20 = fabs(v5);
          double v21 = fabs(v6);
          if (v20 < v21) {
            double v20 = v21;
          }
          if (v20 >= 1.0) {
            double v22 = v20 * 2.22044605e-16;
          }
          else {
            double v22 = 2.22044605e-16;
          }
          if (v5 < v6 && vabdd_f64(v5, v6) > v22) {
            goto LABEL_14;
          }
        }
        else if (v5 < v6)
        {
          goto LABEL_14;
        }
      }
LABEL_46:
      double v23 = *a3;
      if (*a3 == *(double *)&v3) {
        goto LABEL_47;
      }
      if ((*(void *)&v23 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || ((unint64_t)v3 & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_58;
      }
      double v35 = vabdd_f64(v23, *(double *)&v3);
      double v36 = fabs(v23);
      double v37 = fabs(*(double *)&v3);
      if (v36 < v37) {
        double v36 = v37;
      }
      double v38 = v36 >= 1.0 ? v36 * 2.22044605e-16 : 2.22044605e-16;
      if (v35 <= v38)
      {
LABEL_47:
        *(double *)&long long v3 = a3[1];
        double v24 = a2[1];
        if (*(double *)&v3 == v24) {
          return *(double *)&v3;
        }
        if (((unint64_t)v3 & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (*(void *)&v24 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          double v47 = fabs(*(double *)&v3);
          double v48 = fabs(v24);
          if (v47 < v48) {
            double v47 = v48;
          }
          if (v47 >= 1.0) {
            double v49 = v47 * 2.22044605e-16;
          }
          else {
            double v49 = 2.22044605e-16;
          }
          if (*(double *)&v3 >= v24) {
            return *(double *)&v3;
          }
          *(double *)&long long v3 = vabdd_f64(*(double *)&v3, v24);
          if (*(double *)&v3 <= v49) {
            return *(double *)&v3;
          }
        }
        else if (*(double *)&v3 >= v24)
        {
          return *(double *)&v3;
        }
      }
      else
      {
LABEL_58:
        if (v23 >= *(double *)&v3) {
          return *(double *)&v3;
        }
      }
      long long v3 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v3;
      *(double *)&long long v3 = *a2;
      double v27 = *a1;
      if (*a2 != *a1)
      {
        if (((unint64_t)v3 & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v27 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_79;
        }
        double v31 = vabdd_f64(*(double *)&v3, v27);
        double v32 = fabs(*(double *)&v3);
        double v33 = fabs(v27);
        if (v32 < v33) {
          double v32 = v33;
        }
        double v34 = v32 >= 1.0 ? v32 * 2.22044605e-16 : 2.22044605e-16;
        if (v31 > v34) {
          goto LABEL_79;
        }
      }
      *(double *)&long long v3 = a2[1];
      double v27 = a1[1];
      if (*(double *)&v3 == v27) {
        return *(double *)&v3;
      }
      if (((unint64_t)v3 & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL
        && (*(void *)&v27 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v28 = fabs(*(double *)&v3);
        double v29 = fabs(v27);
        if (v28 < v29) {
          double v28 = v29;
        }
        if (v28 >= 1.0) {
          double v30 = v28 * 2.22044605e-16;
        }
        else {
          double v30 = 2.22044605e-16;
        }
        if (*(double *)&v3 >= v27) {
          return *(double *)&v3;
        }
        *(double *)&long long v3 = vabdd_f64(*(double *)&v3, v27);
        if (*(double *)&v3 <= v30) {
          return *(double *)&v3;
        }
      }
      else
      {
LABEL_79:
        if (*(double *)&v3 >= v27) {
          return *(double *)&v3;
        }
      }
      long long v3 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)a2 = v3;
      return *(double *)&v3;
    }
  }
  if (*(double *)&v3 >= v4) {
    goto LABEL_46;
  }
LABEL_14:
  double v9 = *a3;
  if (*a3 == *(double *)&v3) {
    goto LABEL_15;
  }
  if ((*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || ((unint64_t)v3 & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    goto LABEL_30;
  }
  double v50 = vabdd_f64(v9, *(double *)&v3);
  double v51 = fabs(v9);
  double v52 = fabs(*(double *)&v3);
  if (v51 < v52) {
    double v51 = v52;
  }
  double v53 = v51 >= 1.0 ? v51 * 2.22044605e-16 : 2.22044605e-16;
  if (v50 <= v53)
  {
LABEL_15:
    double v10 = a3[1];
    double v11 = a2[1];
    if (v10 != v11)
    {
      if ((*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (*(void *)&v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        if (v10 < v11) {
          goto LABEL_31;
        }
      }
      else
      {
        double v12 = fabs(v10);
        double v13 = fabs(v11);
        if (v12 < v13) {
          double v12 = v13;
        }
        if (v12 >= 1.0) {
          double v14 = v12 * 2.22044605e-16;
        }
        else {
          double v14 = 2.22044605e-16;
        }
        if (v10 < v11 && vabdd_f64(v10, v11) > v14) {
          goto LABEL_31;
        }
      }
    }
  }
  else
  {
LABEL_30:
    if (v9 < *(double *)&v3)
    {
LABEL_31:
      long long v3 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a3;
LABEL_111:
      *(_OWORD *)a3 = v3;
      return *(double *)&v3;
    }
  }
  long long v3 = *(_OWORD *)a1;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)a2 = v3;
  *(double *)&long long v3 = *a3;
  double v39 = *a2;
  if (*a3 != *a2)
  {
    if (((unint64_t)v3 & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v39 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_109;
    }
    double v43 = vabdd_f64(*(double *)&v3, v39);
    double v44 = fabs(*(double *)&v3);
    double v45 = fabs(v39);
    if (v44 < v45) {
      double v44 = v45;
    }
    double v46 = v44 >= 1.0 ? v44 * 2.22044605e-16 : 2.22044605e-16;
    if (v43 > v46) {
      goto LABEL_109;
    }
  }
  *(double *)&long long v3 = a3[1];
  double v39 = a2[1];
  if (*(double *)&v3 == v39) {
    return *(double *)&v3;
  }
  if (((unint64_t)v3 & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL
    && (*(void *)&v39 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v40 = fabs(*(double *)&v3);
    double v41 = fabs(v39);
    if (v40 < v41) {
      double v40 = v41;
    }
    if (v40 >= 1.0) {
      double v42 = v40 * 2.22044605e-16;
    }
    else {
      double v42 = 2.22044605e-16;
    }
    if (*(double *)&v3 < v39)
    {
      *(double *)&long long v3 = vabdd_f64(*(double *)&v3, v39);
      if (*(double *)&v3 > v42) {
        goto LABEL_110;
      }
    }
  }
  else
  {
LABEL_109:
    if (*(double *)&v3 < v39)
    {
LABEL_110:
      long long v3 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      goto LABEL_111;
    }
  }
  return *(double *)&v3;
}

BOOL sub_101236738(double *a1, double *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      double v6 = a2 - 2;
      double v7 = *(a2 - 2);
      double v8 = *a1;
      if (v7 != *a1)
      {
        if ((*(void *)&v7 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v8 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_91;
        }
        double v45 = vabdd_f64(v7, v8);
        double v46 = fabs(v7);
        double v47 = fabs(v8);
        if (v46 < v47) {
          double v46 = v47;
        }
        double v48 = v46 >= 1.0 ? v46 * 2.22044605e-16 : 2.22044605e-16;
        if (v45 > v48) {
          goto LABEL_91;
        }
      }
      double v7 = *(a2 - 1);
      double v8 = a1[1];
      if (v7 == v8) {
        return result;
      }
      if ((*(void *)&v7 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (*(void *)&v8 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
LABEL_91:
        if (v7 >= v8) {
          return result;
        }
        goto LABEL_92;
      }
      double v10 = fabs(v7);
      double v11 = fabs(v8);
      if (v10 < v11) {
        double v10 = v11;
      }
      if (v10 >= 1.0) {
        double v12 = v10 * 2.22044605e-16;
      }
      else {
        double v12 = 2.22044605e-16;
      }
      if (v7 < v8 && vabdd_f64(v7, v8) > v12)
      {
LABEL_92:
        long long v44 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)double v6 = v44;
      }
      return result;
    case 3:
      sub_101236220(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      sub_101236B98(a1, a1 + 2, a1 + 4, (unint64_t *)a2 - 2);
      return 1;
    case 5:
      sub_101236EDC(a1, a1 + 2, a1 + 4, (uint64_t)(a1 + 6), (unint64_t *)a2 - 2);
      return 1;
    default:
      double v13 = a1 + 4;
      sub_101236220(a1, a1 + 2, a1 + 4);
      double v14 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v15 = 0;
      int v16 = 0;
      break;
  }
LABEL_19:
  double v17 = *v14;
  double v18 = *v13;
  if (*v14 == *v13) {
    goto LABEL_20;
  }
  if ((*(void *)&v17 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (*(void *)&v18 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    goto LABEL_31;
  }
  double v36 = vabdd_f64(v17, v18);
  double v37 = fabs(v17);
  double v38 = fabs(v18);
  if (v37 < v38) {
    double v37 = v38;
  }
  double v39 = v37 >= 1.0 ? v37 * 2.22044605e-16 : 2.22044605e-16;
  if (v36 <= v39)
  {
LABEL_20:
    double v19 = v14[1];
    double v20 = v13[1];
    if (v19 == v20) {
      goto LABEL_80;
    }
    if ((*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
      && (*(void *)&v20 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      double v40 = fabs(v19);
      double v41 = fabs(v20);
      if (v40 < v41) {
        double v40 = v41;
      }
      if (v40 >= 1.0) {
        double v42 = v40 * 2.22044605e-16;
      }
      else {
        double v42 = 2.22044605e-16;
      }
      if (v19 >= v20 || vabdd_f64(v19, v20) <= v42) {
        goto LABEL_80;
      }
    }
    else if (v19 >= v20)
    {
      goto LABEL_80;
    }
  }
  else
  {
LABEL_31:
    if (v17 >= v18) {
      goto LABEL_80;
    }
    double v19 = v14[1];
  }
  *(_OWORD *)double v14 = *(_OWORD *)v13;
  double v23 = a1;
  if (v13 == a1) {
    goto LABEL_79;
  }
  double v24 = fabs(v17);
  double v25 = fabs(v19);
  uint64_t v26 = v15;
  while (1)
  {
    double v27 = *(double *)((char *)a1 + v26 + 16);
    if (v17 == v27) {
      goto LABEL_36;
    }
    if ((*(void *)&v17 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
      || (*(void *)&v27 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_59;
    }
    double v33 = vabdd_f64(v17, v27);
    double v34 = fabs(v27);
    if (v24 >= v34) {
      double v34 = v24;
    }
    double v35 = v34 >= 1.0 ? v34 * 2.22044605e-16 : 2.22044605e-16;
    if (v33 <= v35)
    {
LABEL_36:
      double v28 = *(double *)((char *)a1 + v26 + 24);
      if (v19 == v28)
      {
        double v23 = (double *)((char *)a1 + v26 + 32);
LABEL_79:
        *double v23 = v17;
        v23[1] = v19;
        if (++v16 == 8) {
          return v14 + 2 == a2;
        }
LABEL_80:
        double v13 = v14;
        v15 += 16;
        v14 += 2;
        if (v14 == a2) {
          return 1;
        }
        goto LABEL_19;
      }
      if ((*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
        || (*(void *)&v28 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        if (v19 >= v28) {
          goto LABEL_69;
        }
      }
      else
      {
        double v29 = vabdd_f64(v19, v28);
        double v30 = fabs(v28);
        if (v25 >= v30) {
          double v30 = v25;
        }
        if (v30 >= 1.0) {
          double v31 = v30 * 2.22044605e-16;
        }
        else {
          double v31 = 2.22044605e-16;
        }
        if (v29 <= v31 || v19 >= v28)
        {
LABEL_69:
          double v23 = v13;
          goto LABEL_79;
        }
      }
    }
    else
    {
LABEL_59:
      if (v17 >= v27) {
        goto LABEL_69;
      }
    }
    v13 -= 2;
    *(_OWORD *)((char *)a1 + v26 + 32) = *(_OWORD *)((char *)a1 + v26 + 16);
    v26 -= 16;
    if (v26 == -32)
    {
      double v23 = a1;
      goto LABEL_79;
    }
  }
}

__n128 sub_101236B98(double *a1, double *a2, double *a3, unint64_t *a4)
{
  sub_101236220(a1, a2, a3);
  result.n128_u64[0] = *a4;
  double v9 = *a3;
  if (*(double *)a4 != *a3)
  {
    if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_20;
    }
    double v27 = vabdd_f64(result.n128_f64[0], v9);
    double v28 = fabs(result.n128_f64[0]);
    double v29 = fabs(v9);
    if (v28 < v29) {
      double v28 = v29;
    }
    double v30 = v28 >= 1.0 ? v28 * 2.22044605e-16 : 2.22044605e-16;
    if (v27 > v30) {
      goto LABEL_20;
    }
  }
  result.n128_u64[0] = a4[1];
  double v9 = a3[1];
  if (result.n128_f64[0] == v9) {
    return result;
  }
  if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL
    || (*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
LABEL_20:
    if (result.n128_f64[0] >= v9) {
      return result;
    }
    goto LABEL_21;
  }
  double v11 = fabs(result.n128_f64[0]);
  double v12 = fabs(v9);
  if (v11 < v12) {
    double v11 = v12;
  }
  if (v11 >= 1.0) {
    double v13 = v11 * 2.22044605e-16;
  }
  else {
    double v13 = 2.22044605e-16;
  }
  if (result.n128_f64[0] < v9)
  {
    result.n128_f64[0] = vabdd_f64(result.n128_f64[0], v9);
    if (result.n128_f64[0] > v13)
    {
LABEL_21:
      __n128 result = *(__n128 *)a3;
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(__n128 *)a4 = result;
      result.n128_f64[0] = *a3;
      double v15 = *a2;
      if (*a3 != *a2)
      {
        if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v15 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_41;
        }
        double v19 = vabdd_f64(result.n128_f64[0], v15);
        double v20 = fabs(result.n128_f64[0]);
        double v21 = fabs(v15);
        if (v20 < v21) {
          double v20 = v21;
        }
        double v22 = v20 >= 1.0 ? v20 * 2.22044605e-16 : 2.22044605e-16;
        if (v19 > v22) {
          goto LABEL_41;
        }
      }
      result.n128_f64[0] = a3[1];
      double v15 = a2[1];
      if (result.n128_f64[0] == v15) {
        return result;
      }
      if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL
        && (*(void *)&v15 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v16 = fabs(result.n128_f64[0]);
        double v17 = fabs(v15);
        if (v16 < v17) {
          double v16 = v17;
        }
        if (v16 >= 1.0) {
          double v18 = v16 * 2.22044605e-16;
        }
        else {
          double v18 = 2.22044605e-16;
        }
        if (result.n128_f64[0] >= v15) {
          return result;
        }
        result.n128_f64[0] = vabdd_f64(result.n128_f64[0], v15);
        if (result.n128_f64[0] <= v18) {
          return result;
        }
      }
      else
      {
LABEL_41:
        if (result.n128_f64[0] >= v15) {
          return result;
        }
      }
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      result.n128_f64[0] = *a2;
      double v23 = *a1;
      if (*a2 != *a1)
      {
        if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v23 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_69;
        }
        double v31 = vabdd_f64(result.n128_f64[0], v23);
        double v32 = fabs(result.n128_f64[0]);
        double v33 = fabs(v23);
        if (v32 < v33) {
          double v32 = v33;
        }
        double v34 = v32 >= 1.0 ? v32 * 2.22044605e-16 : 2.22044605e-16;
        if (v31 > v34) {
          goto LABEL_69;
        }
      }
      result.n128_f64[0] = a2[1];
      double v23 = a1[1];
      if (result.n128_f64[0] == v23) {
        return result;
      }
      if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL
        && (*(void *)&v23 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v24 = fabs(result.n128_f64[0]);
        double v25 = fabs(v23);
        if (v24 < v25) {
          double v24 = v25;
        }
        if (v24 >= 1.0) {
          double v26 = v24 * 2.22044605e-16;
        }
        else {
          double v26 = 2.22044605e-16;
        }
        if (result.n128_f64[0] >= v23) {
          return result;
        }
        result.n128_f64[0] = vabdd_f64(result.n128_f64[0], v23);
        if (result.n128_f64[0] <= v26) {
          return result;
        }
      }
      else
      {
LABEL_69:
        if (result.n128_f64[0] >= v23) {
          return result;
        }
      }
      __n128 result = *(__n128 *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(__n128 *)a2 = result;
    }
  }
  return result;
}

__n128 sub_101236EDC(double *a1, double *a2, double *a3, uint64_t a4, unint64_t *a5)
{
  sub_101236B98(a1, a2, a3, (unint64_t *)a4);
  result.n128_u64[0] = *a5;
  double v11 = *(double *)a4;
  if (*(double *)a5 != *(double *)a4)
  {
    if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_20;
    }
    double v29 = vabdd_f64(result.n128_f64[0], v11);
    double v30 = fabs(result.n128_f64[0]);
    double v31 = fabs(v11);
    if (v30 < v31) {
      double v30 = v31;
    }
    double v32 = v30 >= 1.0 ? v30 * 2.22044605e-16 : 2.22044605e-16;
    if (v29 > v32) {
      goto LABEL_20;
    }
  }
  result.n128_u64[0] = a5[1];
  double v11 = *(double *)(a4 + 8);
  if (result.n128_f64[0] == v11) {
    return result;
  }
  if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL
    || (*(void *)&v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
LABEL_20:
    if (result.n128_f64[0] >= v11) {
      return result;
    }
    goto LABEL_21;
  }
  double v13 = fabs(result.n128_f64[0]);
  double v14 = fabs(v11);
  if (v13 < v14) {
    double v13 = v14;
  }
  if (v13 >= 1.0) {
    double v15 = v13 * 2.22044605e-16;
  }
  else {
    double v15 = 2.22044605e-16;
  }
  if (result.n128_f64[0] < v11)
  {
    result.n128_f64[0] = vabdd_f64(result.n128_f64[0], v11);
    if (result.n128_f64[0] > v15)
    {
LABEL_21:
      __n128 result = *(__n128 *)a4;
      *(_OWORD *)a4 = *(_OWORD *)a5;
      *(__n128 *)a5 = result;
      result.n128_u64[0] = *(void *)a4;
      double v17 = *a3;
      if (*(double *)a4 != *a3)
      {
        if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v17 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_41;
        }
        double v21 = vabdd_f64(result.n128_f64[0], v17);
        double v22 = fabs(result.n128_f64[0]);
        double v23 = fabs(v17);
        if (v22 < v23) {
          double v22 = v23;
        }
        double v24 = v22 >= 1.0 ? v22 * 2.22044605e-16 : 2.22044605e-16;
        if (v21 > v24) {
          goto LABEL_41;
        }
      }
      result.n128_u64[0] = *(void *)(a4 + 8);
      double v17 = a3[1];
      if (result.n128_f64[0] == v17) {
        return result;
      }
      if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL
        && (*(void *)&v17 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v18 = fabs(result.n128_f64[0]);
        double v19 = fabs(v17);
        if (v18 < v19) {
          double v18 = v19;
        }
        if (v18 >= 1.0) {
          double v20 = v18 * 2.22044605e-16;
        }
        else {
          double v20 = 2.22044605e-16;
        }
        if (result.n128_f64[0] >= v17) {
          return result;
        }
        result.n128_f64[0] = vabdd_f64(result.n128_f64[0], v17);
        if (result.n128_f64[0] <= v20) {
          return result;
        }
      }
      else
      {
LABEL_41:
        if (result.n128_f64[0] >= v17) {
          return result;
        }
      }
      __n128 result = *(__n128 *)a3;
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(__n128 *)a4 = result;
      result.n128_f64[0] = *a3;
      double v25 = *a2;
      if (*a3 != *a2)
      {
        if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v25 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_69;
        }
        double v33 = vabdd_f64(result.n128_f64[0], v25);
        double v34 = fabs(result.n128_f64[0]);
        double v35 = fabs(v25);
        if (v34 < v35) {
          double v34 = v35;
        }
        double v36 = v34 >= 1.0 ? v34 * 2.22044605e-16 : 2.22044605e-16;
        if (v33 > v36) {
          goto LABEL_69;
        }
      }
      result.n128_f64[0] = a3[1];
      double v25 = a2[1];
      if (result.n128_f64[0] == v25) {
        return result;
      }
      if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL
        && (*(void *)&v25 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v26 = fabs(result.n128_f64[0]);
        double v27 = fabs(v25);
        if (v26 < v27) {
          double v26 = v27;
        }
        if (v26 >= 1.0) {
          double v28 = v26 * 2.22044605e-16;
        }
        else {
          double v28 = 2.22044605e-16;
        }
        if (result.n128_f64[0] >= v25) {
          return result;
        }
        result.n128_f64[0] = vabdd_f64(result.n128_f64[0], v25);
        if (result.n128_f64[0] <= v28) {
          return result;
        }
      }
      else
      {
LABEL_69:
        if (result.n128_f64[0] >= v25) {
          return result;
        }
      }
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      result.n128_f64[0] = *a2;
      double v37 = *a1;
      if (*a2 != *a1)
      {
        if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v37 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_90;
        }
        double v41 = vabdd_f64(result.n128_f64[0], v37);
        double v42 = fabs(result.n128_f64[0]);
        double v43 = fabs(v37);
        if (v42 < v43) {
          double v42 = v43;
        }
        double v44 = v42 >= 1.0 ? v42 * 2.22044605e-16 : 2.22044605e-16;
        if (v41 > v44) {
          goto LABEL_90;
        }
      }
      result.n128_f64[0] = a2[1];
      double v37 = a1[1];
      if (result.n128_f64[0] == v37) {
        return result;
      }
      if ((result.n128_u64[0] & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL
        && (*(void *)&v37 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v38 = fabs(result.n128_f64[0]);
        double v39 = fabs(v37);
        if (v38 < v39) {
          double v38 = v39;
        }
        if (v38 >= 1.0) {
          double v40 = v38 * 2.22044605e-16;
        }
        else {
          double v40 = 2.22044605e-16;
        }
        if (result.n128_f64[0] >= v37) {
          return result;
        }
        result.n128_f64[0] = vabdd_f64(result.n128_f64[0], v37);
        if (result.n128_f64[0] <= v40) {
          return result;
        }
      }
      else
      {
LABEL_90:
        if (result.n128_f64[0] >= v37) {
          return result;
        }
      }
      __n128 result = *(__n128 *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(__n128 *)a2 = result;
    }
  }
  return result;
}

void sub_101237320(float64x2_t *a1, void **a2)
{
  double v5 = (float64x2_t *)a2[1];
  unint64_t v4 = (unint64_t)a2[2];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = ((char *)v5 - (unsigned char *)*a2) >> 4;
    unint64_t v8 = v7 + 1;
    if ((unint64_t)(v7 + 1) >> 60) {
LABEL_41:
    }
      sub_10006A748();
    uint64_t v9 = v4 - (void)*a2;
    if (v9 >> 3 > v8) {
      unint64_t v8 = v9 >> 3;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10) {
      unint64_t v10 = (unint64_t)sub_1009C886C(v10);
    }
    else {
      uint64_t v11 = 0;
    }
    double v12 = (float64x2_t *)(v10 + 16 * v7);
    unint64_t v13 = v10 + 16 * v11;
    *double v12 = *a1;
    double v6 = v12 + 1;
    double v15 = (char *)*a2;
    double v14 = (char *)a2[1];
    if (v14 != *a2)
    {
      do
      {
        v12[-1] = *((float64x2_t *)v14 - 1);
        --v12;
        v14 -= 16;
      }
      while (v14 != v15);
      double v14 = (char *)*a2;
    }
    *a2 = v12;
    a2[1] = v6;
    a2[2] = (void *)v13;
    if (v14) {
      operator delete(v14);
    }
  }
  else
  {
    float64x2_t *v5 = *a1;
    double v6 = v5 + 1;
  }
  a2[1] = v6;
  uint64_t v16 = (char *)v6 - (unsigned char *)*a2;
  if ((unint64_t)v16 >= 0x21)
  {
    unint64_t v17 = v16 >> 4;
    do
    {
      float64_t v18 = v6[-1].f64[0];
      float64_t v19 = v6[-1].f64[1];
      double v32 = 1.0;
      float64x2_t v35 = v6[-3];
      v34.f64[0] = v18;
      v34.f64[1] = v19;
      f64 = (_OWORD *)v6[-2].f64;
      float64x2_t v33 = v6[-2];
      sub_101234054(&v35, &v34, &v33, &v32);
      if (v21 != 0.0
        && ((*(void *)&v21 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || fabs(v21) > v32 * 2.22044605e-16)
        && v21 <= 0.0)
      {
        break;
      }
      a2[1] = f64;
      double v22 = a2[2];
      if (f64 >= (_OWORD *)v22)
      {
        uint64_t v23 = ((char *)f64 - (unsigned char *)*a2) >> 4;
        if ((unint64_t)(v23 + 1) >> 60) {
          goto LABEL_41;
        }
        uint64_t v24 = v22 - (unsigned char *)*a2;
        uint64_t v25 = v24 >> 3;
        if (v24 >> 3 <= (unint64_t)(v23 + 1)) {
          uint64_t v25 = v23 + 1;
        }
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v26 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v26 = v25;
        }
        if (v26) {
          unint64_t v26 = (unint64_t)sub_1009C886C(v26);
        }
        else {
          uint64_t v27 = 0;
        }
        double v28 = (float64_t *)(v26 + 16 * v23);
        float64_t *v28 = v18;
        v28[1] = v19;
        double v30 = (char *)*a2;
        double v29 = (char *)a2[1];
        double v31 = v28;
        if (v29 != *a2)
        {
          do
          {
            *((_OWORD *)v31 - 1) = *((_OWORD *)v29 - 1);
            v31 -= 2;
            v29 -= 16;
          }
          while (v29 != v30);
          double v29 = (char *)*a2;
        }
        double v6 = (float64x2_t *)(v28 + 2);
        *a2 = v31;
        a2[1] = v28 + 2;
        a2[2] = (void *)(v26 + 16 * v27);
        if (v29) {
          operator delete(v29);
        }
      }
      else
      {
        v6[-2].f64[0] = v18;
        v6[-2].f64[1] = v19;
        --v6;
      }
      a2[1] = v6;
      --v17;
    }
    while (v17 > 2);
  }
}

void sub_10123759C(float64x2_t *a1, void **a2)
{
  double v5 = (float64x2_t *)a2[1];
  unint64_t v4 = (unint64_t)a2[2];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = ((char *)v5 - (unsigned char *)*a2) >> 4;
    unint64_t v8 = v7 + 1;
    if ((unint64_t)(v7 + 1) >> 60) {
LABEL_41:
    }
      sub_10006A748();
    uint64_t v9 = v4 - (void)*a2;
    if (v9 >> 3 > v8) {
      unint64_t v8 = v9 >> 3;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10) {
      unint64_t v10 = (unint64_t)sub_1009C886C(v10);
    }
    else {
      uint64_t v11 = 0;
    }
    double v12 = (float64x2_t *)(v10 + 16 * v7);
    unint64_t v13 = v10 + 16 * v11;
    *double v12 = *a1;
    double v6 = v12 + 1;
    double v15 = (char *)*a2;
    double v14 = (char *)a2[1];
    if (v14 != *a2)
    {
      do
      {
        v12[-1] = *((float64x2_t *)v14 - 1);
        --v12;
        v14 -= 16;
      }
      while (v14 != v15);
      double v14 = (char *)*a2;
    }
    *a2 = v12;
    a2[1] = v6;
    a2[2] = (void *)v13;
    if (v14) {
      operator delete(v14);
    }
  }
  else
  {
    float64x2_t *v5 = *a1;
    double v6 = v5 + 1;
  }
  a2[1] = v6;
  uint64_t v16 = (char *)v6 - (unsigned char *)*a2;
  if ((unint64_t)v16 >= 0x21)
  {
    unint64_t v17 = v16 >> 4;
    do
    {
      float64_t v18 = v6[-1].f64[0];
      float64_t v19 = v6[-1].f64[1];
      double v32 = 1.0;
      float64x2_t v35 = v6[-3];
      v34.f64[0] = v18;
      v34.f64[1] = v19;
      f64 = (_OWORD *)v6[-2].f64;
      float64x2_t v33 = v6[-2];
      sub_101234054(&v35, &v34, &v33, &v32);
      if (v21 != 0.0
        && ((*(void *)&v21 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 || fabs(v21) > v32 * 2.22044605e-16)
        && v21 > 0.0)
      {
        break;
      }
      a2[1] = f64;
      double v22 = a2[2];
      if (f64 >= (_OWORD *)v22)
      {
        uint64_t v23 = ((char *)f64 - (unsigned char *)*a2) >> 4;
        if ((unint64_t)(v23 + 1) >> 60) {
          goto LABEL_41;
        }
        uint64_t v24 = v22 - (unsigned char *)*a2;
        uint64_t v25 = v24 >> 3;
        if (v24 >> 3 <= (unint64_t)(v23 + 1)) {
          uint64_t v25 = v23 + 1;
        }
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v26 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v26 = v25;
        }
        if (v26) {
          unint64_t v26 = (unint64_t)sub_1009C886C(v26);
        }
        else {
          uint64_t v27 = 0;
        }
        double v28 = (float64_t *)(v26 + 16 * v23);
        float64_t *v28 = v18;
        v28[1] = v19;
        double v30 = (char *)*a2;
        double v29 = (char *)a2[1];
        double v31 = v28;
        if (v29 != *a2)
        {
          do
          {
            *((_OWORD *)v31 - 1) = *((_OWORD *)v29 - 1);
            v31 -= 2;
            v29 -= 16;
          }
          while (v29 != v30);
          double v29 = (char *)*a2;
        }
        double v6 = (float64x2_t *)(v28 + 2);
        *a2 = v31;
        a2[1] = v28 + 2;
        a2[2] = (void *)(v26 + 16 * v27);
        if (v29) {
          operator delete(v29);
        }
      }
      else
      {
        v6[-2].f64[0] = v18;
        v6[-2].f64[1] = v19;
        --v6;
      }
      a2[1] = v6;
      --v17;
    }
    while (v17 > 2);
  }
}

void ***sub_101237818(void ***a1, _OWORD *a2)
{
  unint64_t v4 = *a1;
  double v6 = (*a1)[1];
  unint64_t v5 = (unint64_t)(*a1)[2];
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = ((char *)v6 - (unsigned char *)*v4) >> 4;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 60) {
      sub_10006A748();
    }
    uint64_t v10 = v5 - (void)*v4;
    if (v10 >> 3 > v9) {
      unint64_t v9 = v10 >> 3;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11) {
      unint64_t v11 = (unint64_t)sub_1009C886C(v11);
    }
    else {
      uint64_t v12 = 0;
    }
    unint64_t v13 = (_OWORD *)(v11 + 16 * v8);
    unint64_t v14 = v11 + 16 * v12;
    _OWORD *v13 = *a2;
    uint64_t v7 = v13 + 1;
    uint64_t v16 = (char *)*v4;
    double v15 = (char *)v4[1];
    if (v15 != *v4)
    {
      do
      {
        *--unint64_t v13 = *((_OWORD *)v15 - 1);
        v15 -= 16;
      }
      while (v15 != v16);
      double v15 = (char *)*v4;
    }
    *unint64_t v4 = v13;
    v4[1] = v7;
    v4[2] = (void *)v14;
    if (v15) {
      operator delete(v15);
    }
  }
  else
  {
    _OWORD *v6 = *a2;
    uint64_t v7 = v6 + 1;
  }
  v4[1] = v7;
  return a1;
}

void sub_101237908(void ***a1)
{
  uint64_t v1 = *a1;
  double v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        sub_101233F4C(v4);
      }
      while ((void *)v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *sub_10123798C(void *a1, void *a2, void *a3, uint64_t *a4, void *a5, uint64_t a6)
{
  *((void *)&v1005 + 1) = a2;
  *(void *)&long long v1005 = a1;
  if (*a1 == a1[1])
  {
    uint64_t v10 = (uint64_t *)a1[3];
    unint64_t v11 = (uint64_t *)a1[4];
    if (v10 == v11)
    {
      BOOL v9 = 1;
    }
    else
    {
      do
      {
        uint64_t v12 = *v10;
        uint64_t v13 = v10[1];
        v10 += 3;
        BOOL v9 = v12 == v13;
        _ZF = !v9 || v10 == v11;
      }
      while (!_ZF);
    }
  }
  else
  {
    BOOL v9 = 0;
  }
  if (*a2 == a2[1])
  {
    for (uint64_t i = (void *)a2[3]; ; i += 3)
    {
      if (i == (void *)a2[4]) {
        return a4;
      }
      if (*i != i[1]) {
        break;
      }
    }
  }
  if (!v9)
  {
    long long v1019 = 0u;
    long long v1020 = 0u;
    long long v1018 = 0u;
    char v1017 = 0;
    v1024 = 0;
    uint64_t v1025 = 0;
    uint64_t v1026 = 0;
    v1021 = 0;
    uint64_t v1022 = 0;
    uint64_t v1023 = 0;
    sub_10123CCD0((uint64_t)a1, (uint64_t)&v1024, 0);
    sub_10123CCD0(*((uint64_t *)&v1005 + 1), (uint64_t)&v1021, 1u);
    v1039[0] = 0;
    v1039[1] = (void *)v1005;
    v1039[2] = (void *)1;
    v1039[3] = *((void **)&v1005 + 1);
    v1039[4] = a5;
    v1039[5] = a3;
    *(void *)v1040 = &v1018;
    *(void *)&v1040[8] = &v1017;
    uint64_t v16 = (double *)v1024;
    double v15 = (double *)v1025;
    unint64_t v17 = (double *)v1021;
    if (0xEEEEEEEEEEEEEEEFLL * ((v1025 - (uint64_t)v1024) >> 3) < 0x11
      || (float64_t v18 = (double *)v1022, 0xEEEEEEEEEEEEEEEFLL * ((v1022 - (uint64_t)v1021) >> 3) < 0x11))
    {
      if (v1024 != (void *)v1025)
      {
        double v40 = (double *)v1022;
        double v41 = (double *)v1022;
        do
        {
          _ZF = v17 == v41;
          double v41 = v17;
          if (!_ZF)
          {
            double v42 = v17;
            do
            {
              sub_10123FE18((uint64_t)v1039, v16, v42);
              v42 += 15;
            }
            while (v42 != v40);
            double v41 = v40;
          }
          v16 += 15;
        }
        while (v16 != v15);
      }
    }
    else
    {
      v1009[0] = 0;
      v1009[1] = 0;
      *(void *)&long long v1010 = 0;
      __p[1] = 0;
      __p[0] = 0;
      v1038 = 0;
      int64x2_t v1027 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v1028 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      if (v1024 != (void *)v1025)
      {
        float64_t v19 = 0;
        do
        {
          sub_101240044((double *)v1027.i64, v16 + 4);
          if ((unint64_t)v19 >= (unint64_t)v1010)
          {
            double v21 = (char *)v1009[0];
            uint64_t v22 = (v19 - (char *)v1009[0]) >> 3;
            unint64_t v23 = v22 + 1;
            if ((unint64_t)(v22 + 1) >> 61) {
LABEL_1605:
            }
              sub_10006A748();
            uint64_t v24 = v1010 - (unint64_t)v1009[0];
            if ((uint64_t)(v1010 - (unint64_t)v1009[0]) >> 2 > v23) {
              unint64_t v23 = v24 >> 2;
            }
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v25 = v23;
            }
            if (v25) {
              unint64_t v25 = (unint64_t)sub_100048350(v25);
            }
            else {
              uint64_t v26 = 0;
            }
            uint64_t v27 = (double **)(v25 + 8 * v22);
            char *v27 = v16;
            double v20 = v27 + 1;
            if (v19 != v21)
            {
              do
              {
                double v28 = (double *)*((void *)v19 - 1);
                v19 -= 8;
                *--uint64_t v27 = v28;
              }
              while (v19 != v21);
              float64_t v19 = (char *)v1009[0];
            }
            v1009[0] = v27;
            *(void *)&long long v1010 = v25 + 8 * v26;
            if (v19) {
              operator delete(v19);
            }
          }
          else
          {
            *(void *)float64_t v19 = v16;
            double v20 = v19 + 8;
          }
          v1009[1] = v20;
          v16 += 15;
          float64_t v19 = (char *)v20;
        }
        while (v16 != (double *)v1025);
        unint64_t v17 = (double *)v1021;
        float64_t v18 = (double *)v1022;
      }
      if (v17 != v18)
      {
        do
        {
          sub_101240044((double *)v1027.i64, v17 + 4);
          double v29 = (char *)__p[1];
          if (__p[1] >= v1038)
          {
            double v31 = (char *)__p[0];
            int64_t v32 = ((char *)__p[1] - (char *)__p[0]) >> 3;
            unint64_t v33 = v32 + 1;
            if ((unint64_t)(v32 + 1) >> 61) {
              goto LABEL_1605;
            }
            uint64_t v34 = v1038 - (char *)__p[0];
            if ((v1038 - (char *)__p[0]) >> 2 > v33) {
              unint64_t v33 = v34 >> 2;
            }
            if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v35 = v33;
            }
            if (v35) {
              unint64_t v35 = (unint64_t)sub_100048350(v35);
            }
            else {
              uint64_t v36 = 0;
            }
            double v37 = (double **)(v35 + 8 * v32);
            *double v37 = v17;
            double v30 = v37 + 1;
            if (v29 != v31)
            {
              do
              {
                double v38 = (double *)*((void *)v29 - 1);
                v29 -= 8;
                *--double v37 = v38;
              }
              while (v29 != v31);
              double v29 = (char *)__p[0];
            }
            __p[0] = v37;
            v1038 = (char *)(v35 + 8 * v36);
            if (v29) {
              operator delete(v29);
            }
          }
          else
          {
            *(void *)__p[1] = v17;
            double v30 = v29 + 8;
          }
          __p[1] = v30;
          v17 += 15;
        }
        while (v17 != (double *)v1022);
      }
      sub_10123F750((double *)v1027.i64, (uint64_t **)v1009, (uint64_t **)__p, 0, (uint64_t)v1039);
      if (__p[0]) {
        operator delete(__p[0]);
      }
      if (v1009[0]) {
        operator delete(v1009[0]);
      }
      unint64_t v17 = (double *)v1021;
    }
    if (v17) {
      operator delete(v17);
    }
    if (v1024) {
      operator delete(v1024);
    }
    if (*((void *)&v1020 + 1))
    {
      if (*(void *)(v1005 + 32) != *(void *)(v1005 + 24))
      {
        int64x2_t v1027 = 0uLL;
        v1028.i64[0] = 0;
        sub_10123CCD0(v1005, (uint64_t)&v1027, 0);
        v1039[0] = (void *)v1005;
        v1039[1] = a5;
        v1039[2] = a3;
        v1039[3] = &v1018;
        v1039[5] = 0;
        v1039[4] = &v1017;
        sub_101247670(v1027.i64, (uint64_t)v1039);
        if (v1027.i64[0]) {
          operator delete((void *)v1027.i64[0]);
        }
      }
      if (*(void *)(*((void *)&v1005 + 1) + 32) != *(void *)(*((void *)&v1005 + 1) + 24))
      {
        int64x2_t v1027 = 0uLL;
        v1028.i64[0] = 0;
        sub_10123CCD0(*((uint64_t *)&v1005 + 1), (uint64_t)&v1027, 0);
        v1039[0] = *((void **)&v1005 + 1);
        v1039[1] = a5;
        v1039[2] = a3;
        v1039[3] = &v1018;
        v1039[5] = (void *)1;
        v1039[4] = &v1017;
        sub_101247670(v1027.i64, (uint64_t)v1039);
        if (v1027.i64[0]) {
          operator delete((void *)v1027.i64[0]);
        }
      }
    }
    v967 = a4;
    v1015 = 0;
    uint64_t v1016 = 0;
    v1013[1] = 0;
    v1014 = &v1015;
    v1012 = (uint64_t *)v1013;
    v1013[0] = 0;
    v1039[2] = 0;
    v1039[1] = 0;
    v1039[0] = &v1039[1];
    uint64_t v43 = *((void *)&v1018 + 1);
    uint64_t v44 = v1019;
    if ((void)v1019 != *((void *)&v1018 + 1))
    {
      uint64_t v45 = v1020;
      unint64_t v46 = (unint64_t)v1020 >> 4;
      double v47 = (uint64_t *)(*((void *)&v1018 + 1) + 8 * ((unint64_t)v1020 >> 4));
      uint64_t v48 = *v47;
      uint64_t v49 = *v47 + 376 * (v1020 & 0xF);
      uint64_t v50 = *(void *)(*((void *)&v1018 + 1)
                      + (((*((void *)&v1020 + 1) + (void)v1020) >> 1) & 0x7FFFFFFFFFFFFFF8))
          + 376 * ((DWORD2(v1020) + v1020) & 0xF);
      if (v49 != v50)
      {
        uint64_t v51 = 0;
        uint64_t v994 = *(void *)(*((void *)&v1018 + 1)
                         + (((*((void *)&v1020 + 1) + (void)v1020) >> 1) & 0x7FFFFFFFFFFFFFF8))
             + 376 * ((DWORD2(v1020) + v1020) & 0xF);
        do
        {
          if (*(_DWORD *)(v49 + 16) == 7)
          {
            v998 = v47;
            uint64_t v52 = v49 + 40;
            do
            {
              double v53 = *(void **)(v52 + 16);
              double v54 = *(void **)(v52 + 24);
              double v55 = &v1039[1];
              double v56 = &v1039[1];
              double v57 = (void **)v1039[1];
              if (v1039[1])
              {
                while (1)
                {
                  double v55 = v57;
                  double v58 = v57[4];
                  if (v58 == v53)
                  {
                    double v59 = v55[5];
                    BOOL v60 = v59 == v54;
                    if ((uint64_t)v59 <= (uint64_t)v54)
                    {
                      if ((uint64_t)v59 >= (uint64_t)v54) {
                        char v61 = 1;
                      }
                      else {
                        char v61 = -1;
                      }
                      if (v60) {
                        char v61 = 0;
                      }
                      if ((v61 & 0x80) == 0)
                      {
LABEL_107:
                        double v63 = v55;
                        goto LABEL_108;
                      }
                      goto LABEL_102;
                    }
LABEL_96:
                    double v57 = (void **)*v55;
                    double v56 = v55;
                    if (!*v55) {
                      break;
                    }
                  }
                  else
                  {
                    if ((uint64_t)v58 > (uint64_t)v53) {
                      goto LABEL_96;
                    }
                    if ((uint64_t)v58 >= (uint64_t)v53) {
                      char v62 = 1;
                    }
                    else {
                      char v62 = -1;
                    }
                    if ((v62 & 0x80) == 0) {
                      goto LABEL_107;
                    }
LABEL_102:
                    double v57 = (void **)v55[1];
                    if (!v57)
                    {
                      double v56 = v55 + 1;
                      break;
                    }
                  }
                }
              }
              double v63 = operator new(0x48uLL);
              v63[4] = v53;
              v63[5] = v54;
              v63[7] = 0;
              v63[8] = 0;
              v63[6] = 0;
              *double v63 = 0;
              v63[1] = 0;
              v63[2] = v55;
              *double v56 = v63;
              BOOL v64 = v63;
              if (*(void *)v1039[0])
              {
                v1039[0] = *(void **)v1039[0];
                BOOL v64 = (uint64_t *)*v56;
              }
              sub_100046C90((uint64_t *)v1039[1], v64);
              ++v1039[2];
LABEL_108:
              unint64_t v65 = v63[8];
              double v66 = (char *)v63[7];
              if ((unint64_t)v66 >= v65)
              {
                double v68 = (char *)v63[6];
                uint64_t v69 = (v66 - v68) >> 3;
                if ((unint64_t)(v69 + 1) >> 61) {
                  sub_10006A748();
                }
                unint64_t v70 = v65 - (void)v68;
                unint64_t v71 = (uint64_t)(v65 - (void)v68) >> 2;
                if (v71 <= v69 + 1) {
                  unint64_t v71 = v69 + 1;
                }
                if (v70 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v72 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v72 = v71;
                }
                if (v72)
                {
                  double v73 = (char *)sub_10004EF74((uint64_t)(v63 + 8), v72);
                  double v68 = (char *)v63[6];
                  double v66 = (char *)v63[7];
                }
                else
                {
                  double v73 = 0;
                }
                double v74 = &v73[8 * v69];
                *(void *)double v74 = v51;
                double v67 = v74 + 8;
                while (v66 != v68)
                {
                  uint64_t v75 = *((void *)v66 - 1);
                  v66 -= 8;
                  *((void *)v74 - 1) = v75;
                  v74 -= 8;
                }
                v63[6] = v74;
                v63[7] = v67;
                v63[8] = &v73[8 * v72];
                if (v68) {
                  operator delete(v68);
                }
              }
              else
              {
                *(void *)double v66 = v51;
                double v67 = v66 + 8;
              }
              v63[7] = v67;
              v52 += 168;
            }
            while (v52 != v49 + 376);
            uint64_t v50 = v994;
            double v47 = v998;
            uint64_t v48 = *v998;
          }
          v49 += 376;
          if (v49 - v48 == 6016)
          {
            uint64_t v76 = v47[1];
            ++v47;
            uint64_t v48 = v76;
            uint64_t v49 = v76;
          }
          ++v51;
        }
        while (v49 != v50);
        uint64_t v45 = v1020;
        uint64_t v43 = *((void *)&v1018 + 1);
        uint64_t v44 = v1019;
        unint64_t v46 = (unint64_t)v1020 >> 4;
      }
      if (v44 != v43)
      {
        double v77 = (uint64_t *)(v43 + 8 * v46);
        uint64_t v78 = *v77;
        uint64_t v79 = *(void *)(v43 + (((unint64_t)(*((void *)&v1020 + 1) + v45) >> 1) & 0x7FFFFFFFFFFFFFF8))
            + 376 * ((DWORD2(v1020) + v45) & 0xF);
        if (*v77 + 376 * (v45 & 0xF) != v79)
        {
          uint64_t v80 = *v77 + 376 * (v45 & 0xF);
          uint64_t v968 = v79;
          do
          {
            int v81 = *(_DWORD *)(v80 + 16);
            if (v81 != 2 && v81 != 7)
            {
              uint64_t v970 = v80;
              v971 = v77;
              v974 = (void *)(v80 + 376);
              uint64_t v995 = v80 + 40;
              v978 = (void *)(v80 + 40);
              do
              {
                double v83 = (void **)v1039[1];
                if (v1039[1])
                {
                  BOOL v85 = (void *)v978[2];
                  double v84 = (void *)v978[3];
                  double v86 = &v1039[1];
                  do
                  {
                    double v87 = v83;
                    double v88 = v86;
                    double v89 = v83[4];
                    BOOL v90 = v89 == v85;
                    if ((uint64_t)v89 >= (uint64_t)v85) {
                      char v91 = 1;
                    }
                    else {
                      char v91 = -1;
                    }
                    if (v90)
                    {
                      double v92 = v83[5];
                      BOOL v93 = v92 == v84;
                      char v91 = (uint64_t)v92 >= (uint64_t)v84 ? 1 : -1;
                      if (v93) {
                        char v91 = 0;
                      }
                    }
                    double v94 = v83 + 1;
                    if ((v91 & 0x80) == 0)
                    {
                      double v94 = v87;
                      double v86 = v87;
                    }
                    double v83 = (void **)*v94;
                  }
                  while (v83);
                  if (&v1039[1] != v86)
                  {
                    if (v91 < 0) {
                      double v95 = v88;
                    }
                    else {
                      double v95 = v87;
                    }
                    double v96 = v95[4];
                    BOOL v97 = v96 == v85;
                    if ((uint64_t)v96 <= (uint64_t)v85) {
                      char v98 = 1;
                    }
                    else {
                      char v98 = -1;
                    }
                    if (v97)
                    {
                      if (v91 < 0) {
                        double v99 = v88;
                      }
                      else {
                        double v99 = v87;
                      }
                      double v100 = v99[5];
                      BOOL v101 = v100 == v84;
                      if ((uint64_t)v100 <= (uint64_t)v84) {
                        char v102 = 1;
                      }
                      else {
                        char v102 = -1;
                      }
                      if (v101) {
                        char v98 = 0;
                      }
                      else {
                        char v98 = v102;
                      }
                    }
                    if ((v98 & 0x80) == 0)
                    {
                      if (v91 < 0) {
                        double v87 = v88;
                      }
                      double v103 = v87[6];
                      v982 = v87[7];
                      if (v103 != v982)
                      {
                        do
                        {
                          uint64_t v104 = 0;
                          v999 = 0;
                          v988 = v103;
                          uint64_t v105 = *(void *)(*((void *)&v1018 + 1)
                                           + ((((void)v1020 + *v103) >> 1) & 0x7FFFFFFFFFFFFFF8))
                               + 376 * ((v1020 + *(_DWORD *)v103) & 0xF)
                               + 40;
                          char v106 = 1;
                          do
                          {
                            uint64_t v107 = 0;
                            char v108 = v106;
                            double v109 = (int64x2_t *)(v995 + 168 * v104);
                            double v110 = &v109->i64[1];
                            double v111 = v109 + 1;
                            double v112 = (void *)(v995 + 168 * (v104 ^ 1));
                            double v113 = v112 + 1;
                            double v114 = v112 + 3;
                            double v115 = v112 + 2;
                            char v116 = 1;
                            do
                            {
                              char v117 = v116;
                              int64_t v118 = (int64x2_t *)(v105 + 168 * v107);
                              int32x2_t v119 = vmovn_s64(vceqq_s64(*v111, v118[1]));
                              if ((v119.i32[1] & v119.i32[0] & 1) != 0 && *v110 == v118->i64[1])
                              {
                                double v120 = *v110 ? (void *)*((void *)&v1005 + 1) : (void *)v1005;
                                if (sub_101249034(v120, v110, &v118->i64[1]) <= 1)
                                {
                                  uint64_t v121 = v107 ^ 1;
                                  uint64_t v122 = v105 + 168 * (v107 ^ 1);
                                  uint64_t v124 = *(void *)(v122 + 8);
                                  double v123 = (void *)(v122 + 8);
                                  if (*v113 == v124
                                    && *v114 == *(void *)(v105 + 168 * v121 + 24)
                                    && *v115 == *(void *)(v105 + 168 * v121 + 16))
                                  {
                                    if (*v113) {
                                      double v125 = (void *)*((void *)&v1005 + 1);
                                    }
                                    else {
                                      double v125 = (void *)v1005;
                                    }
                                    uint64_t v126 = sub_101249034(v125, v113, v123);
                                    double v127 = v999;
                                    if (v126 < 2) {
                                      double v127 = v999 + 1;
                                    }
                                    v999 = v127;
                                  }
                                }
                              }
                              char v116 = 0;
                              uint64_t v107 = 1;
                            }
                            while ((v117 & 1) != 0);
                            char v106 = 0;
                            uint64_t v104 = 1;
                          }
                          while ((v108 & 1) != 0);
                          if (v999 == (char *)2) {
                            *(unsigned char *)(*(void *)(*((void *)&v1018 + 1)
                          }
                                                 + ((((void)v1020 + *v988) >> 1) & 0x7FFFFFFFFFFFFFF8))
                                     + 376 * ((v1020 + *(_DWORD *)v988) & 0xF)
                                     + 32) = 1;
                          double v103 = v988 + 1;
                        }
                        while (v988 + 1 != v982);
                      }
                    }
                  }
                }
                v978 += 21;
              }
              while (v978 != v974);
              uint64_t v80 = v970;
              double v77 = v971;
              uint64_t v78 = *v971;
              uint64_t v79 = v968;
            }
            v80 += 376;
            if (v80 - v78 == 6016)
            {
              uint64_t v128 = v77[1];
              ++v77;
              uint64_t v78 = v128;
              uint64_t v80 = v128;
            }
          }
          while (v80 != v79);
        }
      }
    }
    sub_100BB69C0((void *)v1039[1]);
    if ((void)v1019 == *((void *)&v1018 + 1)
      || (double v129 = (void *)(*((void *)&v1018 + 1) + 8 * ((unint64_t)v1020 >> 4)),
          uint64_t v130 = *v129 + 376 * (v1020 & 0xF),
          uint64_t v131 = *(void *)(*((void *)&v1018 + 1)
                           + (((*((void *)&v1020 + 1) + (void)v1020) >> 1) & 0x7FFFFFFFFFFFFFF8))
               + 376 * ((DWORD2(v1020) + v1020) & 0xF),
          v130 == v131))
    {
      v975 = 0;
      double v132 = 0;
    }
    else
    {
      v975 = 0;
      double v132 = 0;
      double v133 = 0;
      uint64_t v134 = 0;
      do
      {
        if (!*(unsigned char *)(v130 + 32))
        {
          uint64_t v136 = *(void *)v130;
          uint64_t v135 = *(void *)(v130 + 8);
          if (v132 >= v133)
          {
            unint64_t v137 = 0xAAAAAAAAAAAAAAABLL * ((v132 - v975) >> 3) + 1;
            if (v137 > 0xAAAAAAAAAAAAAAALL) {
              sub_10006A748();
            }
            if (0x5555555555555556 * ((v133 - v975) >> 3) > v137) {
              unint64_t v137 = 0x5555555555555556 * ((v133 - v975) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((v133 - v975) >> 3) >= 0x555555555555555) {
              unint64_t v138 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v138 = v137;
            }
            if (v138)
            {
              if (v138 > 0xAAAAAAAAAAAAAAALL) {
                sub_10006A7CC();
              }
              double v139 = (char *)operator new(24 * v138);
            }
            else
            {
              double v139 = 0;
            }
            BOOL v140 = &v139[8 * ((v132 - v975) >> 3)];
            *(void *)BOOL v140 = v134;
            *((void *)v140 + 1) = v136;
            *((void *)v140 + 2) = v135;
            if (v132 == v975)
            {
              double v144 = &v139[8 * ((v132 - v975) >> 3)];
              double v142 = v975;
            }
            else
            {
              double v141 = &v139[8 * ((v132 - v975) >> 3)];
              double v142 = v975;
              do
              {
                long long v143 = *(_OWORD *)(v132 - 24);
                double v144 = v141 - 24;
                *((void *)v141 - 1) = *((void *)v132 - 1);
                *(_OWORD *)(v141 - 24) = v143;
                v132 -= 24;
                v141 -= 24;
              }
              while (v132 != v975);
            }
            double v133 = &v139[24 * v138];
            double v132 = v140 + 24;
            if (v142) {
              operator delete(v142);
            }
            v975 = v144;
          }
          else
          {
            *(void *)double v132 = v134;
            *((void *)v132 + 1) = v136;
            *((void *)v132 + 2) = v135;
            v132 += 24;
          }
        }
        v130 += 376;
        if (v130 - *v129 == 6016)
        {
          uint64_t v145 = v129[1];
          ++v129;
          uint64_t v130 = v145;
        }
        ++v134;
      }
      while (v130 != v131);
    }
    unint64_t v146 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((v132 - v975) >> 3));
    if (v132 == v975) {
      uint64_t v147 = 0;
    }
    else {
      uint64_t v147 = v146;
    }
    sub_101249178((unint64_t)v975, (unint64_t)v132, v147, 1);
    v1009[0] = 0;
    v1009[1] = 0;
    *(void *)&long long v1010 = 0;
    if (v975 == v132) {
      goto LABEL_381;
    }
    double v148 = v975;
    do
    {
      double v149 = v148 + 24;
      v983 = v148 + 24;
      if (v148 + 24 != v132)
      {
        double v150 = (uint64_t *)v148;
        v1000 = (double *)(v148 + 8);
        v989 = (uint64_t *)v148;
        while (1)
        {
          double v151 = *((double *)v150 + 2);
          double v152 = *((double *)v149 + 2);
          if (v151 - v152 > 0.001) {
            goto LABEL_320;
          }
          double v153 = *v1000;
          double v154 = *((double *)v149 + 1);
          double v155 = fabs(*v1000);
          double v156 = fabs(v154);
          double v157 = fabs(v151);
          double v158 = fabs(v152);
          if (v155 >= v156) {
            double v156 = v155;
          }
          if (v156 < v157) {
            double v156 = v157;
          }
          if (v156 < v158) {
            double v156 = v158;
          }
          double v159 = v156 >= 1.0 ? v156 * 1000.0 : 1000.0;
          if (v153 == v154
            || ((*(void *)&v153 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
              ? (BOOL v176 = (*(void *)&v154 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              : (BOOL v176 = 0),
                v176 && vabdd_f64(v153, v154) <= v159 * 2.22044605e-16))
          {
            if (v151 == v152
              || (*(void *)&v151 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
              && (*(void *)&v152 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
              && fabs(v151 - v152) <= v159 * 2.22044605e-16)
            {
              break;
            }
          }
LABEL_316:
          v149 += 24;
          if (v149 == v132) {
            goto LABEL_320;
          }
        }
        int64x2_t v161 = v1009[0];
        long long v160 = v1009[1];
        if (v1009[0] != v1009[1])
        {
          unint64_t v162 = 0;
          uint64_t v163 = (double *)v1009[0];
          do
          {
            double v165 = v163[4];
            double v164 = v163[5];
            double v166 = fabs(v165);
            double v167 = fabs(v164);
            if (v166 < v155) {
              double v166 = v155;
            }
            if (v166 < v167) {
              double v166 = v167;
            }
            if (v166 < v157) {
              double v166 = v157;
            }
            double v168 = v166 >= 1.0 ? v166 * 1000.0 : 1000.0;
            if (v165 == v153
              || ((*(void *)&v165 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                ? (BOOL v170 = 1)
                : (BOOL v170 = (*(void *)&v153 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL),
                  !v170 && vabdd_f64(v165, v153) <= v168 * 2.22044605e-16))
            {
              if (v164 == v151) {
                goto LABEL_315;
              }
              BOOL v169 = (*(void *)&v164 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                  || (*(void *)&v151 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL;
              if (!v169 && vabdd_f64(v164, v151) <= v168 * 2.22044605e-16) {
                goto LABEL_315;
              }
            }
            ++v162;
            v163 += 6;
          }
          while (v163 != v1009[1]);
        }
        v1027.i64[1] = 0;
        int64x2_t v1028 = 0uLL;
        v1027.i64[0] = (uint64_t)&v1027.i64[1];
        sub_101249EFC((uint64_t)v1039, &v1027);
        uint64_t v171 = v1028.i64[1];
        v1039[3] = (void *)v1028.i64[1];
        *(_OWORD *)&v1039[4] = *(_OWORD *)v1000;
        float64x2_t v172 = (void **)v1009[1];
        if (v1009[1] < (void *)v1010)
        {
          *(void *)v1009[1] = v1039[0];
          double v173 = v1039[1];
          v172[1] = v1039[1];
          double v174 = (char *)(v172 + 1);
          uint64_t v175 = v1039[2];
          v172[2] = v1039[2];
          if (v175)
          {
            v173[2] = v174;
            v1039[0] = &v1039[1];
            v1039[1] = 0;
            v1039[2] = 0;
          }
          else
          {
            double *v172 = v174;
          }
          v172[3] = v1039[3];
          *((_OWORD *)v172 + 2) = *(_OWORD *)&v1039[4];
          v182 = v172 + 6;
          goto LABEL_314;
        }
        double v177 = (void **)v1009[0];
        unint64_t v178 = 0xAAAAAAAAAAAAAAABLL * (((char *)v1009[1] - (char *)v1009[0]) >> 4);
        unint64_t v179 = v178 + 1;
        if (v178 + 1 > 0x555555555555555) {
          sub_10006A748();
        }
        if (0x5555555555555556 * ((uint64_t)(v1010 - (unint64_t)v1009[0]) >> 4) > v179) {
          unint64_t v179 = 0x5555555555555556 * ((uint64_t)(v1010 - (unint64_t)v1009[0]) >> 4);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v1010 - (unint64_t)v1009[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v180 = 0x555555555555555;
        }
        else {
          unint64_t v180 = v179;
        }
        if (v180)
        {
          if (v180 > 0x555555555555555) {
            sub_10006A7CC();
          }
          double v181 = operator new(48 * v180);
        }
        else
        {
          double v181 = 0;
        }
        double v183 = (char *)&v181[3 * v178];
        double v184 = v1039[1];
        *(void **)double v183 = v1039[0];
        *((void *)v183 + 1) = v184;
        double v185 = v183 + 8;
        double v186 = v1039[2];
        *((void **)v183 + 2) = v1039[2];
        if (v186)
        {
          v184[2] = v185;
          v1039[0] = &v1039[1];
          v1039[1] = 0;
          v1039[2] = 0;
        }
        else
        {
          *(void *)double v183 = v185;
        }
        *((void *)v183 + 3) = v171;
        v181[3 * v178 + 2] = *(_OWORD *)&v1039[4];
        v182 = v183 + 48;
        if (v172 == v177)
        {
          v1009[0] = &v181[3 * v178];
          v1009[1] = v183 + 48;
          *(void *)&long long v1010 = &v181[3 * v180];
          if (!v172) {
            goto LABEL_314;
          }
        }
        else
        {
          uint64_t v187 = 0;
          do
          {
            double v188 = &v183[v187 * 8];
            *((void *)v188 - 6) = v172[v187 - 6];
            double v189 = &v172[v187 - 5];
            double v190 = *v189;
            *(void *)&v183[v187 * 8 - 40] = *v189;
            uint64_t v191 = (uint64_t)&v183[v187 * 8 - 40];
            double v192 = v172[v187 - 4];
            *((void *)v188 - 4) = v192;
            if (v192)
            {
              v190[2] = v191;
              v172[v187 - 6] = v189;
              *double v189 = 0;
              v172[v187 - 4] = 0;
            }
            else
            {
              *((void *)v188 - 6) = v191;
            }
            int64_t v193 = &v183[v187 * 8];
            *((void *)v193 - 3) = v172[v187 - 3];
            *((_OWORD *)v193 - 1) = *(_OWORD *)&v172[v187 - 2];
            v187 -= 6;
          }
          while (&v172[v187] != v177);
          float64x2_t v172 = (void **)v1009[0];
          int64_t v194 = (void **)v1009[1];
          v1009[0] = &v183[v187 * 8];
          v1009[1] = v183 + 48;
          *(void *)&long long v1010 = &v181[3 * v180];
          if (v194 != v172)
          {
            do
            {
              int64_t v195 = v194 - 6;
              sub_10005D144(*(v194 - 5));
              int64_t v194 = v195;
            }
            while (v195 != v172);
          }
          if (!v172) {
            goto LABEL_314;
          }
        }
        operator delete(v172);
LABEL_314:
        unint64_t v162 = 0xAAAAAAAAAAAAAAABLL * ((v160 - v161) >> 4);
        v1009[1] = v182;
        sub_10005D144((void *)v1039[1]);
        sub_10005D144((void *)v1027.i64[1]);
        int64x2_t v161 = v1009[0];
LABEL_315:
        double v150 = v989;
        sub_10124A07C((uint64_t *)&v161[48 * v162], *v989, *v989);
        sub_10124A07C((uint64_t *)v1009[0] + 6 * v162, *(void *)v149, *(void *)v149);
        goto LABEL_316;
      }
LABEL_320:
      double v148 = v983;
    }
    while (v983 != v132);
    uint64_t v196 = v1009[0];
    uint64_t j = v1009[1];
    if (v1009[0] == v1009[1]) {
      goto LABEL_381;
    }
    uint64_t v198 = 1;
    v996 = v1009[1];
    while (2)
    {
      double v199 = v1015;
      double v200 = &v1015;
LABEL_324:
      double v201 = v200;
      if (!v199) {
        goto LABEL_331;
      }
      do
      {
        double v200 = (uint64_t **)v199;
        uint64_t v202 = v199[4];
        if (v202 > v198)
        {
          double v199 = *v200;
          goto LABEL_324;
        }
        if (v202 >= v198)
        {
          uint64_t v203 = v200;
          goto LABEL_334;
        }
        double v199 = v200[1];
      }
      while (v199);
      double v201 = v200 + 1;
LABEL_331:
      uint64_t v203 = operator new(0x48uLL);
      v203[7] = 0;
      v203[8] = 0;
      v203[6] = 0;
      v203[4] = v198;
      v203[5] = v203 + 6;
      *uint64_t v203 = 0;
      v203[1] = 0;
      v203[2] = v200;
      *double v201 = v203;
      v204 = v203;
      if (*v1014)
      {
        v1014 = (uint64_t **)*v1014;
        v204 = *v201;
      }
      sub_100046C90(v1015, v204);
      ++v1016;
LABEL_334:
      double v205 = (uint64_t **)(v203 + 5);
      if (v203 + 5 != v196)
      {
        double v207 = v196 + 1;
        double v206 = (void *)*v196;
        if (!v203[7]) {
          goto LABEL_358;
        }
        long long v209 = (uint64_t **)(v203 + 6);
        uint64_t v208 = v203[6];
        uint64_t v210 = v203[5];
        v203[5] = v203 + 6;
        *(void *)(v208 + 16) = 0;
        v203[6] = 0;
        v203[7] = 0;
        double v211 = *(void *)(v210 + 8) ? *(uint64_t **)(v210 + 8) : (uint64_t *)v210;
        if (v211)
        {
          v1001 = v203;
          double v212 = sub_1000EA590((uint64_t)v211);
          if (v206 == v207)
          {
            v213 = v211;
            double v219 = v206;
          }
          else
          {
            do
            {
              v213 = v212;
              uint64_t v214 = v206[4];
              v211[4] = v214;
              uint64_t v215 = *v209;
              double v216 = v209;
              double v217 = v209;
              if (*v209)
              {
                do
                {
                  while (1)
                  {
                    double v216 = (uint64_t **)v215;
                    if (v214 >= v215[4]) {
                      break;
                    }
                    uint64_t v215 = (uint64_t *)*v215;
                    double v217 = v216;
                    if (!*v216) {
                      goto LABEL_347;
                    }
                  }
                  uint64_t v215 = (uint64_t *)v215[1];
                }
                while (v215);
                double v217 = v216 + 1;
              }
LABEL_347:
              sub_100046C38(v205, (uint64_t)v216, v217, v211);
              if (v212) {
                double v212 = sub_1000EA590((uint64_t)v212);
              }
              else {
                double v212 = 0;
              }
              double v218 = (void *)v206[1];
              if (v218)
              {
                do
                {
                  double v219 = v218;
                  double v218 = (void *)*v218;
                }
                while (v218);
              }
              else
              {
                do
                {
                  double v219 = (void *)v206[2];
                  _ZF = *v219 == (void)v206;
                  double v206 = v219;
                }
                while (!_ZF);
              }
              if (!v213) {
                break;
              }
              double v211 = v213;
              double v206 = v219;
            }
            while (v219 != v207);
          }
          sub_10005D144(v213);
          if (v212)
          {
            v220 = (uint64_t *)v212[2];
            for (uint64_t j = v996; v220; v220 = (uint64_t *)v220[2])
              double v212 = v220;
            sub_10005D144(v212);
          }
          else
          {
            uint64_t j = v996;
          }
          uint64_t v203 = v1001;
        }
        else
        {
LABEL_358:
          double v219 = v206;
        }
        if (v219 != v207)
        {
          v221 = (uint64_t **)(v203 + 6);
          do
          {
            uint64_t v222 = v219[4];
            double v223 = (uint64_t *)operator new(0x28uLL);
            v223[4] = v222;
            v224 = *v221;
            v225 = (uint64_t **)(v203 + 6);
            double v226 = (uint64_t **)(v203 + 6);
            if (*v221)
            {
              do
              {
                while (1)
                {
                  v225 = (uint64_t **)v224;
                  if (v224[4] <= v222) {
                    break;
                  }
                  v224 = (uint64_t *)*v224;
                  double v226 = v225;
                  if (!*v225) {
                    goto LABEL_374;
                  }
                }
                v224 = (uint64_t *)v224[1];
              }
              while (v224);
              double v226 = v225 + 1;
            }
LABEL_374:
            sub_100046C38(v205, (uint64_t)v225, v226, v223);
            double v227 = (void *)v219[1];
            if (v227)
            {
              do
              {
                double v228 = v227;
                double v227 = (void *)*v227;
              }
              while (v227);
            }
            else
            {
              do
              {
                double v228 = (void *)v219[2];
                _ZF = *v228 == (void)v219;
                double v219 = v228;
              }
              while (!_ZF);
            }
            double v219 = v228;
          }
          while (v228 != v207);
        }
      }
      ++v198;
      v203[8] = v196[3];
      v196 += 6;
      if (v196 != j) {
        continue;
      }
      break;
    }
LABEL_381:
    v1039[0] = v1009;
    sub_10124A128((void ***)v1039);
    if (v975) {
      operator delete(v975);
    }
    uint64_t v229 = v1016;
    if (v1016)
    {
      uint64_t v230 = v1020;
      uint64_t v231 = *((void *)&v1018 + 1);
      if ((void)v1019 != *((void *)&v1018 + 1))
      {
        v232 = (uint64_t *)(*((void *)&v1018 + 1) + 8 * ((unint64_t)v1020 >> 4));
        uint64_t v233 = *v232;
        uint64_t v234 = *v232 + 376 * (v1020 & 0xF);
        uint64_t v235 = *(void *)(*((void *)&v1018 + 1)
                         + (((*((void *)&v1020 + 1) + (void)v1020) >> 1) & 0x7FFFFFFFFFFFFFF8))
             + 376 * ((DWORD2(v1020) + v1020) & 0xF);
        while (v234 != v235)
        {
          *(void *)(v234 + 24) = -1;
          v234 += 376;
          if (v234 - v233 == 6016)
          {
            uint64_t v236 = v232[1];
            ++v232;
            uint64_t v233 = v236;
            uint64_t v234 = v236;
          }
        }
      }
      double v237 = (uint64_t *)v1014;
      if (v1014 != &v1015)
      {
        double v238 = (uint64_t *)v1014;
        do
        {
          double v239 = (uint64_t *)v238[5];
          if (v239 != v238 + 6)
          {
            uint64_t v240 = v238[4];
            do
            {
              *(void *)(*(void *)(v231 + (((unint64_t)(v239[4] + v230) >> 1) & 0x7FFFFFFFFFFFFFF8))
                        + 376 * ((*((_DWORD *)v239 + 8) + v230) & 0xF)
                        + 24) = v240;
              double v241 = (uint64_t *)v239[1];
              if (v241)
              {
                do
                {
                  double v242 = v241;
                  double v241 = (uint64_t *)*v241;
                }
                while (v241);
              }
              else
              {
                do
                {
                  double v242 = (uint64_t *)v239[2];
                  _ZF = *v242 == (void)v239;
                  double v239 = v242;
                }
                while (!_ZF);
              }
              double v239 = v242;
            }
            while (v242 != v238 + 6);
          }
          double v243 = (uint64_t *)v238[1];
          if (v243)
          {
            do
            {
              double v244 = (uint64_t **)v243;
              double v243 = (uint64_t *)*v243;
            }
            while (v243);
          }
          else
          {
            do
            {
              double v244 = (uint64_t **)v238[2];
              _ZF = *v244 == v238;
              double v238 = (uint64_t *)v244;
            }
            while (!_ZF);
          }
          double v238 = (uint64_t *)v244;
        }
        while (v244 != &v1015);
        uint64_t v245 = v1020;
        uint64_t v246 = *((void *)&v1018 + 1);
        double v247 = v237;
        do
        {
          double v248 = (uint64_t *)v247[5];
          double v249 = v247 + 6;
          if (v248 != v247 + 6)
          {
            double v250 = (uint64_t *)v247[5];
            while (1)
            {
              uint64_t v251 = *(void *)(v246 + (((unint64_t)(v250[4] + v245) >> 1) & 0x7FFFFFFFFFFFFFF8))
                   + 376 * ((*((_DWORD *)v250 + 8) + v245) & 0xF);
              if (*(_DWORD *)(v251 + 40) == 2 && *(_DWORD *)(v251 + 208) == 2) {
                break;
              }
              double v252 = (uint64_t *)v250[1];
              if (v252)
              {
                do
                {
                  double v253 = v252;
                  double v252 = (uint64_t *)*v252;
                }
                while (v252);
              }
              else
              {
                do
                {
                  double v253 = (uint64_t *)v250[2];
                  _ZF = *v253 == (void)v250;
                  double v250 = v253;
                }
                while (!_ZF);
              }
              double v250 = v253;
              if (v253 == v249) {
                goto LABEL_423;
              }
            }
            do
            {
              *(unsigned char *)(*(void *)(v246 + (((unint64_t)(v248[4] + v245) >> 1) & 0x7FFFFFFFFFFFFFF8))
                       + 376 * ((*((_DWORD *)v248 + 8) + v245) & 0xF)
                       + 33) = 1;
              uint64_t v254 = (uint64_t *)v248[1];
              if (v254)
              {
                do
                {
                  uint64_t v255 = v254;
                  uint64_t v254 = (uint64_t *)*v254;
                }
                while (v254);
              }
              else
              {
                do
                {
                  uint64_t v255 = (uint64_t *)v248[2];
                  _ZF = *v255 == (void)v248;
                  double v248 = v255;
                }
                while (!_ZF);
              }
              double v248 = v255;
            }
            while (v255 != v249);
          }
LABEL_423:
          uint64_t v256 = (uint64_t *)v247[1];
          if (v256)
          {
            do
            {
              uint64_t v257 = (uint64_t **)v256;
              uint64_t v256 = (uint64_t *)*v256;
            }
            while (v256);
          }
          else
          {
            do
            {
              uint64_t v257 = (uint64_t **)v247[2];
              _ZF = *v257 == v247;
              double v247 = (uint64_t *)v257;
            }
            while (!_ZF);
          }
          double v247 = (uint64_t *)v257;
        }
        while (v257 != &v1015);
        v1039[2] = 0;
        v1039[1] = 0;
        v1039[0] = &v1039[1];
        while (2)
        {
          sub_10005D144((void *)v1039[1]);
          v258 = (uint64_t **)(v237 + 5);
          v259 = (uint64_t *)v237[5];
          v1039[2] = 0;
          v1039[0] = &v1039[1];
          v1039[1] = 0;
          uint64_t v260 = v237 + 6;
          if (v259 == v237 + 6) {
            goto LABEL_478;
          }
LABEL_431:
          uint64_t v261 = *(void *)(*((void *)&v1018 + 1)
                           + (((unint64_t)(v1020 + v259[4]) >> 1) & 0x7FFFFFFFFFFFFFF8))
               + 376 * ((v1020 + *((_DWORD *)v259 + 8)) & 0xF);
          int v262 = *(_DWORD *)(v261 + 40);
          if (v262 == 3)
          {
            if (*(_DWORD *)(v261 + 208) == 1) {
              goto LABEL_436;
            }
          }
          else
          {
            if (v262 != 1 || (*(_DWORD *)(v261 + 208) | 2) != 3) {
              goto LABEL_465;
            }
LABEL_436:
            double v263 = *v258;
            if (*v258 != v260)
            {
              do
              {
                uint64_t v264 = v263[4];
                if (v259[4] != v264)
                {
                  uint64_t v265 = *(void *)(v261 + 48);
                  uint64_t v266 = *(void *)(v261 + 216);
                  if (v265 != v266)
                  {
                    uint64_t v267 = *(void *)(*((void *)&v1018 + 1)
                                     + (((unint64_t)(v1020 + v264) >> 1) & 0x7FFFFFFFFFFFFFF8))
                         + 376 * ((v1020 + v264) & 0xF);
                    BOOL v268 = *(void *)(v261 + 56) == *(void *)(v267 + 56)
                        && *(void *)(v261 + 224) == *(void *)(v267 + 224);
                    if (v268
                      && (*(void *)(v261 + 64) & 0x8000000000000000) != 0
                      && (*(void *)(v267 + 64) & 0x8000000000000000) == 0
                      && *(void *)(v261 + 232) == *(void *)(v267 + 232))
                    {
                      *(unsigned char *)(v267 + 32) = 1;
                      *(void *)(v267 + 24) = -1;
                      sub_10124A07C((uint64_t *)v1039, v264, v264);
                      uint64_t v266 = *(void *)(v261 + 216);
                      uint64_t v265 = *(void *)(v261 + 48);
                    }
                    if (v266 != v265)
                    {
                      BOOL v271 = *(void *)(v261 + 224) == *(void *)(v267 + 224)
                          && *(void *)(v261 + 56) == *(void *)(v267 + 56);
                      if (v271
                        && (*(void *)(v261 + 232) & 0x8000000000000000) != 0
                        && (*(void *)(v267 + 232) & 0x8000000000000000) == 0
                        && *(void *)(v261 + 64) == *(void *)(v267 + 64))
                      {
                        uint64_t v272 = v263[4];
                        *(unsigned char *)(v267 + 32) = 1;
                        *(void *)(v267 + 24) = -1;
                        sub_10124A07C((uint64_t *)v1039, v272, v272);
                      }
                    }
                  }
                }
                double v269 = (uint64_t *)v263[1];
                if (v269)
                {
                  do
                  {
                    double v270 = v269;
                    double v269 = (uint64_t *)*v269;
                  }
                  while (v269);
                }
                else
                {
                  do
                  {
                    double v270 = (uint64_t *)v263[2];
                    _ZF = *v270 == (void)v263;
                    double v263 = v270;
                  }
                  while (!_ZF);
                }
                double v263 = v270;
              }
              while (v270 != v260);
            }
          }
LABEL_465:
          double v273 = (uint64_t *)v259[1];
          if (v273)
          {
            do
            {
              double v274 = v273;
              double v273 = (uint64_t *)*v273;
            }
            while (v273);
          }
          else
          {
            do
            {
              double v274 = (uint64_t *)v259[2];
              _ZF = *v274 == (void)v259;
              v259 = v274;
            }
            while (!_ZF);
          }
          v259 = v274;
          if (v274 == v260)
          {
            uint64_t v275 = (void **)v1039[0];
            if (v1039[0] != &v1039[1])
            {
              do
              {
                sub_10124A1B0((uint64_t)(v237 + 5), (uint64_t)v275[4]);
                unint64_t v276 = (void **)v275[1];
                if (v276)
                {
                  do
                  {
                    unint64_t v277 = v276;
                    unint64_t v276 = (void **)*v276;
                  }
                  while (v276);
                }
                else
                {
                  do
                  {
                    unint64_t v277 = (void **)v275[2];
                    _ZF = *v277 == v275;
                    uint64_t v275 = v277;
                  }
                  while (!_ZF);
                }
                uint64_t v275 = v277;
              }
              while (v277 != &v1039[1]);
            }
LABEL_478:
            v278 = (uint64_t *)v237[1];
            if (v278)
            {
              do
              {
                double v279 = (uint64_t **)v278;
                v278 = (uint64_t *)*v278;
              }
              while (v278);
            }
            else
            {
              do
              {
                double v279 = (uint64_t **)v237[2];
                _ZF = *v279 == v237;
                double v237 = (uint64_t *)v279;
              }
              while (!_ZF);
            }
            double v237 = (uint64_t *)v279;
            if (v279 == &v1015)
            {
              double v280 = v1039[1];
              goto LABEL_486;
            }
            continue;
          }
          goto LABEL_431;
        }
      }
      double v280 = 0;
      v1039[2] = 0;
      v1039[1] = 0;
      v1039[0] = &v1039[1];
LABEL_486:
      sub_10005D144(v280);
    }
    uint64_t v281 = v1020;
    uint64_t v283 = *((void *)&v1018 + 1);
    uint64_t v282 = v1019;
    v284 = (void *)(*((void *)&v1018 + 1) + 8 * ((unint64_t)v1020 >> 4));
    if ((void)v1019 == *((void *)&v1018 + 1)) {
      uint64_t v285 = 0;
    }
    else {
      uint64_t v285 = *v284 + 376 * (v1020 & 0xF);
    }
    char v286 = 0;
    while (2)
    {
      uint64_t v287 = v285 - 6016;
LABEL_492:
      if (v282 == v283) {
        uint64_t v288 = 0;
      }
      else {
        uint64_t v288 = *(void *)(v283 + (((unint64_t)(*((void *)&v1020 + 1) + v281) >> 1) & 0x7FFFFFFFFFFFFFF8))
      }
             + 376 * ((DWORD2(v1020) + v281) & 0xF);
      if (v285 != v288)
      {
        int v289 = *(_DWORD *)(v285 + 40);
        if (v289 == 3)
        {
          if (*(_DWORD *)(v285 + 208) == 3) {
            goto LABEL_513;
          }
        }
        else if (v289 == 1)
        {
          if (*(_DWORD *)(v285 + 208) == 1) {
            goto LABEL_513;
          }
        }
        else if (!v289 && !*(_DWORD *)(v285 + 208))
        {
LABEL_513:
          *(unsigned char *)(v285 + 32) = 1;
          *(void *)(v285 + 24) = -1;
          goto LABEL_516;
        }
        if (*(void *)(v285 + 48) == *(void *)(v285 + 216) && *(uint64_t *)(v285 + 24) <= 0)
        {
          if (v289 != 2 || *(_DWORD *)(v285 + 208) != 2) {
            goto LABEL_513;
          }
          char v290 = *(unsigned char *)(v285 + 32);
          if (!v290) {
            goto LABEL_515;
          }
        }
        else
        {
          if (*(unsigned char *)(v285 + 32)) {
            goto LABEL_516;
          }
          char v290 = v289 == 4 && *(_DWORD *)(v285 + 208) == 4;
LABEL_515:
          v286 |= v290;
        }
LABEL_516:
        v287 += 376;
        v285 += 376;
        if (*v284 == v287)
        {
          uint64_t v291 = v284[1];
          ++v284;
          uint64_t v285 = v291;
          continue;
        }
        goto LABEL_492;
      }
      break;
    }
    char v979 = v286;
    v292 = (uint64_t *)v1014;
    if (v1014 != &v1015)
    {
      do
      {
        double v293 = v1015;
        if (v292[7]) {
          BOOL v294 = v1015 == 0;
        }
        else {
          BOOL v294 = 1;
        }
        if (!v294)
        {
          uint64_t v295 = v292[4];
          double v296 = &v1015;
          do
          {
            double v297 = v293;
            double v298 = v296;
            uint64_t v299 = v293[4];
            double v300 = (uint64_t **)(v293 + 1);
            if (v299 >= v295)
            {
              double v300 = (uint64_t **)v297;
              double v296 = (uint64_t **)v297;
            }
            double v293 = *v300;
          }
          while (v293);
          if (v296 != &v1015)
          {
            double v301 = v299 >= v295 ? v297 : (uint64_t *)v298;
            if (v301[4] <= v295)
            {
              BOOL v302 = v299 < v295;
              if (v299 >= v295) {
                double v303 = v297;
              }
              else {
                double v303 = v298;
              }
              double v304 = (uint64_t *)v303[5];
              double v305 = v297 + 6;
              if (v302) {
                double v306 = (uint64_t *)(v298 + 6);
              }
              else {
                double v306 = v305;
              }
              if (v304 == v306)
              {
LABEL_546:
                unint64_t v310 = *(void *)(v292[5] + 32) + v1020;
                uint64_t v311 = *(void *)(*((void *)&v1018 + 1) + ((v310 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * (v310 & 0xF);
                if (*(void *)(v311 + 48)) {
                  uint64_t v312 = v1005;
                }
                else {
                  uint64_t v312 = *((void *)&v1005 + 1);
                }
                if ((int)sub_10124A234((double *)v311, v312) <= 0)
                {
                  v313 = (uint64_t *)v292[5];
                  if (v313 != v292 + 6)
                  {
                    uint64_t v314 = v1020;
                    uint64_t v315 = *((void *)&v1018 + 1);
                    do
                    {
                      *(unsigned char *)(*(void *)(v315 + (((unint64_t)(v313[4] + v314) >> 1) & 0x7FFFFFFFFFFFFFF8))
                               + 376 * ((*((_DWORD *)v313 + 8) + v314) & 0xF)
                               + 32) = 1;
                      v316 = (uint64_t *)v313[1];
                      if (v316)
                      {
                        do
                        {
                          double v317 = v316;
                          v316 = (uint64_t *)*v316;
                        }
                        while (v316);
                      }
                      else
                      {
                        do
                        {
                          double v317 = (uint64_t *)v313[2];
                          _ZF = *v317 == (void)v313;
                          v313 = v317;
                        }
                        while (!_ZF);
                      }
                      v313 = v317;
                    }
                    while (v317 != v292 + 6);
                  }
                }
              }
              else
              {
                while (1)
                {
                  uint64_t v307 = *(void *)(*((void *)&v1018 + 1)
                                   + (((unint64_t)(v304[4] + v1020) >> 1) & 0x7FFFFFFFFFFFFFF8))
                       + 376 * ((*((_DWORD *)v304 + 8) + v1020) & 0xF);
                  if (*(void *)(v307 + 48) != *(void *)(v307 + 216)) {
                    break;
                  }
                  double v308 = (uint64_t *)v304[1];
                  if (v308)
                  {
                    do
                    {
                      double v309 = v308;
                      double v308 = (uint64_t *)*v308;
                    }
                    while (v308);
                  }
                  else
                  {
                    do
                    {
                      double v309 = (uint64_t *)v304[2];
                      _ZF = *v309 == (void)v304;
                      double v304 = v309;
                    }
                    while (!_ZF);
                  }
                  double v304 = v309;
                  if (v309 == v306) {
                    goto LABEL_546;
                  }
                }
              }
            }
          }
        }
        double v318 = (uint64_t *)v292[1];
        if (v318)
        {
          do
          {
            double v319 = (uint64_t **)v318;
            double v318 = (uint64_t *)*v318;
          }
          while (v318);
        }
        else
        {
          do
          {
            double v319 = (uint64_t **)v292[2];
            _ZF = *v319 == v292;
            v292 = (uint64_t *)v319;
          }
          while (!_ZF);
        }
        v292 = (uint64_t *)v319;
      }
      while (v319 != &v1015);
      uint64_t v283 = *((void *)&v1018 + 1);
      uint64_t v282 = v1019;
    }
    double v320 = (void *)(v283 + 8 * ((unint64_t)v1020 >> 4));
    uint64_t v984 = v229;
    if (v282 == v283) {
      uint64_t v321 = 0;
    }
    else {
      uint64_t v321 = *v320 + 376 * (v1020 & 0xF);
    }
    while (2)
    {
      if (v282 == v283)
      {
        if (!v321)
        {
          uint64_t v326 = 0;
          v1027.i64[1] = 0;
          v1028.i64[0] = 0;
          v1027.i64[0] = (uint64_t)&v1027.i64[1];
          double v325 = (void *)(v282 + 8 * ((unint64_t)v1020 >> 4));
          uint64_t v283 = v282;
          goto LABEL_583;
        }
      }
      else if (v321 == *(void *)(v283 + (((*((void *)&v1020 + 1) + (void)v1020) >> 1) & 0x7FFFFFFFFFFFFFF8)) {
                      + 376 * ((DWORD2(v1020) + v1020) & 0xF))
      }
      {
        v1027.i64[1] = 0;
        v1028.i64[0] = 0;
        v1027.i64[0] = (uint64_t)&v1027.i64[1];
        double v325 = (void *)(v283 + 8 * ((unint64_t)v1020 >> 4));
        uint64_t v326 = *v325 + 376 * (v1020 & 0xF);
LABEL_583:
        for (uint64_t k = 0; ; ++k)
        {
          v986 = v325;
          uint64_t v327 = v282 == v283
               ? 0
               : *(void *)(v283 + (((*((void *)&v1020 + 1) + (void)v1020) >> 1) & 0x7FFFFFFFFFFFFFF8))
               + 376 * ((DWORD2(v1020) + v1020) & 0xF);
          if (v326 == v327) {
            break;
          }
          uint64_t v990 = v326;
          if (!*(unsigned char *)(v326 + 32))
          {
            uint64_t v328 = 0;
            uint64_t v329 = v326 + 40;
            double v330 = (void *)(v326 + 376);
            double v331 = (void *)(v326 + 40);
            while (1)
            {
              uint64_t v332 = v331[1];
              uint64_t v333 = v331[2];
              uint64_t v334 = v331[3];
              double v335 = (uint64_t **)&v1027.i64[1];
              double v336 = (uint64_t **)&v1027.i64[1];
              double v337 = (uint64_t *)v1027.i64[1];
              if (v1027.i64[1]) {
                break;
              }
LABEL_605:
              long long v341 = (uint64_t *)operator new(0x50uLL);
              v341[4] = v332;
              v341[5] = v333;
              v341[6] = v334;
              v341[7] = 0;
              v341[8] = 0;
              v341[9] = 0;
              *long long v341 = 0;
              v341[1] = 0;
              v341[2] = (uint64_t)v335;
              *double v336 = v341;
              long long v342 = v341;
              if (*(void *)v1027.i64[0])
              {
                v1027.i64[0] = *(void *)v1027.i64[0];
                long long v342 = *v336;
              }
              sub_100046C90((uint64_t *)v1027.i64[1], v342);
              ++v1028.i64[0];
LABEL_609:
              uint64_t v343 = v329 - 168 * v328 + 176;
              unint64_t v344 = v341[8];
              unint64_t v345 = v341[9];
              if (v344 >= v345)
              {
                uint64_t v347 = v341[7];
                unint64_t v348 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v344 - v347) >> 3);
                unint64_t v349 = v348 + 1;
                if (v348 + 1 > 0x666666666666666) {
                  sub_10006A748();
                }
                unint64_t v350 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v345 - v347) >> 3);
                if (2 * v350 > v349) {
                  unint64_t v349 = 2 * v350;
                }
                if (v350 >= 0x333333333333333) {
                  unint64_t v351 = 0x666666666666666;
                }
                else {
                  unint64_t v351 = v349;
                }
                if (v351)
                {
                  if (v351 > 0x666666666666666) {
                    sub_10006A7CC();
                  }
                  v352 = (char *)operator new(40 * v351);
                }
                else
                {
                  v352 = 0;
                }
                v353 = &v352[40 * v348];
                *(void *)v353 = k;
                *((void *)v353 + 1) = v328;
                v353[16] = 0;
                *((void *)v353 + 3) = v343;
                *((void *)v353 + 4) = v331;
                v355 = (char *)v341[7];
                v354 = (char *)v341[8];
                v356 = v353;
                if (v354 != v355)
                {
                  do
                  {
                    long long v357 = *(_OWORD *)(v354 - 40);
                    long long v358 = *(_OWORD *)(v354 - 24);
                    *((void *)v356 - 1) = *((void *)v354 - 1);
                    *(_OWORD *)(v356 - 24) = v358;
                    *(_OWORD *)(v356 - 40) = v357;
                    v356 -= 40;
                    v354 -= 40;
                  }
                  while (v354 != v355);
                  v354 = (char *)v341[7];
                }
                v359 = &v352[40 * v351];
                v346 = v353 + 40;
                v341[7] = (uint64_t)v356;
                v341[8] = (uint64_t)(v353 + 40);
                v341[9] = (uint64_t)v359;
                if (v354) {
                  operator delete(v354);
                }
              }
              else
              {
                *(void *)unint64_t v344 = k;
                *(void *)(v344 + 8) = v328;
                *(unsigned char *)(v344 + 16) = 0;
                v346 = (char *)(v344 + 40);
                *(void *)(v344 + 24) = v343;
                *(void *)(v344 + 32) = v331;
              }
              v341[8] = (uint64_t)v346;
              v331 += 21;
              ++v328;
              if (v331 == v330) {
                goto LABEL_627;
              }
            }
            while (1)
            {
              double v335 = (uint64_t **)v337;
              uint64_t v338 = v337[4];
              if (v332 == v338)
              {
                v339 = v335[5];
                if ((uint64_t *)v333 == v339)
                {
                  long long v340 = v335[6];
                  if (v334 < (uint64_t)v340) {
                    goto LABEL_600;
                  }
                  if ((uint64_t)v340 >= v334) {
                    goto LABEL_608;
                  }
                }
                else
                {
                  if (v333 < (uint64_t)v339)
                  {
LABEL_600:
                    double v337 = *v335;
                    double v336 = v335;
                    if (!*v335) {
                      goto LABEL_605;
                    }
                    continue;
                  }
                  if ((uint64_t)v339 >= v333)
                  {
LABEL_608:
                    long long v341 = (uint64_t *)v335;
                    goto LABEL_609;
                  }
                }
              }
              else
              {
                if (v332 < v338) {
                  goto LABEL_600;
                }
                if (v338 >= v332) {
                  goto LABEL_608;
                }
              }
              double v337 = v335[1];
              if (!v337)
              {
                double v336 = v335 + 1;
                goto LABEL_605;
              }
            }
          }
LABEL_627:
          uint64_t v326 = v990 + 376;
          double v325 = v986;
          if (v990 + 376 - *v986 == 6016)
          {
            double v325 = v986 + 1;
            uint64_t v326 = v986[1];
          }
          uint64_t v283 = *((void *)&v1018 + 1);
          uint64_t v282 = v1019;
        }
        v360 = (unint64_t *)v1027.i64[0];
        if ((unint64_t *)v1027.i64[0] != &v1027.u64[1])
        {
          do
          {
            unint64_t v361 = v360[7];
            v362 = (char *)v360[8];
            unint64_t v363 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v362[-v361] >> 3));
            v1039[0] = &v1018;
            *(_OWORD *)&v1039[1] = v1005;
            v1039[3] = a3;
            v1039[4] = v1009;
            if (v362 == (char *)v361) {
              uint64_t v364 = 0;
            }
            else {
              uint64_t v364 = v363;
            }
            sub_10124B898(v361, v362, (uint64_t)v1039, v364, 1);
            v365 = (unint64_t *)v360[1];
            if (v365)
            {
              do
              {
                v366 = v365;
                v365 = (unint64_t *)*v365;
              }
              while (v365);
            }
            else
            {
              do
              {
                v366 = (unint64_t *)v360[2];
                _ZF = *v366 == (void)v360;
                v360 = v366;
              }
              while (!_ZF);
            }
            v360 = v366;
          }
          while (v366 != &v1027.u64[1]);
        }
        if (v984)
        {
          v367 = (uint64_t *)v1014;
          if (v1014 != &v1015)
          {
            while (2)
            {
              *(_OWORD *)v1040 = 0u;
              memset(v1039, 0, sizeof(v1039));
              v1009[0] = 0;
              v1009[1] = 0;
              if (!v367[7]) {
                goto LABEL_744;
              }
              v368 = (uint64_t *)v367[5];
              v991 = v367;
              v369 = v367 + 6;
              if (v368 != v367 + 6)
              {
                char v370 = 1;
                do
                {
                  uint64_t v371 = v368[4];
                  v372 = (double *)(*(void *)(*((void *)&v1018 + 1)
                                              + (((unint64_t)(v1020 + v371) >> 1) & 0x7FFFFFFFFFFFFFF8))
                                  + 376 * ((v1020 + v371) & 0xF));
                  if (v370) {
                    *(_OWORD *)v1009 = *(_OWORD *)v372;
                  }
                  uint64_t v373 = 0;
                  char v374 = 1;
                  do
                  {
                    char v375 = v374;
                    sub_10124CF68((unint64_t *)v1039, v372, (int *)&v372[21 * v373 + 5], v371, v373, (uint64_t *)v1005, *((uint64_t **)&v1005 + 1), v370 & 1);
                    char v374 = 0;
                    char v370 = 0;
                    uint64_t v373 = 1;
                  }
                  while ((v375 & 1) != 0);
                  v376 = (uint64_t *)v368[1];
                  if (v376)
                  {
                    do
                    {
                      v377 = v376;
                      v376 = (uint64_t *)*v376;
                    }
                    while (v376);
                  }
                  else
                  {
                    do
                    {
                      v377 = (uint64_t *)v368[2];
                      _ZF = *v377 == (void)v368;
                      v368 = v377;
                    }
                    while (!_ZF);
                  }
                  char v370 = 0;
                  v368 = v377;
                }
                while (v377 != v369);
              }
              sub_10124CD34((uint64_t)v1039, (double *)v1009);
              LOWORD(__p[0]) = 0;
              v378 = v1039[1];
              v379 = (char *)v1039[0];
              if (v1039[1] == v1039[0])
              {
                v379 = (char *)v1039[1];
                v367 = v991;
              }
              else
              {
                unint64_t v380 = 0;
                do
                {
                  if (!*(_DWORD *)&v379[112 * v380 + 44])
                  {
                    v381 = &v379[112 * v380];
                    unint64_t v384 = *((void *)v381 + 9);
                    v382 = v381 + 72;
                    unint64_t v383 = v384;
                    if (v384 <= 1 && !*((unsigned char *)__p + v383))
                    {
                      unint64_t v385 = 0x6DB6DB6DB6DB6DB7 * ((v378 - v379) >> 4);
                      if (v380 + 1 < v385) {
                        unint64_t v386 = v380 + 1;
                      }
                      else {
                        unint64_t v386 = 0;
                      }
                      v1003 = v382;
                      while (*(void *)&v379[112 * v386 + 72] != v383)
                      {
                        if (v386 + 1 < v385) {
                          ++v386;
                        }
                        else {
                          unint64_t v386 = 0;
                        }
                      }
                      uint64_t v387 = *(void *)&v379[112 * v380 + 16];
                      char v388 = 1;
                      uint64_t v389 = v387;
                      while (1)
                      {
                        v390 = &v379[112 * v386];
                        uint64_t v392 = *((void *)v390 + 2);
                        v391 = (uint64_t *)(v390 + 16);
                        if (v392 != v389 && (v388 & 1) == 0)
                        {
                          sub_10124F5CC((uint64_t)v379, (uint64_t)v378, v387, v389 - 1, 1);
                          sub_10124F5CC((uint64_t)v1039[0], (uint64_t)v1039[1], v387 + 1, v389, 2);
                        }
                        if (v386 == v380) {
                          break;
                        }
                        int v393 = *(_DWORD *)&v379[112 * v386 + 44];
                        if (v393 == 1)
                        {
                          char v388 = 0;
                        }
                        else if (!v393)
                        {
                          uint64_t v387 = *v391;
                          char v388 = 1;
                        }
                        uint64_t v389 = *v391;
                        unint64_t v394 = v386 + 1;
                        v378 = v1039[1];
                        v379 = (char *)v1039[0];
                        while (1)
                        {
                          if (v394 < 0x6DB6DB6DB6DB6DB7 * (((char *)v1039[1] - (char *)v1039[0]) >> 4)) {
                            ++v386;
                          }
                          else {
                            unint64_t v386 = 0;
                          }
                          if (*((void *)v1039[0] + 14 * v386 + 9) == v383) {
                            break;
                          }
                          unint64_t v394 = v386 + 1;
                        }
                      }
                      *((unsigned char *)__p + *v1003) = 1;
                      v378 = v1039[1];
                      v379 = (char *)v1039[0];
                    }
                  }
                  ++v380;
                  unint64_t v395 = (v378 - v379) / 112;
                }
                while (v380 < v395);
                v367 = v991;
                if (v378 != v379)
                {
                  uint64_t v396 = 0;
                  uint64_t v397 = 0;
                  uint64_t v398 = 0;
                  unint64_t v399 = v395 + 1;
                  if (v395 <= 1) {
                    uint64_t v400 = 1;
                  }
                  else {
                    uint64_t v400 = (v378 - v379) / 112;
                  }
                  v401 = v379 + 44;
                  v402 = v379 + 44;
                  do
                  {
                    uint64_t v403 = *(void *)(v402 - 28);
                    if (v403 > v397) {
                      uint64_t v397 = *(void *)(v402 - 28);
                    }
                    if (*(_DWORD *)v402 == 1 && *(void *)(v402 + 12) > 1uLL && *(void *)(v402 + 4) < 2uLL) {
                      unint64_t v399 = v403 + 1;
                    }
                    if (v398) {
                      BOOL v405 = 0;
                    }
                    else {
                      BOOL v405 = v403 == v399;
                    }
                    if (v405) {
                      uint64_t v398 = v396;
                    }
                    ++v396;
                    v402 += 112;
                  }
                  while (v400 != v396);
                  uint64_t v406 = 0;
                  uint64_t v407 = 0;
                  uint64_t v408 = v400;
                  uint64_t v409 = v397 + 1;
                  do
                  {
                    if (v398 + 1 == v395) {
                      uint64_t v410 = 0;
                    }
                    else {
                      uint64_t v410 = v398 + 1;
                    }
                    uint64_t v411 = *(void *)&v379[112 * v398 + 16];
                    if (v411 == v406)
                    {
                      uint64_t v411 = v406;
                    }
                    else
                    {
                      if (v411 == v409)
                      {
                        ++v407;
                        uint64_t v409 = v397 + 1;
                      }
                      if (*(_DWORD *)&v379[112 * v398 + 44] == 1)
                      {
                        v412 = &v379[112 * v398];
                        unint64_t v414 = *((void *)v412 + 6);
                        unint64_t v413 = *((void *)v412 + 7);
                        uint64_t v415 = v411 < v397 ? v411 + 1 : 0;
                        if (v414 <= 1 && v413 >= 2) {
                          uint64_t v409 = v415;
                        }
                      }
                    }
                    *(void *)&v379[112 * v398 + 24] = v407;
                    uint64_t v398 = v410;
                    uint64_t v406 = v411;
                    --v408;
                  }
                  while (v408);
                  uint64_t v417 = 0;
                  uint64_t v418 = 0;
                  uint64_t v419 = v400;
                  do
                  {
                    if (*(void *)(v401 - 28) > v417 && *(_DWORD *)v401 == 1)
                    {
                      v418 += (*(void *)(v401 + 4) < 2uLL) & (*(void *)(v401 + 12) > 1uLL);
                      if (*(void *)(v401 + 4) < 2uLL && *(void *)(v401 + 12) > 1uLL) {
                        uint64_t v417 = *(void *)(v401 - 28);
                      }
                    }
                    v401 += 112;
                    --v419;
                  }
                  while (v419);
                  v991[8] = v418;
                  v421 = v379 + 56;
                  uint64_t v422 = v1020;
                  uint64_t v423 = *((void *)&v1018 + 1);
                  do
                  {
                    unsigned int v424 = *((_DWORD *)v421 - 4);
                    if (v424 >= 2) {
                      __assert_rtn("operator[]", "array.hpp", 117, "(i < N)&&(\"out of range\")");
                    }
                    if (*((_DWORD *)v421 - 3) == 1)
                    {
                      uint64_t v425 = *(void *)(v423 + (((unint64_t)(*(v421 - 3) + v422) >> 1) & 0x7FFFFFFFFFFFFFF8))
                           + 376 * ((*((_DWORD *)v421 - 6) + v422) & 0xF);
                      uint64_t v426 = v425 + 40 + 168 * v424;
                      *(_OWORD *)(v426 + 112) = *(_OWORD *)(v421 - 1);
                      *(_OWORD *)(v426 + 128) = *(_OWORD *)(v421 - 5);
                      if (*(void *)(v425 + 48) != *(void *)(v425 + 216) && *v421 != 2) {
                        *(unsigned char *)(v425 + 40 + 168 * v424 + 104) = 0;
                      }
                    }
                    v421 += 14;
                    --v400;
                  }
                  while (v400);
LABEL_743:
                  v1039[1] = v379;
                  operator delete(v379);
LABEL_744:
                  v427 = (uint64_t *)v367[1];
                  if (v427)
                  {
                    do
                    {
                      v428 = (uint64_t **)v427;
                      v427 = (uint64_t *)*v427;
                    }
                    while (v427);
                  }
                  else
                  {
                    do
                    {
                      v428 = (uint64_t **)v367[2];
                      _ZF = *v428 == v367;
                      v367 = (uint64_t *)v428;
                    }
                    while (!_ZF);
                  }
                  v367 = (uint64_t *)v428;
                  if (v428 == &v1015)
                  {
                    v429 = v1014;
                    if (v1014 != &v1015)
                    {
                      do
                      {
                        v430 = v429[5];
                        if (v430 != (uint64_t *)(v429 + 6))
                        {
                          do
                          {
                            v431 = (uint64_t *)v430[1];
                            v432 = v430;
                            if (v431)
                            {
                              do
                              {
                                v433 = v431;
                                v431 = (uint64_t *)*v431;
                              }
                              while (v431);
                            }
                            else
                            {
                              do
                              {
                                v433 = (uint64_t *)v432[2];
                                _ZF = *v433 == (void)v432;
                                v432 = v433;
                              }
                              while (!_ZF);
                            }
                            if (*(unsigned char *)(*(void *)(*((void *)&v1018 + 1)
                                                      + (((unint64_t)(v1020 + v430[4]) >> 1) & 0x7FFFFFFFFFFFFFF8))
                                          + 376 * ((v1020 + *((_DWORD *)v430 + 8)) & 0xF)
                                          + 32))
                            {
                              sub_1000F5B04(v429 + 5, v430);
                              operator delete(v430);
                            }
                            v430 = v433;
                          }
                          while (v433 != (uint64_t *)(v429 + 6));
                        }
                        v434 = v429[1];
                        if (v434)
                        {
                          do
                          {
                            v435 = (uint64_t **)v434;
                            v434 = (uint64_t *)*v434;
                          }
                          while (v434);
                        }
                        else
                        {
                          do
                          {
                            v435 = (uint64_t **)v429[2];
                            _ZF = *v435 == (uint64_t *)v429;
                            v429 = v435;
                          }
                          while (!_ZF);
                        }
                        v429 = v435;
                      }
                      while (v435 != &v1015);
                      v436 = v1014;
                      if (v1014 != &v1015)
                      {
                        do
                        {
                          v437 = v436[1];
                          v438 = v437;
                          v439 = v436;
                          if (v437)
                          {
                            do
                            {
                              v440 = (uint64_t **)v438;
                              v438 = (uint64_t *)*v438;
                            }
                            while (v438);
                          }
                          else
                          {
                            do
                            {
                              v440 = (uint64_t **)v439[2];
                              _ZF = *v440 == (uint64_t *)v439;
                              v439 = v440;
                            }
                            while (!_ZF);
                          }
                          if (v436[7] == (uint64_t *)1)
                          {
                            unint64_t v441 = v1020 + v436[5][4];
                            *(void *)(*(void *)(*((void *)&v1018 + 1) + ((v441 >> 1) & 0x7FFFFFFFFFFFFFF8))
                                      + 376 * (v441 & 0xF)
                                      + 24) = -1;
                            v442 = v436;
                            if (v437)
                            {
                              do
                              {
                                v443 = (uint64_t **)v437;
                                v437 = (uint64_t *)*v437;
                              }
                              while (v437);
                            }
                            else
                            {
                              do
                              {
                                v443 = (uint64_t **)v442[2];
                                _ZF = *v443 == (uint64_t *)v442;
                                v442 = v443;
                              }
                              while (!_ZF);
                            }
                            if (v1014 == v436) {
                              v1014 = v443;
                            }
                            --v1016;
                            sub_10005EE6C(v1015, (uint64_t *)v436);
                            sub_10005D144(v436[6]);
                            operator delete(v436);
                          }
                          v436 = v440;
                        }
                        while (v440 != &v1015);
                      }
                    }
                    goto LABEL_782;
                  }
                  continue;
                }
                v378 = v379;
              }
              break;
            }
            v367[8] = 0;
            if (v378) {
              goto LABEL_743;
            }
            goto LABEL_744;
          }
        }
LABEL_782:
        v444 = (unint64_t *)v1027.i64[0];
        if ((unint64_t *)v1027.i64[0] == &v1027.u64[1]) {
          goto LABEL_840;
        }
        v445 = "(i < N)&&(\"out of range\")";
        v446 = "array.hpp";
LABEL_784:
        v447 = (char *)v444[7];
        v448 = (char *)v444[8];
        uint64_t v449 = v448 - v447;
        if (v448 == v447) {
          goto LABEL_834;
        }
        int64_t v450 = 0xCCCCCCCCCCCCCCCDLL * (v449 >> 3);
        if (v449 <= 40) {
          uint64_t v451 = 1 % v450;
        }
        else {
          uint64_t v451 = 1;
        }
        uint64_t v452 = *((void *)&v1018 + 1);
        uint64_t v453 = v1020;
        v454 = &v447[40 * v451];
        v455 = (char *)v444[7];
        while (2)
        {
          unint64_t v456 = *((void *)v455 + 1);
          if (v456 > 1)
          {
LABEL_843:
            int v489 = 117;
LABEL_1591:
            v962 = "operator[]";
            goto LABEL_1592;
          }
          uint64_t v457 = *(void *)v455;
          if (*(void *)v455 != *(void *)v454)
          {
            uint64_t v458 = v451;
            goto LABEL_797;
          }
          uint64_t v458 = v451 + 1;
          if (v451 <= -2)
          {
            do
              v458 += v450;
            while (v458 < 0);
          }
          else if (v458 < v450)
          {
            v454 += 40;
LABEL_797:
            uint64_t v459 = *(void *)(v452 + (((unint64_t)(v457 + v453) >> 1) & 0x7FFFFFFFFFFFFFF8))
                 + 376 * ((v457 + v453) & 0xF);
            uint64_t v460 = v459 + 40;
            uint64_t v461 = v459 + 40 + 168 * v456;
            uint64_t v462 = *(void *)(v459 + 24);
            if (v462 <= 0)
            {
              uint64_t v457 = *(void *)v454;
              goto LABEL_813;
            }
            while (1)
            {
              if (v457 == *(void *)v454) {
                goto LABEL_813;
              }
              uint64_t v463 = *(void *)(v452 + (((unint64_t)(*(void *)v454 + v453) >> 1) & 0x7FFFFFFFFFFFFFF8))
                   + 376 * ((*(void *)v454 + v453) & 0xF);
              if (v462 != *(void *)(v463 + 24)) {
                break;
              }
              unint64_t v464 = *((void *)v454 + 1);
              if (v464 > 1) {
                goto LABEL_843;
              }
              uint64_t v465 = v463 + 40;
              if (*(void *)(v461 + 8) != *(void *)(v465 + 168 * v464 + 8)
                || *(void *)(v461 + 32) != *(void *)(v465 + 168 * v464 + 32)
                || *(void *)(v461 + 24) != *(void *)(v465 + 168 * v464 + 24)
                || *(void *)(v461 + 40) != *(void *)(v465 + 168 * v464 + 40)
                || *(void *)(v461 + 16) != *(void *)(v465 + 168 * v464 + 16))
              {
                break;
              }
              uint64_t v466 = v458 + 1;
              if (v458 <= -2)
              {
                do
                  v466 += v450;
                while (v466 < 0);
              }
              else if (v466 < v450)
              {
                v454 += 40;
                ++v458;
                continue;
              }
              uint64_t v458 = v466 % v450;
              v454 = &v447[40 * (v466 % v450)];
            }
            uint64_t v457 = *(void *)v454;
LABEL_813:
            uint64_t v451 = v458;
            unint64_t v467 = *((void *)v454 + 1);
            if (v467 > 1)
            {
              int v489 = 122;
              goto LABEL_1591;
            }
            uint64_t v468 = *(void *)(v452 + (((unint64_t)(v457 + v453) >> 1) & 0x7FFFFFFFFFFFFFF8))
                 + 376 * ((v457 + v453) & 0xF)
                 + 168 * v467;
            unint64_t v469 = v460 + 168 * v456;
            *(void *)(v469 + 88) = v457;
            *(void *)(v469 + 80) = *(void *)(*((void *)v454 + 4) + 32);
            if (*(void *)(v461 + 32) != *(void *)(v468 + 72)) {
              goto LABEL_833;
            }
            v470 = (double *)(v468 + 40);
            double v471 = *(double *)(v461 + 64);
            double v472 = v470[8];
            if (vabdd_f64(v471, v472) >= 50.0)
            {
              if (v471 < v472) {
                goto LABEL_832;
              }
              goto LABEL_833;
            }
            double v473 = *(double *)(v461 + 56);
            if (v473 == 0.0)
            {
              int v489 = 56;
              v962 = "apply";
              v446 = "segment_ratio.hpp";
              v445 = "lhs.denominator() != Type(0)";
              goto LABEL_1592;
            }
            double v474 = v470[7];
            if (v474 == 0.0)
            {
              int v489 = 57;
              v962 = "apply";
              v446 = "segment_ratio.hpp";
              v445 = "rhs.denominator() != Type(0)";
LABEL_1592:
              __assert_rtn(v962, v446, v489, v445);
            }
            double v475 = *(double *)(v461 + 48) / v473;
            double v476 = v470[6] / v474;
            if (v475 != v476)
            {
              if ((*(void *)&v475 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                || (*(void *)&v476 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
              {
                BOOL v481 = 1;
              }
              else
              {
                double v477 = vabdd_f64(v475, v476);
                double v478 = fabs(v475);
                double v479 = fabs(v476);
                if (v478 < v479) {
                  double v478 = v479;
                }
                double v480 = v478 >= 1.0 ? v478 * 2.22044605e-16 : 2.22044605e-16;
                BOOL v481 = v477 > v480;
              }
              if (v475 < v476 && v481) {
LABEL_832:
              }
                *(void *)(v460 + 168 * v456 + 96) = v457;
            }
LABEL_833:
            v455 += 40;
            if (v455 != v448) {
              continue;
            }
LABEL_834:
            v482 = (unint64_t *)v444[1];
            if (v482)
            {
              do
              {
                v483 = v482;
                v482 = (unint64_t *)*v482;
              }
              while (v482);
            }
            else
            {
              do
              {
                v483 = (unint64_t *)v444[2];
                _ZF = *v483 == (void)v444;
                v444 = v483;
              }
              while (!_ZF);
            }
            v444 = v483;
            if (v483 != &v1027.u64[1]) {
              goto LABEL_784;
            }
LABEL_840:
            if (v979)
            {
              uint64_t v484 = v1020;
              uint64_t v485 = *((void *)&v1018 + 1);
              uint64_t v486 = v1019;
              v487 = (void *)(*((void *)&v1018 + 1) + 8 * ((unint64_t)v1020 >> 4));
              if ((void)v1019 == *((void *)&v1018 + 1)) {
                uint64_t v488 = 0;
              }
              else {
                uint64_t v488 = *v487 + 376 * (v1020 & 0xF);
              }
              uint64_t v490 = (*((void *)&v1020 + 1) + (void)v1020) >> 4;
              unsigned int v491 = (DWORD2(v1020) + v1020) & 0xF;
              while (1)
              {
                uint64_t v492 = v488 - 6016;
                do
                {
                  if (v486 == v485) {
                    uint64_t v493 = 0;
                  }
                  else {
                    uint64_t v493 = *(void *)(v485 + 8 * v490) + 376 * v491;
                  }
                  if (v488 == v493) {
                    goto LABEL_863;
                  }
                  if (*(double *)(v488 + 112) == 0.0 && *(double *)(v488 + 280) == 0.0)
                  {
                    uint64_t v494 = *(void *)(v488 + 136);
                    if (v494 == -1) {
                      uint64_t v494 = *(void *)(v488 + 128);
                    }
                    uint64_t v495 = *(void *)(v488 + 304);
                    if (v495 == -1) {
                      uint64_t v495 = *(void *)(v488 + 296);
                    }
                    if ((v494 & 0x8000000000000000) == 0 && (v495 & 0x8000000000000000) == 0 && v494 != v495)
                    {
                      v496 = (double *)(*(void *)(v485
                                                  + (((unint64_t)(v494 + v484) >> 1) & 0x7FFFFFFFFFFFFFF8))
                                      + 376 * ((v494 + v484) & 0xF));
                      double v497 = *(double *)v488;
                      double v498 = *(double *)(v488 + 8);
                      *(double *)(v488 + 112) = (v498 - v496[1]) * (v498 - v496[1])
                                              + (*(double *)v488 - *v496) * (*(double *)v488 - *v496);
                      v499 = (double *)(*(void *)(v485
                                                  + (((unint64_t)(v495 + v484) >> 1) & 0x7FFFFFFFFFFFFFF8))
                                      + 376 * ((v495 + v484) & 0xF));
                      *(double *)(v488 + 280) = (v498 - v499[1]) * (v498 - v499[1]) + (v497 - *v499) * (v497 - *v499);
                    }
                  }
                  v488 += 376;
                  v492 += 376;
                }
                while (*v487 != v492);
                uint64_t v500 = v487[1];
                ++v487;
                uint64_t v488 = v500;
              }
            }
LABEL_863:
            sub_10124F66C((void *)v1027.i64[1]);
            long long v1010 = 0u;
            long long v1011 = 0u;
            *(_OWORD *)v1009 = 0u;
            int64x2_t v1027 = (int64x2_t)v1005;
            v1028.i64[0] = (uint64_t)&v1018;
            v1028.i64[1] = (uint64_t)&v1014;
            v1033 = 0;
            unint64_t v1034 = 0;
            v1035 = a3;
            uint64_t v1036 = a6;
            uint64_t v1031 = 0;
            v1032 = (uint64_t *)&v1033;
            v1029 = &v1030;
            v1030 = 0;
            sub_10124F980(0);
            v1033 = 0;
            unint64_t v1034 = 0;
            v1032 = (uint64_t *)&v1033;
            v501 = (void *)v1028.i64[0];
            if (!*(void *)(v1028.i64[0] + 40)) {
              goto LABEL_889;
            }
            uint64_t v502 = 0;
            while (2)
            {
              uint64_t v503 = *(void *)(v501[1] + (((unint64_t)(v501[4] + v502) >> 1) & 0x7FFFFFFFFFFFFFF8))
                   + 376 * ((*((_DWORD *)v501 + 8) + v502) & 0xF);
              if (*(unsigned char *)(v503 + 32)) {
                goto LABEL_888;
              }
              v504 = (void *)(v503 + 40);
              v505 = (void *)(v503 + 376);
              while (2)
              {
                uint64_t v506 = v504[1];
                v507 = (uint64_t *)v504[2];
                uint64_t v508 = v504[3];
                v509 = &v1030;
                v510 = &v1030;
                v511 = v1030;
                if (!v1030) {
                  goto LABEL_882;
                }
                while (2)
                {
                  while (2)
                  {
                    v510 = (uint64_t **)v511;
                    uint64_t v512 = v511[4];
                    if (v506 != v512)
                    {
                      if (v506 >= v512)
                      {
                        if (v512 >= v506) {
                          goto LABEL_885;
                        }
                        goto LABEL_880;
                      }
                      goto LABEL_877;
                    }
                    v513 = v510[5];
                    if (v507 == v513)
                    {
                      v514 = v510[6];
                      if (v508 >= (uint64_t)v514)
                      {
                        if ((uint64_t)v514 >= v508) {
                          goto LABEL_885;
                        }
                        goto LABEL_880;
                      }
                      goto LABEL_877;
                    }
                    if ((uint64_t)v507 < (uint64_t)v513)
                    {
LABEL_877:
                      v511 = *v510;
                      v509 = v510;
                      if (!*v510) {
                        goto LABEL_882;
                      }
                      continue;
                    }
                    break;
                  }
                  if ((uint64_t)v513 >= (uint64_t)v507)
                  {
LABEL_885:
                    v515 = (uint64_t *)v510;
                    goto LABEL_886;
                  }
LABEL_880:
                  v511 = v510[1];
                  if (v511) {
                    continue;
                  }
                  break;
                }
                v509 = v510 + 1;
LABEL_882:
                v515 = (uint64_t *)operator new(0x58uLL);
                v515[4] = v506;
                v515[5] = (uint64_t)v507;
                v515[6] = v508;
                v515[7] = -1;
                v515[10] = 0;
                v515[9] = 0;
                v515[8] = (uint64_t)(v515 + 9);
                uint64_t *v515 = 0;
                v515[1] = 0;
                v515[2] = (uint64_t)v510;
                *v509 = v515;
                v516 = v515;
                if (*v1029)
                {
                  v1029 = (uint64_t **)*v1029;
                  v516 = *v509;
                }
                sub_100046C90(v1030, v516);
                ++v1031;
LABEL_886:
                sub_10124A07C(v515 + 8, v502, v502);
                v504 += 21;
                if (v504 != v505) {
                  continue;
                }
                break;
              }
              v501 = (void *)v1028.i64[0];
LABEL_888:
              if ((unint64_t)++v502 < v501[5]) {
                continue;
              }
              break;
            }
LABEL_889:
            __p[0] = (void *)1;
            v517 = (uint64_t *)v1029;
            if (v1029 != &v1030)
            {
              do
              {
                sub_10124F6FC((uint64_t)&v1027, __p, v517 + 4, v517 + 7, -1);
                v518 = (uint64_t *)v517[1];
                if (v518)
                {
                  do
                  {
                    v519 = (uint64_t **)v518;
                    v518 = (uint64_t *)*v518;
                  }
                  while (v518);
                }
                else
                {
                  do
                  {
                    v519 = (uint64_t **)v517[2];
                    _ZF = *v519 == v517;
                    v517 = (uint64_t *)v519;
                  }
                  while (!_ZF);
                }
                v517 = (uint64_t *)v519;
              }
              while (v519 != &v1030);
              v520 = (uint64_t *)v1029;
              v501 = (void *)v1028.i64[0];
              if (v1029 != &v1030)
              {
                do
                {
                  v521 = (uint64_t *)v520[8];
                  if (v521 != v520 + 9)
                  {
                    uint64_t v522 = v501[4];
                    uint64_t v523 = v501[1];
                    do
                    {
                      unint64_t v524 = v521[4] + v522;
                      uint64_t v525 = *(void *)(v523 + ((v524 >> 1) & 0x7FFFFFFFFFFFFFF8));
                      unsigned int v526 = v524 & 0xF;
                      uint64_t v527 = v525 + 376 * (v524 & 0xF);
                      if (!*(unsigned char *)(v527 + 32))
                      {
                        int v528 = *(_DWORD *)(v527 + 40);
                        int v529 = *(_DWORD *)(v527 + 208);
                        if (v528 != 3 || v529 != 3)
                        {
                          uint64_t v531 = 0;
                          uint64_t v532 = v520[4];
                          uint64_t v533 = v525 + 376 * v526 + 184;
                          do
                          {
                            uint64_t v534 = v533 + v531;
                            if (*(void *)(v533 + v531 - 136) == v532
                              && *(void *)(v534 - 120) == v520[6]
                              && *(void *)(v534 - 128) == v520[5])
                            {
                              *(void *)(v533 + v531) = v520[7];
                            }
                            v531 += 168;
                          }
                          while (v531 != 336);
                        }
                      }
                      v535 = (uint64_t *)v521[1];
                      if (v535)
                      {
                        do
                        {
                          v536 = v535;
                          v535 = (uint64_t *)*v535;
                        }
                        while (v535);
                      }
                      else
                      {
                        do
                        {
                          v536 = (uint64_t *)v521[2];
                          _ZF = *v536 == (void)v521;
                          v521 = v536;
                        }
                        while (!_ZF);
                      }
                      v521 = v536;
                    }
                    while (v536 != v520 + 9);
                  }
                  v537 = (uint64_t *)v520[1];
                  if (v537)
                  {
                    do
                    {
                      v538 = (uint64_t **)v537;
                      v537 = (uint64_t *)*v537;
                    }
                    while (v537);
                  }
                  else
                  {
                    do
                    {
                      v538 = (uint64_t **)v520[2];
                      _ZF = *v538 == v520;
                      v520 = (uint64_t *)v538;
                    }
                    while (!_ZF);
                  }
                  v520 = (uint64_t *)v538;
                }
                while (v538 != &v1030);
              }
            }
            if (v501[5])
            {
              unint64_t v539 = 0;
              do
              {
                uint64_t v540 = *(void *)(v501[1] + (((v501[4] + v539) >> 1) & 0x7FFFFFFFFFFFFFF8))
                     + 376 * ((*((_DWORD *)v501 + 8) + v539) & 0xF);
                uint64_t v543 = *(void *)(v540 + 184);
                v542 = (uint64_t *)(v540 + 184);
                uint64_t v541 = v543;
                uint64_t v544 = *(v542 - 20);
                if (v544 > 0) {
                  uint64_t v545 = -v544;
                }
                else {
                  uint64_t v545 = v539;
                }
                if (v541 == -1)
                {
                  uint64_t v547 = -1;
                }
                else
                {
                  *((void *)sub_10124FA30(&v1032, v541, v542) + 5) = v541;
                  v546 = sub_10124FA30(&v1032, *v542, v542);
                  sub_10124A07C((uint64_t *)v546 + 7, v545, v545);
                  uint64_t v547 = *v542;
                }
                v548 = v542 + 21;
                uint64_t v549 = v542[21];
                if (v549 != -1 && v547 != v549)
                {
                  *((void *)sub_10124FA30(&v1032, v542[21], v542 + 21) + 5) = v549;
                  v551 = sub_10124FA30(&v1032, *v548, v542 + 21);
                  sub_10124A07C((uint64_t *)v551 + 7, v545, v545);
                  uint64_t v547 = *v542;
                  uint64_t v549 = *v548;
                }
                if (v549 != -1 && v547 != -1 && v547 != v549)
                {
                  v554 = sub_10124FA30(&v1032, v547, v542);
                  v555 = sub_10124FB24((uint64_t **)v554 + 10, *v548, v542 + 21);
                  v556 = sub_10124FA30(&v1032, *v548, v542 + 21);
                  v557 = sub_10124FB24((uint64_t **)v556 + 10, *v542, v542);
                  for (uint64_t m = (void *)*((void *)v555 + 7); m; uint64_t m = (void *)*m)
                  {
                    uint64_t v559 = m[4];
                    if (v545 >= v559)
                    {
                      if (v559 >= v545) {
                        goto LABEL_948;
                      }
                      ++m;
                    }
                  }
                  ++*((void *)v555 + 5);
                  sub_10124A07C((uint64_t *)v555 + 6, v545, v545);
LABEL_948:
                  for (n = (void *)*((void *)v557 + 7); n; n = (void *)*n)
                  {
                    uint64_t v561 = n[4];
                    if (v545 >= v561)
                    {
                      if (v561 >= v545) {
                        goto LABEL_954;
                      }
                      ++n;
                    }
                  }
                  ++*((void *)v557 + 5);
                  sub_10124A07C((uint64_t *)v557 + 6, v545, v545);
                }
LABEL_954:
                ++v539;
                v501 = (void *)v1028.i64[0];
              }
              while (v539 < *(void *)(v1028.i64[0] + 40));
            }
            v562 = v1032;
            if (v1032 != (uint64_t *)&v1033)
            {
              while (2)
              {
                uint64_t v563 = v562[12];
                if (v563)
                {
                  if (v563 == 1)
                  {
                    if (*(void *)(v562[10] + 40) < 2uLL) {
                      int v564 = 1;
                    }
                    else {
                      int v564 = 2;
                    }
LABEL_974:
                    *((_DWORD *)v562 + 12) = v564;
LABEL_975:
                    v571 = (uint64_t *)v562[1];
                    if (v571)
                    {
                      do
                      {
                        v572 = v571;
                        v571 = (uint64_t *)*v571;
                      }
                      while (v571);
                    }
                    else
                    {
                      do
                      {
                        v572 = (uint64_t *)v562[2];
                        _ZF = *v572 == (void)v562;
                        v562 = v572;
                      }
                      while (!_ZF);
                    }
                    v562 = v572;
                    if (v572 == (uint64_t *)&v1033) {
                      goto LABEL_981;
                    }
                    continue;
                  }
                  v565 = (uint64_t *)v562[10];
                  if (v565 != v562 + 11)
                  {
                    uint64_t v566 = 0;
                    char v567 = 1;
                    while (v565[5] == 1)
                    {
                      uint64_t v568 = *(void *)(v565[6] + 32);
                      if ((v567 & 1) == 0)
                      {
                        _ZF = v566 == v568;
                        uint64_t v568 = v566;
                        if (!_ZF) {
                          break;
                        }
                      }
                      v569 = (uint64_t *)v565[1];
                      if (v569)
                      {
                        do
                        {
                          v570 = v569;
                          v569 = (uint64_t *)*v569;
                        }
                        while (v569);
                      }
                      else
                      {
                        do
                        {
                          v570 = (uint64_t *)v565[2];
                          _ZF = *v570 == (void)v565;
                          v565 = v570;
                        }
                        while (!_ZF);
                      }
                      char v567 = 0;
                      uint64_t v566 = v568;
                      v565 = v570;
                      if (v570 == v562 + 11) {
                        goto LABEL_973;
                      }
                    }
                    goto LABEL_975;
                  }
                }
                break;
              }
LABEL_973:
              int v564 = 1;
              goto LABEL_974;
            }
LABEL_981:
            v573 = 0;
LABEL_982:
            v574 = v1032;
            if ((unint64_t)v573 >= v1034 || v1032 == (uint64_t *)&v1033) {
              goto LABEL_1091;
            }
            char v980 = 0;
            v976 = v573 + 1;
            while (2)
            {
              if (*((_DWORD *)v574 + 12)) {
                goto LABEL_1084;
              }
              v576 = (uint64_t *)v574[10];
              v577 = v574 + 11;
              if (v576 == v574 + 11)
              {
LABEL_1082:
                char v980 = 1;
                *((_DWORD *)v574 + 12) = 1;
                goto LABEL_1084;
              }
              uint64_t v578 = 0;
              v579 = v574 + 7;
              int v580 = 1;
LABEL_990:
              v581 = v1033;
              if (!v1033) {
                goto LABEL_1084;
              }
              uint64_t v582 = v576[4];
              v583 = &v1033;
              do
              {
                v584 = v581;
                v585 = v583;
                uint64_t v586 = v581[4];
                v587 = v581 + 1;
                if (v586 >= v582)
                {
                  v587 = v584;
                  v583 = (void **)v584;
                }
                v581 = (void *)*v587;
              }
              while (v581);
              if (v583 == &v1033) {
                goto LABEL_1084;
              }
              v588 = v586 >= v582 ? v584 : v585;
              if (v582 < v588[4]) {
                goto LABEL_1084;
              }
              if (v576[5] != 1)
              {
                if (v586 >= v582) {
                  v589 = v584;
                }
                else {
                  v589 = v585;
                }
                if (*((_DWORD *)v589 + 12) != 2) {
                  goto LABEL_1084;
                }
                int v992 = v580;
                uint64_t v997 = v578;
                memset(v1039, 0, 24);
                sub_101249EFC((uint64_t)v1039, v579);
                if (v586 >= v582) {
                  v590 = v584;
                }
                else {
                  v590 = v585;
                }
                v591 = (void *)v590[7];
                if (v586 >= v582) {
                  v592 = v584 + 8;
                }
                else {
                  v592 = v585 + 8;
                }
                if (v591 != v592)
                {
                  do
                  {
                    sub_10124A1B0((uint64_t)v1039, v591[4]);
                    v593 = (void *)v591[1];
                    if (v593)
                    {
                      do
                      {
                        v594 = v593;
                        v593 = (void *)*v593;
                      }
                      while (v593);
                    }
                    else
                    {
                      do
                      {
                        v594 = (void *)v591[2];
                        _ZF = *v594 == (void)v591;
                        v591 = v594;
                      }
                      while (!_ZF);
                    }
                    v591 = v594;
                  }
                  while (v594 != v592);
                }
                if (v1039[2] != (void *)1) {
                  goto LABEL_1083;
                }
                v595 = (void *)v590[7];
                if (v595 != v592)
                {
                  uint64_t v596 = v574[5];
                  uint64_t v597 = v589[5];
                  v598 = (void *)(v1028.i64[1] + 8);
                  while (1)
                  {
                    uint64_t v599 = v595[4];
                    if (v599 < 0) {
                      break;
                    }
                    uint64_t v600 = *(void *)(*(void *)(v1028.i64[0] + 8)
                                     + (((unint64_t)(*(void *)(v1028.i64[0] + 32) + v599) >> 1) & 0x7FFFFFFFFFFFFFF8))
                         + 376 * ((*(_DWORD *)(v1028.i64[0] + 32) + v599) & 0xF);
                    if (*(_DWORD *)(v600 + 40) != 2 || *(_DWORD *)(v600 + 208) != 2) {
                      goto LABEL_1083;
                    }
                    uint64_t v601 = *(void *)(v600 + 184);
                    uint64_t v602 = *(void *)(v600 + 352);
                    if ((v601 != v596 || v602 != v597) && (v602 != v596 || v601 != v597)) {
                      goto LABEL_1083;
                    }
LABEL_1061:
                    v620 = (void *)v595[1];
                    if (v620)
                    {
                      do
                      {
                        v621 = v620;
                        v620 = (void *)*v620;
                      }
                      while (v620);
                    }
                    else
                    {
                      do
                      {
                        v621 = (void *)v595[2];
                        _ZF = *v621 == (void)v595;
                        v595 = v621;
                      }
                      while (!_ZF);
                    }
                    v595 = v621;
                    if (v621 == v592) {
                      goto LABEL_1067;
                    }
                  }
                  v605 = (void *)*v598;
                  if (!*v598) {
                    goto LABEL_1061;
                  }
                  uint64_t v606 = -v599;
                  uint64_t v607 = v1028.i64[1] + 8;
                  do
                  {
                    uint64_t v608 = v605[4];
                    BOOL v609 = v608 < v606;
                    if (v608 >= v606) {
                      v610 = v605;
                    }
                    else {
                      v610 = v605 + 1;
                    }
                    if (!v609) {
                      uint64_t v607 = (uint64_t)v605;
                    }
                    v605 = (void *)*v610;
                  }
                  while (*v610);
                  if ((void *)v607 == v598) {
                    goto LABEL_1061;
                  }
                  if (*(void *)(v607 + 32) > v606) {
                    goto LABEL_1061;
                  }
                  v611 = *(void **)(v607 + 40);
                  v612 = (void *)(v607 + 48);
                  if (v611 == v612) {
                    goto LABEL_1061;
                  }
                  while (1)
                  {
                    uint64_t v613 = *(void *)(*(void *)(v1028.i64[0] + 8)
                                     + (((v611[4] + *(void *)(v1028.i64[0] + 32)) >> 1) & 0x7FFFFFFFFFFFFFF8))
                         + 376 * ((*((_DWORD *)v611 + 8) + *(void *)(v1028.i64[0] + 32)) & 0xF);
                    if (*(_DWORD *)(v613 + 40) != 2 || *(_DWORD *)(v613 + 208) != 2) {
                      break;
                    }
                    uint64_t v614 = *(void *)(v613 + 184);
                    uint64_t v615 = *(void *)(v613 + 352);
                    if ((v614 != v596 || v615 != v597) && (v615 != v596 || v614 != v597)) {
                      break;
                    }
                    v618 = (void *)v611[1];
                    if (v618)
                    {
                      do
                      {
                        v619 = v618;
                        v618 = (void *)*v618;
                      }
                      while (v618);
                    }
                    else
                    {
                      do
                      {
                        v619 = (void *)v611[2];
                        _ZF = *v619 == (void)v611;
                        v611 = v619;
                      }
                      while (!_ZF);
                    }
                    v611 = v619;
                    if (v619 == v612) {
                      goto LABEL_1061;
                    }
                  }
LABEL_1083:
                  sub_10005D144((void *)v1039[1]);
LABEL_1084:
                  v625 = (uint64_t *)v574[1];
                  if (v625)
                  {
                    do
                    {
                      v626 = v625;
                      v625 = (uint64_t *)*v625;
                    }
                    while (v625);
                  }
                  else
                  {
                    do
                    {
                      v626 = (uint64_t *)v574[2];
                      _ZF = *v626 == (void)v574;
                      v574 = v626;
                    }
                    while (!_ZF);
                  }
                  v574 = v626;
                  if (v626 != (uint64_t *)&v1033) {
                    continue;
                  }
                  v573 = v976;
                  if (v980) {
                    goto LABEL_982;
                  }
LABEL_1091:
                  uint64_t v627 = *(void *)(v1028.i64[0] + 8);
                  if (*(void *)(v1028.i64[0] + 16) != v627)
                  {
                    unint64_t v628 = *(void *)(v1028.i64[0] + 32);
                    v629 = (uint64_t *)(v627 + 8 * (v628 >> 4));
                    uint64_t v630 = *v629;
                    uint64_t v631 = *v629 + 376 * (v628 & 0xF);
                    uint64_t v632 = *(void *)(v627 + (((*(void *)(v1028.i64[0] + 40) + v628) >> 1) & 0x7FFFFFFFFFFFFFF8))
                         + 376 * ((*(void *)(v1028.i64[0] + 40) + v628) & 0xF);
                    if (v631 != v632)
                    {
                      v633 = v1033;
                      do
                      {
                        uint64_t v634 = v631 + 40;
                        v631 += 376;
                        do
                        {
                          if (v633)
                          {
                            uint64_t v635 = *(void *)(v634 + 144);
                            v636 = &v1033;
                            v637 = v633;
                            do
                            {
                              v638 = v637;
                              v639 = v636;
                              uint64_t v640 = v637[4];
                              if (v640 >= v635) {
                                v636 = (void **)v637;
                              }
                              else {
                                ++v637;
                              }
                              v637 = (void *)*v637;
                            }
                            while (v637);
                            if (v636 != &v1033)
                            {
                              v641 = v640 >= v635 ? v638 : v639;
                              if (v635 >= v641[4])
                              {
                                if (v640 >= v635) {
                                  v642 = v638;
                                }
                                else {
                                  v642 = v639;
                                }
                                *(unsigned char *)(v634 + 152) = *((_DWORD *)v642 + 12) == 1;
                              }
                            }
                          }
                          v634 += 168;
                        }
                        while (v634 != v631);
                        if (v631 - v630 == 6016)
                        {
                          uint64_t v643 = v629[1];
                          ++v629;
                          uint64_t v630 = v643;
                          uint64_t v631 = v643;
                        }
                      }
                      while (v631 != v632);
                    }
                  }
                  uint64_t v644 = *((void *)&v1018 + 1);
                  uint64_t v645 = v1019;
                  v646 = (void *)(*((void *)&v1018 + 1) + 8 * ((unint64_t)v1020 >> 4));
                  if ((void)v1019 == *((void *)&v1018 + 1)) {
                    uint64_t v647 = 0;
                  }
                  else {
                    uint64_t v647 = *v646 + 376 * (v1020 & 0xF);
                  }
                  unint64_t v648 = *((void *)&v1020 + 1);
                  uint64_t v649 = (*((void *)&v1020 + 1) + (void)v1020) >> 4;
                  unsigned int v650 = (BYTE8(v1020) + (_BYTE)v1020) & 0xF;
LABEL_1118:
                  uint64_t v651 = v647 - 6016;
                  while (1)
                  {
                    uint64_t v652 = v645 == v644 ? 0 : *(void *)(v644 + 8 * v649) + 376 * v650;
                    if (v647 == v652) {
                      break;
                    }
                    *(_DWORD *)(v647 + 200) = 0;
                    *(_WORD *)(v647 + 204) = 0;
                    *(_DWORD *)(v647 + 368) = 0;
                    *(_WORD *)(v647 + 372) = 0;
                    v651 += 376;
                    v647 += 376;
                    if (*v646 == v651)
                    {
                      uint64_t v653 = v646[1];
                      ++v646;
                      uint64_t v647 = v653;
                      goto LABEL_1118;
                    }
                  }
                  *(_OWORD *)v1039 = v1005;
                  v1039[2] = &v1018;
                  v1039[3] = &v1014;
                  v1039[5] = 0;
                  v1039[4] = a3;
                  *(void *)v1040 = a6;
                  *(_OWORD *)&v1040[8] = v1005;
                  v1041 = &v1018;
                  v1042 = &v1012;
                  v1043 = &v1014;
                  v1044 = a5;
                  v1045 = a3;
                  uint64_t v1046 = a6;
                  __p[0] = *((void **)&v1011 + 1);
                  LOWORD(v1024) = 257;
                  if (v648)
                  {
                    uint64_t v654 = 0;
                    while (1)
                    {
                      uint64_t v655 = *(void *)(*((void *)&v1018 + 1)
                                       + (((unint64_t)(v654 + v1020) >> 1) & 0x7FFFFFFFFFFFFFF8));
                      uint64_t v656 = v655 + 376 * ((v654 + v1020) & 0xF);
                      if (!*(unsigned char *)(v656 + 32)) {
                        break;
                      }
LABEL_1136:
                      if (++v654 >= v648) {
                        goto LABEL_1137;
                      }
                    }
                    int v657 = *(_DWORD *)(v656 + 40);
                    if (v657 == 4)
                    {
                      if (*(_DWORD *)(v656 + 208) == 4)
                      {
                        unsigned int v658 = *(double *)(v656 + 112) > *(double *)(v656 + 280);
LABEL_1135:
                        sub_10124FC04((uint64_t)v1039, v656, v654, v658, v1009, (unint64_t *)__p, &v1024);
                        unint64_t v648 = *((void *)&v1020 + 1);
                        goto LABEL_1136;
                      }
                    }
                    else if (v657 == 3 && *(_DWORD *)(v656 + 208) == 3)
                    {
                      goto LABEL_1136;
                    }
                    sub_10124FC04((uint64_t)v1039, v655 + 376 * ((v654 + v1020) & 0xF), v654, 0, v1009, (unint64_t *)__p, &v1024);
                    unsigned int v658 = 1;
                    goto LABEL_1135;
                  }
LABEL_1137:
                  sub_10124F980(v1033);
                  sub_10124F92C(v1030);
                  uint64_t v659 = *((void *)&v1018 + 1);
                  uint64_t v660 = v1019;
                  v661 = (void *)(*((void *)&v1018 + 1) + 8 * ((unint64_t)v1020 >> 4));
                  if ((void)v1019 == *((void *)&v1018 + 1)) {
                    uint64_t v662 = 0;
                  }
                  else {
                    uint64_t v662 = *v661 + 376 * (v1020 & 0xF);
                  }
                  while (1)
                  {
                    uint64_t v663 = v660 == v659
                         ? 0
                         : *(void *)(v659 + (((*((void *)&v1020 + 1) + (void)v1020) >> 1) & 0x7FFFFFFFFFFFFFF8))
                         + 376 * ((DWORD2(v1020) + v1020) & 0xF);
                    if (v662 == v663) {
                      break;
                    }
                    if (*(void *)(v662 + 48) != *(void *)(v662 + 216) || *(unsigned char *)(v662 + 32) == 0)
                    {
                      char v665 = 0;
                      int v666 = 0;
                      v667 = (_DWORD *)(v662 + 40);
                      uint64_t v668 = v662 + 40;
                      while (1)
                      {
                        v1039[2] = 0;
                        v1039[1] = 0;
                        v1039[0] = 0;
                        v669 = *(void **)(v668 + 24);
                        *(_OWORD *)v1039 = *(_OWORD *)(v668 + 8);
                        v1039[2] = v669;
                        if (*(void *)(v662 + 48) != *(void *)(v662 + 216) && *(void *)(v668 + 120) < 3uLL) {
                          goto LABEL_1152;
                        }
                        if (*v667 == 3 || *(_DWORD *)(v662 + 208) == 3) {
                          *((unsigned char *)sub_101252BD0(&v1012, (uint64_t *)v1039, (uint64_t)v1039) + 57) = 1;
                        }
                        if (*((unsigned char *)sub_101252BD0(&v1012, (uint64_t *)v1039, (uint64_t)v1039) + 56)
                          || *((unsigned char *)sub_101252BD0(&v1012, (uint64_t *)v1039, (uint64_t)v1039) + 57))
                        {
                          goto LABEL_1158;
                        }
                        if (v665) {
                          goto LABEL_1161;
                        }
                        uint64_t v670 = *(void *)(v662 + 24);
                        if (v670 >= 1) {
                          break;
                        }
                        char v665 = 0;
                        if (v666)
                        {
LABEL_1194:
                          int v666 = 1;
                          goto LABEL_1152;
                        }
LABEL_1195:
                        if (*(_DWORD *)v668 != 1 || *(unsigned char *)(v662 + 33) != 0)
                        {
                          int v666 = 0;
                          goto LABEL_1158;
                        }
                        if (*v667 == 1 && *(_DWORD *)(v662 + 208) == 1)
                        {
                          int v666 = 0;
                          if (*(void *)(v662 + 48) == *(void *)(v662 + 216)) {
                            goto LABEL_1158;
                          }
                        }
                        else
                        {
                          int v666 = 0;
                        }
LABEL_1152:
                        *((unsigned char *)sub_101252BD0(&v1012, (uint64_t *)v1039, (uint64_t)v1039) + 57) = 1;
LABEL_1158:
                        v668 += 168;
                        if (v668 == v662 + 376) {
                          goto LABEL_1205;
                        }
                      }
                      v671 = v1015;
                      if (!v1015) {
                        goto LABEL_1192;
                      }
                      v672 = &v1015;
                      do
                      {
                        v673 = v671;
                        v674 = v672;
                        uint64_t v675 = v671[4];
                        if (v675 >= v670) {
                          v672 = (uint64_t **)v671;
                        }
                        else {
                          ++v671;
                        }
                        v671 = (uint64_t *)*v671;
                      }
                      while (v671);
                      if (v672 == &v1015) {
                        goto LABEL_1192;
                      }
                      v676 = v675 >= v670 ? v673 : (uint64_t *)v674;
                      if (v676[4] > v670) {
                        goto LABEL_1192;
                      }
                      BOOL v677 = v675 < v670;
                      if (v675 >= v670) {
                        v678 = v673;
                      }
                      else {
                        v678 = v674;
                      }
                      v679 = (uint64_t *)v678[5];
                      v680 = (uint64_t *)(v674 + 6);
                      v681 = v673 + 6;
                      if (!v677) {
                        v680 = v681;
                      }
                      if (v679 == v680)
                      {
LABEL_1192:
                        char v665 = 1;
                        goto LABEL_1195;
                      }
                      int v666 = 0;
                      do
                      {
                        uint64_t v682 = *(void *)(*((void *)&v1018 + 1)
                                         + (((unint64_t)(v679[4] + v1020) >> 1) & 0x7FFFFFFFFFFFFFF8))
                             + 376 * ((*((_DWORD *)v679 + 8) + v1020) & 0xF);
                        if (*(_DWORD *)(v682 + 40) == 3 || *(_DWORD *)(v682 + 208) == 3) {
                          int v666 = 1;
                        }
                        v683 = (uint64_t *)v679[1];
                        if (v683)
                        {
                          do
                          {
                            v684 = v683;
                            v683 = (uint64_t *)*v683;
                          }
                          while (v683);
                        }
                        else
                        {
                          do
                          {
                            v684 = (uint64_t *)v679[2];
                            _ZF = *v684 == (void)v679;
                            v679 = v684;
                          }
                          while (!_ZF);
                        }
                        v679 = v684;
                      }
                      while (v684 != v680);
LABEL_1161:
                      char v665 = 1;
                      if (v666) {
                        goto LABEL_1194;
                      }
                      goto LABEL_1195;
                    }
LABEL_1205:
                    v662 += 376;
                    if (v662 - *v661 == 6016)
                    {
                      uint64_t v686 = v661[1];
                      ++v661;
                      uint64_t v662 = v686;
                    }
                    uint64_t v659 = *((void *)&v1018 + 1);
                    uint64_t v660 = v1019;
                  }
                  v1007 = 0;
                  unint64_t v1008 = 0;
                  v1038 = 0;
                  __p[1] = 0;
                  __p[0] = &__p[1];
                  v1024 = 0;
                  uint64_t v1025 = -1;
                  uint64_t v1026 = -1;
                  sub_1012574A8((double **)v1005, (uint64_t *)&v1024, (uint64_t **)__p);
                  v1021 = (void *)1;
                  uint64_t v1022 = -1;
                  uint64_t v1023 = -1;
                  sub_1012574A8(*((double ***)&v1005 + 1), (uint64_t *)&v1021, (uint64_t **)__p);
                  sub_101257A14(v1007);
                  v1007 = 0;
                  unint64_t v1008 = 0;
                  v1006 = (uint64_t *)&v1007;
                  v687 = (void **)__p[0];
                  if (__p[0] == &__p[1])
                  {
LABEL_1279:
                    sub_101257A14((void *)__p[1]);
                    int64x2_t v1027 = (int64x2_t)xmmword_1015E0D00;
                    v1028.i64[0] = -1;
                    v737 = v1009[1];
                    v738 = (void *)v1010;
                    v739 = (char *)v1009[1] + 8 * ((unint64_t)v1011 / 0xAA);
                    if ((void *)v1010 == v1009[1]) {
                      v740 = 0;
                    }
                    else {
                      v740 = (uint64_t ***)(*v739 + 24 * ((unint64_t)v1011 % 0xAA));
                    }
                    uint64_t v741 = 0;
                    while (1)
                    {
                      unint64_t v742 = v738 == v737
                           ? 0
                           : v737[(*((void *)&v1011 + 1) + (void)v1011) / 0xAAuLL]
                           + 24 * ((*((void *)&v1011 + 1) + (void)v1011) % 0xAAuLL);
                      if (v740 == (uint64_t ***)v742) {
                        break;
                      }
                      memset((char *)v1039 + 6, 255, 24);
                      v743 = (double *)v740[1];
                      v744 = (double *)(*v740 + 2);
                      double v745 = 0.0;
                      if ((unint64_t)((char *)v743 - (char *)*v740) >= 0x40 && v744 != v743)
                      {
                        unint64_t v747 = 0;
                        do
                        {
                          double v748 = *(v744 - 2);
                          double v749 = *v744;
                          if (v748 != *v744)
                          {
                            if ((*(void *)&v748 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                              || (*(void *)&v749 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                            {
                              goto LABEL_1297;
                            }
                            double v751 = vabdd_f64(v748, v749);
                            double v752 = fabs(v748);
                            double v753 = fabs(v749);
                            if (v752 < v753) {
                              double v752 = v753;
                            }
                            double v754 = v752 >= 1.0 ? v752 * 2.22044605e-16 : 2.22044605e-16;
                            if (v751 > v754)
                            {
LABEL_1297:
                              double v745 = v745 + sub_101232970(v744 - 2, v744);
                              v747 += sub_101232BC4(v744 - 2, v744);
                            }
                          }
                          v744 += 2;
                        }
                        while (v744 != v743);
                        if (v747)
                        {
                          uint64_t v755 = (v747 >> 1) + 1;
                          double v756 = fabs(v745);
                          double v757 = -v756;
                          double v758 = -(v756 - (double)(unint64_t)v755 * 6.28318531);
                          if (v745 <= 0.0) {
                            double v745 = v758;
                          }
                          else {
                            double v745 = -(v757 + (double)(unint64_t)v755 * 6.28318531);
                          }
                        }
                      }
                      v759 = *v740;
                      v760 = v740[1];
                      if (*v740 != v760)
                      {
                        uint64_t v7 = *v759;
                        double v6 = v759[1];
                      }
                      v761 = sub_101257B18(&v1006, v1027.i64, (uint64_t)&v1027);
                      v763 = v761 + 16;
                      v762 = v761[16];
                      *((unsigned char *)v761 + 56) = v759 != v760;
                      v761[8] = v7;
                      v761[9] = v6;
                      *((double *)v761 + 10) = v745;
                      *((_WORD *)v761 + 44) = 0;
                      *(_OWORD *)((char *)v761 + 90) = *(_OWORD *)v1039;
                      *(_OWORD *)(v761 + 13) = *(_OWORD *)((char *)&v1039[1] + 6);
                      v761[15] = (uint64_t *)0xBFF0000000000000;
                      if (v762)
                      {
                        v761[17] = v762;
                        operator delete(v762);
                        void *v763 = 0;
                        v763[1] = 0;
                        v763[2] = 0;
                      }
                      void *v763 = 0;
                      v763[1] = 0;
                      v763[2] = 0;
                      *((unsigned char *)sub_101257B18(&v1006, v1027.i64, (uint64_t)&v1027) + 88) = 0;
                      v1027.i64[1] = ++v741;
                      v740 += 3;
                      if ((uint64_t ***)((char *)v740 - *v739) == (uint64_t ***)4080)
                      {
                        v764 = (uint64_t ***)v739[1];
                        ++v739;
                        v740 = v764;
                      }
                      v737 = v1009[1];
                      v738 = (void *)v1010;
                    }
                    unint64_t v765 = v1008;
                    if (v1008)
                    {
                      if (v1008 >= 0x38E38E38E38E38FLL) {
                        sub_10006A748();
                      }
                      v766 = (uint64_t *)operator new(72 * v1008);
                      v767 = &v766[9 * v765];
                      v768 = v766;
                      do
                      {
                        uint64_t *v768 = -1;
                        v768[1] = -1;
                        v768[2] = -1;
                        v768[3] = 0;
                        v768[4] = 0;
                        v768 += 9;
                      }
                      while (v768 != v767);
                      v769 = v1006;
                      if (v1006 == (uint64_t *)&v1007) {
                        goto LABEL_1417;
                      }
                    }
                    else
                    {
                      v769 = v1006;
                      if (v1006 == (uint64_t *)&v1007) {
                        goto LABEL_1588;
                      }
                      v767 = 0;
                      v766 = 0;
                    }
                    unint64_t v977 = v765;
                    uint64_t v770 = 0;
                    uint64_t v771 = 0;
                    uint64_t v772 = 0;
                    int64x2_t v981 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
                    int64x2_t v985 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
                    __asm { FMOV            V1.2D, #1.0 }
                    float64x2_t v987 = (float64x2_t)vdupq_n_s64(0x3CB0000000000000uLL);
                    float64x2_t v993 = _Q1;
                    v1004 = v766;
                    while (1)
                    {
                      double v776 = *((double *)v769 + 10);
                      double v777 = -v776;
                      if (!*((unsigned char *)v769 + 88)) {
                        double v777 = *((double *)v769 + 10);
                      }
                      v778 = (char *)&v766[9 * v770];
                      long long v779 = *((_OWORD *)v769 + 2);
                      *((void *)v778 + 2) = v769[6];
                      *(_OWORD *)v778 = v779;
                      *((double *)v778 + 3) = v777;
                      *((double *)v778 + 4) = fabs(v776);
                      uint64_t v780 = v769[4];
                      if (v780)
                      {
                        if (v780 == 1)
                        {
                          uint64_t v783 = v769[6];
                          if (v783 < -1) {
                            goto LABEL_1596;
                          }
                          uint64_t v784 = *(void *)(*((void *)&v1005 + 1) + 24);
                          uint64_t v785 = (*(void *)(*((void *)&v1005 + 1) + 32) - v784) >> 3;
                          unint64_t v786 = 0xAAAAAAAAAAAAAAABLL * v785;
                          if (v783 >= -1431655765 * (int)v785) {
                            goto LABEL_1596;
                          }
                          uint64_t v787 = *((void *)&v1005 + 1);
                          if ((v783 & 0x8000000000000000) == 0)
                          {
                            if (v786 < v783) {
                              goto LABEL_1597;
                            }
                            uint64_t v787 = v784 + 24 * v783;
                          }
                          v788 = (char *)&v766[9 * v770];
                          *(int64x2_t *)(v788 + 40) = v985;
                          v789 = v788 + 40;
                          v790 = *(double **)v787;
                          uint64_t v791 = *(void *)(v787 + 8);
                          unint64_t v792 = v791 - *(void *)v787;
                          if (v792 <= 0x1F) {
                            uint64_t v793 = 0;
                          }
                          else {
                            uint64_t v793 = -1;
                          }
                          v794 = (double *)(v791 + 16 * v793);
                          *((int64x2_t *)v789 + 1) = v981;
                          if (v790 != v794)
                          {
                            v795 = v790 + 2;
                            v796 = v792 <= 0x1F ? v790 : v790 + 2;
                            sub_101257C54(v790, v796, (double *)v789);
                            if (v795 != v794)
                            {
                              do
                              {
                                v797 = v795 + 2;
                                if (v792 <= 0x1F) {
                                  v798 = v795;
                                }
                                else {
                                  v798 = v795 + 2;
                                }
                                sub_101257D38((double *)v789, v795, v798);
                                v795 += 2;
                              }
                              while (v797 != v794);
                            }
                          }
                        }
                        else if (v780 == 2)
                        {
                          unint64_t v781 = v769[5];
                          if (*((void *)&v1011 + 1) < v781)
                          {
                            int v963 = 96;
                            v964 = "pos";
                            v965 = "range.hpp";
                            v966 = "i <= boost::size(rng)";
LABEL_1599:
                            __assert_rtn(v964, v965, v963, v966);
                          }
                          if ((void *)v1010 == v1009[1]) {
                            v782 = 0;
                          }
                          else {
                            v782 = (void *)(*((void *)v1009[1] + (unint64_t)v1011 / 0xAA)
                          }
                                          + 24 * ((unint64_t)v1011 % 0xAA));
                          v1039[0] = (char *)v1009[1] + 8 * ((unint64_t)v1011 / 0xAA);
                          v1039[1] = v782;
                          sub_10119ECB0(v1039, v781);
                          v815 = (double **)v1039[1];
                          v816 = (char *)&v1004[9 * v770];
                          *(int64x2_t *)(v816 + 40) = v985;
                          v817 = v816 + 40;
                          v818 = *v815;
                          v819 = v815[1];
                          unint64_t v820 = (char *)v819 - (char *)v818;
                          if ((unint64_t)((char *)v819 - (char *)v818) <= 0x1F) {
                            uint64_t v821 = 0;
                          }
                          else {
                            uint64_t v821 = -1;
                          }
                          v822 = &v819[2 * v821];
                          *((int64x2_t *)v817 + 1) = v981;
                          if (v818 != v822)
                          {
                            v823 = v818 + 2;
                            v824 = v820 <= 0x1F ? v818 : v818 + 2;
                            sub_101257C54(v818, v824, (double *)v817);
                            if (v823 != v822)
                            {
                              do
                              {
                                v825 = v823 + 2;
                                if (v820 <= 0x1F) {
                                  v826 = v823;
                                }
                                else {
                                  v826 = v823 + 2;
                                }
                                sub_101257D38((double *)v817, v823, v826);
                                v823 += 2;
                              }
                              while (v825 != v822);
                            }
                          }
                        }
                      }
                      else
                      {
                        uint64_t v799 = v769[6];
                        if (v799 < -1
                          || (uint64_t v800 = *(void *)(v1005 + 24),
                              uint64_t v801 = (*(void *)(v1005 + 32) - v800) >> 3,
                              unint64_t v802 = 0xAAAAAAAAAAAAAAABLL * v801,
                              v799 >= -1431655765 * (int)v801))
                        {
LABEL_1596:
                          int v963 = 94;
                          v964 = "apply";
                          v965 = "get_ring.hpp";
                          v966 = "id.ring_index >= -1 && id.ring_index < int(boost::size(interior_rings(polygon)))";
                          goto LABEL_1599;
                        }
                        uint64_t v803 = v1005;
                        if ((v799 & 0x8000000000000000) == 0)
                        {
                          if (v802 < v799)
                          {
LABEL_1597:
                            int v963 = 96;
                            v964 = "pos";
                            v965 = "range.hpp";
                            v966 = "i <= boost::size(rng)";
                            goto LABEL_1599;
                          }
                          uint64_t v803 = v800 + 24 * v799;
                        }
                        v804 = (char *)&v766[9 * v770];
                        *(int64x2_t *)(v804 + 40) = v985;
                        v805 = v804 + 40;
                        v806 = *(double **)v803;
                        uint64_t v807 = *(void *)(v803 + 8);
                        unint64_t v808 = v807 - *(void *)v803;
                        if (v808 <= 0x1F) {
                          uint64_t v809 = 0;
                        }
                        else {
                          uint64_t v809 = -1;
                        }
                        v810 = (double *)(v807 + 16 * v809);
                        *((int64x2_t *)v805 + 1) = v981;
                        if (v806 != v810)
                        {
                          v811 = v806 + 2;
                          v812 = v808 <= 0x1F ? v806 : v806 + 2;
                          sub_101257C54(v806, v812, (double *)v805);
                          if (v811 != v810)
                          {
                            do
                            {
                              v813 = v811 + 2;
                              if (v808 <= 0x1F) {
                                v814 = v811;
                              }
                              else {
                                v814 = v811 + 2;
                              }
                              sub_101257D38((double *)v805, v811, v814);
                              v811 += 2;
                            }
                            while (v813 != v810);
                          }
                        }
                      }
                      v766 = v1004;
                      v827 = (char *)&v1004[9 * v770];
                      float64x2_t v828 = *(float64x2_t *)(v827 + 40);
                      float64x2_t v829 = vabsq_f64(v828);
                      *(float64x2_t *)(v827 + 40) = vsubq_f64(v828, (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v993, v829), (int8x16_t)v987, (int8x16_t)vmulq_f64(v829, v987)));
                      float64x2_t v830 = *(float64x2_t *)(v827 + 56);
                      float64x2_t v831 = vabsq_f64(v830);
                      *(float64x2_t *)(v827 + 56) = vaddq_f64(v830, (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v993, v831), (int8x16_t)v987, (int8x16_t)vmulq_f64(v831, v987)));
                      if (*((double *)v827 + 3) > 0.0)
                      {
                        ++v772;
                        uint64_t v771 = v770;
                      }
                      v832 = (uint64_t *)v769[1];
                      if (v832)
                      {
                        do
                        {
                          v833 = v832;
                          v832 = (uint64_t *)*v832;
                        }
                        while (v832);
                      }
                      else
                      {
                        do
                        {
                          v833 = (uint64_t *)v769[2];
                          _ZF = *v833 == (void)v769;
                          v769 = v833;
                        }
                        while (!_ZF);
                      }
                      ++v770;
                      v769 = v833;
                      if (v833 == (uint64_t *)&v1007)
                      {
                        if (v772 == v977)
                        {
                          char v834 = 1;
                          goto LABEL_1446;
                        }
                        if (v772 == 1)
                        {
                          v835 = (void **)&v1004[9 * v771];
                          *(_OWORD *)v1039 = *(_OWORD *)v835;
                          v1039[2] = v835[2];
                          v836 = sub_101257B18(&v1006, (uint64_t *)v1039, (uint64_t)v1039);
                          if (v1004 != v767)
                          {
                            v837 = v836;
                            uint64_t v838 = 0;
                            v839 = v1004;
                            do
                            {
                              if (v838 != v771)
                              {
                                v840 = sub_101257B18(&v1006, v839, (uint64_t)v839);
                                *((_OWORD *)v840 + 6) = *(_OWORD *)v1039;
                                v840[14] = (uint64_t *)v1039[2];
                                v842 = v837[17];
                                v841 = v837[18];
                                if (v842 >= v841)
                                {
                                  v845 = v837[16];
                                  unint64_t v846 = 0xAAAAAAAAAAAAAAABLL * (v842 - v845);
                                  unint64_t v847 = v846 + 1;
                                  if (v846 + 1 > 0xAAAAAAAAAAAAAAALL) {
                                    sub_10006A748();
                                  }
                                  unint64_t v848 = 0xAAAAAAAAAAAAAAABLL * (v841 - v845);
                                  if (2 * v848 > v847) {
                                    unint64_t v847 = 2 * v848;
                                  }
                                  if (v848 >= 0x555555555555555) {
                                    unint64_t v849 = 0xAAAAAAAAAAAAAAALL;
                                  }
                                  else {
                                    unint64_t v849 = v847;
                                  }
                                  if (v849) {
                                    unint64_t v849 = (unint64_t)sub_100601864(v849);
                                  }
                                  else {
                                    uint64_t v850 = 0;
                                  }
                                  unint64_t v851 = v849 + 24 * v846;
                                  long long v852 = *(_OWORD *)v839;
                                  *(void *)(v851 + 16) = v839[2];
                                  *(_OWORD *)unint64_t v851 = v852;
                                  v854 = v837[16];
                                  v853 = v837[17];
                                  v855 = (uint64_t *)v851;
                                  if (v853 != v854)
                                  {
                                    do
                                    {
                                      long long v856 = *(_OWORD *)(v853 - 3);
                                      *(v855 - 1) = *(v853 - 1);
                                      *(_OWORD *)(v855 - 3) = v856;
                                      v855 -= 3;
                                      v853 -= 3;
                                    }
                                    while (v853 != v854);
                                    v853 = v837[16];
                                  }
                                  v844 = (uint64_t *)(v851 + 24);
                                  v837[16] = v855;
                                  v837[17] = (uint64_t *)(v851 + 24);
                                  v837[18] = (uint64_t *)(v849 + 24 * v850);
                                  if (v853) {
                                    operator delete(v853);
                                  }
                                }
                                else
                                {
                                  long long v843 = *(_OWORD *)v839;
                                  v842[2] = v839[2];
                                  *(_OWORD *)v842 = v843;
                                  v844 = v842 + 3;
                                }
                                v837[17] = v844;
                              }
                              v839 += 9;
                              ++v838;
                            }
                            while (v839 != v767);
                          }
                          char v834 = 1;
                          v766 = v1004;
LABEL_1446:
                          if (v766) {
                            operator delete(v766);
                          }
                          v871 = v1006;
                          if (v1006 == (uint64_t *)&v1007) {
                            char v872 = 1;
                          }
                          else {
                            char v872 = v834;
                          }
                          if ((v872 & 1) == 0)
                          {
                            do
                            {
                              if ((v871[12] & 0x8000000000000000) == 0)
                              {
                                v873 = sub_101257B18(&v1006, v871 + 12, (uint64_t)(v871 + 12));
                                v874 = v873;
                                v875 = (long long *)(v871 + 4);
                                v877 = v873[17];
                                v876 = v873[18];
                                if (v877 >= v876)
                                {
                                  v880 = v873[16];
                                  unint64_t v881 = 0xAAAAAAAAAAAAAAABLL * (v877 - v880);
                                  unint64_t v882 = v881 + 1;
                                  if (v881 + 1 > 0xAAAAAAAAAAAAAAALL) {
                                    sub_10006A748();
                                  }
                                  unint64_t v883 = 0xAAAAAAAAAAAAAAABLL * (v876 - v880);
                                  if (2 * v883 > v882) {
                                    unint64_t v882 = 2 * v883;
                                  }
                                  if (v883 >= 0x555555555555555) {
                                    unint64_t v884 = 0xAAAAAAAAAAAAAAALL;
                                  }
                                  else {
                                    unint64_t v884 = v882;
                                  }
                                  if (v884) {
                                    unint64_t v884 = (unint64_t)sub_100601864(v884);
                                  }
                                  else {
                                    uint64_t v885 = 0;
                                  }
                                  unint64_t v886 = v884 + 24 * v881;
                                  long long v887 = *v875;
                                  *(void *)(v886 + 16) = v871[6];
                                  *(_OWORD *)unint64_t v886 = v887;
                                  v889 = v874[16];
                                  v888 = v874[17];
                                  v890 = (uint64_t *)v886;
                                  if (v888 != v889)
                                  {
                                    do
                                    {
                                      long long v891 = *(_OWORD *)(v888 - 3);
                                      *(v890 - 1) = *(v888 - 1);
                                      *(_OWORD *)(v890 - 3) = v891;
                                      v890 -= 3;
                                      v888 -= 3;
                                    }
                                    while (v888 != v889);
                                    v888 = v874[16];
                                  }
                                  v879 = (uint64_t *)(v886 + 24);
                                  v874[16] = v890;
                                  v874[17] = (uint64_t *)(v886 + 24);
                                  v874[18] = (uint64_t *)(v884 + 24 * v885);
                                  if (v888) {
                                    operator delete(v888);
                                  }
                                }
                                else
                                {
                                  long long v878 = *v875;
                                  v877[2] = v871[6];
                                  *(_OWORD *)v877 = v878;
                                  v879 = v877 + 3;
                                }
                                v874[17] = v879;
                              }
                              v892 = (uint64_t *)v871[1];
                              if (v892)
                              {
                                do
                                {
                                  v893 = v892;
                                  v892 = (uint64_t *)*v892;
                                }
                                while (v892);
                              }
                              else
                              {
                                do
                                {
                                  v893 = (uint64_t *)v871[2];
                                  _ZF = *v893 == (void)v871;
                                  v871 = v893;
                                }
                                while (!_ZF);
                              }
                              v871 = v893;
                            }
                            while (v893 != (uint64_t *)&v1007);
                            v871 = v1006;
                          }
                          if (v871 != (uint64_t *)&v1007)
                          {
                            while (2)
                            {
                              if (!*((unsigned char *)v871 + 89) && v871[12] == -1)
                              {
                                memset(v1039, 0, sizeof(v1039));
                                v1028.i64[0] = v871[6];
                                int64x2_t v1027 = *((int64x2_t *)v871 + 2);
                                sub_10125A534((char *)v1039, v1005, *((uint64_t *)&v1005 + 1), v1009, v1027.i64, *((unsigned __int8 *)v871 + 88), 0);
                                v895 = (uint64_t *)v871[16];
                                v894 = (uint64_t *)v871[17];
                                while (v895 != v894)
                                {
                                  v896 = v1007;
                                  if (v1007)
                                  {
                                    uint64_t v898 = *v895;
                                    v897 = (void *)v895[1];
                                    v899 = &v1007;
                                    uint64_t v900 = v895[2];
                                    do
                                    {
                                      v901 = v896;
                                      v902 = v899;
                                      uint64_t v903 = v896[4];
                                      BOOL v904 = v903 < v898;
                                      if (v903 == v898)
                                      {
                                        v905 = (void *)v896[5];
                                        BOOL v904 = (uint64_t)v905 < (uint64_t)v897;
                                        if (v905 == v897) {
                                          BOOL v904 = v896[6] < v900;
                                        }
                                      }
                                      int v906 = v904;
                                      v907 = v896 + 1;
                                      if (!v906)
                                      {
                                        v907 = v901;
                                        v899 = (void **)v901;
                                      }
                                      v896 = (void *)*v907;
                                    }
                                    while (v896);
                                    if (&v1007 != v899)
                                    {
                                      if (v906) {
                                        v908 = v902;
                                      }
                                      else {
                                        v908 = v901;
                                      }
                                      uint64_t v909 = v908[4];
                                      BOOL v910 = v898 < v909;
                                      if (v898 == v909)
                                      {
                                        v911 = v906 ? v902 : (void **)v901;
                                        v912 = v911[5];
                                        BOOL v910 = (uint64_t)v897 < (uint64_t)v912;
                                        if (v897 == v912)
                                        {
                                          if (v906) {
                                            v913 = v902;
                                          }
                                          else {
                                            v913 = v901;
                                          }
                                          BOOL v910 = v900 < v913[6];
                                        }
                                      }
                                      if (!v910)
                                      {
                                        v914 = v906 ? v902 : (void **)v901;
                                        if (!*((unsigned char *)v914 + 89))
                                        {
                                          *(_OWORD *)long long __p = *(_OWORD *)v895;
                                          v1038 = (char *)v895[2];
                                          if (v906) {
                                            v915 = v902;
                                          }
                                          else {
                                            v915 = v901;
                                          }
                                          sub_10125A534((char *)v1039, v1005, *((uint64_t *)&v1005 + 1), v1009, (uint64_t *)__p, *((unsigned __int8 *)v915 + 88), 1);
                                          v894 = (uint64_t *)v871[17];
                                        }
                                      }
                                    }
                                  }
                                  v895 += 3;
                                }
                                v916 = (double *)v1039[1];
                                unint64_t v917 = ((char *)v1039[1] - (char *)v1039[0]) >> 4;
                                for (iuint64_t i = (uint64_t *)v1039[3]; ii != v1039[4]; ii += 3)
                                {
                                  uint64_t v919 = *ii;
                                  uint64_t v920 = ii[1];
                                  v917 += (v920 - v919) >> 4;
                                }
                                if (v917 >= 4)
                                {
                                  double v921 = 0.0;
                                  double v922 = 0.0;
                                  if ((void *)((char *)v1039[1] - (char *)v1039[0]) >= (void *)0x40)
                                  {
                                    v923 = (double *)((char *)v1039[0] + 16);
                                    if ((char *)v1039[0] + 16 != v1039[1])
                                    {
                                      unint64_t v924 = 0;
                                      do
                                      {
                                        double v925 = *(v923 - 2);
                                        double v926 = *v923;
                                        if (v925 != *v923)
                                        {
                                          if ((*(void *)&v925 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                                            || (*(void *)&v926 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                                          {
                                            goto LABEL_1528;
                                          }
                                          double v928 = vabdd_f64(v925, v926);
                                          double v929 = fabs(v925);
                                          double v930 = fabs(v926);
                                          if (v929 < v930) {
                                            double v929 = v930;
                                          }
                                          double v931 = v929 >= 1.0 ? v929 * 2.22044605e-16 : 2.22044605e-16;
                                          if (v928 > v931)
                                          {
LABEL_1528:
                                            double v922 = v922 + sub_101232970(v923 - 2, v923);
                                            v924 += sub_101232BC4(v923 - 2, v923);
                                          }
                                        }
                                        v923 += 2;
                                      }
                                      while (v923 != v916);
                                      if (v924)
                                      {
                                        uint64_t v932 = (v924 >> 1) + 1;
                                        double v933 = fabs(v922);
                                        double v934 = -v933;
                                        double v935 = -(v933 - (double)(unint64_t)v932 * 6.28318531);
                                        if (v922 <= 0.0) {
                                          double v922 = v935;
                                        }
                                        else {
                                          double v922 = -(v934 + (double)(unint64_t)v932 * 6.28318531);
                                        }
                                      }
                                    }
                                  }
                                  v936 = v1039[3];
                                  if (v1039[3] != v1039[4])
                                  {
                                    double v921 = 0.0;
                                    do
                                    {
                                      v937 = (double *)v936[1];
                                      v938 = (double *)(*v936 + 16);
                                      BOOL v939 = (unint64_t)v937 - *v936 < 0x40 || v938 == v937;
                                      double v940 = 0.0;
                                      if (!v939)
                                      {
                                        unint64_t v941 = 0;
                                        do
                                        {
                                          double v942 = *(v938 - 2);
                                          double v943 = *v938;
                                          if (v942 != *v938)
                                          {
                                            if ((*(void *)&v942 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                                              || (*(void *)&v943 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                                            {
                                              goto LABEL_1554;
                                            }
                                            double v945 = vabdd_f64(v942, v943);
                                            double v946 = fabs(v942);
                                            double v947 = fabs(v943);
                                            if (v946 < v947) {
                                              double v946 = v947;
                                            }
                                            double v948 = v946 >= 1.0 ? v946 * 2.22044605e-16 : 2.22044605e-16;
                                            if (v945 > v948)
                                            {
LABEL_1554:
                                              double v940 = v940 + sub_101232970(v938 - 2, v938);
                                              v941 += sub_101232BC4(v938 - 2, v938);
                                            }
                                          }
                                          v938 += 2;
                                        }
                                        while (v938 != v937);
                                        if (v941)
                                        {
                                          uint64_t v949 = (v941 >> 1) + 1;
                                          double v950 = fabs(v940);
                                          double v951 = -v950;
                                          double v952 = -(v950 - (double)(unint64_t)v949 * 6.28318531);
                                          if (v940 <= 0.0) {
                                            double v940 = v952;
                                          }
                                          else {
                                            double v940 = -(v951 + (double)(unint64_t)v949 * 6.28318531);
                                          }
                                        }
                                      }
                                      double v921 = v921 + v940;
                                      v936 += 3;
                                    }
                                    while (v936 != v1039[4]);
                                  }
                                  double v953 = v922 + v921;
                                  if (v922 + v921 != 0.0)
                                  {
                                    if (COERCE_UNSIGNED_INT64(fabs(v922 + v921)) > 0x7FEFFFFFFFFFFFFFLL)
                                    {
                                      if (v953 <= 0.0) {
                                        goto LABEL_1580;
                                      }
                                    }
                                    else
                                    {
                                      double v954 = fabs(v953);
                                      double v955 = 2.22044605e-16;
                                      if (v954 >= 1.0) {
                                        double v955 = v954 * 2.22044605e-16;
                                      }
                                      if (v953 <= 0.0 || v954 <= v955) {
                                        goto LABEL_1580;
                                      }
                                    }
                                    v957 = operator new(0x40uLL);
                                    void *v957 = 0;
                                    v957[1] = 0;
                                    sub_10125AA90(v957 + 2, (uint64_t)v1039);
                                    v957[1] = v967;
                                    uint64_t v958 = *v967;
                                    void *v957 = *v967;
                                    *(void *)(v958 + 8) = v957;
                                    uint64_t *v967 = (uint64_t)v957;
                                    ++v967[2];
                                  }
                                }
LABEL_1580:
                                v1024 = &v1039[3];
                                sub_101232E40((void ***)&v1024);
                                if (v1039[0])
                                {
                                  v1039[1] = v1039[0];
                                  operator delete(v1039[0]);
                                }
                              }
                              v959 = (uint64_t *)v871[1];
                              if (v959)
                              {
                                do
                                {
                                  v960 = v959;
                                  v959 = (uint64_t *)*v959;
                                }
                                while (v959);
                              }
                              else
                              {
                                do
                                {
                                  v960 = (uint64_t *)v871[2];
                                  _ZF = *v960 == (void)v871;
                                  v871 = v960;
                                }
                                while (!_ZF);
                              }
                              v871 = v960;
                              if (v960 == (uint64_t *)&v1007) {
                                break;
                              }
                              continue;
                            }
                          }
LABEL_1588:
                          sub_101257A14(v1007);
                          sub_1009C7264((uint64_t)v1009);
                          sub_10005D144(v1013[0]);
                          sub_100D15E74(v1015);
                          sub_10125ABEC((uint64_t)&v1018);
                          return v967;
                        }
LABEL_1417:
                        *(_OWORD *)v1039 = v1005;
                        v1039[2] = v1009;
                        v1039[3] = &v1006;
                        v1039[5] = 0;
                        v1039[4] = a5;
                        if (0x8E38E38E38E38E39 * (v767 - v766) <= 0x10)
                        {
                          if (v766 != v767)
                          {
                            v868 = v766;
                            do
                            {
                              uint64_t v869 = (uint64_t)v868;
                              v868 += 9;
                              if (v868 != v767)
                              {
                                uint64_t v870 = (uint64_t)v868;
                                do
                                {
                                  sub_101258348((uint64_t)v1039, v869, v870);
                                  v870 += 72;
                                }
                                while ((uint64_t *)v870 != v767);
                              }
                            }
                            while (v868 != v767);
                          }
                        }
                        else
                        {
                          __p[1] = 0;
                          __p[0] = 0;
                          v1038 = 0;
                          int64x2_t v1027 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
                          int64x2_t v1028 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
                          if (v766 != v767)
                          {
                            v857 = 0;
                            v858 = (double *)v766;
                            do
                            {
                              sub_101240044((double *)v1027.i64, v858 + 5);
                              if (v857 >= v1038)
                              {
                                v860 = (char *)__p[0];
                                uint64_t v861 = (v857 - (char *)__p[0]) >> 3;
                                unint64_t v862 = v861 + 1;
                                if ((unint64_t)(v861 + 1) >> 61) {
                                  sub_10006A748();
                                }
                                uint64_t v863 = v1038 - (char *)__p[0];
                                if ((v1038 - (char *)__p[0]) >> 2 > v862) {
                                  unint64_t v862 = v863 >> 2;
                                }
                                if ((unint64_t)v863 >= 0x7FFFFFFFFFFFFFF8) {
                                  unint64_t v864 = 0x1FFFFFFFFFFFFFFFLL;
                                }
                                else {
                                  unint64_t v864 = v862;
                                }
                                if (v864) {
                                  unint64_t v864 = (unint64_t)sub_100048350(v864);
                                }
                                else {
                                  uint64_t v865 = 0;
                                }
                                v866 = (double **)(v864 + 8 * v861);
                                *v866 = v858;
                                v859 = v866 + 1;
                                if (v857 != v860)
                                {
                                  do
                                  {
                                    v867 = (double *)*((void *)v857 - 1);
                                    v857 -= 8;
                                    *--v866 = v867;
                                  }
                                  while (v857 != v860);
                                  v857 = (char *)__p[0];
                                }
                                __p[0] = v866;
                                v1038 = (char *)(v864 + 8 * v865);
                                if (v857) {
                                  operator delete(v857);
                                }
                              }
                              else
                              {
                                *(void *)v857 = v858;
                                v859 = v857 + 8;
                              }
                              __p[1] = v859;
                              v858 += 9;
                              v857 = (char *)v859;
                            }
                            while (v858 != (double *)v767);
                          }
                          sub_101257F40((double *)v1027.i64, (uint64_t **)__p, 0, (uint64_t)v1039);
                          if (__p[0]) {
                            operator delete(__p[0]);
                          }
                        }
                        char v834 = 0;
                        goto LABEL_1446;
                      }
                    }
                  }
                  while (1)
                  {
                    v688 = (unsigned __int8 *)v1013[0];
                    if (!v1013[0]) {
                      break;
                    }
                    v690 = v687[4];
                    v689 = v687[5];
                    v691 = (unsigned __int8 *)v1013;
                    v692 = v687[6];
                    do
                    {
                      v693 = v688;
                      v694 = v691;
                      v695 = (void *)*((void *)v688 + 4);
                      BOOL v696 = (uint64_t)v695 < (uint64_t)v690;
                      if (v695 == v690)
                      {
                        v697 = (void *)*((void *)v688 + 5);
                        BOOL v696 = (uint64_t)v697 < (uint64_t)v689;
                        if (v697 == v689) {
                          BOOL v696 = *((void *)v688 + 6) < (uint64_t)v692;
                        }
                      }
                      int v698 = v696;
                      v699 = v688 + 8;
                      if (!v698)
                      {
                        v699 = v693;
                        v691 = v693;
                      }
                      v688 = *(unsigned __int8 **)v699;
                    }
                    while (v688);
                    if (v1013 == (void **)v691) {
                      break;
                    }
                    if (v698) {
                      v700 = v694;
                    }
                    else {
                      v700 = v693;
                    }
                    v701 = (void *)*((void *)v700 + 4);
                    if (v690 == v701)
                    {
                      if (v698) {
                        v702 = v694;
                      }
                      else {
                        v702 = v693;
                      }
                      v703 = (void *)*((void *)v702 + 5);
                      if (v689 == v703)
                      {
                        if (v698) {
                          v704 = v694;
                        }
                        else {
                          v704 = v693;
                        }
                        if ((uint64_t)v692 < *((void *)v704 + 6)) {
                          break;
                        }
                      }
                      else if ((uint64_t)v689 < (uint64_t)v703)
                      {
                        break;
                      }
                    }
                    else if ((uint64_t)v690 < (uint64_t)v701)
                    {
                      break;
                    }
                    if (v698) {
                      v693 = v694;
                    }
                    int v705 = v693[56];
                    int v706 = v693[57];
                    int v707 = v693[58];
LABEL_1236:
                    if (v705 | v706) {
                      goto LABEL_1273;
                    }
                    v708 = v687[4];
                    if (v708 == (void *)1)
                    {
                      int v709 = sub_101257868((double *)v687 + 8, *((double ***)&v1005 + 1), v1005);
                    }
                    else
                    {
                      if (v708) {
                        goto LABEL_1242;
                      }
                      int v709 = sub_101257868((double *)v687 + 8, (double **)v1005, *((uint64_t *)&v1005 + 1));
                    }
                    int v707 = v709 > 0;
LABEL_1242:
                    if (v707)
                    {
                      int64x2_t v710 = *(int64x2_t *)(v687 + 9);
                      int64x2_t v1027 = *(int64x2_t *)(v687 + 7);
                      int64x2_t v1028 = v710;
                      long long v711 = *(_OWORD *)((char *)v687 + 105);
                      *(_OWORD *)v1039 = *(_OWORD *)((char *)v687 + 89);
                      *(_OWORD *)&v1039[2] = v711;
                      v712 = v687[16];
                      *(void **)((char *)&v1039[3] + 7) = v687[15];
                      v713 = v687[17];
                      int64_t v714 = v713 - v712;
                      if (v713 == v712)
                      {
                        v715 = 0;
                        v716 = 0;
                      }
                      else
                      {
                        if (0xAAAAAAAAAAAAAAABLL * (v714 >> 3) > 0xAAAAAAAAAAAAAAALL) {
                          sub_10006A748();
                        }
                        v715 = (char *)sub_100601864(0xAAAAAAAAAAAAAAABLL * (v714 >> 3));
                        memmove(v715, v712, v714);
                        v716 = &v715[8 * (v714 >> 3)];
                      }
                      v717 = sub_101257B18(&v1006, (uint64_t *)v687 + 4, (uint64_t)(v687 + 4));
                      v718 = v717;
                      v719 = v717 + 16;
                      v720 = v717[16];
                      int64x2_t v721 = v1028;
                      *(int64x2_t *)(v717 + 7) = v1027;
                      *(int64x2_t *)(v717 + 9) = v721;
                      long long v722 = *(_OWORD *)&v1039[2];
                      *(_OWORD *)((char *)v717 + 89) = *(_OWORD *)v1039;
                      *((unsigned char *)v717 + 88) = 0;
                      *(_OWORD *)((char *)v717 + 105) = v722;
                      v717[15] = *(uint64_t **)((char *)&v1039[3] + 7);
                      size_t v723 = v716 - v715;
                      unint64_t v724 = 0xAAAAAAAAAAAAAAABLL * ((v716 - v715) >> 3);
                      uint64_t v725 = (uint64_t)v717[18];
                      if (0xAAAAAAAAAAAAAAABLL * ((v725 - (uint64_t)v720) >> 3) >= v724)
                      {
                        v730 = v717 + 17;
                        v733 = v717[17];
                        unint64_t v734 = 0xAAAAAAAAAAAAAAABLL * (v733 - v720);
                        if (v734 >= v724)
                        {
                          if (v716 != v715) {
                            memmove(v720, v715, v716 - v715);
                          }
                        }
                        else
                        {
                          if (v733 != v720)
                          {
                            memmove(v720, v715, (char *)v733 - (char *)v720);
                            v720 = *v730;
                          }
                          v732 = &v715[24 * v734];
                          size_t v723 = v716 - v732;
                          if (v716 != v732)
                          {
                            v729 = (char *)v720;
LABEL_1264:
                            memmove(v729, v732, v723);
                          }
                        }
                      }
                      else
                      {
                        if (v720)
                        {
                          v717[17] = v720;
                          operator delete(v720);
                          uint64_t v725 = 0;
                          void *v719 = 0;
                          v719[1] = 0;
                          v719[2] = 0;
                        }
                        if (v724 > 0xAAAAAAAAAAAAAAALL) {
                          goto LABEL_1606;
                        }
                        unint64_t v726 = 0xAAAAAAAAAAAAAAABLL * (v725 >> 3);
                        uint64_t v727 = 2 * v726;
                        if (2 * v726 <= v724) {
                          uint64_t v727 = 0xAAAAAAAAAAAAAAABLL * ((v716 - v715) >> 3);
                        }
                        unint64_t v728 = v726 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v727;
                        if (v728 > 0xAAAAAAAAAAAAAAALL) {
LABEL_1606:
                        }
                          sub_10006A748();
                        v729 = (char *)sub_100601864(v728);
                        v720 = (uint64_t *)v729;
                        v718[17] = (uint64_t *)v729;
                        v730 = v718 + 17;
                        *(v730 - 1) = (uint64_t *)v729;
                        v730[1] = (uint64_t *)&v729[24 * v731];
                        if (v716 != v715)
                        {
                          v732 = v715;
                          goto LABEL_1264;
                        }
                      }
                      *v730 = (uint64_t *)((char *)v720 + v723);
                      if (v715) {
                        operator delete(v715);
                      }
                    }
LABEL_1273:
                    v735 = (void **)v687[1];
                    if (v735)
                    {
                      do
                      {
                        v736 = v735;
                        v735 = (void **)*v735;
                      }
                      while (v735);
                    }
                    else
                    {
                      do
                      {
                        v736 = (void **)v687[2];
                        _ZF = *v736 == v687;
                        v687 = v736;
                      }
                      while (!_ZF);
                    }
                    v687 = v736;
                    if (v736 == &__p[1]) {
                      goto LABEL_1279;
                    }
                  }
                  int v705 = 0;
                  int v706 = 0;
                  int v707 = 0;
                  goto LABEL_1236;
                }
LABEL_1067:
                sub_10005D144((void *)v1039[1]);
                v577 = v574 + 11;
                v579 = v574 + 7;
                uint64_t v578 = v997;
                int v580 = v992;
              }
              break;
            }
            if (v586 >= v582) {
              v622 = v584;
            }
            else {
              v622 = v585;
            }
            if ((*((_DWORD *)v622 + 12) - 1) >= 2)
            {
              if (v580)
              {
                int v580 = 0;
                uint64_t v578 = *(void *)(v576[6] + 32);
              }
              else
              {
                if (v578 != *(void *)(v576[6] + 32)) {
                  goto LABEL_1084;
                }
                int v580 = 0;
              }
            }
            v623 = (uint64_t *)v576[1];
            if (v623)
            {
              do
              {
                v624 = v623;
                v623 = (uint64_t *)*v623;
              }
              while (v623);
            }
            else
            {
              do
              {
                v624 = (uint64_t *)v576[2];
                _ZF = *v624 == (void)v576;
                v576 = v624;
              }
              while (!_ZF);
            }
            v576 = v624;
            if (v624 == v577) {
              goto LABEL_1082;
            }
            goto LABEL_990;
          }
          break;
        }
        v458 %= v450;
        v454 = &v447[40 * v458];
        goto LABEL_797;
      }
      if (!*(unsigned char *)(v321 + 32))
      {
        uint64_t v322 = *(void *)(v321 + 48);
        if (v322 == *(void *)(v321 + 216))
        {
          uint64_t v323 = v322 ? v1005 : *((void *)&v1005 + 1);
          if ((int)sub_10124A234((double *)v321, v323) <= 0)
          {
            *(unsigned char *)(v321 + 144) = 0;
            *(unsigned char *)(v321 + 312) = 0;
          }
        }
      }
      v321 += 376;
      if (v321 - *v320 == 6016)
      {
        uint64_t v324 = v320[1];
        ++v320;
        uint64_t v321 = v324;
      }
      uint64_t v283 = *((void *)&v1018 + 1);
      uint64_t v282 = v1019;
      continue;
    }
  }
  return a4;
}

void sub_10123CA84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  if (__p) {
    operator delete(__p);
  }
  sub_101257A14(a33);
  sub_1009C7264((uint64_t)&a35);
  sub_10005D144((void *)a43);
  sub_100D15E74((void *)a46);
  sub_10125ABEC((uint64_t)&a49);
  _Unwind_Resume(a1);
}

void sub_10123CCD0(uint64_t a1, uint64_t a2, unsigned int a3)
{
  *(void *)(a2 + 8) = *(void *)a2;
  uint64_t v5 = a3;
  double v6 = *(double **)a1;
  uint64_t v7 = *(double **)(a1 + 8);
  if ((unint64_t)v7 - *(void *)a1 >= 0x20)
  {
    uint64_t v25 = v5;
    uint64_t v26 = -1;
    uint64_t v27 = -1;
    sub_10123CDE0((void **)a2, v6, v7, (uint64_t)&v25);
  }
  BOOL v9 = *(double ***)(a1 + 24);
  uint64_t v8 = *(double ***)(a1 + 32);
  if (v9 != v8)
  {
    uint64_t v10 = 0;
    do
    {
      unint64_t v11 = *v9;
      uint64_t v12 = v9[1];
      if ((unint64_t)((char *)v12 - (char *)*v9) >= 0x20)
      {
        uint64_t v25 = v5;
        uint64_t v26 = -1;
        uint64_t v27 = v10;
        sub_10123CDE0((void **)a2, v11, v12, (uint64_t)&v25);
        uint64_t v8 = *(double ***)(a1 + 32);
      }
      ++v10;
      v9 += 3;
    }
    while (v9 != v8);
  }
  uint64_t v13 = *(float64x2_t **)a2;
  unint64_t v14 = *(float64x2_t **)(a2 + 8);
  if (*(float64x2_t **)a2 != v14)
  {
    __asm { FMOV            V0.2D, #1.0 }
    do
    {
      float64x2_t v20 = v13[2];
      float64x2_t v21 = v13[3];
      float64x2_t v22 = vabsq_f64(v20);
      float64x2_t v23 = vsubq_f64(v20, (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(_Q0, v22), (int8x16_t)xmmword_1015E0D10, (int8x16_t)vmulq_f64(v22, (float64x2_t)xmmword_1015E0D10)));
      float64x2_t v24 = vabsq_f64(v21);
      v13[2] = v23;
      v13[3] = vaddq_f64(v21, (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(_Q0, v24), (int8x16_t)xmmword_1015E0D10, (int8x16_t)vmulq_f64(v24, (float64x2_t)xmmword_1015E0D10)));
      uint64_t v13 = (float64x2_t *)((char *)v13 + 120);
    }
    while (v13 != v14);
  }
}

void sub_10123CDE0(void **a1, double *a2, double *a3, uint64_t a4)
{
  if (a3 == a2) {
    return;
  }
  uint64_t v4 = a2;
  *(void *)double v109 = -1;
  *(void *)&v109[8] = -1;
  *(_OWORD *)&v109[16] = 0uLL;
  v110.i64[0] = 0;
  v110.i64[1] = -1;
  uint64_t v111 = 0;
  int64x2_t v101 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  int64x2_t v102 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  int64x2_t v107 = v102;
  int64x2_t v108 = v101;
  *(void *)char v106 = 0;
  memset(&v106[8], 255, 24);
  double v6 = a1[1];
  unint64_t v7 = 0xEEEEEEEEEEEEEEEFLL * (((char *)v6 - (unsigned char *)*a1) >> 3);
  uint64_t v8 = a2 + 2;
  if (a2 + 2 == a3) {
    goto LABEL_131;
  }
  unint64_t v100 = 0xEEEEEEEEEEEEEEEFLL * (((char *)v6 - (unsigned char *)*a1) >> 3);
  unint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v103 = ((char *)a3 - (char *)a2) >> 4;
  double v14 = *a2;
  double v13 = a2[1];
  char v105 = 1;
  do
  {
    double v15 = v4[3];
    uint64_t v4 = v8;
    double v16 = *v8;
    double v17 = vabdd_f64(*v8, v14);
    double v18 = 180.0;
    if (v17 == 180.0) {
      goto LABEL_5;
    }
    double v19 = v16 - v14;
    if (COERCE__INT64(fabs(v16 - v14)) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      double v25 = fabs(v17 + -180.0);
      double v18 = 180.0;
      if (v17 < 180.0) {
        double v17 = 180.0;
      }
      double v26 = v17 >= 1.0 ? v17 * 2.22044605e-16 : 2.22044605e-16;
      if (v25 <= v26) {
        goto LABEL_5;
      }
    }
    if (v19 <= 180.0)
    {
      if (v19 < -180.0)
      {
        double v18 = fmod(v19 + -180.0, 360.0) + 180.0;
LABEL_5:
        double v19 = v18;
      }
    }
    else
    {
      double v18 = 180.0;
      double v19 = fmod(v19 + 180.0, 360.0) + -180.0;
      if (v19 == -180.0) {
        goto LABEL_5;
      }
      BOOL v27 = ((*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
         && (*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
      if (!v27 || *(void *)&v19 == 0)
      {
        double v18 = 180.0;
        double v29 = fabs(v19 + 180.0);
        double v30 = fabs(v19);
        if (v30 < 180.0) {
          double v30 = 180.0;
        }
        double v31 = v30 >= 1.0 ? v30 * 2.22044605e-16 : 2.22044605e-16;
        if (v29 <= v31) {
          goto LABEL_5;
        }
      }
    }
    if (v19 >= 0.0) {
      int v20 = 0;
    }
    else {
      int v20 = -1;
    }
    if (v19 > 0.0) {
      int v21 = 1;
    }
    else {
      int v21 = v20;
    }
    if (v15 >= v13) {
      int v22 = 0;
    }
    else {
      int v22 = -1;
    }
    if (v15 > v13) {
      int v23 = 1;
    }
    else {
      int v23 = v22;
    }
    if (v21) {
      goto LABEL_67;
    }
    if (v14 != v16)
    {
      if ((*(void *)&v14 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (*(void *)&v16 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_66;
      }
      double v32 = vabdd_f64(v14, v16);
      double v33 = fabs(v14);
      double v34 = fabs(v16);
      if (v33 < v34) {
        double v33 = v34;
      }
      double v35 = v33 >= 1.0 ? v33 * 2.22044605e-16 : 2.22044605e-16;
      if (v32 > v35) {
        goto LABEL_66;
      }
    }
    if (v13 != v15)
    {
      if ((*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (*(void *)&v15 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_66;
      }
      double v36 = vabdd_f64(v13, v15);
      double v37 = fabs(v13);
      double v38 = fabs(v15);
      if (v37 < v38) {
        double v37 = v38;
      }
      double v39 = v37 >= 1.0 ? v37 * 2.22044605e-16 : 2.22044605e-16;
      if (v36 > v39)
      {
LABEL_66:
        int v21 = 0;
LABEL_67:
        int v24 = 0;
        if (!v10) {
          goto LABEL_95;
        }
        goto LABEL_68;
      }
    }
    int v24 = 1;
    int v21 = -99;
    int v23 = -99;
    if (!v10) {
      goto LABEL_95;
    }
LABEL_68:
    if (v21 == *(_DWORD *)v106 && v10 <= 0xA && v23 == *(_DWORD *)&v106[4])
    {
      double v41 = *(double *)&v107.i64[1];
      double v40 = *(double *)v107.i64;
      double v43 = *(double *)&v108.i64[1];
      double v42 = *(double *)v108.i64;
      double v115 = v13;
      v116[0] = v14;
      sub_10123D770(v116, &v115, 1);
      double v44 = v116[0];
      double v115 = v15;
      v116[0] = v16;
      sub_10123D770(v116, &v115, 1);
      double v114 = v13;
      double v115 = v44;
      double v112 = v15;
      double v113 = v116[0];
      sub_10123DA18(&v115, &v114, &v113, &v112);
      v116[0] = v115;
      v116[1] = v114;
      v116[2] = v113;
      v116[3] = v112;
      double v45 = 1.79769313e308;
      if (v40 == 1.79769313e308 && v41 == 1.79769313e308 && v42 == -1.79769313e308 && v43 == -1.79769313e308)
      {
        double v46 = -1.79769313e308;
        double v41 = 1.79769313e308;
        double v43 = -1.79769313e308;
      }
      else
      {
        double v114 = v41;
        double v115 = v40;
        double v112 = v43;
        double v113 = v42;
        double v73 = vabdd_f64(v40, v42);
        if (v73 < 360.0)
        {
          if (COERCE__INT64(fabs(v40 - v42)) > 0x7FEFFFFFFFFFFFFFLL)
          {
            BOOL v74 = 0;
          }
          else
          {
            double v75 = vabdd_f64(360.0, v73);
            double v76 = fmax(v73, 360.0);
            if (v76 >= 1.0) {
              double v77 = v76 * 2.22044605e-16;
            }
            else {
              double v77 = 2.22044605e-16;
            }
            BOOL v74 = v75 <= v77;
          }
        }
        else
        {
          BOOL v74 = 1;
        }
        sub_10123F230(&v115, &v114, &v113, &v112, v74);
        double v45 = v115;
        double v46 = v113;
      }
      v116[4] = v45;
      v116[5] = v41;
      v116[6] = v46;
      v116[7] = v43;
      sub_10123E140(v116, (double *)v107.i64);
      uint64_t v72 = *(void *)&v109[16];
      goto LABEL_98;
    }
    double v47 = (int64x2_t *)a1[1];
    if (!v110.i8[0]) {
      unint64_t v100 = 0xEEEEEEEEEEEEEEEFLL * (((char *)v47 - (unsigned char *)*a1) >> 3);
    }
    uint64_t v48 = (int64x2_t *)a1[2];
    if (v47 >= v48)
    {
      unint64_t v52 = 0xEEEEEEEEEEEEEEEFLL * (((char *)v47 - (unsigned char *)*a1) >> 3);
      unint64_t v53 = v52 + 1;
      if (v52 + 1 > 0x222222222222222) {
        goto LABEL_135;
      }
      unint64_t v54 = 0xEEEEEEEEEEEEEEEFLL * (((char *)v48 - (unsigned char *)*a1) >> 3);
      if (2 * v54 > v53) {
        unint64_t v53 = 2 * v54;
      }
      if (v54 >= 0x111111111111111) {
        unint64_t v55 = 0x222222222222222;
      }
      else {
        unint64_t v55 = v53;
      }
      if (v55) {
        unint64_t v55 = (unint64_t)sub_100448470(v55);
      }
      else {
        uint64_t v56 = 0;
      }
      unint64_t v57 = v55 + 120 * v52;
      *(_OWORD *)unint64_t v57 = *(_OWORD *)v106;
      *(_OWORD *)(v57 + 16) = *(_OWORD *)&v106[16];
      int64x2_t v58 = v108;
      *(int64x2_t *)(v57 + 32) = v107;
      *(int64x2_t *)(v57 + 48) = v58;
      *(void *)(v57 + 112) = v111;
      int64x2_t v59 = v110;
      long long v60 = *(_OWORD *)v109;
      *(_OWORD *)(v57 + 80) = *(_OWORD *)&v109[16];
      *(int64x2_t *)(v57 + 96) = v59;
      *(_OWORD *)(v57 + 64) = v60;
      char v62 = (char *)*a1;
      char v61 = (char *)a1[1];
      double v63 = (char *)v57;
      if (v61 != *a1)
      {
        do
        {
          long long v64 = *(_OWORD *)(v61 - 120);
          long long v65 = *(_OWORD *)(v61 - 104);
          long long v66 = *(_OWORD *)(v61 - 88);
          *(_OWORD *)(v63 - 72) = *(_OWORD *)(v61 - 72);
          *(_OWORD *)(v63 - 88) = v66;
          *(_OWORD *)(v63 - 104) = v65;
          *(_OWORD *)(v63 - 120) = v64;
          long long v67 = *(_OWORD *)(v61 - 56);
          long long v68 = *(_OWORD *)(v61 - 40);
          long long v69 = *(_OWORD *)(v61 - 24);
          *((_WORD *)v63 - 4) = *((_WORD *)v61 - 4);
          *(_OWORD *)(v63 - 24) = v69;
          *(_OWORD *)(v63 - 40) = v68;
          *(_OWORD *)(v63 - 56) = v67;
          v63 -= 120;
          v61 -= 120;
        }
        while (v61 != v62);
        char v61 = (char *)*a1;
      }
      uint64_t v51 = (unint64_t *)(v57 + 120);
      *a1 = v63;
      a1[1] = (void *)(v57 + 120);
      a1[2] = (void *)(v55 + 120 * v56);
      if (v61) {
        operator delete(v61);
      }
    }
    else
    {
      int64x2_t v49 = *(int64x2_t *)&v109[16];
      v47[4] = *(int64x2_t *)v109;
      v47[5] = v49;
      v47[6] = v110;
      v47[7].i64[0] = v111;
      *double v47 = *(int64x2_t *)v106;
      v47[1] = *(int64x2_t *)&v106[16];
      int64x2_t v50 = v108;
      uint64_t v51 = &v47[7].u64[1];
      v47[2] = v107;
      v47[3] = v50;
    }
    a1[1] = v51;
    *(_OWORD *)&v109[8] = xmmword_1015E0D20;
    int64x2_t v107 = v102;
    int64x2_t v108 = v101;
    LOWORD(v111) = 0;
LABEL_95:
    *(_OWORD *)&v106[8] = *(_OWORD *)a4;
    *(void *)&v106[24] = *(void *)(a4 + 16);
    v110.i8[0] = v24;
    v110.i64[1] = v11;
    *(void *)double v109 = v12;
    *(void *)&v109[24] = v103;
    if (!(v24 & 1 | ((v105 & 1) == 0)))
    {
      char v105 = 0;
      LOBYTE(v111) = 1;
    }
    *(void *)char v106 = __PAIR64__(v23, v21);
    double v115 = v13;
    v116[0] = v14;
    sub_10123D770(v116, &v115, 1);
    double v70 = v116[0];
    double v115 = v15;
    v116[0] = v16;
    sub_10123D770(v116, &v115, 1);
    double v71 = v116[0];
    double v115 = v13;
    v116[0] = v70;
    double v114 = v71;
    double v113 = v15;
    sub_10123DA18(v116, &v115, &v114, &v113);
    uint64_t v72 = 0;
    *(double *)v107.i64 = v116[0];
    *(double *)&v107.i64[1] = v115;
    *(double *)v108.i64 = v114;
    *(double *)&v108.i64[1] = v113;
LABEL_98:
    ++v12;
    unint64_t v10 = v72 + 1;
    *(void *)&v109[8] = v12;
    *(void *)&v109[16] = v72 + 1;
    v11 += v24 ^ 1u;
    uint64_t v8 = v4 + 2;
    double v14 = v16;
    double v13 = v15;
  }
  while (v4 + 2 != a3);
  double v6 = a1[1];
  if (v10)
  {
    unint64_t v7 = v100;
    if (!v110.i8[0]) {
      unint64_t v7 = 0xEEEEEEEEEEEEEEEFLL * (((char *)v6 - (unsigned char *)*a1) >> 3);
    }
    uint64_t v78 = a1[2];
    if (v6 >= (_OWORD *)v78)
    {
      unint64_t v81 = 0xEEEEEEEEEEEEEEEFLL * (((char *)v6 - (unsigned char *)*a1) >> 3);
      if (v81 + 1 > 0x222222222222222) {
LABEL_135:
      }
        sub_10006A748();
      unint64_t v82 = 0xEEEEEEEEEEEEEEEFLL * ((v78 - (unsigned char *)*a1) >> 3);
      uint64_t v83 = 2 * v82;
      if (2 * v82 <= v81 + 1) {
        uint64_t v83 = v81 + 1;
      }
      if (v82 >= 0x111111111111111) {
        unint64_t v84 = 0x222222222222222;
      }
      else {
        unint64_t v84 = v83;
      }
      if (v84) {
        unint64_t v84 = (unint64_t)sub_100448470(v84);
      }
      else {
        uint64_t v85 = 0;
      }
      unint64_t v86 = v84 + 120 * v81;
      unint64_t v87 = v84 + 120 * v85;
      *(_OWORD *)unint64_t v86 = *(_OWORD *)v106;
      *(_OWORD *)(v86 + 16) = *(_OWORD *)&v106[16];
      int64x2_t v88 = v108;
      *(int64x2_t *)(v86 + 32) = v107;
      *(int64x2_t *)(v86 + 48) = v88;
      *(void *)(v86 + 112) = v111;
      int64x2_t v89 = v110;
      long long v90 = *(_OWORD *)v109;
      *(_OWORD *)(v86 + 80) = *(_OWORD *)&v109[16];
      *(int64x2_t *)(v86 + 96) = v89;
      *(_OWORD *)(v86 + 64) = v90;
      double v6 = (_OWORD *)(v86 + 120);
      double v92 = (char *)*a1;
      char v91 = (char *)a1[1];
      if (v91 != *a1)
      {
        do
        {
          long long v93 = *(_OWORD *)(v91 - 120);
          long long v94 = *(_OWORD *)(v91 - 104);
          long long v95 = *(_OWORD *)(v91 - 88);
          *(_OWORD *)(v86 - 72) = *(_OWORD *)(v91 - 72);
          *(_OWORD *)(v86 - 88) = v95;
          *(_OWORD *)(v86 - 104) = v94;
          *(_OWORD *)(v86 - 120) = v93;
          long long v96 = *(_OWORD *)(v91 - 56);
          long long v97 = *(_OWORD *)(v91 - 40);
          long long v98 = *(_OWORD *)(v91 - 24);
          *(_WORD *)(v86 - 8) = *((_WORD *)v91 - 4);
          *(_OWORD *)(v86 - 24) = v98;
          *(_OWORD *)(v86 - 40) = v97;
          *(_OWORD *)(v86 - 56) = v96;
          v86 -= 120;
          v91 -= 120;
        }
        while (v91 != v92);
        char v91 = (char *)*a1;
      }
      *a1 = (void *)v86;
      a1[1] = v6;
      a1[2] = (void *)v87;
      if (v91) {
        operator delete(v91);
      }
    }
    else
    {
      long long v79 = *(_OWORD *)&v109[16];
      v6[4] = *(_OWORD *)v109;
      v6[5] = v79;
      void v6[6] = v110;
      *((void *)v6 + 14) = v111;
      _OWORD *v6 = *(_OWORD *)v106;
      v6[1] = *(_OWORD *)&v106[16];
      int64x2_t v80 = v108;
      v6[2] = v107;
      v6[3] = v80;
      double v6 = (_OWORD *)((char *)v6 + 120);
    }
    a1[1] = v6;
  }
  else
  {
    unint64_t v7 = v100;
  }
LABEL_131:
  double v99 = *a1;
  if (v7 < 0xEEEEEEEEEEEEEEEFLL * (((char *)v6 - (unsigned char *)*a1) >> 3) && !v99[120 * v7 + 96]) {
    v99[120 * v7 + 113] = 1;
  }
}

void sub_10123D770(double *a1, double *a2, int a3)
{
  double v6 = *a1;
  double v7 = fabs(*a1);
  double v8 = 180.0;
  if (v7 == 180.0) {
    goto LABEL_2;
  }
  if ((*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v10 = fabs(v7 + -180.0);
    double v8 = 180.0;
    if (v7 < 180.0) {
      double v7 = 180.0;
    }
    double v11 = v7 >= 1.0 ? v7 * 2.22044605e-16 : 2.22044605e-16;
    if (v10 <= v11) {
      goto LABEL_2;
    }
  }
  double v8 = 180.0;
  if (v6 <= 180.0)
  {
    if (v6 >= -180.0) {
      goto LABEL_3;
    }
    double v8 = fmod(v6 + -180.0, 360.0) + 180.0;
    goto LABEL_2;
  }
  double v6 = fmod(v6 + 180.0, 360.0) + -180.0;
  *a1 = v6;
  if (v6 == -180.0) {
    goto LABEL_2;
  }
  BOOL v12 = ((*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
     && (*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
  if (!v12 || *(void *)&v6 == 0)
  {
    double v8 = 180.0;
    double v14 = fabs(v6 + 180.0);
    double v15 = fabs(v6);
    if (v15 < 180.0) {
      double v15 = 180.0;
    }
    double v16 = v15 >= 1.0 ? v15 * 2.22044605e-16 : 2.22044605e-16;
    if (v14 <= v16)
    {
LABEL_2:
      *a1 = v8;
      double v6 = v8;
    }
  }
  if (!a3) {
    goto LABEL_37;
  }
LABEL_3:
  double v9 = fabs(*a2);
  if (v9 == 90.0) {
    goto LABEL_5;
  }
  if ((*(void *)a2 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    goto LABEL_37;
  }
  double v17 = fabs(v9 + -90.0);
  if (v9 < 90.0) {
    double v9 = 90.0;
  }
  double v18 = v9 >= 1.0 ? v9 * 2.22044605e-16 : 2.22044605e-16;
  if (v17 <= v18)
  {
LABEL_5:
    *a1 = 0.0;
    double v6 = 0.0;
  }
  else
  {
LABEL_37:
    if (v6 <= -180.0) {
      goto LABEL_52;
    }
    if ((*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
    {
      if (v6 <= 180.0) {
        return;
      }
LABEL_49:
      __assert_rtn("apply", "normalize_spheroidal_coordinates.hpp", 312, "! math::larger(longitude, constants::max_longitude())");
    }
  }
  double v19 = fabs(v6 + 180.0);
  double v20 = fabs(v6);
  if (v20 < 180.0) {
    double v20 = 180.0;
  }
  if (v20 >= 1.0) {
    double v21 = v20 * 2.22044605e-16;
  }
  else {
    double v21 = 2.22044605e-16;
  }
  if (v19 <= v21) {
LABEL_52:
  }
    __assert_rtn("apply", "normalize_spheroidal_coordinates.hpp", 311, "math::smaller(constants::min_longitude(), longitude)");
  if (v6 > 180.0 && fabs(v6 + -180.0) > v21) {
    goto LABEL_49;
  }
}

void sub_10123DA18(void *a1, double *a2, void *a3, double *a4)
{
  double v8 = fabs(*a2);
  double v9 = 90.0;
  if (v8 == 90.0)
  {
    BOOL v10 = 1;
  }
  else if ((*(void *)a2 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    BOOL v10 = 0;
  }
  else
  {
    double v11 = fabs(v8 + -90.0);
    if (v8 < 90.0) {
      double v8 = 90.0;
    }
    if (v8 >= 1.0) {
      double v12 = v8 * 2.22044605e-16;
    }
    else {
      double v12 = 2.22044605e-16;
    }
    BOOL v10 = v11 <= v12;
  }
  double v13 = fabs(*a4);
  if (v13 == 90.0)
  {
    BOOL v14 = 1;
  }
  else
  {
    if ((*(void *)a4 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
    {
      BOOL v14 = 0;
      BOOL v17 = !v10;
      int v18 = 1;
      goto LABEL_24;
    }
    double v15 = fabs(v13 + -90.0);
    if (v13 >= 90.0) {
      double v9 = v13;
    }
    if (v9 >= 1.0) {
      double v16 = v9 * 2.22044605e-16;
    }
    else {
      double v16 = 2.22044605e-16;
    }
    BOOL v14 = v15 <= v16;
  }
  BOOL v17 = !v10;
  int v18 = !v14;
  if (v10 && (v18 & 1) == 0)
  {
    *a1 = 0;
    *a3 = 0;
    goto LABEL_29;
  }
LABEL_24:
  if (v17 || v14)
  {
    if (((v10 | v18) & 1) == 0) {
      *a3 = *a1;
    }
  }
  else
  {
    BOOL v14 = 0;
    *a1 = *a3;
  }
LABEL_29:
  double v19 = *(double *)a1;
  double v20 = *(double *)a3;
  if (*(double *)a1 == *(double *)a3)
  {
    double v21 = *a2;
    double v22 = *a4;
    if (*a2 <= *a4) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }
  if (v10 || v14) {
    __assert_rtn("special_cases", "envelope_segment.hpp", 260, "!is_pole1 && !is_pole2");
  }
  if (v19 > v20)
  {
    *(double *)a1 = v20;
    *(double *)a3 = v19;
    double v23 = *a2;
    *a2 = *a4;
    *a4 = v23;
    double v19 = *(double *)a1;
    double v20 = *(double *)a3;
  }
  if (vabdd_f64(v19, v20) > 180.0)
  {
    *(double *)a1 = v19 + 360.0;
    *a1 = *a3;
    *(double *)a3 = v19 + 360.0;
    double v21 = *a2;
    double v22 = *a4;
LABEL_37:
    *a2 = v22;
    *a4 = v21;
    double v19 = *(double *)a1;
  }
LABEL_38:
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13360))
  {
    qword_101B13358 = 0x3F91DF46A2529D39;
    __cxa_guard_release(&qword_101B13360);
  }
  double v24 = *(double *)&qword_101B13358;
  double v25 = *a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13360))
  {
    qword_101B13358 = 0x3F91DF46A2529D39;
    __cxa_guard_release(&qword_101B13360);
  }
  double v26 = *(double *)&qword_101B13358;
  double v27 = *(double *)a3;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13360))
  {
    qword_101B13358 = 0x3F91DF46A2529D39;
    __cxa_guard_release(&qword_101B13360);
  }
  double v28 = *(double *)&qword_101B13358;
  double v29 = *a4;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    double v66 = v28;
    double v67 = v29;
    int v59 = __cxa_guard_acquire(&qword_101B13360);
    double v28 = v66;
    double v29 = v67;
    if (v59)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      double v28 = v66;
      double v29 = v67;
    }
  }
  double v30 = v19 * v24;
  double v31 = v29 * *(double *)&qword_101B13358;
  __double2 v32 = __sincos_stret(v27 * v28 - v30);
  __double2 v33 = __sincos_stret(v25 * v26);
  __double2 v34 = __sincos_stret(v31);
  long double v35 = atan2(v32.__sinval * v34.__cosval, v32.__cosval * -(v33.__sinval * v34.__cosval) + v33.__cosval * v34.__sinval);
  double v36 = atan2(v33.__cosval * v32.__sinval, v33.__cosval * v34.__sinval * v32.__cosval - v33.__sinval * v34.__cosval);
  if (*(double *)a1 > *(double *)a3) {
    __assert_rtn("compute_box_corners", "envelope_segment.hpp", 161, "lon1 <= lon2");
  }
  double v37 = *a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    double v60 = v36;
    int v61 = __cxa_guard_acquire(&qword_101B13360);
    double v36 = v60;
    if (v61)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      double v36 = v60;
    }
  }
  double v38 = *(double *)&qword_101B13358;
  double v39 = *a4;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    double v62 = v36;
    int v63 = __cxa_guard_acquire(&qword_101B13360);
    double v36 = v62;
    if (v63)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      double v36 = v62;
    }
  }
  if (v35 != v36)
  {
    if ((*(void *)&v35 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v36 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_51;
    }
    double v55 = vabdd_f64(v35, v36);
    double v56 = fabs(v35);
    double v57 = fabs(v36);
    if (v56 < v57) {
      double v56 = v57;
    }
    double v58 = v56 >= 1.0 ? v56 * 2.22044605e-16 : 2.22044605e-16;
    if (v55 > v58)
    {
LABEL_51:
      double v41 = *a2;
      if (*a2 <= *a4)
      {
        double v42 = v37 * v38;
        double v43 = v36;
      }
      else
      {
        double v42 = v39 * *(double *)&qword_101B13358;
        *a2 = *a4;
        *a4 = v41;
        double v43 = v35;
        long double v35 = v36;
      }
      if (v35 == v43) {
        goto LABEL_94;
      }
      if ((*(void *)&v35 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
        && (*(void *)&v43 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v45 = vabdd_f64(v35, v43);
        double v46 = fabs(v35);
        double v47 = fabs(v43);
        if (v46 < v47) {
          double v46 = v47;
        }
        double v48 = v46 >= 1.0 ? v46 * 2.22044605e-16 : 2.22044605e-16;
        if (v45 <= v48) {
LABEL_94:
        }
          __assert_rtn("contains_pi_half", "envelope_segment.hpp", 128, "! math::equals(a1, a2)");
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13370, memory_order_acquire) & 1) == 0)
      {
        double v64 = v42;
        int v65 = __cxa_guard_acquire(&qword_101B13370);
        double v42 = v64;
        if (v65)
        {
          qword_101B13368 = 0x3FF921FB54442D18;
          __cxa_guard_release(&qword_101B13370);
          double v42 = v64;
        }
      }
      if (v35 >= v43)
      {
        if (v35 <= *(double *)&qword_101B13368 || *(double *)&qword_101B13368 <= v43) {
          return;
        }
      }
      else if (v35 >= *(double *)&qword_101B13368 || *(double *)&qword_101B13368 >= v43)
      {
        return;
      }
      double v51 = cos(v42);
      long double v52 = sin(v35);
      double v53 = acos(fabs(v51 * v52));
      if (*a2 + *a4 >= 0.0)
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13380, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_101B13380))
        {
          qword_101B13378 = 0x404CA5DC1A63C1F8;
          __cxa_guard_release(&qword_101B13380);
        }
        if (*a4 < v53 * *(double *)&qword_101B13378) {
          *a4 = v53 * *(double *)&qword_101B13378;
        }
      }
      else
      {
        double v54 = -v53;
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13380, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_101B13380))
        {
          qword_101B13378 = 0x404CA5DC1A63C1F8;
          __cxa_guard_release(&qword_101B13380);
        }
        if (*a2 > *(double *)&qword_101B13378 * v54) {
          *a2 = *(double *)&qword_101B13378 * v54;
        }
      }
    }
  }
}

void sub_10123E140(double *a1, double *a2)
{
  double v3 = a1[5];
  double v4 = a1[1];
  uint64_t v5 = a1;
  if (v3 < v4)
  {
    if ((*(void *)&v4 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v3 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_6;
    }
    double v187 = vabdd_f64(v4, v3);
    double v188 = fabs(v4);
    double v189 = fabs(v3);
    if (v188 >= v189) {
      double v189 = v188;
    }
    double v190 = v189 >= 1.0 ? v189 * 2.22044605e-16 : 2.22044605e-16;
    uint64_t v5 = a1;
    if (v187 > v190) {
LABEL_6:
    }
      uint64_t v5 = a1 + 4;
  }
  uint64_t v198 = v5;
  double v7 = a1[3];
  double v8 = a1[7];
  double v9 = a1;
  if (v7 < v8)
  {
    if ((*(void *)&v8 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v7 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_12;
    }
    double v191 = vabdd_f64(v8, v7);
    double v192 = fabs(v8);
    double v193 = fabs(v7);
    if (v192 >= v193) {
      double v193 = v192;
    }
    double v194 = v193 >= 1.0 ? v193 * 2.22044605e-16 : 2.22044605e-16;
    double v9 = a1;
    if (v191 > v194) {
LABEL_12:
    }
      double v9 = a1 + 4;
  }
  long long v197 = v9;
  double v11 = 0;
  double v12 = 0;
  unint64_t v13 = 0;
  char v14 = 0;
  uint64_t v15 = 0;
  float64x2_t v201 = (float64x2_t)vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  float64x2_t v202 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  do
  {
    char v16 = v14;
    BOOL v17 = (float64x2_t *)&a1[4 * v15];
    float64x2_t v18 = *v17;
    float64x2_t v203 = v17[1];
    if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(*v17, v202), (int32x4_t)vceqq_f64(v203, v201))))))
    {
      float64x2_t v200 = *v17;
      if (v18.f64[1] != 90.0)
      {
        if ((*(void *)&v18.f64[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
          goto LABEL_23;
        }
        v18.f64[0] = fabs(v18.f64[1] + -90.0);
        double v19 = fabs(v18.f64[1]);
        if (v19 < 90.0) {
          double v19 = 90.0;
        }
        double v20 = v19 >= 1.0 ? v19 * 2.22044605e-16 : 2.22044605e-16;
        if (v18.f64[0] > v20)
        {
LABEL_23:
          if (v203.f64[1] != -90.0)
          {
            if ((*(void *)&v203.f64[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
              goto LABEL_40;
            }
            double v21 = fabs(v203.f64[1] + 90.0);
            double v22 = fabs(v203.f64[1]);
            if (v22 < 90.0) {
              double v22 = 90.0;
            }
            double v23 = v22 >= 1.0 ? v22 * 2.22044605e-16 : 2.22044605e-16;
            if (v21 > v23)
            {
LABEL_40:
              if (v203.f64[0] <= 180.0) {
                goto LABEL_32;
              }
              if ((*(void *)&v203.f64[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                goto LABEL_41;
              }
              double v24 = fabs(v203.f64[0] + -180.0);
              double v25 = fabs(v203.f64[0]);
              if (v25 < 180.0) {
                double v25 = 180.0;
              }
              double v26 = v25 >= 1.0 ? v25 * 2.22044605e-16 : 2.22044605e-16;
              if (v24 <= v26)
              {
LABEL_32:
                if ((unint64_t)v12 < v13)
                {
                  *double v12 = v200.f64[0];
                  v12[1] = v203.f64[0];
                  v12 += 2;
                  goto LABEL_92;
                }
                uint64_t v28 = ((char *)v12 - (char *)v11) >> 4;
                unint64_t v29 = v28 + 1;
                if ((unint64_t)(v28 + 1) >> 60) {
                  sub_10006A748();
                }
                if ((uint64_t)(v13 - (void)v11) >> 3 > v29) {
                  unint64_t v29 = (uint64_t)(v13 - (void)v11) >> 3;
                }
                if (v13 - (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v30 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v30 = v29;
                }
                if (v30) {
                  unint64_t v30 = (unint64_t)sub_1009C886C(v30);
                }
                else {
                  uint64_t v31 = 0;
                }
                double v36 = (void *)(v30 + 16 * v28);
                *double v36 = *(void *)&v200.f64[0];
                v36[1] = *(void *)&v203.f64[0];
                if (v12 == v11)
                {
                  unint64_t v38 = v30 + 16 * v28;
                }
                else
                {
                  unint64_t v37 = v30 + 16 * v28;
                  do
                  {
                    unint64_t v38 = v37 - 16;
                    *(_OWORD *)(v37 - 16) = *((_OWORD *)v12 - 1);
                    v12 -= 2;
                    v37 -= 16;
                  }
                  while (v12 != v11);
                }
                unint64_t v13 = v30 + 16 * v31;
                double v12 = (double *)(v36 + 2);
                if (!v11) {
                  goto LABEL_91;
                }
              }
              else
              {
LABEL_41:
                if ((unint64_t)v12 >= v13)
                {
                  uint64_t v32 = ((char *)v12 - (char *)v11) >> 4;
                  unint64_t v33 = v32 + 1;
                  if ((unint64_t)(v32 + 1) >> 60) {
                    sub_10006A748();
                  }
                  if ((uint64_t)(v13 - (void)v11) >> 3 > v33) {
                    unint64_t v33 = (uint64_t)(v13 - (void)v11) >> 3;
                  }
                  if (v13 - (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
                    unint64_t v34 = 0xFFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v34 = v33;
                  }
                  if (v34) {
                    unint64_t v34 = (unint64_t)sub_1009C886C(v34);
                  }
                  else {
                    uint64_t v35 = 0;
                  }
                  double v39 = (void *)(v34 + 16 * v32);
                  void *v39 = *(void *)&v200.f64[0];
                  v39[1] = 0x4066800000000000;
                  if (v12 == v11)
                  {
                    double v41 = (double *)(v34 + 16 * v32);
                  }
                  else
                  {
                    unint64_t v40 = v34 + 16 * v32;
                    do
                    {
                      double v41 = (double *)(v40 - 16);
                      *(_OWORD *)(v40 - 16) = *((_OWORD *)v12 - 1);
                      v12 -= 2;
                      v40 -= 16;
                    }
                    while (v12 != v11);
                  }
                  unint64_t v13 = v34 + 16 * v35;
                  double v27 = (double *)(v39 + 2);
                  if (v11) {
                    operator delete(v11);
                  }
                  double v11 = v41;
                }
                else
                {
                  *double v12 = v200.f64[0];
                  v12[1] = 180.0;
                  double v27 = v12 + 2;
                }
                double v42 = v203.f64[0] + -360.0;
                if ((unint64_t)v27 < v13)
                {
                  double *v27 = -180.0;
                  v27[1] = v42;
                  double v12 = v27 + 2;
                  goto LABEL_92;
                }
                uint64_t v43 = ((char *)v27 - (char *)v11) >> 4;
                unint64_t v44 = v43 + 1;
                if ((unint64_t)(v43 + 1) >> 60) {
                  sub_10006A748();
                }
                if ((uint64_t)(v13 - (void)v11) >> 3 > v44) {
                  unint64_t v44 = (uint64_t)(v13 - (void)v11) >> 3;
                }
                if (v13 - (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v45 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v45 = v44;
                }
                if (v45) {
                  unint64_t v45 = (unint64_t)sub_1009C886C(v45);
                }
                else {
                  uint64_t v46 = 0;
                }
                unint64_t v38 = v45 + 16 * v43;
                unint64_t v13 = v45 + 16 * v46;
                *(void *)unint64_t v38 = 0xC066800000000000;
                *(double *)(v38 + 8) = v42;
                double v12 = (double *)(v38 + 16);
                if (v27 != v11)
                {
                  do
                  {
                    *(_OWORD *)(v38 - 16) = *((_OWORD *)v27 - 1);
                    v38 -= 16;
                    v27 -= 2;
                  }
                  while (v27 != v11);
                  if (!v11) {
                    goto LABEL_91;
                  }
                }
              }
              operator delete(v11);
LABEL_91:
              double v11 = (double *)v38;
            }
          }
        }
      }
    }
LABEL_92:
    char v14 = 1;
    uint64_t v15 = 1;
  }
  while ((v16 & 1) == 0);
  if (v11 == v12)
  {
    double v57 = 0.0;
    double v66 = 0.0;
    goto LABEL_367;
  }
  double v47 = v11 + 2;
  if (v11 + 2 == v12)
  {
    double v57 = *v11;
    double v58 = v11;
  }
  else
  {
    double v48 = v11 + 2;
    int64x2_t v49 = v11;
    do
    {
      double v50 = *v48;
      double v51 = *v49;
      if (*v48 < *v49)
      {
        if ((*(void *)&v51 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v50 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_101;
        }
        double v53 = vabdd_f64(v51, v50);
        double v54 = fabs(v51);
        double v55 = fabs(v50);
        if (v54 >= v55) {
          double v55 = v54;
        }
        double v56 = v55 >= 1.0 ? v55 * 2.22044605e-16 : 2.22044605e-16;
        if (v53 > v56) {
LABEL_101:
        }
          int64x2_t v49 = v48;
      }
      v48 += 2;
    }
    while (v48 != v12);
    double v57 = *v49;
    double v58 = v11;
    do
    {
      double v59 = v58[1];
      double v60 = v47[1];
      if (v59 < v60)
      {
        if ((*(void *)&v60 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v59 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_116;
        }
        double v62 = vabdd_f64(v60, v59);
        double v63 = fabs(v60);
        double v64 = fabs(v59);
        if (v63 >= v64) {
          double v64 = v63;
        }
        double v65 = v64 >= 1.0 ? v64 * 2.22044605e-16 : 2.22044605e-16;
        if (v62 > v65) {
LABEL_116:
        }
          double v58 = v47;
      }
      v47 += 2;
    }
    while (v47 != v12);
  }
  double v66 = v58[1];
  double v67 = v66 - v57;
  if (v66 - v57 > 180.0)
  {
    if (COERCE_UNSIGNED_INT64(fabs(v66 - v57)) > 0x7FEFFFFFFFFFFFFFLL) {
      goto LABEL_136;
    }
    double v68 = fabs(v67 + -180.0);
    double v69 = fabs(v67);
    if (v69 < 180.0) {
      double v69 = 180.0;
    }
    double v70 = v69 >= 1.0 ? v69 * 2.22044605e-16 : 2.22044605e-16;
    if (v68 > v70)
    {
LABEL_136:
      if ((char *)v12 - (char *)v11 < 0) {
        sub_10006A748();
      }
      double v71 = sub_1009C886C((unint64_t)((char *)v12 - (char *)v11) >> 4);
      double v73 = v71;
      uint64_t v74 = 0;
      do
      {
        double v75 = &v71[v74];
        *(void *)double v75 = &v11[(unint64_t)v74 / 8];
        v75[8] = 1;
        v74 += 16;
      }
      while (&v11[(unint64_t)v74 / 8] != v12);
      uint64_t v76 = (uint64_t)&v71[v74];
      if (v74 < 17) {
        goto LABEL_225;
      }
      uint64_t v77 = v74 >> 4;
      int64_t v78 = (unint64_t)((v74 >> 4) - 2) >> 1;
      int64_t v79 = v78;
      while (2)
      {
        int64_t v80 = v79;
        if ((unint64_t)v74 < 0x20 || v78 < v79) {
          goto LABEL_209;
        }
        uint64_t v81 = (2 * v79) | 1;
        unint64_t v82 = &v73[16 * v81];
        if (2 * v80 + 2 < v77)
        {
          double v83 = *(double *)(*((void *)v82 + 2) + 8 * (v82[24] == 0));
          double v84 = *(double *)(*(void *)v82 + 8 * (v82[8] == 0));
          if (v83 == v84) {
            goto LABEL_387;
          }
          if ((*(void *)&v83 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
            || (*(void *)&v84 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_205;
          }
          double v119 = vabdd_f64(v83, v84);
          double v120 = fabs(v83);
          double v121 = fabs(v84);
          if (v120 < v121) {
            double v120 = v121;
          }
          double v122 = v120 >= 1.0 ? v120 * 2.22044605e-16 : 2.22044605e-16;
          if (v119 <= v122)
          {
LABEL_387:
            if (v82[24]) {
              BOOL v85 = v82[8] == 0;
            }
            else {
              BOOL v85 = 0;
            }
            if (!v85) {
              goto LABEL_151;
            }
          }
          else
          {
LABEL_205:
            if (v83 >= v84) {
              goto LABEL_151;
            }
          }
          v82 += 16;
          uint64_t v81 = 2 * v80 + 2;
        }
LABEL_151:
        unint64_t v86 = &v73[16 * v80];
        int v87 = v86[8];
        BOOL v88 = v86[8] == 0;
        uint64_t v89 = *(void *)v86;
        double v90 = *(double *)(*(void *)v86 + 8 * (v86[8] == 0));
        double v91 = *(double *)(*(void *)v82 + 8 * (v82[8] == 0));
        if (v90 == v91) {
          goto LABEL_153;
        }
        if ((*(void *)&v90 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v91 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_159;
        }
        double v115 = vabdd_f64(v90, v91);
        double v116 = fabs(v90);
        double v117 = fabs(v91);
        if (v116 < v117) {
          double v116 = v117;
        }
        double v118 = v116 >= 1.0 ? v116 * 2.22044605e-16 : 2.22044605e-16;
        if (v115 <= v118)
        {
LABEL_153:
          if (v73[16 * v80 + 8] && !v82[8]) {
            goto LABEL_209;
          }
        }
        else
        {
LABEL_159:
          if (v90 < v91) {
            goto LABEL_209;
          }
        }
        uint64_t v93 = *(void *)v82;
        v86[8] = v82[8];
        *(void *)unint64_t v86 = v93;
        if (v78 < v81) {
          goto LABEL_208;
        }
        uint64_t v94 = 8 * v88;
        while (2)
        {
          long long v95 = v82;
          uint64_t v96 = 2 * v81;
          uint64_t v81 = (2 * v81) | 1;
          unint64_t v82 = &v73[16 * v81];
          uint64_t v97 = v96 + 2;
          if (v97 < v77)
          {
            double v98 = *(double *)(*((void *)v82 + 2) + 8 * (v82[24] == 0));
            double v99 = *(double *)(*(void *)v82 + 8 * (v82[8] == 0));
            if (v98 == v99) {
              goto LABEL_388;
            }
            if ((*(void *)&v98 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
              || (*(void *)&v99 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_185;
            }
            double v110 = vabdd_f64(v98, v99);
            double v111 = fabs(v98);
            double v112 = fabs(v99);
            if (v111 < v112) {
              double v111 = v112;
            }
            double v113 = v111 >= 1.0 ? v111 * 2.22044605e-16 : 2.22044605e-16;
            if (v110 <= v113)
            {
LABEL_388:
              if (v82[24]) {
                BOOL v100 = v82[8] == 0;
              }
              else {
                BOOL v100 = 0;
              }
              if (!v100) {
                goto LABEL_170;
              }
            }
            else
            {
LABEL_185:
              if (v98 >= v99) {
                goto LABEL_170;
              }
            }
            v82 += 16;
            uint64_t v81 = v97;
          }
LABEL_170:
          double v101 = *(double *)(v89 + v94);
          double v102 = *(double *)(*(void *)v82 + 8 * (v82[8] == 0));
          if (v101 != v102)
          {
            if ((*(void *)&v101 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
              || (*(void *)&v102 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_178;
            }
            double v106 = vabdd_f64(v101, v102);
            double v107 = fabs(v101);
            double v108 = fabs(v102);
            if (v107 < v108) {
              double v107 = v108;
            }
            double v109 = v107 >= 1.0 ? v107 * 2.22044605e-16 : 2.22044605e-16;
            if (v106 > v109)
            {
LABEL_178:
              if (v101 < v102) {
                break;
              }
              goto LABEL_179;
            }
          }
          if (!v87 || v82[8])
          {
LABEL_179:
            uint64_t v104 = *(void *)v82;
            v95[8] = v82[8];
            *(void *)long long v95 = v104;
            if (v78 < v81) {
              goto LABEL_208;
            }
            continue;
          }
          break;
        }
        unint64_t v82 = v95;
LABEL_208:
        *(void *)unint64_t v82 = v89;
        v82[8] = v87;
LABEL_209:
        int64_t v79 = v80 - 1;
        if (v80) {
          continue;
        }
        break;
      }
LABEL_225:
      if (v74)
      {
        uint64_t v123 = 0;
        double v124 = 0.0;
        double v125 = 0.0;
        uint64_t v126 = &v73[16 * v72];
        while (1)
        {
          double v127 = *(double **)v73;
          int v128 = v73[8];
          unint64_t v129 = v76 - (void)v73;
          if (v76 - (uint64_t)v73 < 17) {
            goto LABEL_257;
          }
          uint64_t v130 = 0;
          long long v204 = *(_OWORD *)v73;
          uint64_t v131 = (v129 >> 4) - 2;
          if (v129 >> 4 < 2) {
            uint64_t v131 = (v129 >> 4) - 1;
          }
          uint64_t v132 = v131 >> 1;
          double v133 = v73;
          do
          {
            uint64_t v134 = v133;
            v133 += 16 * v130 + 16;
            uint64_t v135 = 2 * v130;
            uint64_t v130 = (2 * v130) | 1;
            uint64_t v136 = v135 + 2;
            if (v136 >= (uint64_t)(v129 >> 4)) {
              goto LABEL_239;
            }
            double v137 = *(double *)(*((void *)v133 + 2) + 8 * (v133[24] == 0));
            double v138 = *(double *)(*(void *)v133 + 8 * (v133[8] == 0));
            if (v137 == v138) {
              goto LABEL_389;
            }
            if ((*(void *)&v137 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
              || (*(void *)&v138 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_245;
            }
            double v142 = vabdd_f64(v137, v138);
            double v143 = fabs(v137);
            double v144 = fabs(v138);
            if (v143 < v144) {
              double v143 = v144;
            }
            double v145 = v143 >= 1.0 ? v143 * 2.22044605e-16 : 2.22044605e-16;
            if (v142 <= v145)
            {
LABEL_389:
              if (v133[24]) {
                BOOL v139 = v133[8] == 0;
              }
              else {
                BOOL v139 = 0;
              }
              if (v139)
              {
LABEL_238:
                v133 += 16;
                uint64_t v130 = v136;
              }
            }
            else
            {
LABEL_245:
              if (v137 < v138) {
                goto LABEL_238;
              }
            }
LABEL_239:
            uint64_t v140 = *(void *)v133;
            v134[8] = v133[8];
            *(void *)uint64_t v134 = v140;
          }
          while (v130 <= v132);
          unint64_t v146 = (uint64_t *)(v76 - 16);
          if ((unsigned char *)(v76 - 16) == v133)
          {
            v133[8] = BYTE8(v204);
            *(void *)double v133 = v204;
          }
          else
          {
            uint64_t v147 = *v146;
            v133[8] = *(unsigned char *)(v76 - 8);
            *(void *)double v133 = v147;
            *(unsigned char *)(v76 - 8) = BYTE8(v204);
            uint64_t *v146 = v204;
            sub_10123F5C0((uint64_t)v73, (uint64_t)(v133 + 16), (v133 + 16 - v73) >> 4);
          }
LABEL_257:
          double v148 = (unsigned char *)(v76 - 16);
          if (v128)
          {
            if (v148 >= v126)
            {
              uint64_t v150 = (v148 - v73) >> 4;
              unint64_t v151 = v150 + 1;
              if ((unint64_t)(v150 + 1) >> 60) {
                sub_10006A748();
              }
              if ((v126 - v73) >> 3 > v151) {
                unint64_t v151 = (v126 - v73) >> 3;
              }
              if ((unint64_t)(v126 - v73) >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v152 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v152 = v151;
              }
              if (v152) {
                unint64_t v152 = (unint64_t)sub_1009C886C(v152);
              }
              else {
                uint64_t v153 = 0;
              }
              uint64_t v154 = v152 + 16 * v150;
              *(void *)uint64_t v154 = v127;
              *(unsigned char *)(v154 + 8) = 0;
              uint64_t v149 = v154;
              while (v148 != v73)
              {
                uint64_t v155 = *((void *)v148 - 2);
                v148 -= 16;
                char v156 = v148[8];
                *(void *)(v149 - 16) = v155;
                v149 -= 16;
                *(unsigned char *)(v149 + 8) = v156;
              }
              uint64_t v126 = (unsigned char *)(v152 + 16 * v153);
              uint64_t v76 = v154 + 16;
              operator delete(v73);
              unint64_t v129 = v76 - v149;
              double v73 = (unsigned char *)v149;
            }
            else
            {
              *(void *)(v76 - 16) = v127;
              *(unsigned char *)(v76 - 8) = 0;
              uint64_t v149 = (uint64_t)v73;
            }
            ++v123;
            sub_10123F5C0(v149, v76, (uint64_t)v129 >> 4);
            double v148 = (unsigned char *)v76;
            goto LABEL_279;
          }
          if (--v123) {
            goto LABEL_279;
          }
          if (v73 != v148)
          {
            if (!v73[8]) {
              __assert_rtn("apply", "max_interval_gap.hpp", 143, "queue.top().is_start_event()");
            }
            uint64_t v123 = 0;
            if (**(double **)v73 - v127[1] > v125 - v124)
            {
              double v124 = v127[1];
              double v125 = **(double **)v73;
            }
LABEL_279:
            uint64_t v76 = (uint64_t)v148;
            if (v73 != v148) {
              continue;
            }
          }
          if (v73) {
            goto LABEL_281;
          }
          goto LABEL_282;
        }
      }
      double v124 = 0.0;
      double v125 = 0.0;
      double v73 = (unsigned char *)v76;
      if (v76) {
LABEL_281:
      }
        operator delete(v73);
      if (v66 >= v57) {
        goto LABEL_298;
      }
LABEL_282:
      if ((*(void *)&v57 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (*(void *)&v66 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_373;
      }
      double v157 = vabdd_f64(v57, v66);
      double v158 = fabs(v57);
      double v159 = fabs(v66);
      if (v158 < v159) {
        double v158 = v159;
      }
      double v160 = v158 >= 1.0 ? v158 * 2.22044605e-16 : 2.22044605e-16;
      if (v157 > v160)
      {
LABEL_373:
        int64_t v195 = "! math::larger(lon_min, lon_max)";
        int v196 = 129;
      }
      else
      {
        if (v66 <= 180.0) {
          goto LABEL_304;
        }
LABEL_298:
        if ((*(void *)&v66 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
          goto LABEL_375;
        }
        double v161 = fabs(v66 + -180.0);
        double v162 = fabs(v66);
        if (v162 < 180.0) {
          double v162 = 180.0;
        }
        double v163 = v162 >= 1.0 ? v162 * 2.22044605e-16 : 2.22044605e-16;
        if (v161 > v163)
        {
LABEL_375:
          int64_t v195 = "! math::larger(lon_max, constants::max_longitude())";
          int v196 = 131;
        }
        else
        {
LABEL_304:
          if (v57 < -180.0
            && ((*(void *)&v57 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
             || ((double v164 = vabdd_f64(-180.0, v57), v165 = fmax(fabs(v57), 180.0), v165 >= 1.0)
               ? (double v166 = v165 * 2.22044605e-16)
               : (double v166 = 2.22044605e-16),
                 v164 > v166)))
          {
            int64_t v195 = "! math::smaller(lon_min, constants::min_longitude())";
            int v196 = 133;
          }
          else
          {
            if (v125 >= v124) {
              goto LABEL_321;
            }
            if ((*(void *)&v124 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
              || (*(void *)&v125 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_374;
            }
            double v167 = vabdd_f64(v124, v125);
            double v168 = fabs(v124);
            double v169 = fabs(v125);
            if (v168 < v169) {
              double v168 = v169;
            }
            double v170 = v168 >= 1.0 ? v168 * 2.22044605e-16 : 2.22044605e-16;
            if (v167 > v170)
            {
LABEL_374:
              int64_t v195 = "! math::larger(max_gap_left, max_gap_right)";
              int v196 = 136;
            }
            else
            {
              if (v125 <= 180.0) {
                goto LABEL_327;
              }
LABEL_321:
              if ((*(void *)&v125 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                goto LABEL_377;
              }
              double v171 = fabs(v125 + -180.0);
              double v172 = fabs(v125);
              if (v172 < 180.0) {
                double v172 = 180.0;
              }
              double v173 = v172 >= 1.0 ? v172 * 2.22044605e-16 : 2.22044605e-16;
              if (v171 > v173)
              {
LABEL_377:
                int64_t v195 = "! math::larger(max_gap_right, constants::max_longitude())";
                int v196 = 138;
              }
              else
              {
LABEL_327:
                if (v124 >= -180.0
                  || (*(void *)&v124 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                  && ((double v174 = vabdd_f64(-180.0, v124), v175 = fmax(fabs(v124), 180.0), v175 >= 1.0)
                    ? (double v176 = v175 * 2.22044605e-16)
                    : (double v176 = 2.22044605e-16),
                      v174 <= v176))
                {
                  double v177 = v125 - v124;
                  if (v125 - v124 <= 0.0) {
                    goto LABEL_367;
                  }
                  if (COERCE_UNSIGNED_INT64(fabs(v125 - v124)) > 0x7FEFFFFFFFFFFFFFLL)
                  {
                    if (v57 + 360.0 - v66 >= v177) {
                      goto LABEL_367;
                    }
                  }
                  else
                  {
                    double v178 = fabs(v177);
                    double v179 = 2.22044605e-16;
                    if (v178 >= 1.0) {
                      double v179 = v178 * 2.22044605e-16;
                    }
                    if (v178 <= v179) {
                      goto LABEL_367;
                    }
                    double v180 = v57 + 360.0 - v66;
                    if (v180 >= v177) {
                      goto LABEL_367;
                    }
                    unint64_t v181 = COERCE__INT64(fabs(v57 + 360.0 - v66)) - 1;
                    BOOL v182 = (unint64_t)(COERCE__INT64(fabs(v57 + 360.0 - v66)) - 0x10000000000000) >> 53 > 0x3FE
                        && v181 > 0xFFFFFFFFFFFFELL;
                    if (!v182 || *(void *)&v180 == 0)
                    {
                      double v184 = vabdd_f64(v177, v180);
                      double v185 = fabs(v180);
                      if (v178 < v185) {
                        double v178 = v185;
                      }
                      double v186 = v178 >= 1.0 ? v178 * 2.22044605e-16 : 2.22044605e-16;
                      if (v184 <= v186) {
                        goto LABEL_367;
                      }
                    }
                  }
                  double v66 = v124 + 360.0;
                  double v57 = v125;
                  goto LABEL_367;
                }
                int64_t v195 = "! math::smaller(max_gap_left, constants::min_longitude())";
                int v196 = 140;
              }
            }
          }
        }
      }
      __assert_rtn("apply", "range_of_boxes.hpp", v196, v195);
    }
  }
LABEL_367:
  *a2 = v57;
  a2[1] = v198[1];
  a2[2] = v66;
  a2[3] = v197[3];
  if (v11)
  {
    operator delete(v11);
  }
}

void sub_10123F1E8(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

double sub_10123F230(double *a1, double *a2, double *a3, double *a4, int a5)
{
  sub_10123D770(a1, a2, 0);
  sub_10123D770(a3, a4, 0);
  double v10 = *a2;
  if (*a2 == -90.0) {
    goto LABEL_9;
  }
  if ((*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v15 = 90.0;
    double v16 = fabs(v10 + 90.0);
    double v17 = fabs(v10);
    if (v17 >= 90.0) {
      double v15 = v17;
    }
    double v18 = v15 >= 1.0 ? v15 * 2.22044605e-16 : 2.22044605e-16;
    if (v16 <= v18)
    {
LABEL_9:
      double v11 = *a4;
      if (*a4 == -90.0) {
        goto LABEL_20;
      }
      if ((*(void *)&v11 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v12 = fabs(v11 + 90.0);
        double v13 = fabs(v11);
        if (v13 < 90.0) {
          double v13 = 90.0;
        }
        double v14 = v13 >= 1.0 ? v13 * 2.22044605e-16 : 2.22044605e-16;
        if (v12 <= v14) {
          goto LABEL_20;
        }
      }
    }
  }
  if (v10 != 90.0)
  {
    if ((*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
      goto LABEL_60;
    }
    double v33 = fabs(v10 + -90.0);
    double v34 = fabs(v10);
    if (v34 < 90.0) {
      double v34 = 90.0;
    }
    double v35 = v34 >= 1.0 ? v34 * 2.22044605e-16 : 2.22044605e-16;
    if (v33 > v35) {
      goto LABEL_60;
    }
  }
  double v19 = *a4;
  if (*a4 == 90.0) {
    goto LABEL_20;
  }
  if ((*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    goto LABEL_60;
  }
  double v36 = fabs(v19 + -90.0);
  double v37 = fabs(v19);
  if (v37 < 90.0) {
    double v37 = 90.0;
  }
  double v38 = v37 >= 1.0 ? v37 * 2.22044605e-16 : 2.22044605e-16;
  if (v36 <= v38)
  {
LABEL_20:
    *a3 = 0.0;
    *a1 = 0.0;
    double v20 = 0.0;
  }
  else
  {
LABEL_60:
    if (a5)
    {
      *a1 = -180.0;
      double v39 = 180.0;
LABEL_64:
      *a3 = v39;
      double v20 = *a1;
      goto LABEL_21;
    }
    double v20 = *a1;
    if (*a1 > *a3)
    {
      double v39 = *a3 + 360.0;
      goto LABEL_64;
    }
  }
LABEL_21:
  double v21 = *a3;
  if (*a3 < v20)
  {
    if ((*(void *)&v20 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v21 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_65;
    }
    double v22 = vabdd_f64(v20, v21);
    double v23 = fabs(v20);
    double v24 = fabs(v21);
    if (v23 < v24) {
      double v23 = v24;
    }
    double v25 = v23 >= 1.0 ? v23 * 2.22044605e-16 : 2.22044605e-16;
    if (v22 > v25) {
LABEL_65:
    }
      __assert_rtn("apply", "normalize_spheroidal_box_coordinates.hpp", 92, "! math::larger(longitude1, longitude2)");
  }
  if (v20 < -180.0)
  {
    if ((*(void *)&v20 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || ((double v26 = vabdd_f64(-180.0, v20), v27 = fmax(fabs(v20), 180.0), v27 >= 1.0)
        ? (double v28 = v27 * 2.22044605e-16)
        : (double v28 = 2.22044605e-16),
          v26 > v28))
    {
      __assert_rtn("apply", "normalize_spheroidal_box_coordinates.hpp", 93, "! math::smaller(longitude1, constants::min_longitude())");
    }
  }
  double v29 = v21 - v20;
  double result = 360.0;
  if (v29 > 360.0)
  {
    if ((*(void *)&v29 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
      goto LABEL_67;
    }
    double v31 = fabs(v29 + -360.0);
    double v32 = fabs(v29);
    if (v32 >= 360.0) {
      double result = v32;
    }
    double result = result >= 1.0 ? result * 2.22044605e-16 : 2.22044605e-16;
    if (v31 > result) {
LABEL_67:
    }
      __assert_rtn("apply", "normalize_spheroidal_box_coordinates.hpp", 95, "! math::larger(longitude2 - longitude1, constants::period())");
  }
  return result;
}

uint64_t sub_10123F5C0(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a3 - 2;
  if (a3 >= 2)
  {
    unint64_t v4 = v3 >> 1;
    uint64_t v5 = (uint64_t *)(result + 16 * (v3 >> 1));
    uint64_t v8 = *(void *)(a2 - 16);
    uint64_t v6 = a2 - 16;
    uint64_t v7 = v8;
    int v9 = *(unsigned __int8 *)(v6 + 8);
    BOOL v10 = *(unsigned char *)(v6 + 8) == 0;
    double v11 = *(double *)(v8 + 8 * (*(unsigned char *)(v6 + 8) == 0));
    double v12 = *(double *)(*v5 + 8 * (*((unsigned char *)v5 + 8) == 0));
    if (v11 == v12) {
      goto LABEL_42;
    }
    if ((*(void *)&v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_10;
    }
    double v26 = vabdd_f64(v11, v12);
    double v27 = fabs(v11);
    double v28 = fabs(v12);
    if (v27 < v28) {
      double v27 = v28;
    }
    double v29 = v27 >= 1.0 ? v27 * 2.22044605e-16 : 2.22044605e-16;
    if (v26 <= v29)
    {
LABEL_42:
      if (!*(unsigned char *)(v6 + 8) || *((unsigned char *)v5 + 8)) {
        return result;
      }
    }
    else
    {
LABEL_10:
      if (v11 >= v12) {
        return result;
      }
    }
    uint64_t v14 = *v5;
    *(unsigned char *)(v6 + 8) = *((unsigned char *)v5 + 8);
    *(void *)uint64_t v6 = v14;
    if (v3 >= 2)
    {
      uint64_t v16 = 8 * v10;
      while (1)
      {
        unint64_t v17 = v4 - 1;
        unint64_t v4 = (v4 - 1) >> 1;
        double v15 = (uint64_t *)(result + 16 * v4);
        double v18 = *(double *)(v7 + v16);
        double v19 = *(double *)(*v15 + 8 * (*((unsigned char *)v15 + 8) == 0));
        if (v18 == v19) {
          goto LABEL_43;
        }
        if ((*(void *)&v18 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_23;
        }
        double v22 = vabdd_f64(v18, v19);
        double v23 = fabs(v18);
        double v24 = fabs(v19);
        if (v23 < v24) {
          double v23 = v24;
        }
        double v25 = v23 >= 1.0 ? v23 * 2.22044605e-16 : 2.22044605e-16;
        if (v22 <= v25)
        {
LABEL_43:
          if (!v9 || *((unsigned char *)v15 + 8)) {
            break;
          }
        }
        else
        {
LABEL_23:
          if (v18 >= v19) {
            break;
          }
        }
        uint64_t v21 = *v15;
        *((unsigned char *)v5 + 8) = *((unsigned char *)v15 + 8);
        uint64_t *v5 = v21;
        uint64_t v5 = (uint64_t *)(result + 16 * v4);
        if (v17 <= 1) {
          goto LABEL_13;
        }
      }
    }
    double v15 = v5;
LABEL_13:
    *double v15 = v7;
    *((unsigned char *)v15 + 8) = v9;
  }
  return result;
}

void sub_10123F750(double *a1, uint64_t **a2, uint64_t **a3, unint64_t a4, uint64_t a5)
{
  double v8 = (*a1 + a1[2]) * 0.5;
  long long v9 = *((_OWORD *)a1 + 1);
  long long v81 = *(_OWORD *)a1;
  uint64_t v83 = *((void *)&v9 + 1);
  v79[1] = *((double *)&v81 + 1);
  long long v80 = v9;
  double v82 = v8;
  v79[0] = v8;
  uint64_t v76 = 0;
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  double v73 = 0;
  uint64_t v74 = 0;
  uint64_t v75 = 0;
  double v70 = 0;
  double v71 = 0;
  uint64_t v72 = 0;
  double v67 = 0;
  double v68 = 0;
  uint64_t v69 = 0;
  long long __p = 0;
  double v65 = 0;
  uint64_t v66 = 0;
  int v61 = 0;
  double v62 = 0;
  uint64_t v63 = 0;
  sub_101240254((double *)&v81, v79, a2, (void **)&v76, (void **)&v73, (void **)&v70);
  sub_101240254((double *)&v81, v79, a3, &v67, &__p, (void **)&v61);
  double v11 = v70;
  BOOL v10 = v71;
  double v12 = v61;
  double v58 = v70;
  if (v70 == v71)
  {
    uint64_t v14 = v62;
  }
  else
  {
    unint64_t v13 = (char *)v71 - (char *)v70;
    uint64_t v14 = v62;
    if ((unint64_t)((char *)v71 - (char *)v70) < 0x80
      || a4 > 0x63
      || (unint64_t)((char *)v62 - (char *)v61) < 0x79)
    {
      if (v61 != v62)
      {
        double v15 = v62;
        uint64_t v16 = v70;
        do
        {
          BOOL v42 = v12 == v15;
          double v15 = v12;
          if (!v42)
          {
            unint64_t v17 = v12;
            do
              sub_10123FE18(a5, *v16, *v17++);
            while (v17 != v14);
            double v15 = v14;
          }
          ++v16;
        }
        while (v16 != v10);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      do
        sub_101240044((double *)v84.i64, *v11++ + 4);
      while (v11 != v10);
      uint64_t v19 = v84.i64[1];
      uint64_t v18 = v84.i64[0];
      uint64_t v21 = v85.i64[1];
      uint64_t v20 = v85.i64[0];
      if (v12 != v14)
      {
        double v22 = v12;
        do
          sub_101240044((double *)v84.i64, *v22++ + 4);
        while (v22 != v14);
        uint64_t v19 = v84.i64[1];
        uint64_t v18 = v84.i64[0];
        uint64_t v21 = v85.i64[1];
        uint64_t v20 = v85.i64[0];
      }
      v59.i64[0] = v18;
      v59.i64[1] = v19;
      v60.i64[0] = v20;
      v60.i64[1] = v21;
      sub_101240848((double *)v59.i64, (uint64_t **)&v70, (uint64_t **)&v61, a4 + 1, a5);
    }
    double v24 = (double **)v67;
    double v23 = v68;
    if ((unint64_t)((char *)v68 - (unsigned char *)v67) < 0x80
      || (unint64_t)((char *)v65 - (unsigned char *)__p) < 0x80
      || a4 > 0x63
      || v13 < 0x79)
    {
      if (v67 != v68)
      {
        double v25 = v68;
        double v26 = v58;
        do
        {
          BOOL v42 = v24 == v25;
          double v25 = v24;
          if (!v42)
          {
            double v27 = v24;
            do
              sub_10123FE18(a5, *v26, *v27++);
            while (v27 != v23);
            double v25 = v23;
          }
          ++v26;
        }
        while (v26 != v10);
      }
      double v28 = (double **)__p;
      double v29 = v65;
      if (__p != v65)
      {
        unint64_t v30 = v65;
        double v31 = v58;
        do
        {
          BOOL v42 = v28 == v30;
          unint64_t v30 = v28;
          if (!v42)
          {
            double v32 = v28;
            do
              sub_10123FE18(a5, *v31, *v32++);
            while (v32 != v29);
            unint64_t v30 = v29;
          }
          ++v31;
        }
        while (v31 != v10);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      double v57 = v58;
      do
        sub_101240044((double *)v84.i64, *v57++ + 4);
      while (v57 != v10);
      int64x2_t v59 = v84;
      int64x2_t v60 = v85;
      sub_101240848((double *)v59.i64, (uint64_t **)&v70, (uint64_t **)&v67, a4 + 1, a5);
      sub_101240848((double *)v59.i64, (uint64_t **)&v70, (uint64_t **)&__p, a4 + 1, a5);
    }
  }
  double v33 = v76;
  double v34 = v77;
  unint64_t v35 = (char *)v77 - (char *)v76;
  if (v12 != v14)
  {
    if (v35 < 0x80
      || (unint64_t)((char *)v74 - (char *)v73) < 0x80
      || a4 > 0x63
      || (unint64_t)((char *)v14 - (char *)v12) < 0x79)
    {
      if (v76 != v77)
      {
        double v37 = v14;
        double v38 = v76;
        do
        {
          BOOL v42 = v12 == v37;
          double v37 = v12;
          if (!v42)
          {
            double v39 = v12;
            do
              sub_10123FE18(a5, *v38, *v39++);
            while (v39 != v14);
            double v37 = v14;
          }
          ++v38;
        }
        while (v38 != v34);
      }
      unint64_t v40 = v73;
      double v41 = v74;
      BOOL v42 = v73 == v74 || v12 == v14;
      if (!v42)
      {
        uint64_t v43 = v14;
        do
        {
          BOOL v42 = v12 == v43;
          uint64_t v43 = v12;
          if (!v42)
          {
            unint64_t v44 = v12;
            do
              sub_10123FE18(a5, *v40, *v44++);
            while (v44 != v14);
            uint64_t v43 = v14;
          }
          ++v40;
        }
        while (v40 != v41);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      double v36 = v12;
      do
        sub_101240044((double *)v84.i64, *v36++ + 4);
      while (v36 != v14);
      int64x2_t v59 = v84;
      int64x2_t v60 = v85;
      sub_101240848((double *)v59.i64, (uint64_t **)&v76, (uint64_t **)&v61, a4 + 1, a5);
      sub_101240848((double *)v59.i64, (uint64_t **)&v73, (uint64_t **)&v61, a4 + 1, a5);
    }
  }
  if (v35 < 0x80 || a4 > 0x63 || (unint64_t)((char *)v68 - (unsigned char *)v67) < 0x79)
  {
    if (v33 != v34)
    {
      unint64_t v45 = (double **)v67;
      uint64_t v46 = v68;
      if (v67 != v68)
      {
        double v47 = v68;
        double v48 = v33;
        do
        {
          BOOL v42 = v45 == v47;
          double v47 = v45;
          if (!v42)
          {
            int64x2_t v49 = v45;
            do
              sub_10123FE18(a5, *v48, *v49++);
            while (v49 != v46);
            double v47 = v46;
          }
          ++v48;
        }
        while (v48 != v34);
      }
    }
  }
  else
  {
    sub_101240848((double *)&v81, (uint64_t **)&v76, (uint64_t **)&v67, a4 + 1, a5);
  }
  double v50 = v73;
  double v51 = v74;
  if ((unint64_t)((char *)v74 - (char *)v73) < 0x80
    || a4 > 0x63
    || (unint64_t)((char *)v65 - (unsigned char *)__p) < 0x79)
  {
    if (v73 != v74)
    {
      long double v52 = (double **)__p;
      double v53 = v65;
      if (__p != v65)
      {
        double v54 = v65;
        double v55 = v73;
        do
        {
          BOOL v42 = v52 == v54;
          double v54 = v52;
          if (!v42)
          {
            double v56 = v52;
            do
              sub_10123FE18(a5, *v55, *v56++);
            while (v56 != v53);
            double v54 = v53;
          }
          ++v55;
        }
        while (v55 != v51);
      }
    }
  }
  else
  {
    sub_101240848(v79, (uint64_t **)&v73, (uint64_t **)&__p, a4 + 1, a5);
  }
  if (v12) {
    operator delete(v12);
  }
  if (__p) {
    operator delete(__p);
  }
  if (v67) {
    operator delete(v67);
  }
  if (v58) {
    operator delete(v58);
  }
  if (v50) {
    operator delete(v50);
  }
  if (v33)
  {
    operator delete(v33);
  }
}

void sub_10123FD84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30)
{
  if (v30) {
    operator delete(v30);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a24) {
    operator delete(a24);
  }
  if (a27) {
    operator delete(a27);
  }
  if (a30) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

void sub_10123FE18(uint64_t a1, double *a2, double *a3)
{
  double v6 = a2[4];
  double v7 = a2[6];
  if (v7 - v6 >= 360.0 || (double v8 = a3[4], v9 = a3[6], v10 = v9 - v8, v9 - v8 >= 360.0))
  {
LABEL_11:
    if (a2[7] >= a3[5] && a2[5] <= a3[7]) {
      sub_101240F1C(*(_DWORD *)a1, *(double ***)(a1 + 8), (uint64_t)a2, *(_DWORD *)(a1 + 16), *(double ***)(a1 + 24), (uint64_t)a3, 0, *(void *)(a1 + 32), *(void *)(a1 + 40), *(void **)(a1 + 48));
    }
    return;
  }
  double v11 = vabdd_f64(v8, v6);
  double v12 = 180.0;
  if (v11 == 180.0) {
    goto LABEL_4;
  }
  double v13 = v8 - v6;
  if ((*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v16 = fabs(v11 + -180.0);
    double v12 = 180.0;
    if (v11 < 180.0) {
      double v11 = 180.0;
    }
    double v17 = v11 >= 1.0 ? v11 * 2.22044605e-16 : 2.22044605e-16;
    if (v16 <= v17) {
      goto LABEL_4;
    }
  }
  double v12 = 180.0;
  if (v13 <= 180.0)
  {
    if (v13 >= -180.0) {
      goto LABEL_5;
    }
    double v12 = fmod(v13 + -180.0, 360.0) + 180.0;
LABEL_4:
    double v13 = v12;
    goto LABEL_5;
  }
  double v13 = fmod(v13 + 180.0, 360.0) + -180.0;
  if (v13 == -180.0) {
    goto LABEL_4;
  }
  BOOL v18 = ((*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
     && (*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
  if (!v18 || *(void *)&v13 == 0)
  {
    double v12 = 180.0;
    double v20 = fabs(v13 + 180.0);
    double v21 = fabs(v13);
    if (v21 < 180.0) {
      double v21 = 180.0;
    }
    double v22 = v21 >= 1.0 ? v21 * 2.22044605e-16 : 2.22044605e-16;
    if (v20 <= v22) {
      goto LABEL_4;
    }
  }
LABEL_5:
  if (v13 < 0.0) {
    double v13 = v13 + 360.0;
  }
  double v14 = v6 + v13;
  double v15 = v10 + v6 + v13 + -360.0;
  if (vabdd_f64(v15, v9) < 180.0) {
    double v15 = v9;
  }
  if (v14 <= v7 || v15 >= v6) {
    goto LABEL_11;
  }
}

void sub_101240044(double *a1, double *a2)
{
  double v3 = *a2;
  double v4 = a2[1];
  double v5 = a2[2];
  double v6 = a2[3];
  double v7 = 1.79769313e308;
  if (*a2 == 1.79769313e308 && v4 == 1.79769313e308 && v5 == -1.79769313e308 && v6 == -1.79769313e308)
  {
    double v13 = -1.79769313e308;
    double v4 = 1.79769313e308;
    double v6 = -1.79769313e308;
  }
  else
  {
    double v34 = a2[1];
    v35[0] = v3;
    double v32 = v6;
    double v33 = v5;
    double v11 = vabdd_f64(v3, v5);
    if (v11 < 360.0)
    {
      if (COERCE_UNSIGNED_INT64(fabs(v3 - v5)) > 0x7FEFFFFFFFFFFFFFLL)
      {
        BOOL v12 = 0;
      }
      else
      {
        double v14 = vabdd_f64(360.0, v11);
        double v15 = fmax(v11, 360.0);
        if (v15 >= 1.0) {
          double v16 = v15 * 2.22044605e-16;
        }
        else {
          double v16 = 2.22044605e-16;
        }
        BOOL v12 = v14 <= v16;
      }
    }
    else
    {
      BOOL v12 = 1;
    }
    sub_10123F230(v35, &v34, &v33, &v32, v12);
    double v7 = v35[0];
    double v13 = v33;
  }
  v35[0] = v7;
  v35[1] = v4;
  v35[2] = v13;
  v35[3] = v6;
  double v17 = *a1;
  double v18 = a1[1];
  double v19 = a1[2];
  double v20 = a1[3];
  double v21 = 1.79769313e308;
  if (*a1 == 1.79769313e308 && v18 == 1.79769313e308 && v19 == -1.79769313e308 && v20 == -1.79769313e308)
  {
    double v27 = -1.79769313e308;
    double v18 = 1.79769313e308;
    double v20 = -1.79769313e308;
  }
  else
  {
    double v33 = a1[1];
    double v34 = v17;
    double v31 = v20;
    double v32 = v19;
    double v25 = vabdd_f64(v17, v19);
    if (v25 < 360.0)
    {
      if (COERCE_UNSIGNED_INT64(fabs(v17 - v19)) > 0x7FEFFFFFFFFFFFFFLL)
      {
        BOOL v26 = 0;
      }
      else
      {
        double v28 = vabdd_f64(360.0, v25);
        double v29 = fmax(v25, 360.0);
        if (v29 >= 1.0) {
          double v30 = v29 * 2.22044605e-16;
        }
        else {
          double v30 = 2.22044605e-16;
        }
        BOOL v26 = v28 <= v30;
      }
    }
    else
    {
      BOOL v26 = 1;
    }
    sub_10123F230(&v34, &v33, &v32, &v31, v26);
    double v21 = v34;
    double v27 = v32;
  }
  v35[4] = v21;
  v35[5] = v18;
  v35[6] = v27;
  v35[7] = v20;
  sub_10123E140(v35, a1);
}

void sub_101240254(double *a1, double *a2, uint64_t **a3, void **a4, void **a5, void **a6)
{
  double v6 = *a3;
  if (*a3 != a3[1])
  {
    while (1)
    {
      uint64_t v13 = *v6;
      double v14 = *a1;
      double v15 = a1[2];
      double v16 = *(double *)(*v6 + 32);
      double v17 = *(double *)(*v6 + 48);
      double v18 = v17 - v16;
      if (v15 - *a1 < 360.0 && v18 < 360.0) {
        break;
      }
LABEL_12:
      if (a1[3] >= *(double *)(v13 + 40))
      {
        BOOL v24 = a1[1] <= *(double *)(v13 + 56);
        goto LABEL_15;
      }
LABEL_13:
      BOOL v24 = 0;
LABEL_15:
      double v25 = *a2;
      double v26 = a2[2];
      if (v26 - *a2 >= 360.0 || v18 >= 360.0) {
        goto LABEL_25;
      }
      double v27 = vabdd_f64(v16, v25);
      double v28 = 180.0;
      if (v27 == 180.0) {
        goto LABEL_18;
      }
      double v29 = v16 - v25;
      if (COERCE__INT64(fabs(v16 - v25)) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v47 = fabs(v27 + -180.0);
        if (v27 < 180.0) {
          double v27 = 180.0;
        }
        double v48 = v27 >= 1.0 ? v27 * 2.22044605e-16 : 2.22044605e-16;
        BOOL v42 = v47 > v48;
        double v28 = 180.0;
        if (!v42) {
          goto LABEL_18;
        }
      }
      if (v29 <= 180.0)
      {
        if (v29 < -180.0)
        {
          double v28 = fmod(v29 + -180.0, 360.0) + 180.0;
LABEL_18:
          double v29 = v28;
        }
      }
      else
      {
        double v29 = fmod(v29 + 180.0, 360.0) + -180.0;
        double v28 = 180.0;
        if (v29 == -180.0) {
          goto LABEL_18;
        }
        BOOL v49 = ((*(void *)&v29 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
           && (*(void *)&v29 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
        if (!v49 || *(void *)&v29 == 0)
        {
          double v51 = fabs(v29 + 180.0);
          double v52 = fabs(v29);
          if (v52 < 180.0) {
            double v52 = 180.0;
          }
          double v53 = v52 >= 1.0 ? v52 * 2.22044605e-16 : 2.22044605e-16;
          BOOL v42 = v51 > v53;
          double v28 = 180.0;
          if (!v42) {
            goto LABEL_18;
          }
        }
      }
      if (v29 < 0.0) {
        double v29 = v29 + 360.0;
      }
      double v30 = v25 + v29;
      double v31 = v18 + v25 + v29 + -360.0;
      if (vabdd_f64(v31, v17) < 180.0) {
        double v31 = v17;
      }
      if (v30 > v26 && v31 < v25)
      {
LABEL_27:
        if (v24)
        {
          double v33 = a4[1];
          unint64_t v32 = (unint64_t)a4[2];
          if ((unint64_t)v33 >= v32)
          {
            uint64_t v35 = ((char *)v33 - (unsigned char *)*a4) >> 3;
            if ((unint64_t)(v35 + 1) >> 61) {
              goto LABEL_139;
            }
            uint64_t v36 = v32 - (void)*a4;
            uint64_t v37 = v36 >> 2;
            if (v36 >> 2 <= (unint64_t)(v35 + 1)) {
              uint64_t v37 = v35 + 1;
            }
            if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v38 = v37;
            }
            if (v38)
            {
              unint64_t v38 = (unint64_t)sub_100048350(v38);
              uint64_t v13 = *v6;
            }
            else
            {
              uint64_t v39 = 0;
            }
            int64x2_t v60 = (void *)(v38 + 8 * v35);
            void *v60 = v13;
            double v34 = v60 + 1;
            double v62 = (char *)*a4;
            int v61 = (char *)a4[1];
            if (v61 != *a4)
            {
              do
              {
                uint64_t v63 = *((void *)v61 - 1);
                v61 -= 8;
                *--int64x2_t v60 = v63;
              }
              while (v61 != v62);
              int v61 = (char *)*a4;
            }
            *a4 = v60;
            a4[1] = v34;
            a4[2] = (void *)(v38 + 8 * v39);
            if (v61) {
              operator delete(v61);
            }
          }
          else
          {
            *double v33 = v13;
            double v34 = v33 + 1;
          }
          a4[1] = v34;
        }
        goto LABEL_102;
      }
LABEL_25:
      if (a2[3] < *(double *)(v13 + 40) || a2[1] > *(double *)(v13 + 56)) {
        goto LABEL_27;
      }
      if (v24)
      {
        double v55 = a6[1];
        unint64_t v54 = (unint64_t)a6[2];
        if ((unint64_t)v55 >= v54)
        {
          uint64_t v64 = ((char *)v55 - (unsigned char *)*a6) >> 3;
          if ((unint64_t)(v64 + 1) >> 61) {
            goto LABEL_139;
          }
          uint64_t v65 = v54 - (void)*a6;
          uint64_t v66 = v65 >> 2;
          if (v65 >> 2 <= (unint64_t)(v64 + 1)) {
            uint64_t v66 = v64 + 1;
          }
          if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v67 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v67 = v66;
          }
          if (v67)
          {
            unint64_t v67 = (unint64_t)sub_100048350(v67);
            uint64_t v13 = *v6;
          }
          else
          {
            uint64_t v68 = 0;
          }
          uint64_t v74 = (void *)(v67 + 8 * v64);
          *uint64_t v74 = v13;
          double v56 = v74 + 1;
          uint64_t v76 = (char *)*a6;
          uint64_t v75 = (char *)a6[1];
          if (v75 != *a6)
          {
            do
            {
              uint64_t v77 = *((void *)v75 - 1);
              v75 -= 8;
              *--uint64_t v74 = v77;
            }
            while (v75 != v76);
            uint64_t v75 = (char *)*a6;
          }
          *a6 = v74;
          a6[1] = v56;
          a6[2] = (void *)(v67 + 8 * v68);
          if (v75) {
            operator delete(v75);
          }
        }
        else
        {
          *double v55 = v13;
          double v56 = v55 + 1;
        }
        a6[1] = v56;
      }
      else
      {
        double v58 = a5[1];
        unint64_t v57 = (unint64_t)a5[2];
        if ((unint64_t)v58 >= v57)
        {
          uint64_t v69 = ((char *)v58 - (unsigned char *)*a5) >> 3;
          if ((unint64_t)(v69 + 1) >> 61) {
LABEL_139:
          }
            sub_10006A748();
          uint64_t v70 = v57 - (void)*a5;
          uint64_t v71 = v70 >> 2;
          if (v70 >> 2 <= (unint64_t)(v69 + 1)) {
            uint64_t v71 = v69 + 1;
          }
          if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v72 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v72 = v71;
          }
          if (v72)
          {
            unint64_t v72 = (unint64_t)sub_100048350(v72);
            uint64_t v13 = *v6;
          }
          else
          {
            uint64_t v73 = 0;
          }
          uint64_t v78 = (void *)(v72 + 8 * v69);
          *uint64_t v78 = v13;
          int64x2_t v59 = v78 + 1;
          long long v80 = (char *)*a5;
          int64_t v79 = (char *)a5[1];
          if (v79 != *a5)
          {
            do
            {
              uint64_t v81 = *((void *)v79 - 1);
              v79 -= 8;
              *--uint64_t v78 = v81;
            }
            while (v79 != v80);
            int64_t v79 = (char *)*a5;
          }
          *a5 = v78;
          a5[1] = v59;
          a5[2] = (void *)(v72 + 8 * v73);
          if (v79) {
            operator delete(v79);
          }
        }
        else
        {
          void *v58 = v13;
          int64x2_t v59 = v58 + 1;
        }
        a5[1] = v59;
      }
LABEL_102:
      if (++v6 == a3[1]) {
        return;
      }
    }
    double v19 = vabdd_f64(v16, v14);
    double v20 = 180.0;
    if (v19 == 180.0) {
      goto LABEL_5;
    }
    double v21 = v16 - v14;
    if (COERCE__INT64(fabs(v16 - v14)) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      double v40 = fabs(v19 + -180.0);
      if (v19 < 180.0) {
        double v19 = 180.0;
      }
      double v41 = v19 >= 1.0 ? v19 * 2.22044605e-16 : 2.22044605e-16;
      BOOL v42 = v40 > v41;
      double v20 = 180.0;
      if (!v42) {
        goto LABEL_5;
      }
    }
    if (v21 <= 180.0)
    {
      if (v21 < -180.0)
      {
        double v20 = fmod(v21 + -180.0, 360.0) + 180.0;
LABEL_5:
        double v21 = v20;
      }
    }
    else
    {
      double v21 = fmod(v21 + 180.0, 360.0) + -180.0;
      double v20 = 180.0;
      if (v21 == -180.0) {
        goto LABEL_5;
      }
      BOOL v42 = ((*(void *)&v21 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
         && (*(void *)&v21 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
      if (!v42 || *(void *)&v21 == 0)
      {
        double v44 = fabs(v21 + 180.0);
        double v45 = fabs(v21);
        if (v45 < 180.0) {
          double v45 = 180.0;
        }
        double v46 = v45 >= 1.0 ? v45 * 2.22044605e-16 : 2.22044605e-16;
        BOOL v42 = v44 > v46;
        double v20 = 180.0;
        if (!v42) {
          goto LABEL_5;
        }
      }
    }
    if (v21 < 0.0) {
      double v21 = v21 + 360.0;
    }
    double v22 = v14 + v21;
    double v23 = v18 + v14 + v21 + -360.0;
    if (vabdd_f64(v23, v17) < 180.0) {
      double v23 = v17;
    }
    if (v22 > v15 && v23 < v14) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
}

void sub_101240848(double *a1, uint64_t **a2, uint64_t **a3, unint64_t a4, uint64_t a5)
{
  double v8 = a1[1] + a1[3];
  long long v81 = *(_OWORD *)a1;
  uint64_t v82 = *((void *)a1 + 2);
  long long v9 = *((_OWORD *)a1 + 1);
  *(void *)&v79[0] = v81;
  long long v80 = v9;
  double v83 = v8 * 0.5;
  v79[1] = v8 * 0.5;
  uint64_t v76 = 0;
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  uint64_t v73 = 0;
  uint64_t v74 = 0;
  uint64_t v75 = 0;
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  unint64_t v67 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  long long __p = 0;
  uint64_t v65 = 0;
  uint64_t v66 = 0;
  int v61 = 0;
  double v62 = 0;
  uint64_t v63 = 0;
  sub_101240254((double *)&v81, v79, a2, (void **)&v76, (void **)&v73, (void **)&v70);
  sub_101240254((double *)&v81, v79, a3, &v67, &__p, (void **)&v61);
  double v11 = v70;
  double v10 = v71;
  BOOL v12 = v61;
  double v58 = v70;
  if (v70 == v71)
  {
    double v14 = v62;
  }
  else
  {
    unint64_t v13 = (char *)v71 - (char *)v70;
    double v14 = v62;
    if ((unint64_t)((char *)v71 - (char *)v70) < 0x80
      || a4 > 0x63
      || (unint64_t)((char *)v62 - (char *)v61) < 0x79)
    {
      if (v61 != v62)
      {
        double v15 = v62;
        double v16 = v70;
        do
        {
          BOOL v42 = v12 == v15;
          double v15 = v12;
          if (!v42)
          {
            double v17 = v12;
            do
              sub_10123FE18(a5, *v16, *v17++);
            while (v17 != v14);
            double v15 = v14;
          }
          ++v16;
        }
        while (v16 != v10);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      do
        sub_101240044((double *)v84.i64, *v11++ + 4);
      while (v11 != v10);
      uint64_t v19 = v84.i64[1];
      uint64_t v18 = v84.i64[0];
      uint64_t v21 = v85.i64[1];
      uint64_t v20 = v85.i64[0];
      if (v12 != v14)
      {
        double v22 = v12;
        do
          sub_101240044((double *)v84.i64, *v22++ + 4);
        while (v22 != v14);
        uint64_t v19 = v84.i64[1];
        uint64_t v18 = v84.i64[0];
        uint64_t v21 = v85.i64[1];
        uint64_t v20 = v85.i64[0];
      }
      v59.i64[0] = v18;
      v59.i64[1] = v19;
      v60.i64[0] = v20;
      v60.i64[1] = v21;
      sub_10123F750(&v59, &v70, &v61, a4 + 1, a5);
    }
    BOOL v24 = (double **)v67;
    double v23 = v68;
    if ((unint64_t)((char *)v68 - (unsigned char *)v67) < 0x80
      || (unint64_t)((char *)v65 - (unsigned char *)__p) < 0x80
      || a4 > 0x63
      || v13 < 0x79)
    {
      if (v67 != v68)
      {
        double v25 = v68;
        double v26 = v58;
        do
        {
          BOOL v42 = v24 == v25;
          double v25 = v24;
          if (!v42)
          {
            double v27 = v24;
            do
              sub_10123FE18(a5, *v26, *v27++);
            while (v27 != v23);
            double v25 = v23;
          }
          ++v26;
        }
        while (v26 != v10);
      }
      double v28 = (double **)__p;
      double v29 = v65;
      if (__p != v65)
      {
        double v30 = v65;
        double v31 = v58;
        do
        {
          BOOL v42 = v28 == v30;
          double v30 = v28;
          if (!v42)
          {
            unint64_t v32 = v28;
            do
              sub_10123FE18(a5, *v31, *v32++);
            while (v32 != v29);
            double v30 = v29;
          }
          ++v31;
        }
        while (v31 != v10);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      unint64_t v57 = v58;
      do
        sub_101240044((double *)v84.i64, *v57++ + 4);
      while (v57 != v10);
      int64x2_t v59 = v84;
      int64x2_t v60 = v85;
      sub_10123F750(&v59, &v70, &v67, a4 + 1, a5);
      sub_10123F750(&v59, &v70, &__p, a4 + 1, a5);
    }
  }
  double v33 = v76;
  double v34 = v77;
  unint64_t v35 = (char *)v77 - (char *)v76;
  if (v12 != v14)
  {
    if (v35 < 0x80
      || (unint64_t)((char *)v74 - (char *)v73) < 0x80
      || a4 > 0x63
      || (unint64_t)((char *)v14 - (char *)v12) < 0x79)
    {
      if (v76 != v77)
      {
        uint64_t v37 = v14;
        unint64_t v38 = v76;
        do
        {
          BOOL v42 = v12 == v37;
          uint64_t v37 = v12;
          if (!v42)
          {
            uint64_t v39 = v12;
            do
              sub_10123FE18(a5, *v38, *v39++);
            while (v39 != v14);
            uint64_t v37 = v14;
          }
          ++v38;
        }
        while (v38 != v34);
      }
      double v40 = v73;
      double v41 = v74;
      BOOL v42 = v73 == v74 || v12 == v14;
      if (!v42)
      {
        uint64_t v43 = v14;
        do
        {
          BOOL v42 = v12 == v43;
          uint64_t v43 = v12;
          if (!v42)
          {
            double v44 = v12;
            do
              sub_10123FE18(a5, *v40, *v44++);
            while (v44 != v14);
            uint64_t v43 = v14;
          }
          ++v40;
        }
        while (v40 != v41);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      uint64_t v36 = v12;
      do
        sub_101240044((double *)v84.i64, *v36++ + 4);
      while (v36 != v14);
      int64x2_t v59 = v84;
      int64x2_t v60 = v85;
      sub_10123F750(&v59, &v76, &v61, a4 + 1, a5);
      sub_10123F750(&v59, &v73, &v61, a4 + 1, a5);
    }
  }
  if (v35 < 0x80 || a4 > 0x63 || (unint64_t)((char *)v68 - (unsigned char *)v67) < 0x79)
  {
    if (v33 != v34)
    {
      double v45 = (double **)v67;
      double v46 = v68;
      if (v67 != v68)
      {
        double v47 = v68;
        double v48 = v33;
        do
        {
          BOOL v42 = v45 == v47;
          double v47 = v45;
          if (!v42)
          {
            BOOL v49 = v45;
            do
              sub_10123FE18(a5, *v48, *v49++);
            while (v49 != v46);
            double v47 = v46;
          }
          ++v48;
        }
        while (v48 != v34);
      }
    }
  }
  else
  {
    sub_10123F750(&v81, &v76, &v67, a4 + 1, a5);
  }
  double v50 = v73;
  double v51 = v74;
  if ((unint64_t)((char *)v74 - (char *)v73) < 0x80
    || a4 > 0x63
    || (unint64_t)((char *)v65 - (unsigned char *)__p) < 0x79)
  {
    if (v73 != v74)
    {
      double v52 = (double **)__p;
      double v53 = v65;
      if (__p != v65)
      {
        unint64_t v54 = v65;
        double v55 = v73;
        do
        {
          BOOL v42 = v52 == v54;
          unint64_t v54 = v52;
          if (!v42)
          {
            double v56 = v52;
            do
              sub_10123FE18(a5, *v55, *v56++);
            while (v56 != v53);
            unint64_t v54 = v53;
          }
          ++v55;
        }
        while (v55 != v51);
      }
    }
  }
  else
  {
    sub_10123F750(v79, &v73, &__p, a4 + 1, a5);
  }
  if (v12) {
    operator delete(v12);
  }
  if (__p) {
    operator delete(__p);
  }
  if (v67) {
    operator delete(v67);
  }
  if (v58) {
    operator delete(v58);
  }
  if (v50) {
    operator delete(v50);
  }
  if (v33)
  {
    operator delete(v33);
  }
}

void sub_101240E88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30)
{
  if (v30) {
    operator delete(v30);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a24) {
    operator delete(a24);
  }
  if (a27) {
    operator delete(a27);
  }
  if (a30) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

void sub_101240F1C(int a1, double **a2, uint64_t a3, int a4, double **a5, uint64_t a6, int a7, uint64_t a8, uint64_t a9, void *a10)
{
  uint64_t v11 = a6;
  if (*(unsigned char *)(a3 + 96) && (unint64_t)(*(void *)(a3 + 80) + 1) < *(void *)(a3 + 88)
    || *(unsigned char *)(a6 + 96) && (unint64_t)(*(void *)(a6 + 80) + 1) < *(void *)(a6 + 88))
  {
    return;
  }
  unint64_t v12 = *(void *)(a3 + 24);
  if ((v12 & 0x8000000000000000) == 0)
  {
    unint64_t v13 = a2[3];
    if (0xAAAAAAAAAAAAAAABLL * (a2[4] - v13) < v12) {
      goto LABEL_416;
    }
    a2 = (double **)&v13[3 * v12];
  }
  double v14 = *a2;
  uint64_t v255 = a2[1];
  unint64_t v15 = *(void *)(a6 + 24);
  if ((v15 & 0x8000000000000000) != 0) {
    goto LABEL_11;
  }
  double v16 = a5[3];
  if (0xAAAAAAAAAAAAAAABLL * (a5[4] - v16) < v15) {
LABEL_416:
  }
    __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
  a5 = (double **)&v16[3 * v15];
LABEL_11:
  uint64_t v265 = a5[1];
  uint64_t v266 = *a5;
  int v17 = *(_DWORD *)a3;
  int v262 = *(_DWORD *)a6;
  uint64_t v259 = *(void *)(a3 + 104);
  uint64_t v18 = *(void *)(a3 + 64);
  uint64_t v19 = *(void *)(a3 + 72);
  uint64_t v20 = &v14[2 * v18];
  if (v18 != v19)
  {
    double v21 = *(double *)(a3 + 32);
    double v22 = *(double *)(a3 + 48);
    double v23 = *(double *)(a6 + 32);
    double v24 = *(double *)(a6 + 48);
    uint64_t v25 = 16 * v19 - 16 * v18;
    double v26 = &v14[2 * v18];
    while (1)
    {
      double v27 = v20;
      uint64_t v28 = v18;
      double v29 = v26[2];
      v26 += 2;
      if (!sub_1012429C0(v17, v29, v21, v22, v23, v24)) {
        break;
      }
      uint64_t v18 = v28 + 1;
      ++v259;
      uint64_t v20 = v26;
      v25 -= 16;
      if (!v25) {
        return;
      }
    }
    uint64_t v18 = v28;
    uint64_t v20 = v27;
  }
  double v237 = &v14[2 * v19];
  if (v20 != v237)
  {
    double v30 = v20 + 2;
    double v31 = &v14[2 * (v20 != v14)];
    if (v20 + 2 != v255) {
      double v31 = v20 + 2;
    }
    unint64_t v32 = v31 + 2;
    double v33 = &v14[2 * (v31 != v14)];
    if (v32 == v255) {
      double v34 = v33;
    }
    else {
      double v34 = v32;
    }
    int v236 = -v17;
    double v35 = 1.0;
    uint64_t v254 = a8;
    uint64_t v257 = v11;
    uint64_t v235 = v14;
    while (1)
    {
      v258 = v20;
      uint64_t v264 = v18;
      double v36 = *(double *)(a3 + 32);
      double v37 = *(double *)(a3 + 48);
      double v38 = *(double *)(v11 + 32);
      double v39 = *(double *)(v11 + 48);
      if (sub_1012429C0(v236, *v20, v36, v37, v38, v39)) {
        return;
      }
      memset(v283, 0, sizeof(v283));
      v277[0] = a3;
      v277[1] = v264;
      v278 = v258;
      double v252 = v34;
      double v253 = v30;
      double v279 = v30;
      double v280 = v34;
      uint64_t v281 = v14;
      uint64_t v282 = v255;
      LOBYTE(v283[0]) = 1;
      uint64_t v40 = *(void *)(v11 + 64);
      uint64_t v41 = *(void *)(v11 + 72);
      BOOL v42 = &v266[2 * v40];
      uint64_t v269 = *(void *)(v11 + 104);
      if (v40 != v41)
      {
        uint64_t v229 = 16 * v41 - 16 * v40;
        uint64_t v230 = &v266[2 * v40];
        while (1)
        {
          double v231 = v230[2];
          v230 += 2;
          if (!sub_1012429C0(v262, v231, v38, v39, v36, v37)) {
            break;
          }
          ++v40;
          ++v269;
          BOOL v42 = v230;
          v229 -= 16;
          if (!v229) {
            goto LABEL_409;
          }
        }
      }
      uint64_t v261 = &v266[2 * v41];
      if (v42 != v261) {
        break;
      }
LABEL_409:
      ++v259;
      uint64_t v11 = v257;
LABEL_410:
      uint64_t v20 = v258 + 2;
      double v30 = v253 + 2;
      uint64_t v18 = v264 + 1;
      double v14 = v235;
      if (v252 + 2 == v255) {
        double v34 = &v235[2 * (v252 != v235)];
      }
      else {
        double v34 = v252 + 2;
      }
      if (v253 == v237) {
        return;
      }
    }
    uint64_t v43 = v42 + 2;
    double v44 = &v266[2 * (v42 != v266)];
    if (v42 + 2 != v265) {
      double v44 = v42 + 2;
    }
    double v45 = v44 + 2;
    double v46 = &v266[2 * (v44 != v266)];
    if (v45 != v265) {
      double v46 = v45;
    }
    BOOL v268 = v46;
    ++v259;
    uint64_t v11 = v257;
    int v47 = a4;
    uint64_t v48 = a3;
    while (1)
    {
      uint64_t v267 = v43;
      if (sub_1012429C0(-v262, *v42, *(double *)(v11 + 32), *(double *)(v11 + 48), *(double *)(v48 + 32), *(double *)(v48 + 48)))
      {
        goto LABEL_410;
      }
      if (a1 != v47
        || *(void *)(v48 + 16) != *(void *)(v11 + 16)
        || *(void *)(v48 + 24) != *(void *)(v11 + 24)
        || !a7
        || v269 != v259 && (v264 || *(void *)(v48 + 88) - 2 > v40))
      {
        break;
      }
LABEL_386:
      v42 += 2;
      ++v40;
      if (v268 + 2 == v265) {
        v225 = &v266[2 * (v268 != v266)];
      }
      else {
        v225 = v268 + 2;
      }
      BOOL v268 = v225;
      ++v269;
      uint64_t v43 = v267 + 2;
      if (v267 == v261) {
        goto LABEL_410;
      }
    }
    uint64_t v49 = 0;
    memset(v276, 0, sizeof(v276));
    v271[0] = v11;
    v271[1] = v40;
    v271[2] = v42;
    uint64_t v272 = v267;
    double v273 = v268;
    double v274 = v266;
    uint64_t v275 = v265;
    memset(&__src[2], 0, 344);
    memset(__src, 0, 24);
    *((void *)&__src[1] + 1) = -1;
    *(void *)&long long v50 = -1;
    *((void *)&v50 + 1) = -1;
    do
    {
      double v51 = (char *)__src + v49;
      *((_DWORD *)v51 + 10) = 0;
      *((_OWORD *)v51 + 3) = v50;
      *((_OWORD *)v51 + 4) = v50;
      *((void *)v51 + 10) = -1;
      *(_OWORD *)(v51 + 88) = xmmword_1015E0D30;
      *((void *)v51 + 13) = 0;
      *((void *)v51 + 14) = 0;
      *((void *)v51 + 15) = -1;
      *((void *)v51 + 16) = -1;
      *((void *)v51 + 17) = -1;
      *((_WORD *)v51 + 72) = 257;
      *((void *)v51 + 19) = 0;
      *((void *)v51 + 20) = 0;
      *((void *)v51 + 21) = -1;
      *((void *)v51 + 22) = -1;
      *((void *)v51 + 23) = -1;
      v51[192] = 0;
      *((_DWORD *)v51 + 50) = 0;
      v49 += 168;
      *((_WORD *)v51 + 102) = 0;
    }
    while (v49 != 336);
    *(void *)&__src[3] = a1;
    *(_OWORD *)((char *)&__src[3] + 8) = *(_OWORD *)(v48 + 16);
    *((void *)&__src[4] + 1) = v264;
    *(void *)&__src[5] = -1;
    *((void *)&__src[13] + 1) = a4;
    __src[14] = *(_OWORD *)(v11 + 16);
    *(void *)&__src[15] = v40;
    *((void *)&__src[15] + 1) = -1;
    uint64_t v301 = 0;
    long long v299 = 0u;
    long long v300 = 0u;
    long long v297 = 0u;
    long long v298 = 0u;
    memset(v296, 0, sizeof(v296));
    long long v294 = 0u;
    long long v295 = 0u;
    long long v293 = 0u;
    memset(v292, 0, sizeof(v292));
    uint64_t v287 = 0;
    long long v289 = 0u;
    uint64_t v285 = v277;
    char v286 = v271;
    uint64_t v288 = v277;
    *(void *)&long long v289 = v271;
    char v290 = v271;
    uint64_t v291 = v277;
    sub_101243388((uint64_t)v292, v278, v279, v42, v267);
    *((void *)&v300 + 1) = a8;
    uint64_t v301 = a9;
    if (BYTE8(v297) == 100) {
      goto LABEL_385;
    }
    memcpy(__dst, __src, sizeof(__dst));
    if (BYTE8(v297) <= 0x6Cu)
    {
      if (BYTE8(v297) != 99)
      {
        if (BYTE8(v297) == 105)
        {
          *(_DWORD *)&__dst[16] = 2;
          if (!v292[0]) {
            goto LABEL_415;
          }
          *(_OWORD *)long long __dst = *(_OWORD *)&v292[1];
          *(_OWORD *)&__dst[88] = *(_OWORD *)&v292[5];
          *(void *)&__dst[104] = v292[7];
          *(_OWORD *)&__dst[256] = v293;
          *(void *)&__dst[272] = v294;
          BOOL v52 = DWORD1(v299) == 1;
          *(_DWORD *)&__dst[168 * (DWORD1(v299) != 1) + 40] = 1;
          *(_DWORD *)&__dst[168 * v52 + 40] = 2;
          goto LABEL_383;
        }
LABEL_136:
        if (BYTE8(v297) != 101 || BYTE9(v297)) {
          goto LABEL_385;
        }
        sub_101243090((uint64_t)__dst, (uint64_t)v292, (uint64_t)&v287);
        goto LABEL_383;
      }
      if (!BYTE9(v297))
      {
        if (HIDWORD(v299))
        {
          if (vabdd_f64(*(double *)&v294, *(double *)&v296[3]) >= 50.0)
          {
            BOOL v120 = *(double *)&v294 < *(double *)&v296[3];
          }
          else
          {
            if (*((double *)&v293 + 1) == 0.0) {
              __assert_rtn("apply", "segment_ratio.hpp", 56, "lhs.denominator() != Type(0)");
            }
            if (*(double *)&v296[2] == 0.0) {
              __assert_rtn("apply", "segment_ratio.hpp", 57, "rhs.denominator() != Type(0)");
            }
            double v118 = *(double *)&v293 / *((double *)&v293 + 1);
            double v119 = *(double *)&v296[1] / *(double *)&v296[2];
            if (*(double *)&v293 / *((double *)&v293 + 1) == *(double *)&v296[1] / *(double *)&v296[2])
            {
              BOOL v120 = 0;
            }
            else if (COERCE_UNSIGNED_INT64(fabs(*(double *)&v293 / *((double *)&v293 + 1))) > 0x7FEFFFFFFFFFFFFFLL {
                   || COERCE_UNSIGNED_INT64(fabs(*(double *)&v296[1] / *(double *)&v296[2])) > 0x7FEFFFFFFFFFFFFFLL)
            }
            {
              BOOL v120 = 1;
            }
            else
            {
              double v165 = vabdd_f64(v118, v119);
              double v166 = fabs(v118);
              double v167 = fabs(v119);
              if (v166 < v167) {
                double v166 = v167;
              }
              if (v166 >= v35) {
                double v168 = v166 * 2.22044605e-16;
              }
              else {
                double v168 = 2.22044605e-16;
              }
              BOOL v120 = v165 > v168;
            }
            if (v118 >= v119) {
              BOOL v120 = 0;
            }
          }
          *(_DWORD *)&__dst[16] = 5;
          if (v292[0] <= (unint64_t)v120) {
LABEL_415:
          }
            __assert_rtn("assign_point", "get_turn_info.hpp", 164, "index < info.count");
          int v251 = HIDWORD(v299);
          *(_OWORD *)long long __dst = *(_OWORD *)&v292[2 * v120 + 1];
          double v170 = &v292[7 * v120];
          *(void *)&__dst[104] = v170[7];
          *(_OWORD *)&__dst[88] = *(_OWORD *)(v170 + 5);
          *(_OWORD *)&__dst[256] = *((_OWORD *)v170 + 4);
          *(void *)&__dst[272] = v170[10];
          uint64_t v171 = (uint64_t)v288;
          double v172 = (double *)v288[2];
          double v173 = (double *)v288[3];
          if (!*((unsigned char *)v288 + 80))
          {
            sub_101246990((uint64_t)v288, (uint64_t)(v288 + 4), *v173, v173[1]);
            *(_OWORD *)(v171 + 64) = *(_OWORD *)*(void *)(v171 + 32);
            *(unsigned char *)(v171 + 80) = 1;
          }
          int v174 = sub_1012472B0(v172, v173, (double *)(v171 + 64));
          uint64_t v175 = v289;
          double v176 = *(double **)(v289 + 16);
          double v177 = *(double **)(v289 + 24);
          if (!*(unsigned char *)(v289 + 80))
          {
            sub_101246990(v289, v289 + 32, *v177, v177[1]);
            *(_OWORD *)(v175 + 64) = *(_OWORD *)*(void *)(v175 + 32);
            *(unsigned char *)(v175 + 80) = 1;
          }
          int v178 = sub_1012472B0(v176, v177, (double *)(v175 + 64));
          int v179 = v178;
          if (v251 == 1) {
            int v180 = v174;
          }
          else {
            int v180 = v178;
          }
          if (v180 * v251 == 1) {
            int v181 = 1;
          }
          else {
            int v181 = 2;
          }
          if (v180 * v251 == 1) {
            int v182 = 2;
          }
          else {
            int v182 = 1;
          }
          BOOL v183 = v180 == 0;
          if (v180) {
            int v184 = v181;
          }
          else {
            int v184 = 4;
          }
          if (v183) {
            int v185 = 4;
          }
          else {
            int v185 = v182;
          }
          *(_DWORD *)&__dst[40] = v184;
          *(_DWORD *)&__dst[208] = v185;
          if (v174)
          {
            double v187 = *(double *)&__dst[8];
            double v186 = *(double *)__dst;
            double v188 = (*(double *)&__dst[8] - v279[1]) * (*(double *)&__dst[8] - v279[1])
                 + (*(double *)__dst - *v279) * (*(double *)__dst - *v279);
            a8 = v254;
            uint64_t v11 = v257;
          }
          else
          {
            a8 = v254;
            uint64_t v11 = v257;
            if (!LOBYTE(v283[3]))
            {
              unint64_t v189 = 0;
              double v190 = v280;
              uint64_t v191 = *(void *)v279;
              double v192 = v279[1];
              double v193 = fabs(v192);
              while (1)
              {
                uint64_t v195 = *(void *)v190;
                double v194 = v190[1];
                *(void *)&v302[0] = v191;
                v303[0] = v192;
                sub_10123D770((double *)v302, v303, 1);
                double v196 = *(double *)v302;
                *(void *)&v302[0] = v195;
                v303[0] = v194;
                sub_10123D770((double *)v302, v303, 1);
                if (v196 != *(double *)v302)
                {
                  if ((*(void *)&v196 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                    || (*(void *)&v302[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                  {
                    break;
                  }
                  double v198 = vabdd_f64(v196, *(double *)v302);
                  double v199 = fabs(v196);
                  double v200 = fabs(*(double *)v302);
                  if (v199 >= v200) {
                    double v200 = v199;
                  }
                  double v201 = v200 >= v35 ? v200 * 2.22044605e-16 : 2.22044605e-16;
                  if (v198 > v201) {
                    break;
                  }
                }
                if (v194 != v192)
                {
                  if ((*(void *)&v192 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
                    || (*(void *)&v194 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                  {
                    break;
                  }
                  double v202 = vabdd_f64(v192, v194);
                  double v203 = fabs(v194);
                  if (v193 >= v203) {
                    double v203 = v193;
                  }
                  double v204 = v203 >= v35 ? v203 * 2.22044605e-16 : 2.22044605e-16;
                  if (v202 > v204) {
                    break;
                  }
                }
                if (v189 >= *(void *)(v277[0] + 88)) {
                  break;
                }
                double v205 = v280;
                double v190 = v280 + 2;
                double v280 = v190;
                if (v190 == v282)
                {
                  double v280 = v281;
                  if (LOBYTE(v283[0]))
                  {
                    double v190 = v281 + 2;
                    double v280 = v281 + 2;
                    if (v205 == v281)
                    {
                      double v280 = v281;
                      double v190 = v205;
                    }
                  }
                  else
                  {
                    double v190 = v281;
                  }
                }
                ++v189;
              }
              *(_OWORD *)&v283[1] = *(_OWORD *)v280;
              LOBYTE(v283[3]) = 1;
              uint64_t v11 = v257;
            }
            double v187 = *(double *)&__dst[8];
            double v186 = *(double *)__dst;
            double v188 = (*(double *)&__dst[8] - *(double *)&v283[2]) * (*(double *)&__dst[8] - *(double *)&v283[2])
                 + (*(double *)__dst - *(double *)&v283[1]) * (*(double *)__dst - *(double *)&v283[1]);
          }
          int v47 = a4;
          *(double *)&__dst[112] = v188;
          if (v179)
          {
            double v206 = *v272;
            double v207 = v272[1];
          }
          else
          {
            if (!LOBYTE(v276[3]))
            {
              unint64_t v208 = 0;
              long long v209 = v273;
              double v210 = *v272;
              double v211 = v272[1];
              double v212 = fabs(v211);
              while (1)
              {
                uint64_t v213 = *(void *)v209;
                double v214 = v209[1];
                *(double *)BOOL v302 = v210;
                v303[0] = v211;
                sub_10123D770((double *)v302, v303, 1);
                double v215 = *(double *)v302;
                *(void *)&v302[0] = v213;
                v303[0] = v214;
                sub_10123D770((double *)v302, v303, 1);
                if (v215 != *(double *)v302)
                {
                  if ((*(void *)&v215 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                    || (*(void *)&v302[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                  {
                    break;
                  }
                  double v217 = vabdd_f64(v215, *(double *)v302);
                  double v218 = fabs(v215);
                  double v219 = fabs(*(double *)v302);
                  if (v218 >= v219) {
                    double v219 = v218;
                  }
                  double v220 = v219 >= 1.0 ? v219 * 2.22044605e-16 : 2.22044605e-16;
                  if (v217 > v220) {
                    break;
                  }
                }
                if (v214 != v211)
                {
                  if ((*(void *)&v211 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
                    || (*(void *)&v214 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                  {
                    break;
                  }
                  double v221 = vabdd_f64(v211, v214);
                  double v222 = fabs(v214);
                  if (v212 >= v222) {
                    double v222 = v212;
                  }
                  double v223 = v222 >= 1.0 ? v222 * 2.22044605e-16 : 2.22044605e-16;
                  if (v221 > v223) {
                    break;
                  }
                }
                if (v208 >= *(void *)(v271[0] + 88)) {
                  break;
                }
                v224 = v273;
                long long v209 = v273 + 2;
                double v273 = v209;
                if (v209 == v275)
                {
                  double v273 = v274;
                  if (LOBYTE(v276[0]))
                  {
                    long long v209 = v274 + 2;
                    double v273 = v274 + 2;
                    if (v224 == v274)
                    {
                      double v273 = v274;
                      long long v209 = v224;
                    }
                  }
                  else
                  {
                    long long v209 = v274;
                  }
                }
                ++v208;
              }
              *(_OWORD *)&v276[1] = *(_OWORD *)v273;
              LOBYTE(v276[3]) = 1;
              int v47 = a4;
              double v35 = 1.0;
            }
            double v206 = *(double *)&v276[1];
            double v207 = *(double *)&v276[2];
          }
          *(double *)&__dst[280] = (v187 - v207) * (v187 - v207) + (v186 - v206) * (v186 - v206);
        }
        else
        {
          sub_101243090((uint64_t)__dst, (uint64_t)v292, (uint64_t)&v287);
          *(_DWORD *)&__dst[16] = 5;
        }
        goto LABEL_383;
      }
      memcpy(v302, __src, 0x178uLL);
      int v84 = v300;
      if (HIDWORD(v299) != 1) {
        goto LABEL_236;
      }
      uint64_t v85 = (uint64_t)v288;
      unint64_t v86 = (double *)v288[2];
      int v87 = (double *)v288[3];
      if (!*((unsigned char *)v288 + 80))
      {
        sub_101246990((uint64_t)v288, (uint64_t)(v288 + 4), *v87, v87[1]);
        *(_OWORD *)(v85 + 64) = *(_OWORD *)*(void *)(v85 + 32);
        *(unsigned char *)(v85 + 80) = 1;
      }
      int v88 = sub_1012472B0(v86, v87, (double *)(v85 + 64));
      if (v88 == 1)
      {
        int v89 = 2;
        uint64_t v11 = v257;
        int v47 = a4;
      }
      else
      {
        uint64_t v11 = v257;
        int v47 = a4;
        if (!v88)
        {
LABEL_236:
          _ZF = v84 == 1;
          a8 = v254;
          if (!_ZF) {
            goto LABEL_385;
          }
          uint64_t v149 = v289;
          uint64_t v150 = *(double **)(v289 + 16);
          unint64_t v151 = *(double **)(v289 + 24);
          if (!*(unsigned char *)(v289 + 80))
          {
            sub_101246990(v289, v289 + 32, *v151, v151[1]);
            *(_OWORD *)(v149 + 64) = *(_OWORD *)*(void *)(v149 + 32);
            *(unsigned char *)(v149 + 80) = 1;
          }
          int v152 = sub_1012472B0(v150, v151, (double *)(v149 + 64));
          if (v152 == 1)
          {
            int v153 = 2;
            uint64_t v11 = v257;
            int v47 = a4;
            goto LABEL_245;
          }
          uint64_t v11 = v257;
          int v47 = a4;
          if (v152)
          {
            if (v152 != -1)
            {
LABEL_246:
              DWORD2(v302[2]) = 3;
              LODWORD(v302[1]) = 5;
              if (!v292[0]) {
                goto LABEL_415;
              }
              v302[0] = *(_OWORD *)&v292[1];
              *(_OWORD *)((char *)&v302[5] + 8) = *(_OWORD *)&v292[5];
              *((void *)&v302[6] + 1) = v292[7];
              v302[16] = v293;
              *(void *)&v302[17] = v294;
              uint64_t v154 = v302;
              goto LABEL_384;
            }
            int v153 = 1;
LABEL_245:
            LODWORD(v302[13]) = v153;
            goto LABEL_246;
          }
LABEL_385:
          uint64_t v48 = a3;
          goto LABEL_386;
        }
        if (v88 != -1)
        {
LABEL_234:
          LODWORD(v302[13]) = 3;
          LODWORD(v302[1]) = 5;
          if (v292[0] <= 1uLL) {
            goto LABEL_415;
          }
          v302[0] = *(_OWORD *)&v292[3];
          *(_OWORD *)((char *)&v302[5] + 8) = v295;
          *((void *)&v302[6] + 1) = v296[0];
          v302[16] = *(_OWORD *)&v296[1];
          *(void *)&v302[17] = v296[3];
          sub_101246DB0(a10, v302);
          goto LABEL_236;
        }
        int v89 = 1;
      }
      DWORD2(v302[2]) = v89;
      goto LABEL_234;
    }
    __asm { FMOV            V0.2D, #1.0 }
    if (BYTE8(v297) != 116)
    {
      if (BYTE8(v297) != 109) {
        goto LABEL_136;
      }
      *(_DWORD *)&__dst[16] = 4;
      *(_OWORD *)long long __dst = *(_OWORD *)&v292[1];
      uint64_t v57 = 0;
      char v58 = 1;
      if (v300 == 1)
      {
        do
        {
          char v59 = v58;
          int v60 = *((_DWORD *)&v299 + v57 + 3);
          if (v60 == -1)
          {
            double v62 = &__dst[168 * v57 + 40];
            *((_OWORD *)v62 + 3) = xmmword_1015E0D30;
            *((void *)v62 + 8) = 0;
          }
          else if (v60 == 1)
          {
            int v61 = &__dst[168 * v57 + 40];
            *((_OWORD *)v61 + 3) = _Q0;
            *((void *)v61 + 8) = 0x412E848000000000;
          }
          else
          {
            if (v59) {
              uint64_t v63 = (long long *)&v292[5];
            }
            else {
              uint64_t v63 = &v293;
            }
            uint64_t v64 = &__dst[168 * v57 + 40];
            *((_OWORD *)v64 + 3) = *v63;
            *((void *)v64 + 8) = *((void *)v63 + 2);
          }
          char v58 = 0;
          uint64_t v57 = 1;
        }
        while ((v59 & 1) != 0);
        int v65 = DWORD1(v299);
        uint64_t v66 = v289;
        uint64_t v68 = (double *)v288[2];
        unint64_t v67 = (double *)v288[3];
        uint64_t v248 = (uint64_t)v288;
        if (!*(unsigned char *)(v289 + 80))
        {
          sub_101246990(v289, v289 + 32, **(double **)(v289 + 24), *(double *)(*(void *)(v289 + 24) + 8));
          *(_OWORD *)(v66 + 64) = *(_OWORD *)*(void *)(v66 + 32);
          *(unsigned char *)(v66 + 80) = 1;
        }
        int v69 = sub_1012472B0(v68, v67, (double *)(v66 + 64));
        int v70 = v69;
        if (!(v65 + v69))
        {
          BOOL v71 = v69 == -1;
          BOOL v72 = v69 != -1;
LABEL_77:
          *(_DWORD *)&__dst[168 * v72 + 40] = 1;
          *(_DWORD *)&__dst[168 * v71 + 40] = 2;
LABEL_185:
          a8 = v254;
LABEL_186:
          uint64_t v11 = v257;
          int v47 = a4;
LABEL_383:
          uint64_t v154 = __dst;
LABEL_384:
          sub_101246DB0(a10, v154);
          goto LABEL_385;
        }
        int v239 = v65;
        double v125 = *(double **)(v66 + 16);
        uint64_t v126 = *(double **)(v66 + 24);
        if (!*(unsigned char *)(v66 + 80))
        {
          double v242 = *(double **)(v66 + 16);
          sub_101246990(v66, v66 + 32, *v126, v126[1]);
          double v125 = v242;
          *(_OWORD *)(v66 + 64) = *(_OWORD *)*(void *)(v66 + 32);
          *(unsigned char *)(v66 + 80) = 1;
        }
        double v243 = (double *)(v66 + 64);
        int v127 = sub_1012472B0(v125, v126, (double *)(v66 + 64));
        int v128 = *(double **)(v66 + 24);
        if (!*(unsigned char *)(v66 + 80))
        {
          sub_101246990(v66, v66 + 32, *v128, v128[1]);
          *(_OWORD *)double v243 = *(_OWORD *)*(void *)(v66 + 32);
          *(unsigned char *)(v66 + 80) = 1;
        }
        int v129 = sub_1012472B0(v128, v243, *(double **)(v248 + 24));
        int v130 = v239;
        if ((v70 & v239) != 0xFFFFFFFF || v127 != 1)
        {
          a8 = v254;
          if (v239 == 1 && v70 == 1 && v127 == -1)
          {
            if (v129 == -1) {
              int v132 = 1;
            }
            else {
              int v132 = 3;
            }
            *(_DWORD *)&__dst[40] = 1;
            *(_DWORD *)&__dst[208] = v132;
            __dst[20] = 1;
            goto LABEL_186;
          }
          if (v239 == v70 && v239 == v127)
          {
            BOOL v158 = v127 == 1;
            BOOL v159 = v129 == 0;
LABEL_268:
            int v160 = v158 ^ v159;
            if (v129 * v130 == -1)
            {
              int v246 = v129;
              int v161 = sub_1012472B0(*(double **)(v248 + 16), *(double **)(v248 + 24), *(double **)(v66 + 24));
              uint64_t v162 = v248;
              double v163 = *(double **)(v248 + 24);
              if (!*(unsigned char *)(v248 + 80))
              {
                sub_101246990(v248, v248 + 32, *v163, v163[1]);
                uint64_t v162 = v248;
                *(_OWORD *)(v248 + 64) = *(_OWORD *)*(void *)(v248 + 32);
                *(unsigned char *)(v248 + 80) = 1;
              }
              int v164 = sub_1012472B0(v163, (double *)(v162 + 64), *(double **)(v66 + 24));
              a8 = v254;
              if (v164 * v161 == 1
                && sub_1012472B0(*(double **)(v66 + 16), *(double **)(v66 + 24), *(double **)(v248 + 24))
                 * v246 == -1)
              {
                v160 ^= 1u;
              }
            }
            *(_DWORD *)&__dst[168 * v160 + 40] = 1;
            *(_DWORD *)&__dst[168 * (v160 ^ 1) + 40] = 2;
            __dst[20] = 1;
            goto LABEL_186;
          }
          int v47 = a4;
          if (!v70)
          {
            if (v239 != v127)
            {
              if (v127 == 1) {
                int v226 = 2;
              }
              else {
                int v226 = 1;
              }
              *(_DWORD *)&__dst[40] = v226;
              int v227 = 3;
              goto LABEL_401;
            }
LABEL_400:
            int v227 = 4;
            *(_DWORD *)&__dst[40] = 4;
LABEL_401:
            *(_DWORD *)&__dst[208] = v227;
            goto LABEL_261;
          }
LABEL_398:
          *(_DWORD *)&__dst[16] = 8;
          goto LABEL_261;
        }
      }
      else
      {
        do
        {
          char v73 = v58;
          int v74 = *((_DWORD *)&v299 + v57 + 3);
          if (v74 == -1)
          {
            uint64_t v76 = &__dst[168 * v57 + 40];
            *((_OWORD *)v76 + 3) = xmmword_1015E0D30;
            *((void *)v76 + 8) = 0;
          }
          else if (v74 == 1)
          {
            uint64_t v75 = &__dst[168 * v57 + 40];
            *((_OWORD *)v75 + 3) = _Q0;
            *((void *)v75 + 8) = 0x412E848000000000;
          }
          else
          {
            if (v73) {
              uint64_t v77 = (long long *)&v292[5];
            }
            else {
              uint64_t v77 = &v293;
            }
            uint64_t v78 = &__dst[168 * v57 + 40];
            *((_OWORD *)v78 + 3) = *v77;
            *((void *)v78 + 8) = *((void *)v77 + 2);
          }
          char v58 = 0;
          uint64_t v57 = 1;
        }
        while ((v73 & 1) != 0);
        int v79 = HIDWORD(v298);
        uint64_t v66 = (uint64_t)v291;
        long long v81 = (double *)v290[2];
        long long v80 = (double *)v290[3];
        uint64_t v248 = (uint64_t)v290;
        if (!*((unsigned char *)v291 + 80))
        {
          sub_101246990((uint64_t)v291, (uint64_t)(v291 + 4), *(double *)v291[3], *(double *)(v291[3] + 8));
          *(_OWORD *)(v66 + 64) = *(_OWORD *)*(void *)(v66 + 32);
          *(unsigned char *)(v66 + 80) = 1;
        }
        int v82 = sub_1012472B0(v81, v80, (double *)(v66 + 64));
        int v83 = v82;
        if (!(v79 + v82))
        {
          BOOL v71 = v82 != -1;
          BOOL v72 = v82 == -1;
          goto LABEL_77;
        }
        int v240 = v79;
        double v133 = *(double **)(v66 + 16);
        uint64_t v134 = *(double **)(v66 + 24);
        if (!*(unsigned char *)(v66 + 80))
        {
          double v244 = *(double **)(v66 + 16);
          sub_101246990(v66, v66 + 32, *v134, v134[1]);
          double v133 = v244;
          *(_OWORD *)(v66 + 64) = *(_OWORD *)*(void *)(v66 + 32);
          *(unsigned char *)(v66 + 80) = 1;
        }
        uint64_t v245 = (double *)(v66 + 64);
        int v135 = sub_1012472B0(v133, v134, (double *)(v66 + 64));
        uint64_t v136 = *(double **)(v66 + 24);
        if (!*(unsigned char *)(v66 + 80))
        {
          sub_101246990(v66, v66 + 32, *v136, v136[1]);
          *(_OWORD *)uint64_t v245 = *(_OWORD *)*(void *)(v66 + 32);
          *(unsigned char *)(v66 + 80) = 1;
        }
        int v129 = sub_1012472B0(v136, v245, *(double **)(v248 + 24));
        int v130 = v240;
        if ((v83 & v240) != 0xFFFFFFFF || v135 != 1)
        {
          a8 = v254;
          if (v240 == 1 && v83 == 1 && v135 == -1)
          {
            if (v129 == -1) {
              int v138 = 1;
            }
            else {
              int v138 = 3;
            }
            *(_DWORD *)&__dst[40] = v138;
            *(_DWORD *)&__dst[208] = 1;
            __dst[20] = 1;
            goto LABEL_186;
          }
          if (v240 == v83 && v240 == v135)
          {
            BOOL v158 = v135 == 1;
            BOOL v159 = v129 != 0;
            goto LABEL_268;
          }
          int v47 = a4;
          if (!v83)
          {
            if (v240 != v135)
            {
              if (v135 == 1) {
                int v228 = 2;
              }
              else {
                int v228 = 1;
              }
              *(_DWORD *)&__dst[208] = v228;
              *(_DWORD *)&__dst[40] = 3;
              goto LABEL_261;
            }
            goto LABEL_400;
          }
          goto LABEL_398;
        }
      }
      *(_DWORD *)&__dst[40] = 2;
      *(_DWORD *)&__dst[208] = 2;
      __dst[20] = 1;
      goto LABEL_185;
    }
    uint64_t v90 = 0;
    *(_DWORD *)&__dst[16] = 3;
    *(_OWORD *)long long __dst = *(_OWORD *)&v292[1];
    char v91 = 1;
    do
    {
      char v92 = v91;
      int v93 = *((_DWORD *)&v299 + v90 + 3);
      if (v93 == -1)
      {
        long long v95 = &__dst[168 * v90 + 40];
        *((_OWORD *)v95 + 3) = xmmword_1015E0D30;
        *((void *)v95 + 8) = 0;
      }
      else if (v93 == 1)
      {
        uint64_t v94 = &__dst[168 * v90 + 40];
        *((_OWORD *)v94 + 3) = _Q0;
        *((void *)v94 + 8) = 0x412E848000000000;
      }
      else
      {
        if (v92) {
          uint64_t v96 = (long long *)&v292[5];
        }
        else {
          uint64_t v96 = &v293;
        }
        uint64_t v97 = &__dst[168 * v90 + 40];
        *((_OWORD *)v97 + 3) = *v96;
        *((void *)v97 + 8) = *((void *)v96 + 2);
      }
      char v91 = 0;
      uint64_t v90 = 1;
    }
    while ((v92 & 1) != 0);
    uint64_t v98 = v289;
    uint64_t v99 = (uint64_t)v288;
    double v101 = *(double **)(v289 + 16);
    BOOL v100 = *(double **)(v289 + 24);
    if (!*((unsigned char *)v288 + 80))
    {
      sub_101246990((uint64_t)v288, (uint64_t)(v288 + 4), *(double *)v288[3], *(double *)(v288[3] + 8));
      *(_OWORD *)(v99 + 64) = *(_OWORD *)*(void *)(v99 + 32);
      *(unsigned char *)(v99 + 80) = 1;
    }
    double v241 = (double *)(v99 + 64);
    int v234 = sub_1012472B0(v101, v100, (double *)(v99 + 64));
    int v102 = DWORD1(v299);
    uint64_t v103 = *(double **)(v99 + 16);
    uint64_t v104 = *(double **)(v99 + 24);
    if (!*(unsigned char *)(v98 + 80))
    {
      double v249 = *(double **)(v99 + 16);
      sub_101246990(v98, v98 + 32, **(double **)(v98 + 24), *(double *)(*(void *)(v98 + 24) + 8));
      uint64_t v103 = v249;
      *(_OWORD *)(v98 + 64) = *(_OWORD *)*(void *)(v98 + 32);
      *(unsigned char *)(v98 + 80) = 1;
    }
    double v250 = (double *)(v98 + 64);
    LODWORD(v238) = v102;
    HIDWORD(v238) = sub_1012472B0(v103, v104, (double *)(v98 + 64));
    if (HIDWORD(v238) * v102 != -1)
    {
      char v105 = *(double **)(v98 + 24);
      if (!*(unsigned char *)(v98 + 80))
      {
        sub_101246990(v98, v98 + 32, *v105, v105[1]);
        *(_OWORD *)double v250 = *(_OWORD *)*(void *)(v98 + 32);
        *(unsigned char *)(v98 + 80) = 1;
      }
      if (!*(unsigned char *)(v99 + 80))
      {
        sub_101246990(v99, v99 + 32, **(double **)(v99 + 24), *(double *)(*(void *)(v99 + 24) + 8));
        *(_OWORD *)double v241 = *(_OWORD *)*(void *)(v99 + 32);
        *(unsigned char *)(v99 + 80) = 1;
      }
      int v233 = sub_1012472B0(v105, v250, v241);
      double v106 = *(double **)(v99 + 16);
      double v107 = *(double **)(v99 + 24);
      if (!*(unsigned char *)(v99 + 80))
      {
        v232 = *(double **)(v99 + 16);
        sub_101246990(v99, v99 + 32, *v107, v107[1]);
        double v106 = v232;
        *(_OWORD *)double v241 = *(_OWORD *)*(void *)(v99 + 32);
        *(unsigned char *)(v99 + 80) = 1;
      }
      int v108 = sub_1012472B0(v106, v107, v241);
      double v109 = *(double **)(v98 + 16);
      double v110 = *(double **)(v98 + 24);
      if (!*(unsigned char *)(v98 + 80))
      {
        sub_101246990(v98, v98 + 32, *v110, v110[1]);
        *(_OWORD *)double v250 = *(_OWORD *)*(void *)(v98 + 32);
        *(unsigned char *)(v98 + 80) = 1;
      }
      int v111 = sub_1012472B0(v109, v110, v250);
      if (HIDWORD(v238)) {
        _ZF = 1;
      }
      else {
        _ZF = v111 * v238 == 1;
      }
      int v113 = !_ZF;
      if (v108 != v238 && v108 != HIDWORD(v238) && (v238 || v108 == -1))
      {
        if (v111 == 1) {
          int v145 = 2;
        }
        else {
          int v145 = 1;
        }
        if (HIDWORD(v238) == 1 || v238 == 1) {
          int v147 = 1;
        }
        else {
          int v147 = 2;
        }
        if (v113) {
          int v147 = 3;
        }
        *(_DWORD *)&__dst[40] = v145;
        *(_DWORD *)&__dst[208] = v147;
        a8 = v254;
        uint64_t v11 = v257;
        int v47 = a4;
        if ((v113 & 1) == 0) {
          __dst[20] = 1;
        }
        goto LABEL_383;
      }
      if (v233) {
        char v114 = 1;
      }
      else {
        char v114 = v113;
      }
      uint64_t v11 = v257;
      int v47 = a4;
      if ((v114 & 1) == 0)
      {
        *(_DWORD *)&__dst[40] = 4;
        *(_DWORD *)&__dst[208] = 4;
        a8 = v254;
        goto LABEL_383;
      }
      a8 = v254;
      if (!v234)
      {
        if (v111 == 1) {
          int v148 = 2;
        }
        else {
          int v148 = 1;
        }
        if (v113) {
          int v117 = 3;
        }
        else {
          int v117 = v148;
        }
        *(_DWORD *)&__dst[40] = 3;
        goto LABEL_231;
      }
      if (v234 == v233 && v111 * v234 != -1)
      {
        if (v111 == 1) {
          int v115 = 1;
        }
        else {
          int v115 = 2;
        }
        if (v111 == 1) {
          int v116 = 2;
        }
        else {
          int v116 = 1;
        }
        if (v113) {
          int v117 = 3;
        }
        else {
          int v117 = v116;
        }
        *(_DWORD *)&__dst[40] = v115;
        goto LABEL_231;
      }
      if (v233 + v111)
      {
        if (v234 != -v111) {
          goto LABEL_383;
        }
        if (v111 == 1) {
          int v169 = 2;
        }
        else {
          int v169 = 1;
        }
        *(_DWORD *)&__dst[40] = v169;
        *(_DWORD *)&__dst[208] = v169;
        if (v113)
        {
          int v117 = 3;
LABEL_231:
          *(_DWORD *)&__dst[208] = v117;
          goto LABEL_383;
        }
      }
      else
      {
        if (v111 == 1) {
          int v155 = 2;
        }
        else {
          int v155 = 1;
        }
        if (v111 == 1) {
          int v156 = 1;
        }
        else {
          int v156 = 2;
        }
        *(_DWORD *)&__dst[40] = v155;
        *(_DWORD *)&__dst[208] = v156;
      }
      __dst[20] = 1;
      goto LABEL_383;
    }
    double v121 = *(double **)(v99 + 16);
    double v122 = *(double **)(v99 + 24);
    if (!*(unsigned char *)(v99 + 80))
    {
      sub_101246990(v99, v99 + 32, *v122, v122[1]);
      *(_OWORD *)double v241 = *(_OWORD *)*(void *)(v99 + 32);
      *(unsigned char *)(v99 + 80) = 1;
    }
    int v123 = sub_1012472B0(v121, v122, v241);
    int v47 = a4;
    if (v123 == v238)
    {
      if (!v234)
      {
        if (HIDWORD(v238) == 1) {
          int v157 = 1;
        }
        else {
          int v157 = 2;
        }
        *(_DWORD *)&__dst[40] = 3;
        *(_DWORD *)&__dst[208] = v157;
        goto LABEL_260;
      }
      if (v234 == HIDWORD(v238))
      {
        if (HIDWORD(v238) == 1) {
          int v124 = 1;
        }
        else {
          int v124 = 2;
        }
        *(_DWORD *)&__dst[40] = v124;
        *(_DWORD *)&__dst[208] = v124;
        __dst[20] = 1;
LABEL_260:
        a8 = v254;
LABEL_261:
        uint64_t v11 = v257;
        goto LABEL_383;
      }
    }
    if (v123 != HIDWORD(v238)) {
      goto LABEL_202;
    }
    BOOL v139 = *(double **)(v98 + 24);
    if (!*(unsigned char *)(v98 + 80))
    {
      sub_101246990(v98, v98 + 32, *v139, v139[1]);
      *(_OWORD *)double v250 = *(_OWORD *)*(void *)(v98 + 32);
      *(unsigned char *)(v98 + 80) = 1;
    }
    if (!*(unsigned char *)(v99 + 80))
    {
      sub_101246990(v99, v99 + 32, **(double **)(v99 + 24), *(double *)(*(void *)(v99 + 24) + 8));
      *(_OWORD *)double v241 = *(_OWORD *)*(void *)(v99 + 32);
      *(unsigned char *)(v99 + 80) = 1;
    }
    int v140 = sub_1012472B0(v139, v250, v241);
    if (!v140)
    {
      *(_DWORD *)&__dst[40] = 4;
      *(_DWORD *)&__dst[208] = 4;
      goto LABEL_185;
    }
    int v47 = a4;
    if (v140 == HIDWORD(v238))
    {
      if (HIDWORD(v238) == 1) {
        int v141 = 1;
      }
      else {
        int v141 = 2;
      }
      if (HIDWORD(v238) == 1) {
        int v142 = 2;
      }
      else {
        int v142 = 1;
      }
      *(_DWORD *)&__dst[40] = v141;
      *(_DWORD *)&__dst[208] = v142;
      __dst[20] = 1;
    }
    else
    {
LABEL_202:
      if (HIDWORD(v238) == 1) {
        int v143 = 2;
      }
      else {
        int v143 = 1;
      }
      if (HIDWORD(v238) == 1) {
        int v144 = 1;
      }
      else {
        int v144 = 2;
      }
      *(_DWORD *)&__dst[40] = v143;
      *(_DWORD *)&__dst[208] = v144;
    }
    goto LABEL_260;
  }
}

BOOL sub_1012429C0(int a1, double a2, double a3, double a4, double a5, double a6)
{
  BOOL result = 0;
  BOOL v8 = a2 > a6 || a2 < a5;
  if (v8 && a6 - a5 < 360.0)
  {
    double v12 = a4;
    double v14 = a2 - a5;
    double v15 = vabdd_f64(a2, a5);
    double v16 = 180.0;
    if (v15 != 180.0)
    {
      if (COERCE_UNSIGNED_INT64(fabs(a2 - a5)) > 0x7FEFFFFFFFFFFFFFLL
        || ((v24 = fabs(v15 + -180.0), v16 = 180.0, v15 >= 180.0) ? (double v25 = v15) : (double v25 = 180.0),
            v25 >= 1.0 ? (double v26 = v25 * 2.22044605e-16) : (double v26 = 2.22044605e-16),
            v24 > v26))
      {
        double v16 = 180.0;
        if (v14 <= 180.0)
        {
          double v17 = a2 - a5;
          if (v14 >= -180.0) {
            goto LABEL_9;
          }
          long double v42 = v14 + -180.0;
          double v44 = a3;
          long double v45 = fmod(v42, 360.0);
          a3 = v44;
          double v12 = a4;
          double v14 = a2 - a5;
          double v16 = v45 + 180.0;
        }
        else
        {
          long double v27 = v14 + 180.0;
          double v29 = a3;
          long double v30 = fmod(v27, 360.0);
          a3 = v29;
          double v12 = a4;
          double v14 = a2 - a5;
          double v17 = v30 + -180.0;
          if (v17 != -180.0)
          {
            BOOL v31 = ((*(void *)&v17 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
               && (*(void *)&v17 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
            if (v31 && *(void *)&v17 != 0) {
              goto LABEL_9;
            }
            double v16 = 180.0;
            double v33 = fabs(v17 + 180.0);
            double v34 = fabs(v17);
            if (v34 < 180.0) {
              double v34 = 180.0;
            }
            double v35 = v34 >= 1.0 ? v34 * 2.22044605e-16 : 2.22044605e-16;
            if (v33 > v35)
            {
LABEL_9:
              if (v17 < 0.0) {
                double v17 = v17 + 360.0;
              }
              if (v17 + a5 <= a6) {
                return 0;
              }
              if (a1 != -1)
              {
                if (a1 == 1)
                {
                  double v18 = 180.0;
                  if (v15 != 180.0)
                  {
                    if ((*(void *)&v14 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                      || ((v46 = fabs(v15 + -180.0), double v18 = 180.0, v15 >= 180.0) ? (v47 = v15) : (v47 = 180.0),
                          v47 >= 1.0 ? (double v48 = v47 * 2.22044605e-16) : (double v48 = 2.22044605e-16),
                          v46 > v48))
                    {
                      double v18 = 180.0;
                      if (v14 <= 180.0)
                      {
                        if (v14 >= -180.0) {
                          goto LABEL_16;
                        }
                        double v80 = a3;
                        long double v81 = fmod(v14 + -180.0, 360.0);
                        a3 = v80;
                        double v18 = v81 + 180.0;
                      }
                      else
                      {
                        double v49 = a3;
                        double v50 = fmod(v14 + 180.0, 360.0);
                        a3 = v49;
                        double v14 = v50 + -180.0;
                        if (v50 + -180.0 != -180.0)
                        {
                          unint64_t v51 = COERCE__INT64(fabs(v50 + -180.0)) - 1;
                          BOOL v52 = (unint64_t)(COERCE__INT64(fabs(v50 + -180.0)) - 0x10000000000000) >> 53 > 0x3FE
                             && v51 > 0xFFFFFFFFFFFFELL;
                          if (v52 && *(void *)&v14 != 0) {
                            goto LABEL_16;
                          }
                          double v18 = 180.0;
                          double v54 = fabs(v14 + 180.0);
                          double v55 = fabs(v14);
                          if (v55 < 180.0) {
                            double v55 = 180.0;
                          }
                          double v56 = v55 >= 1.0 ? v55 * 2.22044605e-16 : 2.22044605e-16;
                          if (v54 > v56)
                          {
LABEL_16:
                            double v19 = vabdd_f64(a3, a5);
                            double v20 = 180.0;
                            if (v19 != 180.0)
                            {
                              double v21 = a3 - a5;
                              if (COERCE__INT64(fabs(a3 - a5)) > 0x7FEFFFFFFFFFFFFFLL) {
                                goto LABEL_92;
                              }
                              double v57 = fabs(v19 + -180.0);
                              double v20 = 180.0;
                              if (v19 < 180.0) {
                                double v19 = 180.0;
                              }
                              double v58 = v19 >= 1.0 ? v19 * 2.22044605e-16 : 2.22044605e-16;
                              if (v57 > v58)
                              {
LABEL_92:
                                double v20 = 180.0;
                                if (v21 <= 180.0)
                                {
                                  if (v21 >= -180.0) {
                                    goto LABEL_18;
                                  }
                                  double v20 = fmod(v21 + -180.0, 360.0) + 180.0;
                                }
                                else
                                {
                                  double v21 = fmod(v21 + 180.0, 360.0) + -180.0;
                                  if (v21 != -180.0)
                                  {
                                    BOOL v59 = ((*(void *)&v21 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
                                       && (*(void *)&v21 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
                                    if (v59 && *(void *)&v21 != 0) {
                                      goto LABEL_18;
                                    }
                                    double v20 = 180.0;
                                    double v61 = fabs(v21 + 180.0);
                                    double v62 = fabs(v21);
                                    if (v62 < 180.0) {
                                      double v62 = 180.0;
                                    }
                                    double v63 = v62 >= 1.0 ? v62 * 2.22044605e-16 : 2.22044605e-16;
                                    if (v61 > v63) {
                                      goto LABEL_18;
                                    }
                                  }
                                }
                              }
                            }
                            double v21 = v20;
LABEL_18:
                            BOOL v22 = v14 < 0.0;
                            if (v21 > 0.0) {
                              BOOL v22 = 0;
                            }
                            BOOL v23 = v21 > v14;
                            return !v23 && v22;
                          }
                        }
                      }
                    }
                  }
                  double v14 = v18;
                  goto LABEL_16;
                }
                return 0;
              }
              double v36 = vabdd_f64(a2, a6);
              double v37 = 180.0;
              if (v36 != 180.0)
              {
                double v38 = a2 - a6;
                if (COERCE__INT64(fabs(a2 - a6)) > 0x7FEFFFFFFFFFFFFFLL) {
                  goto LABEL_116;
                }
                double v64 = fabs(v36 + -180.0);
                double v37 = 180.0;
                if (v36 < 180.0) {
                  double v36 = 180.0;
                }
                double v65 = v36 >= 1.0 ? v36 * 2.22044605e-16 : 2.22044605e-16;
                if (v64 > v65)
                {
LABEL_116:
                  double v37 = 180.0;
                  if (v38 <= 180.0)
                  {
                    if (v38 >= -180.0) {
                      goto LABEL_49;
                    }
                    double v37 = fmod(v38 + -180.0, 360.0) + 180.0;
                  }
                  else
                  {
                    double v66 = fmod(v38 + 180.0, 360.0);
                    double v38 = v66 + -180.0;
                    if (v66 + -180.0 != -180.0)
                    {
                      unint64_t v67 = COERCE__INT64(fabs(v66 + -180.0)) - 1;
                      BOOL v68 = (unint64_t)(COERCE__INT64(fabs(v66 + -180.0)) - 0x10000000000000) >> 53 > 0x3FE
                         && v67 > 0xFFFFFFFFFFFFELL;
                      if (v68 && *(void *)&v38 != 0) {
                        goto LABEL_49;
                      }
                      double v37 = 180.0;
                      double v70 = fabs(v38 + 180.0);
                      double v71 = fabs(v38);
                      if (v71 < 180.0) {
                        double v71 = 180.0;
                      }
                      double v72 = v71 >= 1.0 ? v71 * 2.22044605e-16 : 2.22044605e-16;
                      if (v70 > v72)
                      {
LABEL_49:
                        double v39 = vabdd_f64(v12, a6);
                        double v40 = 180.0;
                        if (v39 != 180.0)
                        {
                          double v41 = v12 - a6;
                          if (COERCE__INT64(fabs(v12 - a6)) > 0x7FEFFFFFFFFFFFFFLL) {
                            goto LABEL_140;
                          }
                          double v73 = fabs(v39 + -180.0);
                          double v40 = 180.0;
                          if (v39 < 180.0) {
                            double v39 = 180.0;
                          }
                          double v74 = v39 >= 1.0 ? v39 * 2.22044605e-16 : 2.22044605e-16;
                          if (v73 > v74)
                          {
LABEL_140:
                            double v40 = 180.0;
                            if (v41 <= 180.0)
                            {
                              if (v41 >= -180.0) {
                                goto LABEL_51;
                              }
                              double v40 = fmod(v41 + -180.0, 360.0) + 180.0;
                            }
                            else
                            {
                              double v41 = fmod(v41 + 180.0, 360.0) + -180.0;
                              if (v41 != -180.0)
                              {
                                BOOL v75 = ((*(void *)&v41 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
                                   && (*(void *)&v41 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
                                if (v75 && *(void *)&v41 != 0) {
                                  goto LABEL_51;
                                }
                                double v40 = 180.0;
                                double v77 = fabs(v41 + 180.0);
                                double v78 = fabs(v41);
                                if (v78 < 180.0) {
                                  double v78 = 180.0;
                                }
                                double v79 = v78 >= 1.0 ? v78 * 2.22044605e-16 : 2.22044605e-16;
                                if (v77 > v79) {
                                  goto LABEL_51;
                                }
                              }
                            }
                          }
                        }
                        double v41 = v40;
LABEL_51:
                        BOOL v22 = v38 > 0.0;
                        if (v41 < 0.0) {
                          BOOL v22 = 0;
                        }
                        BOOL v23 = v38 > v41;
                        return !v23 && v22;
                      }
                    }
                  }
                }
              }
              double v38 = v37;
              goto LABEL_49;
            }
          }
        }
      }
    }
    double v17 = v16;
    goto LABEL_9;
  }
  return result;
}

uint64_t sub_101243090(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v5 = *(double *)(a2 + 80);
  double v6 = *(double *)(a2 + 136);
  if (vabdd_f64(v5, v6) >= 50.0)
  {
    BOOL v11 = v5 < v6;
  }
  else
  {
    double v7 = *(double *)(a2 + 72);
    if (v7 == 0.0) {
      __assert_rtn("apply", "segment_ratio.hpp", 56, "lhs.denominator() != Type(0)");
    }
    double v8 = *(double *)(a2 + 128);
    if (v8 == 0.0) {
      __assert_rtn("apply", "segment_ratio.hpp", 57, "rhs.denominator() != Type(0)");
    }
    double v9 = *(double *)(a2 + 64) / v7;
    double v10 = *(double *)(a2 + 120) / v8;
    if (v9 == v10)
    {
      BOOL v11 = 0;
    }
    else if ((*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL {
           || (*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    }
    {
      BOOL v11 = 1;
    }
    else
    {
      double v12 = vabdd_f64(v9, v10);
      double v13 = fabs(v9);
      double v14 = fabs(v10);
      if (v13 < v14) {
        double v13 = v14;
      }
      if (v13 >= 1.0) {
        double v15 = v13 * 2.22044605e-16;
      }
      else {
        double v15 = 2.22044605e-16;
      }
      BOOL v11 = v12 > v15;
    }
    if (v9 >= v10) {
      BOOL v11 = 0;
    }
  }
  *(_DWORD *)(a1 + 16) = 6;
  if (*(void *)a2 <= (unint64_t)v11) {
    __assert_rtn("assign_point", "get_turn_info.hpp", 164, "index < info.count");
  }
  *(_OWORD *)a1 = *(_OWORD *)(a2 + 16 * v11 + 8);
  uint64_t v16 = a2 + 56 * v11;
  long long v17 = *(_OWORD *)(v16 + 40);
  *(void *)(a1 + 104) = *(void *)(v16 + 56);
  *(_OWORD *)(a1 + 88) = v17;
  long long v18 = *(_OWORD *)(v16 + 64);
  *(void *)(a1 + 272) = *(void *)(v16 + 80);
  *(_OWORD *)(a1 + 256) = v18;
  uint64_t v19 = *(void *)(a3 + 16);
  double v20 = *(double **)(v19 + 24);
  if (!*(unsigned char *)(v19 + 80))
  {
    sub_101246990(*(void *)(a3 + 16), v19 + 32, *v20, v20[1]);
    *(_OWORD *)(v19 + 64) = *(_OWORD *)*(void *)(v19 + 32);
    *(unsigned char *)(v19 + 80) = 1;
  }
  uint64_t v21 = *(void *)(a3 + 8);
  if (!*(unsigned char *)(v21 + 80))
  {
    sub_101246990(*(void *)(a3 + 8), v21 + 32, **(double **)(v21 + 24), *(double *)(*(void *)(v21 + 24) + 8));
    *(_OWORD *)(v21 + 64) = *(_OWORD *)*(void *)(v21 + 32);
    *(unsigned char *)(v21 + 80) = 1;
  }
  int v22 = sub_1012472B0(v20, (double *)(v19 + 64), (double *)(v21 + 64));
  uint64_t v23 = *(void *)(a3 + 8);
  double v24 = *(double **)(v23 + 16);
  double v25 = *(double **)(v23 + 24);
  if (!*(unsigned char *)(v23 + 80))
  {
    sub_101246990(*(void *)(a3 + 8), v23 + 32, *v25, v25[1]);
    *(_OWORD *)(v23 + 64) = *(_OWORD *)*(void *)(v23 + 32);
    *(unsigned char *)(v23 + 80) = 1;
  }
  int v26 = sub_1012472B0(v24, v25, (double *)(v23 + 64));
  uint64_t v27 = *(void *)(a3 + 8);
  uint64_t v28 = *(void *)(a3 + 16);
  long double v30 = *(double **)(v27 + 16);
  double v29 = *(double **)(v27 + 24);
  if (!*(unsigned char *)(v28 + 80))
  {
    sub_101246990(v28, v28 + 32, **(double **)(v28 + 24), *(double *)(*(void *)(v28 + 24) + 8));
    *(_OWORD *)(v28 + 64) = *(_OWORD *)*(void *)(v28 + 32);
    *(unsigned char *)(v28 + 80) = 1;
  }
  uint64_t result = sub_1012472B0(v30, v29, (double *)(v28 + 64));
  if (v22 || v26 != result)
  {
    if (result * v26 == -1) {
      BOOL v33 = v26 == -1;
    }
    else {
      BOOL v33 = v22 == -1;
    }
    if (v33) {
      int v34 = 2;
    }
    else {
      int v34 = 1;
    }
    *(_DWORD *)(a1 + 40) = v34;
    if (v33) {
      int v32 = 1;
    }
    else {
      int v32 = 2;
    }
  }
  else
  {
    int v32 = 4;
    *(_DWORD *)(a1 + 40) = 4;
  }
  *(_DWORD *)(a1 + 208) = v32;
  return result;
}

void sub_101243388(uint64_t a1, double *a2, double *a3, double *a4, double *a5)
{
  char v567 = 0;
  double v10 = a2[1];
  *(double *)uint64_t v568 = *a2;
  *(double *)v570 = v10;
  sub_10123D770((double *)v568, (double *)v570, 1);
  double v11 = *(double *)v568;
  double v12 = a3[1];
  *(double *)uint64_t v568 = *a3;
  *(double *)v570 = v12;
  sub_10123D770((double *)v568, (double *)v570, 1);
  if (v11 != *(double *)v568)
  {
    if ((*(void *)&v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)v568 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_21;
    }
    double v14 = vabdd_f64(v11, *(double *)v568);
    double v15 = fabs(v11);
    double v16 = fabs(*(double *)v568);
    if (v15 >= v16) {
      double v16 = v15;
    }
    double v17 = v16 >= 1.0 ? v16 * 2.22044605e-16 : 2.22044605e-16;
    if (v14 > v17) {
      goto LABEL_21;
    }
  }
  if (v10 == v12) {
    goto LABEL_3;
  }
  if ((*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (*(void *)&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    goto LABEL_21;
  }
  double v18 = vabdd_f64(v10, v12);
  double v19 = fabs(v10);
  double v20 = fabs(v12);
  if (v19 < v20) {
    double v19 = v20;
  }
  double v21 = v19 >= 1.0 ? v19 * 2.22044605e-16 : 2.22044605e-16;
  if (v18 <= v21) {
LABEL_3:
  }
    int v13 = 1;
  else {
LABEL_21:
  }
    int v13 = 0;
  double v22 = a4[1];
  *(double *)uint64_t v568 = *a4;
  *(double *)v570 = v22;
  sub_10123D770((double *)v568, (double *)v570, 1);
  double v23 = *(double *)v568;
  double v24 = a5[1];
  *(double *)uint64_t v568 = *a5;
  *(double *)v570 = v24;
  sub_10123D770((double *)v568, (double *)v570, 1);
  if (v23 != *(double *)v568)
  {
    if ((*(void *)&v23 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)v568 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_51;
    }
    double v36 = vabdd_f64(v23, *(double *)v568);
    double v37 = fabs(v23);
    double v38 = fabs(*(double *)v568);
    if (v37 >= v38) {
      double v38 = v37;
    }
    double v39 = v38 >= 1.0 ? v38 * 2.22044605e-16 : 2.22044605e-16;
    if (v36 > v39) {
      goto LABEL_51;
    }
  }
  if (v22 == v24)
  {
    if (v13) {
      goto LABEL_25;
    }
    BOOL v44 = 1;
  }
  else
  {
    if ((*(void *)&v22 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v24 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
LABEL_51:
      BOOL v44 = 0;
      goto LABEL_53;
    }
    double v40 = vabdd_f64(v22, v24);
    double v41 = fabs(v22);
    double v42 = fabs(v24);
    if (v41 < v42) {
      double v41 = v42;
    }
    if (v41 >= 1.0) {
      double v43 = v41 * 2.22044605e-16;
    }
    else {
      double v43 = 2.22044605e-16;
    }
    BOOL v44 = v40 <= v43;
    if (v40 <= v43) {
      char v45 = v13;
    }
    else {
      char v45 = 0;
    }
    if (v45)
    {
LABEL_25:
      double v25 = a2[1];
      *(double *)uint64_t v568 = *a2;
      *(double *)v570 = v25;
      sub_10123D770((double *)v568, (double *)v570, 1);
      double v26 = *(double *)v568;
      double v27 = a5[1];
      *(double *)uint64_t v568 = *a5;
      *(double *)v570 = v27;
      sub_10123D770((double *)v568, (double *)v570, 1);
      if (v26 == *(double *)v568) {
        goto LABEL_233;
      }
      if ((*(void *)&v26 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
        && (*(void *)v568 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v128 = vabdd_f64(v26, *(double *)v568);
        double v129 = fabs(v26);
        double v130 = fabs(*(double *)v568);
        if (v129 >= v130) {
          double v130 = v129;
        }
        double v131 = v130 >= 1.0 ? v130 * 2.22044605e-16 : 2.22044605e-16;
        if (v128 <= v131)
        {
LABEL_233:
          if (v25 == v27) {
            goto LABEL_27;
          }
          if ((*(void *)&v25 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
            && (*(void *)&v27 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            double v184 = vabdd_f64(v25, v27);
            double v185 = fabs(v25);
            double v186 = fabs(v27);
            if (v185 < v186) {
              double v185 = v186;
            }
            double v187 = v185 >= 1.0 ? v185 * 2.22044605e-16 : 2.22044605e-16;
            if (v184 <= v187)
            {
LABEL_27:
              memset(&v568[24], 0, 128);
              uint64_t v28 = 40;
              do
              {
                double v29 = &v568[v28];
                *(_OWORD *)double v29 = xmmword_1015E0D30;
                *((void *)v29 + 2) = 0;
                *((void *)v29 + 3) = 0;
                *((_OWORD *)v29 + 2) = xmmword_1015E0D40;
                v29[48] = 0;
                v28 += 56;
              }
              while (v29 + 56 != v569);
              *(void *)uint64_t v568 = 1;
              *(_OWORD *)&v568[8] = *(_OWORD *)a2;
              memset(&v570[2], 0, 32);
              long long v30 = *(_OWORD *)&v568[112];
              *(_OWORD *)(a1 + 96) = *(_OWORD *)&v568[96];
              *(_OWORD *)(a1 + 112) = v30;
              *(_OWORD *)(a1 + 128) = *(_OWORD *)&v568[128];
              long long v31 = *(_OWORD *)&v568[48];
              *(_OWORD *)(a1 + 32) = *(_OWORD *)&v568[32];
              *(_OWORD *)(a1 + 48) = v31;
              long long v32 = *(_OWORD *)&v568[80];
              *(_OWORD *)(a1 + 64) = *(_OWORD *)&v568[64];
              *(_OWORD *)(a1 + 80) = v32;
              long long v33 = *(_OWORD *)&v568[16];
              *(_OWORD *)a1 = *(_OWORD *)v568;
              *(_OWORD *)(a1 + 16) = v33;
              long long v34 = *(_OWORD *)&v570[16];
              *(_OWORD *)(a1 + 154) = *(_OWORD *)v570;
              *(void *)&v570[34] = 0;
              *(void *)(a1 + 144) = *(void *)&v568[144];
              __int16 v35 = 48;
              goto LABEL_586;
            }
          }
        }
      }
      *(void *)uint64_t v568 = 0;
      uint64_t v188 = 40;
      do
      {
        unint64_t v189 = &v568[v188];
        *(_OWORD *)unint64_t v189 = xmmword_1015E0D30;
        *((void *)v189 + 2) = 0;
        *((void *)v189 + 3) = 0;
        *((_OWORD *)v189 + 2) = xmmword_1015E0D40;
        v189[48] = 0;
        v188 += 56;
      }
      while (v189 + 56 != v569);
      goto LABEL_585;
    }
  }
LABEL_53:
  double v46 = sub_1012462D8(a2);
  double v48 = v47;
  v566[0] = v46;
  v566[1] = v47;
  double v546 = v49;
  v566[2] = v49;
  double v50 = sub_1012462D8(a3);
  double v52 = v51;
  double v54 = v53;
  v565[0] = v50;
  v565[1] = v51;
  v565[2] = v53;
  double v55 = sub_1012462D8(a4);
  double v57 = v56;
  double v59 = v58;
  v564[0] = v55;
  v564[1] = v56;
  v564[2] = v58;
  double v62 = sub_1012462D8(a5);
  double v63 = v60;
  double v64 = v61;
  v563[0] = v62;
  v563[1] = v60;
  v563[2] = v61;
  unint64_t v561 = 0;
  unint64_t v562 = 0;
  double v65 = v57 * v61 - v59 * v60;
  double v66 = v59 * v62 - v55 * v61;
  double v67 = v55 * v60 - v57 * v62;
  double v558 = v65;
  double v559 = v66;
  double v560 = v67;
  double v557 = 0.0;
  double v68 = 0.0;
  if (v44)
  {
    int v69 = 0;
    int v70 = 0;
    char v71 = 0;
    char v72 = 1;
    double v73 = 0.0;
LABEL_57:
    double v74 = v546;
    goto LABEL_58;
  }
  double v73 = 1.0 - (v59 * v61 + v57 * v60 + v55 * v62);
  double v557 = v73;
  if (v73 == 0.0) {
    goto LABEL_56;
  }
  unint64_t v95 = COERCE__INT64(fabs(1.0 - (v59 * v61 + v57 * v60 + v55 * v62))) - 1;
  BOOL v96 = (unint64_t)(COERCE__INT64(fabs(1.0 - (v59 * v61 + v57 * v60 + v55 * v62))) - 0x10000000000000) >> 53 > 0x3FE
     && v95 > 0xFFFFFFFFFFFFELL;
  BOOL v97 = !v96 || *(void *)&v73 == 0;
  if (v97)
  {
    double v98 = fabs(v73);
    double v99 = 2.22044605e-16;
    if (v98 >= 1.0) {
      double v99 = v98 * 2.22044605e-16;
    }
    if (v98 <= v99)
    {
LABEL_56:
      int v69 = 0;
      int v70 = 0;
      double v557 = 0.0;
      char v72 = 1;
      double v73 = 0.0;
      char v71 = 1;
      goto LABEL_57;
    }
  }
  double v74 = v546;
  double v100 = v546 * v67 + v66 * v48 + v65 * v46;
  if (v100 == 0.0) {
    goto LABEL_86;
  }
  if (COERCE_UNSIGNED_INT64(fabs(v546 * v67 + v66 * v48 + v65 * v46)) >= 0x7FF0000000000000)
  {
    if (v100 > 0.0) {
      int v70 = 1;
    }
    else {
      int v70 = -1;
    }
  }
  else
  {
    double v196 = fabs(v100);
    double v197 = 2.22044605e-16;
    if (v196 >= 1.0) {
      double v197 = v196 * 2.22044605e-16;
    }
    if (v100 > 0.0) {
      int v70 = 1;
    }
    else {
      int v70 = -1;
    }
    if (v196 <= v197) {
LABEL_86:
    }
      int v70 = 0;
  }
  double v232 = v54 * v67 + v66 * v52 + v65 * v50;
  if (v232 != 0.0)
  {
    if (COERCE_UNSIGNED_INT64(fabs(v54 * v67 + v66 * v52 + v65 * v50)) >= 0x7FF0000000000000)
    {
      if (v232 > 0.0) {
        int v69 = 1;
      }
      else {
        int v69 = -1;
      }
      goto LABEL_346;
    }
    double v233 = fabs(v232);
    double v234 = 2.22044605e-16;
    if (v233 >= 1.0) {
      double v234 = v233 * 2.22044605e-16;
    }
    if (v232 > 0.0) {
      int v69 = 1;
    }
    else {
      int v69 = -1;
    }
    if (v233 > v234) {
      goto LABEL_346;
    }
  }
  int v69 = 0;
LABEL_346:
  unint64_t v561 = __PAIR64__(v69, v70);
  if (v69 * v70 == 1)
  {
    *(void *)uint64_t v568 = 0;
    uint64_t v235 = 40;
    do
    {
      int v236 = &v568[v235];
      *(_OWORD *)int v236 = xmmword_1015E0D30;
      *((void *)v236 + 2) = 0;
      *((void *)v236 + 3) = 0;
      *((_OWORD *)v236 + 2) = xmmword_1015E0D40;
      v236[48] = 0;
      v235 += 56;
    }
    while (v236 + 56 != v569);
    goto LABEL_370;
  }
  char v72 = 0;
  char v71 = 0;
LABEL_58:
  double v75 = v48 * v54 - v74 * v52;
  double v76 = v74 * v50 - v46 * v54;
  double v554 = v75;
  double v555 = v76;
  double v77 = v46 * v52 - v48 * v50;
  double v556 = v77;
  double v553 = 0.0;
  if (v13)
  {
    int v78 = 0;
    int v79 = 0;
    goto LABEL_62;
  }
  double v80 = 1.0 - (v74 * v54 + v48 * v52 + v46 * v50);
  double v553 = v80;
  if (v80 == 0.0) {
    goto LABEL_61;
  }
  unint64_t v101 = COERCE__INT64(fabs(1.0 - (v74 * v54 + v48 * v52 + v46 * v50))) - 1;
  BOOL v102 = (unint64_t)(COERCE__INT64(fabs(1.0 - (v74 * v54 + v48 * v52 + v46 * v50))) - 0x10000000000000) >> 53 > 0x3FE
      && v101 > 0xFFFFFFFFFFFFELL;
  if (!v102 || *(void *)&v80 == 0)
  {
    double v104 = fabs(v80);
    double v105 = 2.22044605e-16;
    if (v104 >= 1.0) {
      double v105 = v104 * 2.22044605e-16;
    }
    if (v104 <= v105)
    {
LABEL_61:
      int v78 = 0;
      int v79 = 0;
      double v553 = 0.0;
      char v71 = 1;
LABEL_62:
      int v81 = 1;
      if (v72) {
        goto LABEL_67;
      }
      goto LABEL_63;
    }
  }
  double v106 = v77 * v59 + v76 * v57 + v75 * v55;
  if (v106 == 0.0) {
    goto LABEL_99;
  }
  if (COERCE_UNSIGNED_INT64(fabs(v77 * v59 + v76 * v57 + v75 * v55)) >= 0x7FF0000000000000)
  {
    if (v106 > 0.0) {
      int v79 = 1;
    }
    else {
      int v79 = -1;
    }
  }
  else
  {
    double v198 = fabs(v106);
    double v199 = 2.22044605e-16;
    if (v198 >= 1.0) {
      double v199 = v198 * 2.22044605e-16;
    }
    if (v106 > 0.0) {
      int v79 = 1;
    }
    else {
      int v79 = -1;
    }
    if (v198 <= v199) {
LABEL_99:
    }
      int v79 = 0;
  }
  double v237 = v77 * v64 + v76 * v63 + v75 * v62;
  if (v237 == 0.0)
  {
LABEL_355:
    int v78 = 0;
    goto LABEL_367;
  }
  if (COERCE_UNSIGNED_INT64(fabs(v77 * v64 + v76 * v63 + v75 * v62)) >= 0x7FF0000000000000)
  {
    if (v237 > 0.0) {
      int v78 = 1;
    }
    else {
      int v78 = -1;
    }
  }
  else
  {
    double v238 = fabs(v237);
    double v239 = 2.22044605e-16;
    if (v238 >= 1.0) {
      double v239 = v238 * 2.22044605e-16;
    }
    if (v237 > 0.0) {
      int v78 = 1;
    }
    else {
      int v78 = -1;
    }
    if (v238 <= v239) {
      goto LABEL_355;
    }
  }
LABEL_367:
  unint64_t v562 = __PAIR64__(v78, v79);
  if (v78 * v79 == 1)
  {
    *(void *)uint64_t v568 = 0;
    uint64_t v240 = 40;
    do
    {
      double v241 = &v568[v240];
      *(_OWORD *)double v241 = xmmword_1015E0D30;
      *((void *)v241 + 2) = 0;
      *((void *)v241 + 3) = 0;
      *((_OWORD *)v241 + 2) = xmmword_1015E0D40;
      v241[48] = 0;
      v240 += 56;
    }
    while (v241 + 56 != v569);
    goto LABEL_370;
  }
  double v247 = sqrt(v77 * v77 + v76 * v76 + v75 * v75);
  if (v247 == 0.0) {
    goto LABEL_373;
  }
  if (*(void *)&v247 >> 52 > 0x7FEuLL) {
    goto LABEL_380;
  }
  double v248 = fabs(v247);
  double v249 = 2.22044605e-16;
  if (v248 >= 1.0) {
    double v249 = v248 * 2.22044605e-16;
  }
  if (v248 <= v249)
  {
LABEL_373:
    if (!v69 || !v70)
    {
      int v69 = 0;
      int v70 = 0;
      unint64_t v561 = 0;
    }
    int v81 = 1;
  }
  else
  {
LABEL_380:
    int v81 = 0;
    double v75 = v75 / v247;
    double v76 = v76 / v247;
    double v554 = v75;
    double v555 = v76;
    double v77 = v77 / v247;
    double v556 = v77;
  }
  double v68 = 1.0 - (v74 * v54 + v48 * v52 + v46 * v50);
  if (v72) {
    goto LABEL_67;
  }
LABEL_63:
  double v82 = sqrt(v67 * v67 + v66 * v66 + v65 * v65);
  if (v82 != 0.0)
  {
    if (*(void *)&v82 >> 52 > 0x7FEuLL) {
      goto LABEL_104;
    }
    double v107 = fabs(v82);
    double v108 = 2.22044605e-16;
    if (v107 >= 1.0) {
      double v108 = v107 * 2.22044605e-16;
    }
    if (v107 > v108)
    {
LABEL_104:
      int v94 = 0;
      double v65 = v65 / v82;
      double v66 = v66 / v82;
      double v558 = v65;
      double v559 = v66;
      double v67 = v67 / v82;
      double v560 = v67;
      goto LABEL_105;
    }
  }
  if (!v78 || !v79)
  {
    int v78 = 0;
    int v79 = 0;
    unint64_t v562 = 0;
  }
LABEL_67:
  if (v81)
  {
    double v83 = a2[1];
    *(double *)uint64_t v568 = *a2;
    *(double *)v570 = v83;
    sub_10123D770((double *)v568, (double *)v570, 1);
    double v84 = *(double *)v568;
    double v85 = a5[1];
    *(double *)uint64_t v568 = *a5;
    *(double *)v570 = v85;
    sub_10123D770((double *)v568, (double *)v570, 1);
    if (v84 != *(double *)v568)
    {
      if ((*(void *)&v84 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (*(void *)v568 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_222;
      }
      double v124 = vabdd_f64(v84, *(double *)v568);
      double v125 = fabs(v84);
      double v126 = fabs(*(double *)v568);
      if (v125 >= v126) {
        double v126 = v125;
      }
      double v127 = v126 >= 1.0 ? v126 * 2.22044605e-16 : 2.22044605e-16;
      if (v124 > v127) {
        goto LABEL_222;
      }
    }
    if (v83 == v85) {
      goto LABEL_70;
    }
    if ((*(void *)&v83 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v85 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_222;
    }
    double v173 = vabdd_f64(v83, v85);
    double v174 = fabs(v83);
    double v175 = fabs(v85);
    if (v174 < v175) {
      double v174 = v175;
    }
    double v176 = v174 >= 1.0 ? v174 * 2.22044605e-16 : 2.22044605e-16;
    if (v173 <= v176)
    {
LABEL_70:
      memset(&v568[24], 0, 128);
      uint64_t v86 = 40;
      do
      {
        int v87 = &v568[v86];
        *(_OWORD *)int v87 = xmmword_1015E0D30;
        *((void *)v87 + 2) = 0;
        *((void *)v87 + 3) = 0;
        *((_OWORD *)v87 + 2) = xmmword_1015E0D40;
        v87[48] = 0;
        v86 += 56;
      }
      while (v87 + 56 != v569);
      *(void *)uint64_t v568 = 1;
      *(_OWORD *)&v568[8] = *(_OWORD *)a2;
      memset(&v570[2], 0, 32);
      long long v88 = *(_OWORD *)&v568[112];
      *(_OWORD *)(a1 + 96) = *(_OWORD *)&v568[96];
      *(_OWORD *)(a1 + 112) = v88;
      *(_OWORD *)(a1 + 128) = *(_OWORD *)&v568[128];
      long long v89 = *(_OWORD *)&v568[48];
      *(_OWORD *)(a1 + 32) = *(_OWORD *)&v568[32];
      *(_OWORD *)(a1 + 48) = v89;
      long long v90 = *(_OWORD *)&v568[80];
      *(_OWORD *)(a1 + 64) = *(_OWORD *)&v568[64];
      *(_OWORD *)(a1 + 80) = v90;
      long long v91 = *(_OWORD *)&v568[16];
      *(_OWORD *)a1 = *(_OWORD *)v568;
      *(_OWORD *)(a1 + 16) = v91;
      long long v92 = *(_OWORD *)&v570[16];
      *(_OWORD *)(a1 + 154) = *(_OWORD *)v570;
      *(void *)&v570[34] = 0;
      *(void *)(a1 + 144) = *(void *)&v568[144];
      __int16 v93 = 48;
    }
    else
    {
LABEL_222:
      *(void *)uint64_t v568 = 0;
      uint64_t v177 = 40;
      do
      {
        int v178 = &v568[v177];
        *(_OWORD *)int v178 = xmmword_1015E0D30;
        *((void *)v178 + 2) = 0;
        *((void *)v178 + 3) = 0;
        *((_OWORD *)v178 + 2) = xmmword_1015E0D40;
        v178[48] = 0;
        v177 += 56;
      }
      while (v178 + 56 != v569);
      memset(&v570[2], 0, 32);
      long long v179 = *(_OWORD *)&v568[112];
      *(_OWORD *)(a1 + 96) = *(_OWORD *)&v568[96];
      *(_OWORD *)(a1 + 112) = v179;
      *(_OWORD *)(a1 + 128) = *(_OWORD *)&v568[128];
      long long v180 = *(_OWORD *)&v568[48];
      *(_OWORD *)(a1 + 32) = *(_OWORD *)&v568[32];
      *(_OWORD *)(a1 + 48) = v180;
      long long v181 = *(_OWORD *)&v568[80];
      *(_OWORD *)(a1 + 64) = *(_OWORD *)&v568[64];
      *(_OWORD *)(a1 + 80) = v181;
      long long v182 = *(_OWORD *)&v568[16];
      *(_OWORD *)a1 = *(_OWORD *)v568;
      *(_OWORD *)(a1 + 16) = v182;
      long long v92 = *(_OWORD *)&v570[16];
      *(_OWORD *)(a1 + 154) = *(_OWORD *)v570;
      *(void *)&v570[34] = 0;
      *(void *)(a1 + 144) = *(void *)&v568[144];
      __int16 v93 = 100;
    }
    *(_WORD *)(a1 + 152) = v93;
    *(_OWORD *)(a1 + 170) = v92;
    long long v183 = *(_OWORD *)&v570[26];
    goto LABEL_588;
  }
  int v94 = 1;
LABEL_105:
  double v109 = -v59;
  double v110 = -v55;
  double v111 = -v57;
  double v112 = -v74;
  double v113 = -v46;
  int v114 = v79 | v78;
  double v115 = -v48;
  if (!(v70 | v69))
  {
    if (!v114) {
      goto LABEL_145;
    }
    int v123 = (char *)&v562 + 4;
    LODWORD(v562) = 0;
LABEL_144:
    *(_DWORD *)int v123 = 0;
LABEL_145:
    double v116 = v77 * v67 + v76 * v66 + v75 * v65;
    if (!v81) {
      goto LABEL_109;
    }
LABEL_146:
    double v132 = v73;
    v571[0] = 0.0;
    if (sub_1012463F4(a4, a5, a2, v564, &v558, v566, v565, &v557, v571, v71))
    {
      double v133 = v132;
      double v134 = -v132;
      BOOL v135 = v132 < 0.0;
      if (v132 >= 0.0) {
        double v136 = v571[0];
      }
      else {
        double v136 = -v571[0];
      }
      if (v135) {
        double v137 = v134;
      }
      else {
        double v137 = v133;
      }
      double v138 = 0.0;
      if (v137 != 0.0) {
        double v138 = v136 * 1000000.0 / v137;
      }
      memset(&v568[24], 0, 128);
      uint64_t v139 = 40;
      do
      {
        int v140 = &v568[v139];
        *(_OWORD *)int v140 = xmmword_1015E0D30;
        *((void *)v140 + 2) = 0;
        *((void *)v140 + 3) = 0;
        *((_OWORD *)v140 + 2) = xmmword_1015E0D40;
        v140[48] = 0;
        v139 += 56;
      }
      while (v140 + 56 != v569);
      *(void *)uint64_t v568 = 1;
      *(_OWORD *)&v568[8] = *(_OWORD *)a2;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13390, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_101B13390))
      {
        qword_101B13388 = 0x3FF0000000000000;
        __cxa_guard_release(&qword_101B13390);
      }
      v568[88] = 1;
      *(void *)&v568[40] = 0;
      *(void *)&v568[48] = qword_101B13388;
      *(void *)&v568[56] = 0;
      *(double *)&v568[64] = v136;
      *(double *)&v568[72] = v137;
      *(double *)&v568[80] = v138;
      goto LABEL_159;
    }
    *(void *)uint64_t v568 = 0;
    uint64_t v171 = 40;
    do
    {
      double v172 = &v568[v171];
      *(_OWORD *)double v172 = xmmword_1015E0D30;
      *((void *)v172 + 2) = 0;
      *((void *)v172 + 3) = 0;
      *((_OWORD *)v172 + 2) = xmmword_1015E0D40;
      v172[48] = 0;
      v171 += 56;
    }
    while (v172 + 56 != v569);
    goto LABEL_585;
  }
  if (!v114)
  {
    int v123 = (char *)&v561 + 4;
    LODWORD(v561) = 0;
    goto LABEL_144;
  }
  double v116 = v77 * v67 + v76 * v66 + v75 * v65;
  double v117 = fabs(v116);
  if (v117 != 1.0)
  {
    if (COERCE_UNSIGNED_INT64(fabs(v77 * v67 + v76 * v66 + v75 * v65)) > 0x7FEFFFFFFFFFFFFFLL
      || ((double v190 = fabs(v117 + -1.0), v117 >= 1.0) ? (v191 = v117 * 2.22044605e-16) : (v191 = 2.22044605e-16), v190 > v191))
    {
      if ((v81 | v94) == 1)
      {
        *(void *)uint64_t v568 = 0;
        uint64_t v192 = 40;
        do
        {
          double v193 = &v568[v192];
          *(_OWORD *)double v193 = xmmword_1015E0D30;
          *((void *)v193 + 2) = 0;
          *((void *)v193 + 3) = 0;
          *((_OWORD *)v193 + 2) = xmmword_1015E0D40;
          v193[48] = 0;
          v192 += 56;
        }
        while (v193 + 56 != v569);
LABEL_370:
        memset(&v570[2], 0, 32);
        long long v242 = *(_OWORD *)&v568[112];
        *(_OWORD *)(a1 + 96) = *(_OWORD *)&v568[96];
        *(_OWORD *)(a1 + 112) = v242;
        *(_OWORD *)(a1 + 128) = *(_OWORD *)&v568[128];
        long long v243 = *(_OWORD *)&v568[48];
        *(_OWORD *)(a1 + 32) = *(_OWORD *)&v568[32];
        *(_OWORD *)(a1 + 48) = v243;
        long long v244 = *(_OWORD *)&v568[80];
        *(_OWORD *)(a1 + 64) = *(_OWORD *)&v568[64];
        *(_OWORD *)(a1 + 80) = v244;
        long long v245 = *(_OWORD *)&v568[16];
        *(_OWORD *)a1 = *(_OWORD *)v568;
        *(_OWORD *)(a1 + 16) = v245;
        long long v246 = *(_OWORD *)&v570[16];
        *(_OWORD *)(a1 + 154) = *(_OWORD *)v570;
        *(void *)&v570[34] = 0;
        *(void *)(a1 + 144) = *(void *)&v568[144];
        *(_WORD *)(a1 + 152) = 100;
        *(_OWORD *)(a1 + 170) = v246;
        long long v183 = *(_OWORD *)&v570[26];
LABEL_588:
        *(_OWORD *)(a1 + 180) = v183;
        return;
      }
      double v220 = v76 * v67 - v77 * v66;
      double v221 = v77 * v65 - v75 * v67;
      double v222 = v75 * v66 - v76 * v65;
      double v223 = sqrt(v222 * v222 + v221 * v221 + v220 * v220);
      double v224 = v220 / v223;
      double v225 = v48;
      double v226 = v221 / v223;
      double v227 = v222 / v223;
      double v228 = v77 * (v224 * v115 + v46 * (v221 / v223))
           + v76 * (v222 / v223 * v113 + v74 * v224)
           + v75 * (v221 / v223 * v112 + v225 * (v222 / v223));
      double v535 = v225;
      double v229 = 1.0 - (v74 * (v222 / v223) + v225 * (v221 / v223) + v46 * v224);
      if (v228 >= 0.0) {
        double v230 = v229;
      }
      else {
        double v230 = -v229;
      }
      if (v230 <= -2.0) {
        double v230 = v230 + 4.0;
      }
      if (v230 >= 0.0)
      {
        if (v230 <= v68) {
          goto LABEL_397;
        }
        double v231 = v230 - v68;
      }
      else
      {
        double v231 = -v230;
      }
      if (v231 > 0.0)
      {
        if (v230 + -2.0 <= -2.0) {
          double v250 = v230 + -2.0 + 4.0;
        }
        else {
          double v250 = v230 + -2.0;
        }
        double v251 = 0.0;
        if (v250 > v68) {
          double v251 = v250 - v68;
        }
        if (v250 < 0.0) {
          double v251 = -v250;
        }
        if (v251 < v231)
        {
          double v224 = -v224;
          double v226 = -v226;
          double v227 = -v227;
          goto LABEL_398;
        }
      }
LABEL_397:
      double v250 = v230;
LABEL_398:
      double v252 = -v68;
      double v499 = -v68;
      if (v68 >= 0.0) {
        double v252 = v68;
      }
      double v253 = -v250;
      if (v68 >= 0.0) {
        double v253 = v250;
      }
      BOOL v254 = v253 <= v252 && v253 >= 0.0;
      double v255 = fabs(v250);
      double v256 = vabdd_f64(v68, v250);
      if (v256 <= 0.00000001 || (v255 > 0.00000001 ? (BOOL v257 = !v254) : (BOOL v257 = 0), !v257))
      {
        double v454 = v255;
        if (v67 * (v224 * v111 + v55 * v226) + v66 * (v227 * v110 + v59 * v224) + v65 * (v226 * v109 + v57 * v227) >= 0.0) {
          double v258 = 1.0 - (v227 * v59 + v57 * v226 + v55 * v224);
        }
        else {
          double v258 = -(1.0 - (v227 * v59 + v57 * v226 + v55 * v224));
        }
        if (v258 <= -2.0) {
          double v258 = v258 + 4.0;
        }
        v571[0] = v258;
        double v259 = -v73;
        double v452 = -v73;
        if (v73 >= 0.0) {
          double v259 = v73;
        }
        double v260 = -v258;
        if (v73 >= 0.0) {
          double v260 = v258;
        }
        BOOL v261 = v260 <= v259 && v260 >= 0.0;
        double v262 = fabs(v258);
        double v263 = vabdd_f64(v73, v258);
        if (v263 <= 0.00000001 || (v262 > 0.00000001 ? (BOOL v264 = !v261) : (BOOL v264 = 0), !v264))
        {
          if (v454 <= 0.00000001)
          {
            if (v262 <= 0.00000001)
            {
              double v437 = v262;
              double v442 = v263;
              BOOL v429 = v261;
              double v447 = v256;
              double v456 = -v74;
              double v464 = v115;
              double v469 = v77;
              double v433 = v224;
              double v513 = v67;
              double v474 = v76;
              double v479 = v75;
              double v484 = v64;
              double v489 = v63;
              double v494 = v62;
              double v518 = v66;
              double v523 = v65;
              double v537 = v68;
              double v528 = v73;
              double v268 = a2[1];
              *(double *)uint64_t v568 = *a2;
              double v421 = v268;
              *(double *)v570 = v268;
              sub_10123D770((double *)v568, (double *)v570, 1);
              double v425 = *(double *)v568;
              double v269 = a4[1];
              *(double *)uint64_t v568 = *a4;
              double v417 = v269;
              *(double *)v570 = v269;
              sub_10123D770((double *)v568, (double *)v570, 1);
              double v65 = v523;
              double v73 = v528;
              double v68 = v537;
              double v74 = v546;
              double v67 = v513;
              double v66 = v518;
              double v63 = v489;
              double v62 = v494;
              double v75 = v479;
              double v64 = v484;
              double v77 = v469;
              double v76 = v474;
              double v110 = -v55;
              double v111 = -v57;
              double v109 = -v59;
              double v224 = v433;
              double v262 = v437;
              double v113 = -v46;
              double v115 = v464;
              double v112 = v456;
              double v263 = v442;
              double v256 = v447;
              BOOL v261 = v429;
              if (v425 == *(double *)v568) {
                goto LABEL_442;
              }
              if ((*(void *)&v425 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                && (*(void *)v568 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                double v350 = vabdd_f64(v425, *(double *)v568);
                double v351 = fabs(v425);
                double v352 = fabs(*(double *)v568);
                if (v351 >= v352) {
                  double v352 = v351;
                }
                double v353 = v352 >= 1.0 ? v352 * 2.22044605e-16 : 2.22044605e-16;
                double v256 = v447;
                BOOL v96 = v350 > v353;
                double v262 = v437;
                double v263 = v442;
                if (!v96)
                {
LABEL_442:
                  if (v421 == v417) {
                    goto LABEL_443;
                  }
                  if ((*(void *)&v421 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                    && (*(void *)&v417 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                  {
                    double v354 = vabdd_f64(v421, v417);
                    double v355 = fabs(v421);
                    double v356 = fabs(v417);
                    if (v355 < v356) {
                      double v355 = v356;
                    }
                    double v357 = v355 >= 1.0 ? v355 * 2.22044605e-16 : 2.22044605e-16;
                    double v256 = v447;
                    BOOL v96 = v354 > v357;
                    double v262 = v437;
                    double v263 = v442;
                    if (!v96)
                    {
LABEL_443:
                      v571[0] = 0.0;
LABEL_678:
                      int v360 = 1;
                      double v250 = 0.0;
LABEL_787:
                      *(void *)&v568[72] = 0;
                      *(void *)&v568[80] = &v567;
                      *(double *)&v568[24] = v250;
                      *(double *)&v568[32] = v68;
                      if (v68 >= 0.0)
                      {
                        double v499 = v68;
                      }
                      else
                      {
                        double v250 = -v250;
                        *(double *)&v568[24] = v250;
                        *(double *)&v568[32] = v499;
                      }
                      double v399 = 0.0;
                      if (v499 != 0.0) {
                        double v399 = v250 * 1000000.0 / v499;
                      }
                      double v400 = v571[0];
                      *(double *)&v568[40] = v399;
                      *(double *)&v568[48] = v571[0];
                      *(double *)&v568[56] = v73;
                      if (v73 < 0.0)
                      {
                        double v400 = -v571[0];
                        double v73 = v452;
                        *(double *)&v568[48] = -v571[0];
                        *(double *)&v568[56] = v452;
                      }
                      double v401 = 0.0;
                      if (v73 != 0.0) {
                        double v401 = v400 * 1000000.0 / v73;
                      }
                      *(double *)uint64_t v568 = v224;
                      *(double *)&v568[8] = v226;
                      *(double *)&v568[64] = v401;
                      *(double *)&v568[16] = v227;
                      *(_DWORD *)&v568[72] = v360;
                      sub_1012465F4(a1, (int *)&v561, (uint64_t)v568, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5);
                      return;
                    }
                  }
                }
              }
            }
            if (v263 <= 0.00000001)
            {
              double v438 = v262;
              double v443 = v263;
              BOOL v430 = v261;
              double v448 = v256;
              double v457 = v112;
              double v460 = v113;
              double v465 = v115;
              double v470 = v77;
              double v434 = v224;
              double v501 = v109;
              double v505 = v110;
              double v509 = v111;
              double v514 = v67;
              double v475 = v76;
              double v480 = v75;
              double v485 = v64;
              double v490 = v63;
              double v495 = v62;
              double v519 = v66;
              double v524 = v65;
              double v538 = v68;
              double v529 = v73;
              double v358 = a2[1];
              *(double *)uint64_t v568 = *a2;
              double v422 = v358;
              *(double *)v570 = v358;
              sub_10123D770((double *)v568, (double *)v570, 1);
              double v426 = *(double *)v568;
              double v359 = a5[1];
              *(double *)uint64_t v568 = *a5;
              double v418 = v359;
              *(double *)v570 = v359;
              sub_10123D770((double *)v568, (double *)v570, 1);
              double v65 = v524;
              double v73 = v529;
              double v68 = v538;
              double v74 = v546;
              double v67 = v514;
              double v66 = v519;
              double v63 = v490;
              double v62 = v495;
              double v75 = v480;
              double v64 = v485;
              double v77 = v470;
              double v76 = v475;
              double v110 = v505;
              double v111 = v509;
              double v109 = v501;
              double v224 = v434;
              double v262 = v438;
              double v113 = v460;
              double v115 = v465;
              double v112 = v457;
              double v263 = v443;
              double v256 = v448;
              BOOL v261 = v430;
              if (v426 == *(double *)v568) {
                goto LABEL_676;
              }
              if ((*(void *)&v426 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                && (*(void *)v568 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                double v361 = vabdd_f64(v426, *(double *)v568);
                double v362 = fabs(v426);
                double v363 = fabs(*(double *)v568);
                if (v362 >= v363) {
                  double v363 = v362;
                }
                double v364 = v363 >= 1.0 ? v363 * 2.22044605e-16 : 2.22044605e-16;
                double v256 = v448;
                BOOL v96 = v361 > v364;
                double v262 = v438;
                double v263 = v443;
                if (!v96)
                {
LABEL_676:
                  if (v422 == v418) {
                    goto LABEL_677;
                  }
                  if ((*(void *)&v422 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                    && (*(void *)&v418 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                  {
                    double v365 = vabdd_f64(v422, v418);
                    double v366 = fabs(v422);
                    double v367 = fabs(v418);
                    if (v366 < v367) {
                      double v366 = v367;
                    }
                    double v368 = v366 >= 1.0 ? v366 * 2.22044605e-16 : 2.22044605e-16;
                    double v256 = v448;
                    BOOL v96 = v365 > v368;
                    double v262 = v438;
                    double v263 = v443;
                    if (!v96)
                    {
LABEL_677:
                      v571[0] = v529;
                      goto LABEL_678;
                    }
                  }
                }
              }
            }
          }
          if (v256 <= 0.00000001)
          {
            if (v262 <= 0.00000001)
            {
              double v439 = v262;
              double v444 = v263;
              BOOL v431 = v261;
              double v449 = v256;
              double v458 = v112;
              double v461 = v113;
              double v466 = v115;
              double v471 = v77;
              double v435 = v224;
              double v502 = v109;
              double v506 = v110;
              double v510 = v111;
              double v515 = v67;
              double v476 = v76;
              double v481 = v75;
              double v486 = v64;
              double v491 = v63;
              double v496 = v62;
              double v520 = v66;
              double v525 = v65;
              double v539 = v68;
              double v530 = v73;
              double v369 = a3[1];
              *(double *)uint64_t v568 = *a3;
              double v423 = v369;
              *(double *)v570 = v369;
              sub_10123D770((double *)v568, (double *)v570, 1);
              double v427 = *(double *)v568;
              double v370 = a4[1];
              *(double *)uint64_t v568 = *a4;
              double v419 = v370;
              *(double *)v570 = v370;
              sub_10123D770((double *)v568, (double *)v570, 1);
              double v65 = v525;
              double v73 = v530;
              double v68 = v539;
              double v74 = v546;
              double v67 = v515;
              double v66 = v520;
              double v63 = v491;
              double v62 = v496;
              double v75 = v481;
              double v64 = v486;
              double v77 = v471;
              double v76 = v476;
              double v110 = v506;
              double v111 = v510;
              double v109 = v502;
              double v224 = v435;
              double v262 = v439;
              double v113 = v461;
              double v115 = v466;
              double v112 = v458;
              double v263 = v444;
              double v256 = v449;
              BOOL v261 = v431;
              if (v427 == *(double *)v568) {
                goto LABEL_701;
              }
              if ((*(void *)&v427 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                && (*(void *)v568 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                double v371 = vabdd_f64(v427, *(double *)v568);
                double v372 = fabs(v427);
                double v373 = fabs(*(double *)v568);
                if (v372 >= v373) {
                  double v373 = v372;
                }
                double v374 = v373 >= 1.0 ? v373 * 2.22044605e-16 : 2.22044605e-16;
                double v256 = v449;
                BOOL v96 = v371 > v374;
                double v262 = v439;
                double v263 = v444;
                if (!v96)
                {
LABEL_701:
                  if (v423 == v419) {
                    goto LABEL_702;
                  }
                  if ((*(void *)&v423 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                    && (*(void *)&v419 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                  {
                    double v375 = vabdd_f64(v423, v419);
                    double v376 = fabs(v423);
                    double v377 = fabs(v419);
                    if (v376 < v377) {
                      double v376 = v377;
                    }
                    double v378 = v376 >= 1.0 ? v376 * 2.22044605e-16 : 2.22044605e-16;
                    double v256 = v449;
                    BOOL v96 = v375 > v378;
                    double v262 = v439;
                    double v263 = v444;
                    if (!v96)
                    {
LABEL_702:
                      v571[0] = 0.0;
LABEL_726:
                      int v360 = 2;
                      double v250 = v68;
                      goto LABEL_787;
                    }
                  }
                }
              }
            }
            if (v263 <= 0.00000001)
            {
              double v440 = v262;
              double v445 = v263;
              BOOL v432 = v261;
              double v450 = v256;
              double v459 = v112;
              double v462 = v113;
              double v467 = v115;
              double v472 = v77;
              double v436 = v224;
              double v503 = v109;
              double v507 = v110;
              double v511 = v111;
              double v516 = v67;
              double v477 = v76;
              double v482 = v75;
              double v487 = v64;
              double v492 = v63;
              double v497 = v62;
              double v521 = v66;
              double v526 = v65;
              double v540 = v68;
              double v531 = v73;
              double v379 = a3[1];
              *(double *)uint64_t v568 = *a3;
              double v424 = v379;
              *(double *)v570 = v379;
              sub_10123D770((double *)v568, (double *)v570, 1);
              double v428 = *(double *)v568;
              double v380 = a5[1];
              *(double *)uint64_t v568 = *a5;
              double v420 = v380;
              *(double *)v570 = v380;
              sub_10123D770((double *)v568, (double *)v570, 1);
              double v65 = v526;
              double v73 = v531;
              double v68 = v540;
              double v74 = v546;
              double v67 = v516;
              double v66 = v521;
              double v63 = v492;
              double v62 = v497;
              double v75 = v482;
              double v64 = v487;
              double v77 = v472;
              double v76 = v477;
              double v110 = v507;
              double v111 = v511;
              double v109 = v503;
              double v224 = v436;
              double v262 = v440;
              double v113 = v462;
              double v115 = v467;
              double v112 = v459;
              double v263 = v445;
              double v256 = v450;
              BOOL v261 = v432;
              if (v428 == *(double *)v568) {
                goto LABEL_724;
              }
              if ((*(void *)&v428 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                && (*(void *)v568 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                double v381 = vabdd_f64(v428, *(double *)v568);
                double v382 = fabs(v428);
                double v383 = fabs(*(double *)v568);
                if (v382 >= v383) {
                  double v383 = v382;
                }
                double v384 = v383 >= 1.0 ? v383 * 2.22044605e-16 : 2.22044605e-16;
                double v256 = v450;
                BOOL v96 = v381 > v384;
                double v262 = v440;
                double v263 = v445;
                if (!v96)
                {
LABEL_724:
                  if (v424 == v420) {
                    goto LABEL_725;
                  }
                  if ((*(void *)&v424 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                    && (*(void *)&v420 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                  {
                    double v385 = vabdd_f64(v424, v420);
                    double v386 = fabs(v424);
                    double v387 = fabs(v420);
                    if (v386 < v387) {
                      double v386 = v387;
                    }
                    double v388 = v386 >= 1.0 ? v386 * 2.22044605e-16 : 2.22044605e-16;
                    double v256 = v450;
                    BOOL v96 = v385 > v388;
                    double v262 = v440;
                    double v263 = v445;
                    if (!v96)
                    {
LABEL_725:
                      v571[0] = v531;
                      goto LABEL_726;
                    }
                  }
                }
              }
            }
          }
          if (v254)
          {
            if (v262 <= 0.00000001 && v79 == 0)
            {
              if (v77 * (v55 * v115 + v46 * v57) + v76 * (v59 * v113 + v74 * v55) + v75 * (v57 * v112 + v535 * v59) >= 0.0) {
                double v393 = 1.0 - (v74 * v59 + v535 * v57 + v46 * v55);
              }
              else {
                double v393 = -(1.0 - (v74 * v59 + v535 * v57 + v46 * v55));
              }
              if (v393 <= -2.0) {
                double v250 = v393 + 4.0;
              }
              else {
                double v250 = v393;
              }
              v571[0] = 0.0;
              int v360 = 3;
              goto LABEL_787;
            }
            if (v263 <= 0.00000001 && v78 == 0)
            {
              if (v77 * (v62 * v115 + v46 * v63) + v76 * (v64 * v113 + v74 * v62) + v75 * (v63 * v112 + v535 * v64) >= 0.0) {
                double v395 = 1.0 - (v74 * v64 + v535 * v63 + v46 * v62);
              }
              else {
                double v395 = -(1.0 - (v74 * v64 + v535 * v63 + v46 * v62));
              }
              if (v395 <= -2.0) {
                double v250 = v395 + 4.0;
              }
              else {
                double v250 = v395;
              }
              v571[0] = v73;
              int v360 = 4;
              goto LABEL_787;
            }
          }
          if (v261)
          {
            if (v454 <= 0.00000001 && v70 == 0)
            {
              if (v67 * (v46 * v111 + v55 * v535) + v66 * (v74 * v110 + v59 * v46) + v65 * (v535 * v109 + v57 * v74) >= 0.0) {
                double v394 = 1.0 - (v74 * v59 + v57 * v535 + v55 * v46);
              }
              else {
                double v394 = -(1.0 - (v74 * v59 + v57 * v535 + v55 * v46));
              }
              v571[0] = v394;
              double v250 = 0.0;
              if (v394 <= -2.0) {
                v571[0] = v394 + 4.0;
              }
              int v360 = 1;
              goto LABEL_787;
            }
            if (v256 <= 0.00000001 && v69 == 0)
            {
              double v396 = v73;
              double v397 = v68;
              double v398 = v224;
              sub_101246B4C(v564, &v558, v565, v571);
              double v224 = v398;
              double v68 = v397;
              double v73 = v396;
              int v360 = 2;
              double v250 = v397;
              goto LABEL_787;
            }
            if (v254)
            {
              int v360 = 0;
              goto LABEL_787;
            }
          }
        }
      }
      sub_1012461EC(a1);
      return;
    }
  }
  unint64_t v561 = 0;
  unint64_t v562 = 0;
  if (v81) {
    goto LABEL_146;
  }
LABEL_109:
  double v536 = v68;
  if (v94)
  {
    v571[0] = 0.0;
    if (sub_1012463F4(a2, a3, a4, v566, &v554, v564, v563, &v553, v571, v71))
    {
      if (v536 >= 0.0) {
        double v118 = v571[0];
      }
      else {
        double v118 = -v571[0];
      }
      if (v536 >= 0.0) {
        double v119 = v536;
      }
      else {
        double v119 = -v536;
      }
      double v120 = 0.0;
      if (v119 != 0.0) {
        double v120 = v118 * 1000000.0 / v119;
      }
      memset(&v568[24], 0, 128);
      uint64_t v121 = 40;
      do
      {
        double v122 = &v568[v121];
        *(_OWORD *)double v122 = xmmword_1015E0D30;
        *((void *)v122 + 2) = 0;
        *((void *)v122 + 3) = 0;
        *((_OWORD *)v122 + 2) = xmmword_1015E0D40;
        v122[48] = 0;
        v121 += 56;
      }
      while (v122 + 56 != v569);
      *(void *)uint64_t v568 = 1;
      *(_OWORD *)&v568[8] = *(_OWORD *)a4;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13390, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_101B13390))
      {
        qword_101B13388 = 0x3FF0000000000000;
        __cxa_guard_release(&qword_101B13390);
      }
      v568[88] = 1;
      *(double *)&v568[40] = v118;
      *(double *)&v568[48] = v119;
      *(double *)&v568[56] = v120;
      *(void *)&v568[64] = 0;
      *(void *)&v568[72] = qword_101B13388;
      *(void *)&v568[80] = 0;
LABEL_159:
      memset(&v570[2], 0, 40);
      long long v141 = *(_OWORD *)&v568[112];
      *(_OWORD *)(a1 + 96) = *(_OWORD *)&v568[96];
      *(_OWORD *)(a1 + 112) = v141;
      *(_OWORD *)(a1 + 128) = *(_OWORD *)&v568[128];
      *(void *)(a1 + 144) = *(void *)&v568[144];
      long long v142 = *(_OWORD *)&v568[48];
      *(_OWORD *)(a1 + 32) = *(_OWORD *)&v568[32];
      *(_OWORD *)(a1 + 48) = v142;
      long long v143 = *(_OWORD *)&v568[80];
      *(_OWORD *)(a1 + 64) = *(_OWORD *)&v568[64];
      *(_OWORD *)(a1 + 80) = v143;
      long long v144 = *(_OWORD *)&v568[16];
      *(_OWORD *)a1 = *(_OWORD *)v568;
      *(_OWORD *)(a1 + 16) = v144;
      *(_WORD *)(a1 + 152) = 48;
      long long v34 = *(_OWORD *)&v570[16];
      *(_OWORD *)(a1 + 154) = *(_OWORD *)v570;
LABEL_587:
      *(_OWORD *)(a1 + 170) = v34;
      long long v183 = *(_OWORD *)&v570[26];
      goto LABEL_588;
    }
    *(void *)uint64_t v568 = 0;
    uint64_t v194 = 40;
    do
    {
      uint64_t v195 = &v568[v194];
      *(_OWORD *)uint64_t v195 = xmmword_1015E0D30;
      *((void *)v195 + 2) = 0;
      *((void *)v195 + 3) = 0;
      *((_OWORD *)v195 + 2) = xmmword_1015E0D40;
      v195[48] = 0;
      v194 += 56;
    }
    while (v195 + 56 != v569);
    goto LABEL_585;
  }
  double v500 = -v59;
  double v504 = -v55;
  double v508 = -v57;
  double v512 = v67;
  double v483 = v64;
  double v488 = v63;
  double v493 = v62;
  double v517 = v66;
  double v522 = v65;
  double v441 = v116;
  double v527 = v73;
  double v534 = v48;
  double v455 = -v74;
  double v463 = -v48;
  double v468 = v77;
  double v473 = v76;
  double v478 = v75;
  double v145 = 1.0 - (v74 * v59 + v48 * v57 + v46 * v55);
  double v446 = -v145;
  double v451 = v145;
  if ((v55 * v115 + v46 * v57) * v77 + v76 * (v59 * v113 + v74 * v55) + v75 * (v57 * v112 + v48 * v59) >= 0.0) {
    double v146 = 1.0 - (v74 * v59 + v48 * v57 + v46 * v55);
  }
  else {
    double v146 = -v145;
  }
  if (v146 <= -2.0) {
    double v147 = v146 + 4.0;
  }
  else {
    double v147 = v146;
  }
  BOOL v148 = sub_101246BC4(a4, v147, *a2, a2[1]);
  double v149 = 0.0;
  double v498 = 0.0;
  if (!v148)
  {
    if (sub_101246BC4(a4, v536 - v147, *a3, a3[1])) {
      double v149 = v536;
    }
    else {
      double v149 = v147;
    }
  }
  double v453 = v149;
  if ((v493 * v463 + v46 * v488) * v468 + v473 * (v483 * -v46 + v546 * v493) + v478 * (v488 * v455 + v534 * v483) >= 0.0) {
    double v150 = 1.0 - (v483 * v546 + v534 * v488 + v46 * v493);
  }
  else {
    double v150 = -(1.0 - (v483 * v546 + v534 * v488 + v46 * v493));
  }
  if (v150 <= -2.0) {
    double v151 = v150 + 4.0;
  }
  else {
    double v151 = v150;
  }
  if (!sub_101246BC4(a5, v151, *a2, a2[1]))
  {
    if (sub_101246BC4(a5, v536 - v151, *a3, a3[1])) {
      double v152 = v536;
    }
    else {
      double v152 = v151;
    }
    double v498 = v152;
  }
  double v153 = v451;
  if ((v46 * v508 + v55 * v534) * v512 + v517 * (v546 * v504 + v59 * v46) + v522 * (v534 * v500 + v57 * v546) < 0.0) {
    double v153 = v446;
  }
  if (v153 <= -2.0) {
    double v154 = v153 + 4.0;
  }
  else {
    double v154 = v153;
  }
  BOOL v155 = sub_101246BC4(a2, v154, *a4, a4[1]);
  double v156 = 0.0;
  double v157 = 0.0;
  if (!v155)
  {
    if (sub_101246BC4(a2, v527 - v154, *a5, a5[1])) {
      double v157 = v527;
    }
    else {
      double v157 = v154;
    }
    double v156 = 0.0;
  }
  double v158 = v157;
  if (v512 * (v50 * v508 + v55 * v52) + v517 * (v54 * v504 + v59 * v50) + v522 * (v52 * v500 + v57 * v54) >= 0.0) {
    double v159 = 1.0 - (v59 * v54 + v57 * v52 + v55 * v50);
  }
  else {
    double v159 = -(1.0 - (v59 * v54 + v57 * v52 + v55 * v50));
  }
  if (v159 <= -2.0) {
    double v160 = v159 + 4.0;
  }
  else {
    double v160 = v159;
  }
  BOOL v161 = sub_101246BC4(a3, v160, *a4, a4[1]);
  double v162 = v527;
  if (v161 || (BOOL v163 = sub_101246BC4(a3, v527 - v160, *a5, a5[1]), v162 = v527, v156 = v160, v164 = v527, !v163)) {
    double v164 = v156;
  }
  double v165 = v158;
  if (v162 >= 0.0) {
    double v166 = v162;
  }
  else {
    double v166 = -v162;
  }
  if (v162 >= 0.0) {
    double v167 = v158;
  }
  else {
    double v167 = -v158;
  }
  if (v166 == 0.0)
  {
    if (v162 >= 0.0) {
      double v168 = v164;
    }
    else {
      double v168 = -v164;
    }
    double v169 = 0.0;
    double v170 = 0.0;
  }
  else
  {
    double v169 = v167 * 1000000.0 / v166;
    if (v162 >= 0.0) {
      double v168 = v164;
    }
    else {
      double v168 = -v164;
    }
    double v170 = v168 * 1000000.0 / v166;
  }
  if (v536 >= 0.0) {
    double v200 = v536;
  }
  else {
    double v200 = -v536;
  }
  if (v536 >= 0.0) {
    double v201 = v453;
  }
  else {
    double v201 = -v453;
  }
  if (v200 == 0.0)
  {
    if (v536 >= 0.0) {
      double v202 = v498;
    }
    else {
      double v202 = -v498;
    }
    double v203 = 0.0;
    double v204 = 0.0;
  }
  else
  {
    double v203 = v201 * 1000000.0 / v200;
    if (v536 >= 0.0) {
      double v202 = v498;
    }
    else {
      double v202 = -v498;
    }
    double v204 = v202 * 1000000.0 / v200;
  }
  if (v453 == 0.0
    || (*(void *)&v453 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
    && ((v206 = vabdd_f64(0.0, v453), double v207 = fmax(fabs(v453), 0.0), v207 >= 1.0)
      ? (double v208 = v207 * 2.22044605e-16)
      : (double v208 = 2.22044605e-16),
        v206 <= v208))
  {
    unsigned int v205 = 1;
    goto LABEL_293;
  }
  if (v498 == 0.0
    || (*(void *)&v498 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
    && ((double v265 = vabdd_f64(0.0, v498), v266 = fmax(fabs(v498), 0.0), v266 >= 1.0)
      ? (double v267 = v266 * 2.22044605e-16)
      : (double v267 = 2.22044605e-16),
        v265 <= v267))
  {
    unsigned int v205 = 3;
    goto LABEL_293;
  }
  if (v453 < v498)
  {
    if (v453 <= 0.0)
    {
      if (v498 >= 0.0) {
        unsigned int v205 = 2;
      }
      else {
        unsigned int v205 = 4;
      }
      goto LABEL_293;
    }
LABEL_447:
    unsigned int v205 = 0;
    goto LABEL_293;
  }
  if (v453 < 0.0) {
    goto LABEL_447;
  }
  if (v498 <= 0.0) {
    unsigned int v205 = 2;
  }
  else {
    unsigned int v205 = 4;
  }
LABEL_293:
  if (v536 == v453)
  {
LABEL_294:
    unsigned int v209 = 1;
    goto LABEL_451;
  }
  if (((*(void *)&v536 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 <= 0x3FE
    || (*(void *)&v536 & 0x7FFFFFFFFFFFFFFFuLL) - 1 <= 0xFFFFFFFFFFFFELL
    || *(void *)&v536 == 0)
  {
    if ((*(void *)&v453 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      double v212 = vabdd_f64(v536, v453);
      double v213 = fabs(v536);
      double v214 = fabs(v453);
      if (v213 < v214) {
        double v213 = v214;
      }
      double v215 = v213 >= 1.0 ? v213 * 2.22044605e-16 : 2.22044605e-16;
      if (v212 <= v215) {
        goto LABEL_294;
      }
    }
    if (v536 == v498) {
      goto LABEL_384;
    }
    if ((*(void *)&v498 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      double v216 = vabdd_f64(v536, v498);
      double v217 = fabs(v536);
      double v218 = fabs(v498);
      if (v217 < v218) {
        double v217 = v218;
      }
      double v219 = v217 >= 1.0 ? v217 * 2.22044605e-16 : 2.22044605e-16;
      if (v216 <= v219)
      {
LABEL_384:
        unsigned int v209 = 3;
        goto LABEL_451;
      }
    }
  }
  else if (v536 == v498)
  {
    goto LABEL_384;
  }
  if (v453 >= v498)
  {
    if (v536 <= v453)
    {
      if (v536 >= v498) {
        unsigned int v209 = 2;
      }
      else {
        unsigned int v209 = 4;
      }
      goto LABEL_451;
    }
  }
  else if (v536 >= v453)
  {
    if (v536 <= v498) {
      unsigned int v209 = 2;
    }
    else {
      unsigned int v209 = 4;
    }
    goto LABEL_451;
  }
  unsigned int v209 = 0;
LABEL_451:
  if (v165 == 0.0
    || (*(void *)&v165 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
    && ((double v271 = vabdd_f64(0.0, v165), v272 = fmax(fabs(v165), 0.0), v272 >= 1.0)
      ? (double v273 = v272 * 2.22044605e-16)
      : (double v273 = 2.22044605e-16),
        v271 <= v273))
  {
    int v270 = 1;
    goto LABEL_460;
  }
  if (v164 == 0.0
    || (*(void *)&v164 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
    && ((double v285 = vabdd_f64(0.0, v164), v286 = fmax(fabs(v164), 0.0), v286 >= 1.0)
      ? (double v287 = v286 * 2.22044605e-16)
      : (double v287 = 2.22044605e-16),
        v285 <= v287))
  {
    int v270 = 3;
    goto LABEL_460;
  }
  if (v165 < v164)
  {
    if (v165 <= 0.0)
    {
      if (v164 >= 0.0) {
        int v270 = 2;
      }
      else {
        int v270 = 4;
      }
      goto LABEL_460;
    }
LABEL_505:
    int v270 = 0;
    goto LABEL_460;
  }
  if (v165 < 0.0) {
    goto LABEL_505;
  }
  if (v164 <= 0.0) {
    int v270 = 2;
  }
  else {
    int v270 = 4;
  }
LABEL_460:
  if (v162 == v165)
  {
LABEL_461:
    int v274 = 1;
    goto LABEL_509;
  }
  if (((*(void *)&v162 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 <= 0x3FE
    || (*(void *)&v162 & 0x7FFFFFFFFFFFFFFFuLL) - 1 <= 0xFFFFFFFFFFFFELL
    || *(void *)&v162 == 0)
  {
    if ((*(void *)&v165 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      double v277 = vabdd_f64(v162, v165);
      double v278 = fabs(v162);
      double v279 = fabs(v165);
      if (v278 < v279) {
        double v278 = v279;
      }
      double v280 = v278 >= 1.0 ? v278 * 2.22044605e-16 : 2.22044605e-16;
      if (v277 <= v280) {
        goto LABEL_461;
      }
    }
    if (v162 == v164) {
      goto LABEL_491;
    }
    if ((*(void *)&v164 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      double v281 = vabdd_f64(v162, v164);
      double v282 = fabs(v162);
      double v283 = fabs(v164);
      if (v282 < v283) {
        double v282 = v283;
      }
      double v284 = v282 >= 1.0 ? v282 * 2.22044605e-16 : 2.22044605e-16;
      if (v281 <= v284) {
        goto LABEL_491;
      }
    }
  }
  else if (v162 == v164)
  {
LABEL_491:
    int v274 = 3;
    goto LABEL_509;
  }
  if (v165 < v164)
  {
    if (v162 >= v165)
    {
      if (v162 <= v164) {
        int v274 = 2;
      }
      else {
        int v274 = 4;
      }
      goto LABEL_509;
    }
LABEL_503:
    int v274 = 0;
    goto LABEL_509;
  }
  if (v162 > v165) {
    goto LABEL_503;
  }
  if (v162 >= v164) {
    int v274 = 2;
  }
  else {
    int v274 = 4;
  }
LABEL_509:
  if (v205 == 3)
  {
    double v169 = 0.0;
    if (v166 != 0.0) {
      double v169 = v166 * 1000000.0 / v166;
    }
    if (v536 >= 0.0) {
      double v202 = 0.0;
    }
    else {
      double v202 = -0.0;
    }
    if (v200 == 0.0) {
      double v204 = 0.0;
    }
    else {
      double v204 = v202 / v200;
    }
    double v167 = v166;
  }
  else if (v205 == 1)
  {
    if (v162 >= 0.0) {
      double v167 = 0.0;
    }
    else {
      double v167 = -0.0;
    }
    if (v166 == 0.0) {
      double v169 = 0.0;
    }
    else {
      double v169 = v167 / v166;
    }
    if (v536 >= 0.0) {
      double v201 = 0.0;
    }
    else {
      double v201 = -0.0;
    }
    if (v200 == 0.0) {
      double v203 = 0.0;
    }
    else {
      double v203 = v201 / v200;
    }
  }
  if (v209 != 3)
  {
    if (v209 == 1)
    {
      double v203 = 0.0;
      if (v162 >= 0.0) {
        double v168 = 0.0;
      }
      else {
        double v168 = -0.0;
      }
      if (v166 == 0.0) {
        double v170 = 0.0;
      }
      else {
        double v170 = v168 / v166;
      }
      if (v200 != 0.0) {
        double v203 = v200 * 1000000.0 / v200;
      }
      double v201 = v200;
      goto LABEL_548;
    }
    if (v205 | v209 && (v205 < 4 || v209 < 4)) {
      goto LABEL_548;
    }
    *(void *)uint64_t v568 = 0;
    uint64_t v313 = 40;
    do
    {
      uint64_t v314 = &v568[v313];
      *(_OWORD *)uint64_t v314 = xmmword_1015E0D30;
      *((void *)v314 + 2) = 0;
      *((void *)v314 + 3) = 0;
      *((_OWORD *)v314 + 2) = xmmword_1015E0D40;
      v314[48] = 0;
      v313 += 56;
    }
    while (v314 + 56 != v569);
LABEL_585:
    memset(&v570[2], 0, 32);
    long long v315 = *(_OWORD *)&v568[112];
    *(_OWORD *)(a1 + 96) = *(_OWORD *)&v568[96];
    *(_OWORD *)(a1 + 112) = v315;
    *(_OWORD *)(a1 + 128) = *(_OWORD *)&v568[128];
    long long v316 = *(_OWORD *)&v568[48];
    *(_OWORD *)(a1 + 32) = *(_OWORD *)&v568[32];
    *(_OWORD *)(a1 + 48) = v316;
    long long v317 = *(_OWORD *)&v568[80];
    *(_OWORD *)(a1 + 64) = *(_OWORD *)&v568[64];
    *(_OWORD *)(a1 + 80) = v317;
    long long v318 = *(_OWORD *)&v568[16];
    *(_OWORD *)a1 = *(_OWORD *)v568;
    *(_OWORD *)(a1 + 16) = v318;
    long long v34 = *(_OWORD *)&v570[16];
    *(_OWORD *)(a1 + 154) = *(_OWORD *)v570;
    *(void *)&v570[34] = 0;
    *(void *)(a1 + 144) = *(void *)&v568[144];
    __int16 v35 = 100;
LABEL_586:
    *(_WORD *)(a1 + 152) = v35;
    goto LABEL_587;
  }
  double v204 = 0.0;
  double v170 = 0.0;
  if (v166 != 0.0) {
    double v170 = v166 * 1000000.0 / v166;
  }
  if (v200 != 0.0) {
    double v204 = v200 * 1000000.0 / v200;
  }
  double v168 = v166;
  double v202 = v200;
LABEL_548:
  memset(v568, 0, sizeof(v568));
  uint64_t v288 = 40;
  do
  {
    long long v289 = &v568[v288];
    *(_OWORD *)long long v289 = xmmword_1015E0D30;
    *((void *)v289 + 2) = 0;
    *((void *)v289 + 3) = 0;
    *((_OWORD *)v289 + 2) = xmmword_1015E0D40;
    v289[48] = 0;
    v288 += 56;
  }
  while (v289 + 56 != v569);
  *(_OWORD *)v570 = xmmword_1015E0D30;
  *(void *)&v570[16] = 0;
  *(void *)&v570[24] = 0;
  *(_OWORD *)&v570[32] = xmmword_1015E0D40;
  char v290 = &qword_101B13000;
  if (v205 - 1 > 2)
  {
    unsigned int v292 = 0;
  }
  else
  {
    *(_OWORD *)&v568[8] = *(_OWORD *)a2;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13390, memory_order_acquire) & 1) == 0)
    {
      unsigned int v547 = v205;
      unsigned int v402 = v209;
      double v541 = v170;
      int v403 = v270;
      double v532 = v169;
      int v404 = __cxa_guard_acquire(&qword_101B13390);
      char v290 = &qword_101B13000;
      double v169 = v532;
      int v270 = v403;
      double v170 = v541;
      unsigned int v209 = v402;
      unsigned int v205 = v547;
      if (v404)
      {
        qword_101B13388 = 0x3FF0000000000000;
        __cxa_guard_release(&qword_101B13390);
        char v290 = &qword_101B13000;
        double v169 = v532;
        int v270 = v403;
        double v170 = v541;
        unsigned int v209 = v402;
        unsigned int v205 = v547;
      }
    }
    v568[88] = 1;
    *(void *)&v568[40] = 0;
    *(void *)&v568[48] = qword_101B13388;
    *(void *)&v568[56] = 0;
    *(double *)&v568[64] = v167;
    *(double *)&v568[72] = v166;
    *(double *)&v568[80] = v169;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13390, memory_order_acquire) & 1) == 0)
    {
      unsigned int v548 = v205;
      unsigned int v405 = v209;
      double v406 = v170;
      int v542 = v270;
      int v407 = __cxa_guard_acquire(&qword_101B13390);
      char v290 = &qword_101B13000;
      int v270 = v542;
      double v170 = v406;
      unsigned int v209 = v405;
      unsigned int v205 = v548;
      if (v407)
      {
        qword_101B13388 = 0x3FF0000000000000;
        __cxa_guard_release(&qword_101B13390);
        char v290 = &qword_101B13000;
        int v270 = v542;
        double v170 = v406;
        unsigned int v209 = v405;
        unsigned int v205 = v548;
      }
    }
    uint64_t v291 = v290[113];
    *(void *)v570 = 0;
    *(void *)&v570[8] = v291;
    *(void *)&v570[16] = 0;
    unsigned int v292 = 1;
  }
  if (v270 == 2)
  {
    *(_OWORD *)&v568[16 * v292 + 8] = *(_OWORD *)a4;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13390, memory_order_acquire) & 1) == 0)
    {
      unsigned int v549 = v205;
      unsigned int v408 = v209;
      double v409 = v170;
      int v410 = __cxa_guard_acquire(&qword_101B13390);
      char v290 = &qword_101B13000;
      int v270 = 2;
      double v170 = v409;
      unsigned int v209 = v408;
      unsigned int v205 = v549;
      if (v410)
      {
        qword_101B13388 = 0x3FF0000000000000;
        __cxa_guard_release(&qword_101B13390);
        char v290 = &qword_101B13000;
        int v270 = 2;
        double v170 = v409;
        unsigned int v209 = v408;
        unsigned int v205 = v549;
      }
    }
    uint64_t v293 = v290[113];
    long long v294 = (double *)&v568[56 * v292];
    *((unsigned char *)v294 + 88) = 1;
    v294[5] = v201;
    v294[6] = v200;
    v294[7] = v203;
    v294[8] = 0.0;
    *((void *)v294 + 9) = v293;
    v294[10] = 0.0;
    long long v295 = (double *)&v570[24 * v292];
    *long long v295 = v201;
    v295[1] = v200;
    v295[2] = v203;
    ++v292;
  }
  unsigned int v296 = v209 - 1;
  if (v209 - 1 <= 2 && v292 <= 1)
  {
    *(_OWORD *)&v568[16 * v292 + 8] = *(_OWORD *)a3;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B133B0, memory_order_acquire) & 1) == 0)
    {
      unsigned int v550 = v205;
      unsigned int v411 = v209;
      double v412 = v170;
      int v543 = v270;
      int v413 = __cxa_guard_acquire(&qword_101B133B0);
      int v270 = v543;
      double v170 = v412;
      unsigned int v209 = v411;
      unsigned int v205 = v550;
      if (v413)
      {
        *(void *)&xmmword_101B13398 = 0x3FF0000000000000;
        *((void *)&xmmword_101B13398 + 1) = 0x3FF0000000000000;
        qword_101B133A8 = 0x412E848000000000;
        __cxa_guard_release(&qword_101B133B0);
        int v270 = v543;
        double v170 = v412;
        unsigned int v209 = v411;
        unsigned int v205 = v550;
      }
    }
    long long v297 = xmmword_101B13398;
    uint64_t v298 = qword_101B133A8;
    long long v299 = &v568[56 * v292];
    v299[88] = 1;
    *(_OWORD *)(v299 + 40) = v297;
    *((void *)v299 + 7) = v298;
    *((double *)v299 + 8) = v168;
    *((double *)v299 + 9) = v166;
    *((double *)v299 + 10) = v170;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B133B0, memory_order_acquire) & 1) == 0)
    {
      unsigned int v551 = v205;
      unsigned int v414 = v209;
      int v544 = v270;
      int v415 = __cxa_guard_acquire(&qword_101B133B0);
      int v270 = v544;
      unsigned int v209 = v414;
      unsigned int v205 = v551;
      if (v415)
      {
        *(void *)&xmmword_101B13398 = 0x3FF0000000000000;
        *((void *)&xmmword_101B13398 + 1) = 0x3FF0000000000000;
        qword_101B133A8 = 0x412E848000000000;
        __cxa_guard_release(&qword_101B133B0);
        int v270 = v544;
        unsigned int v209 = v414;
        unsigned int v205 = v551;
      }
    }
    uint64_t v300 = qword_101B133A8;
    uint64_t v301 = &v570[24 * v292];
    *(_OWORD *)uint64_t v301 = xmmword_101B13398;
    *((void *)v301 + 2) = v300;
    ++v292;
  }
  if (v274 == 2 && v292 <= 1)
  {
    *(_OWORD *)&v568[16 * v292 + 8] = *(_OWORD *)a5;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B133B0, memory_order_acquire) & 1) == 0)
    {
      unsigned int v552 = v205;
      unsigned int v533 = v209;
      int v545 = v270;
      int v416 = __cxa_guard_acquire(&qword_101B133B0);
      int v270 = v545;
      unsigned int v209 = v533;
      unsigned int v205 = v552;
      if (v416)
      {
        *(void *)&xmmword_101B13398 = 0x3FF0000000000000;
        *((void *)&xmmword_101B13398 + 1) = 0x3FF0000000000000;
        qword_101B133A8 = 0x412E848000000000;
        __cxa_guard_release(&qword_101B133B0);
        int v270 = v545;
        unsigned int v209 = v533;
        unsigned int v205 = v552;
      }
    }
    long long v302 = xmmword_101B13398;
    uint64_t v303 = qword_101B133A8;
    double v304 = (double *)&v568[56 * v292];
    *((unsigned char *)v304 + 88) = 1;
    v304[5] = v202;
    v304[6] = v200;
    v304[7] = v204;
    *((_OWORD *)v304 + 4) = v302;
    *((void *)v304 + 10) = v303;
    double v305 = (double *)&v570[24 * v292];
    *double v305 = v202;
    v305[1] = v200;
    v305[2] = v204;
    ++v292;
  }
  if (v292 != 2) {
    goto LABEL_595;
  }
  if (vabdd_f64(*(double *)&v570[40], *(double *)&v570[16]) >= 50.0)
  {
    if (*(double *)&v570[40] >= *(double *)&v570[16]) {
      goto LABEL_595;
    }
  }
  else
  {
    if (*(double *)&v570[32] == 0.0) {
      __assert_rtn("apply", "segment_ratio.hpp", 56, "lhs.denominator() != Type(0)");
    }
    if (*(double *)&v570[8] == 0.0) {
      __assert_rtn("apply", "segment_ratio.hpp", 57, "rhs.denominator() != Type(0)");
    }
    double v306 = *(double *)&v570[24] / *(double *)&v570[32];
    double v307 = *(double *)v570 / *(double *)&v570[8];
    if (*(double *)&v570[24] / *(double *)&v570[32] == *(double *)v570 / *(double *)&v570[8]) {
      goto LABEL_595;
    }
    if (COERCE_UNSIGNED_INT64(fabs(*(double *)&v570[24] / *(double *)&v570[32])) > 0x7FEFFFFFFFFFFFFFLL
      || COERCE_UNSIGNED_INT64(fabs(*(double *)v570 / *(double *)&v570[8])) > 0x7FEFFFFFFFFFFFFFLL)
    {
      BOOL v312 = 1;
    }
    else
    {
      double v308 = vabdd_f64(v306, v307);
      double v309 = fabs(v306);
      double v310 = fabs(v307);
      if (v309 < v310) {
        double v309 = v310;
      }
      double v311 = v309 >= 1.0 ? v309 * 2.22044605e-16 : 2.22044605e-16;
      BOOL v312 = v308 > v311;
    }
    if (v306 >= v307 || !v312) {
      goto LABEL_595;
    }
  }
  char v319 = v568[88];
  long long v320 = *(_OWORD *)&v568[40];
  long long v321 = *(_OWORD *)&v568[56];
  long long v322 = *(_OWORD *)&v568[72];
  *(_OWORD *)&v568[40] = *(_OWORD *)&v568[96];
  *(_OWORD *)&v568[56] = *(_OWORD *)&v568[112];
  *(_OWORD *)&v568[72] = *(_OWORD *)&v568[128];
  v568[88] = v568[144];
  *(_OWORD *)&v568[112] = v321;
  *(_OWORD *)&v568[128] = v322;
  *(_OWORD *)&v568[96] = v320;
  v568[144] = v319;
  long long v323 = *(_OWORD *)&v568[8];
  *(_OWORD *)v571 = *(_OWORD *)&v568[8];
  *(_OWORD *)&v568[8] = *(_OWORD *)&v568[24];
  *(_OWORD *)&v568[24] = v323;
LABEL_595:
  if ((v209 & 0xFFFFFFFD) == 1) {
    int v324 = 0;
  }
  else {
    int v324 = -1;
  }
  unsigned int v325 = v205 - 4;
  BOOL v326 = v205 - 4 < 0xFFFFFFFD;
  int v327 = (v205 & 0xFFFFFFFD) != 1;
  BOOL v328 = (v205 & 0xFFFFFFFD) != 1 || v205 - 4 < 0xFFFFFFFD;
  if (v325 <= 0xFFFFFFFC) {
    int v327 = 0;
  }
  if (v209 == 2) {
    int v324 = 1;
  }
  else {
    int v327 = v326;
  }
  int v329 = !v328;
  if ((v209 & 0xFFFFFFFD) == 1)
  {
    int v327 = !v328;
    BOOL v330 = v296 >= 3;
  }
  else
  {
    BOOL v330 = 1;
  }
  *(void *)uint64_t v568 = v292;
  unsigned int v331 = v274 & 0xFFFFFFFD;
  if (!v330) {
    int v329 = v327 + 1;
  }
  unsigned int v332 = v270 & 0xFFFFFFFD;
  unsigned int v333 = v270 - 4;
  BOOL v334 = (v270 - 4) < 0xFFFFFFFD;
  BOOL v97 = v332 == 1;
  BOOL v335 = v332 != 1;
  int v336 = !v97 || v334;
  if (v333 <= 0xFFFFFFFC) {
    BOOL v335 = 0;
  }
  int v337 = v336 ^ 1;
  if (v274 != 2) {
    BOOL v335 = v334;
  }
  unsigned int v338 = v274 - 1;
  if (v331 == 1) {
    int v339 = v337;
  }
  else {
    int v339 = v335;
  }
  if (v331 != 1 || v338 >= 3) {
    int v341 = v337;
  }
  else {
    int v341 = v339 + 1;
  }
  BOOL v342 = v327 == 0;
  if (v296 < 3) {
    BOOL v342 = v326;
  }
  BOOL v343 = v339 == 0;
  if (v338 < 3) {
    BOOL v343 = v334;
  }
  if (v329 == 1 && v341 == 1 && v342 && v343)
  {
    if (v441 >= 0.0)
    {
      int v344 = 97;
    }
    else if (v324)
    {
      int v344 = 102;
    }
    else
    {
      int v344 = 116;
    }
  }
  else
  {
    int v344 = 99;
    if (v329 == 2 && v341 == 2) {
      int v344 = 101;
    }
  }
  long long v345 = *(_OWORD *)&v568[112];
  if (v331 == 1) {
    int v346 = 0;
  }
  else {
    int v346 = -1;
  }
  if (v274 == 2) {
    int v346 = 1;
  }
  *(_OWORD *)(a1 + 96) = *(_OWORD *)&v568[96];
  *(_OWORD *)(a1 + 112) = v345;
  *(_OWORD *)(a1 + 128) = *(_OWORD *)&v568[128];
  *(void *)(a1 + 144) = *(void *)&v568[144];
  long long v347 = *(_OWORD *)&v568[48];
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v568[32];
  *(_OWORD *)(a1 + 48) = v347;
  long long v348 = *(_OWORD *)&v568[80];
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v568[64];
  *(_OWORD *)(a1 + 80) = v348;
  long long v349 = *(_OWORD *)&v568[16];
  *(_OWORD *)a1 = *(_OWORD *)v568;
  *(_OWORD *)(a1 + 16) = v349;
  *(_DWORD *)(a1 + 152) = v344 | ((v441 < 0.0) << 8);
  *(_OWORD *)(a1 + 156) = 0u;
  *(_OWORD *)(a1 + 172) = 0u;
  *(_DWORD *)(a1 + 188) = v324;
  *(_DWORD *)(a1 + 192) = v346;
}

double sub_1012461EC(uint64_t a1)
{
  *(void *)&v9[0] = 0;
  uint64_t v1 = 40;
  do
  {
    double v2 = (char *)v9 + v1;
    *(_OWORD *)double v2 = xmmword_1015E0D30;
    *((void *)v2 + 2) = 0;
    *((void *)v2 + 3) = 0;
    *((_OWORD *)v2 + 2) = xmmword_1015E0D40;
    v2[48] = 0;
    v1 += 56;
  }
  while (v2 + 56 != v11);
  memset(&v11[8], 0, 32);
  long long v3 = v9[7];
  *(_OWORD *)(a1 + 96) = v9[6];
  *(_OWORD *)(a1 + 112) = v3;
  *(_OWORD *)(a1 + 128) = v9[8];
  long long v4 = v9[3];
  *(_OWORD *)(a1 + 32) = v9[2];
  *(_OWORD *)(a1 + 48) = v4;
  long long v5 = v9[5];
  *(_OWORD *)(a1 + 64) = v9[4];
  *(_OWORD *)(a1 + 80) = v5;
  long long v6 = v9[1];
  *(_OWORD *)a1 = v9[0];
  *(_OWORD *)(a1 + 16) = v6;
  long long v7 = *(_OWORD *)&v11[22];
  *(_OWORD *)(a1 + 154) = *(_OWORD *)&v11[6];
  *(void *)&v11[40] = 0;
  *(void *)(a1 + 144) = v10;
  *(_WORD *)(a1 + 152) = 100;
  *(_OWORD *)(a1 + 170) = v7;
  double result = *(double *)&v11[32];
  *(_OWORD *)(a1 + 180) = *(_OWORD *)&v11[32];
  return result;
}

double sub_1012462D8(double *a1)
{
  double v1 = *a1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    double v8 = a1;
    int v7 = __cxa_guard_acquire(&qword_101B13360);
    a1 = v8;
    if (v7)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      a1 = v8;
    }
  }
  double v2 = *(double *)&qword_101B13358;
  double v3 = a1[1];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13360))
  {
    qword_101B13358 = 0x3F91DF46A2529D39;
    __cxa_guard_release(&qword_101B13360);
  }
  double v4 = v1 * v2;
  double cosval = __sincos_stret(v3 * *(double *)&qword_101B13358).__cosval;
  return __sincos_stret(v4).__cosval * cosval;
}

BOOL sub_1012463F4(double *a1, double *a2, double *a3, double *a4, double *a5, double *a6, double *a7, double *a8, double *a9, char a10)
{
  char v28 = 1;
  double v17 = 1.0 - sub_101246D58(a5, a4, a6, (BOOL *)&v28);
  *a9 = v17;
  if (!v28)
  {
    double v17 = -v17;
    *a9 = v17;
  }
  if (v17 <= -2.0)
  {
    double v17 = v17 + 4.0;
    *a9 = v17;
  }
  if (sub_101246BC4(a3, v17, *a1, a1[1])) {
    goto LABEL_6;
  }
  if (sub_101246BC4(a3, *a8 - *a9, *a2, a2[1]))
  {
    double v18 = *a8;
    goto LABEL_9;
  }
  if (a10)
  {
    char v29 = 1;
    double v20 = 1.0 - sub_101246D58(a5, a4, a7, (BOOL *)&v29);
    if (!v29) {
      double v20 = -v20;
    }
    double v21 = v20 + 4.0;
    if (v20 > -2.0) {
      double v21 = v20;
    }
    if (v21 == 0.0) {
      goto LABEL_6;
    }
    if ((*(void *)&v21 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      double v22 = fabs(v21);
      double v23 = 2.22044605e-16;
      if (v22 >= 1.0) {
        double v23 = v22 * 2.22044605e-16;
      }
      if (v22 <= v23)
      {
LABEL_6:
        *a9 = 0.0;
        return 1;
      }
    }
    double v18 = *a8;
    double v24 = *a8 - v21;
    if (v24 == 0.0) {
      goto LABEL_9;
    }
    if ((*(void *)&v24 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      double v25 = fabs(v24);
      double v26 = 2.22044605e-16;
      if (v25 >= 1.0) {
        double v26 = v25 * 2.22044605e-16;
      }
      if (v25 <= v26)
      {
LABEL_9:
        *a9 = v18;
        return 1;
      }
    }
  }
  else
  {
    double v18 = *a8;
  }
  double v27 = *a9;
  if (v18 < 0.0) {
    double v27 = -*a9;
  }
  if (v27 < 0.0) {
    return 0;
  }
  if (v18 < 0.0) {
    double v18 = -v18;
  }
  return v27 <= v18;
}

__n128 sub_1012465F4(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  memset(&v38[8], 0, 144);
  uint64_t v10 = 40;
  do
  {
    double v11 = &v38[v10];
    *(_OWORD *)double v11 = xmmword_1015E0D30;
    *((void *)v11 + 2) = 0;
    *((void *)v11 + 3) = 0;
    *((_OWORD *)v11 + 2) = xmmword_1015E0D40;
    unsigned char v11[48] = 0;
    v10 += 56;
  }
  while (v11 + 56 != (unsigned char *)&v39);
  *(void *)double v38 = 1;
  switch(*(_DWORD *)(a3 + 72))
  {
    case 0:
      long double v13 = *(double *)a3;
      long double v12 = *(double *)(a3 + 8);
      long double v14 = *(double *)(a3 + 16);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13380, memory_order_acquire) & 1) == 0)
      {
        double v36 = v13;
        double v32 = v12;
        int v33 = __cxa_guard_acquire(&qword_101B13380);
        long double v12 = v32;
        long double v13 = v36;
        if (v33)
        {
          qword_101B13378 = 0x404CA5DC1A63C1F8;
          __cxa_guard_release(&qword_101B13380);
          long double v12 = v32;
          long double v13 = v36;
        }
      }
      double v15 = *(double *)&qword_101B13378;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13380, memory_order_acquire) & 1) == 0)
      {
        double v35 = v12;
        double v37 = v13;
        int v34 = __cxa_guard_acquire(&qword_101B13380);
        long double v12 = v35;
        long double v13 = v37;
        if (v34)
        {
          qword_101B13378 = 0x404CA5DC1A63C1F8;
          __cxa_guard_release(&qword_101B13380);
          long double v12 = v35;
          long double v13 = v37;
        }
      }
      long double v16 = v15 * atan2(v12, v13);
      double v17 = asin(v14) * *(double *)&qword_101B13378;
      double v39 = v17;
      long double v40 = v16;
      sub_10123D770(&v40, &v39, 1);
      long double v18 = v40;
      break;
    case 1:
      long double v18 = *(double *)a4;
      double v17 = *(double *)(a4 + 8);
      break;
    case 2:
      long double v18 = *(double *)a5;
      double v17 = *(double *)(a5 + 8);
      break;
    case 3:
      long double v18 = *(double *)a6;
      double v17 = *(double *)(a6 + 8);
      break;
    default:
      long double v18 = *(double *)a7;
      double v17 = *(double *)(a7 + 8);
      break;
  }
  *(long double *)&v38[8] = v18;
  *(double *)&v38[16] = v17;
  v38[88] = 1;
  *(_OWORD *)&v38[40] = *(_OWORD *)(a3 + 24);
  *(void *)&v38[56] = *(void *)(a3 + 40);
  *(_OWORD *)&v38[64] = *(_OWORD *)(a3 + 48);
  *(void *)&v38[80] = *(void *)(a3 + 64);
  int v19 = *a2;
  int v20 = a2[2];
  int v21 = a2[3];
  if (!(*a2 | v20))
  {
    int v20 = -1;
    if (v21 == 1) {
      int v23 = -1;
    }
    else {
      int v23 = 1;
    }
    if (v21 == 1) {
      int v24 = 1;
    }
    else {
      int v24 = -1;
    }
    char v25 = 102;
    goto LABEL_33;
  }
  int v22 = a2[1];
  if (!(v22 | v21))
  {
    if (v20 == 1) {
      int v23 = -1;
    }
    else {
      int v23 = 1;
    }
    if (v20 == 1) {
      int v24 = 1;
    }
    else {
      int v24 = -1;
    }
    int v20 = 1;
    char v25 = 116;
    int v19 = 1;
    goto LABEL_51;
  }
  if (!(v22 | v20))
  {
    if (v21 == 1) {
      int v23 = 1;
    }
    else {
      int v23 = -1;
    }
    int v19 = -1;
    int v20 = 1;
    goto LABEL_49;
  }
  if (!(v19 | v21))
  {
    if (v20 == 1) {
      int v23 = 1;
    }
    else {
      int v23 = -1;
    }
    int v19 = 1;
    int v20 = -1;
LABEL_49:
    char v25 = 97;
    goto LABEL_50;
  }
  if (v20)
  {
    if (v19)
    {
      if (v21)
      {
        if (v22)
        {
          int v20 = -1;
          if (v21 == 1) {
            int v23 = -1;
          }
          else {
            int v23 = 1;
          }
          if (v21 == 1) {
            int v24 = 1;
          }
          else {
            int v24 = -1;
          }
          char v25 = 105;
LABEL_33:
          int v19 = -1;
          goto LABEL_51;
        }
        int v19 = 0;
        if (v21 == 1) {
          int v23 = 1;
        }
        else {
          int v23 = -1;
        }
        int v20 = 1;
      }
      else
      {
        int v20 = 0;
        if (v22 == 1) {
          int v23 = 1;
        }
        else {
          int v23 = -1;
        }
        int v19 = 1;
      }
      char v25 = 109;
LABEL_50:
      int v24 = v23;
      goto LABEL_51;
    }
    BOOL v31 = v21 == 1;
    int v20 = -1;
    if (v21 == 1) {
      int v23 = -1;
    }
    else {
      int v23 = 1;
    }
  }
  else
  {
    BOOL v31 = v21 == 1;
    int v19 = -1;
    if (v21 == 1) {
      int v23 = -1;
    }
    else {
      int v23 = 1;
    }
  }
  if (v31) {
    int v24 = a2[3];
  }
  else {
    int v24 = -1;
  }
  char v25 = 115;
LABEL_51:
  long long v26 = *(_OWORD *)&v38[112];
  *(_OWORD *)(a1 + 96) = *(_OWORD *)&v38[96];
  *(_OWORD *)(a1 + 112) = v26;
  *(_OWORD *)(a1 + 128) = *(_OWORD *)&v38[128];
  *(void *)(a1 + 144) = *(void *)&v38[144];
  long long v27 = *(_OWORD *)&v38[48];
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v38[32];
  *(_OWORD *)(a1 + 48) = v27;
  long long v28 = *(_OWORD *)&v38[80];
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v38[64];
  *(_OWORD *)(a1 + 80) = v28;
  long long v29 = *(_OWORD *)&v38[16];
  *(_OWORD *)a1 = *(_OWORD *)v38;
  *(_OWORD *)(a1 + 16) = v29;
  *(unsigned char *)(a1 + 152) = v25;
  *(unsigned char *)(a1 + 153) = 0;
  *(_DWORD *)(a1 + 156) = v20;
  *(_DWORD *)(a1 + 160) = v19;
  *(_DWORD *)(a1 + 164) = v23;
  *(_DWORD *)(a1 + 168) = v24;
  __n128 result = *(__n128 *)a2;
  *(_OWORD *)(a1 + 172) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 188) = v20;
  *(_DWORD *)(a1 + 192) = v19;
  return result;
}

void sub_101246990(uint64_t a1, uint64_t a2, double a3, double a4)
{
  unint64_t v8 = 0;
  uint64_t v9 = *(void *)a2;
  BOOL v10 = (*(void *)&a4 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
  double v11 = fabs(a4);
  while (1)
  {
    double v13 = *(double *)v9;
    double v12 = *(double *)(v9 + 8);
    double v25 = a4;
    double v26 = a3;
    sub_10123D770(&v26, &v25, 1);
    double v14 = v26;
    double v25 = v12;
    double v26 = v13;
    sub_10123D770(&v26, &v25, 1);
    if (v14 != v26)
    {
      if ((*(void *)&v14 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (*(void *)&v26 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        break;
      }
      double v16 = vabdd_f64(v14, v26);
      double v17 = fabs(v14);
      double v18 = fabs(v26);
      if (v17 >= v18) {
        double v18 = v17;
      }
      double v19 = v18 >= 1.0 ? v18 * 2.22044605e-16 : 2.22044605e-16;
      if (v16 > v19) {
        break;
      }
    }
    if (v12 != a4)
    {
      if (!v10 || (*(void *)&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        break;
      }
      double v20 = vabdd_f64(a4, v12);
      double v21 = fabs(v12);
      if (v11 >= v21) {
        double v21 = v11;
      }
      double v22 = v21 >= 1.0 ? v21 * 2.22044605e-16 : 2.22044605e-16;
      if (v20 > v22) {
        break;
      }
    }
    if (v8 >= *(void *)(*(void *)a1 + 88)) {
      break;
    }
    uint64_t v23 = *(void *)a2;
    uint64_t v9 = *(void *)a2 + 16;
    *(void *)a2 = v9;
    if (v9 == *(void *)(a2 + 16))
    {
      uint64_t v24 = *(void *)(a2 + 8);
      *(void *)a2 = v24;
      if (*(unsigned char *)(a2 + 24))
      {
        uint64_t v9 = v24 + 16;
        *(void *)a2 = v24 + 16;
        if (v23 == v24)
        {
          *(void *)a2 = v24;
          uint64_t v9 = v23;
        }
      }
      else
      {
        uint64_t v9 = v24;
      }
    }
    ++v8;
  }
}

double sub_101246B4C(double *a1, double *a2, double *a3, double *a4)
{
  char v6 = 1;
  double result = 1.0 - sub_101246D58(a2, a1, a3, (BOOL *)&v6);
  *a4 = result;
  if (!v6)
  {
    double result = -result;
    *a4 = result;
  }
  if (result <= -2.0)
  {
    double result = result + 4.0;
    *a4 = result;
  }
  return result;
}

BOOL sub_101246BC4(double *a1, double a2, double a3, double a4)
{
  double v5 = fabs(a2);
  if (v5 > 0.00000001) {
    return 0;
  }
  if (a2 == 0.0) {
    return 1;
  }
  if ((*(void *)&a2 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v8 = 2.22044605e-16;
    if (v5 >= 1.0) {
      double v8 = v5 * 2.22044605e-16;
    }
    if (v5 <= v8) {
      return 1;
    }
  }
  double v20 = a4;
  double v21 = a3;
  sub_10123D770(&v21, &v20, 1);
  double v9 = v21;
  double v10 = *a1;
  double v11 = a1[1];
  double v20 = v11;
  double v21 = v10;
  sub_10123D770(&v21, &v20, 1);
  if (v9 != v21)
  {
    if ((*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v21 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      return 0;
    }
    double v16 = vabdd_f64(v9, v21);
    double v17 = fabs(v9);
    double v18 = fabs(v21);
    if (v17 >= v18) {
      double v18 = v17;
    }
    double v19 = v18 >= 1.0 ? v18 * 2.22044605e-16 : 2.22044605e-16;
    if (v16 > v19) {
      return 0;
    }
  }
  if (v11 == a4) {
    return 1;
  }
  if ((*(void *)&a4 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (*(void *)&v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    return 0;
  }
  double v12 = vabdd_f64(a4, v11);
  double v13 = fabs(a4);
  double v14 = fabs(v11);
  if (v13 < v14) {
    double v13 = v14;
  }
  double v15 = v13 >= 1.0 ? v13 * 2.22044605e-16 : 2.22044605e-16;
  return v12 <= v15;
}

double sub_101246D58(double *a1, double *a2, double *a3, BOOL *a4)
{
  double v5 = a3[1];
  double v4 = a3[2];
  double v7 = a2[1];
  double v6 = a2[2];
  double v8 = *a3;
  double v9 = *a2;
  *a4 = (*a2 * v5 - v7 * *a3) * a1[2] + a1[1] * (v6 * *a3 - *a2 * v4) + *a1 * (v7 * v4 - v6 * v5) >= 0.0;
  return v4 * v6 + v7 * v5 + v9 * v8;
}

void *sub_101246DB0(void *a1, void *__src)
{
  double v4 = (char *)a1[1];
  double v5 = (char *)a1[2];
  uint64_t v6 = v5 - v4;
  if (v5 == v4) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 2 * (v5 - v4) - 1;
  }
  unint64_t v8 = a1[4];
  unint64_t v9 = a1[5] + v8;
  if (v7 == v9)
  {
    if (v8 < 0x10)
    {
      uint64_t v23 = v6 >> 3;
      uint64_t v24 = (char *)a1[3];
      double v25 = (char *)*a1;
      uint64_t v26 = (uint64_t)&v24[-*a1];
      if (v6 >> 3 >= (unint64_t)(v26 >> 3))
      {
        uint64_t v29 = v26 >> 2;
        if (v24 == v25) {
          unint64_t v30 = 1;
        }
        else {
          unint64_t v30 = v29;
        }
        BOOL v31 = (char *)sub_100048350(v30);
        uint64_t v33 = v32;
        int v34 = operator new(0x1780uLL);
        double v35 = &v31[8 * v23];
        double v36 = &v31[8 * v33];
        if (v23 == v33)
        {
          uint64_t v37 = 8 * v23;
          if (v6 < 1)
          {
            double v73 = v34;
            uint64_t v74 = v37 >> 2;
            if (v5 == v4) {
              unint64_t v75 = 1;
            }
            else {
              unint64_t v75 = v74;
            }
            double v76 = (char *)sub_100048350(v75);
            double v35 = &v76[8 * (v75 >> 2)];
            double v36 = &v76[8 * v77];
            if (v31) {
              operator delete(v31);
            }
            BOOL v31 = v76;
            int v34 = v73;
          }
          else
          {
            uint64_t v38 = v37 >> 3;
            if (v38 >= -1) {
              unint64_t v39 = v38 + 1;
            }
            else {
              unint64_t v39 = v38 + 2;
            }
            v35 -= 8 * (v39 >> 1);
          }
        }
        *(void *)double v35 = v34;
        int v78 = v35 + 8;
        for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
        {
          if (v35 == v31)
          {
            if (v78 >= v36)
            {
              if (v36 == v31) {
                unint64_t v84 = 1;
              }
              else {
                unint64_t v84 = (v36 - v31) >> 2;
              }
              double v85 = (char *)sub_100048350(v84);
              int v87 = v85;
              double v35 = &v85[(2 * v84 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v89 = v78 - v31;
              BOOL v88 = v78 == v31;
              int v78 = v35;
              if (!v88)
              {
                int v78 = &v35[v89 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v90 = 8 * (v89 >> 3);
                long long v91 = v35;
                long long v92 = (uint64_t *)v31;
                do
                {
                  uint64_t v93 = *v92++;
                  *(void *)long long v91 = v93;
                  v91 += 8;
                  v90 -= 8;
                }
                while (v90);
              }
              double v36 = &v85[8 * v86];
              if (v31) {
                operator delete(v31);
              }
              BOOL v31 = v87;
            }
            else
            {
              uint64_t v80 = (v36 - v78) >> 3;
              if (v80 >= -1) {
                uint64_t v81 = v80 + 1;
              }
              else {
                uint64_t v81 = v80 + 2;
              }
              uint64_t v82 = v81 >> 1;
              double v35 = &v31[8 * (v81 >> 1)];
              double v83 = v31;
              if (v78 != v31)
              {
                memmove(v35, v31, v78 - v31);
                double v83 = v78;
              }
              int v78 = &v83[8 * v82];
            }
          }
          uint64_t v94 = *(void *)(i - 8);
          *((void *)v35 - 1) = v94;
          v35 -= 8;
        }
        unint64_t v95 = (char *)*a1;
        *a1 = v31;
        a1[1] = v35;
        a1[2] = v78;
        a1[3] = v36;
        if (v95) {
          operator delete(v95);
        }
        goto LABEL_36;
      }
      long long v27 = operator new(0x1780uLL);
      long long v28 = v27;
      if (v24 == v5)
      {
        if (v4 == v25)
        {
          if (v5 == v4) {
            unint64_t v51 = 1;
          }
          else {
            unint64_t v51 = (v24 - v4) >> 2;
          }
          uint64_t v52 = 2 * v51;
          double v53 = (char *)sub_100048350(v51);
          double v4 = &v53[(v52 + 6) & 0xFFFFFFFFFFFFFFF8];
          double v55 = (uint64_t *)a1[1];
          double v56 = v4;
          uint64_t v57 = a1[2] - (void)v55;
          if (v57)
          {
            double v56 = &v4[v57 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v58 = 8 * (v57 >> 3);
            double v59 = &v53[(v52 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              uint64_t v60 = *v55++;
              *(void *)double v59 = v60;
              v59 += 8;
              v58 -= 8;
            }
            while (v58);
          }
          double v61 = (char *)*a1;
          *a1 = v53;
          a1[1] = v4;
          a1[2] = v56;
          a1[3] = &v53[8 * v54];
          if (v61)
          {
            operator delete(v61);
            double v4 = (char *)a1[1];
          }
        }
        *((void *)v4 - 1) = v28;
        double v62 = (char *)a1[1];
        double v63 = (char *)a1[2];
        a1[1] = v62 - 8;
        uint64_t v64 = *((void *)v62 - 1);
        a1[1] = v62;
        if (v63 == (char *)a1[3])
        {
          uint64_t v65 = (uint64_t)&v62[-*a1];
          if ((unint64_t)v62 <= *a1)
          {
            if (v63 == (char *)*a1) {
              unint64_t v96 = 1;
            }
            else {
              unint64_t v96 = (uint64_t)&v63[-*a1] >> 2;
            }
            BOOL v97 = (char *)sub_100048350(v96);
            double v99 = &v97[8 * (v96 >> 2)];
            double v100 = (uint64_t *)a1[1];
            double v63 = v99;
            uint64_t v101 = a1[2] - (void)v100;
            if (v101)
            {
              double v63 = &v99[v101 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v102 = 8 * (v101 >> 3);
              uint64_t v103 = &v97[8 * (v96 >> 2)];
              do
              {
                uint64_t v104 = *v100++;
                *(void *)uint64_t v103 = v104;
                v103 += 8;
                v102 -= 8;
              }
              while (v102);
            }
            double v105 = (char *)*a1;
            *a1 = v97;
            a1[1] = v99;
            a1[2] = v63;
            a1[3] = &v97[8 * v98];
            if (v105)
            {
              operator delete(v105);
              double v63 = (char *)a1[2];
            }
          }
          else
          {
            uint64_t v66 = v65 >> 3;
            BOOL v15 = v65 >> 3 < -1;
            uint64_t v67 = (v65 >> 3) + 2;
            if (v15) {
              uint64_t v68 = v67;
            }
            else {
              uint64_t v68 = v66 + 1;
            }
            uint64_t v69 = -(v68 >> 1);
            uint64_t v70 = v68 >> 1;
            char v71 = &v62[-8 * v70];
            int64_t v72 = v63 - v62;
            if (v63 != v62)
            {
              memmove(&v62[-8 * v70], v62, v63 - v62);
              double v62 = (char *)a1[1];
            }
            double v63 = &v71[v72];
            a1[1] = &v62[8 * v69];
            a1[2] = &v71[v72];
          }
        }
        *(void *)double v63 = v64;
      }
      else
      {
        *(void *)double v5 = v27;
      }
    }
    else
    {
      a1[4] = v8 - 16;
      uint64_t v12 = *(void *)v4;
      double v10 = v4 + 8;
      uint64_t v11 = v12;
      a1[1] = v10;
      if (v5 == (char *)a1[3])
      {
        uint64_t v13 = (uint64_t)&v10[-*a1];
        if ((unint64_t)v10 <= *a1)
        {
          if (v5 == (char *)*a1) {
            unint64_t v40 = 1;
          }
          else {
            unint64_t v40 = (uint64_t)&v5[-*a1] >> 2;
          }
          double v41 = (char *)sub_100048350(v40);
          double v43 = &v41[8 * (v40 >> 2)];
          BOOL v44 = (uint64_t *)a1[1];
          double v5 = v43;
          uint64_t v45 = a1[2] - (void)v44;
          if (v45)
          {
            double v5 = &v43[v45 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v46 = 8 * (v45 >> 3);
            double v47 = &v41[8 * (v40 >> 2)];
            do
            {
              uint64_t v48 = *v44++;
              *(void *)double v47 = v48;
              v47 += 8;
              v46 -= 8;
            }
            while (v46);
          }
          double v49 = (char *)*a1;
          *a1 = v41;
          a1[1] = v43;
          a1[2] = v5;
          a1[3] = &v41[8 * v42];
          if (v49)
          {
            operator delete(v49);
            double v5 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v14 = v13 >> 3;
          BOOL v15 = v13 >> 3 < -1;
          uint64_t v16 = (v13 >> 3) + 2;
          if (v15) {
            uint64_t v17 = v16;
          }
          else {
            uint64_t v17 = v14 + 1;
          }
          uint64_t v18 = -(v17 >> 1);
          uint64_t v19 = v17 >> 1;
          double v20 = &v10[-8 * v19];
          int64_t v21 = v5 - v10;
          if (v5 != v10)
          {
            memmove(&v10[-8 * v19], v10, v5 - v10);
            double v5 = (char *)a1[1];
          }
          double v22 = &v5[8 * v18];
          double v5 = &v20[v21];
          a1[1] = v22;
          a1[2] = &v20[v21];
        }
      }
      *(void *)double v5 = v11;
    }
    a1[2] += 8;
LABEL_36:
    double v4 = (char *)a1[1];
    unint64_t v9 = a1[5] + a1[4];
  }
  double result = memcpy((void *)(*(void *)&v4[(v9 >> 1) & 0x7FFFFFFFFFFFFFF8] + 376 * (v9 & 0xF)), __src, 0x178uLL);
  ++a1[5];
  return result;
}

void sub_101247284(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1012472B0(double *a1, double *a2, double *a3)
{
  double v3 = *a1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    uint64_t v38 = a1;
    unint64_t v40 = a2;
    uint64_t v45 = a3;
    int v28 = __cxa_guard_acquire(&qword_101B13360);
    a2 = v40;
    a3 = v45;
    int v29 = v28;
    a1 = v38;
    if (v29)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      a1 = v38;
      a2 = v40;
      a3 = v45;
    }
  }
  double v4 = *(double *)&qword_101B13358;
  double v5 = a1[1];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    double v41 = a2;
    uint64_t v46 = a3;
    int v30 = __cxa_guard_acquire(&qword_101B13360);
    a2 = v41;
    a3 = v46;
    if (v30)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      a2 = v41;
      a3 = v46;
    }
  }
  double v6 = *(double *)&qword_101B13358;
  double v7 = *a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    uint64_t v42 = a2;
    double v47 = a3;
    int v31 = __cxa_guard_acquire(&qword_101B13360);
    a2 = v42;
    a3 = v47;
    if (v31)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      a2 = v42;
      a3 = v47;
    }
  }
  double v8 = *(double *)&qword_101B13358;
  double v9 = a2[1];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    uint64_t v48 = a3;
    double v32 = v8;
    int v33 = __cxa_guard_acquire(&qword_101B13360);
    double v8 = v32;
    a3 = v48;
    if (v33)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      double v8 = v32;
      a3 = v48;
    }
  }
  double v10 = *(double *)&qword_101B13358;
  double v11 = *a3;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    double v49 = a3;
    double v34 = v8;
    double v39 = v10;
    double v43 = v11;
    int v35 = __cxa_guard_acquire(&qword_101B13360);
    double v10 = v39;
    double v11 = v43;
    double v8 = v34;
    a3 = v49;
    if (v35)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      double v10 = v39;
      double v11 = v43;
      double v8 = v34;
      a3 = v49;
    }
  }
  double v12 = v3 * v4;
  double v13 = v5 * v6;
  double v14 = v7 * v8;
  double v15 = v9 * v10;
  double v44 = v11 * *(double *)&qword_101B13358;
  double v16 = a3[1];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13360, memory_order_acquire) & 1) == 0)
  {
    double v36 = v5 * v6;
    int v37 = __cxa_guard_acquire(&qword_101B13360);
    double v13 = v36;
    if (v37)
    {
      qword_101B13358 = 0x3F91DF46A2529D39;
      __cxa_guard_release(&qword_101B13360);
      double v13 = v36;
    }
  }
  double v17 = v16 * *(double *)&qword_101B13358;
  __double2 v18 = __sincos_stret(v13);
  __double2 v19 = __sincos_stret(v12);
  __double2 v20 = __sincos_stret(v15);
  __double2 v21 = __sincos_stret(v14);
  __double2 v22 = __sincos_stret(v17);
  __double2 v23 = __sincos_stret(v44);
  double v24 = v23.__sinval
      * ((v18.__sinval * (v21.__cosval * v20.__cosval) - v19.__cosval * v18.__cosval * v20.__sinval)
       * v22.__cosval)
      + (v19.__sinval * v18.__cosval * v20.__sinval - v18.__sinval * (v21.__sinval * v20.__cosval))
      * v22.__cosval
      * v23.__cosval
      + (v19.__cosval * v18.__cosval * (v21.__sinval * v20.__cosval)
       - v19.__sinval * v18.__cosval * (v21.__cosval * v20.__cosval))
      * v22.__sinval;
  if (v24 == 0.0) {
    return 0;
  }
  if (COERCE_UNSIGNED_INT64(fabs(v23.__sinval* ((v18.__sinval * (v21.__cosval * v20.__cosval) - v19.__cosval * v18.__cosval * v20.__sinval)* v22.__cosval)+ (v19.__sinval * v18.__cosval * v20.__sinval - v18.__sinval * (v21.__sinval * v20.__cosval))* v22.__cosval* v23.__cosval+ (v19.__cosval * v18.__cosval * (v21.__sinval * v20.__cosval)- v19.__sinval * v18.__cosval * (v21.__cosval * v20.__cosval))* v22.__sinval)) >= 0x7FF0000000000000)
  {
    if (v24 > 0.0) {
      return 1;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    double v26 = fabs(v24);
    double v27 = 2.22044605e-16;
    if (v26 >= 1.0) {
      double v27 = v26 * 2.22044605e-16;
    }
    if (v24 > 0.0) {
      uint64_t result = 1;
    }
    else {
      uint64_t result = 0xFFFFFFFFLL;
    }
    if (v26 <= v27) {
      return 0;
    }
  }
  return result;
}

void sub_101247670(uint64_t *a1, uint64_t a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  if (0xEEEEEEEEEEEEEEEFLL * ((v4 - *a1) >> 3) <= 0x10)
  {
    while (v5 != v4)
    {
      uint64_t v16 = v5;
      v5 += 120;
      if (v5 != v4)
      {
        uint64_t v4 = v5;
        do
        {
          sub_101247C4C(a2, v16, v4);
          v4 += 120;
        }
        while (v4 != a1[1]);
      }
    }
  }
  else
  {
    long long __p = 0;
    __double2 v19 = 0;
    unint64_t v20 = 0;
    v17[0] = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    v17[1] = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    if (v5 != v4)
    {
      double v6 = 0;
      do
      {
        sub_101240044((double *)v17, (double *)(v5 + 32));
        if ((unint64_t)v6 >= v20)
        {
          double v8 = (char *)__p;
          uint64_t v9 = (v6 - (unsigned char *)__p) >> 3;
          unint64_t v10 = v9 + 1;
          if ((unint64_t)(v9 + 1) >> 61) {
            sub_10006A748();
          }
          uint64_t v11 = v20 - (void)__p;
          if ((uint64_t)(v20 - (void)__p) >> 2 > v10) {
            unint64_t v10 = v11 >> 2;
          }
          if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v12 = v10;
          }
          if (v12) {
            unint64_t v12 = (unint64_t)sub_100048350(v12);
          }
          else {
            uint64_t v13 = 0;
          }
          double v14 = (uint64_t *)(v12 + 8 * v9);
          *double v14 = v5;
          double v7 = (char *)(v14 + 1);
          if (v6 != v8)
          {
            do
            {
              uint64_t v15 = *((void *)v6 - 1);
              v6 -= 8;
              *--double v14 = v15;
            }
            while (v6 != v8);
            double v6 = (char *)__p;
          }
          long long __p = v14;
          unint64_t v20 = v12 + 8 * v13;
          if (v6) {
            operator delete(v6);
          }
        }
        else
        {
          *(void *)double v6 = v5;
          double v7 = v6 + 8;
        }
        __double2 v19 = v7;
        v5 += 120;
        double v6 = v7;
      }
      while (v5 != a1[1]);
    }
    sub_101247844((double *)v17, (uint64_t **)&__p, 0, a2);
    if (__p) {
      operator delete(__p);
    }
  }
}

void sub_101247828(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101247844(double *a1, uint64_t **a2, unint64_t a3, uint64_t a4)
{
  double v6 = (*a1 + a1[2]) * 0.5;
  long long v7 = *((_OWORD *)a1 + 1);
  long long v48 = *(_OWORD *)a1;
  uint64_t v50 = *((void *)&v7 + 1);
  v46[1] = *((double *)&v48 + 1);
  long long v47 = v7;
  double v49 = v6;
  v46[0] = v6;
  double v43 = 0;
  double v44 = 0;
  uint64_t v45 = 0;
  unint64_t v40 = 0;
  double v41 = 0;
  uint64_t v42 = 0;
  int v37 = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  sub_101240254((double *)&v48, v46, a2, (void **)&v43, (void **)&v40, (void **)&v37);
  double v8 = v37;
  uint64_t v9 = v38;
  if (v37 != v38)
  {
    int64x2_t v51 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    int64x2_t v52 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    unint64_t v10 = v37;
    do
      sub_101240044((double *)v51.i64, (double *)(*v10++ + 32));
    while (v10 != v9);
    v36[0] = v51;
    v36[1] = v52;
    unint64_t v11 = (char *)v9 - (char *)v8;
    unint64_t v12 = v8;
    if (a3 > 0x63 || (unint64_t v12 = v8, v11 <= 0x78))
    {
      do
      {
        double v14 = v12 + 1;
        if (v12 + 1 == v9) {
          break;
        }
        uint64_t v13 = v12 + 1;
        do
          sub_101247C4C(a4, *v12, *v13++);
        while (v13 != v9);
        ++v12;
      }
      while (v14 != v9);
    }
    else
    {
      sub_101247E88((double *)v36, &v37, a3 + 1, a4);
    }
    if (v11 < 0x80 || a3 > 0x63 || (unint64_t)((char *)v44 - (char *)v43) < 0x79)
    {
      uint64_t v15 = v43;
      uint64_t v16 = v44;
      if (v43 != v44)
      {
        double v17 = v44;
        __double2 v18 = v8;
        do
        {
          BOOL v19 = v15 == v17;
          double v17 = v15;
          if (!v19)
          {
            unint64_t v20 = v15;
            do
              sub_101247C4C(a4, *v18, *v20++);
            while (v20 != v16);
            double v17 = v16;
          }
          ++v18;
        }
        while (v18 != v9);
      }
    }
    else
    {
      sub_101248960((double *)v36, &v37, &v43, a3 + 1, a4);
    }
    if (v11 < 0x80 || a3 > 0x63 || (unint64_t)((char *)v41 - (char *)v40) < 0x79)
    {
      if (v8 != v9)
      {
        __double2 v21 = v40;
        __double2 v22 = v41;
        if (v40 != v41)
        {
          __double2 v23 = v41;
          double v24 = v8;
          do
          {
            BOOL v19 = v21 == v23;
            __double2 v23 = v21;
            if (!v19)
            {
              double v25 = v21;
              do
                sub_101247C4C(a4, *v24, *v25++);
              while (v25 != v22);
              __double2 v23 = v22;
            }
            ++v24;
          }
          while (v24 != v9);
        }
      }
    }
    else
    {
      sub_101248960((double *)v36, &v37, &v40, a3 + 1, a4);
    }
  }
  double v26 = v43;
  double v27 = v44;
  if (a3 > 0x63 || (unint64_t)((char *)v44 - (char *)v43) < 0x79)
  {
    if (v43 != v44)
    {
      int v28 = v43;
      do
      {
        int v29 = v28 + 1;
        if (v28 + 1 == v27) {
          break;
        }
        int v30 = v28 + 1;
        do
          sub_101247C4C(a4, *v28, *v30++);
        while (v30 != v27);
        ++v28;
      }
      while (v29 != v27);
    }
  }
  else
  {
    sub_101247E88((double *)&v48, &v43, a3 + 1, a4);
  }
  int v31 = v40;
  double v32 = v41;
  if (a3 > 0x63 || (unint64_t)((char *)v41 - (char *)v40) < 0x79)
  {
    if (v40 != v41)
    {
      int v33 = v40;
      do
      {
        double v34 = v33 + 1;
        if (v33 + 1 == v32) {
          break;
        }
        int v35 = v33 + 1;
        do
          sub_101247C4C(a4, *v33, *v35++);
        while (v35 != v32);
        ++v33;
      }
      while (v34 != v32);
    }
  }
  else
  {
    sub_101247E88(v46, &v40, a3 + 1, a4);
  }
  if (v8) {
    operator delete(v8);
  }
  if (v31) {
    operator delete(v31);
  }
  if (v26)
  {
    operator delete(v26);
  }
}

void sub_101247BF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20)
{
  if (v20) {
    operator delete(v20);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_101247C4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v6 = *(double *)(a2 + 32);
  double v7 = *(double *)(a2 + 48);
  if (v7 - v6 >= 360.0 || (double v8 = *(double *)(a3 + 32), v9 = *(double *)(a3 + 48), v10 = v9 - v8, v9 - v8 >= 360.0))
  {
LABEL_11:
    if (*(double *)(a2 + 56) >= *(double *)(a3 + 40)
      && *(double *)(a2 + 40) <= *(double *)(a3 + 56)
      && !(*(unsigned __int8 *)(a2 + 96) | *(unsigned __int8 *)(a3 + 96)))
    {
      sub_101240F1C(*(_DWORD *)(a1 + 40), *(double ***)a1, a2, *(_DWORD *)(a1 + 40), *(double ***)a1, a3, *(unsigned __int8 *)(a1 + 44), *(void *)(a1 + 8), *(void *)(a1 + 16), *(void **)(a1 + 24));
    }
    return;
  }
  double v11 = vabdd_f64(v8, v6);
  double v12 = 180.0;
  if (v11 == 180.0) {
    goto LABEL_4;
  }
  double v13 = v8 - v6;
  if ((*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v16 = fabs(v11 + -180.0);
    double v12 = 180.0;
    if (v11 < 180.0) {
      double v11 = 180.0;
    }
    double v17 = v11 >= 1.0 ? v11 * 2.22044605e-16 : 2.22044605e-16;
    if (v16 <= v17) {
      goto LABEL_4;
    }
  }
  double v12 = 180.0;
  if (v13 <= 180.0)
  {
    if (v13 >= -180.0) {
      goto LABEL_5;
    }
    double v12 = fmod(v13 + -180.0, 360.0) + 180.0;
LABEL_4:
    double v13 = v12;
    goto LABEL_5;
  }
  double v13 = fmod(v13 + 180.0, 360.0) + -180.0;
  if (v13 == -180.0) {
    goto LABEL_4;
  }
  BOOL v18 = ((*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
     && (*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
  if (!v18 || *(void *)&v13 == 0)
  {
    double v12 = 180.0;
    double v20 = fabs(v13 + 180.0);
    double v21 = fabs(v13);
    if (v21 < 180.0) {
      double v21 = 180.0;
    }
    double v22 = v21 >= 1.0 ? v21 * 2.22044605e-16 : 2.22044605e-16;
    if (v20 <= v22) {
      goto LABEL_4;
    }
  }
LABEL_5:
  if (v13 < 0.0) {
    double v13 = v13 + 360.0;
  }
  double v14 = v6 + v13;
  double v15 = v10 + v6 + v13 + -360.0;
  if (vabdd_f64(v15, v9) < 180.0) {
    double v15 = v9;
  }
  if (v14 <= v7 || v15 >= v6) {
    goto LABEL_11;
  }
}

void sub_101247E88(double *a1, uint64_t **a2, unint64_t a3, uint64_t a4)
{
  double v6 = (a1[1] + a1[3]) * 0.5;
  uint64_t v50 = *((void *)a1 + 2);
  long long v7 = *(_OWORD *)a1;
  long long v8 = *((_OWORD *)a1 + 1);
  v47[0] = *a1;
  long long v48 = v8;
  long long v49 = v7;
  double v51 = v6;
  v47[1] = v6;
  double v44 = 0;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  double v41 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  sub_101240254((double *)&v49, v47, a2, (void **)&v44, (void **)&v41, (void **)&v38);
  double v9 = v38;
  double v10 = v39;
  if (v38 != v39)
  {
    int64x2_t v52 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    int64x2_t v53 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    double v11 = v38;
    do
      sub_101240044((double *)v52.i64, (double *)(*v11++ + 32));
    while (v11 != v10);
    v37[0] = v52;
    v37[1] = v53;
    unint64_t v12 = (char *)v10 - (char *)v9;
    double v13 = v9;
    if (a3 > 0x63 || (double v13 = v9, v12 <= 0x78))
    {
      do
      {
        double v15 = v13 + 1;
        if (v13 + 1 == v10) {
          break;
        }
        double v14 = v13 + 1;
        do
          sub_101247C4C(a4, *v13, *v14++);
        while (v14 != v10);
        ++v13;
      }
      while (v15 != v10);
    }
    else
    {
      sub_101247844(v37, &v38, a3 + 1, a4);
    }
    if (v12 < 0x80 || a3 > 0x63 || (unint64_t)((char *)v45 - (char *)v44) < 0x79)
    {
      double v16 = v44;
      double v17 = v45;
      if (v44 != v45)
      {
        BOOL v18 = v45;
        BOOL v19 = v9;
        do
        {
          BOOL v20 = v16 == v18;
          BOOL v18 = v16;
          if (!v20)
          {
            double v21 = v16;
            do
              sub_101247C4C(a4, *v19, *v21++);
            while (v21 != v17);
            BOOL v18 = v17;
          }
          ++v19;
        }
        while (v19 != v10);
      }
    }
    else
    {
      sub_101248298((double *)v37, &v38, &v44, a3 + 1, a4);
    }
    if (v12 < 0x80 || a3 > 0x63 || (unint64_t)((char *)v42 - (char *)v41) < 0x79)
    {
      if (v9 != v10)
      {
        double v22 = v41;
        __double2 v23 = v42;
        if (v41 != v42)
        {
          double v24 = v42;
          double v25 = v9;
          do
          {
            BOOL v20 = v22 == v24;
            double v24 = v22;
            if (!v20)
            {
              double v26 = v22;
              do
                sub_101247C4C(a4, *v25, *v26++);
              while (v26 != v23);
              double v24 = v23;
            }
            ++v25;
          }
          while (v25 != v10);
        }
      }
    }
    else
    {
      sub_101248298((double *)v37, &v38, &v41, a3 + 1, a4);
    }
  }
  double v27 = v44;
  int v28 = v45;
  if (a3 > 0x63 || (unint64_t)((char *)v45 - (char *)v44) < 0x79)
  {
    if (v44 != v45)
    {
      int v29 = v44;
      do
      {
        int v30 = v29 + 1;
        if (v29 + 1 == v28) {
          break;
        }
        int v31 = v29 + 1;
        do
          sub_101247C4C(a4, *v29, *v31++);
        while (v31 != v28);
        ++v29;
      }
      while (v30 != v28);
    }
  }
  else
  {
    sub_101247844(&v49, &v44, a3 + 1, a4);
  }
  double v32 = v41;
  int v33 = v42;
  if (a3 > 0x63 || (unint64_t)((char *)v42 - (char *)v41) < 0x79)
  {
    if (v41 != v42)
    {
      double v34 = v41;
      do
      {
        int v35 = v34 + 1;
        if (v34 + 1 == v33) {
          break;
        }
        double v36 = v34 + 1;
        do
          sub_101247C4C(a4, *v34, *v36++);
        while (v36 != v33);
        ++v34;
      }
      while (v35 != v33);
    }
  }
  else
  {
    sub_101247844(v47, &v41, a3 + 1, a4);
  }
  if (v9) {
    operator delete(v9);
  }
  if (v32) {
    operator delete(v32);
  }
  if (v27)
  {
    operator delete(v27);
  }
}

void sub_101248244(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20)
{
  if (v20) {
    operator delete(v20);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_101248298(double *a1, uint64_t **a2, uint64_t **a3, unint64_t a4, uint64_t a5)
{
  double v8 = (*a1 + a1[2]) * 0.5;
  long long v9 = *((_OWORD *)a1 + 1);
  long long v81 = *(_OWORD *)a1;
  uint64_t v83 = *((void *)&v9 + 1);
  v79[1] = *((double *)&v81 + 1);
  long long v80 = v9;
  double v82 = v8;
  v79[0] = v8;
  double v76 = 0;
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  double v73 = 0;
  uint64_t v74 = 0;
  uint64_t v75 = 0;
  uint64_t v70 = 0;
  char v71 = 0;
  uint64_t v72 = 0;
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  long long __p = 0;
  uint64_t v65 = 0;
  uint64_t v66 = 0;
  double v61 = 0;
  double v62 = 0;
  uint64_t v63 = 0;
  sub_101240254((double *)&v81, v79, a2, (void **)&v76, (void **)&v73, (void **)&v70);
  sub_101240254((double *)&v81, v79, a3, &v67, &__p, (void **)&v61);
  double v11 = v70;
  double v10 = v71;
  unint64_t v12 = v61;
  uint64_t v58 = v70;
  if (v70 == v71)
  {
    double v14 = v62;
  }
  else
  {
    unint64_t v13 = (char *)v71 - (char *)v70;
    double v14 = v62;
    if ((unint64_t)((char *)v71 - (char *)v70) < 0x80
      || a4 > 0x63
      || (unint64_t)((char *)v62 - (char *)v61) < 0x79)
    {
      if (v61 != v62)
      {
        double v15 = v62;
        double v16 = v70;
        do
        {
          BOOL v42 = v12 == v15;
          double v15 = v12;
          if (!v42)
          {
            double v17 = v12;
            do
              sub_101247C4C(a5, *v16, *v17++);
            while (v17 != v14);
            double v15 = v14;
          }
          ++v16;
        }
        while (v16 != v10);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      do
        sub_101240044((double *)v84.i64, (double *)(*v11++ + 32));
      while (v11 != v10);
      uint64_t v19 = v84.i64[1];
      uint64_t v18 = v84.i64[0];
      uint64_t v21 = v85.i64[1];
      uint64_t v20 = v85.i64[0];
      if (v12 != v14)
      {
        double v22 = v12;
        do
          sub_101240044((double *)v84.i64, (double *)(*v22++ + 32));
        while (v22 != v14);
        uint64_t v19 = v84.i64[1];
        uint64_t v18 = v84.i64[0];
        uint64_t v21 = v85.i64[1];
        uint64_t v20 = v85.i64[0];
      }
      v59.i64[0] = v18;
      v59.i64[1] = v19;
      v60.i64[0] = v20;
      v60.i64[1] = v21;
      sub_101248960((double *)v59.i64, &v70, &v61, a4 + 1, a5);
    }
    double v24 = (uint64_t *)v67;
    __double2 v23 = v68;
    if ((unint64_t)((char *)v68 - (unsigned char *)v67) < 0x80
      || (unint64_t)((char *)v65 - (unsigned char *)__p) < 0x80
      || a4 > 0x63
      || v13 < 0x79)
    {
      if (v67 != v68)
      {
        double v25 = v68;
        double v26 = v58;
        do
        {
          BOOL v42 = v24 == v25;
          double v25 = v24;
          if (!v42)
          {
            double v27 = v24;
            do
              sub_101247C4C(a5, *v26, *v27++);
            while (v27 != v23);
            double v25 = v23;
          }
          ++v26;
        }
        while (v26 != v10);
      }
      int v28 = (uint64_t *)__p;
      int v29 = v65;
      if (__p != v65)
      {
        int v30 = v65;
        int v31 = v58;
        do
        {
          BOOL v42 = v28 == v30;
          int v30 = v28;
          if (!v42)
          {
            double v32 = v28;
            do
              sub_101247C4C(a5, *v31, *v32++);
            while (v32 != v29);
            int v30 = v29;
          }
          ++v31;
        }
        while (v31 != v10);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      uint64_t v57 = v58;
      do
        sub_101240044((double *)v84.i64, (double *)(*v57++ + 32));
      while (v57 != v10);
      int64x2_t v59 = v84;
      int64x2_t v60 = v85;
      sub_101248960((double *)v59.i64, &v70, (uint64_t **)&v67, a4 + 1, a5);
      sub_101248960((double *)v59.i64, &v70, (uint64_t **)&__p, a4 + 1, a5);
    }
  }
  int v33 = v76;
  double v34 = v77;
  unint64_t v35 = (char *)v77 - (char *)v76;
  if (v12 != v14)
  {
    if (v35 < 0x80
      || (unint64_t)((char *)v74 - (char *)v73) < 0x80
      || a4 > 0x63
      || (unint64_t)((char *)v14 - (char *)v12) < 0x79)
    {
      if (v76 != v77)
      {
        int v37 = v14;
        uint64_t v38 = v76;
        do
        {
          BOOL v42 = v12 == v37;
          int v37 = v12;
          if (!v42)
          {
            uint64_t v39 = v12;
            do
              sub_101247C4C(a5, *v38, *v39++);
            while (v39 != v14);
            int v37 = v14;
          }
          ++v38;
        }
        while (v38 != v34);
      }
      uint64_t v40 = v73;
      double v41 = v74;
      BOOL v42 = v73 == v74 || v12 == v14;
      if (!v42)
      {
        uint64_t v43 = v14;
        do
        {
          BOOL v42 = v12 == v43;
          uint64_t v43 = v12;
          if (!v42)
          {
            double v44 = v12;
            do
              sub_101247C4C(a5, *v40, *v44++);
            while (v44 != v14);
            uint64_t v43 = v14;
          }
          ++v40;
        }
        while (v40 != v41);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      double v36 = v12;
      do
        sub_101240044((double *)v84.i64, (double *)(*v36++ + 32));
      while (v36 != v14);
      int64x2_t v59 = v84;
      int64x2_t v60 = v85;
      sub_101248960((double *)v59.i64, &v76, &v61, a4 + 1, a5);
      sub_101248960((double *)v59.i64, &v73, &v61, a4 + 1, a5);
    }
  }
  if (v35 < 0x80 || a4 > 0x63 || (unint64_t)((char *)v68 - (unsigned char *)v67) < 0x79)
  {
    if (v33 != v34)
    {
      uint64_t v45 = (uint64_t *)v67;
      uint64_t v46 = v68;
      if (v67 != v68)
      {
        long long v47 = v68;
        long long v48 = v33;
        do
        {
          BOOL v42 = v45 == v47;
          long long v47 = v45;
          if (!v42)
          {
            long long v49 = v45;
            do
              sub_101247C4C(a5, *v48, *v49++);
            while (v49 != v46);
            long long v47 = v46;
          }
          ++v48;
        }
        while (v48 != v34);
      }
    }
  }
  else
  {
    sub_101248960((double *)&v81, &v76, (uint64_t **)&v67, a4 + 1, a5);
  }
  uint64_t v50 = v73;
  double v51 = v74;
  if ((unint64_t)((char *)v74 - (char *)v73) < 0x80
    || a4 > 0x63
    || (unint64_t)((char *)v65 - (unsigned char *)__p) < 0x79)
  {
    if (v73 != v74)
    {
      int64x2_t v52 = (uint64_t *)__p;
      int64x2_t v53 = v65;
      if (__p != v65)
      {
        uint64_t v54 = v65;
        double v55 = v73;
        do
        {
          BOOL v42 = v52 == v54;
          uint64_t v54 = v52;
          if (!v42)
          {
            double v56 = v52;
            do
              sub_101247C4C(a5, *v55, *v56++);
            while (v56 != v53);
            uint64_t v54 = v53;
          }
          ++v55;
        }
        while (v55 != v51);
      }
    }
  }
  else
  {
    sub_101248960(v79, &v73, (uint64_t **)&__p, a4 + 1, a5);
  }
  if (v12) {
    operator delete(v12);
  }
  if (__p) {
    operator delete(__p);
  }
  if (v67) {
    operator delete(v67);
  }
  if (v58) {
    operator delete(v58);
  }
  if (v50) {
    operator delete(v50);
  }
  if (v33)
  {
    operator delete(v33);
  }
}

void sub_1012488CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30)
{
  if (v30) {
    operator delete(v30);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a24) {
    operator delete(a24);
  }
  if (a27) {
    operator delete(a27);
  }
  if (a30) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

void sub_101248960(double *a1, uint64_t **a2, uint64_t **a3, unint64_t a4, uint64_t a5)
{
  double v8 = a1[1] + a1[3];
  long long v81 = *(_OWORD *)a1;
  uint64_t v82 = *((void *)a1 + 2);
  long long v9 = *((_OWORD *)a1 + 1);
  *(void *)&v79[0] = v81;
  long long v80 = v9;
  double v83 = v8 * 0.5;
  v79[1] = v8 * 0.5;
  double v76 = 0;
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  double v73 = 0;
  uint64_t v74 = 0;
  uint64_t v75 = 0;
  uint64_t v70 = 0;
  char v71 = 0;
  uint64_t v72 = 0;
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  long long __p = 0;
  uint64_t v65 = 0;
  uint64_t v66 = 0;
  double v61 = 0;
  double v62 = 0;
  uint64_t v63 = 0;
  sub_101240254((double *)&v81, v79, a2, (void **)&v76, (void **)&v73, (void **)&v70);
  sub_101240254((double *)&v81, v79, a3, &v67, &__p, (void **)&v61);
  double v11 = v70;
  double v10 = v71;
  unint64_t v12 = v61;
  uint64_t v58 = v70;
  if (v70 == v71)
  {
    double v14 = v62;
  }
  else
  {
    unint64_t v13 = (char *)v71 - (char *)v70;
    double v14 = v62;
    if ((unint64_t)((char *)v71 - (char *)v70) < 0x80
      || a4 > 0x63
      || (unint64_t)((char *)v62 - (char *)v61) < 0x79)
    {
      if (v61 != v62)
      {
        double v15 = v62;
        double v16 = v70;
        do
        {
          BOOL v42 = v12 == v15;
          double v15 = v12;
          if (!v42)
          {
            double v17 = v12;
            do
              sub_101247C4C(a5, *v16, *v17++);
            while (v17 != v14);
            double v15 = v14;
          }
          ++v16;
        }
        while (v16 != v10);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      do
        sub_101240044((double *)v84.i64, (double *)(*v11++ + 32));
      while (v11 != v10);
      uint64_t v19 = v84.i64[1];
      uint64_t v18 = v84.i64[0];
      uint64_t v21 = v85.i64[1];
      uint64_t v20 = v85.i64[0];
      if (v12 != v14)
      {
        double v22 = v12;
        do
          sub_101240044((double *)v84.i64, (double *)(*v22++ + 32));
        while (v22 != v14);
        uint64_t v19 = v84.i64[1];
        uint64_t v18 = v84.i64[0];
        uint64_t v21 = v85.i64[1];
        uint64_t v20 = v85.i64[0];
      }
      v59.i64[0] = v18;
      v59.i64[1] = v19;
      v60.i64[0] = v20;
      v60.i64[1] = v21;
      sub_101248298(&v59, &v70, &v61, a4 + 1, a5);
    }
    double v24 = (uint64_t *)v67;
    __double2 v23 = v68;
    if ((unint64_t)((char *)v68 - (unsigned char *)v67) < 0x80
      || (unint64_t)((char *)v65 - (unsigned char *)__p) < 0x80
      || a4 > 0x63
      || v13 < 0x79)
    {
      if (v67 != v68)
      {
        double v25 = v68;
        double v26 = v58;
        do
        {
          BOOL v42 = v24 == v25;
          double v25 = v24;
          if (!v42)
          {
            double v27 = v24;
            do
              sub_101247C4C(a5, *v26, *v27++);
            while (v27 != v23);
            double v25 = v23;
          }
          ++v26;
        }
        while (v26 != v10);
      }
      int v28 = (uint64_t *)__p;
      int v29 = v65;
      if (__p != v65)
      {
        int v30 = v65;
        int v31 = v58;
        do
        {
          BOOL v42 = v28 == v30;
          int v30 = v28;
          if (!v42)
          {
            double v32 = v28;
            do
              sub_101247C4C(a5, *v31, *v32++);
            while (v32 != v29);
            int v30 = v29;
          }
          ++v31;
        }
        while (v31 != v10);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      uint64_t v57 = v58;
      do
        sub_101240044((double *)v84.i64, (double *)(*v57++ + 32));
      while (v57 != v10);
      int64x2_t v59 = v84;
      int64x2_t v60 = v85;
      sub_101248298(&v59, &v70, &v67, a4 + 1, a5);
      sub_101248298(&v59, &v70, &__p, a4 + 1, a5);
    }
  }
  int v33 = v76;
  double v34 = v77;
  unint64_t v35 = (char *)v77 - (char *)v76;
  if (v12 != v14)
  {
    if (v35 < 0x80
      || (unint64_t)((char *)v74 - (char *)v73) < 0x80
      || a4 > 0x63
      || (unint64_t)((char *)v14 - (char *)v12) < 0x79)
    {
      if (v76 != v77)
      {
        int v37 = v14;
        uint64_t v38 = v76;
        do
        {
          BOOL v42 = v12 == v37;
          int v37 = v12;
          if (!v42)
          {
            uint64_t v39 = v12;
            do
              sub_101247C4C(a5, *v38, *v39++);
            while (v39 != v14);
            int v37 = v14;
          }
          ++v38;
        }
        while (v38 != v34);
      }
      uint64_t v40 = v73;
      double v41 = v74;
      BOOL v42 = v73 == v74 || v12 == v14;
      if (!v42)
      {
        uint64_t v43 = v14;
        do
        {
          BOOL v42 = v12 == v43;
          uint64_t v43 = v12;
          if (!v42)
          {
            double v44 = v12;
            do
              sub_101247C4C(a5, *v40, *v44++);
            while (v44 != v14);
            uint64_t v43 = v14;
          }
          ++v40;
        }
        while (v40 != v41);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      double v36 = v12;
      do
        sub_101240044((double *)v84.i64, (double *)(*v36++ + 32));
      while (v36 != v14);
      int64x2_t v59 = v84;
      int64x2_t v60 = v85;
      sub_101248298(&v59, &v76, &v61, a4 + 1, a5);
      sub_101248298(&v59, &v73, &v61, a4 + 1, a5);
    }
  }
  if (v35 < 0x80 || a4 > 0x63 || (unint64_t)((char *)v68 - (unsigned char *)v67) < 0x79)
  {
    if (v33 != v34)
    {
      uint64_t v45 = (uint64_t *)v67;
      uint64_t v46 = v68;
      if (v67 != v68)
      {
        long long v47 = v68;
        long long v48 = v33;
        do
        {
          BOOL v42 = v45 == v47;
          long long v47 = v45;
          if (!v42)
          {
            long long v49 = v45;
            do
              sub_101247C4C(a5, *v48, *v49++);
            while (v49 != v46);
            long long v47 = v46;
          }
          ++v48;
        }
        while (v48 != v34);
      }
    }
  }
  else
  {
    sub_101248298(&v81, &v76, &v67, a4 + 1, a5);
  }
  uint64_t v50 = v73;
  double v51 = v74;
  if ((unint64_t)((char *)v74 - (char *)v73) < 0x80
    || a4 > 0x63
    || (unint64_t)((char *)v65 - (unsigned char *)__p) < 0x79)
  {
    if (v73 != v74)
    {
      int64x2_t v52 = (uint64_t *)__p;
      int64x2_t v53 = v65;
      if (__p != v65)
      {
        uint64_t v54 = v65;
        double v55 = v73;
        do
        {
          BOOL v42 = v52 == v54;
          uint64_t v54 = v52;
          if (!v42)
          {
            double v56 = v52;
            do
              sub_101247C4C(a5, *v55, *v56++);
            while (v56 != v53);
            uint64_t v54 = v53;
          }
          ++v55;
        }
        while (v55 != v51);
      }
    }
  }
  else
  {
    sub_101248298(v79, &v73, &__p, a4 + 1, a5);
  }
  if (v12) {
    operator delete(v12);
  }
  if (__p) {
    operator delete(__p);
  }
  if (v67) {
    operator delete(v67);
  }
  if (v58) {
    operator delete(v58);
  }
  if (v50) {
    operator delete(v50);
  }
  if (v33)
  {
    operator delete(v33);
  }
}

void sub_101248FA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30)
{
  if (v30) {
    operator delete(v30);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a24) {
    operator delete(a24);
  }
  if (a27) {
    operator delete(a27);
  }
  if (a30) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101249034(void *a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    __assert_rtn("segment_distance", "get_ring.hpp", 149, "second.source_index == first.source_index");
  }
  if (a3[1] != a2[1]) {
    __assert_rtn("segment_distance", "get_ring.hpp", 150, "second.multi_index == first.multi_index");
  }
  uint64_t v3 = a3[2];
  if (v3 != a2[2]) {
    __assert_rtn("segment_distance", "get_ring.hpp", 151, "second.ring_index == first.ring_index");
  }
  uint64_t v4 = a3[3];
  uint64_t v5 = a2[3];
  BOOL v6 = v4 < v5;
  uint64_t v7 = v4 - v5;
  if (v6)
  {
    if (v3 < -1 || (uint64_t v8 = a1[3], v9 = 0xAAAAAAAAAAAAAAABLL * ((a1[4] - v8) >> 3), v3 >= (int)v9)) {
      __assert_rtn("apply", "get_ring.hpp", 94, "id.ring_index >= -1 && id.ring_index < int(boost::size(interior_rings(polygon)))");
    }
    if ((v3 & 0x8000000000000000) == 0)
    {
      if (v9 < v3) {
        __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
      }
      a1 = (void *)(v8 + 24 * v3);
    }
    return v7 + ((uint64_t)(a1[1] - *a1) >> 4) - 1;
  }
  return v7;
}

void sub_101249178(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - v10) >> 3);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*(double *)(a2 - 8) > *(double *)(v10 + 16))
                {
                  uint64_t v102 = *(void *)(v10 + 16);
                  long long v94 = *(_OWORD *)v10;
                  long long v47 = *(_OWORD *)(a2 - 24);
                  *(void *)(v10 + 16) = *(void *)(a2 - 8);
                  *(_OWORD *)unint64_t v10 = v47;
                  *(void *)(a2 - 8) = v102;
                  *(_OWORD *)(a2 - 24) = v94;
                }
                break;
              case 3uLL:
                sub_101249A38((long long *)v10, (double *)(v10 + 24), (double *)(a2 - 24));
                break;
              case 4uLL:
                sub_101249D20(v10, v10 + 24, v10 + 48, a2 - 24);
                break;
              case 5uLL:
                sub_101249DF0((__n128 *)v10, (__n128 *)(v10 + 24), (__n128 *)(v10 + 48), (__n128 *)(v10 + 72), (__n128 *)(a2 - 24));
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 575)
          {
            long long v48 = (_OWORD *)(v10 + 24);
            BOOL v50 = v10 == a2 || v48 == (_OWORD *)a2;
            if (a4)
            {
              if (!v50)
              {
                uint64_t v51 = 0;
                int64x2_t v52 = (_OWORD *)v10;
                do
                {
                  double v53 = *((double *)v52 + 5);
                  double v54 = *((double *)v52 + 2);
                  int64x2_t v52 = v48;
                  if (v53 > v54)
                  {
                    long long v95 = *v48;
                    uint64_t v55 = v51;
                    while (1)
                    {
                      uint64_t v56 = v10 + v55;
                      *(_OWORD *)(v56 + 24) = *(_OWORD *)(v10 + v55);
                      *(void *)(v56 + 40) = *(void *)(v10 + v55 + 16);
                      if (!v55) {
                        break;
                      }
                      v55 -= 24;
                      if (v53 <= *(double *)(v56 - 8))
                      {
                        uint64_t v57 = v10 + v55 + 24;
                        goto LABEL_83;
                      }
                    }
                    uint64_t v57 = v10;
LABEL_83:
                    *(_OWORD *)uint64_t v57 = v95;
                    *(double *)(v57 + 16) = v53;
                  }
                  long long v48 = (_OWORD *)((char *)v52 + 24);
                  v51 += 24;
                }
                while ((_OWORD *)((char *)v52 + 24) != (_OWORD *)a2);
              }
            }
            else if (!v50)
            {
              do
              {
                double v84 = *(double *)(a1 + 40);
                double v85 = *(double *)(a1 + 16);
                a1 = (unint64_t)v48;
                if (v84 > v85)
                {
                  long long v98 = *v48;
                  uint64_t v86 = v48;
                  do
                  {
                    _OWORD *v86 = *(_OWORD *)((char *)v86 - 24);
                    *((void *)v86 + 2) = *((void *)v86 - 1);
                    double v87 = *((double *)v86 - 4);
                    uint64_t v86 = (_OWORD *)((char *)v86 - 24);
                  }
                  while (v84 > v87);
                  _OWORD *v86 = v98;
                  *((double *)v86 + 2) = v84;
                }
                long long v48 = (_OWORD *)((char *)v48 + 24);
              }
              while (a1 + 24 != a2);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v58 = (v12 - 2) >> 1;
              int64_t v59 = v58;
              do
              {
                int64_t v60 = v59;
                if (v58 >= v59)
                {
                  uint64_t v61 = (2 * v59) | 1;
                  unint64_t v62 = v10 + 24 * v61;
                  if (2 * v60 + 2 < (uint64_t)v12 && *(double *)(v10 + 24 * v61 + 16) > *(double *)(v62 + 40))
                  {
                    v62 += 24;
                    uint64_t v61 = 2 * v60 + 2;
                  }
                  double v63 = *(double *)(v10 + 24 * v60 + 16);
                  if (*(double *)(v62 + 16) <= v63)
                  {
                    unint64_t v64 = v10 + 24 * v60;
                    long long v96 = *(_OWORD *)v64;
                    do
                    {
                      unint64_t v65 = v62;
                      long long v66 = *(_OWORD *)v62;
                      *(void *)(v64 + 16) = *(void *)(v62 + 16);
                      *(_OWORD *)unint64_t v64 = v66;
                      if (v58 < v61) {
                        break;
                      }
                      uint64_t v67 = (2 * v61) | 1;
                      unint64_t v62 = v10 + 24 * v67;
                      uint64_t v68 = 2 * v61 + 2;
                      if (v68 < (uint64_t)v12 && *(double *)(v10 + 24 * v67 + 16) > *(double *)(v62 + 40))
                      {
                        v62 += 24;
                        uint64_t v67 = v68;
                      }
                      unint64_t v64 = v65;
                      uint64_t v61 = v67;
                    }
                    while (*(double *)(v62 + 16) <= v63);
                    *(_OWORD *)unint64_t v65 = v96;
                    *(double *)(v65 + 16) = v63;
                  }
                }
                int64_t v59 = v60 - 1;
              }
              while (v60);
              int64_t v69 = v11 / 0x18uLL;
              do
              {
                uint64_t v70 = 0;
                uint64_t v103 = *(void *)(v10 + 16);
                long long v97 = *(_OWORD *)v10;
                unint64_t v71 = v10;
                do
                {
                  unint64_t v72 = v71;
                  uint64_t v73 = v70 + 1;
                  v71 += 24 * (v70 + 1);
                  uint64_t v74 = 2 * v70;
                  uint64_t v70 = (2 * v70) | 1;
                  int64_t v75 = v74 + 2;
                  if (v75 < v69 && *(double *)(v72 + 24 * v73 + 16) > *(double *)(v71 + 40))
                  {
                    v71 += 24;
                    uint64_t v70 = v75;
                  }
                  long long v76 = *(_OWORD *)v71;
                  *(void *)(v72 + 16) = *(void *)(v71 + 16);
                  *(_OWORD *)unint64_t v72 = v76;
                }
                while (v70 <= (uint64_t)((unint64_t)(v69 - 2) >> 1));
                a2 -= 24;
                if (v71 == a2)
                {
                  *(void *)(v71 + 16) = v103;
                  *(_OWORD *)unint64_t v71 = v97;
                }
                else
                {
                  long long v77 = *(_OWORD *)a2;
                  *(void *)(v71 + 16) = *(void *)(a2 + 16);
                  *(_OWORD *)unint64_t v71 = v77;
                  *(void *)(a2 + 16) = v103;
                  *(_OWORD *)a2 = v97;
                  uint64_t v78 = v71 - v10 + 24;
                  if (v78 >= 25)
                  {
                    unint64_t v79 = (v78 / 0x18uLL - 2) >> 1;
                    double v80 = *(double *)(v71 + 16);
                    if (*(double *)(v10 + 24 * v79 + 16) > v80)
                    {
                      long long v90 = *(_OWORD *)v71;
                      do
                      {
                        unint64_t v81 = v71;
                        unint64_t v71 = v10 + 24 * v79;
                        long long v82 = *(_OWORD *)v71;
                        *(void *)(v81 + 16) = *(void *)(v71 + 16);
                        *(_OWORD *)unint64_t v81 = v82;
                        if (!v79) {
                          break;
                        }
                        unint64_t v79 = (v79 - 1) >> 1;
                      }
                      while (*(double *)(v10 + 24 * v79 + 16) > v80);
                      *(_OWORD *)unint64_t v71 = v90;
                      *(double *)(v71 + 16) = v80;
                    }
                  }
                }
              }
              while (v69-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 24 * (v12 >> 1);
          if ((unint64_t)v11 >= 0xC01)
          {
            sub_101249A38((long long *)a1, (double *)(a1 + 24 * (v12 >> 1)), (double *)(a2 - 24));
            uint64_t v15 = 3 * v13;
            double v16 = (double *)(a1 + 24 * v13 - 24);
            sub_101249A38((long long *)(a1 + 24), v16, (double *)(a2 - 48));
            double v17 = (double *)(a1 + 24 + 8 * v15);
            sub_101249A38((long long *)(a1 + 48), v17, (double *)(a2 - 72));
            sub_101249A38((long long *)v16, (double *)v14, v17);
            uint64_t v99 = *(void *)(a1 + 16);
            long long v91 = *(_OWORD *)a1;
            uint64_t v18 = *(void *)(v14 + 16);
            *(_OWORD *)a1 = *(_OWORD *)v14;
            *(void *)(a1 + 16) = v18;
            *(void *)(v14 + 16) = v99;
            *(_OWORD *)unint64_t v14 = v91;
          }
          else
          {
            sub_101249A38((long long *)(a1 + 24 * (v12 >> 1)), (double *)a1, (double *)(a2 - 24));
          }
          --a3;
          if (a4) {
            break;
          }
          double v19 = *(double *)(a1 + 16);
          if (*(double *)(a1 - 8) > v19) {
            goto LABEL_12;
          }
          long long v89 = *(_OWORD *)a1;
          if (v19 <= *(double *)(a2 - 8))
          {
            unint64_t v37 = a1 + 24;
            do
            {
              unint64_t v10 = v37;
              if (v37 >= a2) {
                break;
              }
              double v38 = *(double *)(v37 + 16);
              v37 += 24;
            }
            while (v19 <= v38);
          }
          else
          {
            unint64_t v35 = a1;
            do
            {
              unint64_t v10 = v35 + 24;
              double v36 = *(double *)(v35 + 40);
              v35 += 24;
            }
            while (v19 <= v36);
          }
          unint64_t v39 = a2;
          if (v10 < a2)
          {
            unint64_t v40 = a2;
            do
            {
              unint64_t v39 = v40 - 24;
              double v41 = *(double *)(v40 - 8);
              v40 -= 24;
            }
            while (v19 > v41);
          }
          while (v10 < v39)
          {
            uint64_t v101 = *(void *)(v10 + 16);
            long long v93 = *(_OWORD *)v10;
            long long v42 = *(_OWORD *)v39;
            *(void *)(v10 + 16) = *(void *)(v39 + 16);
            *(_OWORD *)unint64_t v10 = v42;
            *(void *)(v39 + 16) = v101;
            *(_OWORD *)unint64_t v39 = v93;
            do
            {
              double v43 = *(double *)(v10 + 40);
              v10 += 24;
            }
            while (v19 <= v43);
            do
            {
              double v44 = *(double *)(v39 - 8);
              v39 -= 24;
            }
            while (v19 > v44);
          }
          uint64_t v45 = (long long *)(v10 - 24);
          BOOL v4 = v10 - 24 >= a1;
          BOOL v5 = v10 - 24 == a1;
          if (v10 - 24 != a1)
          {
            long long v46 = *v45;
            *(void *)(a1 + 16) = *(void *)(v10 - 8);
            *(_OWORD *)a1 = v46;
          }
          a4 = 0;
          *uint64_t v45 = v89;
          *(double *)(v10 - 8) = v19;
        }
        double v19 = *(double *)(a1 + 16);
LABEL_12:
        uint64_t v20 = 0;
        long long v88 = *(_OWORD *)a1;
        do
        {
          double v21 = *(double *)(a1 + v20 + 40);
          v20 += 24;
        }
        while (v21 > v19);
        unint64_t v22 = a1 + v20;
        unint64_t v23 = a2;
        if (v20 == 24)
        {
          unint64_t v26 = a2;
          while (v22 < v26)
          {
            unint64_t v24 = v26 - 24;
            double v27 = *(double *)(v26 - 8);
            v26 -= 24;
            if (v27 > v19) {
              goto LABEL_22;
            }
          }
          unint64_t v24 = v26;
        }
        else
        {
          do
          {
            unint64_t v24 = v23 - 24;
            double v25 = *(double *)(v23 - 8);
            v23 -= 24;
          }
          while (v25 <= v19);
        }
LABEL_22:
        if (v22 >= v24)
        {
          unint64_t v10 = v22;
        }
        else
        {
          unint64_t v28 = v24;
          unint64_t v10 = v22;
          do
          {
            uint64_t v100 = *(void *)(v10 + 16);
            long long v92 = *(_OWORD *)v10;
            long long v29 = *(_OWORD *)v28;
            *(void *)(v10 + 16) = *(void *)(v28 + 16);
            *(_OWORD *)unint64_t v10 = v29;
            *(void *)(v28 + 16) = v100;
            *(_OWORD *)unint64_t v28 = v92;
            do
            {
              double v30 = *(double *)(v10 + 40);
              v10 += 24;
            }
            while (v30 > v19);
            do
            {
              double v31 = *(double *)(v28 - 8);
              v28 -= 24;
            }
            while (v31 <= v19);
          }
          while (v10 < v28);
        }
        double v32 = (long long *)(v10 - 24);
        if (v10 - 24 != a1)
        {
          long long v33 = *v32;
          *(void *)(a1 + 16) = *(void *)(v10 - 8);
          *(_OWORD *)a1 = v33;
        }
        long long *v32 = v88;
        *(double *)(v10 - 8) = v19;
        if (v22 >= v24) {
          break;
        }
LABEL_35:
        sub_101249178(a1, v10 - 24, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v34 = sub_101249B28(a1, v10 - 24);
      if (sub_101249B28(v10, a2)) {
        break;
      }
      if (!v34) {
        goto LABEL_35;
      }
    }
    a2 = v10 - 24;
    if (!v34) {
      continue;
    }
    break;
  }
}

long long *sub_101249A38(long long *result, double *a2, double *a3)
{
  double v3 = a2[2];
  double v4 = a3[2];
  if (v3 <= *((double *)result + 2))
  {
    if (v4 > v3)
    {
      uint64_t v8 = *((void *)a2 + 2);
      long long v9 = *(_OWORD *)a2;
      uint64_t v10 = *((void *)a3 + 2);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((void *)a2 + 2) = v10;
      *(_OWORD *)a3 = v9;
      *((void *)a3 + 2) = v8;
      if (a2[2] > *((double *)result + 2))
      {
        uint64_t v11 = *((void *)result + 2);
        long long v12 = *result;
        uint64_t v13 = *((void *)a2 + 2);
        void *result = *(_OWORD *)a2;
        *((void *)result + 2) = v13;
        *(_OWORD *)a2 = v12;
        *((void *)a2 + 2) = v11;
      }
    }
  }
  else
  {
    if (v4 <= v3)
    {
      uint64_t v14 = *((void *)result + 2);
      long long v15 = *result;
      uint64_t v16 = *((void *)a2 + 2);
      void *result = *(_OWORD *)a2;
      *((void *)result + 2) = v16;
      *(_OWORD *)a2 = v15;
      *((void *)a2 + 2) = v14;
      if (a3[2] <= a2[2]) {
        return result;
      }
      uint64_t v5 = *((void *)a2 + 2);
      long long v6 = *(_OWORD *)a2;
      uint64_t v17 = *((void *)a3 + 2);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((void *)a2 + 2) = v17;
    }
    else
    {
      uint64_t v5 = *((void *)result + 2);
      long long v6 = *result;
      uint64_t v7 = *((void *)a3 + 2);
      void *result = *(_OWORD *)a3;
      *((void *)result + 2) = v7;
    }
    *(_OWORD *)a3 = v6;
    *((void *)a3 + 2) = v5;
  }
  return result;
}

BOOL sub_101249B28(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(double *)(a2 - 8) > *(double *)(a1 + 16))
      {
        uint64_t v6 = *(void *)(a1 + 16);
        long long v7 = *(_OWORD *)a1;
        uint64_t v8 = *(void *)(a2 - 8);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 24);
        *(void *)(a1 + 16) = v8;
        *(_OWORD *)(a2 - 24) = v7;
        *(void *)(a2 - 8) = v6;
      }
      return result;
    case 3uLL:
      sub_101249A38((long long *)a1, (double *)(a1 + 24), (double *)(a2 - 24));
      return 1;
    case 4uLL:
      sub_101249D20(a1, a1 + 24, a1 + 48, a2 - 24);
      return 1;
    case 5uLL:
      sub_101249DF0((__n128 *)a1, (__n128 *)(a1 + 24), (__n128 *)(a1 + 48), (__n128 *)(a1 + 72), (__n128 *)(a2 - 24));
      return 1;
    default:
      uint64_t v9 = a1 + 48;
      sub_101249A38((long long *)a1, (double *)(a1 + 24), (double *)(a1 + 48));
      uint64_t v10 = a1 + 72;
      if (a1 + 72 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    double v13 = *(double *)(v10 + 16);
    if (v13 > *(double *)(v9 + 16))
    {
      long long v17 = *(_OWORD *)v10;
      uint64_t v14 = v11;
      while (1)
      {
        uint64_t v15 = a1 + v14;
        *(_OWORD *)(v15 + 72) = *(_OWORD *)(a1 + v14 + 48);
        *(void *)(v15 + 88) = *(void *)(a1 + v14 + 64);
        if (v14 == -48) {
          break;
        }
        v14 -= 24;
        if (v13 <= *(double *)(v15 + 40))
        {
          uint64_t v16 = a1 + v14 + 72;
          goto LABEL_12;
        }
      }
      uint64_t v16 = a1;
LABEL_12:
      *(_OWORD *)uint64_t v16 = v17;
      *(double *)(v16 + 16) = v13;
      if (++v12 == 8) {
        return v10 + 24 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 24;
    v10 += 24;
    if (v10 == a2) {
      return 1;
    }
  }
}

__n128 sub_101249D20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_101249A38((long long *)a1, (double *)a2, (double *)a3);
  result.n128_u64[0] = *(void *)(a4 + 16);
  if (result.n128_f64[0] > *(double *)(a3 + 16))
  {
    uint64_t v9 = *(void *)(a3 + 16);
    __n128 result = *(__n128 *)a3;
    uint64_t v10 = *(void *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(void *)(a3 + 16) = v10;
    *(__n128 *)a4 = result;
    *(void *)(a4 + 16) = v9;
    result.n128_u64[0] = *(void *)(a3 + 16);
    if (result.n128_f64[0] > *(double *)(a2 + 16))
    {
      uint64_t v11 = *(void *)(a2 + 16);
      __n128 result = *(__n128 *)a2;
      uint64_t v12 = *(void *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(void *)(a2 + 16) = v12;
      *(__n128 *)a3 = result;
      *(void *)(a3 + 16) = v11;
      result.n128_u64[0] = *(void *)(a2 + 16);
      if (result.n128_f64[0] > *(double *)(a1 + 16))
      {
        uint64_t v13 = *(void *)(a1 + 16);
        __n128 result = *(__n128 *)a1;
        uint64_t v14 = *(void *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(void *)(a1 + 16) = v14;
        *(__n128 *)a2 = result;
        *(void *)(a2 + 16) = v13;
      }
    }
  }
  return result;
}

__n128 sub_101249DF0(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  sub_101249D20((uint64_t)a1, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4);
  result.n128_u64[0] = a5[1].n128_u64[0];
  if (result.n128_f64[0] > a4[1].n128_f64[0])
  {
    unint64_t v11 = a4[1].n128_u64[0];
    __n128 result = *a4;
    unint64_t v12 = a5[1].n128_u64[0];
    *a4 = *a5;
    a4[1].n128_u64[0] = v12;
    *a5 = result;
    a5[1].n128_u64[0] = v11;
    result.n128_u64[0] = a4[1].n128_u64[0];
    if (result.n128_f64[0] > a3[1].n128_f64[0])
    {
      unint64_t v13 = a3[1].n128_u64[0];
      __n128 result = *a3;
      unint64_t v14 = a4[1].n128_u64[0];
      *a3 = *a4;
      a3[1].n128_u64[0] = v14;
      *a4 = result;
      a4[1].n128_u64[0] = v13;
      result.n128_u64[0] = a3[1].n128_u64[0];
      if (result.n128_f64[0] > a2[1].n128_f64[0])
      {
        unint64_t v15 = a2[1].n128_u64[0];
        __n128 result = *a2;
        unint64_t v16 = a3[1].n128_u64[0];
        *a2 = *a3;
        a2[1].n128_u64[0] = v16;
        *a3 = result;
        a3[1].n128_u64[0] = v15;
        result.n128_u64[0] = a2[1].n128_u64[0];
        if (result.n128_f64[0] > a1[1].n128_f64[0])
        {
          unint64_t v17 = a1[1].n128_u64[0];
          __n128 result = *a1;
          unint64_t v18 = a2[1].n128_u64[0];
          *a1 = *a2;
          a1[1].n128_u64[0] = v18;
          *a2 = result;
          a2[1].n128_u64[0] = v17;
        }
      }
    }
  }
  return result;
}

uint64_t sub_101249EFC(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  double v3 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  uint64_t v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    uint64_t v6 = 0;
    long long v7 = (uint64_t *)(a1 + 8);
    while (1)
    {
      uint64_t v8 = v5[4];
      uint64_t v9 = v3;
      if (v7 == v3) {
        goto LABEL_9;
      }
      uint64_t v10 = v6;
      unint64_t v11 = v3;
      if (v6)
      {
        do
        {
          uint64_t v9 = v10;
          uint64_t v10 = (uint64_t *)v10[1];
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v9 = (uint64_t *)v11[2];
          BOOL v12 = *v9 == (void)v11;
          unint64_t v11 = v9;
        }
        while (v12);
      }
      if (v9[4] < v8)
      {
LABEL_9:
        if (v6) {
          unint64_t v13 = (uint64_t **)v9;
        }
        else {
          unint64_t v13 = (uint64_t **)v3;
        }
        if (v6) {
          unint64_t v14 = (uint64_t **)(v9 + 1);
        }
        else {
          unint64_t v14 = (uint64_t **)v3;
        }
        if (!*v14)
        {
LABEL_25:
          unint64_t v17 = (uint64_t *)operator new(0x28uLL);
          v17[4] = v8;
          sub_100046C38((uint64_t **)a1, (uint64_t)v13, v14, v17);
        }
      }
      else
      {
        unint64_t v14 = (uint64_t **)v3;
        unint64_t v13 = (uint64_t **)v3;
        if (!v6) {
          goto LABEL_25;
        }
        unint64_t v15 = v6;
        while (1)
        {
          while (1)
          {
            unint64_t v13 = (uint64_t **)v15;
            uint64_t v16 = v15[4];
            if (v16 <= v8) {
              break;
            }
            unint64_t v15 = *v13;
            unint64_t v14 = v13;
            if (!*v13) {
              goto LABEL_25;
            }
          }
          if (v16 >= v8) {
            break;
          }
          unint64_t v15 = v13[1];
          if (!v15)
          {
            unint64_t v14 = v13 + 1;
            goto LABEL_25;
          }
        }
      }
      unint64_t v18 = (void *)v5[1];
      if (v18)
      {
        do
        {
          double v19 = v18;
          unint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          double v19 = (void *)v5[2];
          BOOL v12 = *v19 == (void)v5;
          uint64_t v5 = v19;
        }
        while (!v12);
      }
      if (v19 == v4) {
        return a1;
      }
      long long v7 = *(uint64_t **)a1;
      uint64_t v6 = *(uint64_t **)(a1 + 8);
      uint64_t v5 = v19;
    }
  }
  return a1;
}

void sub_10124A068(_Unwind_Exception *a1)
{
  sub_10005D144(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_10124A07C(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (uint64_t **)result;
  uint64_t v6 = (uint64_t **)(result + 1);
  uint64_t v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        long long v7 = (uint64_t **)v5;
        uint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    long long v7 = (uint64_t **)(result + 1);
LABEL_9:
    uint64_t v9 = (uint64_t *)operator new(0x28uLL);
    v9[4] = a3;
    return sub_100046C38(v4, (uint64_t)v7, v6, v9);
  }
  return result;
}

void sub_10124A128(void ***a1)
{
  double v1 = *a1;
  double v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 48;
        sub_10005D144(*((void **)v4 - 5));
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_10124A1B0(uint64_t a1, uint64_t a2)
{
  double v2 = *(void **)(a1 + 8);
  if (v2)
  {
    double v3 = (uint64_t *)(a1 + 8);
    do
    {
      uint64_t v4 = v2[4];
      BOOL v5 = v4 < a2;
      if (v4 >= a2) {
        uint64_t v6 = v2;
      }
      else {
        uint64_t v6 = v2 + 1;
      }
      if (!v5) {
        double v3 = v2;
      }
      double v2 = (void *)*v6;
    }
    while (*v6);
    if (v3 != (uint64_t *)(a1 + 8) && v3[4] <= a2)
    {
      sub_1000F5B04((uint64_t **)a1, v3);
      operator delete(v3);
    }
  }
}

uint64_t sub_10124A234(double *a1, uint64_t a2)
{
  double v2 = *(double **)a2;
  double v3 = *(double **)(a2 + 8);
  if ((unint64_t)v3 - *(void *)a2 < 0x40) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  int v15 = 0;
  if (v2 + 2 == v3) {
    return 0xFFFFFFFFLL;
  }
  do
  {
    if (!sub_10124A3D0(a1, v2, v2 + 2, (uint64_t)&v13)) {
      break;
    }
    uint64_t v6 = v2 + 4;
    v2 += 2;
  }
  while (v6 != v3);
  if ((_BYTE)v15) {
    return 0;
  }
  if (v14 && HIDWORD(v14))
  {
    if ((int)v14 < 1)
    {
      if (!v13) {
        return 0xFFFFFFFFLL;
      }
    }
    else if (!(v13 + HIDWORD(v13)))
    {
      return 0xFFFFFFFFLL;
    }
  }
  else if (!v13)
  {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = *(double ***)(a2 + 24);
  uint64_t v8 = *(double ***)(a2 + 32);
  if (v9 != v8)
  {
    while (1)
    {
      uint64_t v10 = *v9;
      unint64_t v11 = v9[1];
      if ((unint64_t)((char *)v11 - (char *)*v9) >= 0x40)
      {
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        int v15 = 0;
        if (v10 + 2 != v11)
        {
          do
          {
            if (!sub_10124A3D0(a1, v10, v10 + 2, (uint64_t)&v13)) {
              break;
            }
            BOOL v12 = v10 + 4;
            v10 += 2;
          }
          while (v12 != v11);
          if ((_BYTE)v15) {
            return 0;
          }
          if (v14 && HIDWORD(v14))
          {
            if ((int)v14 < 1)
            {
              if (v13) {
                return 0xFFFFFFFFLL;
              }
            }
            else if (v13 + HIDWORD(v13))
            {
              return 0xFFFFFFFFLL;
            }
          }
          else if (v13)
          {
            return 0xFFFFFFFFLL;
          }
        }
        uint64_t v8 = *(double ***)(a2 + 32);
      }
      v9 += 3;
      uint64_t result = 1;
      if (v9 == v8) {
        return result;
      }
    }
  }
  return 1;
}

BOOL sub_10124A3D0(double *a1, double *a2, double *a3, uint64_t a4)
{
  double v8 = *a1;
  double v9 = a1[1];
  double v10 = *a2;
  double v232 = a3[1];
  double v233 = a2[1];
  double v234 = *a1 - *a2;
  double v235 = *a3;
  double v11 = vabdd_f64(*a1, *a2);
  double v12 = 180.0;
  if (v11 == 180.0) {
    goto LABEL_2;
  }
  if (COERCE_UNSIGNED_INT64(fabs(*a1 - *a2)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v32 = fabs(v11 + -180.0);
    double v12 = 180.0;
    double v33 = v11 >= 180.0 ? v11 : 180.0;
    double v34 = v33 >= 1.0 ? v33 * 2.22044605e-16 : 2.22044605e-16;
    if (v32 <= v34) {
      goto LABEL_2;
    }
  }
  double v12 = 180.0;
  if (v234 <= 180.0)
  {
    double v13 = *a1 - *a2;
    if (v234 >= -180.0) {
      goto LABEL_3;
    }
    double v70 = a1[1];
    long double v71 = fmod(v234 + -180.0, 360.0);
    double v9 = v70;
    double v12 = v71 + 180.0;
LABEL_2:
    double v13 = v12;
    goto LABEL_3;
  }
  double v35 = a1[1];
  long double v36 = fmod(v234 + 180.0, 360.0);
  double v9 = v35;
  double v13 = v36 + -180.0;
  if (v13 == -180.0) {
    goto LABEL_2;
  }
  BOOL v37 = ((*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
     && (*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
  if (!v37 || *(void *)&v13 == 0)
  {
    double v12 = 180.0;
    double v39 = fabs(v13 + 180.0);
    double v40 = fabs(v13);
    if (v40 < 180.0) {
      double v40 = 180.0;
    }
    double v41 = v40 >= 1.0 ? v40 * 2.22044605e-16 : 2.22044605e-16;
    if (v39 <= v41) {
      goto LABEL_2;
    }
  }
LABEL_3:
  double v14 = fabs(v13);
  double v15 = 2.22044605e-16;
  if (v14 >= 1.0) {
    double v15 = v14 * 2.22044605e-16;
  }
  BOOL v16 = (*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && v14 <= v15;
  int v17 = v13 == 0.0 || v16;
  double v18 = vabdd_f64(v8, v235);
  double v19 = 180.0;
  if (v18 != 180.0)
  {
    double v20 = v8 - v235;
    if (COERCE__INT64(fabs(v8 - v235)) > 0x7FEFFFFFFFFFFFFFLL) {
      goto LABEL_61;
    }
    double v42 = fabs(v18 + -180.0);
    double v19 = 180.0;
    if (v18 < 180.0) {
      double v18 = 180.0;
    }
    double v43 = v18 >= 1.0 ? v18 * 2.22044605e-16 : 2.22044605e-16;
    if (v42 > v43)
    {
LABEL_61:
      double v19 = 180.0;
      if (v20 <= 180.0)
      {
        if (v20 >= -180.0) {
          goto LABEL_13;
        }
        double v72 = v9;
        long double v73 = fmod(v20 + -180.0, 360.0);
        double v9 = v72;
        double v19 = v73 + 180.0;
      }
      else
      {
        double v44 = v9;
        long double v45 = fmod(v20 + 180.0, 360.0);
        double v9 = v44;
        double v20 = v45 + -180.0;
        if (v20 != -180.0)
        {
          BOOL v46 = ((*(void *)&v20 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
             && (*(void *)&v20 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
          if (v46 && *(void *)&v20 != 0) {
            goto LABEL_13;
          }
          double v19 = 180.0;
          double v48 = fabs(v20 + 180.0);
          double v49 = fabs(v20);
          if (v49 < 180.0) {
            double v49 = 180.0;
          }
          double v50 = v49 >= 1.0 ? v49 * 2.22044605e-16 : 2.22044605e-16;
          if (v48 > v50) {
            goto LABEL_13;
          }
        }
      }
    }
  }
  double v20 = v19;
LABEL_13:
  double v21 = fabs(v20);
  double v22 = 2.22044605e-16;
  if (v21 >= 1.0) {
    double v22 = v21 * 2.22044605e-16;
  }
  BOOL v23 = (*(void *)&v20 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && v21 <= v22;
  int v24 = v20 == 0.0 || v23;
  double v25 = v8 + dbl_1015E0D50[v8 <= 0.0];
  double v231 = a1;
  if (v17) {
    goto LABEL_22;
  }
  double v27 = vabdd_f64(v25, v10);
  double v28 = 180.0;
  if (v27 == 180.0) {
    goto LABEL_24;
  }
  double v29 = v25 - v10;
  double v51 = fabs(v25 - v10);
  unint64_t v52 = (unint64_t)(*(void *)&v51 - 0x10000000000000) >> 53;
  unint64_t v53 = *(void *)&v51 - 1;
  BOOL v54 = v52 > 0x3FE && v53 > 0xFFFFFFFFFFFFELL;
  if (!v54 || COERCE__INT64(v25 - v10) == 0)
  {
    double v56 = fabs(v27 + -180.0);
    double v28 = 180.0;
    if (v27 < 180.0) {
      double v27 = 180.0;
    }
    double v57 = v27 >= 1.0 ? v27 * 2.22044605e-16 : 2.22044605e-16;
    if (v56 <= v57) {
      goto LABEL_24;
    }
  }
  double v28 = 180.0;
  if (v29 <= 180.0)
  {
    if (v29 >= -180.0) {
      goto LABEL_25;
    }
    double v74 = v9;
    long double v75 = fmod(v29 + -180.0, 360.0);
    double v9 = v74;
    double v28 = v75 + 180.0;
    goto LABEL_24;
  }
  double v58 = v9;
  long double v59 = fmod(v29 + 180.0, 360.0);
  double v9 = v58;
  double v29 = v59 + -180.0;
  if (v29 == -180.0) {
    goto LABEL_24;
  }
  BOOL v60 = ((*(void *)&v29 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
     && (*(void *)&v29 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
  if (!v60 || *(void *)&v29 == 0)
  {
    double v28 = 180.0;
    double v62 = fabs(v29 + 180.0);
    double v63 = fabs(v29);
    if (v63 < 180.0) {
      double v63 = 180.0;
    }
    double v64 = v63 >= 1.0 ? v63 * 2.22044605e-16 : 2.22044605e-16;
    if (v62 <= v64) {
LABEL_24:
    }
      double v29 = v28;
  }
LABEL_25:
  if (v29 == 0.0) {
    goto LABEL_26;
  }
  if ((*(void *)&v29 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v65 = fabs(v29);
    double v66 = 2.22044605e-16;
    if (v65 >= 1.0) {
      double v66 = v65 * 2.22044605e-16;
    }
    if (v65 <= v66)
    {
LABEL_26:
      int v26 = 0;
LABEL_27:
      int v30 = 1;
      if (v24) {
        goto LABEL_28;
      }
      goto LABEL_129;
    }
  }
  double v67 = fabs(v233);
  if (v67 == 90.0)
  {
LABEL_22:
    int v26 = 1;
    goto LABEL_27;
  }
  if ((*(void *)&v233 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    int v30 = 0;
  }
  else
  {
    double v68 = fabs(v67 + -90.0);
    if (v67 < 90.0) {
      double v67 = 90.0;
    }
    if (v67 >= 1.0) {
      double v69 = v67 * 2.22044605e-16;
    }
    else {
      double v69 = 2.22044605e-16;
    }
    int v30 = v68 <= v69;
  }
  int v26 = 1;
  if (v24) {
    goto LABEL_28;
  }
LABEL_129:
  double v76 = vabdd_f64(v25, v235);
  double v77 = 180.0;
  if (v76 == 180.0) {
    goto LABEL_130;
  }
  double v78 = v25 - v235;
  double v129 = fabs(v25 - v235);
  unint64_t v130 = (unint64_t)(*(void *)&v129 - 0x10000000000000) >> 53;
  unint64_t v131 = *(void *)&v129 - 1;
  BOOL v132 = v130 > 0x3FE && v131 > 0xFFFFFFFFFFFFELL;
  if (!v132 || COERCE__INT64(v25 - v235) == 0)
  {
    double v134 = fabs(v76 + -180.0);
    double v77 = 180.0;
    if (v76 < 180.0) {
      double v76 = 180.0;
    }
    double v135 = v76 >= 1.0 ? v76 * 2.22044605e-16 : 2.22044605e-16;
    if (v134 <= v135) {
      goto LABEL_130;
    }
  }
  double v77 = 180.0;
  if (v78 <= 180.0)
  {
    if (v78 >= -180.0) {
      goto LABEL_131;
    }
    double v184 = v9;
    long double v185 = fmod(v78 + -180.0, 360.0);
    double v9 = v184;
    double v77 = v185 + 180.0;
    goto LABEL_130;
  }
  double v136 = v9;
  long double v137 = fmod(v78 + 180.0, 360.0);
  double v9 = v136;
  double v78 = v137 + -180.0;
  if (v78 == -180.0) {
    goto LABEL_130;
  }
  BOOL v138 = ((*(void *)&v78 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
      && (*(void *)&v78 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
  if (!v138 || *(void *)&v78 == 0)
  {
    double v77 = 180.0;
    double v140 = fabs(v78 + 180.0);
    double v141 = fabs(v78);
    if (v141 < 180.0) {
      double v141 = 180.0;
    }
    double v142 = v141 >= 1.0 ? v141 * 2.22044605e-16 : 2.22044605e-16;
    if (v140 <= v142) {
LABEL_130:
    }
      double v78 = v77;
  }
LABEL_131:
  if (v78 == 0.0) {
    goto LABEL_132;
  }
  if ((*(void *)&v78 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v143 = fabs(v78);
    double v144 = 2.22044605e-16;
    if (v143 >= 1.0) {
      double v144 = v143 * 2.22044605e-16;
    }
    if (v143 <= v144)
    {
LABEL_132:
      int v31 = 0;
      goto LABEL_133;
    }
  }
  double v145 = fabs(v232);
  if (v145 == 90.0)
  {
LABEL_28:
    int v31 = 1;
LABEL_133:
    BOOL v79 = 1;
    goto LABEL_134;
  }
  if ((*(void *)&v232 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    BOOL v79 = 0;
  }
  else
  {
    double v146 = fabs(v145 + -90.0);
    if (v145 < 90.0) {
      double v145 = 90.0;
    }
    if (v145 >= 1.0) {
      double v147 = v145 * 2.22044605e-16;
    }
    else {
      double v147 = 2.22044605e-16;
    }
    BOOL v79 = v146 <= v147;
  }
  int v31 = 1;
LABEL_134:
  double v80 = v235 - v10;
  double v81 = vabdd_f64(v235, v10);
  double v82 = 180.0;
  if (v81 == 180.0) {
    goto LABEL_135;
  }
  if (COERCE_UNSIGNED_INT64(fabs(v235 - v10)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v86 = fabs(v81 + -180.0);
    double v82 = 180.0;
    double v87 = v81 >= 180.0 ? v81 : 180.0;
    double v88 = v87 >= 1.0 ? v87 * 2.22044605e-16 : 2.22044605e-16;
    if (v86 <= v88) {
      goto LABEL_135;
    }
  }
  double v82 = 180.0;
  if (v80 <= 180.0)
  {
    double v83 = v235 - v10;
    if (v80 >= -180.0) {
      goto LABEL_136;
    }
    double v150 = v9;
    long double v151 = fmod(v80 + -180.0, 360.0);
    double v9 = v150;
    double v80 = v235 - v10;
    double v82 = v151 + 180.0;
LABEL_135:
    double v83 = v82;
    goto LABEL_136;
  }
  double v89 = v9;
  long double v90 = fmod(v80 + 180.0, 360.0);
  double v9 = v89;
  double v80 = v235 - v10;
  double v83 = v90 + -180.0;
  if (v83 == -180.0) {
    goto LABEL_135;
  }
  BOOL v91 = ((*(void *)&v83 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
     && (*(void *)&v83 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
  if (!v91 || *(void *)&v83 == 0)
  {
    double v82 = 180.0;
    double v93 = fabs(v83 + 180.0);
    double v94 = fabs(v83);
    if (v94 < 180.0) {
      double v94 = 180.0;
    }
    double v95 = v94 >= 1.0 ? v94 * 2.22044605e-16 : 2.22044605e-16;
    if (v93 <= v95) {
      goto LABEL_135;
    }
  }
LABEL_136:
  double v84 = 180.0;
  if (v83 == 180.0) {
    goto LABEL_137;
  }
  if ((*(void *)&v83 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    int v99 = v30 ^ 1;
    char v100 = 1;
    if (((v30 ^ 1) & 1) != 0 || !v79) {
      goto LABEL_206;
    }
LABEL_304:
    if ((v233 > v9 || v232 < v9) && (v232 > v9 || v233 < v9) || ((v26 | v31) & 1) == 0) {
      return *(unsigned char *)(a4 + 16) == 0;
    }
    goto LABEL_314;
  }
  double v96 = fabs(v83 + -180.0);
  double v97 = fabs(v83);
  if (v97 < 180.0) {
    double v97 = 180.0;
  }
  if (v97 >= 1.0) {
    double v98 = v97 * 2.22044605e-16;
  }
  else {
    double v98 = 2.22044605e-16;
  }
  if (v96 > v98)
  {
    int v99 = v30 ^ 1;
    char v100 = 1;
    if (((v30 ^ 1) & 1) != 0 || !v79) {
      goto LABEL_206;
    }
    goto LABEL_304;
  }
LABEL_137:
  double v85 = fabs(v9);
  if (v85 == 90.0
    || (v30 |= v79, (*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    && ((double v101 = fabs(v85 + -90.0), v85 >= 90.0) ? (v102 = v85) : (v102 = 90.0),
        v102 >= 1.0 ? (double v103 = v102 * 2.22044605e-16) : (double v103 = 2.22044605e-16),
        v101 <= v103))
  {
    int v30 = 1;
  }
  if (v30)
  {
    if (180.0 - v233 - v232 <= 180.0)
    {
      if (v233 <= v9) {
        char v148 = v17;
      }
      else {
        char v148 = 0;
      }
      if ((v148 & 1) == 0)
      {
        char v170 = v232 <= v9 ? v24 : 0;
        if ((v170 & 1) == 0 && v9 != 90.0)
        {
          if ((*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
            || ((double v171 = fabs(v9 + -90.0), v85 >= 90.0) ? (v172 = v85) : (v172 = 90.0),
                v172 >= 1.0 ? (double v173 = v172 * 2.22044605e-16) : (double v173 = 2.22044605e-16),
                v171 > v173))
          {
            if ((v17 | v24)) {
              return *(unsigned char *)(a4 + 16) == 0;
            }
            if (v9 == -90.0) {
              goto LABEL_383;
            }
            if ((*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
              return *(unsigned char *)(a4 + 16) == 0;
            }
            double v109 = v9 + 90.0;
            goto LABEL_377;
          }
        }
      }
    }
    else
    {
      if (v233 >= v9) {
        char v104 = v17;
      }
      else {
        char v104 = 0;
      }
      if ((v104 & 1) == 0)
      {
        char v105 = v232 >= v9 ? v24 : 0;
        if ((v105 & 1) == 0 && v9 != -90.0)
        {
          if ((*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
            || ((double v106 = fabs(v9 + 90.0), v85 >= 90.0) ? (v107 = v85) : (v107 = 90.0),
                v107 >= 1.0 ? (double v108 = v107 * 2.22044605e-16) : (double v108 = 2.22044605e-16),
                v106 > v108))
          {
            if ((v17 | v24)) {
              return *(unsigned char *)(a4 + 16) == 0;
            }
            if (v9 == 90.0)
            {
LABEL_383:
              int v99 = 0;
              char v100 = 0;
              int v30 = 1;
              BOOL v79 = 1;
              goto LABEL_206;
            }
            if ((*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
              return *(unsigned char *)(a4 + 16) == 0;
            }
            double v109 = v9 + -90.0;
LABEL_377:
            double v174 = fabs(v109);
            if (v85 < 90.0) {
              double v85 = 90.0;
            }
            if (v85 >= 1.0) {
              double v175 = v85 * 2.22044605e-16;
            }
            else {
              double v175 = 2.22044605e-16;
            }
            if (v174 > v175) {
              return *(unsigned char *)(a4 + 16) == 0;
            }
            goto LABEL_383;
          }
        }
      }
    }
LABEL_314:
    *(unsigned char *)(a4 + 16) = 1;
    return *(unsigned char *)(a4 + 16) == 0;
  }
  char v100 = 0;
  int v99 = v30 ^ 1;
  BOOL v79 = v30;
LABEL_206:
  if (v11 == 180.0) {
    goto LABEL_207;
  }
  if ((*(void *)&v234 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v119 = fabs(v11 + -180.0);
    double v84 = 180.0;
    double v120 = v11 >= 180.0 ? v11 : 180.0;
    double v121 = v120 >= 1.0 ? v120 * 2.22044605e-16 : 2.22044605e-16;
    if (v119 <= v121) {
      goto LABEL_207;
    }
  }
  double v84 = 180.0;
  if (v234 <= 180.0)
  {
    if (v234 >= -180.0) {
      goto LABEL_208;
    }
    double v176 = v9;
    long double v177 = fmod(v234 + -180.0, 360.0);
    double v9 = v176;
    double v84 = v177 + 180.0;
LABEL_207:
    double v234 = v84;
    goto LABEL_208;
  }
  double v122 = v9;
  double v123 = fmod(v234 + 180.0, 360.0);
  double v9 = v122;
  double v234 = v123 + -180.0;
  if (v123 + -180.0 == -180.0) {
    goto LABEL_207;
  }
  BOOL v124 = (unint64_t)(COERCE__INT64(fabs(v123 + -180.0)) - 0x10000000000000) >> 53 > 0x3FE
      && (unint64_t)(COERCE__INT64(fabs(v123 + -180.0)) - 1) > 0xFFFFFFFFFFFFELL;
  if (!v124 || *(void *)&v234 == 0)
  {
    double v84 = 180.0;
    double v126 = fabs(v234 + 180.0);
    double v127 = fabs(v234);
    if (v127 < 180.0) {
      double v127 = 180.0;
    }
    double v128 = v127 >= 1.0 ? v127 * 2.22044605e-16 : 2.22044605e-16;
    if (v126 <= v128) {
      goto LABEL_207;
    }
  }
LABEL_208:
  if ((v100 & 1) == 0)
  {
    if (v234 >= 0.0) {
      int v111 = 2;
    }
    else {
      int v111 = -2;
    }
    if (v234 >= 0.0) {
      int v117 = 1;
    }
    else {
      int v117 = -1;
    }
    if (180.0 - v233 - v232 > 180.0) {
      int v118 = v117;
    }
    else {
      int v118 = -v117;
    }
    goto LABEL_231;
  }
  double v110 = 180.0;
  if (v81 == 180.0) {
    goto LABEL_210;
  }
  if ((*(void *)&v80 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v152 = fabs(v81 + -180.0);
    double v110 = 180.0;
    double v153 = v81 >= 180.0 ? v81 : 180.0;
    double v154 = v153 >= 1.0 ? v153 * 2.22044605e-16 : 2.22044605e-16;
    if (v152 <= v154) {
      goto LABEL_210;
    }
  }
  double v110 = 180.0;
  if (v80 <= 180.0)
  {
    if (v80 >= -180.0) {
      goto LABEL_211;
    }
    double v208 = v9;
    long double v209 = fmod(v80 + -180.0, 360.0);
    double v9 = v208;
    double v110 = v209 + 180.0;
LABEL_210:
    double v80 = v110;
    goto LABEL_211;
  }
  double v155 = v9;
  double v156 = fmod(v80 + 180.0, 360.0);
  double v9 = v155;
  double v80 = v156 + -180.0;
  if (v156 + -180.0 == -180.0) {
    goto LABEL_210;
  }
  unint64_t v157 = COERCE__INT64(fabs(v156 + -180.0)) - 1;
  BOOL v158 = (unint64_t)(COERCE__INT64(fabs(v156 + -180.0)) - 0x10000000000000) >> 53 > 0x3FE
      && v157 > 0xFFFFFFFFFFFFELL;
  if (!v158 || *(void *)&v80 == 0)
  {
    double v110 = 180.0;
    double v160 = fabs(v80 + 180.0);
    double v161 = fabs(v80);
    if (v161 < 180.0) {
      double v161 = 180.0;
    }
    double v162 = v161 >= 1.0 ? v161 * 2.22044605e-16 : 2.22044605e-16;
    if (v160 <= v162) {
      goto LABEL_210;
    }
  }
LABEL_211:
  if (v79 | v30)
  {
    if (v80 >= 0.0) {
      int v111 = 1;
    }
    else {
      int v111 = -1;
    }
    double v112 = 180.0;
    double v113 = v8 + 180.0;
    if (v30) {
      double v114 = v10;
    }
    else {
      double v114 = v235;
    }
    double v115 = vabdd_f64(v114, v113);
    if (v115 != 180.0)
    {
      double v116 = v114 - v113;
      if ((*(void *)&v116 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        goto LABEL_407;
      }
      double v186 = fabs(v115 + -180.0);
      double v112 = 180.0;
      if (v115 < 180.0) {
        double v115 = 180.0;
      }
      double v187 = v115 >= 1.0 ? v115 * 2.22044605e-16 : 2.22044605e-16;
      if (v186 > v187)
      {
LABEL_407:
        double v112 = 180.0;
        if (v116 <= 180.0)
        {
          if (v116 >= -180.0) {
            goto LABEL_220;
          }
          double v220 = v9;
          long double v221 = fmod(v116 + -180.0, 360.0);
          double v9 = v220;
          double v112 = v221 + 180.0;
        }
        else
        {
          double v188 = v9;
          long double v189 = fmod(v116 + 180.0, 360.0);
          double v9 = v188;
          double v116 = v189 + -180.0;
          if (v116 != -180.0)
          {
            BOOL v190 = ((*(void *)&v116 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
                && (*(void *)&v116 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
            if (v190 && *(void *)&v116 != 0) {
              goto LABEL_220;
            }
            double v112 = 180.0;
            double v192 = fabs(v116 + 180.0);
            double v193 = fabs(v116);
            if (v193 < 180.0) {
              double v193 = 180.0;
            }
            double v194 = v193 >= 1.0 ? v193 * 2.22044605e-16 : 2.22044605e-16;
            if (v192 > v194)
            {
LABEL_220:
              if (v116 != 0.0)
              {
                if ((*(void *)&v116 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                  goto LABEL_428;
                }
                double v195 = fabs(v116);
                double v196 = 2.22044605e-16;
                if (v195 >= 1.0) {
                  double v196 = v195 * 2.22044605e-16;
                }
                if (v195 > v196)
                {
LABEL_428:
                  if (v99) {
                    double v197 = a3;
                  }
                  else {
                    double v197 = a2;
                  }
                  double v198 = v197[1];
                  if (v9 == v198) {
                    goto LABEL_446;
                  }
                  double v199 = *v197;
                  if ((*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                    && (*(void *)&v198 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                  {
                    double v200 = vabdd_f64(v9, v198);
                    double v201 = fabs(v9);
                    double v202 = fabs(v198);
                    if (v201 < v202) {
                      double v201 = v202;
                    }
                    double v203 = v201 >= 1.0 ? v201 * 2.22044605e-16 : 2.22044605e-16;
                    if (v200 <= v203) {
                      goto LABEL_446;
                    }
                  }
                  *(double *)double v237 = *v197;
                  *(double *)&v237[1] = v198;
                  *(double *)&v236[1] = v198;
                  double v204 = -1.0;
                  if (v80 >= 0.0) {
                    double v204 = 1.0;
                  }
                  double v205 = v204 + v199;
                  double v206 = fabs(v205);
                  double v207 = 180.0;
                  if (v206 != 180.0)
                  {
                    BOOL v222 = ((*(void *)&v205 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
                        && (*(void *)&v205 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
                    if (v222 && *(void *)&v205 != 0) {
                      goto LABEL_500;
                    }
                    double v224 = fabs(v206 + -180.0);
                    double v207 = 180.0;
                    if (v206 < 180.0) {
                      double v206 = 180.0;
                    }
                    double v225 = v206 >= 1.0 ? v206 * 2.22044605e-16 : 2.22044605e-16;
                    if (v224 > v225)
                    {
LABEL_500:
                      double v207 = 180.0;
                      if (v205 <= 180.0)
                      {
                        if (v205 >= -180.0) {
                          goto LABEL_444;
                        }
                        double v207 = fmod(v205 + -180.0, 360.0) + 180.0;
                      }
                      else
                      {
                        double v205 = fmod(v205 + 180.0, 360.0) + -180.0;
                        if (v205 != -180.0)
                        {
                          BOOL v226 = ((*(void *)&v205 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
                              && (*(void *)&v205 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
                          if (v226 && *(void *)&v205 != 0) {
                            goto LABEL_444;
                          }
                          double v207 = 180.0;
                          double v228 = fabs(v205 + 180.0);
                          double v229 = fabs(v205);
                          if (v229 < 180.0) {
                            double v229 = 180.0;
                          }
                          double v230 = v229 >= 1.0 ? v229 * 2.22044605e-16 : 2.22044605e-16;
                          if (v228 > v230) {
                            goto LABEL_444;
                          }
                        }
                      }
                    }
                  }
                  double v205 = v207;
LABEL_444:
                  *(double *)int v236 = v205;
                  double v167 = (double *)v237;
                  double v168 = (double *)v236;
                  double v169 = v231;
                  goto LABEL_445;
                }
              }
              goto LABEL_221;
            }
          }
        }
      }
    }
    double v116 = v112;
    goto LABEL_220;
  }
  if (v234 >= 0.0) {
    int v163 = 0;
  }
  else {
    int v163 = -1;
  }
  if (v80 >= 0.0) {
    int v164 = 0;
  }
  else {
    int v164 = -1;
  }
  if (v80 > 0.0) {
    int v165 = 1;
  }
  else {
    int v165 = v164;
  }
  BOOL v166 = v165 == v163;
  if (v234 > 0.0) {
    BOOL v166 = v80 > 0.0;
  }
  if (!v166 || fabs(v234) >= fabs(v80))
  {
    double v178 = 180.0;
    double v179 = vabdd_f64(v8 + 180.0, v10);
    if (v179 != 180.0)
    {
      double v180 = v8 + 180.0 - v10;
      unint64_t v210 = COERCE__INT64(fabs(v180)) - 1;
      BOOL v211 = (unint64_t)(COERCE__INT64(fabs(v180)) - 0x10000000000000) >> 53 > 0x3FE
          && v210 > 0xFFFFFFFFFFFFELL;
      if (v211 && *(void *)&v180 != 0) {
        goto LABEL_463;
      }
      double v213 = fabs(v179 + -180.0);
      double v178 = 180.0;
      if (v179 < 180.0) {
        double v179 = 180.0;
      }
      double v214 = v179 >= 1.0 ? v179 * 2.22044605e-16 : 2.22044605e-16;
      if (v213 > v214)
      {
LABEL_463:
        double v178 = 180.0;
        if (v180 <= 180.0)
        {
          if (v180 >= -180.0) {
            goto LABEL_388;
          }
          double v178 = fmod(v180 + -180.0, 360.0) + 180.0;
        }
        else
        {
          double v180 = fmod(v180 + 180.0, 360.0) + -180.0;
          if (v180 != -180.0)
          {
            BOOL v215 = ((*(void *)&v180 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
                && (*(void *)&v180 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
            if (v215 && *(void *)&v180 != 0) {
              goto LABEL_388;
            }
            double v178 = 180.0;
            double v217 = fabs(v180 + 180.0);
            double v218 = fabs(v180);
            if (v218 < 180.0) {
              double v218 = 180.0;
            }
            double v219 = v218 >= 1.0 ? v218 * 2.22044605e-16 : 2.22044605e-16;
            if (v217 > v219) {
              goto LABEL_388;
            }
          }
        }
      }
    }
    double v180 = v178;
LABEL_388:
    BOOL v181 = v80 > 0.0;
    if (v180 >= 0.0) {
      int v182 = 0;
    }
    else {
      int v182 = -1;
    }
    BOOL v183 = v165 == v182;
    if (v180 <= 0.0) {
      BOOL v181 = v183;
    }
    if (!v181 || fabs(v180) >= fabs(v80)) {
      return *(unsigned char *)(a4 + 16) == 0;
    }
    if (v80 >= 0.0) {
      int v111 = 2;
    }
    else {
      int v111 = -2;
    }
LABEL_221:
    *(_DWORD *)(a4 + 4) -= v111;
    *(_DWORD *)(a4 + 12) -= v111;
    return *(unsigned char *)(a4 + 16) == 0;
  }
  if (v80 >= 0.0) {
    int v111 = 2;
  }
  else {
    int v111 = -2;
  }
  double v167 = a2;
  double v168 = a3;
  double v169 = v231;
LABEL_445:
  int v118 = sub_1012472B0(v167, v168, v169);
  if (v118)
  {
LABEL_231:
    if (v118 * v111 >= 1) {
      *(_DWORD *)a4 += v111;
    }
    *(_DWORD *)(a4 + 8) += v111;
    return *(unsigned char *)(a4 + 16) == 0;
  }
LABEL_446:
  BOOL result = 0;
  *(unsigned char *)(a4 + 16) = 1;
  *(_DWORD *)a4 = 0;
  return result;
}

void sub_10124B898(unint64_t a1, char *a2, uint64_t a3, uint64_t a4, char a5)
{
  while (2)
  {
    uint64_t v137 = (uint64_t)(a2 - 40);
    double v133 = (long long *)(a2 - 120);
    double v134 = (long long *)(a2 - 80);
    double v12 = (char *)a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = (unint64_t)v12;
          uint64_t v13 = a2 - v12;
          unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - v12) >> 3);
          if (v6 || !v5)
          {
            switch(v14)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (sub_10124C23C(a3, (void *)v137, (void *)a1))
                {
                  long long v58 = *(_OWORD *)a1;
                  long long v59 = *(_OWORD *)(a1 + 16);
                  uint64_t v144 = *(void *)(a1 + 32);
                  long long v142 = v58;
                  long long v143 = v59;
                  long long v60 = *(_OWORD *)v137;
                  long long v61 = *(_OWORD *)(v137 + 16);
                  *(void *)(a1 + 32) = *(void *)(v137 + 32);
                  *(_OWORD *)a1 = v60;
                  *(_OWORD *)(a1 + 16) = v61;
                  long long v62 = v142;
                  long long v63 = v143;
                  *(void *)(v137 + 32) = v144;
                  *(_OWORD *)uint64_t v137 = v62;
                  *(_OWORD *)(v137 + 16) = v63;
                }
                break;
              case 3uLL:
                sub_10124C50C((long long *)a1, (long long *)(a1 + 40), (long long *)v137, a3);
                break;
              case 4uLL:
                sub_10124CB1C(a1, a1 + 40, a1 + 80, v137, a3);
                break;
              case 5uLL:
                sub_10124CC08(a1, a1 + 40, a1 + 80, a1 + 120, v137, a3);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v13 <= 959)
          {
            double v64 = (char *)(a1 + 40);
            BOOL v66 = (char *)a1 == a2 || v64 == a2;
            if (a5)
            {
              if (!v66)
              {
                uint64_t v67 = 0;
                double v68 = (void *)a1;
                do
                {
                  double v69 = v68;
                  double v68 = v64;
                  if (sub_10124C23C(a3, v64, v69))
                  {
                    long long v70 = *(_OWORD *)v68;
                    long long v71 = *((_OWORD *)v68 + 1);
                    uint64_t v144 = v68[4];
                    long long v142 = v70;
                    long long v143 = v71;
                    uint64_t v72 = v67;
                    while (1)
                    {
                      uint64_t v73 = a1 + v72;
                      long long v74 = *(_OWORD *)(a1 + v72 + 16);
                      *(_OWORD *)(v73 + 40) = *(_OWORD *)(a1 + v72);
                      *(_OWORD *)(v73 + 56) = v74;
                      *(void *)(v73 + 72) = *(void *)(a1 + v72 + 32);
                      if (!v72) {
                        break;
                      }
                      v72 -= 40;
                      if ((sub_10124C23C(a3, &v142, (void *)(v72 + a1)) & 1) == 0)
                      {
                        uint64_t v75 = a1 + v72 + 40;
                        goto LABEL_80;
                      }
                    }
                    uint64_t v75 = a1;
LABEL_80:
                    long long v76 = v142;
                    long long v77 = v143;
                    *(void *)(v75 + 32) = v144;
                    *(_OWORD *)uint64_t v75 = v76;
                    *(_OWORD *)(v75 + 16) = v77;
                  }
                  double v64 = (char *)(v68 + 5);
                  v67 += 40;
                }
                while (v68 + 5 != (void *)a2);
              }
            }
            else if (!v66)
            {
              unint64_t v124 = a1 - 40;
              do
              {
                double v125 = (void *)a1;
                a1 = (unint64_t)v64;
                if (sub_10124C23C(a3, v64, v125))
                {
                  long long v126 = *(_OWORD *)a1;
                  long long v127 = *(_OWORD *)(a1 + 16);
                  uint64_t v144 = *(void *)(a1 + 32);
                  long long v142 = v126;
                  long long v143 = v127;
                  unint64_t v128 = v124;
                  do
                  {
                    long long v129 = *(_OWORD *)(v128 + 56);
                    *(_OWORD *)(v128 + 80) = *(_OWORD *)(v128 + 40);
                    *(_OWORD *)(v128 + 96) = v129;
                    *(void *)(v128 + 112) = *(void *)(v128 + 72);
                    char v130 = sub_10124C23C(a3, &v142, (void *)v128);
                    v128 -= 40;
                  }
                  while ((v130 & 1) != 0);
                  long long v131 = v142;
                  long long v132 = v143;
                  *(void *)(v128 + 112) = v144;
                  *(_OWORD *)(v128 + 80) = v131;
                  *(_OWORD *)(v128 + 96) = v132;
                }
                double v64 = (char *)(a1 + 40);
                v124 += 40;
              }
              while ((char *)(a1 + 40) != a2);
            }
            return;
          }
          if (!a4)
          {
            if ((char *)a1 != a2)
            {
              int64_t v78 = (v14 - 2) >> 1;
              double v135 = a2;
              int64_t v138 = v78;
              do
              {
                int64_t v79 = v78;
                if (v138 >= v78)
                {
                  uint64_t v80 = (2 * v78) | 1;
                  unint64_t v81 = a1 + 40 * v80;
                  if (2 * v78 + 2 < (uint64_t)v14
                    && sub_10124C23C(a3, (void *)(a1 + 40 * v80), (void *)(v81 + 40)))
                  {
                    v81 += 40;
                    uint64_t v80 = 2 * v79 + 2;
                  }
                  unint64_t v82 = a1 + 40 * v79;
                  if ((sub_10124C23C(a3, (void *)v81, (void *)v82) & 1) == 0)
                  {
                    long long v83 = *(_OWORD *)v82;
                    long long v84 = *(_OWORD *)(v82 + 16);
                    uint64_t v144 = *(void *)(v82 + 32);
                    long long v142 = v83;
                    long long v143 = v84;
                    do
                    {
                      unint64_t v85 = v81;
                      long long v86 = *(_OWORD *)v81;
                      long long v87 = *(_OWORD *)(v81 + 16);
                      *(void *)(v82 + 32) = *(void *)(v81 + 32);
                      *(_OWORD *)unint64_t v82 = v86;
                      *(_OWORD *)(v82 + 16) = v87;
                      if (v138 < v80) {
                        break;
                      }
                      uint64_t v88 = (2 * v80) | 1;
                      unint64_t v81 = a1 + 40 * v88;
                      uint64_t v89 = 2 * v80 + 2;
                      if (v89 < (uint64_t)v14
                        && sub_10124C23C(a3, (void *)(a1 + 40 * v88), (void *)(v81 + 40)))
                      {
                        v81 += 40;
                        uint64_t v88 = v89;
                      }
                      unint64_t v82 = v85;
                      uint64_t v80 = v88;
                    }
                    while (!sub_10124C23C(a3, (void *)v81, &v142));
                    long long v90 = v142;
                    long long v91 = v143;
                    *(void *)(v85 + 32) = v144;
                    *(_OWORD *)unint64_t v85 = v90;
                    *(_OWORD *)(v85 + 16) = v91;
                    a2 = v135;
                  }
                }
                int64_t v78 = v79 - 1;
              }
              while (v79);
              int64_t v92 = v13 / 0x28uLL;
              do
              {
                uint64_t v93 = 0;
                long long v94 = *(_OWORD *)a1;
                long long v95 = *(_OWORD *)(a1 + 16);
                uint64_t v141 = *(void *)(a1 + 32);
                long long v139 = v94;
                long long v140 = v95;
                uint64_t v96 = v92 - 2;
                double v136 = a2;
                if (v92 < 2) {
                  uint64_t v96 = v92 - 1;
                }
                uint64_t v97 = v96 >> 1;
                unint64_t v98 = a1;
                do
                {
                  uint64_t v99 = v98 + 40 * v93 + 40;
                  uint64_t v100 = (2 * v93) | 1;
                  uint64_t v101 = 2 * v93 + 2;
                  if (v101 < v92
                    && sub_10124C23C(a3, (void *)(v98 + 40 * v93 + 40), (void *)(v98 + 40 * v93 + 80)))
                  {
                    v99 += 40;
                    uint64_t v100 = v101;
                  }
                  long long v102 = *(_OWORD *)v99;
                  long long v103 = *(_OWORD *)(v99 + 16);
                  *(void *)(v98 + 32) = *(void *)(v99 + 32);
                  *(_OWORD *)unint64_t v98 = v102;
                  *(_OWORD *)(v98 + 16) = v103;
                  unint64_t v98 = v99;
                  uint64_t v93 = v100;
                }
                while (v100 <= v97);
                char v104 = v136 - 40;
                if ((char *)v99 == v136 - 40)
                {
                  double v109 = v136 - 40;
                  long long v121 = v139;
                  long long v122 = v140;
                  *(void *)(v99 + 32) = v141;
                  *(_OWORD *)uint64_t v99 = v121;
                  *(_OWORD *)(v99 + 16) = v122;
                  int64_t v111 = v92 - 1;
                }
                else
                {
                  long long v105 = *(_OWORD *)v104;
                  long long v106 = *(_OWORD *)(v136 - 24);
                  *(void *)(v99 + 32) = *((void *)v136 - 1);
                  *(_OWORD *)uint64_t v99 = v105;
                  *(_OWORD *)(v99 + 16) = v106;
                  long long v107 = v139;
                  long long v108 = v140;
                  *((void *)v136 - 1) = v141;
                  *(_OWORD *)char v104 = v107;
                  *(_OWORD *)(v136 - 24) = v108;
                  double v109 = v136 - 40;
                  uint64_t v110 = v99 - a1 + 40;
                  int64_t v111 = v92 - 1;
                  if (v110 >= 41)
                  {
                    unint64_t v112 = (v110 / 0x28uLL - 2) >> 1;
                    unint64_t v113 = a1 + 40 * v112;
                    if (sub_10124C23C(a3, (void *)v113, (void *)v99))
                    {
                      long long v114 = *(_OWORD *)v99;
                      long long v115 = *(_OWORD *)(v99 + 16);
                      uint64_t v144 = *(void *)(v99 + 32);
                      long long v142 = v114;
                      long long v143 = v115;
                      do
                      {
                        uint64_t v116 = v113;
                        long long v117 = *(_OWORD *)v113;
                        long long v118 = *(_OWORD *)(v113 + 16);
                        *(void *)(v99 + 32) = *(void *)(v113 + 32);
                        *(_OWORD *)uint64_t v99 = v117;
                        *(_OWORD *)(v99 + 16) = v118;
                        if (!v112) {
                          break;
                        }
                        unint64_t v112 = (v112 - 1) >> 1;
                        unint64_t v113 = a1 + 40 * v112;
                        uint64_t v99 = v116;
                      }
                      while ((sub_10124C23C(a3, (void *)v113, &v142) & 1) != 0);
                      long long v119 = v142;
                      long long v120 = v143;
                      *(void *)(v116 + 32) = v144;
                      *(_OWORD *)uint64_t v116 = v119;
                      *(_OWORD *)(v116 + 16) = v120;
                    }
                  }
                }
                BOOL v123 = v92 <= 2;
                int64_t v92 = v111;
                a2 = v109;
              }
              while (!v123);
            }
            return;
          }
          uint64_t v15 = (uint64_t)a2;
          unint64_t v16 = a1 + 40 * (v14 >> 1);
          if ((unint64_t)v13 >= 0x1401)
          {
            sub_10124C50C((long long *)a1, (long long *)(a1 + 40 * (v14 >> 1)), (long long *)v137, a3);
            sub_10124C50C((long long *)(a1 + 40), (long long *)(a1 + 40 * (v14 >> 1) - 40), v134, a3);
            sub_10124C50C((long long *)(a1 + 80), (long long *)(a1 + 40 + 40 * (v14 >> 1)), v133, a3);
            sub_10124C50C((long long *)(a1 + 40 * (v14 >> 1) - 40), (long long *)v16, (long long *)(a1 + 40 + 40 * (v14 >> 1)), a3);
            long long v17 = *(_OWORD *)a1;
            long long v18 = *(_OWORD *)(a1 + 16);
            uint64_t v144 = *(void *)(a1 + 32);
            long long v142 = v17;
            long long v143 = v18;
            long long v19 = *(_OWORD *)v16;
            long long v20 = *(_OWORD *)(v16 + 16);
            *(void *)(a1 + 32) = *(void *)(v16 + 32);
            *(_OWORD *)a1 = v19;
            *(_OWORD *)(a1 + 16) = v20;
            long long v21 = v142;
            long long v22 = v143;
            *(void *)(v16 + 32) = v144;
            *(_OWORD *)unint64_t v16 = v21;
            *(_OWORD *)(v16 + 16) = v22;
          }
          else
          {
            sub_10124C50C((long long *)(a1 + 40 * (v14 >> 1)), (long long *)a1, (long long *)v137, a3);
          }
          --a4;
          if (a5 & 1) != 0 || (sub_10124C23C(a3, (void *)(a1 - 40), (void *)a1)) {
            break;
          }
          long long v42 = *(_OWORD *)a1;
          long long v43 = *(_OWORD *)(a1 + 16);
          uint64_t v141 = *(void *)(a1 + 32);
          long long v139 = v42;
          long long v140 = v43;
          if (sub_10124C23C(a3, &v139, (void *)v137))
          {
            double v12 = (char *)a1;
            do
              v12 += 40;
            while ((sub_10124C23C(a3, &v139, v12) & 1) == 0);
          }
          else
          {
            double v44 = (char *)(a1 + 40);
            do
            {
              double v12 = v44;
              if (v44 >= a2) {
                break;
              }
              int v45 = sub_10124C23C(a3, &v139, v44);
              double v44 = v12 + 40;
            }
            while (!v45);
          }
          BOOL v46 = a2;
          if (v12 < a2)
          {
            BOOL v46 = a2;
            do
              v46 -= 40;
            while ((sub_10124C23C(a3, &v139, v46) & 1) != 0);
          }
          while (v12 < v46)
          {
            long long v47 = *(_OWORD *)v12;
            long long v48 = *((_OWORD *)v12 + 1);
            uint64_t v144 = *((void *)v12 + 4);
            long long v142 = v47;
            long long v143 = v48;
            long long v49 = *(_OWORD *)v46;
            long long v50 = *((_OWORD *)v46 + 1);
            *((void *)v12 + 4) = *((void *)v46 + 4);
            *(_OWORD *)double v12 = v49;
            *((_OWORD *)v12 + 1) = v50;
            long long v51 = v142;
            long long v52 = v143;
            *((void *)v46 + 4) = v144;
            *(_OWORD *)BOOL v46 = v51;
            *((_OWORD *)v46 + 1) = v52;
            do
              v12 += 40;
            while (!sub_10124C23C(a3, &v139, v12));
            do
              v46 -= 40;
            while ((sub_10124C23C(a3, &v139, v46) & 1) != 0);
          }
          unint64_t v53 = (long long *)(v12 - 40);
          BOOL v5 = (unint64_t)(v12 - 40) >= a1;
          BOOL v6 = v12 - 40 == (char *)a1;
          if (v12 - 40 != (char *)a1)
          {
            long long v54 = *v53;
            long long v55 = *(_OWORD *)(v12 - 24);
            *(void *)(a1 + 32) = *((void *)v12 - 1);
            *(_OWORD *)a1 = v54;
            *(_OWORD *)(a1 + 16) = v55;
          }
          a5 = 0;
          long long v56 = v139;
          long long v57 = v140;
          *((void *)v12 - 1) = v141;
          *unint64_t v53 = v56;
          *(_OWORD *)(v12 - 24) = v57;
        }
        uint64_t v23 = 0;
        long long v24 = *(_OWORD *)a1;
        long long v25 = *(_OWORD *)(a1 + 16);
        uint64_t v141 = *(void *)(a1 + 32);
        long long v139 = v24;
        long long v140 = v25;
        do
          v23 += 40;
        while ((sub_10124C23C(a3, (void *)(v23 + a1), &v139) & 1) != 0);
        unint64_t v26 = a1 + v23;
        double v27 = (void *)v15;
        BOOL v6 = v23 == 40;
        a2 = (char *)v15;
        if (v6)
        {
          double v27 = (void *)v15;
          do
          {
            if (v26 >= (unint64_t)v27) {
              break;
            }
            v27 -= 5;
          }
          while ((sub_10124C23C(a3, v27, &v139) & 1) == 0);
        }
        else
        {
          do
            v27 -= 5;
          while (!sub_10124C23C(a3, v27, &v139));
        }
        if (v26 < (unint64_t)v27)
        {
          double v28 = v27;
          unint64_t v29 = v26;
          do
          {
            long long v30 = *(_OWORD *)v29;
            long long v31 = *(_OWORD *)(v29 + 16);
            uint64_t v144 = *(void *)(v29 + 32);
            long long v142 = v30;
            long long v143 = v31;
            long long v32 = *(_OWORD *)v28;
            long long v33 = *((_OWORD *)v28 + 1);
            *(void *)(v29 + 32) = v28[4];
            *(_OWORD *)unint64_t v29 = v32;
            *(_OWORD *)(v29 + 16) = v33;
            long long v34 = v142;
            long long v35 = v143;
            v28[4] = v144;
            *(_OWORD *)double v28 = v34;
            *((_OWORD *)v28 + 1) = v35;
            do
              v29 += 40;
            while ((sub_10124C23C(a3, (void *)v29, &v139) & 1) != 0);
            do
              v28 -= 5;
            while (!sub_10124C23C(a3, v28, &v139));
          }
          while (v29 < (unint64_t)v28);
          uint64_t v36 = v29 - 40;
        }
        else
        {
          uint64_t v36 = v26 - 40;
        }
        if (v36 != a1)
        {
          long long v37 = *(_OWORD *)v36;
          long long v38 = *(_OWORD *)(v36 + 16);
          *(void *)(a1 + 32) = *(void *)(v36 + 32);
          *(_OWORD *)a1 = v37;
          *(_OWORD *)(a1 + 16) = v38;
        }
        long long v39 = v139;
        long long v40 = v140;
        *(void *)(v36 + 32) = v141;
        *(_OWORD *)uint64_t v36 = v39;
        *(_OWORD *)(v36 + 16) = v40;
        if (v26 >= (unint64_t)v27) {
          break;
        }
LABEL_32:
        sub_10124B898(a1, v36, a3, a4, a5 & 1);
        a5 = 0;
        double v12 = (char *)(v36 + 40);
      }
      BOOL v41 = sub_10124C644(a1, v36, a3);
      double v12 = (char *)(v36 + 40);
      if (sub_10124C644(v36 + 40, v15, a3)) {
        break;
      }
      if (!v41) {
        goto LABEL_32;
      }
    }
    a2 = (char *)v36;
    if (!v41) {
      continue;
    }
    break;
  }
}

uint64_t sub_10124C23C(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a2[4];
  uint64_t v4 = a3[4];
  uint64_t v5 = *(void *)(v3 + 8);
  uint64_t v6 = *(void *)(v4 + 8);
  BOOL v7 = v5 < v6;
  if (v5 != v6) {
    return v7;
  }
  uint64_t v8 = *(void *)(v3 + 32);
  uint64_t v9 = *(void *)(v4 + 32);
  if (v8 != v9
    || *(void *)(v3 + 24) != *(void *)(v4 + 24)
    || *(void *)(v3 + 40) != *(void *)(v4 + 40)
    || *(void *)(v3 + 16) != *(void *)(v4 + 16))
  {
    uint64_t v21 = *(void *)(v3 + 16);
    uint64_t v22 = *(void *)(v4 + 16);
    BOOL v7 = v21 < v22;
    if (v21 == v22)
    {
      uint64_t v23 = *(void *)(v3 + 24);
      uint64_t v24 = *(void *)(v4 + 24);
      BOOL v7 = v23 < v24;
      if (v23 == v24)
      {
        uint64_t v25 = *(void *)(v3 + 40);
        uint64_t v26 = *(void *)(v4 + 40);
        BOOL v27 = v8 < v9;
        BOOL v18 = v25 == v26;
        BOOL v28 = v25 < v26;
        if (v18) {
          return v27;
        }
        else {
          return v28;
        }
      }
    }
    return v7;
  }
  double v10 = *(double *)(v3 + 64);
  double v11 = *(double *)(v4 + 64);
  if (vabdd_f64(v10, v11) >= 50.0) {
    return v10 < v11;
  }
  double v12 = *(double *)(v3 + 56);
  if (v12 == 0.0) {
    __assert_rtn("apply", "segment_ratio.hpp", 89, "lhs.denominator() != Type(0)");
  }
  double v13 = *(double *)(v4 + 56);
  if (v13 == 0.0) {
    __assert_rtn("apply", "segment_ratio.hpp", 90, "rhs.denominator() != Type(0)");
  }
  double v10 = *(double *)(v3 + 48) / v12;
  double v11 = *(double *)(v4 + 48) / v13;
  if (v10 != v11)
  {
    if ((*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      return v10 < v11;
    }
    double v34 = vabdd_f64(v10, v11);
    double v35 = fabs(v10);
    double v36 = fabs(v11);
    if (v35 < v36) {
      double v35 = v36;
    }
    double v37 = v35 >= 1.0 ? v35 * 2.22044605e-16 : 2.22044605e-16;
    if (v34 > v37) {
      return v10 < v11;
    }
  }
  uint64_t v14 = *(void *)(*(void *)a1 + 32);
  uint64_t v15 = *(void *)(*(void *)a1 + 8);
  unint64_t v16 = (_DWORD *)(*(void *)(v15 + (((unint64_t)(v14 + *a2) >> 1) & 0x7FFFFFFFFFFFFFF8))
                 + 376 * ((v14 + *(_DWORD *)a2) & 0xF));
  long long v17 = (_DWORD *)(*(void *)(v15 + (((unint64_t)(*a3 + v14) >> 1) & 0x7FFFFFFFFFFFFFF8))
                 + 376 * ((*(_DWORD *)a3 + v14) & 0xF));
  BOOL v18 = v16[4] == 2 && v17[4] == 2;
  if (v18)
  {
    return sub_10124C85C(a1, a2, a3);
  }
  else
  {
    int v19 = v16[10];
    BOOL v20 = v19 == 3 && v16[52] == 3;
    int v31 = v17[10];
    BOOL v32 = v31 == 3 && v17[52] == 3;
    if (v20 && !v32) {
      return 1;
    }
    if (v20 || !v32)
    {
      BOOL v33 = v19 == 1 && v16[52] == 1;
      BOOL v38 = v31 == 1 && v17[52] == 1;
      if (v33 && !v38) {
        return 1;
      }
      unsigned int v39 = v33 || !v38;
      if (*a2 < *a3) {
        return v39;
      }
      else {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
}

uint64_t sub_10124C50C(long long *a1, long long *a2, long long *a3, uint64_t a4)
{
  char v8 = sub_10124C23C(a4, a2, a1);
  uint64_t result = sub_10124C23C(a4, a3, a2);
  if (v8)
  {
    if (result)
    {
      long long v10 = *a1;
      long long v11 = a1[1];
      uint64_t v12 = *((void *)a1 + 4);
      uint64_t v13 = *((void *)a3 + 4);
      long long v14 = a3[1];
      *a1 = *a3;
      a1[1] = v14;
      *((void *)a1 + 4) = v13;
    }
    else
    {
      long long v25 = *a1;
      long long v26 = a1[1];
      uint64_t v27 = *((void *)a1 + 4);
      uint64_t v28 = *((void *)a2 + 4);
      long long v29 = a2[1];
      *a1 = *a2;
      a1[1] = v29;
      *((void *)a1 + 4) = v28;
      *((void *)a2 + 4) = v27;
      *a2 = v25;
      a2[1] = v26;
      uint64_t result = sub_10124C23C(a4, a3, a2);
      if (!result) {
        return result;
      }
      long long v10 = *a2;
      long long v11 = a2[1];
      uint64_t v12 = *((void *)a2 + 4);
      uint64_t v30 = *((void *)a3 + 4);
      long long v31 = a3[1];
      *a2 = *a3;
      a2[1] = v31;
      *((void *)a2 + 4) = v30;
    }
    *((void *)a3 + 4) = v12;
    *a3 = v10;
    a3[1] = v11;
  }
  else if (result)
  {
    long long v15 = *a2;
    long long v16 = a2[1];
    uint64_t v17 = *((void *)a2 + 4);
    uint64_t v18 = *((void *)a3 + 4);
    long long v19 = a3[1];
    *a2 = *a3;
    a2[1] = v19;
    *((void *)a2 + 4) = v18;
    *((void *)a3 + 4) = v17;
    *a3 = v15;
    a3[1] = v16;
    uint64_t result = sub_10124C23C(a4, a2, a1);
    if (result)
    {
      long long v20 = *a1;
      long long v21 = a1[1];
      uint64_t v22 = *((void *)a1 + 4);
      uint64_t v23 = *((void *)a2 + 4);
      long long v24 = a2[1];
      *a1 = *a2;
      a1[1] = v24;
      *((void *)a1 + 4) = v23;
      *((void *)a2 + 4) = v22;
      *a2 = v20;
      a2[1] = v21;
    }
  }
  return result;
}

BOOL sub_10124C644(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v8 = a2 - 40;
      if (!sub_10124C23C(a3, (void *)(a2 - 40), (void *)a1)) {
        return 1;
      }
      long long v9 = *(_OWORD *)a1;
      long long v10 = *(_OWORD *)(a1 + 16);
      uint64_t v11 = *(void *)(a1 + 32);
      uint64_t v12 = *(void *)(v8 + 32);
      long long v13 = *(_OWORD *)(v8 + 16);
      *(_OWORD *)a1 = *(_OWORD *)v8;
      *(_OWORD *)(a1 + 16) = v13;
      *(void *)(a1 + 32) = v12;
      *(void *)(v8 + 32) = v11;
      BOOL result = 1;
      *(_OWORD *)uint64_t v8 = v9;
      *(_OWORD *)(v8 + 16) = v10;
      return result;
    case 3uLL:
      sub_10124C50C((long long *)a1, (long long *)(a1 + 40), (long long *)(a2 - 40), a3);
      return 1;
    case 4uLL:
      sub_10124CB1C(a1, a1 + 40, a1 + 80, a2 - 40, a3);
      return 1;
    case 5uLL:
      sub_10124CC08(a1, a1 + 40, a1 + 80, a1 + 120, a2 - 40, a3);
      return 1;
    default:
      long long v14 = (void *)(a1 + 80);
      sub_10124C50C((long long *)a1, (long long *)(a1 + 40), (long long *)(a1 + 80), a3);
      uint64_t v15 = a1 + 120;
      if (a1 + 120 == a2) {
        return 1;
      }
      uint64_t v16 = 0;
      int v17 = 0;
      break;
  }
  while (1)
  {
    if (sub_10124C23C(a3, (void *)v15, v14))
    {
      long long v18 = *(_OWORD *)(v15 + 16);
      long long v24 = *(_OWORD *)v15;
      long long v25 = v18;
      uint64_t v26 = *(void *)(v15 + 32);
      uint64_t v19 = v16;
      while (1)
      {
        uint64_t v20 = a1 + v19;
        long long v21 = *(_OWORD *)(a1 + v19 + 96);
        *(_OWORD *)(v20 + 120) = *(_OWORD *)(a1 + v19 + 80);
        *(_OWORD *)(v20 + 136) = v21;
        *(void *)(v20 + 152) = *(void *)(a1 + v19 + 112);
        if (v19 == -80) {
          break;
        }
        v19 -= 40;
        if ((sub_10124C23C(a3, &v24, (void *)(v20 + 40)) & 1) == 0)
        {
          uint64_t v22 = a1 + v19 + 120;
          goto LABEL_12;
        }
      }
      uint64_t v22 = a1;
LABEL_12:
      long long v23 = v25;
      *(_OWORD *)uint64_t v22 = v24;
      *(_OWORD *)(v22 + 16) = v23;
      *(void *)(v22 + 32) = v26;
      if (++v17 == 8) {
        return v15 + 40 == a2;
      }
    }
    long long v14 = (void *)v15;
    v16 += 40;
    v15 += 40;
    if (v15 == a2) {
      return 1;
    }
  }
}

BOOL sub_10124C85C(uint64_t a1, void *a2, void *a3)
{
  long long v26 = 0uLL;
  long long v25 = 0uLL;
  uint64_t v6 = *(uint64_t **)(a1 + 8);
  BOOL v7 = *(uint64_t **)(a1 + 16);
  uint64_t v8 = (uint64_t *)(a2[4] + 8);
  if (sub_10124C9DC(v6, v7, v8, 0, &v26)) {
    sub_10124C9DC(v6, v7, v8, 1, &v25);
  }
  long long v24 = 0uLL;
  long long v23 = 0uLL;
  long long v9 = *(uint64_t **)(a1 + 8);
  long long v10 = *(uint64_t **)(a1 + 16);
  uint64_t v11 = (uint64_t *)a2[3];
  if (sub_10124C9DC(v9, v10, v11, 0, &v24)) {
    sub_10124C9DC(v9, v10, v11, 1, &v23);
  }
  long long v22 = 0uLL;
  long long v21 = 0uLL;
  long long v13 = *(uint64_t **)(a1 + 8);
  uint64_t v12 = *(uint64_t **)(a1 + 16);
  long long v14 = (uint64_t *)a3[3];
  if (sub_10124C9DC(v13, v12, v14, 0, &v22)) {
    sub_10124C9DC(v13, v12, v14, 1, &v21);
  }
  int v15 = sub_1012472B0((double *)&v26, (double *)&v25, (double *)&v23);
  int v16 = sub_1012472B0((double *)&v26, (double *)&v25, (double *)&v21);
  BOOL v17 = v15 < v16;
  if (v15 == v16)
  {
    int v18 = sub_1012472B0((double *)&v24, (double *)&v23, (double *)&v21);
    int v19 = sub_1012472B0((double *)&v22, (double *)&v21, (double *)&v23);
    BOOL v17 = v19 < v18;
    if (v19 == v18) {
      return *a2 < *a3;
    }
  }
  return v17;
}

uint64_t sub_10124C9DC(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, _OWORD *a5)
{
  uint64_t v5 = *a3;
  if ((unint64_t)*a3 >= 2) {
    __assert_rtn("copy_segment_point", "copy_segment_point.hpp", 317, "seg_id.source_index == 0 || seg_id.source_index == 1");
  }
  if (v5 != 1)
  {
    if (v5) {
      return 0;
    }
    unint64_t v6 = a3[2];
    if ((v6 & 0x8000000000000000) != 0) {
      goto LABEL_7;
    }
    uint64_t v7 = a1[3];
    if (0xAAAAAAAAAAAAAAABLL * ((a1[4] - v7) >> 3) >= v6)
    {
      a1 = (uint64_t *)(v7 + 24 * v6);
LABEL_7:
      uint64_t v8 = *a1;
      uint64_t v9 = a1[1];
      goto LABEL_12;
    }
LABEL_19:
    __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
  }
  unint64_t v10 = a3[2];
  if ((v10 & 0x8000000000000000) == 0)
  {
    uint64_t v11 = a2[3];
    if (0xAAAAAAAAAAAAAAABLL * ((a2[4] - v11) >> 3) < v10) {
      goto LABEL_19;
    }
    a2 = (uint64_t *)(v11 + 24 * v10);
  }
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
LABEL_12:
  unint64_t v12 = (v9 - v8) >> 4;
  uint64_t v13 = (a3[3] + a4) % (uint64_t)(v12 - 1);
  uint64_t v14 = ((v12 - 1) & (v13 >> 63)) + v13;
  if (v14 < 0 || v14 >= v12) {
    __assert_rtn("apply", "copy_segment_point.hpp", 74, "target >= 0 && std::size_t(target) < boost::size(view)");
  }
  *a5 = *(_OWORD *)(v8 + 16 * v14);
  return 1;
}

__n128 sub_10124CB1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_10124C50C((long long *)a1, (long long *)a2, (long long *)a3, a5);
  if (sub_10124C23C(a5, (void *)a4, (void *)a3))
  {
    long long v11 = *(_OWORD *)a3;
    long long v12 = *(_OWORD *)(a3 + 16);
    uint64_t v13 = *(void *)(a3 + 32);
    uint64_t v14 = *(void *)(a4 + 32);
    long long v15 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 16) = v15;
    *(void *)(a3 + 32) = v14;
    *(void *)(a4 + 32) = v13;
    *(_OWORD *)a4 = v11;
    *(_OWORD *)(a4 + 16) = v12;
    if (sub_10124C23C(a5, (void *)a3, (void *)a2))
    {
      long long v16 = *(_OWORD *)a2;
      long long v17 = *(_OWORD *)(a2 + 16);
      uint64_t v18 = *(void *)(a2 + 32);
      uint64_t v19 = *(void *)(a3 + 32);
      long long v20 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 16) = v20;
      *(void *)(a2 + 32) = v19;
      *(void *)(a3 + 32) = v18;
      *(_OWORD *)a3 = v16;
      *(_OWORD *)(a3 + 16) = v17;
      if (sub_10124C23C(a5, (void *)a2, (void *)a1))
      {
        __n128 result = *(__n128 *)a1;
        long long v21 = *(_OWORD *)(a1 + 16);
        uint64_t v22 = *(void *)(a1 + 32);
        uint64_t v23 = *(void *)(a2 + 32);
        long long v24 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v24;
        *(void *)(a1 + 32) = v23;
        *(void *)(a2 + 32) = v22;
        *(__n128 *)a2 = result;
        *(_OWORD *)(a2 + 16) = v21;
      }
    }
  }
  return result;
}

__n128 sub_10124CC08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  sub_10124CB1C(a1, a2, a3, a4, a6);
  if (sub_10124C23C(a6, (void *)a5, (void *)a4))
  {
    long long v13 = *(_OWORD *)a4;
    long long v14 = *(_OWORD *)(a4 + 16);
    uint64_t v15 = *(void *)(a4 + 32);
    uint64_t v16 = *(void *)(a5 + 32);
    long long v17 = *(_OWORD *)(a5 + 16);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_OWORD *)(a4 + 16) = v17;
    *(void *)(a4 + 32) = v16;
    *(void *)(a5 + 32) = v15;
    *(_OWORD *)a5 = v13;
    *(_OWORD *)(a5 + 16) = v14;
    if (sub_10124C23C(a6, (void *)a4, (void *)a3))
    {
      long long v18 = *(_OWORD *)a3;
      long long v19 = *(_OWORD *)(a3 + 16);
      uint64_t v20 = *(void *)(a3 + 32);
      uint64_t v21 = *(void *)(a4 + 32);
      long long v22 = *(_OWORD *)(a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)(a3 + 16) = v22;
      *(void *)(a3 + 32) = v21;
      *(void *)(a4 + 32) = v20;
      *(_OWORD *)a4 = v18;
      *(_OWORD *)(a4 + 16) = v19;
      if (sub_10124C23C(a6, (void *)a3, (void *)a2))
      {
        __n128 v23 = *(__n128 *)a2;
        long long v24 = *(_OWORD *)(a2 + 16);
        uint64_t v25 = *(void *)(a2 + 32);
        uint64_t v26 = *(void *)(a3 + 32);
        long long v27 = *(_OWORD *)(a3 + 16);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_OWORD *)(a2 + 16) = v27;
        *(void *)(a2 + 32) = v26;
        *(void *)(a3 + 32) = v25;
        *(__n128 *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        if (sub_10124C23C(a6, (void *)a2, (void *)a1))
        {
          __n128 result = *(__n128 *)a1;
          long long v28 = *(_OWORD *)(a1 + 16);
          uint64_t v29 = *(void *)(a1 + 32);
          uint64_t v30 = *(void *)(a2 + 32);
          long long v31 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 16) = v31;
          *(void *)(a1 + 32) = v30;
          *(void *)(a2 + 32) = v29;
          *(__n128 *)a2 = result;
          *(_OWORD *)(a2 + 16) = v28;
        }
      }
    }
  }
  return result;
}

void sub_10124CD34(uint64_t a1, double *a2)
{
  unint64_t v4 = *(void *)a1;
  uint64_t v5 = *(long long **)(a1 + 8);
  unint64_t v6 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * ((uint64_t)((uint64_t)v5 - v4) >> 4));
  uint64_t v7 = (long long *)(a1 + 24);
  v33[0] = (double *)(a1 + 24);
  v33[1] = a2;
  v33[2] = (double *)(a1 + 56);
  if (v5 == (long long *)v4) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = v6;
  }
  sub_10124D670(v4, v5, v33, v8, 1);
  unint64_t v9 = *(void *)a1;
  uint64_t v10 = *(void *)(a1 + 8);
  if (v10 != *(void *)a1)
  {
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    uint64_t v13 = 0;
    while (!v12)
    {
LABEL_22:
      *(void *)(v9 + v11 + 16) = v13;
      ++v12;
      v11 += 112;
      if (v12 >= 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v10 - v9) >> 4)) {
        return;
      }
    }
    long long v14 = (double *)(v9 + v11);
    uint64_t v15 = (double *)(v9 + v11 - 112);
    int v16 = sub_1012472B0((double *)(a1 + 24), a2, v15);
    int v17 = sub_1012472B0((double *)(a1 + 24), a2, v14);
    if (!(v16 | v17))
    {
      long long v18 = *((_OWORD *)v14 - 7);
      long long v19 = *v7;
      long long v35 = *(_OWORD *)a2;
      long long v36 = v19;
      long long v34 = v18;
      int v20 = sub_10124E930((double *)&v36, (double *)&v35, (double *)&v34);
      long long v21 = *(_OWORD *)v14;
      long long v22 = *v7;
      long long v35 = *(_OWORD *)a2;
      long long v36 = v22;
      long long v34 = v21;
      BOOL v23 = v20 < (int)sub_10124E930((double *)&v36, (double *)&v35, (double *)&v34);
      goto LABEL_18;
    }
    int v24 = v17;
    if (!v16
      && (long long v25 = *(_OWORD *)v15,
          long long v26 = *v7,
          long long v35 = *(_OWORD *)a2,
          long long v36 = v26,
          long long v34 = v25,
          sub_10124E930((double *)&v36, (double *)&v35, (double *)&v34) == -1))
    {
      unsigned int v32 = 1;
    }
    else
    {
      if (v24
        || (long long v27 = *(_OWORD *)v14,
            long long v28 = *v7,
            long long v35 = *(_OWORD *)a2,
            long long v36 = v28,
            long long v34 = v27,
            sub_10124E930((double *)&v36, (double *)&v35, (double *)&v34) != -1))
      {
        BOOL v23 = v16 < v24;
        if (v16 != v24)
        {
LABEL_18:
          unsigned int v32 = v23;
          goto LABEL_21;
        }
        int v29 = sub_1012472B0(a2, v15, v14);
        if (v29)
        {
          int v30 = v29;
          int v31 = sub_1012472B0(a2, v14, v15);
          if (v30 + v31) {
            BOOL v23 = 0;
          }
          else {
            BOOL v23 = v31 < v30;
          }
          goto LABEL_18;
        }
      }
      unsigned int v32 = 0;
    }
LABEL_21:
    v13 += v32;
    unint64_t v9 = *(void *)a1;
    uint64_t v10 = *(void *)(a1 + 8);
    goto LABEL_22;
  }
}

double sub_10124CF68(unint64_t *a1, double *a2, int *a3, uint64_t a4, int a5, uint64_t *a6, uint64_t *a7, int a8)
{
  long long v89 = 0uLL;
  long long v88 = 0uLL;
  long long v87 = 0uLL;
  long long v14 = a3 + 2;
  if (sub_10124C9DC(a6, a7, (uint64_t *)a3 + 1, 0, &v89)
    && sub_10124C9DC(a6, a7, (uint64_t *)v14, 1, &v88))
  {
    sub_10124C9DC(a6, a7, (uint64_t *)v14, 2, &v87);
  }
  double v15 = *((double *)a3 + 6);
  double v16 = *((double *)a3 + 7);
  if (v15 == v16) {
    goto LABEL_5;
  }
  if ((*(void *)&v15 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (*(void *)&v16 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    goto LABEL_14;
  }
  double v18 = vabdd_f64(v15, v16);
  double v19 = fabs(v15);
  double v20 = fabs(v16);
  if (v19 < v20) {
    double v19 = v20;
  }
  double v21 = v19 >= 1.0 ? v19 * 2.22044605e-16 : 2.22044605e-16;
  if (v18 <= v21) {
LABEL_5:
  }
    int v17 = (double *)&v87;
  else {
LABEL_14:
  }
    int v17 = (double *)&v88;
  double v23 = *v17;
  double v22 = v17[1];
  uint64_t v24 = -1;
  double v26 = *((double *)&v89 + 1);
  double v25 = *(double *)&v89;
  while (1)
  {
    double v28 = *a2;
    double v27 = a2[1];
    double v29 = fabs(v25);
    double v30 = fabs(*a2);
    double v31 = fabs(v26);
    double v32 = fabs(v27);
    if (v29 < v30) {
      double v29 = v30;
    }
    if (v29 < v31) {
      double v29 = v31;
    }
    if (v29 < v32) {
      double v29 = v32;
    }
    double v33 = v29 >= 1.0 ? v29 * 1000000000.0 : 1000000000.0;
    if (v25 != v28
      && ((*(void *)&v25 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
       || (*(void *)&v28 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
       || vabdd_f64(v25, v28) > v33 * 2.22044605e-16))
    {
      break;
    }
    if (v26 == v27)
    {
      BOOL v34 = 1;
    }
    else
    {
      if ((*(void *)&v26 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (*(void *)&v27 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        break;
      }
      BOOL v34 = vabdd_f64(v26, v27) <= v33 * 2.22044605e-16;
    }
    if (v24 + 1 < -9 || !v34) {
      break;
    }
    *(_OWORD *)long long v90 = 0uLL;
    sub_10124C9DC(a6, a7, (uint64_t *)v14, v24, v90);
    double v26 = *(double *)&v90[8];
    double v25 = *(double *)v90;
    --v24;
  }
  *(double *)&long long v89 = v25;
  *((double *)&v89 + 1) = v26;
  for (uint64_t i = 1; ; ++i)
  {
    double v36 = fabs(v23);
    double v37 = fabs(v28);
    double v38 = fabs(v22);
    double v39 = fabs(v27);
    if (v36 < v37) {
      double v36 = v37;
    }
    if (v36 < v38) {
      double v36 = v38;
    }
    if (v36 < v39) {
      double v36 = v39;
    }
    double v40 = v36 >= 1.0 ? v36 * 1000000000.0 : 1000000000.0;
    if (v23 != v28
      && ((*(void *)&v23 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
       || (*(void *)&v28 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
       || vabdd_f64(v23, v28) > v40 * 2.22044605e-16))
    {
      break;
    }
    if (v22 == v27)
    {
      BOOL v41 = 1;
    }
    else
    {
      if ((*(void *)&v22 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (*(void *)&v27 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        break;
      }
      BOOL v41 = vabdd_f64(v22, v27) <= v40 * 2.22044605e-16;
    }
    if ((unint64_t)(i - 1) > 9 || !v41) {
      break;
    }
    *(_OWORD *)long long v90 = 0uLL;
    sub_10124C9DC(a6, a7, (uint64_t *)v14, i, v90);
    double v22 = *(double *)&v90[8];
    double v23 = *(double *)v90;
    double v28 = *a2;
    double v27 = a2[1];
  }
  int v42 = *a3;
  long long v43 = *((_OWORD *)v14 + 1);
  *(_OWORD *)&v90[4] = *(_OWORD *)v14;
  *(_OWORD *)&v90[20] = v43;
  *(void *)&v90[36] = *((void *)v14 + 4);
  double v44 = (char *)a1[1];
  int v45 = (char *)a1[2];
  if (v44 >= v45)
  {
    uint64_t v49 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)&v44[-*a1] >> 4);
    unint64_t v50 = v49 + 1;
    if ((unint64_t)(v49 + 1) > 0x249249249249249) {
      goto LABEL_94;
    }
    unint64_t v51 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)&v45[-*a1] >> 4);
    if (2 * v51 > v50) {
      unint64_t v50 = 2 * v51;
    }
    if (v51 >= 0x124924924924924) {
      unint64_t v52 = 0x249249249249249;
    }
    else {
      unint64_t v52 = v50;
    }
    if (v52) {
      unint64_t v52 = (unint64_t)sub_10124D624(v52);
    }
    else {
      uint64_t v53 = 0;
    }
    unint64_t v54 = v52 + 112 * v49;
    *(_OWORD *)unint64_t v54 = v89;
    *(_OWORD *)(v54 + 16) = xmmword_1014C33B0;
    long long v55 = *(_OWORD *)&v90[16];
    *(_OWORD *)(v54 + 68) = *(_OWORD *)v90;
    unint64_t v56 = v52 + 112 * v53;
    *(void *)(v54 + 32) = a4;
    int v47 = a5;
    *(_DWORD *)(v54 + 40) = a5;
    *(void *)(v54 + 52) = 0;
    *(void *)(v54 + 44) = 0;
    *(_DWORD *)(v54 + 60) = 0;
    *(_DWORD *)(v54 + 64) = v42;
    *(_OWORD *)(v54 + 84) = v55;
    *(_OWORD *)(v54 + 96) = *(_OWORD *)&v90[28];
    unint64_t v48 = v54 + 112;
    long long v58 = (char *)*a1;
    long long v57 = (char *)a1[1];
    if (v57 != (char *)*a1)
    {
      do
      {
        long long v59 = *((_OWORD *)v57 - 7);
        long long v60 = *((_OWORD *)v57 - 5);
        *(_OWORD *)(v54 - 96) = *((_OWORD *)v57 - 6);
        *(_OWORD *)(v54 - 80) = v60;
        *(_OWORD *)(v54 - 112) = v59;
        long long v61 = *((_OWORD *)v57 - 4);
        long long v62 = *((_OWORD *)v57 - 3);
        long long v63 = *((_OWORD *)v57 - 1);
        *(_OWORD *)(v54 - 32) = *((_OWORD *)v57 - 2);
        *(_OWORD *)(v54 - 16) = v63;
        *(_OWORD *)(v54 - 64) = v61;
        *(_OWORD *)(v54 - 48) = v62;
        v54 -= 112;
        v57 -= 112;
      }
      while (v57 != v58);
      long long v57 = (char *)*a1;
    }
    *a1 = v54;
    a1[1] = v48;
    a1[2] = v56;
    if (v57) {
      operator delete(v57);
    }
  }
  else
  {
    *(_OWORD *)double v44 = v89;
    *((_OWORD *)v44 + 1) = xmmword_1014C33B0;
    long long v46 = *(_OWORD *)&v90[16];
    *(_OWORD *)(v44 + 68) = *(_OWORD *)v90;
    *((void *)v44 + 4) = a4;
    int v47 = a5;
    *((_DWORD *)v44 + 10) = a5;
    *(void *)(v44 + 52) = 0;
    *(void *)(v44 + 44) = 0;
    *((_DWORD *)v44 + 15) = 0;
    *((_DWORD *)v44 + 16) = v42;
    *(_OWORD *)(v44 + 84) = v46;
    unint64_t v48 = (unint64_t)(v44 + 112);
    *((_OWORD *)v44 + 6) = *(_OWORD *)&v90[28];
  }
  a1[1] = v48;
  if (a8)
  {
    *(_OWORD *)(a1 + 3) = v89;
    ++a1[5];
  }
  int v64 = *a3;
  long long v65 = *((_OWORD *)v14 + 1);
  *(_OWORD *)&v90[4] = *(_OWORD *)v14;
  *(_OWORD *)&v90[20] = v65;
  *(void *)&v90[36] = *((void *)v14 + 4);
  BOOL v66 = (char *)a1[2];
  if (v48 < (unint64_t)v66)
  {
    *(double *)unint64_t v48 = v23;
    *(double *)(v48 + 8) = v22;
    *(_OWORD *)(v48 + 16) = xmmword_1014C33B0;
    *(void *)(v48 + 32) = a4;
    *(_DWORD *)(v48 + 40) = v47;
    *(_DWORD *)(v48 + 44) = 1;
    *(void *)(v48 + 48) = 0;
    *(void *)(v48 + 56) = 0;
    *(_DWORD *)(v48 + 64) = v64;
    long long v67 = *(_OWORD *)&v90[16];
    *(_OWORD *)(v48 + 68) = *(_OWORD *)v90;
    *(_OWORD *)(v48 + 84) = v67;
    *(_OWORD *)(v48 + 96) = *(_OWORD *)&v90[28];
    unint64_t v68 = v48 + 112;
    goto LABEL_93;
  }
  uint64_t v69 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v48 - *a1) >> 4);
  if ((unint64_t)(v69 + 1) > 0x249249249249249) {
LABEL_94:
  }
    sub_10006A748();
  unint64_t v70 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)&v66[-*a1] >> 4);
  uint64_t v71 = 2 * v70;
  if (2 * v70 <= v69 + 1) {
    uint64_t v71 = v69 + 1;
  }
  if (v70 >= 0x124924924924924) {
    unint64_t v72 = 0x249249249249249;
  }
  else {
    unint64_t v72 = v71;
  }
  if (v72) {
    unint64_t v72 = (unint64_t)sub_10124D624(v72);
  }
  else {
    uint64_t v73 = 0;
  }
  unint64_t v74 = v72 + 112 * v69;
  unint64_t v75 = v72 + 112 * v73;
  *(double *)unint64_t v74 = v23;
  *(double *)(v74 + 8) = v22;
  *(_OWORD *)(v74 + 16) = xmmword_1014C33B0;
  *(void *)(v74 + 32) = a4;
  *(_DWORD *)(v74 + 40) = v47;
  *(_DWORD *)(v74 + 44) = 1;
  *(void *)(v74 + 48) = 0;
  *(void *)(v74 + 56) = 0;
  *(_DWORD *)(v74 + 64) = v64;
  long long v76 = *(_OWORD *)&v90[16];
  *(_OWORD *)(v74 + 68) = *(_OWORD *)v90;
  *(_OWORD *)(v74 + 84) = v76;
  *(_OWORD *)(v74 + 96) = *(_OWORD *)&v90[28];
  unint64_t v68 = v74 + 112;
  int64_t v78 = (char *)*a1;
  long long v77 = (char *)a1[1];
  if (v77 != (char *)*a1)
  {
    do
    {
      long long v79 = *((_OWORD *)v77 - 7);
      long long v80 = *((_OWORD *)v77 - 5);
      *(_OWORD *)(v74 - 96) = *((_OWORD *)v77 - 6);
      *(_OWORD *)(v74 - 80) = v80;
      *(_OWORD *)(v74 - 112) = v79;
      long long v81 = *((_OWORD *)v77 - 4);
      long long v82 = *((_OWORD *)v77 - 3);
      long long v83 = *((_OWORD *)v77 - 1);
      *(_OWORD *)(v74 - 32) = *((_OWORD *)v77 - 2);
      *(_OWORD *)(v74 - 16) = v83;
      *(_OWORD *)(v74 - 64) = v81;
      *(_OWORD *)(v74 - 48) = v82;
      v74 -= 112;
      v77 -= 112;
    }
    while (v77 != v78);
    long long v77 = (char *)*a1;
  }
  *a1 = v74;
  a1[1] = v68;
  a1[2] = v75;
  if (v77) {
    operator delete(v77);
  }
LABEL_93:
  a1[1] = v68;
  return v25;
}

void *sub_10124D624(unint64_t a1)
{
  if (a1 >= 0x24924924924924ALL) {
    sub_10006A7CC();
  }
  return operator new(112 * a1);
}

void sub_10124D670(unint64_t a1, long long *a2, double **a3, uint64_t a4, char a5)
{
  while (2)
  {
    unint64_t v12 = a2 - 7;
    double v239 = a2;
    double v241 = (double *)(a2 - 14);
    double v238 = (double *)(a2 - 21);
    unint64_t v13 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v13;
          uint64_t v14 = (uint64_t)a2 - v13;
          uint64_t v15 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)((uint64_t)a2 - v13) >> 4);
          if (v6 || !v5)
          {
            switch(v15)
            {
              case 0:
              case 1:
                return;
              case 2:
                if (sub_10124E250(a3, (double *)v12, (double *)a1))
                {
                  long long v105 = *(_OWORD *)a1;
                  long long v106 = *(_OWORD *)(a1 + 32);
                  long long v251 = *(_OWORD *)(a1 + 16);
                  long long v252 = v106;
                  long long v250 = v105;
                  long long v107 = *(_OWORD *)(a1 + 48);
                  long long v108 = *(_OWORD *)(a1 + 64);
                  long long v109 = *(_OWORD *)(a1 + 96);
                  long long v255 = *(_OWORD *)(a1 + 80);
                  long long v256 = v109;
                  long long v253 = v107;
                  long long v254 = v108;
                  long long v110 = v12[6];
                  long long v112 = v12[3];
                  long long v111 = v12[4];
                  *(_OWORD *)(a1 + 80) = v12[5];
                  *(_OWORD *)(a1 + 96) = v110;
                  *(_OWORD *)(a1 + 48) = v112;
                  *(_OWORD *)(a1 + 64) = v111;
                  long long v113 = *v12;
                  long long v114 = v12[2];
                  *(_OWORD *)(a1 + 16) = v12[1];
                  *(_OWORD *)(a1 + 32) = v114;
                  *(_OWORD *)a1 = v113;
                  long long v115 = v250;
                  long long v116 = v252;
                  v12[1] = v251;
                  v12[2] = v116;
                  *unint64_t v12 = v115;
                  long long v117 = v253;
                  long long v118 = v254;
                  long long v119 = v256;
                  v12[5] = v255;
                  v12[6] = v119;
                  _OWORD v12[3] = v117;
                  v12[4] = v118;
                }
                break;
              case 3:
                sub_10124E444((double *)a1, (double *)(a1 + 112), (double *)v12, a3);
                break;
              case 4:
                sub_10124F1FC((double *)a1, (double *)(a1 + 112), (double *)(a1 + 224), (double *)v12, a3);
                break;
              case 5:
                sub_10124F3A8((double *)a1, (double *)(a1 + 112), (double *)(a1 + 224), (double *)(a1 + 336), (double *)v12, a3);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v14 <= 2687)
          {
            long long v120 = (double *)(a1 + 112);
            BOOL v122 = (long long *)a1 == a2 || v120 == (double *)a2;
            if (a5)
            {
              if (!v122)
              {
                uint64_t v123 = 0;
                unint64_t v124 = (double *)a1;
                do
                {
                  double v125 = v124;
                  unint64_t v124 = v120;
                  if (sub_10124E250(a3, v120, v125))
                  {
                    long long v126 = *(_OWORD *)v124;
                    long long v127 = *((_OWORD *)v124 + 2);
                    long long v251 = *((_OWORD *)v124 + 1);
                    long long v252 = v127;
                    long long v250 = v126;
                    long long v128 = *((_OWORD *)v124 + 3);
                    long long v129 = *((_OWORD *)v124 + 4);
                    long long v130 = *((_OWORD *)v124 + 6);
                    long long v255 = *((_OWORD *)v124 + 5);
                    long long v256 = v130;
                    long long v253 = v128;
                    long long v254 = v129;
                    uint64_t v131 = v123;
                    while (1)
                    {
                      long long v132 = (_OWORD *)(a1 + v131);
                      long long v133 = *(_OWORD *)(a1 + v131 + 80);
                      v132[11] = *(_OWORD *)(a1 + v131 + 64);
                      v132[12] = v133;
                      v132[13] = *(_OWORD *)(a1 + v131 + 96);
                      long long v134 = *(_OWORD *)(a1 + v131 + 16);
                      v132[7] = *(_OWORD *)(a1 + v131);
                      v132[8] = v134;
                      long long v135 = *(_OWORD *)(a1 + v131 + 48);
                      v132[9] = *(_OWORD *)(a1 + v131 + 32);
                      v132[10] = v135;
                      if (!v131) {
                        break;
                      }
                      v131 -= 112;
                      if ((sub_10124E250(a3, (double *)&v250, (double *)(v131 + a1)) & 1) == 0)
                      {
                        double v136 = (_OWORD *)(a1 + v131 + 112);
                        goto LABEL_80;
                      }
                    }
                    double v136 = (_OWORD *)a1;
LABEL_80:
                    long long v137 = v250;
                    long long v138 = v252;
                    v136[1] = v251;
                    v136[2] = v138;
                    *double v136 = v137;
                    long long v139 = v253;
                    long long v140 = v254;
                    long long v141 = v256;
                    v136[5] = v255;
                    v136[6] = v141;
                    v136[3] = v139;
                    v136[4] = v140;
                  }
                  long long v120 = v124 + 14;
                  v123 += 112;
                }
                while (v124 + 14 != (double *)a2);
              }
            }
            else if (!v122)
            {
              unint64_t v221 = a1 - 112;
              do
              {
                BOOL v222 = (double *)a1;
                a1 = (unint64_t)v120;
                if (sub_10124E250(a3, v120, v222))
                {
                  long long v223 = *(_OWORD *)a1;
                  long long v224 = *(_OWORD *)(a1 + 32);
                  long long v251 = *(_OWORD *)(a1 + 16);
                  long long v252 = v224;
                  long long v250 = v223;
                  long long v225 = *(_OWORD *)(a1 + 48);
                  long long v226 = *(_OWORD *)(a1 + 64);
                  long long v227 = *(_OWORD *)(a1 + 96);
                  long long v255 = *(_OWORD *)(a1 + 80);
                  long long v256 = v227;
                  long long v253 = v225;
                  long long v254 = v226;
                  unint64_t v228 = v221;
                  do
                  {
                    long long v229 = *(_OWORD *)(v228 + 192);
                    *(_OWORD *)(v228 + 288) = *(_OWORD *)(v228 + 176);
                    *(_OWORD *)(v228 + 304) = v229;
                    *(_OWORD *)(v228 + 320) = *(_OWORD *)(v228 + 208);
                    long long v230 = *(_OWORD *)(v228 + 128);
                    *(_OWORD *)(v228 + 224) = *(_OWORD *)(v228 + 112);
                    *(_OWORD *)(v228 + 240) = v230;
                    long long v231 = *(_OWORD *)(v228 + 160);
                    *(_OWORD *)(v228 + 256) = *(_OWORD *)(v228 + 144);
                    *(_OWORD *)(v228 + 272) = v231;
                    char v232 = sub_10124E250(a3, (double *)&v250, (double *)v228);
                    v228 -= 112;
                  }
                  while ((v232 & 1) != 0);
                  long long v233 = v250;
                  long long v234 = v252;
                  *(_OWORD *)(v228 + 240) = v251;
                  *(_OWORD *)(v228 + 256) = v234;
                  *(_OWORD *)(v228 + 224) = v233;
                  long long v235 = v253;
                  long long v236 = v254;
                  long long v237 = v256;
                  *(_OWORD *)(v228 + 304) = v255;
                  *(_OWORD *)(v228 + 320) = v237;
                  *(_OWORD *)(v228 + 272) = v235;
                  *(_OWORD *)(v228 + 288) = v236;
                }
                long long v120 = (double *)(a1 + 112);
                v221 += 112;
              }
              while ((long long *)(a1 + 112) != a2);
            }
            return;
          }
          if (!a4)
          {
            if ((long long *)a1 != a2)
            {
              int64_t v142 = (unint64_t)(v15 - 2) >> 1;
              int64_t v242 = v142;
              do
              {
                int64_t v143 = v142;
                if (v242 >= v142)
                {
                  uint64_t v144 = (2 * v142) | 1;
                  unint64_t v145 = a1 + 112 * v144;
                  if (2 * v142 + 2 < v15
                    && sub_10124E250(a3, (double *)(a1 + 112 * v144), (double *)(v145 + 112)))
                  {
                    v145 += 112;
                    uint64_t v144 = 2 * v143 + 2;
                  }
                  double v146 = (double *)(a1 + 112 * v143);
                  if ((sub_10124E250(a3, (double *)v145, v146) & 1) == 0)
                  {
                    long long v147 = *(_OWORD *)v146;
                    long long v148 = *((_OWORD *)v146 + 2);
                    long long v251 = *((_OWORD *)v146 + 1);
                    long long v252 = v148;
                    long long v250 = v147;
                    long long v149 = *((_OWORD *)v146 + 3);
                    long long v150 = *((_OWORD *)v146 + 4);
                    long long v151 = *((_OWORD *)v146 + 6);
                    long long v255 = *((_OWORD *)v146 + 5);
                    long long v256 = v151;
                    long long v253 = v149;
                    long long v254 = v150;
                    do
                    {
                      double v152 = (double *)v145;
                      long long v153 = *(_OWORD *)v145;
                      long long v154 = *(_OWORD *)(v145 + 32);
                      *((_OWORD *)v146 + 1) = *(_OWORD *)(v145 + 16);
                      *((_OWORD *)v146 + 2) = v154;
                      *(_OWORD *)double v146 = v153;
                      long long v155 = *(_OWORD *)(v145 + 48);
                      long long v156 = *(_OWORD *)(v145 + 64);
                      long long v157 = *(_OWORD *)(v145 + 96);
                      *((_OWORD *)v146 + 5) = *(_OWORD *)(v145 + 80);
                      *((_OWORD *)v146 + 6) = v157;
                      *((_OWORD *)v146 + 3) = v155;
                      *((_OWORD *)v146 + 4) = v156;
                      if (v242 < v144) {
                        break;
                      }
                      uint64_t v158 = (2 * v144) | 1;
                      unint64_t v145 = a1 + 112 * v158;
                      uint64_t v159 = 2 * v144 + 2;
                      if (v159 < v15
                        && sub_10124E250(a3, (double *)(a1 + 112 * v158), (double *)(v145 + 112)))
                      {
                        v145 += 112;
                        uint64_t v158 = v159;
                      }
                      double v146 = v152;
                      uint64_t v144 = v158;
                    }
                    while (!sub_10124E250(a3, (double *)v145, (double *)&v250));
                    long long v160 = v250;
                    long long v161 = v252;
                    *((_OWORD *)v152 + 1) = v251;
                    *((_OWORD *)v152 + 2) = v161;
                    *(_OWORD *)double v152 = v160;
                    long long v162 = v253;
                    long long v163 = v254;
                    long long v164 = v256;
                    *((_OWORD *)v152 + 5) = v255;
                    *((_OWORD *)v152 + 6) = v164;
                    *((_OWORD *)v152 + 3) = v162;
                    *((_OWORD *)v152 + 4) = v163;
                  }
                }
                int64_t v142 = v143 - 1;
              }
              while (v143);
              uint64_t v165 = (((unint64_t)v14 >> 4) * (unsigned __int128)0x2492492492492493uLL) >> 64;
              BOOL v166 = v239;
              do
              {
                uint64_t v167 = 0;
                long long v168 = *(_OWORD *)a1;
                long long v169 = *(_OWORD *)(a1 + 32);
                long long v244 = *(_OWORD *)(a1 + 16);
                long long v245 = v169;
                long long v243 = v168;
                long long v170 = *(_OWORD *)(a1 + 48);
                long long v171 = *(_OWORD *)(a1 + 64);
                long long v172 = *(_OWORD *)(a1 + 96);
                long long v248 = *(_OWORD *)(a1 + 80);
                long long v249 = v172;
                long long v246 = v170;
                long long v247 = v171;
                uint64_t v173 = v165 - 2;
                uint64_t v240 = v166;
                if (v165 < 2) {
                  uint64_t v173 = v165 - 1;
                }
                uint64_t v174 = v173 >> 1;
                double v175 = (_OWORD *)a1;
                do
                {
                  uint64_t v176 = (uint64_t)&v175[7 * v167 + 7];
                  uint64_t v177 = (2 * v167) | 1;
                  uint64_t v178 = 2 * v167 + 2;
                  if (v178 < v165
                    && sub_10124E250(a3, (double *)&v175[7 * v167 + 7], (double *)&v175[7 * v167 + 14]))
                  {
                    v176 += 112;
                    uint64_t v177 = v178;
                  }
                  long long v179 = *(_OWORD *)v176;
                  long long v180 = *(_OWORD *)(v176 + 32);
                  v175[1] = *(_OWORD *)(v176 + 16);
                  v175[2] = v180;
                  _OWORD *v175 = v179;
                  long long v181 = *(_OWORD *)(v176 + 48);
                  long long v182 = *(_OWORD *)(v176 + 64);
                  long long v183 = *(_OWORD *)(v176 + 96);
                  v175[5] = *(_OWORD *)(v176 + 80);
                  v175[6] = v183;
                  v175[3] = v181;
                  v175[4] = v182;
                  double v175 = (_OWORD *)v176;
                  uint64_t v167 = v177;
                }
                while (v177 <= v174);
                double v184 = v240 - 7;
                if ((long long *)v176 == v240 - 7)
                {
                  BOOL v166 = v240 - 7;
                  long long v215 = v243;
                  long long v216 = v245;
                  *(_OWORD *)(v176 + 16) = v244;
                  *(_OWORD *)(v176 + 32) = v216;
                  *(_OWORD *)uint64_t v176 = v215;
                  long long v217 = v246;
                  long long v218 = v247;
                  long long v219 = v249;
                  *(_OWORD *)(v176 + 80) = v248;
                  *(_OWORD *)(v176 + 96) = v219;
                  *(_OWORD *)(v176 + 48) = v217;
                  *(_OWORD *)(v176 + 64) = v218;
                  uint64_t v196 = v165 - 1;
                }
                else
                {
                  long long v185 = *v184;
                  long long v186 = *(v240 - 5);
                  *(_OWORD *)(v176 + 16) = *(v240 - 6);
                  *(_OWORD *)(v176 + 32) = v186;
                  *(_OWORD *)uint64_t v176 = v185;
                  long long v187 = *(v240 - 4);
                  long long v188 = *(v240 - 3);
                  long long v189 = *(v240 - 1);
                  *(_OWORD *)(v176 + 80) = *(v240 - 2);
                  *(_OWORD *)(v176 + 96) = v189;
                  *(_OWORD *)(v176 + 48) = v187;
                  *(_OWORD *)(v176 + 64) = v188;
                  long long v190 = v249;
                  long long v192 = v246;
                  long long v191 = v247;
                  *(v240 - 2) = v248;
                  *(v240 - 1) = v190;
                  *(v240 - 4) = v192;
                  *(v240 - 3) = v191;
                  long long v193 = v243;
                  long long v194 = v245;
                  *(v240 - 6) = v244;
                  *(v240 - 5) = v194;
                  BOOL v166 = v240 - 7;
                  long long *v184 = v193;
                  uint64_t v195 = v176 - a1 + 112;
                  uint64_t v196 = v165 - 1;
                  if (v195 >= 113)
                  {
                    unint64_t v197 = (unint64_t)(((((unint64_t)v195 >> 4) * (unsigned __int128)0x2492492492492493uLL) >> 64)
                                            - 2) >> 1;
                    double v198 = (_OWORD *)(a1 + 112 * v197);
                    if (sub_10124E250(a3, (double *)v198, (double *)v176))
                    {
                      long long v199 = *(_OWORD *)v176;
                      long long v200 = *(_OWORD *)(v176 + 32);
                      long long v251 = *(_OWORD *)(v176 + 16);
                      long long v252 = v200;
                      long long v250 = v199;
                      long long v201 = *(_OWORD *)(v176 + 48);
                      long long v202 = *(_OWORD *)(v176 + 64);
                      long long v203 = *(_OWORD *)(v176 + 96);
                      long long v255 = *(_OWORD *)(v176 + 80);
                      long long v256 = v203;
                      long long v253 = v201;
                      long long v254 = v202;
                      do
                      {
                        double v204 = v198;
                        long long v205 = *v198;
                        long long v206 = v198[2];
                        *(_OWORD *)(v176 + 16) = v198[1];
                        *(_OWORD *)(v176 + 32) = v206;
                        *(_OWORD *)uint64_t v176 = v205;
                        long long v207 = v198[3];
                        long long v208 = v198[4];
                        long long v209 = v198[6];
                        *(_OWORD *)(v176 + 80) = v198[5];
                        *(_OWORD *)(v176 + 96) = v209;
                        *(_OWORD *)(v176 + 48) = v207;
                        *(_OWORD *)(v176 + 64) = v208;
                        if (!v197) {
                          break;
                        }
                        unint64_t v197 = (v197 - 1) >> 1;
                        double v198 = (_OWORD *)(a1 + 112 * v197);
                        uint64_t v176 = (uint64_t)v204;
                      }
                      while ((sub_10124E250(a3, (double *)v198, (double *)&v250) & 1) != 0);
                      long long v210 = v250;
                      long long v211 = v252;
                      v204[1] = v251;
                      v204[2] = v211;
                      _OWORD *v204 = v210;
                      long long v212 = v253;
                      long long v213 = v254;
                      long long v214 = v256;
                      v204[5] = v255;
                      v204[6] = v214;
                      v204[3] = v212;
                      v204[4] = v213;
                    }
                  }
                }
                BOOL v220 = v165 <= 2;
                uint64_t v165 = v196;
              }
              while (!v220);
            }
            return;
          }
          unint64_t v16 = (unint64_t)v15 >> 1;
          unint64_t v17 = a1 + 112 * ((unint64_t)v15 >> 1);
          if ((unint64_t)v14 < 0x3801)
          {
            sub_10124E444((double *)v17, (double *)a1, (double *)v12, a3);
          }
          else
          {
            sub_10124E444((double *)a1, (double *)v17, (double *)v12, a3);
            uint64_t v18 = 112 * v16;
            sub_10124E444((double *)(a1 + 112), (double *)(v18 + a1 - 112), v241, a3);
            sub_10124E444((double *)(a1 + 224), (double *)(a1 + 112 + v18), v238, a3);
            sub_10124E444((double *)(v18 + a1 - 112), (double *)v17, (double *)(a1 + 112 + v18), a3);
            long long v19 = *(_OWORD *)a1;
            long long v20 = *(_OWORD *)(a1 + 32);
            long long v251 = *(_OWORD *)(a1 + 16);
            long long v252 = v20;
            long long v250 = v19;
            long long v21 = *(_OWORD *)(a1 + 48);
            long long v22 = *(_OWORD *)(a1 + 64);
            long long v23 = *(_OWORD *)(a1 + 96);
            long long v255 = *(_OWORD *)(a1 + 80);
            long long v256 = v23;
            long long v253 = v21;
            long long v254 = v22;
            long long v24 = *(_OWORD *)(v17 + 96);
            long long v26 = *(_OWORD *)(v17 + 48);
            long long v25 = *(_OWORD *)(v17 + 64);
            *(_OWORD *)(a1 + 80) = *(_OWORD *)(v17 + 80);
            *(_OWORD *)(a1 + 96) = v24;
            *(_OWORD *)(a1 + 48) = v26;
            *(_OWORD *)(a1 + 64) = v25;
            long long v27 = *(_OWORD *)v17;
            long long v28 = *(_OWORD *)(v17 + 32);
            *(_OWORD *)(a1 + 16) = *(_OWORD *)(v17 + 16);
            *(_OWORD *)(a1 + 32) = v28;
            *(_OWORD *)a1 = v27;
            long long v29 = v250;
            long long v30 = v252;
            *(_OWORD *)(v17 + 16) = v251;
            *(_OWORD *)(v17 + 32) = v30;
            *(_OWORD *)unint64_t v17 = v29;
            long long v31 = v253;
            long long v32 = v254;
            long long v33 = v256;
            *(_OWORD *)(v17 + 80) = v255;
            *(_OWORD *)(v17 + 96) = v33;
            *(_OWORD *)(v17 + 48) = v31;
            *(_OWORD *)(v17 + 64) = v32;
          }
          --a4;
          if (a5 & 1) != 0 || (sub_10124E250(a3, (double *)(a1 - 112), (double *)a1)) {
            break;
          }
          long long v71 = *(_OWORD *)a1;
          long long v72 = *(_OWORD *)(a1 + 32);
          long long v244 = *(_OWORD *)(a1 + 16);
          long long v245 = v72;
          long long v243 = v71;
          long long v73 = *(_OWORD *)(a1 + 48);
          long long v74 = *(_OWORD *)(a1 + 64);
          long long v75 = *(_OWORD *)(a1 + 96);
          long long v248 = *(_OWORD *)(a1 + 80);
          long long v249 = v75;
          long long v246 = v73;
          long long v247 = v74;
          if (sub_10124E250(a3, (double *)&v243, (double *)v12))
          {
            unint64_t v13 = a1;
            a2 = v239;
            do
              v13 += 112;
            while ((sub_10124E250(a3, (double *)&v243, (double *)v13) & 1) == 0);
          }
          else
          {
            long long v76 = (double *)(a1 + 112);
            a2 = v239;
            do
            {
              unint64_t v13 = (unint64_t)v76;
              if (v76 >= (double *)v239) {
                break;
              }
              int v77 = sub_10124E250(a3, (double *)&v243, v76);
              long long v76 = (double *)(v13 + 112);
            }
            while (!v77);
          }
          int64_t v78 = a2;
          if (v13 < (unint64_t)a2)
          {
            int64_t v78 = a2;
            do
              v78 -= 7;
            while ((sub_10124E250(a3, (double *)&v243, (double *)v78) & 1) != 0);
          }
          while (v13 < (unint64_t)v78)
          {
            long long v79 = *(_OWORD *)v13;
            long long v80 = *(_OWORD *)(v13 + 32);
            long long v251 = *(_OWORD *)(v13 + 16);
            long long v252 = v80;
            long long v250 = v79;
            long long v81 = *(_OWORD *)(v13 + 48);
            long long v82 = *(_OWORD *)(v13 + 64);
            long long v83 = *(_OWORD *)(v13 + 96);
            long long v255 = *(_OWORD *)(v13 + 80);
            long long v256 = v83;
            long long v253 = v81;
            long long v254 = v82;
            long long v84 = v78[6];
            long long v86 = v78[3];
            long long v85 = v78[4];
            *(_OWORD *)(v13 + 80) = v78[5];
            *(_OWORD *)(v13 + 96) = v84;
            *(_OWORD *)(v13 + 48) = v86;
            *(_OWORD *)(v13 + 64) = v85;
            long long v87 = *v78;
            long long v88 = v78[2];
            *(_OWORD *)(v13 + 16) = v78[1];
            *(_OWORD *)(v13 + 32) = v88;
            *(_OWORD *)unint64_t v13 = v87;
            long long v89 = v250;
            long long v90 = v252;
            v78[1] = v251;
            v78[2] = v90;
            *int64_t v78 = v89;
            long long v91 = v253;
            long long v92 = v254;
            long long v93 = v256;
            v78[5] = v255;
            v78[6] = v93;
            v78[3] = v91;
            v78[4] = v92;
            do
              v13 += 112;
            while (!sub_10124E250(a3, (double *)&v243, (double *)v13));
            do
              v78 -= 7;
            while ((sub_10124E250(a3, (double *)&v243, (double *)v78) & 1) != 0);
          }
          long long v94 = (long long *)(v13 - 112);
          BOOL v5 = v13 - 112 >= a1;
          BOOL v6 = v13 - 112 == a1;
          if (v13 - 112 != a1)
          {
            long long v95 = *v94;
            long long v96 = *(_OWORD *)(v13 - 80);
            *(_OWORD *)(a1 + 16) = *(_OWORD *)(v13 - 96);
            *(_OWORD *)(a1 + 32) = v96;
            *(_OWORD *)a1 = v95;
            long long v97 = *(_OWORD *)(v13 - 64);
            long long v98 = *(_OWORD *)(v13 - 48);
            long long v99 = *(_OWORD *)(v13 - 16);
            *(_OWORD *)(a1 + 80) = *(_OWORD *)(v13 - 32);
            *(_OWORD *)(a1 + 96) = v99;
            *(_OWORD *)(a1 + 48) = v97;
            *(_OWORD *)(a1 + 64) = v98;
          }
          a5 = 0;
          long long v100 = v243;
          long long v101 = v245;
          *(_OWORD *)(v13 - 96) = v244;
          *(_OWORD *)(v13 - 80) = v101;
          *long long v94 = v100;
          long long v102 = v246;
          long long v103 = v247;
          long long v104 = v249;
          *(_OWORD *)(v13 - 32) = v248;
          *(_OWORD *)(v13 - 16) = v104;
          *(_OWORD *)(v13 - 64) = v102;
          *(_OWORD *)(v13 - 48) = v103;
        }
        uint64_t v34 = 0;
        long long v35 = *(_OWORD *)a1;
        long long v36 = *(_OWORD *)(a1 + 32);
        long long v244 = *(_OWORD *)(a1 + 16);
        long long v245 = v36;
        long long v243 = v35;
        long long v37 = *(_OWORD *)(a1 + 48);
        long long v38 = *(_OWORD *)(a1 + 64);
        long long v39 = *(_OWORD *)(a1 + 96);
        long long v248 = *(_OWORD *)(a1 + 80);
        long long v249 = v39;
        long long v246 = v37;
        long long v247 = v38;
        do
          v34 += 112;
        while ((sub_10124E250(a3, (double *)(v34 + a1), (double *)&v243) & 1) != 0);
        unint64_t v40 = a1 + v34;
        BOOL v41 = (double *)v239;
        BOOL v6 = v34 == 112;
        a2 = v239;
        if (v6)
        {
          BOOL v41 = (double *)v239;
          do
          {
            if (v40 >= (unint64_t)v41) {
              break;
            }
            v41 -= 14;
          }
          while ((sub_10124E250(a3, v41, (double *)&v243) & 1) == 0);
        }
        else
        {
          do
            v41 -= 14;
          while (!sub_10124E250(a3, v41, (double *)&v243));
        }
        if (v40 >= (unint64_t)v41)
        {
          unint64_t v59 = v40 - 112;
        }
        else
        {
          int v42 = v41;
          unint64_t v43 = v40;
          do
          {
            long long v44 = *(_OWORD *)v43;
            long long v45 = *(_OWORD *)(v43 + 32);
            long long v251 = *(_OWORD *)(v43 + 16);
            long long v252 = v45;
            long long v250 = v44;
            long long v46 = *(_OWORD *)(v43 + 48);
            long long v47 = *(_OWORD *)(v43 + 64);
            long long v48 = *(_OWORD *)(v43 + 96);
            long long v255 = *(_OWORD *)(v43 + 80);
            long long v256 = v48;
            long long v253 = v46;
            long long v254 = v47;
            long long v49 = *((_OWORD *)v42 + 6);
            long long v51 = *((_OWORD *)v42 + 3);
            long long v50 = *((_OWORD *)v42 + 4);
            *(_OWORD *)(v43 + 80) = *((_OWORD *)v42 + 5);
            *(_OWORD *)(v43 + 96) = v49;
            *(_OWORD *)(v43 + 48) = v51;
            *(_OWORD *)(v43 + 64) = v50;
            long long v52 = *(_OWORD *)v42;
            long long v53 = *((_OWORD *)v42 + 2);
            *(_OWORD *)(v43 + 16) = *((_OWORD *)v42 + 1);
            *(_OWORD *)(v43 + 32) = v53;
            *(_OWORD *)unint64_t v43 = v52;
            long long v54 = v250;
            long long v55 = v252;
            *((_OWORD *)v42 + 1) = v251;
            *((_OWORD *)v42 + 2) = v55;
            *(_OWORD *)int v42 = v54;
            long long v56 = v253;
            long long v57 = v254;
            long long v58 = v256;
            *((_OWORD *)v42 + 5) = v255;
            *((_OWORD *)v42 + 6) = v58;
            *((_OWORD *)v42 + 3) = v56;
            *((_OWORD *)v42 + 4) = v57;
            do
              v43 += 112;
            while ((sub_10124E250(a3, (double *)v43, (double *)&v243) & 1) != 0);
            do
              v42 -= 14;
            while (!sub_10124E250(a3, v42, (double *)&v243));
          }
          while (v43 < (unint64_t)v42);
          unint64_t v59 = v43 - 112;
        }
        if (v59 != a1)
        {
          long long v60 = *(_OWORD *)v59;
          long long v61 = *(_OWORD *)(v59 + 32);
          *(_OWORD *)(a1 + 16) = *(_OWORD *)(v59 + 16);
          *(_OWORD *)(a1 + 32) = v61;
          *(_OWORD *)a1 = v60;
          long long v62 = *(_OWORD *)(v59 + 48);
          long long v63 = *(_OWORD *)(v59 + 64);
          long long v64 = *(_OWORD *)(v59 + 96);
          *(_OWORD *)(a1 + 80) = *(_OWORD *)(v59 + 80);
          *(_OWORD *)(a1 + 96) = v64;
          *(_OWORD *)(a1 + 48) = v62;
          *(_OWORD *)(a1 + 64) = v63;
        }
        long long v65 = v243;
        long long v66 = v245;
        *(_OWORD *)(v59 + 16) = v244;
        *(_OWORD *)(v59 + 32) = v66;
        *(_OWORD *)unint64_t v59 = v65;
        long long v67 = v246;
        long long v68 = v247;
        long long v69 = v249;
        *(_OWORD *)(v59 + 80) = v248;
        *(_OWORD *)(v59 + 96) = v69;
        *(_OWORD *)(v59 + 48) = v67;
        *(_OWORD *)(v59 + 64) = v68;
        if (v40 >= (unint64_t)v41) {
          break;
        }
LABEL_32:
        sub_10124D670(a1, v59, a3, a4, a5 & 1);
        a5 = 0;
        unint64_t v13 = v59 + 112;
      }
      BOOL v70 = sub_10124E6A4((double *)a1, (long long *)v59, a3);
      unint64_t v13 = v59 + 112;
      if (sub_10124E6A4((double *)(v59 + 112), v239, a3)) {
        break;
      }
      if (!v70) {
        goto LABEL_32;
      }
    }
    a2 = (long long *)v59;
    if (!v70) {
      continue;
    }
    break;
  }
}

uint64_t sub_10124E250(double **a1, double *a2, double *a3)
{
  int v6 = sub_1012472B0(*a1, a1[1], a2);
  int v7 = sub_1012472B0(*a1, a1[1], a3);
  if (!(v6 | v7))
  {
    long long v8 = *(_OWORD *)*a1;
    long long v31 = *(_OWORD *)a1[1];
    long long v32 = v8;
    long long v30 = *(_OWORD *)a2;
    int v9 = sub_10124E930((double *)&v32, (double *)&v31, (double *)&v30);
    long long v10 = *(_OWORD *)*a1;
    long long v31 = *(_OWORD *)a1[1];
    long long v32 = v10;
    long long v30 = *(_OWORD *)a3;
    int v11 = sub_10124E930((double *)&v32, (double *)&v31, (double *)&v30);
    BOOL v12 = v9 < v11;
    if (v9 != v11) {
      return v12;
    }
LABEL_12:
    int v19 = *((_DWORD *)a2 + 11);
    int v20 = *((_DWORD *)a3 + 11);
    BOOL v12 = v19 < v20;
    if (v19 == v20)
    {
      uint64_t v21 = *((void *)a2 + 4);
      uint64_t v22 = *((void *)a3 + 4);
      BOOL v12 = v21 < v22;
      if (v21 == v22)
      {
        uint64_t v23 = *((void *)a2 + 9);
        uint64_t v24 = *((void *)a3 + 9);
        BOOL v12 = v23 < v24;
        if (v23 == v24)
        {
          uint64_t v25 = *((void *)a2 + 10);
          uint64_t v26 = *((void *)a3 + 10);
          BOOL v12 = v25 < v26;
          if (v25 == v26)
          {
            uint64_t v27 = *((void *)a2 + 11);
            uint64_t v28 = *((void *)a3 + 11);
            BOOL v12 = v27 < v28;
            if (v27 == v28) {
              return *((_OWORD *)a2 + 6) < *((_OWORD *)a3 + 6);
            }
          }
        }
      }
    }
    return v12;
  }
  int v13 = v7;
  if (!v6)
  {
    long long v14 = *(_OWORD *)*a1;
    long long v31 = *(_OWORD *)a1[1];
    long long v32 = v14;
    long long v30 = *(_OWORD *)a2;
    if (sub_10124E930((double *)&v32, (double *)&v31, (double *)&v30) == -1) {
      return 1;
    }
  }
  if (!v13)
  {
    long long v15 = *(_OWORD *)*a1;
    long long v31 = *(_OWORD *)a1[1];
    long long v32 = v15;
    long long v30 = *(_OWORD *)a3;
    if (sub_10124E930((double *)&v32, (double *)&v31, (double *)&v30) == -1) {
      return 0;
    }
  }
  BOOL v12 = v6 < v13;
  if (v6 == v13)
  {
    int v16 = sub_1012472B0(a1[1], a2, a3);
    if (v16)
    {
      int v17 = v16;
      int v18 = sub_1012472B0(a1[1], a3, a2);
      if (!(v17 + v18)) {
        return v18 < v17;
      }
    }
    goto LABEL_12;
  }
  return v12;
}

__n128 sub_10124E444(double *a1, double *a2, double *a3, double **a4)
{
  char v8 = sub_10124E250(a4, a2, a1);
  int v9 = sub_10124E250(a4, a3, a2);
  if (v8)
  {
    if (v9)
    {
      long long v52 = *((_OWORD *)a1 + 4);
      long long v56 = *((_OWORD *)a1 + 5);
      long long v60 = *((_OWORD *)a1 + 6);
      long long v36 = *(_OWORD *)a1;
      long long v40 = *((_OWORD *)a1 + 1);
      __n128 v44 = *(__n128 *)(a1 + 4);
      long long v48 = *((_OWORD *)a1 + 3);
      long long v12 = *((_OWORD *)a3 + 1);
      long long v11 = *((_OWORD *)a3 + 2);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *((_OWORD *)a1 + 1) = v12;
      *((_OWORD *)a1 + 2) = v11;
      long long v13 = *((_OWORD *)a3 + 6);
      long long v15 = *((_OWORD *)a3 + 3);
      long long v14 = *((_OWORD *)a3 + 4);
      *((_OWORD *)a1 + 5) = *((_OWORD *)a3 + 5);
      *((_OWORD *)a1 + 6) = v13;
      *((_OWORD *)a1 + 3) = v15;
      *((_OWORD *)a1 + 4) = v14;
    }
    else
    {
      long long v55 = *((_OWORD *)a1 + 4);
      long long v59 = *((_OWORD *)a1 + 5);
      long long v63 = *((_OWORD *)a1 + 6);
      long long v39 = *(_OWORD *)a1;
      long long v43 = *((_OWORD *)a1 + 1);
      long long v47 = *((_OWORD *)a1 + 2);
      long long v51 = *((_OWORD *)a1 + 3);
      long long v27 = *((_OWORD *)a2 + 1);
      long long v26 = *((_OWORD *)a2 + 2);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *((_OWORD *)a1 + 1) = v27;
      *((_OWORD *)a1 + 2) = v26;
      long long v28 = *((_OWORD *)a2 + 6);
      long long v30 = *((_OWORD *)a2 + 3);
      long long v29 = *((_OWORD *)a2 + 4);
      *((_OWORD *)a1 + 5) = *((_OWORD *)a2 + 5);
      *((_OWORD *)a1 + 6) = v28;
      *((_OWORD *)a1 + 3) = v30;
      *((_OWORD *)a1 + 4) = v29;
      *(_OWORD *)a2 = v39;
      *((_OWORD *)a2 + 1) = v43;
      *((_OWORD *)a2 + 5) = v59;
      *((_OWORD *)a2 + 6) = v63;
      *((_OWORD *)a2 + 2) = v47;
      *((_OWORD *)a2 + 3) = v51;
      *((_OWORD *)a2 + 4) = v55;
      if (!sub_10124E250(a4, a3, a2)) {
        return result;
      }
      long long v52 = *((_OWORD *)a2 + 4);
      long long v56 = *((_OWORD *)a2 + 5);
      long long v60 = *((_OWORD *)a2 + 6);
      long long v36 = *(_OWORD *)a2;
      long long v40 = *((_OWORD *)a2 + 1);
      __n128 v44 = *(__n128 *)(a2 + 4);
      long long v48 = *((_OWORD *)a2 + 3);
      long long v32 = *((_OWORD *)a3 + 1);
      long long v31 = *((_OWORD *)a3 + 2);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v32;
      *((_OWORD *)a2 + 2) = v31;
      long long v33 = *((_OWORD *)a3 + 6);
      long long v35 = *((_OWORD *)a3 + 3);
      long long v34 = *((_OWORD *)a3 + 4);
      *((_OWORD *)a2 + 5) = *((_OWORD *)a3 + 5);
      *((_OWORD *)a2 + 6) = v33;
      *((_OWORD *)a2 + 3) = v35;
      *((_OWORD *)a2 + 4) = v34;
    }
    *(_OWORD *)a3 = v36;
    *((_OWORD *)a3 + 1) = v40;
    *((_OWORD *)a3 + 5) = v56;
    *((_OWORD *)a3 + 6) = v60;
    __n128 result = v44;
    *((__n128 *)a3 + 2) = v44;
    *((_OWORD *)a3 + 3) = v48;
    *((_OWORD *)a3 + 4) = v52;
  }
  else if (v9)
  {
    long long v53 = *((_OWORD *)a2 + 4);
    long long v57 = *((_OWORD *)a2 + 5);
    long long v61 = *((_OWORD *)a2 + 6);
    long long v37 = *(_OWORD *)a2;
    long long v41 = *((_OWORD *)a2 + 1);
    long long v45 = *((_OWORD *)a2 + 2);
    long long v49 = *((_OWORD *)a2 + 3);
    long long v17 = *((_OWORD *)a3 + 1);
    long long v16 = *((_OWORD *)a3 + 2);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *((_OWORD *)a2 + 1) = v17;
    *((_OWORD *)a2 + 2) = v16;
    long long v18 = *((_OWORD *)a3 + 6);
    long long v20 = *((_OWORD *)a3 + 3);
    long long v19 = *((_OWORD *)a3 + 4);
    *((_OWORD *)a2 + 5) = *((_OWORD *)a3 + 5);
    *((_OWORD *)a2 + 6) = v18;
    *((_OWORD *)a2 + 3) = v20;
    *((_OWORD *)a2 + 4) = v19;
    *(_OWORD *)a3 = v37;
    *((_OWORD *)a3 + 1) = v41;
    *((_OWORD *)a3 + 5) = v57;
    *((_OWORD *)a3 + 6) = v61;
    *((_OWORD *)a3 + 2) = v45;
    *((_OWORD *)a3 + 3) = v49;
    *((_OWORD *)a3 + 4) = v53;
    if (sub_10124E250(a4, a2, a1))
    {
      long long v54 = *((_OWORD *)a1 + 4);
      long long v58 = *((_OWORD *)a1 + 5);
      long long v62 = *((_OWORD *)a1 + 6);
      long long v38 = *(_OWORD *)a1;
      long long v42 = *((_OWORD *)a1 + 1);
      __n128 v46 = *(__n128 *)(a1 + 4);
      long long v50 = *((_OWORD *)a1 + 3);
      long long v22 = *((_OWORD *)a2 + 1);
      long long v21 = *((_OWORD *)a2 + 2);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *((_OWORD *)a1 + 1) = v22;
      *((_OWORD *)a1 + 2) = v21;
      long long v23 = *((_OWORD *)a2 + 6);
      long long v25 = *((_OWORD *)a2 + 3);
      long long v24 = *((_OWORD *)a2 + 4);
      *((_OWORD *)a1 + 5) = *((_OWORD *)a2 + 5);
      *((_OWORD *)a1 + 6) = v23;
      *((_OWORD *)a1 + 3) = v25;
      *((_OWORD *)a1 + 4) = v24;
      *(_OWORD *)a2 = v38;
      *((_OWORD *)a2 + 1) = v42;
      *((_OWORD *)a2 + 5) = v58;
      *((_OWORD *)a2 + 6) = v62;
      __n128 result = v46;
      *((__n128 *)a2 + 2) = v46;
      *((_OWORD *)a2 + 3) = v50;
      *((_OWORD *)a2 + 4) = v54;
    }
  }
  return result;
}

BOOL sub_10124E6A4(double *a1, long long *a2, double **a3)
{
  uint64_t v6 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(0x6DB6DB6DB6DB6DB7 * v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      char v8 = a2 - 7;
      if (!sub_10124E250(a3, (double *)a2 - 14, a1)) {
        return 1;
      }
      long long v9 = *((_OWORD *)a1 + 5);
      long long v41 = *((_OWORD *)a1 + 4);
      long long v42 = v9;
      long long v43 = *((_OWORD *)a1 + 6);
      long long v10 = *((_OWORD *)a1 + 1);
      long long v37 = *(_OWORD *)a1;
      long long v38 = v10;
      long long v11 = *((_OWORD *)a1 + 3);
      long long v39 = *((_OWORD *)a1 + 2);
      long long v40 = v11;
      long long v13 = v8[1];
      long long v12 = v8[2];
      *(_OWORD *)a1 = *v8;
      *((_OWORD *)a1 + 1) = v13;
      *((_OWORD *)a1 + 2) = v12;
      long long v14 = v8[6];
      long long v16 = v8[3];
      long long v15 = v8[4];
      *((_OWORD *)a1 + 5) = v8[5];
      *((_OWORD *)a1 + 6) = v14;
      *((_OWORD *)a1 + 3) = v16;
      *((_OWORD *)a1 + 4) = v15;
      long long v17 = v38;
      long long *v8 = v37;
      v8[1] = v17;
      long long v18 = v43;
      long long v19 = v41;
      void v8[5] = v42;
      v8[6] = v18;
      long long v20 = v40;
      BOOL result = 1;
      v8[2] = v39;
      v8[3] = v20;
      _OWORD v8[4] = v19;
      return result;
    case 3:
      sub_10124E444(a1, a1 + 14, (double *)a2 - 14, a3);
      return 1;
    case 4:
      sub_10124F1FC(a1, a1 + 14, a1 + 28, (double *)a2 - 14, a3);
      return 1;
    case 5:
      sub_10124F3A8(a1, a1 + 14, a1 + 28, a1 + 42, (double *)a2 - 14, a3);
      return 1;
    default:
      long long v21 = a1 + 28;
      sub_10124E444(a1, a1 + 14, a1 + 28, a3);
      long long v22 = a1 + 42;
      if (a1 + 42 == (double *)a2) {
        return 1;
      }
      uint64_t v23 = 0;
      int v24 = 0;
      break;
  }
  while (1)
  {
    if (sub_10124E250(a3, v22, v21))
    {
      long long v25 = *((_OWORD *)v22 + 5);
      long long v41 = *((_OWORD *)v22 + 4);
      long long v42 = v25;
      long long v43 = *((_OWORD *)v22 + 6);
      long long v26 = *((_OWORD *)v22 + 1);
      long long v37 = *(_OWORD *)v22;
      long long v38 = v26;
      long long v27 = *((_OWORD *)v22 + 3);
      uint64_t v28 = v23;
      long long v39 = *((_OWORD *)v22 + 2);
      long long v40 = v27;
      while (1)
      {
        uint64_t v29 = (uint64_t)a1 + v28;
        long long v30 = *(_OWORD *)((char *)a1 + v28 + 304);
        *(_OWORD *)(v29 + 400) = *(_OWORD *)((char *)a1 + v28 + 288);
        *(_OWORD *)(v29 + 416) = v30;
        *(_OWORD *)(v29 + 432) = *(_OWORD *)((char *)a1 + v28 + 320);
        long long v31 = *(_OWORD *)((char *)a1 + v28 + 240);
        *(_OWORD *)(v29 + 336) = *(_OWORD *)((char *)a1 + v28 + 224);
        *(_OWORD *)(v29 + 352) = v31;
        long long v32 = *(_OWORD *)((char *)a1 + v28 + 272);
        *(_OWORD *)(v29 + 368) = *(_OWORD *)((char *)a1 + v28 + 256);
        *(_OWORD *)(v29 + 384) = v32;
        if (v28 == -224) {
          break;
        }
        v28 -= 112;
        if ((sub_10124E250(a3, (double *)&v37, (double *)(v29 + 112)) & 1) == 0)
        {
          long long v33 = (double *)((char *)a1 + v28 + 336);
          goto LABEL_12;
        }
      }
      long long v33 = a1;
LABEL_12:
      long long v34 = v42;
      *((_OWORD *)v33 + 4) = v41;
      *((_OWORD *)v33 + 5) = v34;
      *((_OWORD *)v33 + 6) = v43;
      long long v35 = v38;
      *(_OWORD *)long long v33 = v37;
      *((_OWORD *)v33 + 1) = v35;
      long long v36 = v40;
      ++v24;
      *((_OWORD *)v33 + 2) = v39;
      *((_OWORD *)v33 + 3) = v36;
      if (v24 == 8) {
        return v22 + 14 == (double *)a2;
      }
    }
    long long v21 = v22;
    v23 += 112;
    v22 += 14;
    if (v22 == (double *)a2) {
      return 1;
    }
  }
}

uint64_t sub_10124E930(double *a1, double *a2, double *a3)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B133C0, memory_order_acquire) & 1) == 0)
  {
    long long v87 = a1;
    long long v88 = a3;
    long long v89 = a2;
    int v90 = __cxa_guard_acquire(&qword_101B133C0);
    a2 = v89;
    a3 = v88;
    int v91 = v90;
    a1 = v87;
    if (v91)
    {
      qword_101B133B8 = 0x4056800000000000;
      __cxa_guard_release(&qword_101B133C0);
      a1 = v87;
      a2 = v89;
      a3 = v88;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B133D0, memory_order_acquire) & 1) == 0)
  {
    long long v92 = a1;
    long long v93 = a3;
    long long v94 = a2;
    int v95 = __cxa_guard_acquire(&qword_101B133D0);
    a2 = v94;
    a3 = v93;
    int v96 = v95;
    a1 = v92;
    if (v96)
    {
      qword_101B133C8 = 0x4056800000000000;
      __cxa_guard_release(&qword_101B133D0);
      a1 = v92;
      a2 = v94;
      a3 = v93;
    }
  }
  double v3 = *a1;
  double v4 = a1[1];
  double v6 = *a2;
  double v5 = a2[1];
  double v8 = *a3;
  double v7 = a3[1];
  if (*a2 == *a1) {
    goto LABEL_15;
  }
  if ((*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
    && (*(void *)&v3 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v29 = vabdd_f64(v6, v3);
    double v30 = fabs(v6);
    double v31 = fabs(v3);
    if (v30 < v31) {
      double v30 = v31;
    }
    double v32 = v30 >= 1.0 ? v30 * 2.22044605e-16 : 2.22044605e-16;
    if (v29 <= v32)
    {
LABEL_15:
      if (v5 == v4) {
        return 0;
      }
      if ((*(void *)&v5 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
        && (*(void *)&v4 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v10 = vabdd_f64(v5, v4);
        double v11 = fabs(v5);
        double v12 = fabs(v4);
        if (v11 < v12) {
          double v11 = v12;
        }
        double v13 = v11 >= 1.0 ? v11 * 2.22044605e-16 : 2.22044605e-16;
        if (v10 <= v13) {
          return 0;
        }
      }
    }
  }
  if (v6 == v8) {
    goto LABEL_40;
  }
  if ((*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
    && (*(void *)&v8 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v16 = vabdd_f64(v6, v8);
    double v17 = fabs(v6);
    double v18 = fabs(v8);
    if (v17 < v18) {
      double v17 = v18;
    }
    double v19 = v17 >= 1.0 ? v17 * 2.22044605e-16 : 2.22044605e-16;
    if (v16 <= v19)
    {
LABEL_40:
      if (v5 == v7) {
        return 0;
      }
      if ((*(void *)&v5 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
        && (*(void *)&v7 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v20 = vabdd_f64(v5, v7);
        double v21 = fabs(v5);
        double v22 = fabs(v7);
        if (v21 < v22) {
          double v21 = v22;
        }
        double v23 = v21 >= 1.0 ? v21 * 2.22044605e-16 : 2.22044605e-16;
        if (v20 <= v23) {
          return 0;
        }
      }
    }
  }
  double v24 = fabs(v4);
  if (*(double *)&qword_101B133B8 == v24)
  {
    BOOL v25 = 1;
  }
  else if ((qword_101B133B8 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL {
         || (*(void *)&v4 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  }
  {
    BOOL v25 = 0;
  }
  else
  {
    double v26 = vabdd_f64(*(double *)&qword_101B133B8, v24);
    double v27 = fabs(*(double *)&qword_101B133B8);
    if (v27 >= v24) {
      double v24 = v27;
    }
    if (v24 >= 1.0) {
      double v28 = v24 * 2.22044605e-16;
    }
    else {
      double v28 = 2.22044605e-16;
    }
    BOOL v25 = v26 <= v28;
  }
  double v33 = fabs(v5);
  if (*(double *)&qword_101B133B8 == v33)
  {
    BOOL v34 = 1;
  }
  else if ((qword_101B133B8 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL {
         || (*(void *)&v5 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  }
  {
    BOOL v34 = 0;
  }
  else
  {
    double v35 = vabdd_f64(*(double *)&qword_101B133B8, v33);
    double v36 = fabs(*(double *)&qword_101B133B8);
    if (v36 < v33) {
      double v36 = v33;
    }
    if (v36 >= 1.0) {
      double v37 = v36 * 2.22044605e-16;
    }
    else {
      double v37 = 2.22044605e-16;
    }
    BOOL v34 = v35 <= v37;
  }
  double v38 = fabs(v7);
  if (*(double *)&qword_101B133C8 != v38)
  {
    if ((qword_101B133C8 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v7 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      BOOL v39 = 0;
      if (!v34) {
        goto LABEL_95;
      }
    }
    else
    {
      double v40 = vabdd_f64(*(double *)&qword_101B133C8, v38);
      double v41 = fabs(*(double *)&qword_101B133C8);
      if (v41 >= v38) {
        double v38 = v41;
      }
      if (v38 >= 1.0) {
        double v42 = v38 * 2.22044605e-16;
      }
      else {
        double v42 = 2.22044605e-16;
      }
      BOOL v39 = v40 <= v42;
      if (!v34) {
        goto LABEL_95;
      }
    }
    goto LABEL_83;
  }
  BOOL v39 = 1;
  if (v34)
  {
LABEL_83:
    if (!v25) {
      goto LABEL_94;
    }
    char v43 = (v4 >= 0.0) ^ (v5 < 0.0);
    if (v4 > 0.0) {
      char v43 = 0;
    }
    if (v5 > 0.0) {
      char v43 = v4 > 0.0;
    }
    if ((v43 & 1) == 0)
    {
LABEL_94:
      if (!v39) {
        goto LABEL_95;
      }
      char v44 = (v5 < 0.0) ^ (v7 >= 0.0);
      if (v7 > 0.0) {
        char v44 = 0;
      }
      if (v5 > 0.0) {
        char v44 = v7 > 0.0;
      }
      if ((v44 & 1) == 0) {
        goto LABEL_95;
      }
    }
    return 0;
  }
LABEL_95:
  double v45 = vabdd_f64(v3, v6);
  double v46 = 180.0;
  if (v45 == 180.0) {
    goto LABEL_96;
  }
  double v47 = v3 - v6;
  if (COERCE__INT64(fabs(v3 - v6)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v56 = fabs(v45 + -180.0);
    double v46 = 180.0;
    if (v45 < 180.0) {
      double v45 = 180.0;
    }
    double v57 = v45 >= 1.0 ? v45 * 2.22044605e-16 : 2.22044605e-16;
    if (v56 <= v57) {
      goto LABEL_96;
    }
  }
  double v46 = 180.0;
  if (v47 <= 180.0)
  {
    if (v47 >= -180.0) {
      goto LABEL_97;
    }
    double v46 = fmod(v47 + -180.0, 360.0) + 180.0;
    goto LABEL_96;
  }
  double v58 = fmod(v47 + 180.0, 360.0);
  double v47 = v58 + -180.0;
  if (v58 + -180.0 == -180.0) {
    goto LABEL_96;
  }
  unint64_t v59 = COERCE__INT64(fabs(v58 + -180.0)) - 1;
  BOOL v60 = (unint64_t)(COERCE__INT64(fabs(v58 + -180.0)) - 0x10000000000000) >> 53 > 0x3FE
     && v59 > 0xFFFFFFFFFFFFELL;
  if (!v60 || *(void *)&v47 == 0)
  {
    double v46 = 180.0;
    double v62 = fabs(v47 + 180.0);
    double v63 = fabs(v47);
    if (v63 < 180.0) {
      double v63 = 180.0;
    }
    double v64 = v63 >= 1.0 ? v63 * 2.22044605e-16 : 2.22044605e-16;
    if (v62 <= v64) {
LABEL_96:
    }
      double v47 = v46;
  }
LABEL_97:
  double v48 = vabdd_f64(v8, v6);
  double v49 = 180.0;
  if (v48 == 180.0) {
    goto LABEL_98;
  }
  double v50 = v8 - v6;
  if ((*(void *)&v50 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v65 = fabs(v48 + -180.0);
    double v49 = 180.0;
    if (v48 < 180.0) {
      double v48 = 180.0;
    }
    double v66 = v48 >= 1.0 ? v48 * 2.22044605e-16 : 2.22044605e-16;
    if (v65 <= v66) {
      goto LABEL_98;
    }
  }
  double v49 = 180.0;
  if (v50 > 180.0)
  {
    double v67 = fmod(v50 + 180.0, 360.0);
    double v50 = v67 + -180.0;
    if (v67 + -180.0 != -180.0)
    {
      unint64_t v68 = COERCE__INT64(fabs(v67 + -180.0)) - 1;
      BOOL v69 = (unint64_t)(COERCE__INT64(fabs(v67 + -180.0)) - 0x10000000000000) >> 53 > 0x3FE
         && v68 > 0xFFFFFFFFFFFFELL;
      if (v69 && *(void *)&v50 != 0) {
        goto LABEL_99;
      }
      double v49 = 180.0;
      double v71 = fabs(v50 + 180.0);
      double v72 = fabs(v50);
      if (v72 < 180.0) {
        double v72 = 180.0;
      }
      double v73 = v72 >= 1.0 ? v72 * 2.22044605e-16 : 2.22044605e-16;
      if (v71 > v73) {
        goto LABEL_99;
      }
    }
    goto LABEL_98;
  }
  if (v50 < -180.0)
  {
    double v49 = fmod(v50 + -180.0, 360.0) + 180.0;
LABEL_98:
    double v50 = v49;
  }
LABEL_99:
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B133E0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B133E0))
  {
    qword_101B133D8 = 0x4066800000000000;
    __cxa_guard_release(&qword_101B133E0);
  }
  double v51 = fabs(v47);
  long long v52 = &qword_101B13000;
  double v53 = *(double *)&qword_101B133D8;
  if (v51 == *(double *)&qword_101B133D8) {
    goto LABEL_101;
  }
  double v55 = v4 - v5;
  if ((*(void *)&v47 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (qword_101B133D8 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    goto LABEL_160;
  }
  double v74 = vabdd_f64(v51, *(double *)&qword_101B133D8);
  double v75 = fabs(*(double *)&qword_101B133D8);
  if (v51 >= v75) {
    double v75 = v51;
  }
  double v76 = v75 >= 1.0 ? v75 * 2.22044605e-16 : 2.22044605e-16;
  if (v74 <= v76)
  {
LABEL_101:
    int v54 = 0;
    if (v4 + v5 < 0.0) {
      double v53 = -*(double *)&qword_101B133D8;
    }
    double v55 = v53 - (v4 + v5);
  }
  else
  {
LABEL_160:
    int v54 = 1;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B133E0, memory_order_acquire) & 1) == 0)
  {
    double v97 = v55;
    int v98 = __cxa_guard_acquire(&qword_101B133E0);
    long long v52 = &qword_101B13000;
    double v55 = v97;
    if (v98)
    {
      qword_101B133D8 = 0x4066800000000000;
      __cxa_guard_release(&qword_101B133E0);
      long long v52 = &qword_101B13000;
      double v55 = v97;
    }
  }
  double v77 = fabs(v50);
  double v78 = *((double *)v52 + 123);
  if (v77 == v78) {
    goto LABEL_163;
  }
  double v80 = v7 - v5;
  if ((*(void *)&v50 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
    && (*(void *)&v78 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v81 = vabdd_f64(v77, v78);
    double v82 = fabs(v78);
    if (v77 >= v82) {
      double v82 = v77;
    }
    double v83 = v82 >= 1.0 ? v82 * 2.22044605e-16 : 2.22044605e-16;
    if (v81 <= v83)
    {
LABEL_163:
      double v79 = v5 + v7;
      if (v5 + v7 >= 0.0) {
        double v80 = v78 - v79;
      }
      else {
        double v80 = -v78 - v79;
      }
      double v77 = 0.0;
    }
  }
  if (v54) {
    double v84 = v51;
  }
  else {
    double v84 = 0.0;
  }
  if (v77 >= v84) {
    double v77 = v84;
  }
  if (v25 || v34 || v39) {
    double v77 = 0.0;
  }
  double v85 = fabs(v55);
  double v86 = fabs(v80);
  if (v86 < v85) {
    double v85 = v86;
  }
  if (v77 >= v85)
  {
    double v55 = v47;
    double v80 = v50;
  }
  if (v80 > 0.0 != v55 <= 0.0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 1;
  }
}

__n128 sub_10124F1FC(double *a1, double *a2, double *a3, double *a4, double **a5)
{
  sub_10124E444(a1, a2, a3, a5);
  if (sub_10124E250(a5, a4, a3))
  {
    long long v38 = *((_OWORD *)a3 + 4);
    long long v41 = *((_OWORD *)a3 + 5);
    long long v44 = *((_OWORD *)a3 + 6);
    long long v26 = *(_OWORD *)a3;
    long long v29 = *((_OWORD *)a3 + 1);
    long long v32 = *((_OWORD *)a3 + 2);
    long long v35 = *((_OWORD *)a3 + 3);
    long long v12 = *((_OWORD *)a4 + 1);
    long long v11 = *((_OWORD *)a4 + 2);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *((_OWORD *)a3 + 1) = v12;
    *((_OWORD *)a3 + 2) = v11;
    long long v13 = *((_OWORD *)a4 + 6);
    long long v15 = *((_OWORD *)a4 + 3);
    long long v14 = *((_OWORD *)a4 + 4);
    *((_OWORD *)a3 + 5) = *((_OWORD *)a4 + 5);
    *((_OWORD *)a3 + 6) = v13;
    *((_OWORD *)a3 + 3) = v15;
    *((_OWORD *)a3 + 4) = v14;
    *(_OWORD *)a4 = v26;
    *((_OWORD *)a4 + 1) = v29;
    *((_OWORD *)a4 + 5) = v41;
    *((_OWORD *)a4 + 6) = v44;
    *((_OWORD *)a4 + 2) = v32;
    *((_OWORD *)a4 + 3) = v35;
    *((_OWORD *)a4 + 4) = v38;
    if (sub_10124E250(a5, a3, a2))
    {
      long long v39 = *((_OWORD *)a2 + 4);
      long long v42 = *((_OWORD *)a2 + 5);
      long long v45 = *((_OWORD *)a2 + 6);
      long long v27 = *(_OWORD *)a2;
      long long v30 = *((_OWORD *)a2 + 1);
      long long v33 = *((_OWORD *)a2 + 2);
      long long v36 = *((_OWORD *)a2 + 3);
      long long v17 = *((_OWORD *)a3 + 1);
      long long v16 = *((_OWORD *)a3 + 2);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v17;
      *((_OWORD *)a2 + 2) = v16;
      long long v18 = *((_OWORD *)a3 + 6);
      long long v20 = *((_OWORD *)a3 + 3);
      long long v19 = *((_OWORD *)a3 + 4);
      *((_OWORD *)a2 + 5) = *((_OWORD *)a3 + 5);
      *((_OWORD *)a2 + 6) = v18;
      *((_OWORD *)a2 + 3) = v20;
      *((_OWORD *)a2 + 4) = v19;
      *(_OWORD *)a3 = v27;
      *((_OWORD *)a3 + 1) = v30;
      *((_OWORD *)a3 + 5) = v42;
      *((_OWORD *)a3 + 6) = v45;
      *((_OWORD *)a3 + 2) = v33;
      *((_OWORD *)a3 + 3) = v36;
      *((_OWORD *)a3 + 4) = v39;
      if (sub_10124E250(a5, a2, a1))
      {
        long long v40 = *((_OWORD *)a1 + 4);
        long long v43 = *((_OWORD *)a1 + 5);
        long long v46 = *((_OWORD *)a1 + 6);
        long long v28 = *(_OWORD *)a1;
        long long v31 = *((_OWORD *)a1 + 1);
        __n128 v34 = *(__n128 *)(a1 + 4);
        long long v37 = *((_OWORD *)a1 + 3);
        long long v22 = *((_OWORD *)a2 + 1);
        long long v21 = *((_OWORD *)a2 + 2);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *((_OWORD *)a1 + 1) = v22;
        *((_OWORD *)a1 + 2) = v21;
        long long v23 = *((_OWORD *)a2 + 6);
        long long v25 = *((_OWORD *)a2 + 3);
        long long v24 = *((_OWORD *)a2 + 4);
        *((_OWORD *)a1 + 5) = *((_OWORD *)a2 + 5);
        *((_OWORD *)a1 + 6) = v23;
        *((_OWORD *)a1 + 3) = v25;
        *((_OWORD *)a1 + 4) = v24;
        *(_OWORD *)a2 = v28;
        *((_OWORD *)a2 + 1) = v31;
        *((_OWORD *)a2 + 5) = v43;
        *((_OWORD *)a2 + 6) = v46;
        __n128 result = v34;
        *((__n128 *)a2 + 2) = v34;
        *((_OWORD *)a2 + 3) = v37;
        *((_OWORD *)a2 + 4) = v40;
      }
    }
  }
  return result;
}

__n128 sub_10124F3A8(double *a1, double *a2, double *a3, double *a4, double *a5, double **a6)
{
  sub_10124F1FC(a1, a2, a3, a4, a6);
  if (sub_10124E250(a6, a5, a4))
  {
    long long v49 = *((_OWORD *)a4 + 4);
    long long v53 = *((_OWORD *)a4 + 5);
    long long v57 = *((_OWORD *)a4 + 6);
    long long v33 = *(_OWORD *)a4;
    long long v37 = *((_OWORD *)a4 + 1);
    long long v41 = *((_OWORD *)a4 + 2);
    long long v45 = *((_OWORD *)a4 + 3);
    long long v14 = *((_OWORD *)a5 + 1);
    long long v13 = *((_OWORD *)a5 + 2);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *((_OWORD *)a4 + 1) = v14;
    *((_OWORD *)a4 + 2) = v13;
    long long v15 = *((_OWORD *)a5 + 6);
    long long v17 = *((_OWORD *)a5 + 3);
    long long v16 = *((_OWORD *)a5 + 4);
    *((_OWORD *)a4 + 5) = *((_OWORD *)a5 + 5);
    *((_OWORD *)a4 + 6) = v15;
    *((_OWORD *)a4 + 3) = v17;
    *((_OWORD *)a4 + 4) = v16;
    *(_OWORD *)a5 = v33;
    *((_OWORD *)a5 + 1) = v37;
    *((_OWORD *)a5 + 5) = v53;
    *((_OWORD *)a5 + 6) = v57;
    *((_OWORD *)a5 + 2) = v41;
    *((_OWORD *)a5 + 3) = v45;
    *((_OWORD *)a5 + 4) = v49;
    if (sub_10124E250(a6, a4, a3))
    {
      long long v50 = *((_OWORD *)a3 + 4);
      long long v54 = *((_OWORD *)a3 + 5);
      long long v58 = *((_OWORD *)a3 + 6);
      long long v34 = *(_OWORD *)a3;
      long long v38 = *((_OWORD *)a3 + 1);
      long long v42 = *((_OWORD *)a3 + 2);
      long long v46 = *((_OWORD *)a3 + 3);
      long long v19 = *((_OWORD *)a4 + 1);
      long long v18 = *((_OWORD *)a4 + 2);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *((_OWORD *)a3 + 1) = v19;
      *((_OWORD *)a3 + 2) = v18;
      long long v20 = *((_OWORD *)a4 + 6);
      long long v22 = *((_OWORD *)a4 + 3);
      long long v21 = *((_OWORD *)a4 + 4);
      *((_OWORD *)a3 + 5) = *((_OWORD *)a4 + 5);
      *((_OWORD *)a3 + 6) = v20;
      *((_OWORD *)a3 + 3) = v22;
      *((_OWORD *)a3 + 4) = v21;
      *(_OWORD *)a4 = v34;
      *((_OWORD *)a4 + 1) = v38;
      *((_OWORD *)a4 + 5) = v54;
      *((_OWORD *)a4 + 6) = v58;
      *((_OWORD *)a4 + 2) = v42;
      *((_OWORD *)a4 + 3) = v46;
      *((_OWORD *)a4 + 4) = v50;
      if (sub_10124E250(a6, a3, a2))
      {
        long long v51 = *((_OWORD *)a2 + 4);
        long long v55 = *((_OWORD *)a2 + 5);
        long long v59 = *((_OWORD *)a2 + 6);
        long long v35 = *(_OWORD *)a2;
        long long v39 = *((_OWORD *)a2 + 1);
        long long v43 = *((_OWORD *)a2 + 2);
        long long v47 = *((_OWORD *)a2 + 3);
        long long v24 = *((_OWORD *)a3 + 1);
        long long v23 = *((_OWORD *)a3 + 2);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *((_OWORD *)a2 + 1) = v24;
        *((_OWORD *)a2 + 2) = v23;
        long long v25 = *((_OWORD *)a3 + 6);
        long long v27 = *((_OWORD *)a3 + 3);
        long long v26 = *((_OWORD *)a3 + 4);
        *((_OWORD *)a2 + 5) = *((_OWORD *)a3 + 5);
        *((_OWORD *)a2 + 6) = v25;
        *((_OWORD *)a2 + 3) = v27;
        *((_OWORD *)a2 + 4) = v26;
        *(_OWORD *)a3 = v35;
        *((_OWORD *)a3 + 1) = v39;
        *((_OWORD *)a3 + 5) = v55;
        *((_OWORD *)a3 + 6) = v59;
        *((_OWORD *)a3 + 2) = v43;
        *((_OWORD *)a3 + 3) = v47;
        *((_OWORD *)a3 + 4) = v51;
        if (sub_10124E250(a6, a2, a1))
        {
          long long v52 = *((_OWORD *)a1 + 4);
          long long v56 = *((_OWORD *)a1 + 5);
          long long v60 = *((_OWORD *)a1 + 6);
          long long v36 = *(_OWORD *)a1;
          long long v40 = *((_OWORD *)a1 + 1);
          __n128 v44 = *(__n128 *)(a1 + 4);
          long long v48 = *((_OWORD *)a1 + 3);
          long long v29 = *((_OWORD *)a2 + 1);
          long long v28 = *((_OWORD *)a2 + 2);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *((_OWORD *)a1 + 1) = v29;
          *((_OWORD *)a1 + 2) = v28;
          long long v30 = *((_OWORD *)a2 + 6);
          long long v32 = *((_OWORD *)a2 + 3);
          long long v31 = *((_OWORD *)a2 + 4);
          *((_OWORD *)a1 + 5) = *((_OWORD *)a2 + 5);
          *((_OWORD *)a1 + 6) = v30;
          *((_OWORD *)a1 + 3) = v32;
          *((_OWORD *)a1 + 4) = v31;
          *(_OWORD *)a2 = v36;
          *((_OWORD *)a2 + 1) = v40;
          *((_OWORD *)a2 + 5) = v56;
          *((_OWORD *)a2 + 6) = v60;
          __n128 result = v44;
          *((__n128 *)a2 + 2) = v44;
          *((_OWORD *)a2 + 3) = v48;
          *((_OWORD *)a2 + 4) = v52;
        }
      }
    }
  }
  return result;
}

uint64_t sub_10124F5CC(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a2 != result)
  {
    uint64_t v5 = 0;
    unint64_t v6 = (a2 - result) / 112;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    for (uint64_t i = (void *)(result + 56); ; i += 14)
    {
      uint64_t v8 = *(i - 5);
      if (a4 >= a3)
      {
        if (v8 >= a3)
        {
          BOOL v14 = __OFSUB__(v8, a4);
          BOOL v12 = v8 == a4;
          BOOL v13 = v8 - a4 < 0;
        }
        else
        {
          BOOL v14 = 0;
          BOOL v12 = 0;
          BOOL v13 = 0;
        }
        if (!(v13 ^ v14 | v12)) {
          goto LABEL_21;
        }
      }
      else
      {
        if (v8 < a3)
        {
          BOOL v11 = __OFSUB__(v8, a4);
          BOOL v9 = v8 == a4;
          BOOL v10 = v8 - a4 < 0;
        }
        else
        {
          BOOL v11 = 0;
          BOOL v9 = 1;
          BOOL v10 = 0;
        }
        if (!(v10 ^ v11 | v9)) {
          goto LABEL_21;
        }
      }
      if (a5 == 2) {
        break;
      }
      if (a5 == 1)
      {
        long long v15 = (void *)(result + 112 * v5 + 48);
LABEL_20:
        ++*v15;
      }
LABEL_21:
      ++v5;
      if (!--v6) {
        return result;
      }
    }
    long long v15 = i;
    goto LABEL_20;
  }
  return result;
}

void sub_10124F66C(void *a1)
{
  if (a1)
  {
    sub_10124F66C(*a1);
    sub_10124F66C(a1[1]);
    double v2 = (void *)a1[7];
    if (v2)
    {
      a1[8] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

uint64_t sub_10124F6C8(uint64_t a1)
{
  return a1;
}

uint64_t sub_10124F6FC(uint64_t result, void *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  if (*a4 <= 0)
  {
    uint64_t v5 = a5;
    uint64_t v8 = result;
    if (a5 == -1) {
      uint64_t v5 = (*a2)++;
    }
    *a4 = v5;
    BOOL v9 = (uint64_t *)a4[1];
    BOOL v10 = a4 + 2;
    if (v9 != a4 + 2)
    {
      BOOL v11 = (void *)(result + 40);
      do
      {
        uint64_t v12 = *(void *)(v8 + 16);
        unint64_t v13 = *(void *)(v12 + 32) + v9[4];
        uint64_t v14 = *(void *)(*(void *)(v12 + 8) + ((v13 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * (v13 & 0xF);
        if (!*(unsigned char *)(v14 + 32))
        {
          long long v16 = (void *)(v14 + 40);
          int v15 = *(_DWORD *)(v14 + 40);
          int v17 = *(_DWORD *)(v14 + 208);
          BOOL v18 = v15 == 3 && v17 == 3;
          if (!v18)
          {
            if (*(uint64_t *)(v14 + 24) <= 0)
            {
              if (v15 == 1)
              {
                if (v17 != 1) {
                  goto LABEL_26;
                }
              }
              else if (v15 != 2 || v17 != 2)
              {
LABEL_26:
                long long v20 = (void *)(v14 + 376);
                uint64_t v21 = *a3;
                do
                {
                  uint64_t v23 = v16[1];
                  uint64_t v22 = v16[2];
                  uint64_t v24 = v16[3];
                  v40[0] = v23;
                  v40[1] = v22;
                  v40[2] = v24;
                  if (v23 != v21 || v24 != a3[2] || v22 != a3[1])
                  {
                    long long v27 = (void *)*v11;
                    if (*v11)
                    {
                      long long v28 = (void *)(v8 + 40);
                      do
                      {
                        uint64_t v29 = v27[4];
                        BOOL v30 = v29 < v23;
                        if (v29 == v23)
                        {
                          uint64_t v31 = v27[5];
                          BOOL v30 = v31 < v22;
                          if (v31 == v22) {
                            BOOL v30 = v27[6] < v24;
                          }
                        }
                        int v32 = v30;
                        BOOL v33 = v32 == 0;
                        if (v32) {
                          long long v34 = v27 + 1;
                        }
                        else {
                          long long v34 = v27;
                        }
                        if (v33) {
                          long long v28 = v27;
                        }
                        long long v27 = (void *)*v34;
                      }
                      while (*v34);
                      if (v11 != v28)
                      {
                        uint64_t v35 = v28[4];
                        BOOL v36 = v23 < v35;
                        if (v23 == v35)
                        {
                          uint64_t v37 = v28[5];
                          BOOL v36 = v22 < v37;
                          if (v22 == v37) {
                            BOOL v36 = v24 < v28[6];
                          }
                        }
                        if (!v36)
                        {
                          __n128 result = sub_10124F6FC(v8, a2, v40, v28 + 7, v5);
                          uint64_t v21 = *a3;
                        }
                      }
                    }
                  }
                  v16 += 21;
                }
                while (v16 != v20);
              }
            }
            else if (v15 == 1)
            {
              if (v17 != 2) {
                goto LABEL_26;
              }
            }
            else if (v15 != 2 || (v17 - 1) >= 2)
            {
              goto LABEL_26;
            }
          }
        }
        long long v38 = (uint64_t *)v9[1];
        if (v38)
        {
          do
          {
            long long v39 = v38;
            long long v38 = (uint64_t *)*v38;
          }
          while (v38);
        }
        else
        {
          do
          {
            long long v39 = (uint64_t *)v9[2];
            BOOL v18 = *v39 == (void)v9;
            BOOL v9 = v39;
          }
          while (!v18);
        }
        BOOL v9 = v39;
      }
      while (v39 != v10);
    }
  }
  return result;
}

void sub_10124F92C(void *a1)
{
  if (a1)
  {
    sub_10124F92C(*a1);
    sub_10124F92C(a1[1]);
    sub_10005D144((void *)a1[9]);
    operator delete(a1);
  }
}

void sub_10124F980(void *a1)
{
  if (a1)
  {
    sub_10124F980(*a1);
    sub_10124F980(a1[1]);
    sub_10124F9DC((void *)a1[11]);
    sub_10005D144((void *)a1[8]);
    operator delete(a1);
  }
}

void sub_10124F9DC(void *a1)
{
  if (a1)
  {
    sub_10124F9DC(*a1);
    sub_10124F9DC(a1[1]);
    sub_10005D144((void *)a1[7]);
    operator delete(a1);
  }
}

char *sub_10124FA30(uint64_t **a1, uint64_t a2, void *a3)
{
  unint64_t v6 = a1 + 1;
  uint64_t v5 = (char *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        double v7 = v5;
        uint64_t v8 = *((void *)v5 + 4);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *(char **)v7;
        unint64_t v6 = (uint64_t **)v7;
        if (!*(void *)v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = (char *)*((void *)v7 + 1);
      if (!v5)
      {
        unint64_t v6 = (uint64_t **)(v7 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    double v7 = (char *)(a1 + 1);
LABEL_9:
    BOOL v9 = v7;
    double v7 = (char *)operator new(0x68uLL);
    *((void *)v7 + 4) = *a3;
    *(_OWORD *)(v7 + 40) = xmmword_1015E0D20;
    *((void *)v7 + 8) = 0;
    *((void *)v7 + 7) = v7 + 64;
    *((void *)v7 + 12) = 0;
    *((void *)v7 + 11) = 0;
    *((void *)v7 + 9) = 0;
    *((void *)v7 + 10) = v7 + 88;
    *(void *)double v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v9;
    uint64_t *v6 = (uint64_t *)v7;
    BOOL v10 = (uint64_t *)**a1;
    BOOL v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      BOOL v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

char *sub_10124FB24(uint64_t **a1, uint64_t a2, void *a3)
{
  unint64_t v6 = a1 + 1;
  uint64_t v5 = (char *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        double v7 = v5;
        uint64_t v8 = *((void *)v5 + 4);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *(char **)v7;
        unint64_t v6 = (uint64_t **)v7;
        if (!*(void *)v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = (char *)*((void *)v7 + 1);
      if (!v5)
      {
        unint64_t v6 = (uint64_t **)(v7 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    double v7 = (char *)(a1 + 1);
LABEL_9:
    BOOL v9 = v7;
    double v7 = (char *)operator new(0x48uLL);
    *((void *)v7 + 4) = *a3;
    *(_OWORD *)(v7 + 40) = 0u;
    *(_OWORD *)(v7 + 56) = 0u;
    *((void *)v7 + 6) = v7 + 56;
    *(void *)double v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v9;
    uint64_t *v6 = (uint64_t *)v7;
    BOOL v10 = (uint64_t *)**a1;
    BOOL v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      BOOL v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_10124FC04(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, void *a5, unint64_t *a6, unsigned char *a7)
{
  uint64_t v7 = a2 + 40 + 168 * a4;
  if (*(_DWORD *)(v7 + 160)) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = *(unsigned char *)(v7 + 104) == 0;
  }
  if (v8 || *(unsigned char *)(a2 + 40 + 168 * a4 + 164)) {
    return;
  }
  int v11 = *(_DWORD *)v7;
  if (v11 != 4 && v11 != 2) {
    return;
  }
  long long v254 = 0;
  long long v255 = 0;
  unint64_t v256 = 0;
  uint64_t v17 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8)
                  + (((unint64_t)(*(void *)(*(void *)(a1 + 72) + 32) + a3) >> 1) & 0x7FFFFFFFFFFFFFF8))
      + 376 * ((*(_DWORD *)(*(void *)(a1 + 72) + 32) + a3) & 0xF);
  sub_101250E34((char **)&v254, (double *)v17);
  *(void *)&long long v259 = a3;
  LODWORD(v257) = a4;
  if (sub_101251150(a1, a3, a4, (uint64_t *)&v259, (unsigned int *)&v257, (uint64_t)&v254, 1)) {
    goto LABEL_13;
  }
  if ((void)v259 == a3)
  {
LABEL_38:
    uint64_t v43 = v17 + 40 + 168 * a4;
    goto LABEL_39;
  }
  uint64_t v81 = *(void *)(v17 + 24);
  if (v81 <= 0)
  {
    double v82 = *(void **)(a1 + 72);
    goto LABEL_108;
  }
  if (v257 >= 2) {
    __assert_rtn("operator[]", "array.hpp", 117, "(i < N)&&(\"out of range\")");
  }
  double v82 = *(void **)(a1 + 72);
  uint64_t v83 = *(void *)(v82[1] + (((v82[4] + (void)v259) >> 1) & 0x7FFFFFFFFFFFFFF8))
      + 376 * ((*((_DWORD *)v82 + 8) + v259) & 0xF);
  if (*(void *)(v83 + 24) != v81) {
    goto LABEL_108;
  }
  uint64_t v84 = v83 + 40;
  uint64_t v85 = *(void *)(v83 + 40 + 168 * v257 + 96);
  if (v85 == -1) {
    uint64_t v85 = *(void *)(v84 + 168 * v257 + 88);
  }
  if (v85 != a3)
  {
LABEL_108:
    uint64_t v107 = 2 * v82[5] + 3;
    while (!sub_101251150(a1, a3, a4, (uint64_t *)&v259, (unsigned int *)&v257, (uint64_t)&v254, 0))
    {
      if ((void)v259 == a3 && v257 == a4) {
        goto LABEL_38;
      }
      if (!--v107) {
        break;
      }
    }
LABEL_13:
    unint64_t v18 = *a6;
    long long v19 = (void *)a1;
    long long v20 = *(void **)(a1 + 72);
    unint64_t v251 = v20[4] + a3;
    uint64_t v252 = *(void *)(v20[1] + ((v251 >> 1) & 0x7FFFFFFFFFFFFFF8));
    uint64_t v21 = v19[7];
    uint64_t v22 = v19[8];
    uint64_t v24 = v19[12];
    uint64_t v23 = v19[13];
    *a7 = 0;
    if (!a7[1])
    {
      a7[1] = 1;
      sub_101252CF0(v21, v24, v23);
      sub_101252CF0(v22, v24, v23);
    }
    unint64_t v25 = a5[5];
    unint64_t v26 = v18 - v25;
    long long v248 = v20;
    if (v18 <= v25)
    {
      if (v18 < v25)
      {
        unint64_t v76 = a5[4];
        uint64_t v78 = a5[1];
        uint64_t v77 = a5[2];
        double v79 = (void *)(v78 + 8 * (v76 / 0xAA));
        unint64_t v80 = v77 == v78 ? 0 : *v79 + 24 * (v76 % 0xAA);
        *(void *)&long long v259 = v78 + 8 * (v76 / 0xAA);
        *((void *)&v259 + 1) = v80;
        sub_10119ECB0(&v259, v18);
        long long v109 = (void *)(v78 + 8 * ((v76 + v25) / 0xAA));
        unint64_t v110 = v77 == v78 ? 0 : *v109 + 24 * ((v76 + v25) % 0xAA);
        if (v110 != *((void *)&v259 + 1))
        {
          uint64_t v111 = 170 * ((uint64_t)((uint64_t)v109 - v259) >> 3) - 0x5555555555555555 * ((uint64_t)(v110 - *v109) >> 3);
          uint64_t v112 = (uint64_t)(*((void *)&v259 + 1) - *(void *)v259) >> 3;
          uint64_t v113 = v111 + 0x5555555555555555 * v112;
          if (v113 >= 1)
          {
            if (v77 == v78) {
              unint64_t v114 = 0;
            }
            else {
              unint64_t v114 = *v79 + 24 * (v76 % 0xAA);
            }
            if (*((void *)&v259 + 1) == v114) {
              uint64_t v117 = 0;
            }
            else {
              uint64_t v117 = 170 * ((uint64_t)(v259 - (void)v79) >> 3)
            }
                   - 0x5555555555555555 * v112
                   + 0x5555555555555555 * ((uint64_t)(v114 - *v79) >> 3);
            *(void *)&long long v259 = v78 + 8 * (v76 / 0xAA);
            *((void *)&v259 + 1) = v114;
            sub_10119ECB0(&v259, v117);
            uint64_t v118 = *((void *)&v259 + 1);
            if (*((void *)&v259 + 1) != v110)
            {
              long long v119 = (void *)v259;
              do
              {
                long long v120 = *(void **)v118;
                if (*(void *)v118)
                {
                  *(void *)(v118 + 8) = v120;
                  operator delete(v120);
                }
                v118 += 24;
                if (v118 - *v119 == 4080)
                {
                  uint64_t v121 = v119[1];
                  ++v119;
                  uint64_t v118 = v121;
                }
              }
              while (v118 != v110);
              uint64_t v78 = a5[1];
              uint64_t v77 = a5[2];
              unint64_t v76 = a5[4];
              unint64_t v25 = a5[5];
            }
            uint64_t v122 = 170 * ((v77 - v78) >> 3) - 1;
            if (v77 == v78) {
              uint64_t v122 = 0;
            }
            a5[5] = v25 - v113;
            if (v122 - (v25 - v113 + v76) >= 0x154)
            {
              do
              {
                operator delete(*(void **)(v77 - 8));
                uint64_t v123 = a5[1];
                uint64_t v77 = a5[2] - 8;
                uint64_t v124 = 170 * ((v77 - v123) >> 3) - 1;
                a5[2] = v77;
                if (v77 == v123) {
                  uint64_t v124 = 0;
                }
              }
              while ((unint64_t)(v124 - (a5[5] + a5[4])) > 0x153);
            }
          }
        }
      }
    }
    else
    {
      long long v27 = (char *)a5[1];
      long long v28 = (char *)a5[2];
      uint64_t v29 = (v28 - v27) >> 3;
      if (v28 == v27) {
        uint64_t v30 = 0;
      }
      else {
        uint64_t v30 = 170 * v29 - 1;
      }
      unint64_t v31 = a5[4];
      unint64_t v32 = v31 + v25;
      unint64_t v33 = v30 - (v31 + v25);
      BOOL v34 = v26 >= v33;
      unint64_t v35 = v26 - v33;
      if (v35 != 0 && v34)
      {
        if (v28 == v27) {
          unint64_t v36 = v35 + 1;
        }
        else {
          unint64_t v36 = v35;
        }
        if (v36 % 0xAA) {
          unint64_t v37 = v36 / 0xAA + 1;
        }
        else {
          unint64_t v37 = v36 / 0xAA;
        }
        if (v37 >= v31 / 0xAA) {
          unint64_t v38 = v31 / 0xAA;
        }
        else {
          unint64_t v38 = v37;
        }
        if (v37 <= v31 / 0xAA)
        {
          for (a5[4] = v31 - 170 * v38; v38; --v38)
          {
            double v86 = (void *)a5[1];
            uint64_t v89 = *v86;
            long long v87 = (char *)(v86 + 1);
            uint64_t v88 = v89;
            a5[1] = v87;
            if (v28 == (char *)a5[3])
            {
              uint64_t v90 = (uint64_t)&v87[-*a5];
              if ((unint64_t)v87 <= *a5)
              {
                if (v28 == (char *)*a5) {
                  unint64_t v97 = 1;
                }
                else {
                  unint64_t v97 = (uint64_t)&v28[-*a5] >> 2;
                }
                int v98 = (char *)sub_100048350(v97);
                long long v100 = &v98[8 * (v97 >> 2)];
                long long v101 = (uint64_t *)a5[1];
                long long v28 = v100;
                uint64_t v102 = a5[2] - (void)v101;
                if (v102)
                {
                  long long v28 = &v100[v102 & 0xFFFFFFFFFFFFFFF8];
                  uint64_t v103 = 8 * (v102 >> 3);
                  long long v104 = &v98[8 * (v97 >> 2)];
                  do
                  {
                    uint64_t v105 = *v101++;
                    *(void *)long long v104 = v105;
                    v104 += 8;
                    v103 -= 8;
                  }
                  while (v103);
                }
                long long v106 = (char *)*a5;
                *a5 = v98;
                a5[1] = v100;
                a5[2] = v28;
                a5[3] = &v98[8 * v99];
                if (v106)
                {
                  operator delete(v106);
                  long long v28 = (char *)a5[2];
                }
              }
              else
              {
                uint64_t v91 = v90 >> 3;
                BOOL v68 = v90 >> 3 < -1;
                uint64_t v92 = (v90 >> 3) + 2;
                if (v68) {
                  uint64_t v93 = v92;
                }
                else {
                  uint64_t v93 = v91 + 1;
                }
                long long v94 = &v87[-8 * (v93 >> 1)];
                int64_t v95 = v28 - v87;
                if (v28 != v87)
                {
                  memmove(&v87[-8 * (v93 >> 1)], v87, v28 - v87);
                  long long v28 = (char *)a5[1];
                }
                int v96 = &v28[-8 * (v93 >> 1)];
                long long v28 = &v94[v95];
                a5[1] = v96;
                a5[2] = &v94[v95];
              }
            }
            *(void *)long long v28 = v88;
            long long v28 = (char *)(a5[2] + 8);
            a5[2] = v28;
          }
        }
        else
        {
          unint64_t v39 = v37 - v38;
          uint64_t v40 = a5[3] - *a5;
          if (v37 - v38 <= (v40 >> 3) - v29)
          {
            if (v39)
            {
              while (a5[3] != a5[2])
              {
                *(void *)&long long v259 = operator new(0xFF0uLL);
                sub_10088F710(a5, &v259);
                --v37;
                if (!--v39)
                {
                  long long v28 = (char *)a5[2];
                  goto LABEL_193;
                }
              }
              for (uint64_t i = 0; i != v39; ++i)
              {
                *(void *)&long long v259 = operator new(0xFF0uLL);
                sub_10088F824((uint64_t)a5, &v259);
                long long v28 = (char *)a5[2];
                if (&v28[-a5[1]] == (char *)8) {
                  uint64_t v150 = 169;
                }
                else {
                  uint64_t v150 = 170;
                }
                uint64_t v151 = v150 + a5[4];
                a5[4] = v151;
              }
              unint64_t v38 = v37;
            }
            else
            {
LABEL_193:
              uint64_t v151 = a5[4];
            }
            for (a5[4] = v151 - 170 * v38; v38; --v38)
            {
              double v152 = (void *)a5[1];
              uint64_t v155 = *v152;
              long long v153 = (char *)(v152 + 1);
              uint64_t v154 = v155;
              a5[1] = v153;
              if (v28 == (char *)a5[3])
              {
                uint64_t v156 = (uint64_t)&v153[-*a5];
                if ((unint64_t)v153 <= *a5)
                {
                  if (v28 == (char *)*a5) {
                    unint64_t v163 = 1;
                  }
                  else {
                    unint64_t v163 = (uint64_t)&v28[-*a5] >> 2;
                  }
                  long long v164 = (char *)sub_100048350(v163);
                  BOOL v166 = &v164[8 * (v163 >> 2)];
                  uint64_t v167 = (uint64_t *)a5[1];
                  long long v28 = v166;
                  uint64_t v168 = a5[2] - (void)v167;
                  if (v168)
                  {
                    long long v28 = &v166[v168 & 0xFFFFFFFFFFFFFFF8];
                    uint64_t v169 = 8 * (v168 >> 3);
                    long long v170 = &v164[8 * (v163 >> 2)];
                    do
                    {
                      uint64_t v171 = *v167++;
                      *(void *)long long v170 = v171;
                      v170 += 8;
                      v169 -= 8;
                    }
                    while (v169);
                  }
                  long long v172 = (char *)*a5;
                  *a5 = v164;
                  a5[1] = v166;
                  a5[2] = v28;
                  a5[3] = &v164[8 * v165];
                  if (v172)
                  {
                    operator delete(v172);
                    long long v28 = (char *)a5[2];
                  }
                }
                else
                {
                  uint64_t v157 = v156 >> 3;
                  BOOL v68 = v156 >> 3 < -1;
                  uint64_t v158 = (v156 >> 3) + 2;
                  if (v68) {
                    uint64_t v159 = v158;
                  }
                  else {
                    uint64_t v159 = v157 + 1;
                  }
                  long long v160 = &v153[-8 * (v159 >> 1)];
                  int64_t v161 = v28 - v153;
                  if (v28 != v153)
                  {
                    memmove(&v153[-8 * (v159 >> 1)], v153, v28 - v153);
                    long long v28 = (char *)a5[1];
                  }
                  long long v162 = &v28[-8 * (v159 >> 1)];
                  long long v28 = &v160[v161];
                  a5[1] = v162;
                  a5[2] = &v160[v161];
                }
              }
              *(void *)long long v28 = v154;
              long long v28 = (char *)(a5[2] + 8);
              a5[2] = v28;
            }
          }
          else
          {
            if (v40 >> 2 <= v39 + v29) {
              unint64_t v41 = v39 + v29;
            }
            else {
              unint64_t v41 = v40 >> 2;
            }
            BOOL v261 = a5 + 3;
            if (v41) {
              unint64_t v41 = (unint64_t)sub_100048350(v41);
            }
            else {
              uint64_t v42 = 0;
            }
            *(void *)&long long v259 = v41;
            *((void *)&v259 + 1) = v41 + 8 * (v29 - v38);
            *(void *)&long long v260 = *((void *)&v259 + 1);
            *((void *)&v260 + 1) = v41 + 8 * v42;
            do
            {
              *(void *)&long long v257 = operator new(0xFF0uLL);
              sub_10088F710(&v259, &v257);
              --v39;
            }
            while (v39);
            uint64_t v246 = -170 * v38;
            unint64_t v247 = v26;
            if (v38)
            {
              double v125 = (void *)a5[1];
              long long v126 = (char *)v260;
              do
              {
                if (v126 == *((char **)&v260 + 1))
                {
                  long long v127 = (char *)*((void *)&v259 + 1);
                  long long v128 = (void *)v259;
                  if (*((void *)&v259 + 1) <= (unint64_t)v259)
                  {
                    if (v126 == (char *)v259) {
                      unint64_t v134 = 1;
                    }
                    else {
                      unint64_t v134 = (uint64_t)&v126[-v259] >> 2;
                    }
                    long long v135 = (char *)sub_100048350(v134);
                    uint64_t v137 = v126 - v127;
                    BOOL v8 = v126 == v127;
                    long long v126 = &v135[8 * (v134 >> 2)];
                    if (!v8)
                    {
                      long long v126 = &v135[8 * (v134 >> 2) + (v137 & 0xFFFFFFFFFFFFFFF8)];
                      uint64_t v138 = 8 * (v137 >> 3);
                      long long v139 = &v135[8 * (v134 >> 2)];
                      do
                      {
                        uint64_t v140 = *(void *)v127;
                        v127 += 8;
                        *(void *)long long v139 = v140;
                        v139 += 8;
                        v138 -= 8;
                      }
                      while (v138);
                    }
                    *(void *)&long long v259 = v135;
                    *((void *)&v259 + 1) = &v135[8 * (v134 >> 2)];
                    *(void *)&long long v260 = v126;
                    *((void *)&v260 + 1) = &v135[8 * v136];
                    if (v128) {
                      operator delete(v128);
                    }
                  }
                  else
                  {
                    uint64_t v129 = (uint64_t)(*((void *)&v259 + 1) - v259) >> 3;
                    if (v129 >= -1) {
                      uint64_t v130 = v129 + 1;
                    }
                    else {
                      uint64_t v130 = v129 + 2;
                    }
                    uint64_t v131 = *((void *)&v259 + 1) - 8 * (v130 >> 1);
                    long long v132 = &v126[-*((void *)&v259 + 1)];
                    if (v126 != *((char **)&v259 + 1))
                    {
                      memmove((void *)(*((void *)&v259 + 1) - 8 * (v130 >> 1)), *((const void **)&v259 + 1), (size_t)&v126[-*((void *)&v259 + 1)]);
                      long long v126 = v127;
                    }
                    long long v133 = &v126[-8 * (v130 >> 1)];
                    long long v126 = &v132[v131];
                    *((void *)&v259 + 1) = v133;
                    *(void *)&long long v260 = &v132[v131];
                  }
                }
                *(void *)long long v126 = *v125;
                long long v126 = (char *)(v260 + 8);
                *(void *)&long long v260 = v260 + 8;
                double v125 = (void *)(a5[1] + 8);
                a5[1] = v125;
                --v38;
              }
              while (v38);
            }
            long long v141 = (void *)a5[2];
            unint64_t v26 = v247;
            while (v141 != (void *)a5[1])
              sub_10088F824((uint64_t)&v259, --v141);
            int64_t v142 = (char *)*a5;
            long long v143 = v260;
            *(_OWORD *)a5 = v259;
            *((_OWORD *)a5 + 1) = v143;
            a5[4] += v246;
            if (v142)
            {
              operator delete(v142);
              long long v28 = (char *)a5[2];
            }
            else
            {
              long long v28 = (char *)v143;
            }
          }
        }
        unint64_t v25 = a5[5];
        long long v27 = (char *)a5[1];
        unint64_t v32 = a5[4] + v25;
      }
      uint64_t v173 = &v27[8 * (v32 / 0xAA)];
      if (v28 == v27) {
        uint64_t v174 = 0;
      }
      else {
        uint64_t v174 = (char *)(*(void *)v173 + 24 * (v32 % 0xAA));
      }
      *(void *)&long long v259 = &v27[8 * (v32 / 0xAA)];
      *((void *)&v259 + 1) = v174;
      sub_10119ECB0(&v259, v26);
      uint64_t v175 = *((void *)&v259 + 1);
      if (v174 != *((char **)&v259 + 1))
      {
        uint64_t v176 = (char *)v259;
        do
        {
          if (v173 == v176) {
            uint64_t v177 = v175;
          }
          else {
            uint64_t v177 = *(void *)v173 + 4080;
          }
          if (v174 == (char *)v177)
          {
            long long v179 = v174;
          }
          else
          {
            size_t v178 = 24 * ((v177 - (uint64_t)v174 - 24) / 0x18uLL) + 24;
            bzero(v174, v178);
            long long v179 = &v174[v178];
            unint64_t v25 = a5[5];
          }
          v25 -= 0x5555555555555555 * ((v179 - v174) >> 3);
          a5[5] = v25;
          if (v173 == v176) {
            break;
          }
          long long v180 = (char *)*((void *)v173 + 1);
          v173 += 8;
          uint64_t v174 = v180;
        }
        while (v180 != (char *)v175);
      }
    }
    __n128 v44 = v254;
    long long v255 = (char *)v254;
    uint64_t v181 = v252 + 376 * (v251 & 0xF) + 40 + 168 * a4;
    *(_DWORD *)(v181 + 160) = 4;
    *(unsigned char *)(v181 + 164) = 1;
    unint64_t v182 = v248[4];
    uint64_t v183 = v248[1];
    uint64_t v184 = v248[2];
    long long v185 = (void *)(v183 + 8 * (v182 >> 4));
    if (v184 == v183) {
      uint64_t v186 = 0;
    }
    else {
      uint64_t v186 = *v185 + 376 * (v248[4] & 0xFLL);
    }
    unint64_t v187 = v248[5] + v182;
    unint64_t v188 = v187 >> 4;
    unsigned int v189 = v187 & 0xF;
    while (1)
    {
      uint64_t v190 = v184 == v183 ? 0 : *(void *)(v183 + 8 * v188) + 376 * v189;
      if (v186 == v190) {
        break;
      }
      for (uint64_t j = 0; j != 336; j += 168)
      {
        uint64_t v192 = v186 + j;
        if (!*(unsigned char *)(v186 + j + 204) && !*(unsigned char *)(v192 + 205)) {
          *(_DWORD *)(v192 + 200) = 0;
        }
      }
      uint64_t v193 = v186 + 376 - *v185;
      v186 += 376;
      if (v193 == 6016)
      {
        uint64_t v194 = v185[1];
        ++v185;
        uint64_t v186 = v194;
      }
    }
    goto LABEL_270;
  }
  uint64_t v43 = v84 + 168 * v257;
LABEL_39:
  *(_DWORD *)(v43 + 160) = 3;
  __n128 v44 = v254;
  uint64_t v45 = (uint64_t)v255;
  if ((unint64_t)(v255 - (char *)v254) >= 0x31)
  {
    uint64_t v253 = a1;
    if ((unint64_t)(v255 - (char *)v254) >= 0x50)
    {
      long long v46 = "erase";
      while (1)
      {
        long long v47 = v44 + 2;
        if (sub_1012472B0((double *)(v45 - 32), v44, v44 + 2)) {
          goto LABEL_64;
        }
        if (v44 == (double *)v45) {
          break;
        }
        if ((double *)v45 != v47)
        {
          memmove(v44, v44 + 2, v45 - (void)v47);
          long long v47 = (double *)v45;
        }
        sub_1012524EC((char **)&v254, (((char *)v47 - (char *)v44) >> 4) - 1);
        sub_1012524EC((char **)&v254, ((v255 - (char *)v254) >> 4) - 1);
        __n128 v44 = v254;
        long long v48 = (double *)v255;
        if (v254 == (double *)v255)
        {
          int v245 = 121;
          long long v46 = "front";
LABEL_288:
          __assert_rtn(v46, "range.hpp", v245, "!boost::empty(rng)");
        }
        if ((unint64_t)v255 >= v256)
        {
          uint64_t v49 = (v255 - (char *)v254) >> 4;
          unint64_t v50 = v49 + 1;
          if ((unint64_t)(v49 + 1) >> 60) {
            sub_10006A748();
          }
          uint64_t v51 = v256 - (void)v254;
          if ((uint64_t)(v256 - (void)v254) >> 3 > v50) {
            unint64_t v50 = v51 >> 3;
          }
          if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v52 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v52 = v50;
          }
          if (v52) {
            unint64_t v52 = (unint64_t)sub_1009C886C(v52);
          }
          else {
            uint64_t v53 = 0;
          }
          long long v54 = (char *)(v52 + 16 * v49);
          *(_OWORD *)long long v54 = *(_OWORD *)v44;
          long long v55 = v54;
          do
          {
            *((_OWORD *)v55 - 1) = *((_OWORD *)v48 - 1);
            v55 -= 16;
            v48 -= 2;
          }
          while (v48 != v44);
          uint64_t v45 = (uint64_t)(v54 + 16);
          long long v254 = (double *)v55;
          unint64_t v256 = v52 + 16 * v53;
          if (v44) {
            operator delete(v44);
          }
          __n128 v44 = (double *)v55;
        }
        else
        {
          *(_OWORD *)long long v255 = *(_OWORD *)v254;
          uint64_t v45 = (uint64_t)(v48 + 2);
        }
        long long v255 = (char *)v45;
        if ((unint64_t)(v45 - (void)v44) <= 0x40) {
          goto LABEL_64;
        }
      }
      int v245 = 264;
      goto LABEL_288;
    }
LABEL_64:
    long long v56 = (char *)a5[2];
    long long v57 = (char *)a5[1];
    unint64_t v58 = (v56 - v57) >> 3;
    if (v56 == v57) {
      uint64_t v59 = 0;
    }
    else {
      uint64_t v59 = 170 * v58 - 1;
    }
    unint64_t v60 = a5[4];
    unint64_t v61 = a5[5] + v60;
    if (v59 != v61)
    {
      uint64_t v62 = a1;
LABEL_252:
      long long v209 = (void *)(*(void *)&v57[8 * (v61 / 0xAA)] + 24 * (v61 % 0xAA));
      *long long v209 = 0;
      v209[1] = 0;
      v209[2] = 0;
      sub_101252B54(v209, v44, v45, (v45 - (uint64_t)v44) >> 4);
      ++a5[5];
      long long v210 = *(uint64_t ***)(v62 + 80);
      long long v211 = *(void **)(v62 + 16);
      uint64_t v212 = v211[1];
      uint64_t v213 = v211[2];
      long long v214 = (void *)(v212 + 8 * (v211[4] >> 4));
      long long v249 = v44;
      if (v213 == v212) {
        uint64_t v215 = 0;
      }
      else {
        uint64_t v215 = *v214 + 376 * (v211[4] & 0xFLL);
      }
      while (1)
      {
        if (v213 == v212)
        {
          uint64_t v217 = 0;
        }
        else
        {
          unint64_t v216 = v211[5] + v211[4];
          uint64_t v217 = *(void *)(v212 + ((v216 >> 1) & 0x7FFFFFFFFFFFFFF8)) + 376 * (v216 & 0xF);
        }
        if (v215 == v217) {
          break;
        }
        long long v218 = v214;
        uint64_t v219 = 0;
        uint64_t v220 = v215 + 40;
        char v221 = 1;
        do
        {
          char v222 = v221;
          uint64_t v223 = v220 + 168 * v219;
          int v225 = *(_DWORD *)(v223 + 160);
          long long v224 = (_DWORD *)(v223 + 160);
          if ((v225 - 1) <= 2)
          {
            uint64_t v226 = v220 + 168 * v219;
            *(void *)&long long v260 = 0;
            long long v259 = 0uLL;
            uint64_t v227 = *(void *)(v226 + 24);
            long long v259 = *(_OWORD *)(v226 + 8);
            *(void *)&long long v260 = v227;
            *((unsigned char *)sub_101252BD0(v210, (uint64_t *)&v259, (uint64_t)&v259) + 56) = 1;
            if (*(_DWORD *)v226 == 4)
            {
              uint64_t v258 = 0;
              long long v257 = 0uLL;
              uint64_t v228 = v220 + 168 * (v219 ^ 1);
              uint64_t v229 = *(void *)(v228 + 24);
              long long v257 = *(_OWORD *)(v228 + 8);
              uint64_t v258 = v229;
              *((unsigned char *)sub_101252BD0(v210, (uint64_t *)&v257, (uint64_t)&v257) + 56) = 1;
            }
            if ((*v224 - 1) <= 2) {
              *(unsigned char *)(v220 + 168 * v219 + 165) = 1;
            }
          }
          char v221 = 0;
          uint64_t v219 = 1;
        }
        while ((v222 & 1) != 0);
        v215 += 376;
        long long v214 = v218;
        if (v215 - *v218 == 6016)
        {
          long long v214 = v218 + 1;
          uint64_t v215 = v218[1];
        }
        long long v211 = *(void **)(v253 + 16);
        uint64_t v212 = v211[1];
        uint64_t v213 = v211[2];
      }
      __n128 v44 = v249;
      ++*a6;
      goto LABEL_270;
    }
    uint64_t v62 = a1;
    if (v60 < 0xAA)
    {
      long long v115 = (char *)a5[3];
      uint64_t v116 = (uint64_t)&v115[-*a5];
      if (v58 >= v116 >> 3)
      {
        if (v115 == (char *)*a5) {
          unint64_t v144 = 1;
        }
        else {
          unint64_t v144 = v116 >> 2;
        }
        BOOL v261 = a5 + 3;
        *(void *)&long long v259 = sub_100048350(v144);
        *((void *)&v259 + 1) = v259 + 8 * v58;
        *(void *)&long long v260 = *((void *)&v259 + 1);
        *((void *)&v260 + 1) = v259 + 8 * v145;
        *(void *)&long long v257 = operator new(0xFF0uLL);
        sub_10088F710(&v259, &v257);
        for (uint64_t k = (void *)a5[2]; k != (void *)a5[1]; sub_10088F824((uint64_t)&v259, k))
          --k;
        long long v147 = (char *)*a5;
        long long v148 = v260;
        *(_OWORD *)a5 = v259;
        *((_OWORD *)a5 + 1) = v148;
        if (v147) {
          operator delete(v147);
        }
        goto LABEL_251;
      }
      if (v115 != v56)
      {
        *(void *)&long long v259 = operator new(0xFF0uLL);
        sub_10088F710(a5, &v259);
LABEL_251:
        long long v57 = (char *)a5[1];
        unint64_t v61 = a5[5] + a5[4];
        __n128 v44 = v254;
        uint64_t v45 = (uint64_t)v255;
        goto LABEL_252;
      }
      *(void *)&long long v259 = operator new(0xFF0uLL);
      sub_10088F824((uint64_t)a5, &v259);
      long long v206 = (void *)a5[1];
      long long v56 = (char *)a5[2];
      uint64_t v208 = *v206;
      long long v207 = (char *)(v206 + 1);
      uint64_t v64 = v208;
      a5[1] = v207;
      if (v56 == (char *)a5[3])
      {
        uint64_t v230 = (uint64_t)&v207[-*a5];
        if ((unint64_t)v207 > *a5)
        {
          uint64_t v231 = v230 >> 3;
          BOOL v68 = v230 >> 3 < -1;
          uint64_t v232 = (v230 >> 3) + 2;
          if (v68) {
            uint64_t v233 = v232;
          }
          else {
            uint64_t v233 = v231 + 1;
          }
          uint64_t v234 = -(v233 >> 1);
          uint64_t v235 = v233 >> 1;
          long long v236 = &v207[-8 * v235];
          int64_t v237 = v56 - v207;
          if (v56 != v207)
          {
            memmove(&v207[-8 * v235], v207, v56 - v207);
            long long v207 = (char *)a5[1];
          }
          long long v56 = &v236[v237];
          double v75 = &v207[8 * v234];
          goto LABEL_77;
        }
        if (v56 == (char *)*a5) {
          unint64_t v238 = 1;
        }
        else {
          unint64_t v238 = (uint64_t)&v56[-*a5] >> 2;
        }
        uint64_t v196 = (char *)sub_100048350(v238);
        unint64_t v197 = &v196[8 * (v238 >> 2)];
        long long v199 = &v196[8 * v239];
        uint64_t v240 = (uint64_t *)a5[1];
        long long v56 = v197;
        uint64_t v241 = a5[2] - (void)v240;
        if (v241)
        {
          long long v56 = &v197[v241 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v242 = 8 * (v241 >> 3);
          long long v243 = &v196[8 * (v238 >> 2)];
          do
          {
            uint64_t v244 = *v240++;
            *(void *)long long v243 = v244;
            v243 += 8;
            v242 -= 8;
          }
          while (v242);
        }
LABEL_247:
        long long v205 = (char *)*a5;
        *a5 = v196;
        a5[1] = v197;
        a5[2] = v56;
        a5[3] = v199;
        if (v205)
        {
          operator delete(v205);
          long long v56 = (char *)a5[2];
        }
      }
    }
    else
    {
      a5[4] = v60 - 170;
      uint64_t v65 = *(void *)v57;
      double v63 = v57 + 8;
      uint64_t v64 = v65;
      a5[1] = v63;
      if (v56 == (char *)a5[3])
      {
        uint64_t v66 = (uint64_t)&v63[-*a5];
        if ((unint64_t)v63 > *a5)
        {
          uint64_t v67 = v66 >> 3;
          BOOL v68 = v66 >> 3 < -1;
          uint64_t v69 = (v66 >> 3) + 2;
          if (v68) {
            uint64_t v70 = v69;
          }
          else {
            uint64_t v70 = v67 + 1;
          }
          uint64_t v71 = -(v70 >> 1);
          uint64_t v72 = v70 >> 1;
          double v73 = &v63[-8 * v72];
          int64_t v74 = v56 - v63;
          if (v56 != v63)
          {
            memmove(&v63[-8 * v72], v63, v56 - v63);
            long long v56 = (char *)a5[1];
          }
          double v75 = &v56[8 * v71];
          long long v56 = &v73[v74];
LABEL_77:
          a5[1] = v75;
          a5[2] = v56;
          goto LABEL_250;
        }
        if (v56 == (char *)*a5) {
          unint64_t v195 = 1;
        }
        else {
          unint64_t v195 = (uint64_t)&v56[-*a5] >> 2;
        }
        uint64_t v196 = (char *)sub_100048350(v195);
        unint64_t v197 = &v196[8 * (v195 >> 2)];
        long long v199 = &v196[8 * v198];
        long long v200 = (uint64_t *)a5[1];
        long long v56 = v197;
        uint64_t v201 = a5[2] - (void)v200;
        if (v201)
        {
          long long v56 = &v197[v201 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v202 = 8 * (v201 >> 3);
          long long v203 = &v196[8 * (v195 >> 2)];
          do
          {
            uint64_t v204 = *v200++;
            *(void *)long long v203 = v204;
            v203 += 8;
            v202 -= 8;
          }
          while (v202);
        }
        goto LABEL_247;
      }
    }
LABEL_250:
    *(void *)long long v56 = v64;
    a5[2] += 8;
    goto LABEL_251;
  }
LABEL_270:
  if (v44)
  {
    long long v255 = (char *)v44;
    operator delete(v44);
  }
}

void sub_101250D98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p)
{
  operator delete(v23);
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

void sub_101250DA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  if (a23) {
    operator delete(a23);
  }
  JUMPOUT(0x101250E20);
}

void sub_101250DD4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void **a24,void **a25)
{
  __cxa_begin_catch(a1);
  while (a24 != a25)
  {
    unint64_t v26 = *a24++;
    operator delete(v26);
  }
  __cxa_rethrow();
}

void sub_101250DF8()
{
}

void sub_101250E34(char **a1, double *a2)
{
  double v4 = *a1;
  if (a1[1] - *a1 != 16) {
    goto LABEL_20;
  }
  double v5 = *(double *)v4;
  double v6 = *((double *)v4 + 1);
  double v43 = v6;
  double v44 = v5;
  sub_10123D770(&v44, &v43, 1);
  double v7 = v44;
  double v8 = *a2;
  double v9 = a2[1];
  double v43 = v9;
  double v44 = v8;
  sub_10123D770(&v44, &v43, 1);
  if (v7 != v44)
  {
    if ((*(void *)&v7 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v44 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_20;
    }
    double v39 = vabdd_f64(v7, v44);
    double v40 = fabs(v7);
    double v41 = fabs(v44);
    if (v40 >= v41) {
      double v41 = v40;
    }
    double v42 = v41 >= 1.0 ? v41 * 2.22044605e-16 : 2.22044605e-16;
    if (v39 > v42) {
      goto LABEL_20;
    }
  }
  if (v6 != v9)
  {
    if ((*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_20;
    }
    double v11 = vabdd_f64(v6, v9);
    double v12 = fabs(v6);
    double v13 = fabs(v9);
    if (v12 < v13) {
      double v12 = v13;
    }
    double v14 = v12 >= 1.0 ? v12 * 2.22044605e-16 : 2.22044605e-16;
    if (v11 > v14)
    {
LABEL_20:
      uint64_t v17 = a1[1];
      unint64_t v16 = (unint64_t)a1[2];
      if ((unint64_t)v17 >= v16)
      {
        uint64_t v19 = (v17 - *a1) >> 4;
        unint64_t v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) >> 60) {
LABEL_63:
        }
          sub_10006A748();
        uint64_t v21 = v16 - (void)*a1;
        if (v21 >> 3 > v20) {
          unint64_t v20 = v21 >> 3;
        }
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v22 = v20;
        }
        if (v22) {
          unint64_t v22 = (unint64_t)sub_1009C886C(v22);
        }
        else {
          uint64_t v23 = 0;
        }
        uint64_t v24 = (_OWORD *)(v22 + 16 * v19);
        unint64_t v25 = v22 + 16 * v23;
        _OWORD *v24 = *(_OWORD *)a2;
        unint64_t v18 = (double *)(v24 + 1);
        long long v27 = *a1;
        unint64_t v26 = a1[1];
        if (v26 != *a1)
        {
          do
          {
            *--uint64_t v24 = *((_OWORD *)v26 - 1);
            v26 -= 16;
          }
          while (v26 != v27);
          unint64_t v26 = *a1;
        }
        *a1 = (char *)v24;
        a1[1] = (char *)v18;
        a1[2] = (char *)v25;
        if (v26) {
          operator delete(v26);
        }
      }
      else
      {
        *(_OWORD *)uint64_t v17 = *(_OWORD *)a2;
        unint64_t v18 = (double *)(v17 + 16);
      }
      a1[1] = (char *)v18;
      if ((unint64_t)((char *)v18 - *a1) >= 0x21)
      {
        do
        {
          if (sub_1012472B0(v18 - 6, v18 - 4, a2)) {
            break;
          }
          sub_1012524EC(a1, ((a1[1] - *a1) >> 4) - 2);
          uint64_t v29 = a1[1];
          unint64_t v28 = (unint64_t)a1[2];
          if ((unint64_t)v29 >= v28)
          {
            uint64_t v30 = (v29 - *a1) >> 4;
            unint64_t v31 = v30 + 1;
            if ((unint64_t)(v30 + 1) >> 60) {
              goto LABEL_63;
            }
            uint64_t v32 = v28 - (void)*a1;
            if (v32 >> 3 > v31) {
              unint64_t v31 = v32 >> 3;
            }
            if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v33 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v33 = v31;
            }
            if (v33) {
              unint64_t v33 = (unint64_t)sub_1009C886C(v33);
            }
            else {
              uint64_t v34 = 0;
            }
            unint64_t v35 = (_OWORD *)(v33 + 16 * v30);
            *unint64_t v35 = *(_OWORD *)a2;
            unint64_t v37 = *a1;
            unint64_t v36 = a1[1];
            unint64_t v38 = (char *)v35;
            if (v36 != *a1)
            {
              do
              {
                *((_OWORD *)v38 - 1) = *((_OWORD *)v36 - 1);
                v38 -= 16;
                v36 -= 16;
              }
              while (v36 != v37);
              unint64_t v36 = *a1;
            }
            unint64_t v18 = (double *)(v35 + 1);
            *a1 = v38;
            a1[1] = (char *)(v35 + 1);
            a1[2] = (char *)(v33 + 16 * v34);
            if (v36) {
              operator delete(v36);
            }
          }
          else
          {
            *(_OWORD *)uint64_t v29 = *(_OWORD *)a2;
            unint64_t v18 = (double *)(v29 + 16);
          }
          a1[1] = (char *)v18;
        }
        while ((unint64_t)((char *)v18 - *a1) > 0x20);
      }
    }
  }
}

uint64_t sub_101251150(uint64_t a1, uint64_t a2, BOOL a3, uint64_t *a4, unsigned int *a5, uint64_t a6, int a7)
{
  unsigned int v7 = *a5;
  if (*a5 >= 2) {
    __assert_rtn("operator[]", "array.hpp", 117, "(i < N)&&(\"out of range\")");
  }
  uint64_t v9 = *a4;
  uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8)
                  + (((unint64_t)(*(void *)(*(void *)(a1 + 72) + 32) + *a4) >> 1) & 0x7FFFFFFFFFFFFFF8))
      + 376 * ((*(_DWORD *)(*(void *)(a1 + 72) + 32) + *(_DWORD *)a4) & 0xF)
      + 40;
  uint64_t v11 = v10 + 168 * v7;
  uint64_t v12 = *(void *)(v11 + 96);
  if ((v12 & 0x8000000000000000) == 0)
  {
    BOOL v267 = a3;
    uint64_t v13 = a2;
    uint64_t v266 = *a4;
    unsigned int v269 = *a5;
    int v270 = a5;
    int v14 = a7;
    uint64_t v15 = a6;
    unint64_t v16 = a4;
    *a4 = v12;
    long long v17 = *(_OWORD *)(v11 + 24);
    long long v271 = *(_OWORD *)(v11 + 8);
    long long v272 = v17;
    uint64_t v273 = *(void *)(v11 + 40);
    goto LABEL_4;
  }
  uint64_t v21 = *(void *)(v10 + 168 * v7 + 80);
  if (v21 < 0 || (uint64_t v22 = *(void *)(v10 + 168 * v7 + 88), v22 < 0))
  {
    BOOL v19 = a7 == 0;
    goto LABEL_313;
  }
  *a4 = v22;
  long long v23 = *(_OWORD *)(v11 + 24);
  long long v271 = *(_OWORD *)(v11 + 8);
  long long v272 = v23;
  uint64_t v273 = *(void *)(v11 + 40);
  unint64_t v24 = *(void *)(v11 + 24);
  unsigned int v269 = v7;
  int v270 = a5;
  uint64_t v266 = v9;
  BOOL v267 = a3;
  if (*(void *)(v11 + 8))
  {
    unint64_t v25 = *(double ***)(a1 + 64);
    if ((v24 & 0x8000000000000000) != 0)
    {
      unint64_t v16 = a4;
      uint64_t v13 = a2;
      int v14 = a7;
LABEL_136:
      uint64_t v123 = *v25;
      uint64_t v124 = v25[1];
      uint64_t v125 = *(void *)(v11 + 32);
      uint64_t v126 = v125 + 1;
      uint64_t v127 = ((char *)v124 - (char *)*v25) >> 4;
      BOOL v51 = v127 <= v125 + 1;
      uint64_t v128 = v127 - (v125 + 1);
      if (!v51)
      {
        if (v125 < v21) {
          uint64_t v129 = ~v125;
        }
        else {
          uint64_t v129 = v128;
        }
        uint64_t v15 = a6;
        if (v129 + v21 >= 0)
        {
          uint64_t v130 = &v123[2 * v126];
          uint64_t v131 = v129 + v21 + 1;
          do
          {
            sub_101252604((char **)v15, v130);
            if (v130 + 2 == v124) {
              uint64_t v130 = v123;
            }
            else {
              v130 += 2;
            }
            --v131;
          }
          while (v131);
        }
        goto LABEL_4;
      }
LABEL_374:
      __assert_rtn("apply", "copy_segments.hpp", 95, "from_index < static_cast<signed_size_type>(boost::size(view))");
    }
    long long v27 = v25 + 3;
    unint64_t v26 = v25[3];
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v27[1] - (void)v26) >> 3) >= v24)
    {
      uint64_t v13 = a2;
      unint64_t v16 = a4;
      int v14 = a7;
      unint64_t v25 = (double **)&v26[3 * v24];
      goto LABEL_136;
    }
LABEL_375:
    __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
  }
  double v41 = *(double ***)(a1 + 56);
  if ((v24 & 0x8000000000000000) != 0)
  {
    unint64_t v16 = a4;
    uint64_t v13 = a2;
    int v14 = a7;
  }
  else
  {
    double v43 = v41 + 3;
    double v42 = v41[3];
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v43[1] - (void)v42) >> 3) < v24) {
      goto LABEL_375;
    }
    uint64_t v13 = a2;
    unint64_t v16 = a4;
    int v14 = a7;
    double v41 = (double **)&v42[3 * v24];
  }
  long long v132 = *v41;
  long long v133 = v41[1];
  uint64_t v134 = *(void *)(v11 + 32);
  uint64_t v135 = v134 + 1;
  uint64_t v136 = ((char *)v133 - (char *)*v41) >> 4;
  BOOL v51 = v136 <= v134 + 1;
  uint64_t v137 = v136 - (v134 + 1);
  if (v51) {
    goto LABEL_374;
  }
  if (v134 < v21) {
    uint64_t v138 = ~v134;
  }
  else {
    uint64_t v138 = v137;
  }
  uint64_t v15 = a6;
  if (v138 + v21 >= 0)
  {
    long long v139 = &v132[2 * v135];
    uint64_t v140 = v138 + v21 + 1;
    do
    {
      sub_101252604((char **)v15, v139);
      if (v139 + 2 == v133) {
        long long v139 = v132;
      }
      else {
        v139 += 2;
      }
      --v140;
    }
    while (v140);
  }
LABEL_4:
  uint64_t v18 = *v16;
  if (*(unsigned char *)(*(void *)(*(void *)(*(void *)(a1 + 72) + 8)
                            + (((unint64_t)(*(void *)(*(void *)(a1 + 72) + 32) + *v16) >> 1) & 0x7FFFFFFFFFFFFFF8))
                + 376 * ((*(_DWORD *)(*(void *)(a1 + 72) + 32) + *(_DWORD *)v16) & 0xF)
                + 32))
  {
    BOOL v19 = v14 == 0;
    unsigned int v20 = 3;
    goto LABEL_314;
  }
  unint64_t v28 = (char **)v15;
  uint64_t v29 = v16;
  int v30 = v14;
  if (v14) {
    *(_DWORD *)(v10 + 168 * v269 + 160) = 1;
  }
  unint64_t v31 = (char **)v15;
  uint64_t v32 = *(void *)(a1 + 16);
  uint64_t v33 = *(void *)(v32 + 32);
  uint64_t v34 = *(void *)(v32 + 8);
  uint64_t v35 = *(void *)(v34 + (((unint64_t)(v33 + v18) >> 1) & 0x7FFFFFFFFFFFFFF8));
  unsigned int v36 = (v33 + v18) & 0xF;
  uint64_t v37 = v35 + 376 * v36;
  uint64_t v38 = *(void *)(v37 + 24);
  uint64_t v39 = v13;
  if (*(void *)(v15 + 8) - *(void *)v15 >= 0x11uLL)
  {
    BOOL v40 = v38 >= 1
       && *(void *)(*(void *)(v34 + (((unint64_t)(v33 + v13) >> 1) & 0x7FFFFFFFFFFFFFF8))
                    + 376 * ((v33 + v13) & 0xF)
                    + 24) == v38;
    if (v18 == v13 || v40)
    {
      *uint64_t v29 = v13;
      unint64_t v60 = v270;
      BOOL v122 = v267;
      goto LABEL_134;
    }
  }
  if (v38 <= 0)
  {
    uint64_t v53 = v37 + 40;
    if (*(_DWORD *)(v37 + 40) != 2 || *(_DWORD *)(v37 + 208) != 2)
    {
LABEL_190:
      uint64_t v161 = 0;
      char v162 = 1;
      unint64_t v60 = v270;
      do
      {
        char v163 = v162;
        if (*(_DWORD *)(v53 + 168 * v161 + 160) == 1)
        {
          unsigned int v181 = v161;
          goto LABEL_224;
        }
        char v162 = 0;
        uint64_t v161 = 1;
      }
      while ((v163 & 1) != 0);
      uint64_t v164 = 0;
      *int v270 = -1;
      char v165 = 1;
      do
      {
        int v166 = *(_DWORD *)(v53 + 168 * v164 + 160);
        if ((v165 & 1) == 0) {
          break;
        }
        char v165 = 0;
        uint64_t v164 = 1;
      }
      while (v166 == 3);
      if (v166 == 3) {
        goto LABEL_312;
      }
      if (*(_DWORD *)(v37 + 40) != 4 || *(_DWORD *)(v37 + 208) != 4)
      {
        uint64_t v168 = 0;
        char v169 = 0;
        uint64_t v170 = *(void *)(v37 + 48);
        uint64_t v171 = *(void *)(v37 + 216);
        uint64_t v172 = *(void *)(v37 + 184);
        char v173 = 1;
        unsigned int v174 = -1;
        long long v175 = v271;
        while (1)
        {
          char v176 = v173;
          uint64_t v177 = v53 + 168 * v168;
          if (*(_DWORD *)v177 != 2 || (*(_DWORD *)(v53 + 168 * v168 + 160) & 0xFFFFFFFE) == 2) {
            goto LABEL_220;
          }
          if ((v169 & 1) == 0)
          {
LABEL_219:
            *int v270 = v168;
            char v169 = 1;
            unsigned int v174 = v168;
            goto LABEL_220;
          }
          BOOL v179 = v172 != -1 && v172 == *(void *)(v37 + 352);
          if (v170 == v171)
          {
            BOOL v180 = *(void *)(v177 + 16) == *((void *)&v175 + 1);
            if (v179) {
              goto LABEL_213;
            }
          }
          else
          {
            BOOL v180 = *(void *)(v177 + 8) == (void)v175;
            if (v179)
            {
LABEL_213:
              if (!v180) {
                goto LABEL_219;
              }
              goto LABEL_215;
            }
          }
          if (v180) {
            goto LABEL_219;
          }
LABEL_215:
          char v169 = 1;
LABEL_220:
          char v173 = 0;
          uint64_t v168 = 1;
          if ((v176 & 1) == 0)
          {
            if ((v169 & 1) == 0) {
              goto LABEL_312;
            }
LABEL_280:
            if (v174 < 2) {
              goto LABEL_225;
            }
LABEL_281:
            __assert_rtn("operator[]", "array.hpp", 122, "(i < N)&&(\"out of range\")");
          }
        }
      }
      uint64_t v206 = 0;
      LOWORD(v279) = 0;
      LOWORD(v274) = 0;
      char v207 = 1;
      while (1)
      {
        char v208 = v207;
        uint64_t v209 = *(void *)(v53 + 168 * v206 + 96);
        if (v209 == -1)
        {
          uint64_t v209 = *(void *)(v53 + 168 * v206 + 88);
          if (v209 == -1)
          {
            BOOL v212 = 0;
            *((unsigned char *)&v279 + v206) = 0;
            goto LABEL_255;
          }
        }
        uint64_t v210 = *(void *)(*(void *)(*(void *)(a1 + 16) + 8)
                         + (((unint64_t)(*(void *)(*(void *)(a1 + 16) + 32) + v209) >> 1) & 0x7FFFFFFFFFFFFFF8))
             + 376 * ((*(_DWORD *)(*(void *)(a1 + 16) + 32) + v209) & 0xF);
        if (*(uint64_t *)(v210 + 24) > 0 || (int v211 = *(_DWORD *)(v210 + 40), v211 == 2))
        {
          *((unsigned char *)&v279 + v206) = 1;
        }
        else
        {
          int v213 = *(_DWORD *)(v210 + 208);
          BOOL v214 = v211 == 4;
          if (v213 == 2 || v213 == 4) {
            BOOL v214 = 1;
          }
          *((unsigned char *)&v279 + v206) = v214;
          if (v211 != 4 && v213 != 4 && v213 != 2)
          {
            BOOL v212 = 0;
            goto LABEL_255;
          }
        }
        BOOL v212 = v209 == v39;
LABEL_255:
        char v207 = 0;
        *((unsigned char *)&v275[-1] + v206) = v212;
        uint64_t v206 = 1;
        if ((v208 & 1) == 0)
        {
          if (v274 == BYTE1(v274))
          {
            uint64_t v218 = 0;
            char v219 = 0;
            double v220 = 0.0;
            char v221 = 1;
            unsigned int v174 = -1;
            do
            {
              char v222 = v221;
              if (*((unsigned char *)&v279 + v218))
              {
                double v223 = *(double *)(v53 + 168 * v218 + 72);
                if ((v219 & (v223 >= v220)) != 0)
                {
                  char v219 = 1;
                }
                else
                {
                  *int v270 = v218;
                  char v219 = 1;
                  unsigned int v174 = v218;
                  double v220 = v223;
                }
              }
              char v221 = 0;
              uint64_t v218 = 1;
            }
            while ((v222 & 1) != 0);
            if (v219) {
              goto LABEL_280;
            }
LABEL_312:
            BOOL v19 = v30 == 0;
LABEL_313:
            unsigned int v20 = 1;
LABEL_314:
            if (v19) {
              return v20 + 1;
            }
            else {
              return v20;
            }
          }
          BOOL v122 = v274 == 0;
LABEL_134:
          unsigned int *v60 = v122;
          goto LABEL_225;
        }
      }
    }
    int v54 = v30;
    uint64_t v55 = 0;
    long long v281 = 0u;
    long long v282 = 0u;
    long long v279 = 0u;
    long long v280 = 0u;
    char v56 = 1;
    do
    {
      char v57 = v56;
      sub_10125295C((unint64_t *)&v279, (double *)v37, v53 + 168 * v55, *v29, v55, &v271, *(uint64_t **)a1, *(uint64_t **)(a1 + 8), 1);
      char v56 = 0;
      uint64_t v55 = 1;
    }
    while ((v57 & 1) != 0);
    if (*((void *)&v281 + 1))
    {
      sub_10124CD34((uint64_t)&v279, (double *)v37);
      uint64_t v58 = sub_101252A2C(a1, v279, *((uint64_t *)&v279 + 1));
      uint64_t v59 = (void *)v279;
      unint64_t v60 = v270;
      unint64_t v31 = v28;
      if (v58 >= 1 && *((void *)&v279 + 1) != (void)v279)
      {
        uint64_t v61 = 0;
        unint64_t v62 = (*((void *)&v279 + 1) - (void)v279) / 112;
        if (v62 <= 1) {
          uint64_t v63 = 1;
        }
        else {
          uint64_t v63 = (*((void *)&v279 + 1) - (void)v279) / 112;
        }
        uint64_t v64 = v279 + 32;
        double v65 = 0.0;
        uint64_t v66 = (*((void *)&v279 + 1) - (void)v279) / 112;
        do
        {
          uint64_t v67 = *(void *)(v64 - 16);
          if (v67 > v58) {
            break;
          }
          if (v67 == v58)
          {
            unsigned int v68 = *(_DWORD *)(v64 + 8);
            if (v68 >= 2) {
              __assert_rtn("operator[]", "array.hpp", 117, "(i < N)&&(\"out of range\")");
            }
            uint64_t v69 = *(void *)(*(void *)(*(void *)(a1 + 16) + 8)
                            + (((*(void *)v64 + *(void *)(*(void *)(a1 + 16) + 32)) >> 1) & 0x7FFFFFFFFFFFFFF8))
                + 376 * ((*(_DWORD *)v64 + *(_DWORD *)(*(void *)(a1 + 16) + 32)) & 0xF)
                + 40;
            if (!*(unsigned char *)(v69 + 168 * v68 + 165))
            {
              uint64_t v70 = v69 + 168 * v68;
              if (*(double *)(v70 + 72) < v65 || v66 == v62)
              {
                double v65 = *(double *)(v70 + 72);
                uint64_t v66 = v61;
              }
            }
          }
          ++v61;
          v64 += 112;
        }
        while (v63 != v61);
        if (v66 != v62)
        {
          uint64_t v72 = v279 + 112 * v66;
          *uint64_t v29 = *(void *)(v72 + 32);
          *int v270 = *(_DWORD *)(v72 + 40);
          *((void *)&v279 + 1) = v59;
          operator delete(v59);
          goto LABEL_225;
        }
        goto LABEL_186;
      }
    }
    else
    {
      uint64_t v59 = (void *)v279;
      unint64_t v60 = v270;
      unint64_t v31 = v28;
    }
    if (!v59)
    {
      int v270 = v60;
LABEL_188:
      int v30 = v54;
      if (*(uint64_t *)(v37 + 24) >= 1)
      {
        uint64_t v158 = *(void *)(a1 + 16);
        uint64_t v18 = *v29;
        uint64_t v159 = *(void *)(v158 + 8);
        unint64_t v160 = *(void *)(v158 + 32) + *v29;
        unsigned int v36 = v160 & 0xF;
        uint64_t v35 = *(void *)(v159 + ((v160 >> 1) & 0x7FFFFFFFFFFFFFF8));
        goto LABEL_25;
      }
      goto LABEL_190;
    }
LABEL_186:
    int v270 = v60;
    *((void *)&v279 + 1) = v59;
    operator delete(v59);
    goto LABEL_188;
  }
LABEL_25:
  uint64_t v44 = *(void *)(v35 + 376 * v36 + 24);
  if (v44 <= 0) {
    __assert_rtn("select_turn_from_cluster", "traversal.hpp", 790, "turn.is_clustered()");
  }
  uint64_t v45 = *(void *)(a1 + 24);
  long long v48 = *(void **)(v45 + 8);
  long long v46 = (void *)(v45 + 8);
  long long v47 = v48;
  if (!v48) {
    goto LABEL_36;
  }
  uint64_t v49 = v46;
  do
  {
    uint64_t v50 = v47[4];
    BOOL v51 = v50 < v44;
    if (v50 >= v44) {
      unint64_t v52 = v47;
    }
    else {
      unint64_t v52 = v47 + 1;
    }
    if (!v51) {
      uint64_t v49 = v47;
    }
    long long v47 = (void *)*v52;
  }
  while (*v52);
  if (v49 == v46 || v44 < v49[4]) {
LABEL_36:
  }
    __assert_rtn("select_turn_from_cluster", "traversal.hpp", 793, "mit != m_clusters.end()");
  double v73 = v29;
  long long v281 = 0u;
  long long v282 = 0u;
  unint64_t v76 = (void *)v49[5];
  double v75 = (void **)(v49 + 5);
  int64_t v74 = v76;
  long long v279 = 0u;
  long long v280 = 0u;
  uint64_t v77 = v75 + 1;
  if (v76 == v75 + 1) {
    goto LABEL_312;
  }
  int v264 = v30;
  double v265 = v73;
  double v263 = v31;
  do
  {
    uint64_t v78 = v74[4];
    uint64_t v79 = *(void *)(*(void *)(*(void *)(a1 + 16) + 8)
                    + (((unint64_t)(*(void *)(*(void *)(a1 + 16) + 32) + v78) >> 1) & 0x7FFFFFFFFFFFFFF8))
        + 376 * ((*(_DWORD *)(*(void *)(a1 + 16) + 32) + v78) & 0xF);
    if (!*(unsigned char *)(v79 + 32))
    {
      uint64_t v80 = 0;
      char v81 = 1;
      do
      {
        char v82 = v81;
        sub_10125295C((unint64_t *)&v279, (double *)v79, v79 + 40 + 168 * v80, v78, v80, &v271, *(uint64_t **)a1, *(uint64_t **)(a1 + 8), v78 == v18);
        char v81 = 0;
        uint64_t v80 = 1;
      }
      while ((v82 & 1) != 0);
    }
    uint64_t v83 = (void *)v74[1];
    if (v83)
    {
      do
      {
        uint64_t v84 = v83;
        uint64_t v83 = (void *)*v83;
      }
      while (v83);
    }
    else
    {
      do
      {
        uint64_t v84 = (void *)v74[2];
        BOOL v19 = *v84 == (void)v74;
        int64_t v74 = v84;
      }
      while (!v19);
    }
    int64_t v74 = v84;
  }
  while (v84 != v77);
  uint64_t v85 = v265;
  if (!*((void *)&v281 + 1))
  {
    if ((void)v279)
    {
      *((void *)&v279 + 1) = v279;
      operator delete((void *)v279);
    }
    int v30 = v264;
    goto LABEL_312;
  }
  sub_10124CD34((uint64_t)&v279, (double *)(*(void *)(*(void *)(*(void *)(a1 + 16) + 8)+ (((unint64_t)(*(void *)(*(void *)(a1 + 16) + 32) + v18) >> 1) & 0x7FFFFFFFFFFFFFF8))+ 376 * ((*(_DWORD *)(*(void *)(a1 + 16) + 32) + v18) & 0xF)));
  uint64_t v278 = 0;
  uint64_t v268 = *(void *)(a1 + 16);
  int v274 = v75;
  long long v277 = 0u;
  *(_OWORD *)uint64_t v275 = 0u;
  *(_OWORD *)long long __p = 0u;
  double v86 = *v75;
  if (*v75 == v77)
  {
    char v141 = 1;
    goto LABEL_164;
  }
  do
  {
    uint64_t v87 = v86[4];
    uint64_t v88 = *(void *)(*(void *)(v268 + 8)
                    + (((unint64_t)(*(void *)(v268 + 32) + v87) >> 1) & 0x7FFFFFFFFFFFFFF8))
        + 376 * ((*(_DWORD *)(v268 + 32) + v87) & 0xF);
    if (!*(unsigned char *)(v88 + 32))
    {
      uint64_t v90 = v88 + 40;
      if (*(_DWORD *)(v88 + 40) != 2 || *(_DWORD *)(v88 + 208) != 2)
      {
        uint64_t v91 = 0;
        char v92 = 1;
        while (1)
        {
          char v93 = v92;
          uint64_t v94 = v90 + 168 * v91;
          uint64_t v95 = *(void *)(v94 + 96);
          if (v95 == -1) {
            uint64_t v95 = *(void *)(v90 + 168 * v91 + 88);
          }
          int v96 = *(_DWORD *)v94;
          switch(v96)
          {
            case 4:
              goto LABEL_88;
            case 3:
              uint64_t v99 = *(void *)(v90 + 168 * (v91 ^ 1) + 96);
              if (v99 == -1) {
                uint64_t v99 = *(void *)(v90 + 168 * (v91 ^ 1) + 88);
              }
              if (v95 != v99)
              {
                for (uint64_t i = v274[1]; i; uint64_t i = (void *)*i)
                {
                  uint64_t v101 = i[4];
                  if (v95 >= v101)
                  {
                    if (v101 >= v95) {
                      goto LABEL_116;
                    }
                    ++i;
                  }
                }
                uint64_t v102 = (char *)v277;
                if ((unint64_t)v277 >= *((void *)&v277 + 1))
                {
                  uint64_t v113 = (char *)__p[1];
                  uint64_t v114 = (uint64_t)(v277 - (unint64_t)__p[1]) >> 5;
                  unint64_t v115 = v114 + 1;
                  if ((unint64_t)(v114 + 1) >> 59) {
LABEL_378:
                  }
                    sub_10006A748();
                  int64_t v116 = *((void *)&v277 + 1) - (unint64_t)__p[1];
                  if ((uint64_t)(*((void *)&v277 + 1) - (unint64_t)__p[1]) >> 4 > v115) {
                    unint64_t v115 = v116 >> 4;
                  }
                  if ((unint64_t)v116 >= 0x7FFFFFFFFFFFFFE0) {
                    unint64_t v117 = 0x7FFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v117 = v115;
                  }
                  if (v117) {
                    unint64_t v117 = (unint64_t)sub_1000509C0(v117);
                  }
                  else {
                    uint64_t v118 = 0;
                  }
                  long long v119 = (char *)(v117 + 32 * v114);
                  *(void *)long long v119 = v87;
                  *((_DWORD *)v119 + 2) = v91;
                  *((void *)v119 + 2) = v95;
                  *((void *)v119 + 3) = -1;
                  long long v120 = v119;
                  if (v102 != v113)
                  {
                    do
                    {
                      long long v121 = *((_OWORD *)v102 - 1);
                      *((_OWORD *)v120 - 2) = *((_OWORD *)v102 - 2);
                      *((_OWORD *)v120 - 1) = v121;
                      v120 -= 32;
                      v102 -= 32;
                    }
                    while (v102 != v113);
                    uint64_t v102 = (char *)__p[1];
                  }
                  uint64_t v103 = v119 + 32;
                  __p[1] = v120;
                  *((void *)&v277 + 1) = v117 + 32 * v118;
                  if (v102) {
                    operator delete(v102);
                  }
                }
                else
                {
                  *(void *)long long v277 = v87;
                  *((_DWORD *)v102 + 2) = v91;
                  uint64_t v103 = v102 + 32;
                  *((void *)v102 + 2) = v95;
                  *((void *)v102 + 3) = -1;
                }
                *(void *)&long long v277 = v103;
              }
              break;
            case 2:
LABEL_88:
              if (v95 == v87) {
                goto LABEL_162;
              }
              unint64_t v97 = (char *)v275[1];
              if (v275[1] >= __p[0])
              {
                long long v104 = (char *)v275[0];
                int64_t v105 = ((char *)v275[1] - (char *)v275[0]) >> 5;
                unint64_t v106 = v105 + 1;
                if ((unint64_t)(v105 + 1) >> 59) {
                  goto LABEL_378;
                }
                int64_t v107 = (char *)__p[0] - (char *)v275[0];
                if (((char *)__p[0] - (char *)v275[0]) >> 4 > v106) {
                  unint64_t v106 = v107 >> 4;
                }
                if ((unint64_t)v107 >= 0x7FFFFFFFFFFFFFE0) {
                  unint64_t v108 = 0x7FFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v108 = v106;
                }
                if (v108) {
                  unint64_t v108 = (unint64_t)sub_1000509C0(v108);
                }
                else {
                  uint64_t v109 = 0;
                }
                unint64_t v110 = v108 + 32 * v105;
                *(void *)unint64_t v110 = v87;
                *(_DWORD *)(v110 + 8) = v91;
                *(void *)(v110 + 16) = v95;
                *(void *)(v110 + 24) = -1;
                uint64_t v111 = (char *)v110;
                if (v97 != v104)
                {
                  do
                  {
                    long long v112 = *((_OWORD *)v97 - 1);
                    *((_OWORD *)v111 - 2) = *((_OWORD *)v97 - 2);
                    *((_OWORD *)v111 - 1) = v112;
                    v111 -= 32;
                    v97 -= 32;
                  }
                  while (v97 != v104);
                  unint64_t v97 = (char *)v275[0];
                }
                int v98 = (void *)(v110 + 32);
                v275[0] = v111;
                __p[0] = (void *)(v108 + 32 * v109);
                if (v97) {
                  operator delete(v97);
                }
              }
              else
              {
                *(void *)v275[1] = v87;
                *((_DWORD *)v97 + 2) = v91;
                int v98 = v97 + 32;
                *((void *)v97 + 2) = v95;
                *((void *)v97 + 3) = -1;
              }
              v275[1] = v98;
              break;
          }
LABEL_116:
          char v92 = 0;
          uint64_t v91 = 1;
          if ((v93 & 1) == 0) {
            goto LABEL_74;
          }
        }
      }
LABEL_162:
      char v141 = 0;
      unint64_t v31 = v263;
      uint64_t v85 = v265;
LABEL_164:
      unint64_t v60 = v270;
LABEL_165:
      LOBYTE(v278) = v141;
      uint64_t v143 = *((void *)&v279 + 1);
      uint64_t v142 = v279;
      goto LABEL_166;
    }
LABEL_74:
    uint64_t v89 = (void *)v86[1];
    if (v89)
    {
      do
      {
        double v86 = v89;
        uint64_t v89 = (void *)*v89;
      }
      while (v89);
    }
    else
    {
      do
      {
        uint64_t v89 = v86;
        double v86 = (void *)v86[2];
      }
      while ((void *)*v86 != v89);
    }
  }
  while (v86 != v274 + 1);
  uint64_t v241 = __p[1];
  uint64_t v242 = (void *)v277;
  uint64_t v143 = *((void *)&v279 + 1);
  uint64_t v142 = v279;
  long long v243 = (char *)v275[0];
  uint64_t v244 = (char *)v275[1];
  unint64_t v31 = v263;
  uint64_t v85 = v265;
  unint64_t v60 = v270;
  if (__p[1] == (void *)v277) {
    goto LABEL_356;
  }
  unint64_t v245 = (*((void *)&v279 + 1) - (void)v279) / 112;
  if (v275[0] == v275[1])
  {
    if (v245 <= 1) {
      unint64_t v245 = 1;
    }
  }
  else
  {
    if (v245 <= 1) {
      unint64_t v245 = 1;
    }
    uint64_t v246 = (char *)v275[0];
    do
    {
      if (v143 == v142)
      {
LABEL_331:
        uint64_t v250 = -1;
      }
      else
      {
        unint64_t v247 = v245;
        long long v248 = (_DWORD *)(v142 + 44);
        while (*(void *)(v248 - 3) != *(void *)v246 || *(v248 - 1) != *((_DWORD *)v246 + 2) || *v248 != 1)
        {
          v248 += 28;
          if (!--v247) {
            goto LABEL_331;
          }
        }
        uint64_t v250 = *(void *)(v248 - 7);
      }
      *((void *)v246 + 3) = v250;
      v246 += 32;
    }
    while (v246 != v244);
  }
  unint64_t v251 = v241;
  do
  {
    if (v143 == v142)
    {
LABEL_346:
      uint64_t v255 = -1;
    }
    else
    {
      unint64_t v252 = v245;
      uint64_t v253 = (_DWORD *)(v142 + 44);
      while (*(void *)(v253 - 3) != *(void *)v251 || *(v253 - 1) != v251[2] || *v253 != 1)
      {
        v253 += 28;
        if (!--v252) {
          goto LABEL_346;
        }
      }
      uint64_t v255 = *(void *)(v253 - 7);
    }
    *((void *)v251 + 3) = v255;
    v251 += 8;
  }
  while (v251 != (_DWORD *)v242);
  if (v243 == v244)
  {
    char v141 = 1;
    goto LABEL_165;
  }
  unint64_t v256 = v243;
  while (2)
  {
    long long v257 = v241;
    do
    {
      if (v257[2] == *((void *)v256 + 2) && v257[3] == *((void *)v256 + 3))
      {
        char v141 = 0;
        goto LABEL_165;
      }
      v257 += 4;
    }
    while (v257 != v242);
    v256 += 32;
    if (v256 != v244) {
      continue;
    }
    break;
  }
LABEL_356:
  LOBYTE(v278) = 1;
  if (v243 != v244)
  {
    int v240 = -1;
    uint64_t v258 = -1;
    uint64_t v259 = -1;
    while (1)
    {
      uint64_t v260 = *((void *)v243 + 2);
      if (v89)
      {
        BOOL v261 = v89;
        do
        {
          uint64_t v262 = v261[4];
          if (v260 >= v262)
          {
            if (v262 >= v260) {
              goto LABEL_367;
            }
            ++v261;
          }
          BOOL v261 = (void *)*v261;
        }
        while (v261);
      }
      if ((v258 & 0x8000000000000000) == 0 && v259 != v260) {
        break;
      }
      uint64_t v258 = *(void *)v243;
      int v240 = *((_DWORD *)v243 + 2);
      uint64_t v259 = *((void *)v243 + 2);
LABEL_367:
      v243 += 32;
      if (v243 == v244)
      {
        if (v258 < 0) {
          break;
        }
        uint64_t v156 = v265;
        *double v265 = v258;
        goto LABEL_301;
      }
    }
  }
LABEL_166:
  uint64_t v144 = sub_101252A2C(a1, v142, v143);
  if (v144 < 1 || *((void *)&v279 + 1) == (void)v279) {
    goto LABEL_183;
  }
  uint64_t v145 = 0;
  unint64_t v146 = (*((void *)&v279 + 1) - (void)v279) / 112;
  uint64_t v147 = v146 <= 1 ? 1 : (*((void *)&v279 + 1) - (void)v279) / 112;
  uint64_t v148 = v279 + 32;
  double v149 = 0.0;
  uint64_t v150 = (*((void *)&v279 + 1) - (void)v279) / 112;
  do
  {
    uint64_t v151 = *(void *)(v148 - 16);
    if (v151 > v144) {
      break;
    }
    if (v151 == v144)
    {
      unsigned int v152 = *(_DWORD *)(v148 + 8);
      if (v152 >= 2) {
        __assert_rtn("operator[]", "array.hpp", 117, "(i < N)&&(\"out of range\")");
      }
      uint64_t v153 = *(void *)(*(void *)(*(void *)(a1 + 16) + 8)
                       + (((*(void *)v148 + *(void *)(*(void *)(a1 + 16) + 32)) >> 1) & 0x7FFFFFFFFFFFFFF8))
           + 376 * ((*(_DWORD *)v148 + *(_DWORD *)(*(void *)(a1 + 16) + 32)) & 0xF)
           + 40;
      if (!*(unsigned char *)(v153 + 168 * v152 + 165))
      {
        uint64_t v154 = v153 + 168 * v152;
        if (*(double *)(v154 + 72) < v149 || v150 == v146)
        {
          double v149 = *(double *)(v154 + 72);
          uint64_t v150 = v145;
        }
      }
    }
    ++v145;
    v148 += 112;
  }
  while (v147 != v145);
  if (v150 == v146)
  {
LABEL_183:
    uint64_t v156 = v85;
    int v157 = 0;
  }
  else
  {
    uint64_t v239 = v279 + 112 * v150;
    uint64_t v156 = v85;
    uint64_t *v85 = *(void *)(v239 + 32);
    int v240 = *(_DWORD *)(v239 + 40);
LABEL_301:
    unsigned int *v60 = v240;
    int v157 = 1;
  }
  if (__p[1]) {
    operator delete(__p[1]);
  }
  if (v275[0]) {
    operator delete(v275[0]);
  }
  if (!(void)v279)
  {
    int v30 = v264;
    if (v157) {
      goto LABEL_308;
    }
    goto LABEL_312;
  }
  *((void *)&v279 + 1) = v279;
  operator delete((void *)v279);
  int v30 = v264;
  if ((v157 & 1) == 0) {
    goto LABEL_312;
  }
LABEL_308:
  unsigned int v181 = v269;
  uint64_t v29 = v156;
  if (v30 && *v156 == v266) {
LABEL_224:
  }
    unsigned int *v60 = v181;
LABEL_225:
  unsigned int v182 = *v60;
  if (*v60 >= 2) {
    goto LABEL_281;
  }
  uint64_t v183 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8)
                   + (((unint64_t)(*(void *)(*(void *)(a1 + 72) + 32) + *v29) >> 1) & 0x7FFFFFFFFFFFFFF8))
       + 376 * ((*(_DWORD *)(*(void *)(a1 + 72) + 32) + *(_DWORD *)v29) & 0xF);
  uint64_t v184 = v183 + 40;
  uint64_t v185 = v183 + 40 + 168 * v182;
  if (*(unsigned char *)(v185 + 165)) {
    return 5;
  }
  uint64_t v186 = v184 + 168 * v182;
  int v188 = *(_DWORD *)(v186 + 160);
  unint64_t v187 = (_DWORD *)(v186 + 160);
  if (v188 == 2) {
    return 5;
  }
  sub_101250E34(v31, (double *)v183);
  if (*(_DWORD *)v185 == 4)
  {
    uint64_t v190 = 0;
    char v191 = 1;
    do
    {
      char v192 = v191;
      uint64_t v193 = v184 + 168 * v190;
      int v195 = *(_DWORD *)(v193 + 160);
      uint64_t v194 = (_DWORD *)(v193 + 160);
      if (!v195) {
        *uint64_t v194 = 2;
      }
      char v191 = 0;
      uint64_t v190 = 1;
    }
    while ((v192 & 1) != 0);
  }
  else
  {
    *unint64_t v187 = 2;
  }
  uint64_t v196 = *(void *)(v183 + 24);
  if (v196 < 1) {
    return 0;
  }
  uint64_t v197 = *(void *)(a1 + 24);
  long long v200 = *(void **)(v197 + 8);
  uint64_t v198 = (void *)(v197 + 8);
  long long v199 = v200;
  if (!v200) {
    goto LABEL_247;
  }
  uint64_t v201 = *(void *)(v184 + 168 * v182 + 128);
  uint64_t v202 = v198;
  do
  {
    uint64_t v203 = v199[4];
    BOOL v204 = v203 < v196;
    if (v203 >= v196) {
      long long v205 = v199;
    }
    else {
      long long v205 = v199 + 1;
    }
    if (!v204) {
      uint64_t v202 = v199;
    }
    long long v199 = (void *)*v205;
  }
  while (*v205);
  if (v202 == v198 || v202[4] > v196) {
LABEL_247:
  }
    __assert_rtn("set_visited_in_cluster", "traversal.hpp", 162, "mit != m_clusters.end()");
  long long v224 = (void *)v202[5];
  int v225 = v202 + 6;
  if (v224 == v202 + 6) {
    return 0;
  }
  uint64_t v226 = *(void *)(a1 + 16);
  uint64_t v227 = *(void *)(v226 + 32);
  uint64_t v228 = *(void *)(v226 + 8);
  do
  {
    uint64_t v229 = 0;
    uint64_t v230 = *(void *)(v228 + (((unint64_t)(v224[4] + v227) >> 1) & 0x7FFFFFFFFFFFFFF8))
         + 376 * ((*((_DWORD *)v224 + 8) + v227) & 0xF)
         + 40;
    char v231 = 1;
    do
    {
      char v232 = v231;
      uint64_t v233 = v230 + 168 * v229;
      int v235 = *(_DWORD *)(v233 + 160);
      uint64_t v234 = (_DWORD *)(v233 + 160);
      if (v235) {
        BOOL v236 = 0;
      }
      else {
        BOOL v236 = *((void *)v234 - 4) == v201;
      }
      if (v236) {
        *uint64_t v234 = 2;
      }
      char v231 = 0;
      uint64_t v229 = 1;
    }
    while ((v232 & 1) != 0);
    int64_t v237 = (void *)v224[1];
    if (v237)
    {
      do
      {
        unint64_t v238 = v237;
        int64_t v237 = (void *)*v237;
      }
      while (v237);
    }
    else
    {
      do
      {
        unint64_t v238 = (void *)v224[2];
        BOOL v19 = *v238 == (void)v224;
        long long v224 = v238;
      }
      while (!v19);
    }
    uint64_t result = 0;
    long long v224 = v238;
  }
  while (v238 != v225);
  return result;
}

void sub_101252494(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,void *a24,uint64_t a25,uint64_t a26,void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  if (a24) {
    operator delete(a24);
  }
  uint64_t v29 = *(void **)(v27 - 160);
  if (v29)
  {
    *(void *)(v27 - 152) = v29;
    operator delete(v29);
  }
  _Unwind_Resume(exception_object);
}

void sub_1012524EC(char **a1, unint64_t a2)
{
  double v3 = *a1;
  double v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 4;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    uint64_t v18 = &v3[16 * a2];
    goto LABEL_19;
  }
  unint64_t v6 = a2 - v5;
  unsigned int v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 4)
  {
    bzero(a1[1], 16 * v6);
    uint64_t v18 = &v4[16 * v6];
LABEL_19:
    a1[1] = v18;
    return;
  }
  if (a2 >> 60) {
    sub_10006A748();
  }
  uint64_t v8 = v7 - v3;
  uint64_t v9 = v8 >> 3;
  if (v8 >> 3 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  uint64_t v11 = (char *)sub_1009C886C(v10);
  uint64_t v12 = &v11[16 * v5];
  int v14 = &v11[16 * v13];
  bzero(v12, 16 * v6);
  uint64_t v15 = &v12[16 * v6];
  long long v17 = *a1;
  unint64_t v16 = a1[1];
  if (v16 != *a1)
  {
    do
    {
      *((_OWORD *)v12 - 1) = *((_OWORD *)v16 - 1);
      v12 -= 16;
      v16 -= 16;
    }
    while (v16 != v17);
    unint64_t v16 = *a1;
  }
  *a1 = v12;
  a1[1] = v15;
  a1[2] = v14;
  if (v16)
  {
    operator delete(v16);
  }
}

void sub_101252604(char **a1, double *a2)
{
  double v4 = *a1;
  if (a1[1] - *a1 != 16) {
    goto LABEL_20;
  }
  double v5 = *((double *)v4 + 1);
  *(void *)&long long v46 = *(void *)v4;
  *(double *)&long long v45 = v5;
  sub_10123D770((double *)&v46, (double *)&v45, 1);
  double v6 = *(double *)&v46;
  double v7 = a2[1];
  *(double *)&long long v46 = *a2;
  *(double *)&long long v45 = v7;
  sub_10123D770((double *)&v46, (double *)&v45, 1);
  if (v6 != *(double *)&v46)
  {
    if ((*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || ((unint64_t)v46 & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_20;
    }
    double v40 = vabdd_f64(v6, *(double *)&v46);
    double v41 = fabs(v6);
    double v42 = fabs(*(double *)&v46);
    if (v41 >= v42) {
      double v42 = v41;
    }
    double v43 = v42 >= 1.0 ? v42 * 2.22044605e-16 : 2.22044605e-16;
    if (v40 > v43) {
      goto LABEL_20;
    }
  }
  if (v5 != v7)
  {
    if ((*(void *)&v5 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v7 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_20;
    }
    double v9 = vabdd_f64(v5, v7);
    double v10 = fabs(v5);
    double v11 = fabs(v7);
    if (v10 < v11) {
      double v10 = v11;
    }
    double v12 = v10 >= 1.0 ? v10 * 2.22044605e-16 : 2.22044605e-16;
    if (v9 > v12)
    {
LABEL_20:
      uint64_t v15 = a1[1];
      unint64_t v14 = (unint64_t)a1[2];
      if ((unint64_t)v15 >= v14)
      {
        uint64_t v17 = (v15 - *a1) >> 4;
        unint64_t v18 = v17 + 1;
        if ((unint64_t)(v17 + 1) >> 60) {
LABEL_64:
        }
          sub_10006A748();
        uint64_t v19 = v14 - (void)*a1;
        if (v19 >> 3 > v18) {
          unint64_t v18 = v19 >> 3;
        }
        if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v20 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v20 = v18;
        }
        if (v20) {
          unint64_t v20 = (unint64_t)sub_1009C886C(v20);
        }
        else {
          uint64_t v21 = 0;
        }
        uint64_t v22 = (char *)(v20 + 16 * v17);
        unint64_t v23 = v20 + 16 * v21;
        *(_OWORD *)uint64_t v22 = *(_OWORD *)a2;
        unint64_t v16 = v22 + 16;
        unint64_t v25 = *a1;
        unint64_t v24 = a1[1];
        if (v24 != *a1)
        {
          do
          {
            *((_OWORD *)v22 - 1) = *((_OWORD *)v24 - 1);
            v22 -= 16;
            v24 -= 16;
          }
          while (v24 != v25);
          unint64_t v24 = *a1;
        }
        *a1 = v22;
        a1[1] = v16;
        a1[2] = (char *)v23;
        if (v24) {
          operator delete(v24);
        }
      }
      else
      {
        *(_OWORD *)uint64_t v15 = *(_OWORD *)a2;
        unint64_t v16 = v15 + 16;
      }
      a1[1] = v16;
      if ((unint64_t)(v16 - *a1) >= 0x21)
      {
        do
        {
          unint64_t v26 = (double *)(v16 - 48);
          uint64_t v27 = (double *)(v16 - 32);
          if (sub_1012472B0(v26, v27, a2)) {
            break;
          }
          long long v28 = *(_OWORD *)v26;
          long long v45 = *(_OWORD *)v27;
          long long v46 = v28;
          long long v44 = *(_OWORD *)a2;
          if ((int)sub_10124E930((double *)&v46, (double *)&v45, (double *)&v44) > 0) {
            break;
          }
          sub_1012524EC(a1, ((a1[1] - *a1) >> 4) - 2);
          int v30 = a1[1];
          unint64_t v29 = (unint64_t)a1[2];
          if ((unint64_t)v30 >= v29)
          {
            uint64_t v31 = (v30 - *a1) >> 4;
            unint64_t v32 = v31 + 1;
            if ((unint64_t)(v31 + 1) >> 60) {
              goto LABEL_64;
            }
            uint64_t v33 = v29 - (void)*a1;
            if (v33 >> 3 > v32) {
              unint64_t v32 = v33 >> 3;
            }
            if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v34 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v34 = v32;
            }
            if (v34) {
              unint64_t v34 = (unint64_t)sub_1009C886C(v34);
            }
            else {
              uint64_t v35 = 0;
            }
            unsigned int v36 = (char *)(v34 + 16 * v31);
            *(_OWORD *)unsigned int v36 = *(_OWORD *)a2;
            uint64_t v38 = *a1;
            uint64_t v37 = a1[1];
            uint64_t v39 = v36;
            if (v37 != *a1)
            {
              do
              {
                *((_OWORD *)v39 - 1) = *((_OWORD *)v37 - 1);
                v39 -= 16;
                v37 -= 16;
              }
              while (v37 != v38);
              uint64_t v37 = *a1;
            }
            unint64_t v16 = v36 + 16;
            *a1 = v39;
            a1[1] = v36 + 16;
            a1[2] = (char *)(v34 + 16 * v35);
            if (v37) {
              operator delete(v37);
            }
          }
          else
          {
            *(_OWORD *)int v30 = *(_OWORD *)a2;
            unint64_t v16 = v30 + 16;
          }
          a1[1] = v16;
        }
        while ((unint64_t)(v16 - *a1) > 0x20);
      }
    }
  }
}

void sub_10125295C(unint64_t *a1, double *a2, uint64_t a3, uint64_t a4, int a5, void *a6, uint64_t *a7, uint64_t *a8, char a9)
{
  double v14 = sub_10124CF68(a1, a2, (int *)a3, a4, a5, a7, a8, 0);
  if (a9)
  {
    uint64_t v16 = *(void *)(a3 + 8);
    if (v16 == *a6 && *(void *)(a3 + 24) == a6[2] && *(void *)(a3 + 16) == a6[1])
    {
      double v17 = v14;
      unint64_t v18 = v15;
      if (v16) {
        uint64_t v19 = a8;
      }
      else {
        uint64_t v19 = a7;
      }
      uint64_t v20 = sub_101249034(v19, a6, (void *)(a3 + 8));
      unint64_t v21 = a1[5];
      if (!v21 || v20 < (uint64_t)a1[6])
      {
        *((double *)a1 + 3) = v17;
        a1[4] = v18;
        a1[6] = v20;
      }
      a1[5] = v21 + 1;
    }
  }
}

uint64_t sub_101252A2C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(a2 + 40);
  if (v3 >= 2) {
LABEL_23:
  }
    __assert_rtn("operator[]", "array.hpp", 117, "(i < N)&&(\"out of range\")");
  if (a3 == a2) {
    return -1;
  }
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(v4 + 32);
  uint64_t v6 = *(void *)(v4 + 8);
  unint64_t v7 = (a3 - a2) / 112;
  uint64_t v8 = (void *)(*(void *)(v6 + (((unint64_t)(*(void *)(a2 + 32) + v5) >> 1) & 0x7FFFFFFFFFFFFFF8))
                + 376 * ((*(_DWORD *)(a2 + 32) + v5) & 0xF)
                + 168 * v3
                + 184);
  if (v7 <= 1) {
    unint64_t v7 = 1;
  }
  for (uint64_t i = (_DWORD *)(a2 + 44); ; i += 28)
  {
    uint64_t result = *(void *)(i - 7);
    if (result && *i != 0)
    {
      unsigned int v12 = *(i - 1);
      if (v12 >= 2) {
        goto LABEL_23;
      }
      uint64_t v13 = *(void *)(v6 + (((unint64_t)(*(void *)(i - 3) + v5) >> 1) & 0x7FFFFFFFFFFFFFF8))
          + 376 * ((*(i - 3) + v5) & 0xF)
          + 40;
      int v14 = *(_DWORD *)(v13 + 168 * v12);
      if (v14 == 4 || v14 == 2)
      {
        uint64_t v16 = v13 + 168 * v12;
        uint64_t v17 = *(void *)(v16 + 144);
        int v18 = *(unsigned __int8 *)(v16 + 152);
        if (*v8 == v17 || v18 == 0) {
          break;
        }
      }
    }
    if (!--v7) {
      return -1;
    }
  }
  return result;
}

void *sub_101252B54(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_100A61D48(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_101252BB4(_Unwind_Exception *exception_object)
{
  unsigned int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **sub_101252BD0(uint64_t **a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (!v5)
  {
    double v10 = a1 + 1;
    goto LABEL_18;
  }
  uint64_t v7 = *a2;
  size_t v8 = (uint64_t *)a2[1];
  double v9 = (uint64_t *)a2[2];
  do
  {
    while (1)
    {
      double v10 = (uint64_t **)v5;
      uint64_t v11 = v5[4];
      if (v7 != v11) {
        break;
      }
      unsigned int v12 = v10[5];
      if (v8 != v12)
      {
        if ((uint64_t)v8 < (uint64_t)v12) {
          goto LABEL_12;
        }
        if ((uint64_t)v12 >= (uint64_t)v8) {
          return v10;
        }
        goto LABEL_15;
      }
      uint64_t v13 = v10[6];
      if ((uint64_t)v9 >= (uint64_t)v13)
      {
        if ((uint64_t)v13 >= (uint64_t)v9) {
          return v10;
        }
        goto LABEL_15;
      }
LABEL_12:
      uint64_t v5 = *v10;
      uint64_t v6 = v10;
      if (!*v10) {
        goto LABEL_18;
      }
    }
    if (v7 < v11) {
      goto LABEL_12;
    }
    if (v11 >= v7) {
      return v10;
    }
LABEL_15:
    uint64_t v5 = v10[1];
  }
  while (v5);
  uint64_t v6 = v10 + 1;
LABEL_18:
  int v14 = (uint64_t *)v10;
  double v10 = (uint64_t **)operator new(0x40uLL);
  *((_OWORD *)v10 + 2) = *(_OWORD *)a3;
  void v10[6] = *(uint64_t **)(a3 + 16);
  *((_WORD *)v10 + 28) = 0;
  *((unsigned char *)v10 + 58) = 0;
  uint64_t *v10 = 0;
  v10[1] = 0;
  v10[2] = v14;
  void *v6 = (uint64_t *)v10;
  unint64_t v15 = (uint64_t *)**a1;
  uint64_t v16 = (uint64_t *)v10;
  if (v15)
  {
    *a1 = v15;
    uint64_t v16 = *v6;
  }
  sub_100046C90(a1[1], v16);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return v10;
}

uint64_t sub_101252CF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v29 = 0u;
  long long v30 = 0u;
  long long v28 = 0u;
  char v27 = 0;
  long long __p = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  sub_10123CCD0(a1, (uint64_t)&__p, 0);
  v31.i64[0] = a1;
  v31.i64[1] = a2;
  uint64_t v32 = a3;
  uint64_t v33 = &v28;
  unint64_t v34 = &v27;
  uint64_t v35 = 0;
  uint64_t v7 = (double *)__p;
  uint64_t v6 = v37;
  if (0xEEEEEEEEEEEEEEEFLL * (((char *)v37 - (unsigned char *)__p) >> 3) <= 0x10)
  {
LABEL_27:
    while (v7 != v6)
    {
      uint64_t v20 = (uint64_t)v7;
      v7 += 15;
      uint64_t v21 = (uint64_t)v7;
      if (v7 != v6)
      {
        while ((sub_1012534CC((uint64_t)&v31, v20, v21) & 1) != 0)
        {
          uint64_t v6 = (double *)(v21 + 120);
          uint64_t v21 = (uint64_t)v6;
          if (v6 == v37) {
            goto LABEL_27;
          }
        }
        break;
      }
    }
  }
  else
  {
    double v40 = 0;
    double v41 = 0;
    unint64_t v42 = 0;
    v39[0] = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    v39[1] = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    if (__p != v37)
    {
      size_t v8 = 0;
      do
      {
        sub_101240044((double *)v39[0].i64, v7 + 4);
        if ((unint64_t)v8 >= v42)
        {
          double v10 = v40;
          uint64_t v11 = v8 - v40;
          unint64_t v12 = v11 + 1;
          if ((unint64_t)(v11 + 1) >> 61) {
            sub_10006A748();
          }
          uint64_t v13 = v42 - (void)v40;
          if ((uint64_t)(v42 - (void)v40) >> 2 > v12) {
            unint64_t v12 = v13 >> 2;
          }
          if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v14 = v12;
          }
          if (v14) {
            unint64_t v14 = (unint64_t)sub_100048350(v14);
          }
          else {
            uint64_t v15 = 0;
          }
          uint64_t v16 = (uint64_t *)(v14 + 8 * v11);
          uint64_t *v16 = (uint64_t)v7;
          double v9 = v16 + 1;
          if (v8 != v10)
          {
            do
            {
              uint64_t v17 = *--v8;
              *--uint64_t v16 = v17;
            }
            while (v8 != v10);
            size_t v8 = v40;
          }
          double v40 = v16;
          unint64_t v42 = v14 + 8 * v15;
          if (v8) {
            operator delete(v8);
          }
        }
        else
        {
          uint64_t *v8 = (uint64_t)v7;
          double v9 = v8 + 1;
        }
        double v41 = v9;
        v7 += 15;
        size_t v8 = v9;
      }
      while (v7 != v37);
    }
    sub_1012530BC((double *)v39[0].i64, &v40, 0, (uint64_t)&v31);
    if (v40) {
      operator delete(v40);
    }
  }
  if (__p) {
    operator delete(__p);
  }
  int v18 = (void *)(*((void *)&v28 + 1) + 8 * ((unint64_t)v30 / 0x14));
  if ((void)v29 == *((void *)&v28 + 1)) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = (_DWORD *)(*v18 + 200 * ((unint64_t)v30 % 0x14));
  }
LABEL_33:
  uint64_t v22 = v19 - 1000;
  while (1)
  {
    unint64_t v23 = (void)v29 == *((void *)&v28 + 1)
        ? 0
        : *(void *)(*((void *)&v28 + 1) + 8 * ((*((void *)&v30 + 1) + (void)v30) / 0x14uLL))
        + 200 * ((*((void *)&v30 + 1) + (void)v30) % 0x14uLL);
    if (v19 == (_DWORD *)v23) {
      return sub_1012573E0((uint64_t)&v28);
    }
    int v24 = v19[10];
    if (v24 == 1)
    {
      if (v19[30] != 1) {
        goto LABEL_47;
      }
    }
    else if (v24 != 2 || v19[30] != 2)
    {
LABEL_47:
      v39[0].i64[0] = (uint64_t)&off_101AA3F70;
      v31.i64[0] = (uint64_t)"/AppleInternal/Library/BuildRoots/7a5643da-a7fb-11ef-987a-36218cb420d5/Applications/Xcode.ap"
                            "p/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.2.Internal.sdk/us"
                            "r/local/include/boost/geometry/algorithms/detail/has_self_intersections.hpp";
      v31.i64[1] = (uint64_t)"BOOL boost::geometry::detail::overlay::has_self_intersections(const Geometry &, const Strate"
                            "gy &, const RobustPolicy &, BOOL) [Geometry = boost::geometry::model::polygon<boost::geometr"
                            "y::model::point<double, 2, boost::geometry::cs::spherical_equatorial<boost::geometry::degree"
                            ">>>, Strategy = boost::geometry::strategies::relate::spherical<>, RobustPolicy = boost::geom"
                            "etry::detail::no_rescale_policy]";
      uint64_t v32 = 129;
      sub_101253078(&v31);
    }
    if ((v19[4] - 3) >= 2) {
      goto LABEL_47;
    }
    v22 += 50;
    v19 += 50;
    if ((_DWORD *)*v18 == v22)
    {
      unint64_t v25 = (_DWORD *)v18[1];
      ++v18;
      uint64_t v19 = v25;
      goto LABEL_33;
    }
  }
}

void sub_10125302C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  sub_1012573E0((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_101253078(int8x16_t *a1)
{
  exception = __cxa_allocate_exception(0x38uLL);
  sub_101256CF4((uint64_t)exception, a1);
}

uint64_t sub_1012530BC(double *a1, uint64_t **a2, unint64_t a3, uint64_t a4)
{
  double v6 = (*a1 + a1[2]) * 0.5;
  long long v7 = *((_OWORD *)a1 + 1);
  long long v48 = *(_OWORD *)a1;
  uint64_t v50 = *((void *)&v7 + 1);
  v46[1] = *((double *)&v48 + 1);
  long long v47 = v7;
  double v49 = v6;
  v46[0] = v6;
  double v43 = 0;
  long long v44 = 0;
  uint64_t v45 = 0;
  long long __p = 0;
  double v41 = 0;
  uint64_t v42 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  sub_101240254((double *)&v48, v46, a2, &v43, &__p, (void **)&v37);
  size_t v8 = v37;
  double v9 = v38;
  if (v37 != v38)
  {
    int64x2_t v51 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    int64x2_t v52 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    double v10 = v37;
    do
      sub_101240044((double *)v51.i64, (double *)(*v10++ + 32));
    while (v10 != v9);
    v36[0] = v51;
    v36[1] = v52;
    unint64_t v11 = (char *)v9 - (char *)v8;
    unint64_t v12 = v8;
    if (a3 > 0x63 || (unint64_t v12 = v8, v11 <= 0x78))
    {
LABEL_16:
      unint64_t v14 = v12 + 1;
      if (v12 + 1 != v9)
      {
        uint64_t v13 = v12 + 1;
        while ((sub_1012534CC(a4, *v12, *v13) & 1) != 0)
        {
          if (++v13 == v9)
          {
            ++v12;
            if (v14 == v9) {
              goto LABEL_7;
            }
            goto LABEL_16;
          }
        }
        goto LABEL_41;
      }
    }
    else if (!sub_101255254((double *)v36, &v37, a3 + 1, a4))
    {
      goto LABEL_41;
    }
LABEL_7:
    if (v11 < 0x80 || a3 > 0x63 || (unint64_t)((char *)v44 - (unsigned char *)v43) < 0x79)
    {
      uint64_t v15 = (uint64_t *)v43;
      uint64_t v16 = v44;
      if (v43 != v44)
      {
        uint64_t v17 = v44;
        int v18 = v8;
        while (1)
        {
          uint64_t v19 = v15;
          BOOL v20 = v15 == v17;
          uint64_t v17 = v15;
          if (!v20) {
            break;
          }
LABEL_24:
          if (++v18 == v9) {
            goto LABEL_25;
          }
        }
        while ((sub_1012534CC(a4, *v18, *v19) & 1) != 0)
        {
          if (++v19 == v16)
          {
            uint64_t v17 = v16;
            goto LABEL_24;
          }
        }
        goto LABEL_41;
      }
    }
    else if (!sub_101255D8C((double *)v36, &v37, (uint64_t **)&v43, a3 + 1, a4))
    {
      goto LABEL_41;
    }
LABEL_25:
    if (v11 >= 0x80 && a3 <= 0x63 && (unint64_t)((char *)v41 - (unsigned char *)__p) >= 0x79)
    {
      if (sub_101255D8C((double *)v36, &v37, (uint64_t **)&__p, a3 + 1, a4)) {
        goto LABEL_38;
      }
LABEL_41:
      uint64_t v28 = 0;
      goto LABEL_42;
    }
    if (v8 != v9)
    {
      uint64_t v21 = (uint64_t *)__p;
      uint64_t v22 = v41;
      if (__p != v41)
      {
        unint64_t v23 = v41;
        int v24 = v8;
        while (1)
        {
          unint64_t v25 = v21;
          BOOL v20 = v21 == v23;
          unint64_t v23 = v21;
          if (!v20) {
            break;
          }
LABEL_33:
          if (++v24 == v9) {
            goto LABEL_38;
          }
        }
        while ((sub_1012534CC(a4, *v24, *v25) & 1) != 0)
        {
          if (++v25 == v22)
          {
            unint64_t v23 = v22;
            goto LABEL_33;
          }
        }
        goto LABEL_41;
      }
    }
  }
LABEL_38:
  char v27 = (uint64_t *)v43;
  unint64_t v26 = v44;
  if (a3 > 0x63 || (unint64_t)((char *)v44 - (unsigned char *)v43) < 0x79)
  {
    if (v43 != v44)
    {
LABEL_50:
      long long v30 = v27 + 1;
      int8x16_t v31 = v27 + 1;
      if (v27 + 1 != v26)
      {
        while ((sub_1012534CC(a4, *v27, *v31) & 1) != 0)
        {
          if (++v31 == v26)
          {
            ++v27;
            if (v30 != v26) {
              goto LABEL_50;
            }
            goto LABEL_54;
          }
        }
        goto LABEL_41;
      }
    }
  }
  else if (!sub_101255254((double *)&v48, (uint64_t **)&v43, a3 + 1, a4))
  {
    goto LABEL_41;
  }
LABEL_54:
  uint64_t v33 = (uint64_t *)__p;
  uint64_t v32 = v41;
  if (a3 > 0x63 || (unint64_t)((char *)v41 - (unsigned char *)__p) < 0x79)
  {
    if (__p != v41)
    {
LABEL_58:
      unint64_t v34 = v33 + 1;
      uint64_t v35 = v33 + 1;
      if (v33 + 1 != v32)
      {
        while ((sub_1012534CC(a4, *v33, *v35) & 1) != 0)
        {
          if (++v35 == v32)
          {
            uint64_t v28 = 1;
            ++v33;
            if (v34 != v32) {
              goto LABEL_58;
            }
            goto LABEL_42;
          }
        }
        goto LABEL_41;
      }
    }
    uint64_t v28 = 1;
  }
  else
  {
    uint64_t v28 = sub_101255254(v46, (uint64_t **)&__p, a3 + 1, a4);
  }
LABEL_42:
  if (v8) {
    operator delete(v8);
  }
  if (__p) {
    operator delete(__p);
  }
  if (v43) {
    operator delete(v43);
  }
  return v28;
}

void sub_101253478(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20)
{
  if (v20) {
    operator delete(v20);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1012534CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = a2;
  double v6 = *(double *)(a2 + 32);
  double v7 = *(double *)(a2 + 48);
  double v8 = *(double *)(a3 + 32);
  double v9 = *(double *)(a3 + 48);
  if (v7 - v6 >= 360.0 || v9 - v8 >= 360.0) {
    goto LABEL_11;
  }
  double v10 = vabdd_f64(v8, v6);
  double v11 = 180.0;
  if (v10 == 180.0) {
    goto LABEL_4;
  }
  double v12 = v8 - v6;
  if (COERCE__INT64(fabs(v8 - v6)) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v34 = fabs(v10 + -180.0);
    double v11 = 180.0;
    if (v10 < 180.0) {
      double v10 = 180.0;
    }
    double v35 = v10 >= 1.0 ? v10 * 2.22044605e-16 : 2.22044605e-16;
    if (v34 <= v35) {
      goto LABEL_4;
    }
  }
  double v11 = 180.0;
  if (v12 <= 180.0)
  {
    if (v12 >= -180.0) {
      goto LABEL_5;
    }
    double v11 = fmod(v12 + -180.0, 360.0) + 180.0;
LABEL_4:
    double v12 = v11;
    goto LABEL_5;
  }
  double v12 = fmod(v12 + 180.0, 360.0) + -180.0;
  if (v12 == -180.0) {
    goto LABEL_4;
  }
  BOOL v36 = ((*(void *)&v12 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
     && (*(void *)&v12 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
  _ZF = !v36 || *(void *)&v12 == 0;
  if (_ZF)
  {
    double v11 = 180.0;
    double v38 = fabs(v12 + 180.0);
    double v39 = fabs(v12);
    if (v39 < 180.0) {
      double v39 = 180.0;
    }
    double v40 = v39 >= 1.0 ? v39 * 2.22044605e-16 : 2.22044605e-16;
    if (v38 <= v40) {
      goto LABEL_4;
    }
  }
LABEL_5:
  if (v12 < 0.0) {
    double v12 = v12 + 360.0;
  }
  double v13 = v6 + v12;
  double v14 = v9 - v8 + v6 + v12 + -360.0;
  if (vabdd_f64(v14, v9) < 180.0) {
    double v14 = v9;
  }
  if (v13 > v7 && v14 < v6) {
    return 1;
  }
LABEL_11:
  if (*(double *)(v4 + 56) < *(double *)(v3 + 40)
    || *(double *)(v4 + 40) > *(double *)(v3 + 56)
    || *(unsigned __int8 *)(v4 + 96) | *(unsigned __int8 *)(v3 + 96))
  {
    return 1;
  }
  uint64_t v293 = *(int *)(a1 + 40);
  uint64_t v15 = *(double ***)a1;
  int v290 = *(unsigned __int8 *)(a1 + 44);
  long long v292 = *(_OWORD *)(a1 + 8);
  uint64_t v16 = *(void **)(a1 + 24);
  unint64_t v17 = *(void *)(v4 + 24);
  int v18 = *(double ***)a1;
  if ((v17 & 0x8000000000000000) == 0)
  {
    uint64_t v19 = v15[3];
    if (0xAAAAAAAAAAAAAAABLL * (v15[4] - v19) < v17) {
      goto LABEL_462;
    }
    int v18 = (double **)&v19[3 * v17];
  }
  BOOL v20 = *v18;
  uint64_t v21 = v18[1];
  unint64_t v22 = *(void *)(v3 + 24);
  int v264 = *(unsigned char **)(a1 + 32);
  if ((v22 & 0x8000000000000000) != 0) {
    goto LABEL_20;
  }
  int v24 = v15 + 3;
  unint64_t v23 = v15[3];
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24[1] - (void)v23) >> 3) < v22) {
LABEL_462:
  }
    __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
  uint64_t v15 = (double **)&v23[3 * v22];
LABEL_20:
  uint64_t v298 = v15[1];
  long long v299 = *v15;
  int v25 = *(_DWORD *)v4;
  int v296 = *(_DWORD *)v3;
  uint64_t v297 = *(void *)(v4 + 104);
  uint64_t v27 = *(void *)(v4 + 64);
  uint64_t v26 = *(void *)(v4 + 72);
  uint64_t v28 = &v20[2 * v27];
  if (v27 != v26)
  {
    uint64_t v301 = *(void *)(v4 + 72);
    uint64_t v29 = 16 * v26 - 16 * v27;
    long long v30 = &v20[2 * v27];
    while (1)
    {
      uint64_t v31 = v27;
      double v32 = v30[2];
      v30 += 2;
      if (!sub_1012429C0(v25, v32, v6, v7, v8, v9)) {
        break;
      }
      uint64_t v27 = v31 + 1;
      ++v297;
      uint64_t result = 1;
      uint64_t v28 = v30;
      v29 -= 16;
      if (!v29) {
        return result;
      }
    }
    uint64_t v27 = v31;
    uint64_t v26 = v301;
  }
  uint64_t v278 = &v20[2 * v26];
  if (v28 != v278)
  {
    double v41 = &v20[2 * (v28 != v20)];
    if (v28 + 2 != v21) {
      double v41 = v28 + 2;
    }
    uint64_t v42 = v41 + 2;
    double v43 = &v20[2 * (v41 != v20)];
    if (v42 != v21) {
      double v43 = v42;
    }
    long long v289 = v43;
    int v279 = -v25;
    long long v44 = v28 + 2;
    double v45 = 1.0;
    uint64_t v284 = v3;
    double v287 = v16;
    uint64_t v288 = v4;
    int v270 = v21;
    long long v271 = v20;
    while (1)
    {
      uint64_t v295 = v27;
      double v46 = *(double *)(v4 + 32);
      double v47 = *(double *)(v4 + 48);
      double v48 = *(double *)(v3 + 32);
      double v49 = *(double *)(v3 + 48);
      if (sub_1012429C0(v279, *v28, v46, v47, v48, v49)) {
        return 1;
      }
      memset(v328, 0, sizeof(v328));
      v322[0] = v4;
      v322[1] = v295;
      double v285 = v44;
      double v286 = v28;
      long long v323 = v28;
      int v324 = v44;
      unsigned int v325 = v289;
      BOOL v326 = v20;
      int v327 = v21;
      LOBYTE(v328[0]) = 1;
      uint64_t v51 = *(void *)(v3 + 64);
      uint64_t v50 = *(void *)(v3 + 72);
      int64x2_t v52 = &v299[2 * v51];
      uint64_t v53 = *(void *)(v3 + 104);
      if (v51 != v50)
      {
        uint64_t v259 = 16 * v50 - 16 * v51;
        uint64_t v260 = &v299[2 * v51];
        while (1)
        {
          double v261 = v260[2];
          v260 += 2;
          if (!sub_1012429C0(v296, v261, v48, v49, v46, v47)) {
            break;
          }
          ++v51;
          ++v53;
          int64x2_t v52 = v260;
          v259 -= 16;
          if (!v259) {
            goto LABEL_455;
          }
        }
      }
      long long v294 = &v299[2 * v50];
      if (v52 != v294) {
        break;
      }
LABEL_455:
      ++v297;
      uint64_t v4 = v288;
LABEL_456:
      uint64_t v28 = v286 + 2;
      long long v44 = v285 + 2;
      uint64_t v27 = v295 + 1;
      uint64_t v262 = v289 + 2;
      uint64_t v21 = v270;
      BOOL v20 = v271;
      if (v289 + 2 == v270) {
        uint64_t v262 = &v271[2 * (v289 != v271)];
      }
      long long v289 = v262;
      uint64_t result = 1;
      if (v285 == v278) {
        return result;
      }
    }
    int v54 = v52 + 2;
    uint64_t v55 = &v299[2 * (v52 != v299)];
    if (v52 + 2 != v298) {
      uint64_t v55 = v52 + 2;
    }
    char v56 = v55 + 2;
    char v57 = &v299[2 * (v55 != v299)];
    if (v56 != v298) {
      char v57 = v56;
    }
    long long v302 = v57;
    ++v297;
    uint64_t v58 = v287;
    uint64_t v4 = v288;
    while (1)
    {
      uint64_t v300 = v54;
      if (sub_1012429C0(-v296, *v52, *(double *)(v3 + 32), *(double *)(v3 + 48), *(double *)(v4 + 32), *(double *)(v4 + 48)))
      {
        goto LABEL_456;
      }
      uint64_t v59 = *(void *)(v4 + 16);
      uint64_t v60 = *(void *)(v3 + 16);
      if (v59 != v60
        || !v290
        || *(void *)(v4 + 24) != *(void *)(v3 + 24)
        || v53 != v297 && (v295 || *(void *)(v4 + 88) - 2 > v51))
      {
        break;
      }
LABEL_325:
      v52 += 2;
      ++v51;
      int v195 = v302 + 2;
      if (v302 + 2 == v298) {
        int v195 = &v299[2 * (v302 != v299)];
      }
      long long v302 = v195;
      ++v53;
      int v54 = v300 + 2;
      if (v300 == v294) {
        goto LABEL_456;
      }
    }
    uint64_t v61 = 0;
    memset(v321, 0, sizeof(v321));
    v316[0] = v3;
    v316[1] = v51;
    v316[2] = v52;
    long long v317 = v300;
    long long v318 = v302;
    char v319 = v299;
    long long v320 = v298;
    double v315 = 0.0;
    long long v313 = 0u;
    long long v314 = 0u;
    long long v311 = 0u;
    long long v312 = 0u;
    long long v309 = 0u;
    long long v310 = 0u;
    long long v307 = 0u;
    long long v308 = 0u;
    long long v305 = 0u;
    long long v306 = 0u;
    long long v303 = 0u;
    *(void *)&long long v304 = 0;
    *((void *)&v304 + 1) = -1;
    *(void *)&long long v62 = -1;
    *((void *)&v62 + 1) = -1;
    do
    {
      uint64_t v63 = (char *)&v303 + v61;
      *((_DWORD *)v63 + 10) = 0;
      *((_OWORD *)v63 + 3) = v62;
      *((_OWORD *)v63 + 4) = v62;
      *((void *)v63 + 10) = -1;
      *(_OWORD *)(v63 + 88) = xmmword_1015E0D30;
      v61 += 80;
      *((void *)v63 + 13) = 0;
      *((void *)v63 + 14) = 0;
    }
    while (v61 != 160);
    uint64_t v64 = *(void *)(v4 + 24);
    *(void *)&long long v306 = v293;
    *((void *)&v306 + 1) = v59;
    *(void *)&long long v307 = v64;
    *((void *)&v307 + 1) = v295;
    uint64_t v65 = *(void *)(v3 + 24);
    *(void *)&long long v308 = -1;
    *(void *)&long long v311 = v293;
    *((void *)&v311 + 1) = v60;
    *(void *)&long long v312 = v65;
    *((void *)&v312 + 1) = v51;
    *(void *)&long long v313 = -1;
    unint64_t v66 = v58[5];
    memset(v352, 0, sizeof(v352));
    long long v350 = 0u;
    long long v351 = 0u;
    memset(v349, 0, sizeof(v349));
    long long v347 = 0u;
    long long v348 = 0u;
    long long v346 = 0u;
    memset(v345, 0, sizeof(v345));
    uint64_t v340 = 0;
    long long v342 = 0u;
    unsigned int v338 = v322;
    int v339 = v316;
    int v341 = v322;
    *(void *)&long long v342 = v316;
    BOOL v343 = v316;
    int v344 = v322;
    sub_101243388((uint64_t)v345, v323, v324, v52, v300);
    *(_OWORD *)&v352[3] = v292;
    if (BYTE8(v350) == 100)
    {
LABEL_312:
      unint64_t v184 = v58[5];
      if (v184 < v66) {
        goto LABEL_462;
      }
      unint64_t v185 = v58[4];
      uint64_t v186 = v58[1];
      uint64_t v187 = v58[2];
      int v188 = (void *)(v186 + 8 * (v185 / 0x14));
      if (v187 == v186)
      {
        unint64_t v189 = 0;
        if (!v66) {
          goto LABEL_320;
        }
      }
      else
      {
        unint64_t v189 = *v188 + 200 * (v185 % 0x14);
        if (!v66)
        {
LABEL_320:
          unint64_t v192 = v185 + v184;
          uint64_t v193 = (void *)(v186 + 8 * (v192 / 0x14));
          if (v187 == v186) {
            unint64_t v194 = 0;
          }
          else {
            unint64_t v194 = *v193 + 200 * (v192 % 0x14);
          }
          if (v189 != v194
            && 20 * (v193 - v188) - 0x70A3D70A3D70A3D7 * ((uint64_t)(v194 - *v193) >> 3) != 0x8F5C28F5C28F5C29
                                                                                           * ((uint64_t)(v189 - *v188) >> 3))
          {
            uint64_t result = 0;
            *int v264 = 1;
            return result;
          }
          goto LABEL_325;
        }
      }
      uint64_t v190 = v66 - 0x70A3D70A3D70A3D7 * ((uint64_t)(v189 - *v188) >> 3);
      if (v190 < 1)
      {
        unint64_t v191 = 19 - v190;
        v188 -= v191 / 0x14;
        unint64_t v189 = *v188 + 200 * (20 * (v191 / 0x14) - v191) + 3800;
      }
      else
      {
        v188 += v190 / 0x14uLL;
        unint64_t v189 = *v188 + 200 * (v190 % 0x14uLL);
      }
      goto LABEL_320;
    }
    unint64_t v291 = v66;
    *(_OWORD *)int v336 = v313;
    *(_OWORD *)&v336[16] = v314;
    double v337 = v315;
    *(_OWORD *)&v332[16] = v309;
    long long v333 = v310;
    long long v334 = v311;
    long long v335 = v312;
    v331[0] = v305;
    v331[1] = v306;
    v331[2] = v307;
    *(_OWORD *)unsigned int v332 = v308;
    long long v329 = v303;
    long long v330 = v304;
    if (BYTE8(v350) <= 0x6Cu)
    {
      if (BYTE8(v350) != 99)
      {
        if (BYTE8(v350) == 105)
        {
          LODWORD(v330) = 2;
          if (!v345[0]) {
            goto LABEL_463;
          }
          long long v329 = *(_OWORD *)&v345[1];
          *(_OWORD *)&v332[8] = *(_OWORD *)&v345[5];
          *(void *)&v332[24] = v345[7];
          *(_OWORD *)&v336[8] = v346;
          *(void *)&v336[24] = v347;
          BOOL v67 = HIDWORD(v352[0]) == 1;
          DWORD2(v331[5 * (HIDWORD(v352[0]) != 1)]) = 1;
          DWORD2(v331[5 * v67]) = 2;
          goto LABEL_309;
        }
LABEL_169:
        if (BYTE8(v350) != 101 || BYTE9(v350)) {
          goto LABEL_311;
        }
        sub_1012564B8((uint64_t)&v329, (uint64_t)v345, (uint64_t)&v340);
        goto LABEL_309;
      }
      if (!BYTE9(v350))
      {
        if (HIDWORD(v352[1]))
        {
          if (vabdd_f64(*(double *)&v347, *(double *)&v349[3]) >= 50.0)
          {
            BOOL v135 = *(double *)&v347 < *(double *)&v349[3];
          }
          else
          {
            if (*((double *)&v346 + 1) == 0.0) {
              __assert_rtn("apply", "segment_ratio.hpp", 56, "lhs.denominator() != Type(0)");
            }
            if (*(double *)&v349[2] == 0.0) {
              __assert_rtn("apply", "segment_ratio.hpp", 57, "rhs.denominator() != Type(0)");
            }
            double v133 = *(double *)&v346 / *((double *)&v346 + 1);
            double v134 = *(double *)&v349[1] / *(double *)&v349[2];
            if (*(double *)&v346 / *((double *)&v346 + 1) == *(double *)&v349[1] / *(double *)&v349[2])
            {
              BOOL v135 = 0;
            }
            else if (COERCE_UNSIGNED_INT64(fabs(*(double *)&v346 / *((double *)&v346 + 1))) > 0x7FEFFFFFFFFFFFFFLL {
                   || COERCE_UNSIGNED_INT64(fabs(*(double *)&v349[1] / *(double *)&v349[2])) > 0x7FEFFFFFFFFFFFFFLL)
            }
            {
              BOOL v135 = 1;
            }
            else
            {
              double v196 = vabdd_f64(v133, v134);
              double v197 = fabs(v133);
              double v198 = fabs(v134);
              if (v197 < v198) {
                double v197 = v198;
              }
              if (v197 >= v45) {
                double v199 = v197 * 2.22044605e-16;
              }
              else {
                double v199 = 2.22044605e-16;
              }
              BOOL v135 = v196 > v199;
            }
            if (v133 >= v134) {
              BOOL v135 = 0;
            }
          }
          int v283 = HIDWORD(v352[1]);
          LODWORD(v330) = 5;
          if (v345[0] <= (unint64_t)v135) {
LABEL_463:
          }
            __assert_rtn("assign_point", "get_turn_info.hpp", 164, "index < info.count");
          long long v329 = *(_OWORD *)&v345[2 * v135 + 1];
          uint64_t v201 = &v345[7 * v135];
          *(void *)&v332[24] = v201[7];
          *(_OWORD *)&v332[8] = *(_OWORD *)(v201 + 5);
          *(_OWORD *)&v336[8] = *((_OWORD *)v201 + 4);
          *(void *)&v336[24] = v201[10];
          uint64_t v202 = (uint64_t)v341;
          uint64_t v203 = (double *)v341[2];
          BOOL v204 = (double *)v341[3];
          if (!*((unsigned char *)v341 + 80))
          {
            sub_101246990((uint64_t)v341, (uint64_t)(v341 + 4), *v204, v204[1]);
            *(_OWORD *)(v202 + 64) = *(_OWORD *)*(void *)(v202 + 32);
            *(unsigned char *)(v202 + 80) = 1;
          }
          int v205 = sub_1012472B0(v203, v204, (double *)(v202 + 64));
          uint64_t v206 = v342;
          char v207 = *(double **)(v342 + 16);
          char v208 = *(double **)(v342 + 24);
          if (!*(unsigned char *)(v342 + 80))
          {
            sub_101246990(v342, v342 + 32, *v208, v208[1]);
            *(_OWORD *)(v206 + 64) = *(_OWORD *)*(void *)(v206 + 32);
            *(unsigned char *)(v206 + 80) = 1;
          }
          int v209 = sub_1012472B0(v207, v208, (double *)(v206 + 64));
          int v210 = v209;
          if (v283 == 1) {
            int v211 = v205;
          }
          else {
            int v211 = v209;
          }
          if (v211 * v283 == 1) {
            int v212 = 1;
          }
          else {
            int v212 = 2;
          }
          if (v211 * v283 == 1) {
            int v213 = 2;
          }
          else {
            int v213 = 1;
          }
          BOOL v214 = v211 == 0;
          if (v211) {
            int v215 = v212;
          }
          else {
            int v215 = 4;
          }
          if (v214) {
            int v216 = 4;
          }
          else {
            int v216 = v213;
          }
          DWORD2(v331[0]) = v215;
          DWORD2(v333) = v216;
          if (v205)
          {
            double v218 = *((double *)&v329 + 1);
            double v217 = *(double *)&v329;
            double v219 = (*((double *)&v329 + 1) - v324[1]) * (*((double *)&v329 + 1) - v324[1])
                 + (*(double *)&v329 - *v324) * (*(double *)&v329 - *v324);
            uint64_t v3 = v284;
            uint64_t v4 = v288;
          }
          else
          {
            uint64_t v3 = v284;
            uint64_t v4 = v288;
            if (!LOBYTE(v328[3]))
            {
              unint64_t v220 = 0;
              char v221 = v325;
              uint64_t v222 = *(void *)v324;
              double v223 = v324[1];
              double v224 = fabs(v223);
              while (1)
              {
                uint64_t v226 = *(void *)v221;
                double v225 = v221[1];
                *(void *)&long long v353 = v222;
                v364[0] = v223;
                sub_10123D770((double *)&v353, v364, 1);
                double v227 = *(double *)&v353;
                *(void *)&long long v353 = v226;
                v364[0] = v225;
                sub_10123D770((double *)&v353, v364, 1);
                if (v227 != *(double *)&v353)
                {
                  if ((*(void *)&v227 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                    || ((unint64_t)v353 & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL)
                  {
                    break;
                  }
                  double v229 = vabdd_f64(v227, *(double *)&v353);
                  double v230 = fabs(v227);
                  double v231 = fabs(*(double *)&v353);
                  if (v230 >= v231) {
                    double v231 = v230;
                  }
                  double v232 = v231 >= v45 ? v231 * 2.22044605e-16 : 2.22044605e-16;
                  if (v229 > v232) {
                    break;
                  }
                }
                if (v225 != v223)
                {
                  if ((*(void *)&v223 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
                    || (*(void *)&v225 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                  {
                    break;
                  }
                  double v233 = vabdd_f64(v223, v225);
                  double v234 = fabs(v225);
                  if (v224 >= v234) {
                    double v234 = v224;
                  }
                  double v235 = v234 >= v45 ? v234 * 2.22044605e-16 : 2.22044605e-16;
                  if (v233 > v235) {
                    break;
                  }
                }
                if (v220 >= *(void *)(v322[0] + 88)) {
                  break;
                }
                BOOL v236 = v325;
                char v221 = v325 + 2;
                unsigned int v325 = v221;
                if (v221 == v327)
                {
                  unsigned int v325 = v326;
                  if (LOBYTE(v328[0]))
                  {
                    char v221 = v326 + 2;
                    unsigned int v325 = v326 + 2;
                    if (v236 == v326)
                    {
                      unsigned int v325 = v326;
                      char v221 = v236;
                    }
                  }
                  else
                  {
                    char v221 = v326;
                  }
                }
                ++v220;
              }
              *(_OWORD *)&v328[1] = *(_OWORD *)v325;
              LOBYTE(v328[3]) = 1;
              uint64_t v4 = v288;
            }
            double v218 = *((double *)&v329 + 1);
            double v217 = *(double *)&v329;
            double v219 = (*((double *)&v329 + 1) - *(double *)&v328[2]) * (*((double *)&v329 + 1) - *(double *)&v328[2])
                 + (*(double *)&v329 - *(double *)&v328[1]) * (*(double *)&v329 - *(double *)&v328[1]);
          }
          uint64_t v58 = v287;
          *(double *)&long long v333 = v219;
          if (v210)
          {
            double v237 = *v317;
            double v238 = v317[1];
          }
          else
          {
            if (!LOBYTE(v321[3]))
            {
              unint64_t v239 = 0;
              int v240 = v318;
              double v241 = *v317;
              double v242 = v317[1];
              double v243 = fabs(v242);
              while (1)
              {
                uint64_t v244 = *(void *)v240;
                double v245 = v240[1];
                *(double *)&long long v353 = v241;
                v364[0] = v242;
                sub_10123D770((double *)&v353, v364, 1);
                double v246 = *(double *)&v353;
                *(void *)&long long v353 = v244;
                v364[0] = v245;
                sub_10123D770((double *)&v353, v364, 1);
                if (v246 != *(double *)&v353)
                {
                  if ((*(void *)&v246 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                    || ((unint64_t)v353 & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL)
                  {
                    break;
                  }
                  double v248 = vabdd_f64(v246, *(double *)&v353);
                  double v249 = fabs(v246);
                  double v250 = fabs(*(double *)&v353);
                  if (v249 >= v250) {
                    double v250 = v249;
                  }
                  double v251 = v250 >= 1.0 ? v250 * 2.22044605e-16 : 2.22044605e-16;
                  if (v248 > v251) {
                    break;
                  }
                }
                if (v245 != v242)
                {
                  if ((*(void *)&v242 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
                    || (*(void *)&v245 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                  {
                    break;
                  }
                  double v252 = vabdd_f64(v242, v245);
                  double v253 = fabs(v245);
                  if (v243 >= v253) {
                    double v253 = v243;
                  }
                  double v254 = v253 >= 1.0 ? v253 * 2.22044605e-16 : 2.22044605e-16;
                  if (v252 > v254) {
                    break;
                  }
                }
                if (v239 >= *(void *)(v316[0] + 88)) {
                  break;
                }
                uint64_t v255 = v318;
                int v240 = v318 + 2;
                long long v318 = v240;
                if (v240 == v320)
                {
                  long long v318 = v319;
                  if (LOBYTE(v321[0]))
                  {
                    int v240 = v319 + 2;
                    long long v318 = v319 + 2;
                    if (v255 == v319)
                    {
                      long long v318 = v319;
                      int v240 = v255;
                    }
                  }
                  else
                  {
                    int v240 = v319;
                  }
                }
                ++v239;
              }
              *(_OWORD *)&v321[1] = *(_OWORD *)v318;
              LOBYTE(v321[3]) = 1;
              uint64_t v58 = v287;
              double v45 = 1.0;
            }
            double v237 = *(double *)&v321[1];
            double v238 = *(double *)&v321[2];
          }
          double v337 = (v218 - v238) * (v218 - v238) + (v217 - v237) * (v217 - v237);
        }
        else
        {
          sub_1012564B8((uint64_t)&v329, (uint64_t)v345, (uint64_t)&v340);
          LODWORD(v330) = 5;
        }
        goto LABEL_309;
      }
      *(_OWORD *)double v362 = v313;
      *(_OWORD *)&v362[16] = v314;
      double v363 = v315;
      *(_OWORD *)&v358[16] = v309;
      long long v359 = v310;
      long long v361 = v312;
      long long v360 = v311;
      long long v355 = v305;
      long long v356 = v306;
      *(_OWORD *)double v358 = v308;
      long long v357 = v307;
      long long v354 = v304;
      long long v353 = v303;
      int v99 = v352[2];
      if (HIDWORD(v352[1]) != 1)
      {
LABEL_268:
        _ZF = v99 == 1;
        uint64_t v3 = v284;
        if (!_ZF) {
          goto LABEL_311;
        }
        uint64_t v170 = v342;
        uint64_t v171 = *(double **)(v342 + 16);
        uint64_t v172 = *(double **)(v342 + 24);
        if (!*(unsigned char *)(v342 + 80))
        {
          sub_101246990(v342, v342 + 32, *v172, v172[1]);
          *(_OWORD *)(v170 + 64) = *(_OWORD *)*(void *)(v170 + 32);
          *(unsigned char *)(v170 + 80) = 1;
        }
        int v173 = sub_1012472B0(v171, v172, (double *)(v170 + 64));
        if (v173 == 1)
        {
          int v174 = 2;
          uint64_t v58 = v287;
          uint64_t v4 = v288;
        }
        else
        {
          uint64_t v58 = v287;
          uint64_t v4 = v288;
          if (!v173)
          {
LABEL_311:
            unint64_t v66 = v291;
            goto LABEL_312;
          }
          if (v173 != -1) {
            goto LABEL_278;
          }
          int v174 = 1;
        }
        DWORD2(v359) = v174;
LABEL_278:
        DWORD2(v355) = 3;
        LODWORD(v354) = 5;
        if (!v345[0]) {
          goto LABEL_463;
        }
        long long v353 = *(_OWORD *)&v345[1];
        *(_OWORD *)&v358[8] = *(_OWORD *)&v345[5];
        *(void *)&v358[24] = v345[7];
        *(_OWORD *)&v362[8] = v346;
        *(void *)&v362[24] = v347;
        long long v175 = &v353;
        goto LABEL_310;
      }
      uint64_t v100 = (uint64_t)v341;
      uint64_t v101 = (double *)v341[2];
      uint64_t v102 = (double *)v341[3];
      if (!*((unsigned char *)v341 + 80))
      {
        sub_101246990((uint64_t)v341, (uint64_t)(v341 + 4), *v102, v102[1]);
        *(_OWORD *)(v100 + 64) = *(_OWORD *)*(void *)(v100 + 32);
        *(unsigned char *)(v100 + 80) = 1;
      }
      int v103 = sub_1012472B0(v101, v102, (double *)(v100 + 64));
      if (v103 == 1)
      {
        int v104 = 2;
        uint64_t v58 = v287;
        uint64_t v4 = v288;
      }
      else
      {
        uint64_t v58 = v287;
        uint64_t v4 = v288;
        if (!v103) {
          goto LABEL_268;
        }
        if (v103 != -1) {
          goto LABEL_266;
        }
        int v104 = 1;
      }
      DWORD2(v355) = v104;
LABEL_266:
      DWORD2(v359) = 3;
      LODWORD(v354) = 5;
      if (v345[0] <= 1uLL) {
        goto LABEL_463;
      }
      long long v353 = *(_OWORD *)&v345[3];
      *(_OWORD *)&v358[8] = v348;
      *(void *)&v358[24] = v349[0];
      *(_OWORD *)&v362[8] = *(_OWORD *)&v349[1];
      *(void *)&v362[24] = v349[3];
      sub_1012567B0(v58, (uint64_t)&v353);
      goto LABEL_268;
    }
    __asm { FMOV            V0.2D, #1.0 }
    if (BYTE8(v350) != 116)
    {
      if (BYTE8(v350) != 109) {
        goto LABEL_169;
      }
      LODWORD(v330) = 4;
      long long v329 = *(_OWORD *)&v345[1];
      uint64_t v72 = 0;
      char v73 = 1;
      if (LODWORD(v352[2]) == 1)
      {
        do
        {
          char v74 = v73;
          int v75 = *((_DWORD *)&v352[1] + v72 + 1);
          if (v75 == -1)
          {
            uint64_t v77 = (char *)&v331[5 * v72] + 8;
            *((_OWORD *)v77 + 3) = xmmword_1015E0D30;
            *((void *)v77 + 8) = 0;
          }
          else if (v75 == 1)
          {
            unint64_t v76 = (char *)&v331[5 * v72] + 8;
            *((_OWORD *)v76 + 3) = _Q0;
            *((void *)v76 + 8) = 0x412E848000000000;
          }
          else
          {
            if (v74) {
              uint64_t v78 = (long long *)&v345[5];
            }
            else {
              uint64_t v78 = &v346;
            }
            uint64_t v79 = (char *)&v331[5 * v72] + 8;
            *((_OWORD *)v79 + 3) = *v78;
            *((void *)v79 + 8) = *((void *)v78 + 2);
          }
          char v73 = 0;
          uint64_t v72 = 1;
        }
        while ((v74 & 1) != 0);
        int v80 = HIDWORD(v352[0]);
        uint64_t v81 = v342;
        char v82 = (double *)v341[2];
        uint64_t v83 = (double *)v341[3];
        uint64_t v280 = (uint64_t)v341;
        if (!*(unsigned char *)(v342 + 80))
        {
          sub_101246990(v342, v342 + 32, **(double **)(v342 + 24), *(double *)(*(void *)(v342 + 24) + 8));
          *(_OWORD *)(v81 + 64) = *(_OWORD *)*(void *)(v81 + 32);
          *(unsigned char *)(v81 + 80) = 1;
        }
        int v84 = sub_1012472B0(v82, v83, (double *)(v81 + 64));
        int v85 = v84;
        if (!(v80 + v84))
        {
          BOOL v86 = v84 == -1;
          BOOL v87 = v84 != -1;
LABEL_110:
          DWORD2(v331[5 * v87]) = 1;
          DWORD2(v331[5 * v86]) = 2;
LABEL_308:
          uint64_t v3 = v284;
          uint64_t v58 = v287;
          uint64_t v4 = v288;
          goto LABEL_309;
        }
        int v268 = v80;
        char v141 = *(double **)(v81 + 16);
        uint64_t v142 = *(double **)(v81 + 24);
        if (!*(unsigned char *)(v81 + 80))
        {
          uint64_t v273 = *(double **)(v81 + 16);
          sub_101246990(v81, v81 + 32, *v142, v142[1]);
          char v141 = v273;
          *(_OWORD *)(v81 + 64) = *(_OWORD *)*(void *)(v81 + 32);
          *(unsigned char *)(v81 + 80) = 1;
        }
        int v274 = (double *)(v81 + 64);
        int v143 = sub_1012472B0(v141, v142, (double *)(v81 + 64));
        uint64_t v144 = *(double **)(v81 + 24);
        if (!*(unsigned char *)(v81 + 80))
        {
          sub_101246990(v81, v81 + 32, *v144, v144[1]);
          *(_OWORD *)int v274 = *(_OWORD *)*(void *)(v81 + 32);
          *(unsigned char *)(v81 + 80) = 1;
        }
        int v145 = sub_1012472B0(v144, v274, *(double **)(v280 + 24));
        int v146 = v268;
        if ((v85 & v268) != 0xFFFFFFFF || v143 != 1)
        {
          int v148 = v145;
          int v149 = v143;
          if (v268 == 1 && v85 == 1 && v143 == -1)
          {
            if (v145 == -1) {
              int v150 = 1;
            }
            else {
              int v150 = 3;
            }
            DWORD2(v331[0]) = 1;
            DWORD2(v333) = v150;
LABEL_307:
            BYTE4(v330) = 1;
            goto LABEL_308;
          }
          if (v268 == v85 && v268 == v143)
          {
            BOOL v179 = v143 == 1;
            BOOL v180 = v145 == 0;
LABEL_300:
            unsigned int v181 = v179 ^ v180;
            if (v148 * v146 == -1)
            {
              int v277 = sub_1012472B0(*(double **)(v280 + 16), *(double **)(v280 + 24), *(double **)(v81 + 24));
              uint64_t v182 = v280;
              uint64_t v183 = *(double **)(v280 + 24);
              if (!*(unsigned char *)(v280 + 80))
              {
                sub_101246990(v280, v280 + 32, *v183, v183[1]);
                uint64_t v182 = v280;
                *(_OWORD *)(v280 + 64) = *(_OWORD *)*(void *)(v280 + 32);
                *(unsigned char *)(v280 + 80) = 1;
              }
              if (sub_1012472B0(v183, (double *)(v182 + 64), *(double **)(v81 + 24)) * v277 == 1
                && sub_1012472B0(*(double **)(v81 + 16), *(double **)(v81 + 24), *(double **)(v280 + 24))
                 * v148 == -1)
              {
                v181 ^= 1u;
              }
            }
            DWORD2(v331[5 * v181]) = 1;
            DWORD2(v331[5 * (v181 ^ 1)]) = 2;
            goto LABEL_307;
          }
          uint64_t v58 = v287;
          if (!v85)
          {
            uint64_t v3 = v284;
            if (v268 != v149)
            {
              if (v149 == 1) {
                int v256 = 2;
              }
              else {
                int v256 = 1;
              }
              DWORD2(v331[0]) = v256;
              int v257 = 3;
              goto LABEL_446;
            }
LABEL_445:
            int v257 = 4;
            DWORD2(v331[0]) = 4;
LABEL_446:
            DWORD2(v333) = v257;
            goto LABEL_451;
          }
          goto LABEL_443;
        }
      }
      else
      {
        do
        {
          char v88 = v73;
          int v89 = *((_DWORD *)&v352[1] + v72 + 1);
          if (v89 == -1)
          {
            uint64_t v91 = (char *)&v331[5 * v72] + 8;
            *((_OWORD *)v91 + 3) = xmmword_1015E0D30;
            *((void *)v91 + 8) = 0;
          }
          else if (v89 == 1)
          {
            uint64_t v90 = (char *)&v331[5 * v72] + 8;
            *((_OWORD *)v90 + 3) = _Q0;
            *((void *)v90 + 8) = 0x412E848000000000;
          }
          else
          {
            if (v88) {
              char v92 = (long long *)&v345[5];
            }
            else {
              char v92 = &v346;
            }
            char v93 = (char *)&v331[5 * v72] + 8;
            *((_OWORD *)v93 + 3) = *v92;
            *((void *)v93 + 8) = *((void *)v92 + 2);
          }
          char v73 = 0;
          uint64_t v72 = 1;
        }
        while ((v88 & 1) != 0);
        int v94 = HIDWORD(v351);
        uint64_t v81 = (uint64_t)v344;
        uint64_t v95 = (double *)v343[2];
        int v96 = (double *)v343[3];
        uint64_t v280 = (uint64_t)v343;
        if (!*((unsigned char *)v344 + 80))
        {
          sub_101246990((uint64_t)v344, (uint64_t)(v344 + 4), *(double *)v344[3], *(double *)(v344[3] + 8));
          *(_OWORD *)(v81 + 64) = *(_OWORD *)*(void *)(v81 + 32);
          *(unsigned char *)(v81 + 80) = 1;
        }
        int v97 = sub_1012472B0(v95, v96, (double *)(v81 + 64));
        int v98 = v97;
        if (!(v94 + v97))
        {
          BOOL v86 = v97 != -1;
          BOOL v87 = v97 == -1;
          goto LABEL_110;
        }
        int v269 = v94;
        uint64_t v151 = *(double **)(v81 + 16);
        unsigned int v152 = *(double **)(v81 + 24);
        if (!*(unsigned char *)(v81 + 80))
        {
          uint64_t v275 = *(double **)(v81 + 16);
          sub_101246990(v81, v81 + 32, *v152, v152[1]);
          uint64_t v151 = v275;
          *(_OWORD *)(v81 + 64) = *(_OWORD *)*(void *)(v81 + 32);
          *(unsigned char *)(v81 + 80) = 1;
        }
        unint64_t v276 = (double *)(v81 + 64);
        int v153 = sub_1012472B0(v151, v152, (double *)(v81 + 64));
        uint64_t v154 = *(double **)(v81 + 24);
        if (!*(unsigned char *)(v81 + 80))
        {
          sub_101246990(v81, v81 + 32, *v154, v154[1]);
          *(_OWORD *)unint64_t v276 = *(_OWORD *)*(void *)(v81 + 32);
          *(unsigned char *)(v81 + 80) = 1;
        }
        int v155 = sub_1012472B0(v154, v276, *(double **)(v280 + 24));
        int v146 = v269;
        if ((v98 & v269) != 0xFFFFFFFF || v153 != 1)
        {
          int v148 = v155;
          int v157 = v153;
          if (v269 != 1 || v98 != 1 || v153 != -1)
          {
            if (v269 == v98 && v269 == v153)
            {
              BOOL v179 = v153 == 1;
              BOOL v180 = v155 != 0;
              goto LABEL_300;
            }
            uint64_t v58 = v287;
            if (!v98)
            {
              uint64_t v3 = v284;
              if (v269 != v157)
              {
                if (v157 == 1) {
                  int v258 = 2;
                }
                else {
                  int v258 = 1;
                }
                DWORD2(v333) = v258;
                DWORD2(v331[0]) = 3;
                goto LABEL_451;
              }
              goto LABEL_445;
            }
LABEL_443:
            LODWORD(v330) = 8;
            uint64_t v3 = v284;
LABEL_451:
            uint64_t v4 = v288;
            goto LABEL_309;
          }
          if (v155 == -1) {
            int v158 = 1;
          }
          else {
            int v158 = 3;
          }
          DWORD2(v331[0]) = v158;
          DWORD2(v333) = 1;
LABEL_218:
          BYTE4(v330) = 1;
          goto LABEL_308;
        }
      }
      DWORD2(v331[0]) = 2;
      DWORD2(v333) = 2;
      goto LABEL_218;
    }
    uint64_t v105 = 0;
    LODWORD(v330) = 3;
    long long v329 = *(_OWORD *)&v345[1];
    char v106 = 1;
    do
    {
      char v107 = v106;
      int v108 = *((_DWORD *)&v352[1] + v105 + 1);
      if (v108 == -1)
      {
        unint64_t v110 = (char *)&v331[5 * v105] + 8;
        *((_OWORD *)v110 + 3) = xmmword_1015E0D30;
        *((void *)v110 + 8) = 0;
      }
      else if (v108 == 1)
      {
        uint64_t v109 = (char *)&v331[5 * v105] + 8;
        *((_OWORD *)v109 + 3) = _Q0;
        *((void *)v109 + 8) = 0x412E848000000000;
      }
      else
      {
        if (v107) {
          uint64_t v111 = (long long *)&v345[5];
        }
        else {
          uint64_t v111 = &v346;
        }
        long long v112 = (char *)&v331[5 * v105] + 8;
        *((_OWORD *)v112 + 3) = *v111;
        *((void *)v112 + 8) = *((void *)v111 + 2);
      }
      char v106 = 0;
      uint64_t v105 = 1;
    }
    while ((v107 & 1) != 0);
    uint64_t v113 = v342;
    uint64_t v114 = (uint64_t)v341;
    int64_t v116 = *(double **)(v342 + 16);
    unint64_t v115 = *(double **)(v342 + 24);
    if (!*((unsigned char *)v341 + 80))
    {
      sub_101246990((uint64_t)v341, (uint64_t)(v341 + 4), *(double *)v341[3], *(double *)(v341[3] + 8));
      *(_OWORD *)(v114 + 64) = *(_OWORD *)*(void *)(v114 + 32);
      *(unsigned char *)(v114 + 80) = 1;
    }
    long long v272 = (double *)(v114 + 64);
    int v266 = sub_1012472B0(v116, v115, (double *)(v114 + 64));
    int v117 = HIDWORD(v352[0]);
    uint64_t v118 = *(double **)(v114 + 16);
    long long v119 = *(double **)(v114 + 24);
    if (!*(unsigned char *)(v113 + 80))
    {
      long long v281 = *(double **)(v114 + 16);
      sub_101246990(v113, v113 + 32, **(double **)(v113 + 24), *(double *)(*(void *)(v113 + 24) + 8));
      uint64_t v118 = v281;
      *(_OWORD *)(v113 + 64) = *(_OWORD *)*(void *)(v113 + 32);
      *(unsigned char *)(v113 + 80) = 1;
    }
    long long v282 = (double *)(v113 + 64);
    LODWORD(v267) = v117;
    HIDWORD(v267) = sub_1012472B0(v118, v119, (double *)(v113 + 64));
    if (HIDWORD(v267) * v117 != -1)
    {
      long long v120 = *(double **)(v113 + 24);
      if (!*(unsigned char *)(v113 + 80))
      {
        sub_101246990(v113, v113 + 32, *v120, v120[1]);
        *(_OWORD *)long long v282 = *(_OWORD *)*(void *)(v113 + 32);
        *(unsigned char *)(v113 + 80) = 1;
      }
      if (!*(unsigned char *)(v114 + 80))
      {
        sub_101246990(v114, v114 + 32, **(double **)(v114 + 24), *(double *)(*(void *)(v114 + 24) + 8));
        *(_OWORD *)long long v272 = *(_OWORD *)*(void *)(v114 + 32);
        *(unsigned char *)(v114 + 80) = 1;
      }
      int v265 = sub_1012472B0(v120, v282, v272);
      long long v121 = *(double **)(v114 + 16);
      BOOL v122 = *(double **)(v114 + 24);
      if (!*(unsigned char *)(v114 + 80))
      {
        double v263 = *(double **)(v114 + 16);
        sub_101246990(v114, v114 + 32, *v122, v122[1]);
        long long v121 = v263;
        *(_OWORD *)long long v272 = *(_OWORD *)*(void *)(v114 + 32);
        *(unsigned char *)(v114 + 80) = 1;
      }
      int v123 = sub_1012472B0(v121, v122, v272);
      uint64_t v124 = *(double **)(v113 + 16);
      uint64_t v125 = *(double **)(v113 + 24);
      if (!*(unsigned char *)(v113 + 80))
      {
        sub_101246990(v113, v113 + 32, *v125, v125[1]);
        *(_OWORD *)long long v282 = *(_OWORD *)*(void *)(v113 + 32);
        *(unsigned char *)(v113 + 80) = 1;
      }
      int v126 = sub_1012472B0(v124, v125, v282);
      if (HIDWORD(v267)) {
        BOOL v127 = 1;
      }
      else {
        BOOL v127 = v126 * v267 == 1;
      }
      int v128 = !v127;
      if (v123 != v267 && v123 != HIDWORD(v267) && (v267 || v123 == -1))
      {
        if (v126 == 1) {
          int v166 = 2;
        }
        else {
          int v166 = 1;
        }
        if (HIDWORD(v267) == 1 || v267 == 1) {
          int v168 = 1;
        }
        else {
          int v168 = 2;
        }
        if (v128) {
          int v168 = 3;
        }
        DWORD2(v331[0]) = v166;
        DWORD2(v333) = v168;
        uint64_t v3 = v284;
        uint64_t v58 = v287;
        uint64_t v4 = v288;
        if ((v128 & 1) == 0) {
          BYTE4(v330) = 1;
        }
        goto LABEL_309;
      }
      if (v265) {
        char v129 = 1;
      }
      else {
        char v129 = v128;
      }
      uint64_t v3 = v284;
      uint64_t v58 = v287;
      uint64_t v4 = v288;
      if (v129)
      {
        if (!v266)
        {
          if (v126 == 1) {
            int v169 = 2;
          }
          else {
            int v169 = 1;
          }
          if (v128) {
            int v132 = 3;
          }
          else {
            int v132 = v169;
          }
          DWORD2(v331[0]) = 3;
          goto LABEL_263;
        }
        if (v266 == v265 && v126 * v266 != -1)
        {
          if (v126 == 1) {
            int v130 = 1;
          }
          else {
            int v130 = 2;
          }
          if (v126 == 1) {
            int v131 = 2;
          }
          else {
            int v131 = 1;
          }
          if (v128) {
            int v132 = 3;
          }
          else {
            int v132 = v131;
          }
          DWORD2(v331[0]) = v130;
          goto LABEL_263;
        }
        if (!(v265 + v126))
        {
          if (v126 == 1) {
            int v176 = 2;
          }
          else {
            int v176 = 1;
          }
          if (v126 == 1) {
            int v177 = 1;
          }
          else {
            int v177 = 2;
          }
          DWORD2(v331[0]) = v176;
          DWORD2(v333) = v177;
LABEL_288:
          BYTE4(v330) = 1;
          goto LABEL_309;
        }
        if (v266 != -v126) {
          goto LABEL_309;
        }
        if (v126 == 1) {
          int v200 = 2;
        }
        else {
          int v200 = 1;
        }
        DWORD2(v331[0]) = v200;
        DWORD2(v333) = v200;
        if (!v128) {
          goto LABEL_288;
        }
        int v132 = 3;
      }
      else
      {
        int v132 = 4;
        DWORD2(v331[0]) = 4;
      }
LABEL_263:
      DWORD2(v333) = v132;
LABEL_309:
      long long v175 = &v329;
LABEL_310:
      sub_1012567B0(v58, (uint64_t)v175);
      goto LABEL_311;
    }
    uint64_t v136 = *(double **)(v114 + 16);
    uint64_t v137 = *(double **)(v114 + 24);
    if (!*(unsigned char *)(v114 + 80))
    {
      sub_101246990(v114, v114 + 32, *v137, v137[1]);
      *(_OWORD *)long long v272 = *(_OWORD *)*(void *)(v114 + 32);
      *(unsigned char *)(v114 + 80) = 1;
    }
    int v138 = sub_1012472B0(v136, v137, v272);
    uint64_t v58 = v287;
    uint64_t v4 = v288;
    int v139 = HIDWORD(v267);
    if (v138 == v267)
    {
      if (!v266)
      {
        if (HIDWORD(v267) == 1) {
          int v178 = 1;
        }
        else {
          int v178 = 2;
        }
        DWORD2(v331[0]) = 3;
        DWORD2(v333) = v178;
        goto LABEL_293;
      }
      if (v266 == HIDWORD(v267))
      {
        if (HIDWORD(v267) == 1) {
          int v140 = 1;
        }
        else {
          int v140 = 2;
        }
        DWORD2(v331[0]) = v140;
        DWORD2(v333) = v140;
        BYTE4(v330) = 1;
LABEL_293:
        uint64_t v3 = v284;
        goto LABEL_309;
      }
    }
    if (v138 != HIDWORD(v267)) {
      goto LABEL_234;
    }
    uint64_t v159 = *(double **)(v113 + 24);
    if (!*(unsigned char *)(v113 + 80))
    {
      sub_101246990(v113, v113 + 32, *v159, v159[1]);
      *(_OWORD *)long long v282 = *(_OWORD *)*(void *)(v113 + 32);
      *(unsigned char *)(v113 + 80) = 1;
    }
    if (!*(unsigned char *)(v114 + 80))
    {
      sub_101246990(v114, v114 + 32, **(double **)(v114 + 24), *(double *)(*(void *)(v114 + 24) + 8));
      *(_OWORD *)long long v272 = *(_OWORD *)*(void *)(v114 + 32);
      *(unsigned char *)(v114 + 80) = 1;
    }
    int v160 = sub_1012472B0(v159, v282, v272);
    if (!v160)
    {
      DWORD2(v331[0]) = 4;
      DWORD2(v333) = 4;
      uint64_t v3 = v284;
      uint64_t v58 = v287;
      goto LABEL_309;
    }
    int v139 = HIDWORD(v267);
    uint64_t v58 = v287;
    if (v160 == HIDWORD(v267))
    {
      if (HIDWORD(v267) == 1) {
        int v161 = 1;
      }
      else {
        int v161 = 2;
      }
      if (HIDWORD(v267) == 1) {
        int v162 = 2;
      }
      else {
        int v162 = 1;
      }
      DWORD2(v331[0]) = v161;
      DWORD2(v333) = v162;
      BYTE4(v330) = 1;
    }
    else
    {
LABEL_234:
      BOOL v163 = v139 == 1;
      if (v139 == 1) {
        int v164 = 2;
      }
      else {
        int v164 = 1;
      }
      if (v163) {
        int v165 = 1;
      }
      else {
        int v165 = 2;
      }
      DWORD2(v331[0]) = v164;
      DWORD2(v333) = v165;
    }
    goto LABEL_293;
  }
  return 1;
}

uint64_t sub_101255254(double *a1, uint64_t **a2, unint64_t a3, uint64_t a4)
{
  double v6 = (a1[1] + a1[3]) * 0.5;
  uint64_t v50 = *((void *)a1 + 2);
  long long v7 = *(_OWORD *)a1;
  long long v8 = *((_OWORD *)a1 + 1);
  v47[0] = *a1;
  long long v48 = v8;
  long long v49 = v7;
  double v51 = v6;
  v47[1] = v6;
  long long v44 = 0;
  double v45 = 0;
  uint64_t v46 = 0;
  long long __p = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  double v38 = 0;
  double v39 = 0;
  uint64_t v40 = 0;
  sub_101240254((double *)&v49, v47, a2, &v44, &__p, (void **)&v38);
  double v9 = v38;
  double v10 = v39;
  if (v38 != v39)
  {
    int64x2_t v52 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    int64x2_t v53 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    double v11 = v38;
    do
      sub_101240044((double *)v52.i64, (double *)(*v11++ + 32));
    while (v11 != v10);
    v37[0] = v52;
    v37[1] = v53;
    unint64_t v12 = (char *)v10 - (char *)v9;
    double v13 = v9;
    if (a3 > 0x63 || (double v13 = v9, v12 <= 0x78))
    {
LABEL_16:
      uint64_t v15 = v13 + 1;
      if (v13 + 1 != v10)
      {
        double v14 = v13 + 1;
        while ((sub_1012534CC(a4, *v13, *v14) & 1) != 0)
        {
          if (++v14 == v10)
          {
            ++v13;
            if (v15 == v10) {
              goto LABEL_7;
            }
            goto LABEL_16;
          }
        }
        goto LABEL_41;
      }
    }
    else if (!sub_1012530BC(v37, &v38, a3 + 1, a4))
    {
      goto LABEL_41;
    }
LABEL_7:
    if (v12 < 0x80 || a3 > 0x63 || (unint64_t)((char *)v45 - (unsigned char *)v44) < 0x79)
    {
      uint64_t v16 = (uint64_t *)v44;
      unint64_t v17 = v45;
      if (v44 != v45)
      {
        int v18 = v45;
        uint64_t v19 = v9;
        while (1)
        {
          BOOL v20 = v16;
          BOOL v21 = v16 == v18;
          int v18 = v16;
          if (!v21) {
            break;
          }
LABEL_24:
          if (++v19 == v10) {
            goto LABEL_25;
          }
        }
        while ((sub_1012534CC(a4, *v19, *v20) & 1) != 0)
        {
          if (++v20 == v17)
          {
            int v18 = v17;
            goto LABEL_24;
          }
        }
        goto LABEL_41;
      }
    }
    else if (!sub_10125566C((double *)v37, &v38, (uint64_t **)&v44, a3 + 1, a4))
    {
      goto LABEL_41;
    }
LABEL_25:
    if (v12 >= 0x80 && a3 <= 0x63 && (unint64_t)((char *)v42 - (unsigned char *)__p) >= 0x79)
    {
      if (sub_10125566C((double *)v37, &v38, (uint64_t **)&__p, a3 + 1, a4)) {
        goto LABEL_38;
      }
LABEL_41:
      uint64_t v29 = 0;
      goto LABEL_42;
    }
    if (v9 != v10)
    {
      unint64_t v22 = (uint64_t *)__p;
      unint64_t v23 = v42;
      if (__p != v42)
      {
        int v24 = v42;
        int v25 = v9;
        while (1)
        {
          uint64_t v26 = v22;
          BOOL v21 = v22 == v24;
          int v24 = v22;
          if (!v21) {
            break;
          }
LABEL_33:
          if (++v25 == v10) {
            goto LABEL_38;
          }
        }
        while ((sub_1012534CC(a4, *v25, *v26) & 1) != 0)
        {
          if (++v26 == v23)
          {
            int v24 = v23;
            goto LABEL_33;
          }
        }
        goto LABEL_41;
      }
    }
  }
LABEL_38:
  uint64_t v28 = (uint64_t *)v44;
  uint64_t v27 = v45;
  if (a3 > 0x63 || (unint64_t)((char *)v45 - (unsigned char *)v44) < 0x79)
  {
    if (v44 != v45)
    {
LABEL_50:
      uint64_t v31 = v28 + 1;
      double v32 = v28 + 1;
      if (v28 + 1 != v27)
      {
        while ((sub_1012534CC(a4, *v28, *v32) & 1) != 0)
        {
          if (++v32 == v27)
          {
            ++v28;
            if (v31 != v27) {
              goto LABEL_50;
            }
            goto LABEL_54;
          }
        }
        goto LABEL_41;
      }
    }
  }
  else if (!sub_1012530BC(&v49, &v44, a3 + 1, a4))
  {
    goto LABEL_41;
  }
LABEL_54:
  double v34 = (uint64_t *)__p;
  uint64_t v33 = v42;
  if (a3 > 0x63 || (unint64_t)((char *)v42 - (unsigned char *)__p) < 0x79)
  {
    if (__p != v42)
    {
LABEL_58:
      double v35 = v34 + 1;
      BOOL v36 = v34 + 1;
      if (v34 + 1 != v33)
      {
        while ((sub_1012534CC(a4, *v34, *v36) & 1) != 0)
        {
          if (++v36 == v33)
          {
            uint64_t v29 = 1;
            ++v34;
            if (v35 != v33) {
              goto LABEL_58;
            }
            goto LABEL_42;
          }
        }
        goto LABEL_41;
      }
    }
    uint64_t v29 = 1;
  }
  else
  {
    uint64_t v29 = sub_1012530BC(v47, &__p, a3 + 1, a4);
  }
LABEL_42:
  if (v9) {
    operator delete(v9);
  }
  if (__p) {
    operator delete(__p);
  }
  if (v44) {
    operator delete(v44);
  }
  return v29;
}

void sub_101255618(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20)
{
  if (v20) {
    operator delete(v20);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10125566C(double *a1, uint64_t **a2, uint64_t **a3, unint64_t a4, uint64_t a5)
{
  double v8 = (*a1 + a1[2]) * 0.5;
  long long v9 = *((_OWORD *)a1 + 1);
  long long v86 = *(_OWORD *)a1;
  uint64_t v88 = *((void *)&v9 + 1);
  v84[1] = *((double *)&v86 + 1);
  long long v85 = v9;
  double v87 = v8;
  v84[0] = v8;
  uint64_t v81 = 0;
  char v82 = 0;
  uint64_t v83 = 0;
  uint64_t v78 = 0;
  uint64_t v79 = 0;
  uint64_t v80 = 0;
  int v75 = 0;
  unint64_t v76 = 0;
  uint64_t v77 = 0;
  uint64_t v72 = 0;
  char v73 = 0;
  uint64_t v74 = 0;
  long long __p = 0;
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  unint64_t v66 = 0;
  BOOL v67 = 0;
  uint64_t v68 = 0;
  sub_101240254((double *)&v86, v84, a2, &v81, &v78, (void **)&v75);
  sub_101240254((double *)&v86, v84, a3, &v72, &__p, (void **)&v66);
  double v10 = v75;
  double v11 = v76;
  unint64_t v12 = v66;
  if (v75 == v76)
  {
    double v14 = v67;
    goto LABEL_12;
  }
  unint64_t v13 = (char *)v76 - (char *)v75;
  double v14 = v67;
  if ((unint64_t)((char *)v76 - (char *)v75) < 0x80
    || a4 > 0x63
    || (unint64_t)((char *)v67 - (char *)v66) < 0x79)
  {
    if (v66 != v67)
    {
      uint64_t v15 = v67;
      uint64_t v16 = v75;
      while (1)
      {
        unint64_t v17 = v12;
        BOOL v26 = v12 == v15;
        uint64_t v15 = v12;
        if (!v26) {
          break;
        }
LABEL_9:
        if (++v16 == v11) {
          goto LABEL_46;
        }
      }
      while ((sub_1012534CC(a5, *v16, *v17) & 1) != 0)
      {
        if (++v17 == v14)
        {
          uint64_t v15 = v14;
          goto LABEL_9;
        }
      }
      goto LABEL_95;
    }
  }
  else
  {
    int64x2_t v89 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    int64x2_t v90 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    double v32 = v75;
    do
      sub_101240044((double *)v89.i64, (double *)(*v10++ + 32));
    while (v10 != v11);
    uint64_t v34 = v89.i64[1];
    uint64_t v33 = v89.i64[0];
    uint64_t v36 = v90.i64[1];
    uint64_t v35 = v90.i64[0];
    if (v12 != v14)
    {
      uint64_t v37 = v12;
      do
        sub_101240044((double *)v89.i64, (double *)(*v37++ + 32));
      while (v37 != v14);
      uint64_t v34 = v89.i64[1];
      uint64_t v33 = v89.i64[0];
      uint64_t v36 = v90.i64[1];
      uint64_t v35 = v90.i64[0];
    }
    v64.i64[0] = v33;
    v64.i64[1] = v34;
    v65.i64[0] = v35;
    v65.i64[1] = v36;
    double v10 = v32;
    if ((sub_101255D8C((double *)v64.i64, &v75, &v66, a4 + 1, a5) & 1) == 0) {
      goto LABEL_95;
    }
  }
LABEL_46:
  double v39 = (uint64_t *)v72;
  double v38 = v73;
  if ((unint64_t)((char *)v73 - (unsigned char *)v72) < 0x80
    || (unint64_t)((char *)v70 - (unsigned char *)__p) < 0x80
    || a4 > 0x63
    || v13 < 0x79)
  {
    if (v72 == v73)
    {
LABEL_55:
      uint64_t v43 = (uint64_t *)__p;
      long long v44 = v70;
      if (__p == v70) {
        goto LABEL_12;
      }
      double v45 = v70;
      uint64_t v46 = v10;
      while (1)
      {
        double v47 = v43;
        BOOL v26 = v43 == v45;
        double v45 = v43;
        if (!v26) {
          break;
        }
LABEL_61:
        if (++v46 == v11) {
          goto LABEL_12;
        }
      }
      while ((sub_1012534CC(a5, *v46, *v47) & 1) != 0)
      {
        if (++v47 == v44)
        {
          double v45 = v44;
          goto LABEL_61;
        }
      }
    }
    else
    {
      uint64_t v40 = v73;
      double v41 = v10;
      while (1)
      {
        uint64_t v42 = v39;
        BOOL v26 = v39 == v40;
        uint64_t v40 = v39;
        if (!v26) {
          break;
        }
LABEL_54:
        if (++v41 == v11) {
          goto LABEL_55;
        }
      }
      while ((sub_1012534CC(a5, *v41, *v42) & 1) != 0)
      {
        if (++v42 == v38)
        {
          uint64_t v40 = v38;
          goto LABEL_54;
        }
      }
    }
LABEL_95:
    uint64_t v50 = 0;
    if (!v12) {
      goto LABEL_97;
    }
    goto LABEL_96;
  }
  unint64_t v55 = a4;
  int64x2_t v89 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  int64x2_t v90 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  char v56 = v10;
  do
    sub_101240044((double *)v89.i64, (double *)(*v10++ + 32));
  while (v10 != v11);
  int64x2_t v64 = v89;
  int64x2_t v65 = v90;
  double v10 = v56;
  if (!sub_101255D8C((double *)v64.i64, &v75, (uint64_t **)&v72, v55 + 1, a5)
    || (sub_101255D8C((double *)v64.i64, &v75, (uint64_t **)&__p, v55 + 1, a5) & 1) == 0)
  {
    goto LABEL_95;
  }
  a4 = v55;
LABEL_12:
  uint64_t v19 = (uint64_t *)v81;
  int v18 = v82;
  unint64_t v20 = (char *)v82 - (unsigned char *)v81;
  if (v12 == v14) {
    goto LABEL_27;
  }
  if (v20 >= 0x80
    && (unint64_t)((char *)v79 - (unsigned char *)v78) >= 0x80
    && a4 <= 0x63
    && (unint64_t)((char *)v14 - (char *)v12) >= 0x79)
  {
    char v57 = v10;
    int64x2_t v89 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    int64x2_t v90 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    uint64_t v58 = v12;
    do
      sub_101240044((double *)v89.i64, (double *)(*v58++ + 32));
    while (v58 != v14);
    int64x2_t v64 = v89;
    int64x2_t v65 = v90;
    double v10 = v57;
    if (!sub_101255D8C((double *)v64.i64, (uint64_t **)&v81, &v66, a4 + 1, a5)
      || (sub_101255D8C((double *)v64.i64, (uint64_t **)&v78, &v66, a4 + 1, a5) & 1) == 0)
    {
      goto LABEL_95;
    }
LABEL_27:
    uint64_t v27 = v10;
    if (v20 < 0x80 || a4 > 0x63 || (unint64_t)((char *)v73 - (unsigned char *)v72) < 0x79)
    {
      if (v19 != v18)
      {
        uint64_t v28 = (uint64_t *)v72;
        uint64_t v29 = v73;
        if (v72 != v73)
        {
          long long v30 = v73;
          while (1)
          {
            uint64_t v31 = v28;
            BOOL v26 = v28 == v30;
            long long v30 = v28;
            if (!v26) {
              break;
            }
LABEL_35:
            if (++v19 == v18) {
              goto LABEL_66;
            }
          }
          while ((sub_1012534CC(a5, *v19, *v31) & 1) != 0)
          {
            if (++v31 == v29)
            {
              long long v30 = v29;
              goto LABEL_35;
            }
          }
          goto LABEL_70;
        }
      }
    }
    else if ((sub_101255D8C((double *)&v86, (uint64_t **)&v81, (uint64_t **)&v72, a4 + 1, a5) & 1) == 0)
    {
LABEL_70:
      uint64_t v50 = 0;
      goto LABEL_80;
    }
LABEL_66:
    long long v49 = (uint64_t *)v78;
    long long v48 = v79;
    if ((unint64_t)((char *)v79 - (unsigned char *)v78) < 0x80
      || a4 > 0x63
      || (unint64_t)((char *)v70 - (unsigned char *)__p) < 0x79)
    {
      if (v78 != v79)
      {
        double v51 = (uint64_t *)__p;
        int64x2_t v52 = v70;
        if (__p != v70)
        {
          int64x2_t v53 = v70;
          while (1)
          {
            int v54 = v51;
            BOOL v26 = v51 == v53;
            int64x2_t v53 = v51;
            if (!v26) {
              break;
            }
LABEL_78:
            if (++v49 == v48) {
              goto LABEL_79;
            }
          }
          while ((sub_1012534CC(a5, *v49, *v54) & 1) != 0)
          {
            if (++v54 == v52)
            {
              int64x2_t v53 = v52;
              goto LABEL_78;
            }
          }
          goto LABEL_70;
        }
      }
    }
    else if ((sub_101255D8C(v84, (uint64_t **)&v78, (uint64_t **)&__p, a4 + 1, a5) & 1) == 0)
    {
      goto LABEL_70;
    }
LABEL_79:
    uint64_t v50 = 1;
LABEL_80:
    double v10 = v27;
    if (!v12) {
      goto LABEL_97;
    }
LABEL_96:
    operator delete(v12);
    goto LABEL_97;
  }
  if (v81 != v82)
  {
    BOOL v21 = v14;
    unint64_t v22 = (uint64_t *)v81;
    while (1)
    {
      unint64_t v23 = v12;
      BOOL v26 = v12 == v21;
      BOOL v21 = v12;
      if (!v26) {
        break;
      }
LABEL_21:
      if (++v22 == v18) {
        goto LABEL_22;
      }
    }
    while ((sub_1012534CC(a5, *v22, *v23) & 1) != 0)
    {
      if (++v23 == v14)
      {
        BOOL v21 = v14;
        goto LABEL_21;
      }
    }
    goto LABEL_95;
  }
LABEL_22:
  int v24 = (uint64_t *)v78;
  int v25 = v79;
  BOOL v26 = v78 == v79 || v12 == v14;
  if (v26) {
    goto LABEL_27;
  }
  uint64_t v60 = v14;
  unint64_t v63 = a4;
  while (1)
  {
    uint64_t v61 = v10;
    long long v62 = v12;
    BOOL v26 = v12 == v60;
    uint64_t v60 = v12;
    if (!v26) {
      break;
    }
LABEL_112:
    ++v24;
    double v10 = v61;
    a4 = v63;
    if (v24 == v25) {
      goto LABEL_27;
    }
  }
  while ((sub_1012534CC(a5, *v24, *v62) & 1) != 0)
  {
    if (++v62 == v14)
    {
      uint64_t v60 = v14;
      goto LABEL_112;
    }
  }
  uint64_t v50 = 0;
  double v10 = v61;
  if (v12) {
    goto LABEL_96;
  }
LABEL_97:
  if (__p) {
    operator delete(__p);
  }
  if (v72) {
    operator delete(v72);
  }
  if (v10) {
    operator delete(v10);
  }
  if (v78) {
    operator delete(v78);
  }
  if (v81) {
    operator delete(v81);
  }
  return v50;
}

void sub_101255CF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30)
{
  if (v30) {
    operator delete(v30);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a24) {
    operator delete(a24);
  }
  if (a27) {
    operator delete(a27);
  }
  if (a30) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101255D8C(double *a1, uint64_t **a2, uint64_t **a3, unint64_t a4, uint64_t a5)
{
  double v8 = a1[1] + a1[3];
  long long v86 = *(_OWORD *)a1;
  uint64_t v87 = *((void *)a1 + 2);
  long long v9 = *((_OWORD *)a1 + 1);
  *(void *)&v84[0] = v86;
  long long v85 = v9;
  double v88 = v8 * 0.5;
  v84[1] = v8 * 0.5;
  uint64_t v81 = 0;
  char v82 = 0;
  uint64_t v83 = 0;
  uint64_t v78 = 0;
  uint64_t v79 = 0;
  uint64_t v80 = 0;
  int v75 = 0;
  unint64_t v76 = 0;
  uint64_t v77 = 0;
  uint64_t v72 = 0;
  char v73 = 0;
  uint64_t v74 = 0;
  long long __p = 0;
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  unint64_t v66 = 0;
  BOOL v67 = 0;
  uint64_t v68 = 0;
  sub_101240254((double *)&v86, v84, a2, &v81, &v78, (void **)&v75);
  sub_101240254((double *)&v86, v84, a3, &v72, &__p, (void **)&v66);
  double v10 = v75;
  double v11 = v76;
  unint64_t v12 = v66;
  if (v75 == v76)
  {
    double v14 = v67;
    goto LABEL_12;
  }
  unint64_t v13 = (char *)v76 - (char *)v75;
  double v14 = v67;
  if ((unint64_t)((char *)v76 - (char *)v75) < 0x80
    || a4 > 0x63
    || (unint64_t)((char *)v67 - (char *)v66) < 0x79)
  {
    if (v66 != v67)
    {
      uint64_t v15 = v67;
      uint64_t v16 = v75;
      while (1)
      {
        unint64_t v17 = v12;
        BOOL v26 = v12 == v15;
        uint64_t v15 = v12;
        if (!v26) {
          break;
        }
LABEL_9:
        if (++v16 == v11) {
          goto LABEL_46;
        }
      }
      while ((sub_1012534CC(a5, *v16, *v17) & 1) != 0)
      {
        if (++v17 == v14)
        {
          uint64_t v15 = v14;
          goto LABEL_9;
        }
      }
      goto LABEL_95;
    }
  }
  else
  {
    int64x2_t v89 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    int64x2_t v90 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    double v32 = v75;
    do
      sub_101240044((double *)v89.i64, (double *)(*v10++ + 32));
    while (v10 != v11);
    uint64_t v34 = v89.i64[1];
    uint64_t v33 = v89.i64[0];
    uint64_t v36 = v90.i64[1];
    uint64_t v35 = v90.i64[0];
    if (v12 != v14)
    {
      uint64_t v37 = v12;
      do
        sub_101240044((double *)v89.i64, (double *)(*v37++ + 32));
      while (v37 != v14);
      uint64_t v34 = v89.i64[1];
      uint64_t v33 = v89.i64[0];
      uint64_t v36 = v90.i64[1];
      uint64_t v35 = v90.i64[0];
    }
    v64.i64[0] = v33;
    v64.i64[1] = v34;
    v65.i64[0] = v35;
    v65.i64[1] = v36;
    double v10 = v32;
    if ((sub_10125566C(&v64, &v75, &v66, a4 + 1, a5) & 1) == 0) {
      goto LABEL_95;
    }
  }
LABEL_46:
  double v39 = (uint64_t *)v72;
  double v38 = v73;
  if ((unint64_t)((char *)v73 - (unsigned char *)v72) < 0x80
    || (unint64_t)((char *)v70 - (unsigned char *)__p) < 0x80
    || a4 > 0x63
    || v13 < 0x79)
  {
    if (v72 == v73)
    {
LABEL_55:
      uint64_t v43 = (uint64_t *)__p;
      long long v44 = v70;
      if (__p == v70) {
        goto LABEL_12;
      }
      double v45 = v70;
      uint64_t v46 = v10;
      while (1)
      {
        double v47 = v43;
        BOOL v26 = v43 == v45;
        double v45 = v43;
        if (!v26) {
          break;
        }
LABEL_61:
        if (++v46 == v11) {
          goto LABEL_12;
        }
      }
      while ((sub_1012534CC(a5, *v46, *v47) & 1) != 0)
      {
        if (++v47 == v44)
        {
          double v45 = v44;
          goto LABEL_61;
        }
      }
    }
    else
    {
      uint64_t v40 = v73;
      double v41 = v10;
      while (1)
      {
        uint64_t v42 = v39;
        BOOL v26 = v39 == v40;
        uint64_t v40 = v39;
        if (!v26) {
          break;
        }
LABEL_54:
        if (++v41 == v11) {
          goto LABEL_55;
        }
      }
      while ((sub_1012534CC(a5, *v41, *v42) & 1) != 0)
      {
        if (++v42 == v38)
        {
          uint64_t v40 = v38;
          goto LABEL_54;
        }
      }
    }
LABEL_95:
    uint64_t v50 = 0;
    if (!v12) {
      goto LABEL_97;
    }
    goto LABEL_96;
  }
  unint64_t v55 = a4;
  int64x2_t v89 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  int64x2_t v90 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  char v56 = v10;
  do
    sub_101240044((double *)v89.i64, (double *)(*v10++ + 32));
  while (v10 != v11);
  int64x2_t v64 = v89;
  int64x2_t v65 = v90;
  double v10 = v56;
  if (!sub_10125566C(&v64, &v75, &v72, v55 + 1, a5)
    || (sub_10125566C(&v64, &v75, &__p, v55 + 1, a5) & 1) == 0)
  {
    goto LABEL_95;
  }
  a4 = v55;
LABEL_12:
  uint64_t v19 = (uint64_t *)v81;
  int v18 = v82;
  unint64_t v20 = (char *)v82 - (unsigned char *)v81;
  if (v12 == v14) {
    goto LABEL_27;
  }
  if (v20 >= 0x80
    && (unint64_t)((char *)v79 - (unsigned char *)v78) >= 0x80
    && a4 <= 0x63
    && (unint64_t)((char *)v14 - (char *)v12) >= 0x79)
  {
    char v57 = v10;
    int64x2_t v89 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    int64x2_t v90 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    uint64_t v58 = v12;
    do
      sub_101240044((double *)v89.i64, (double *)(*v58++ + 32));
    while (v58 != v14);
    int64x2_t v64 = v89;
    int64x2_t v65 = v90;
    double v10 = v57;
    if (!sub_10125566C(&v64, &v81, &v66, a4 + 1, a5)
      || (sub_10125566C(&v64, &v78, &v66, a4 + 1, a5) & 1) == 0)
    {
      goto LABEL_95;
    }
LABEL_27:
    uint64_t v27 = v10;
    if (v20 < 0x80 || a4 > 0x63 || (unint64_t)((char *)v73 - (unsigned char *)v72) < 0x79)
    {
      if (v19 != v18)
      {
        uint64_t v28 = (uint64_t *)v72;
        uint64_t v29 = v73;
        if (v72 != v73)
        {
          long long v30 = v73;
          while (1)
          {
            uint64_t v31 = v28;
            BOOL v26 = v28 == v30;
            long long v30 = v28;
            if (!v26) {
              break;
            }
LABEL_35:
            if (++v19 == v18) {
              goto LABEL_66;
            }
          }
          while ((sub_1012534CC(a5, *v19, *v31) & 1) != 0)
          {
            if (++v31 == v29)
            {
              long long v30 = v29;
              goto LABEL_35;
            }
          }
          goto LABEL_70;
        }
      }
    }
    else if ((sub_10125566C(&v86, &v81, &v72, a4 + 1, a5) & 1) == 0)
    {
LABEL_70:
      uint64_t v50 = 0;
      goto LABEL_80;
    }
LABEL_66:
    long long v49 = (uint64_t *)v78;
    long long v48 = v79;
    if ((unint64_t)((char *)v79 - (unsigned char *)v78) < 0x80
      || a4 > 0x63
      || (unint64_t)((char *)v70 - (unsigned char *)__p) < 0x79)
    {
      if (v78 != v79)
      {
        double v51 = (uint64_t *)__p;
        int64x2_t v52 = v70;
        if (__p != v70)
        {
          int64x2_t v53 = v70;
          while (1)
          {
            int v54 = v51;
            BOOL v26 = v51 == v53;
            int64x2_t v53 = v51;
            if (!v26) {
              break;
            }
LABEL_78:
            if (++v49 == v48) {
              goto LABEL_79;
            }
          }
          while ((sub_1012534CC(a5, *v49, *v54) & 1) != 0)
          {
            if (++v54 == v52)
            {
              int64x2_t v53 = v52;
              goto LABEL_78;
            }
          }
          goto LABEL_70;
        }
      }
    }
    else if ((sub_10125566C(v84, &v78, &__p, a4 + 1, a5) & 1) == 0)
    {
      goto LABEL_70;
    }
LABEL_79:
    uint64_t v50 = 1;
LABEL_80:
    double v10 = v27;
    if (!v12) {
      goto LABEL_97;
    }
LABEL_96:
    operator delete(v12);
    goto LABEL_97;
  }
  if (v81 != v82)
  {
    BOOL v21 = v14;
    unint64_t v22 = (uint64_t *)v81;
    while (1)
    {
      unint64_t v23 = v12;
      BOOL v26 = v12 == v21;
      BOOL v21 = v12;
      if (!v26) {
        break;
      }
LABEL_21:
      if (++v22 == v18) {
        goto LABEL_22;
      }
    }
    while ((sub_1012534CC(a5, *v22, *v23) & 1) != 0)
    {
      if (++v23 == v14)
      {
        BOOL v21 = v14;
        goto LABEL_21;
      }
    }
    goto LABEL_95;
  }
LABEL_22:
  int v24 = (uint64_t *)v78;
  int v25 = v79;
  BOOL v26 = v78 == v79 || v12 == v14;
  if (v26) {
    goto LABEL_27;
  }
  uint64_t v60 = v14;
  unint64_t v63 = a4;
  while (1)
  {
    uint64_t v61 = v10;
    long long v62 = v12;
    BOOL v26 = v12 == v60;
    uint64_t v60 = v12;
    if (!v26) {
      break;
    }
LABEL_112:
    ++v24;
    double v10 = v61;
    a4 = v63;
    if (v24 == v25) {
      goto LABEL_27;
    }
  }
  while ((sub_1012534CC(a5, *v24, *v62) & 1) != 0)
  {
    if (++v62 == v14)
    {
      uint64_t v60 = v14;
      goto LABEL_112;
    }
  }
  uint64_t v50 = 0;
  double v10 = v61;
  if (v12) {
    goto LABEL_96;
  }
LABEL_97:
  if (__p) {
    operator delete(__p);
  }
  if (v72) {
    operator delete(v72);
  }
  if (v10) {
    operator delete(v10);
  }
  if (v78) {
    operator delete(v78);
  }
  if (v81) {
    operator delete(v81);
  }
  return v50;
}

void sub_101256424(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30)
{
  if (v30) {
    operator delete(v30);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a24) {
    operator delete(a24);
  }
  if (a27) {
    operator delete(a27);
  }
  if (a30) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1012564B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v5 = *(double *)(a2 + 80);
  double v6 = *(double *)(a2 + 136);
  if (vabdd_f64(v5, v6) >= 50.0)
  {
    BOOL v11 = v5 < v6;
  }
  else
  {
    double v7 = *(double *)(a2 + 72);
    if (v7 == 0.0) {
      __assert_rtn("apply", "segment_ratio.hpp", 56, "lhs.denominator() != Type(0)");
    }
    double v8 = *(double *)(a2 + 128);
    if (v8 == 0.0) {
      __assert_rtn("apply", "segment_ratio.hpp", 57, "rhs.denominator() != Type(0)");
    }
    double v9 = *(double *)(a2 + 64) / v7;
    double v10 = *(double *)(a2 + 120) / v8;
    if (v9 == v10)
    {
      BOOL v11 = 0;
    }
    else if ((*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL {
           || (*(void *)&v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    }
    {
      BOOL v11 = 1;
    }
    else
    {
      double v12 = vabdd_f64(v9, v10);
      double v13 = fabs(v9);
      double v14 = fabs(v10);
      if (v13 < v14) {
        double v13 = v14;
      }
      if (v13 >= 1.0) {
        double v15 = v13 * 2.22044605e-16;
      }
      else {
        double v15 = 2.22044605e-16;
      }
      BOOL v11 = v12 > v15;
    }
    if (v9 >= v10) {
      BOOL v11 = 0;
    }
  }
  *(_DWORD *)(a1 + 16) = 6;
  if (*(void *)a2 <= (unint64_t)v11) {
    __assert_rtn("assign_point", "get_turn_info.hpp", 164, "index < info.count");
  }
  *(_OWORD *)a1 = *(_OWORD *)(a2 + 16 * v11 + 8);
  uint64_t v16 = a2 + 56 * v11;
  long long v17 = *(_OWORD *)(v16 + 40);
  *(void *)(a1 + 104) = *(void *)(v16 + 56);
  *(_OWORD *)(a1 + 88) = v17;
  long long v18 = *(_OWORD *)(v16 + 64);
  *(void *)(a1 + 184) = *(void *)(v16 + 80);
  *(_OWORD *)(a1 + 168) = v18;
  uint64_t v19 = *(void *)(a3 + 16);
  unint64_t v20 = *(double **)(v19 + 24);
  if (!*(unsigned char *)(v19 + 80))
  {
    sub_101246990(*(void *)(a3 + 16), v19 + 32, *v20, v20[1]);
    *(_OWORD *)(v19 + 64) = *(_OWORD *)*(void *)(v19 + 32);
    *(unsigned char *)(v19 + 80) = 1;
  }
  uint64_t v21 = *(void *)(a3 + 8);
  if (!*(unsigned char *)(v21 + 80))
  {
    sub_101246990(*(void *)(a3 + 8), v21 + 32, **(double **)(v21 + 24), *(double *)(*(void *)(v21 + 24) + 8));
    *(_OWORD *)(v21 + 64) = *(_OWORD *)*(void *)(v21 + 32);
    *(unsigned char *)(v21 + 80) = 1;
  }
  int v22 = sub_1012472B0(v20, (double *)(v19 + 64), (double *)(v21 + 64));
  uint64_t v23 = *(void *)(a3 + 8);
  int v24 = *(double **)(v23 + 16);
  int v25 = *(double **)(v23 + 24);
  if (!*(unsigned char *)(v23 + 80))
  {
    sub_101246990(*(void *)(a3 + 8), v23 + 32, *v25, v25[1]);
    *(_OWORD *)(v23 + 64) = *(_OWORD *)*(void *)(v23 + 32);
    *(unsigned char *)(v23 + 80) = 1;
  }
  int v26 = sub_1012472B0(v24, v25, (double *)(v23 + 64));
  uint64_t v27 = *(void *)(a3 + 8);
  uint64_t v28 = *(void *)(a3 + 16);
  long long v30 = *(double **)(v27 + 16);
  uint64_t v29 = *(double **)(v27 + 24);
  if (!*(unsigned char *)(v28 + 80))
  {
    sub_101246990(v28, v28 + 32, **(double **)(v28 + 24), *(double *)(*(void *)(v28 + 24) + 8));
    *(_OWORD *)(v28 + 64) = *(_OWORD *)*(void *)(v28 + 32);
    *(unsigned char *)(v28 + 80) = 1;
  }
  uint64_t result = sub_1012472B0(v30, v29, (double *)(v28 + 64));
  if (v22 || v26 != result)
  {
    if (result * v26 == -1) {
      BOOL v33 = v26 == -1;
    }
    else {
      BOOL v33 = v22 == -1;
    }
    if (v33) {
      int v34 = 2;
    }
    else {
      int v34 = 1;
    }
    *(_DWORD *)(a1 + 40) = v34;
    if (v33) {
      int v32 = 1;
    }
    else {
      int v32 = 2;
    }
  }
  else
  {
    int v32 = 4;
    *(_DWORD *)(a1 + 40) = 4;
  }
  *(_DWORD *)(a1 + 120) = v32;
  return result;
}

__n128 sub_1012567B0(void *a1, uint64_t a2)
{
  uint64_t v4 = (char *)a1[1];
  double v5 = (char *)a1[2];
  unint64_t v6 = (v5 - v4) >> 3;
  if (v5 == v4) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 20 * v6 - 1;
  }
  unint64_t v8 = a1[4];
  unint64_t v9 = a1[5] + v8;
  if (v7 == v9)
  {
    if (v8 < 0x14)
    {
      uint64_t v23 = (char *)a1[3];
      int v24 = (char *)*a1;
      uint64_t v25 = (uint64_t)&v23[-*a1];
      if (v6 >= v25 >> 3)
      {
        uint64_t v28 = v25 >> 2;
        if (v23 == v24) {
          unint64_t v29 = 1;
        }
        else {
          unint64_t v29 = v28;
        }
        long long v30 = (char *)sub_100048350(v29);
        uint64_t v32 = v31;
        BOOL v33 = operator new(0xFA0uLL);
        int v34 = &v30[8 * v6];
        uint64_t v35 = &v30[8 * v32];
        if (v6 == v32)
        {
          uint64_t v36 = 8 * v6;
          if (v5 - v4 < 1)
          {
            uint64_t v81 = v33;
            uint64_t v82 = v36 >> 2;
            if (v5 == v4) {
              unint64_t v83 = 1;
            }
            else {
              unint64_t v83 = v82;
            }
            int v84 = (char *)sub_100048350(v83);
            int v34 = &v84[8 * (v83 >> 2)];
            uint64_t v35 = &v84[8 * v85];
            if (v30) {
              operator delete(v30);
            }
            long long v30 = v84;
            BOOL v33 = v81;
          }
          else
          {
            uint64_t v37 = v36 >> 3;
            if (v37 >= -1) {
              unint64_t v38 = v37 + 1;
            }
            else {
              unint64_t v38 = v37 + 2;
            }
            v34 -= 8 * (v38 >> 1);
          }
        }
        *(void *)int v34 = v33;
        long long v86 = v34 + 8;
        for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
        {
          if (v34 == v30)
          {
            if (v86 >= v35)
            {
              if (v35 == v30) {
                unint64_t v92 = 1;
              }
              else {
                unint64_t v92 = (v35 - v30) >> 2;
              }
              char v93 = (char *)sub_100048350(v92);
              uint64_t v95 = v93;
              int v34 = &v93[(2 * v92 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v97 = v86 - v30;
              BOOL v96 = v86 == v30;
              long long v86 = v34;
              if (!v96)
              {
                long long v86 = &v34[v97 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v98 = 8 * (v97 >> 3);
                int v99 = v34;
                uint64_t v100 = (uint64_t *)v30;
                do
                {
                  uint64_t v101 = *v100++;
                  *(void *)int v99 = v101;
                  v99 += 8;
                  v98 -= 8;
                }
                while (v98);
              }
              uint64_t v35 = &v93[8 * v94];
              if (v30) {
                operator delete(v30);
              }
              long long v30 = v95;
            }
            else
            {
              uint64_t v88 = (v35 - v86) >> 3;
              if (v88 >= -1) {
                uint64_t v89 = v88 + 1;
              }
              else {
                uint64_t v89 = v88 + 2;
              }
              uint64_t v90 = v89 >> 1;
              int v34 = &v30[8 * (v89 >> 1)];
              uint64_t v91 = v30;
              if (v86 != v30)
              {
                memmove(v34, v30, v86 - v30);
                uint64_t v91 = v86;
              }
              long long v86 = &v91[8 * v90];
            }
          }
          uint64_t v102 = *(void *)(i - 8);
          *((void *)v34 - 1) = v102;
          v34 -= 8;
        }
        int v103 = (char *)*a1;
        *a1 = v30;
        a1[1] = v34;
        a1[2] = v86;
        a1[3] = v35;
        if (v103) {
          operator delete(v103);
        }
        goto LABEL_36;
      }
      int v26 = operator new(0xFA0uLL);
      uint64_t v27 = v26;
      if (v23 == v5)
      {
        if (v4 == v24)
        {
          if (v5 == v4) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v23 - v4) >> 2;
          }
          uint64_t v60 = 2 * v59;
          uint64_t v61 = (char *)sub_100048350(v59);
          uint64_t v4 = &v61[(v60 + 6) & 0xFFFFFFFFFFFFFFF8];
          unint64_t v63 = (uint64_t *)a1[1];
          int64x2_t v64 = v4;
          uint64_t v65 = a1[2] - (void)v63;
          if (v65)
          {
            int64x2_t v64 = &v4[v65 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v66 = 8 * (v65 >> 3);
            BOOL v67 = &v61[(v60 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              uint64_t v68 = *v63++;
              *(void *)BOOL v67 = v68;
              v67 += 8;
              v66 -= 8;
            }
            while (v66);
          }
          uint64_t v69 = (char *)*a1;
          *a1 = v61;
          a1[1] = v4;
          a1[2] = v64;
          a1[3] = &v61[8 * v62];
          if (v69)
          {
            operator delete(v69);
            uint64_t v4 = (char *)a1[1];
          }
        }
        *((void *)v4 - 1) = v27;
        uint64_t v70 = (char *)a1[1];
        uint64_t v71 = (char *)a1[2];
        a1[1] = v70 - 8;
        uint64_t v72 = *((void *)v70 - 1);
        a1[1] = v70;
        if (v71 == (char *)a1[3])
        {
          uint64_t v73 = (uint64_t)&v70[-*a1];
          if ((unint64_t)v70 <= *a1)
          {
            if (v71 == (char *)*a1) {
              unint64_t v104 = 1;
            }
            else {
              unint64_t v104 = (uint64_t)&v71[-*a1] >> 2;
            }
            uint64_t v105 = (char *)sub_100048350(v104);
            char v107 = &v105[8 * (v104 >> 2)];
            int v108 = (uint64_t *)a1[1];
            uint64_t v71 = v107;
            uint64_t v109 = a1[2] - (void)v108;
            if (v109)
            {
              uint64_t v71 = &v107[v109 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v110 = 8 * (v109 >> 3);
              uint64_t v111 = &v105[8 * (v104 >> 2)];
              do
              {
                uint64_t v112 = *v108++;
                *(void *)uint64_t v111 = v112;
                v111 += 8;
                v110 -= 8;
              }
              while (v110);
            }
            uint64_t v113 = (char *)*a1;
            *a1 = v105;
            a1[1] = v107;
            a1[2] = v71;
            a1[3] = &v105[8 * v106];
            if (v113)
            {
              operator delete(v113);
              uint64_t v71 = (char *)a1[2];
            }
          }
          else
          {
            uint64_t v74 = v73 >> 3;
            BOOL v15 = v73 >> 3 < -1;
            uint64_t v75 = (v73 >> 3) + 2;
            if (v15) {
              uint64_t v76 = v75;
            }
            else {
              uint64_t v76 = v74 + 1;
            }
            uint64_t v77 = -(v76 >> 1);
            uint64_t v78 = v76 >> 1;
            uint64_t v79 = &v70[-8 * v78];
            int64_t v80 = v71 - v70;
            if (v71 != v70)
            {
              memmove(&v70[-8 * v78], v70, v71 - v70);
              uint64_t v70 = (char *)a1[1];
            }
            uint64_t v71 = &v79[v80];
            a1[1] = &v70[8 * v77];
            a1[2] = &v79[v80];
          }
        }
        *(void *)uint64_t v71 = v72;
      }
      else
      {
        *(void *)double v5 = v26;
      }
    }
    else
    {
      a1[4] = v8 - 20;
      uint64_t v12 = *(void *)v4;
      double v10 = v4 + 8;
      uint64_t v11 = v12;
      a1[1] = v10;
      if (v5 == (char *)a1[3])
      {
        uint64_t v13 = (uint64_t)&v10[-*a1];
        if ((unint64_t)v10 <= *a1)
        {
          if (v5 == (char *)*a1) {
            unint64_t v39 = 1;
          }
          else {
            unint64_t v39 = (uint64_t)&v5[-*a1] >> 2;
          }
          uint64_t v40 = (char *)sub_100048350(v39);
          uint64_t v42 = &v40[8 * (v39 >> 2)];
          uint64_t v43 = (uint64_t *)a1[1];
          double v5 = v42;
          uint64_t v44 = a1[2] - (void)v43;
          if (v44)
          {
            double v5 = &v42[v44 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v45 = 8 * (v44 >> 3);
            uint64_t v46 = &v40[8 * (v39 >> 2)];
            do
            {
              uint64_t v47 = *v43++;
              *(void *)uint64_t v46 = v47;
              v46 += 8;
              v45 -= 8;
            }
            while (v45);
          }
          long long v48 = (char *)*a1;
          *a1 = v40;
          a1[1] = v42;
          a1[2] = v5;
          a1[3] = &v40[8 * v41];
          if (v48)
          {
            operator delete(v48);
            double v5 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v14 = v13 >> 3;
          BOOL v15 = v13 >> 3 < -1;
          uint64_t v16 = (v13 >> 3) + 2;
          if (v15) {
            uint64_t v17 = v16;
          }
          else {
            uint64_t v17 = v14 + 1;
          }
          uint64_t v18 = -(v17 >> 1);
          uint64_t v19 = v17 >> 1;
          unint64_t v20 = &v10[-8 * v19];
          int64_t v21 = v5 - v10;
          if (v5 != v10)
          {
            memmove(&v10[-8 * v19], v10, v5 - v10);
            double v5 = (char *)a1[1];
          }
          int v22 = &v5[8 * v18];
          double v5 = &v20[v21];
          a1[1] = v22;
          a1[2] = &v20[v21];
        }
      }
      *(void *)double v5 = v11;
    }
    a1[2] += 8;
LABEL_36:
    uint64_t v4 = (char *)a1[1];
    unint64_t v9 = a1[5] + a1[4];
  }
  unint64_t v49 = *(void *)&v4[8 * (v9 / 0x14)] + 200 * (v9 % 0x14);
  *(_OWORD *)unint64_t v49 = *(_OWORD *)a2;
  long long v50 = *(_OWORD *)(a2 + 16);
  long long v51 = *(_OWORD *)(a2 + 32);
  long long v52 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v49 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v49 + 64) = v52;
  *(_OWORD *)(v49 + 16) = v50;
  *(_OWORD *)(v49 + 32) = v51;
  long long v53 = *(_OWORD *)(a2 + 80);
  long long v54 = *(_OWORD *)(a2 + 96);
  long long v55 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(v49 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(v49 + 128) = v55;
  *(_OWORD *)(v49 + 80) = v53;
  *(_OWORD *)(v49 + 96) = v54;
  __n128 result = *(__n128 *)(a2 + 144);
  long long v57 = *(_OWORD *)(a2 + 160);
  long long v58 = *(_OWORD *)(a2 + 176);
  *(void *)(v49 + 192) = *(void *)(a2 + 192);
  *(_OWORD *)(v49 + 160) = v57;
  *(_OWORD *)(v49 + 176) = v58;
  *(__n128 *)(v49 + 144) = result;
  ++a1[5];
  return result;
}

void sub_101256CC8(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

int8x16_t sub_101256CF4(uint64_t a1, int8x16_t *a2)
{
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &off_101AA3EF8;
  *(void *)(a1 + 8) = off_101AA3F28;
  *(void *)(a1 + 16) = off_101AA3F50;
  *(_DWORD *)(a1 + 48) = a2[1].i32[0];
  int8x16_t result = vextq_s8(*a2, *a2, 8uLL);
  *(int8x16_t *)(a1 + 32) = result;
  return result;
}

uint64_t sub_101256D70(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 24));
  std::exception::~exception((std::exception *)(a1 + 8));
  return a1;
}

void sub_101256DC4()
{
}

void sub_101256F84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100098B6C(&a9);
  sub_100098B6C(&a10);
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  _Unwind_Resume(a1);
}

void sub_101256FFC(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x38uLL);
  sub_1012572B0((uint64_t)exception, a1);
}

void sub_101257044(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_101257058(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 24));
  std::exception::~exception((std::exception *)(a1 + 8));

  operator delete();
}

void sub_1012570CC(uint64_t a1)
{
  *(void *)(a1 + 8) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 16));

  std::exception::~exception((std::exception *)a1);
}

void sub_101257128(uint64_t a1)
{
  *(void *)(a1 + 8) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 16));
  std::exception::~exception((std::exception *)a1);

  operator delete();
}

const char *sub_1012571A0()
{
  return "Boost.Geometry Overlay invalid input exception";
}

void sub_1012571AC(void *a1)
{
  *a1 = &off_10199A8F0;
  sub_100098B6C(a1 + 1);

  std::exception::~exception((std::exception *)a1 - 1);
}

void sub_101257204(void *a1)
{
  *a1 = &off_10199A8F0;
  sub_100098B6C(a1 + 1);
  std::exception::~exception((std::exception *)a1 - 1);

  operator delete();
}

void sub_101257278(std::exception *a1)
{
  std::exception::~exception(a1);

  operator delete();
}

uint64_t sub_1012572B0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_10199A898;
  *(void *)(a1 + 8) = &off_101AA3F70;
  uint64_t v4 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = &off_10199A8F0;
  *(void *)(a1 + 24) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = v5;
  *(void *)a1 = &off_101AA3EF8;
  *(void *)(a1 + 8) = off_101AA3F28;
  *(void *)(a1 + 16) = off_101AA3F50;
  return a1;
}

void sub_1012573CC(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1012573E0(uint64_t a1)
{
  double v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      double v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 10;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 20;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1012574A8(double **a1, uint64_t *a2, uint64_t **a3)
{
  uint64_t v9 = a1;
  uint64_t v10 = a1[1];
  if (v10 != *a1)
  {
    memset(&v59[6], 255, 24);
    uint64_t v11 = *a1 + 2;
    double v12 = 0.0;
    if ((unint64_t)((char *)v10 - (char *)*a1) >= 0x40 && v11 != v10)
    {
      unint64_t v14 = 0;
      double v4 = 1.0;
      do
      {
        double v15 = *(v11 - 2);
        double v16 = *v11;
        if (v15 != *v11)
        {
          if ((*(void *)&v15 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
            || (*(void *)&v16 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_12;
          }
          double v18 = vabdd_f64(v15, v16);
          double v19 = fabs(v15);
          double v20 = fabs(v16);
          if (v19 < v20) {
            double v19 = v20;
          }
          double v21 = v19 >= 1.0 ? v19 * 2.22044605e-16 : 2.22044605e-16;
          if (v18 > v21)
          {
LABEL_12:
            double v3 = sub_101232970(v11 - 2, v11);
            double v12 = v12 + v3;
            v14 += sub_101232BC4(v11 - 2, v11);
          }
        }
        v11 += 2;
      }
      while (v11 != v10);
      if (v14)
      {
        double v22 = (double)((v14 >> 1) + 1);
        double v23 = fabs(v12);
        double v24 = -v23;
        double v25 = -(v23 - v22 * 6.28318531);
        double v26 = -(v24 + v22 * 6.28318531);
        if (v12 <= 0.0) {
          double v12 = v25;
        }
        else {
          double v12 = v26;
        }
      }
    }
    uint64_t v27 = *v9;
    uint64_t v28 = v9[1];
    if (*v9 != v28)
    {
      double v4 = *v27;
      double v3 = v27[1];
    }
    BOOL v29 = v27 != v28;
    long long v30 = sub_101257B18(a3, a2, (uint64_t)a2);
    *((unsigned char *)v30 + 56) = v29;
    *((double *)v30 + 8) = v4;
    *((double *)v30 + 9) = v3;
    *((double *)v30 + 10) = v12;
    *((_WORD *)v30 + 44) = 0;
    *(_OWORD *)((char *)v30 + 90) = *(_OWORD *)v59;
    *(_OWORD *)(v30 + 13) = *(_OWORD *)&v59[14];
    v30[15] = (uint64_t *)0xBFF0000000000000;
    uint64_t v32 = v30 + 16;
    uint64_t v31 = v30[16];
    if (v31)
    {
      v30[17] = v31;
      operator delete(v31);
    }
    void *v32 = 0;
    v32[1] = 0;
    v32[2] = 0;
  }
  int v34 = (uint64_t ***)v9[3];
  for (uint64_t i = v9[4]; v34 != (uint64_t ***)i; v34 += 3)
  {
    ++a2[2];
    uint64_t v35 = (double *)v34[1];
    if (v35 != (double *)*v34)
    {
      memset(&v59[6], 255, 24);
      uint64_t v36 = (double *)(*v34 + 2);
      double v37 = 0.0;
      if ((unint64_t)((char *)v35 - (char *)*v34) >= 0x40 && v36 != v35)
      {
        unint64_t v39 = v9;
        uint64_t v40 = a3;
        unint64_t v41 = 0;
        do
        {
          double v42 = *(v36 - 2);
          double v43 = *v36;
          if (v42 != *v36)
          {
            if ((*(void *)&v42 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
              || (*(void *)&v43 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_43;
            }
            double v45 = vabdd_f64(v42, v43);
            double v46 = fabs(v42);
            double v47 = fabs(v43);
            if (v46 < v47) {
              double v46 = v47;
            }
            double v48 = v46 >= 1.0 ? v46 * 2.22044605e-16 : 2.22044605e-16;
            if (v45 > v48)
            {
LABEL_43:
              double v37 = v37 + sub_101232970(v36 - 2, v36);
              v41 += sub_101232BC4(v36 - 2, v36);
            }
          }
          v36 += 2;
        }
        while (v36 != v35);
        if (v41)
        {
          uint64_t v49 = (v41 >> 1) + 1;
          double v50 = fabs(v37);
          double v51 = -v50;
          double v52 = -(v50 - (double)(unint64_t)v49 * 6.28318531);
          if (v37 <= 0.0) {
            double v37 = v52;
          }
          else {
            double v37 = -(v51 + (double)(unint64_t)v49 * 6.28318531);
          }
        }
        a3 = v40;
        uint64_t v9 = v39;
      }
      long long v53 = *v34;
      long long v54 = v34[1];
      if (*v34 != v54)
      {
        unint64_t v5 = *v53;
        uint64_t v6 = v53[1];
      }
      BOOL v55 = v53 != v54;
      char v56 = sub_101257B18(a3, a2, (uint64_t)a2);
      *((unsigned char *)v56 + 56) = v55;
      v56[8] = v5;
      v56[9] = v6;
      *((double *)v56 + 10) = v37;
      *((_WORD *)v56 + 44) = 0;
      *(_OWORD *)((char *)v56 + 90) = *(_OWORD *)v59;
      *(_OWORD *)(v56 + 13) = *(_OWORD *)&v59[14];
      v56[15] = (uint64_t *)0xBFF0000000000000;
      long long v58 = v56 + 16;
      long long v57 = v56[16];
      if (v57)
      {
        v56[17] = v57;
        operator delete(v57);
      }
      void *v58 = 0;
      v58[1] = 0;
      v58[2] = 0;
      uint64_t i = v9[4];
    }
  }
}

uint64_t sub_101257868(double *a1, double **a2, uint64_t a3)
{
  uint64_t result = sub_10124A234(a1, a3);
  if (!result)
  {
    uint64_t v6 = *a2;
    uint64_t v7 = a2[1];
    uint64_t v8 = a2[3];
    uint64_t v9 = a2[4];
    if (v8 == v9)
    {
      uint64_t v11 = 0;
LABEL_10:
      uint64_t v8 = a2[4];
    }
    else
    {
      uint64_t v10 = a2[3];
      do
      {
        if (*(void *)v10 != *((void *)v10 + 1)) {
          break;
        }
        v10 += 3;
      }
      while (v10 != v9);
      while (1)
      {
        uint64_t v11 = *(double **)v8;
        if (*(void *)v8 != *((void *)v8 + 1)) {
          break;
        }
        v8 += 3;
        if (v8 == v9)
        {
          uint64_t v11 = 0;
          goto LABEL_10;
        }
      }
    }
    double v15 = *a2;
    double v16 = v8;
    uint64_t v17 = v9;
    double v18 = v11;
    if (v6 != v7 || v8 != v9)
    {
      if (v6 == v7) {
        goto LABEL_17;
      }
      double v12 = v6 + 2;
LABEL_18:
      double v15 = v12;
      while (v15 != v7 || v16 != v9 || v9 != v17 && v18 != 0)
      {
        if (v15 != v7)
        {
          uint64_t result = sub_10124A234(v15, a3);
          if (result) {
            return result;
          }
          double v12 = v15 + 2;
          goto LABEL_18;
        }
        if (v16 == v17) {
          __assert_rtn("dereference", "flatten_iterator.hpp", 152, "m_outer_it != m_outer_end");
        }
        if (v18 == *((double **)v16 + 1)) {
          __assert_rtn("dereference", "flatten_iterator.hpp", 153, "m_inner_it != AccessInnerEnd::apply(*m_outer_it)");
        }
        uint64_t result = sub_10124A234(v18, a3);
        if (result) {
          return result;
        }
LABEL_17:
        sub_101257A70((uint64_t)&v16);
      }
    }
    return 0;
  }
  return result;
}

void sub_101257A14(void *a1)
{
  if (a1)
  {
    sub_101257A14(*a1);
    sub_101257A14(a1[1]);
    double v2 = (void *)a1[16];
    if (v2)
    {
      a1[17] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

uint64_t sub_101257A70(uint64_t result)
{
  double v2 = *(void **)result;
  uint64_t v1 = *(void **)(result + 8);
  if (*(void **)result == v1) {
    __assert_rtn("increment", "flatten_iterator.hpp", 192, "m_outer_it != m_outer_end");
  }
  uint64_t v3 = v2[1];
  uint64_t v4 = *(void *)(result + 16);
  if (v4 == v3) {
    __assert_rtn("increment", "flatten_iterator.hpp", 193, "m_inner_it != AccessInnerEnd::apply(*m_outer_it)");
  }
  uint64_t v5 = v4 + 16;
  *(void *)(result + 16) = v5;
  if (v5 == v3)
  {
    while (1)
    {
      v2 += 3;
      *(void *)uint64_t result = v2;
      if (v2 == v1) {
        break;
      }
      if (*v2 != v2[1])
      {
        *(void *)(result + 16) = *v2;
        return result;
      }
    }
  }
  return result;
}

uint64_t **sub_101257B18(uint64_t **a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (!v5)
  {
    uint64_t v10 = a1 + 1;
    goto LABEL_18;
  }
  uint64_t v7 = *a2;
  uint64_t v8 = (uint64_t *)a2[1];
  uint64_t v9 = (uint64_t *)a2[2];
  do
  {
    while (1)
    {
      uint64_t v10 = (uint64_t **)v5;
      uint64_t v11 = v5[4];
      if (v7 != v11) {
        break;
      }
      double v12 = v10[5];
      if (v8 != v12)
      {
        if ((uint64_t)v8 < (uint64_t)v12) {
          goto LABEL_12;
        }
        if ((uint64_t)v12 >= (uint64_t)v8) {
          return v10;
        }
        goto LABEL_15;
      }
      uint64_t v13 = v10[6];
      if ((uint64_t)v9 >= (uint64_t)v13)
      {
        if ((uint64_t)v13 >= (uint64_t)v9) {
          return v10;
        }
        goto LABEL_15;
      }
LABEL_12:
      uint64_t v5 = *v10;
      uint64_t v6 = v10;
      if (!*v10) {
        goto LABEL_18;
      }
    }
    if (v7 < v11) {
      goto LABEL_12;
    }
    if (v11 >= v7) {
      return v10;
    }
LABEL_15:
    uint64_t v5 = v10[1];
  }
  while (v5);
  uint64_t v6 = v10 + 1;
LABEL_18:
  unint64_t v14 = (uint64_t *)v10;
  uint64_t v10 = (uint64_t **)operator new(0x98uLL);
  *((_OWORD *)v10 + 2) = *(_OWORD *)a3;
  void v10[6] = *(uint64_t **)(a3 + 16);
  *((unsigned char *)v10 + 56) = 0;
  v10[10] = 0;
  *((_WORD *)v10 + 44) = 0;
  v10[12] = (uint64_t *)-1;
  v10[13] = (uint64_t *)-1;
  v10[14] = (uint64_t *)-1;
  v10[15] = (uint64_t *)0xBFF0000000000000;
  v10[17] = 0;
  v10[18] = 0;
  uint8_t v10[16] = 0;
  double *v10 = 0;
  v10[1] = 0;
  v10[2] = v14;
  double *v6 = (uint64_t *)v10;
  double v15 = (uint64_t *)**a1;
  double v16 = (uint64_t *)v10;
  if (v15)
  {
    *a1 = v15;
    double v16 = *v6;
  }
  sub_100046C90(a1[1], v16);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return v10;
}

double sub_101257C54(double *a1, double *a2, double *a3)
{
  if (!a1) {
    __assert_rtn("get", "pointing_segment.hpp", 101, "s.first != __null");
  }
  if (!a2) {
    __assert_rtn("get", "pointing_segment.hpp", 124, "s.second != __null");
  }
  double v4 = *a1;
  double v6 = *a2;
  uint64_t v7 = *((void *)a2 + 1);
  uint64_t v16 = *((void *)a1 + 1);
  uint64_t v5 = v16;
  double v17 = v4;
  sub_10123D770(&v17, (double *)&v16, 1);
  double v8 = v17;
  uint64_t v16 = v7;
  double v17 = v6;
  sub_10123D770(&v17, (double *)&v16, 1);
  double v9 = v17;
  uint64_t v16 = v5;
  double v17 = v8;
  uint64_t v14 = v7;
  double v15 = v9;
  sub_10123DA18(&v17, (double *)&v16, &v15, (double *)&v14);
  uint64_t v11 = v16;
  double result = v17;
  uint64_t v13 = v14;
  double v12 = v15;
  *a3 = v17;
  *((void *)a3 + 1) = v11;
  a3[2] = v12;
  *((void *)a3 + 3) = v13;
  return result;
}

void sub_101257D38(double *a1, double *a2, double *a3)
{
  if (!a2) {
    __assert_rtn("get", "pointing_segment.hpp", 101, "s.first != __null");
  }
  if (!a3) {
    __assert_rtn("get", "pointing_segment.hpp", 124, "s.second != __null");
  }
  double v4 = *a2;
  double v6 = *a3;
  double v7 = a3[1];
  double v23 = a2[1];
  double v5 = v23;
  v24[0] = v4;
  sub_10123D770(v24, &v23, 1);
  double v8 = v24[0];
  double v23 = v7;
  v24[0] = v6;
  sub_10123D770(v24, &v23, 1);
  double v22 = v5;
  double v23 = v8;
  double v20 = v7;
  double v21 = v24[0];
  sub_10123DA18(&v23, &v22, &v21, &v20);
  v24[0] = v23;
  v24[1] = v22;
  v24[2] = v21;
  v24[3] = v20;
  double v9 = *a1;
  double v10 = a1[1];
  double v11 = 1.79769313e308;
  double v12 = a1[2];
  double v13 = a1[3];
  if (*a1 == 1.79769313e308 && v10 == 1.79769313e308 && v12 == -1.79769313e308 && v13 == -1.79769313e308)
  {
    double v14 = -1.79769313e308;
    double v10 = 1.79769313e308;
    double v13 = -1.79769313e308;
  }
  else
  {
    double v22 = a1[1];
    double v23 = v9;
    double v20 = v13;
    double v21 = v12;
    double v15 = vabdd_f64(v9, v12);
    if (v15 < 360.0)
    {
      if (COERCE_UNSIGNED_INT64(fabs(v9 - v12)) > 0x7FEFFFFFFFFFFFFFLL)
      {
        BOOL v16 = 0;
      }
      else
      {
        double v17 = vabdd_f64(360.0, v15);
        double v18 = fmax(v15, 360.0);
        if (v18 >= 1.0) {
          double v19 = v18 * 2.22044605e-16;
        }
        else {
          double v19 = 2.22044605e-16;
        }
        BOOL v16 = v17 <= v19;
      }
    }
    else
    {
      BOOL v16 = 1;
    }
    sub_10123F230(&v23, &v22, &v21, &v20, v16);
    double v11 = v23;
    double v14 = v21;
  }
  v24[4] = v11;
  v24[5] = v10;
  v24[6] = v14;
  v24[7] = v13;
  sub_10123E140(v24, a1);
}

void sub_101257F40(double *a1, uint64_t **a2, unint64_t a3, uint64_t a4)
{
  double v6 = (*a1 + a1[2]) * 0.5;
  long long v7 = *((_OWORD *)a1 + 1);
  long long v48 = *(_OWORD *)a1;
  uint64_t v50 = *((void *)&v7 + 1);
  v46[1] = *((double *)&v48 + 1);
  long long v47 = v7;
  double v49 = v6;
  v46[0] = v6;
  double v43 = 0;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v40 = 0;
  unint64_t v41 = 0;
  uint64_t v42 = 0;
  double v37 = 0;
  unint64_t v38 = 0;
  uint64_t v39 = 0;
  sub_1012588B0((double *)&v48, v46, a2, (void **)&v43, (void **)&v40, (void **)&v37);
  double v8 = v37;
  double v9 = v38;
  if (v37 != v38)
  {
    int64x2_t v51 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    int64x2_t v52 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    double v10 = v37;
    do
      sub_101240044((double *)v51.i64, (double *)(*v10++ + 40));
    while (v10 != v9);
    v36[0] = v51;
    v36[1] = v52;
    unint64_t v11 = (char *)v9 - (char *)v8;
    double v12 = v8;
    if (a3 > 0x63 || (double v12 = v8, v11 <= 0x78))
    {
      do
      {
        double v14 = v12 + 1;
        if (v12 + 1 == v9) {
          break;
        }
        double v13 = v12 + 1;
        do
          sub_101258348(a4, *v12, *v13++);
        while (v13 != v9);
        ++v12;
      }
      while (v14 != v9);
    }
    else
    {
      sub_101258EA4((double *)v36, &v37, a3 + 1, a4);
    }
    if (v11 < 0x80 || a3 > 0x63 || (unint64_t)((char *)v44 - (char *)v43) < 0x79)
    {
      double v15 = v43;
      BOOL v16 = v44;
      if (v43 != v44)
      {
        double v17 = v44;
        double v18 = v8;
        do
        {
          BOOL v19 = v15 == v17;
          double v17 = v15;
          if (!v19)
          {
            double v20 = v15;
            do
              sub_101258348(a4, *v18, *v20++);
            while (v20 != v16);
            double v17 = v16;
          }
          ++v18;
        }
        while (v18 != v9);
      }
    }
    else
    {
      sub_10125997C((double *)v36, &v37, &v43, a3 + 1, a4);
    }
    if (v11 < 0x80 || a3 > 0x63 || (unint64_t)((char *)v41 - (char *)v40) < 0x79)
    {
      if (v8 != v9)
      {
        double v21 = v40;
        double v22 = v41;
        if (v40 != v41)
        {
          double v23 = v41;
          double v24 = v8;
          do
          {
            BOOL v19 = v21 == v23;
            double v23 = v21;
            if (!v19)
            {
              double v25 = v21;
              do
                sub_101258348(a4, *v24, *v25++);
              while (v25 != v22);
              double v23 = v22;
            }
            ++v24;
          }
          while (v24 != v9);
        }
      }
    }
    else
    {
      sub_10125997C((double *)v36, &v37, &v40, a3 + 1, a4);
    }
  }
  double v26 = v43;
  uint64_t v27 = v44;
  if (a3 > 0x63 || (unint64_t)((char *)v44 - (char *)v43) < 0x79)
  {
    if (v43 != v44)
    {
      uint64_t v28 = v43;
      do
      {
        BOOL v29 = v28 + 1;
        if (v28 + 1 == v27) {
          break;
        }
        long long v30 = v28 + 1;
        do
          sub_101258348(a4, *v28, *v30++);
        while (v30 != v27);
        ++v28;
      }
      while (v29 != v27);
    }
  }
  else
  {
    sub_101258EA4((double *)&v48, &v43, a3 + 1, a4);
  }
  uint64_t v31 = v40;
  uint64_t v32 = v41;
  if (a3 > 0x63 || (unint64_t)((char *)v41 - (char *)v40) < 0x79)
  {
    if (v40 != v41)
    {
      BOOL v33 = v40;
      do
      {
        int v34 = v33 + 1;
        if (v33 + 1 == v32) {
          break;
        }
        uint64_t v35 = v33 + 1;
        do
          sub_101258348(a4, *v33, *v35++);
        while (v35 != v32);
        ++v33;
      }
      while (v34 != v32);
    }
  }
  else
  {
    sub_101258EA4(v46, &v40, a3 + 1, a4);
  }
  if (v8) {
    operator delete(v8);
  }
  if (v31) {
    operator delete(v31);
  }
  if (v26)
  {
    operator delete(v26);
  }
}

void sub_1012582F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20)
{
  if (v20) {
    operator delete(v20);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_101258348(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v6 = (double *)(a2 + 32);
  long long v7 = (double *)(a3 + 32);
  if (*(double *)(a2 + 32) < *(double *)(a3 + 32))
  {
    if (!*(unsigned char *)(a1 + 40))
    {
      double v29 = *(double *)(a3 + 24);
      if (v29 <= 0.0) {
        return;
      }
      if ((*(void *)&v29 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v30 = fabs(v29);
        double v31 = 2.22044605e-16;
        if (v30 >= 1.0) {
          double v31 = v30 * 2.22044605e-16;
        }
        if (v30 <= v31) {
          return;
        }
      }
      double v32 = *(double *)(a2 + 24);
      if (v32 >= 0.0) {
        return;
      }
      if ((*(void *)&v32 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v33 = vabdd_f64(0.0, v32);
        double v34 = fmax(fabs(v32), 0.0);
        double v35 = v34 >= 1.0 ? v34 * 2.22044605e-16 : 2.22044605e-16;
        if (v33 <= v35) {
          return;
        }
      }
    }
    double v8 = sub_101257B18(*(uint64_t ***)(a1 + 24), (uint64_t *)a2, a2);
    double v9 = *((double *)v8 + 8);
    double v10 = *(double *)(a3 + 40);
    double v11 = *(double *)(a3 + 56);
    BOOL v12 = v9 > v11 || v9 < v10;
    if (!v12 || v11 - v10 >= 360.0) {
      goto LABEL_14;
    }
    double v13 = vabdd_f64(v9, v10);
    double v14 = 180.0;
    if (v13 != 180.0)
    {
      double v15 = v9 - v10;
      if ((*(void *)&v15 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        goto LABEL_69;
      }
      double v40 = fabs(v13 + -180.0);
      double v14 = 180.0;
      if (v13 < 180.0) {
        double v13 = 180.0;
      }
      double v41 = v13 >= 1.0 ? v13 * 2.22044605e-16 : 2.22044605e-16;
      if (v40 > v41)
      {
LABEL_69:
        double v14 = 180.0;
        if (v15 <= 180.0)
        {
          if (v15 >= -180.0) {
            goto LABEL_11;
          }
          double v14 = fmod(v15 + -180.0, 360.0) + 180.0;
        }
        else
        {
          double v15 = fmod(v15 + 180.0, 360.0) + -180.0;
          if (v15 != -180.0)
          {
            BOOL v42 = ((*(void *)&v15 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
               && (*(void *)&v15 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
            if (v42 && *(void *)&v15 != 0) {
              goto LABEL_11;
            }
            double v14 = 180.0;
            double v44 = fabs(v15 + 180.0);
            double v45 = fabs(v15);
            if (v45 < 180.0) {
              double v45 = 180.0;
            }
            double v46 = v45 >= 1.0 ? v45 * 2.22044605e-16 : 2.22044605e-16;
            if (v44 > v46)
            {
LABEL_11:
              if (v15 < 0.0) {
                double v15 = v15 + 360.0;
              }
              if (v10 + v15 > v11) {
                return;
              }
LABEL_14:
              double v16 = *((double *)v8 + 9);
              BOOL v17 = v16 < *(double *)(a3 + 48) || v16 > *(double *)(a3 + 64);
              if (v17
                || !sub_10125A050((uint64_t)(v8 + 7), (uint64_t *)a2, (uint64_t *)a3, *(void *)a1, *(void *)(a1 + 8), *(void **)(a1 + 16))|| v8[12] != (uint64_t *)-1 && *v7 >= *((double *)v8 + 15))
              {
                return;
              }
              long long v18 = *(_OWORD *)a3;
              v8[14] = *(uint64_t **)(a3 + 16);
              *((_OWORD *)v8 + 6) = v18;
              goto LABEL_42;
            }
          }
        }
      }
    }
    double v15 = v14;
    goto LABEL_11;
  }
  if (*(unsigned char *)(a1 + 40)) {
    goto LABEL_23;
  }
  double v36 = *(double *)(a2 + 24);
  if (v36 > 0.0)
  {
    if ((*(void *)&v36 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
      goto LABEL_114;
    }
    double v37 = fabs(v36);
    double v38 = 2.22044605e-16;
    if (v37 >= 1.0) {
      double v38 = v37 * 2.22044605e-16;
    }
    if (v37 > v38)
    {
LABEL_114:
      double v39 = *(double *)(a3 + 24);
      if (v39 < 0.0)
      {
        if ((*(void *)&v39 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || ((v54 = vabdd_f64(0.0, v39), double v55 = fmax(fabs(v39), 0.0), v55 >= 1.0)
            ? (double v56 = v55 * 2.22044605e-16)
            : (double v56 = 2.22044605e-16),
              v54 > v56))
        {
LABEL_23:
          double v8 = sub_101257B18(*(uint64_t ***)(a1 + 24), (uint64_t *)a3, a3);
          double v19 = *((double *)v8 + 8);
          double v20 = *(double *)(a2 + 40);
          double v21 = *(double *)(a2 + 56);
          BOOL v22 = v19 > v21 || v19 < v20;
          if (!v22 || v21 - v20 >= 360.0) {
            goto LABEL_34;
          }
          double v23 = vabdd_f64(v19, v20);
          double v24 = 180.0;
          if (v23 != 180.0)
          {
            double v25 = v19 - v20;
            if ((*(void *)&v25 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
              goto LABEL_93;
            }
            double v47 = fabs(v23 + -180.0);
            double v24 = 180.0;
            if (v23 < 180.0) {
              double v23 = 180.0;
            }
            double v48 = v23 >= 1.0 ? v23 * 2.22044605e-16 : 2.22044605e-16;
            if (v47 > v48)
            {
LABEL_93:
              double v24 = 180.0;
              if (v25 <= 180.0)
              {
                if (v25 >= -180.0) {
                  goto LABEL_31;
                }
                double v24 = fmod(v25 + -180.0, 360.0) + 180.0;
              }
              else
              {
                double v25 = fmod(v25 + 180.0, 360.0) + -180.0;
                if (v25 != -180.0)
                {
                  BOOL v49 = ((*(void *)&v25 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
                     && (*(void *)&v25 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
                  if (v49 && *(void *)&v25 != 0) {
                    goto LABEL_31;
                  }
                  double v24 = 180.0;
                  double v51 = fabs(v25 + 180.0);
                  double v52 = fabs(v25);
                  if (v52 < 180.0) {
                    double v52 = 180.0;
                  }
                  double v53 = v52 >= 1.0 ? v52 * 2.22044605e-16 : 2.22044605e-16;
                  if (v51 > v53)
                  {
LABEL_31:
                    if (v25 < 0.0) {
                      double v25 = v25 + 360.0;
                    }
                    if (v20 + v25 > v21) {
                      return;
                    }
LABEL_34:
                    double v26 = *((double *)v8 + 9);
                    BOOL v27 = v26 < *(double *)(a2 + 48) || v26 > *(double *)(a2 + 64);
                    if (v27
                      || !sub_10125A050((uint64_t)(v8 + 7), (uint64_t *)a3, (uint64_t *)a2, *(void *)a1, *(void *)(a1 + 8), *(void **)(a1 + 16))|| v8[12] != (uint64_t *)-1 && *v6 >= *((double *)v8 + 15))
                    {
                      return;
                    }
                    long long v28 = *(_OWORD *)a2;
                    v8[14] = *(uint64_t **)(a2 + 16);
                    *((_OWORD *)v8 + 6) = v28;
                    long long v7 = v6;
LABEL_42:
                    unsigned char v8[15] = *(uint64_t **)v7;
                    return;
                  }
                }
              }
            }
          }
          double v25 = v24;
          goto LABEL_31;
        }
      }
    }
  }
}

void sub_1012588B0(double *a1, double *a2, uint64_t **a3, void **a4, void **a5, void **a6)
{
  double v6 = *a3;
  if (*a3 != a3[1])
  {
    while (1)
    {
      uint64_t v13 = *v6;
      double v14 = *a1;
      double v15 = a1[2];
      double v16 = *(double *)(*v6 + 40);
      double v17 = *(double *)(*v6 + 56);
      double v18 = v17 - v16;
      if (v15 - *a1 < 360.0 && v18 < 360.0) {
        break;
      }
LABEL_12:
      if (a1[3] >= *(double *)(v13 + 48))
      {
        BOOL v24 = a1[1] <= *(double *)(v13 + 64);
        goto LABEL_15;
      }
LABEL_13:
      BOOL v24 = 0;
LABEL_15:
      double v25 = *a2;
      double v26 = a2[2];
      if (v26 - *a2 >= 360.0 || v18 >= 360.0) {
        goto LABEL_25;
      }
      double v27 = vabdd_f64(v16, v25);
      double v28 = 180.0;
      if (v27 == 180.0) {
        goto LABEL_18;
      }
      double v29 = v16 - v25;
      if (COERCE__INT64(fabs(v16 - v25)) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v47 = fabs(v27 + -180.0);
        if (v27 < 180.0) {
          double v27 = 180.0;
        }
        double v48 = v27 >= 1.0 ? v27 * 2.22044605e-16 : 2.22044605e-16;
        BOOL v42 = v47 > v48;
        double v28 = 180.0;
        if (!v42) {
          goto LABEL_18;
        }
      }
      if (v29 <= 180.0)
      {
        if (v29 < -180.0)
        {
          double v28 = fmod(v29 + -180.0, 360.0) + 180.0;
LABEL_18:
          double v29 = v28;
        }
      }
      else
      {
        double v29 = fmod(v29 + 180.0, 360.0) + -180.0;
        double v28 = 180.0;
        if (v29 == -180.0) {
          goto LABEL_18;
        }
        BOOL v49 = ((*(void *)&v29 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
           && (*(void *)&v29 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
        if (!v49 || *(void *)&v29 == 0)
        {
          double v51 = fabs(v29 + 180.0);
          double v52 = fabs(v29);
          if (v52 < 180.0) {
            double v52 = 180.0;
          }
          double v53 = v52 >= 1.0 ? v52 * 2.22044605e-16 : 2.22044605e-16;
          BOOL v42 = v51 > v53;
          double v28 = 180.0;
          if (!v42) {
            goto LABEL_18;
          }
        }
      }
      if (v29 < 0.0) {
        double v29 = v29 + 360.0;
      }
      double v30 = v25 + v29;
      double v31 = v18 + v25 + v29 + -360.0;
      if (vabdd_f64(v31, v17) < 180.0) {
        double v31 = v17;
      }
      if (v30 > v26 && v31 < v25)
      {
LABEL_27:
        if (v24)
        {
          double v33 = a4[1];
          unint64_t v32 = (unint64_t)a4[2];
          if ((unint64_t)v33 >= v32)
          {
            uint64_t v35 = ((char *)v33 - (unsigned char *)*a4) >> 3;
            if ((unint64_t)(v35 + 1) >> 61) {
              goto LABEL_139;
            }
            uint64_t v36 = v32 - (void)*a4;
            uint64_t v37 = v36 >> 2;
            if (v36 >> 2 <= (unint64_t)(v35 + 1)) {
              uint64_t v37 = v35 + 1;
            }
            if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v38 = v37;
            }
            if (v38)
            {
              unint64_t v38 = (unint64_t)sub_100048350(v38);
              uint64_t v13 = *v6;
            }
            else
            {
              uint64_t v39 = 0;
            }
            uint64_t v60 = (void *)(v38 + 8 * v35);
            void *v60 = v13;
            double v34 = v60 + 1;
            uint64_t v62 = (char *)*a4;
            uint64_t v61 = (char *)a4[1];
            if (v61 != *a4)
            {
              do
              {
                uint64_t v63 = *((void *)v61 - 1);
                v61 -= 8;
                *--uint64_t v60 = v63;
              }
              while (v61 != v62);
              uint64_t v61 = (char *)*a4;
            }
            *a4 = v60;
            a4[1] = v34;
            a4[2] = (void *)(v38 + 8 * v39);
            if (v61) {
              operator delete(v61);
            }
          }
          else
          {
            *double v33 = v13;
            double v34 = v33 + 1;
          }
          a4[1] = v34;
        }
        goto LABEL_102;
      }
LABEL_25:
      if (a2[3] < *(double *)(v13 + 48) || a2[1] > *(double *)(v13 + 64)) {
        goto LABEL_27;
      }
      if (v24)
      {
        double v55 = a6[1];
        unint64_t v54 = (unint64_t)a6[2];
        if ((unint64_t)v55 >= v54)
        {
          uint64_t v64 = ((char *)v55 - (unsigned char *)*a6) >> 3;
          if ((unint64_t)(v64 + 1) >> 61) {
            goto LABEL_139;
          }
          uint64_t v65 = v54 - (void)*a6;
          uint64_t v66 = v65 >> 2;
          if (v65 >> 2 <= (unint64_t)(v64 + 1)) {
            uint64_t v66 = v64 + 1;
          }
          if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v67 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v67 = v66;
          }
          if (v67)
          {
            unint64_t v67 = (unint64_t)sub_100048350(v67);
            uint64_t v13 = *v6;
          }
          else
          {
            uint64_t v68 = 0;
          }
          uint64_t v74 = (void *)(v67 + 8 * v64);
          *uint64_t v74 = v13;
          double v56 = v74 + 1;
          uint64_t v76 = (char *)*a6;
          uint64_t v75 = (char *)a6[1];
          if (v75 != *a6)
          {
            do
            {
              uint64_t v77 = *((void *)v75 - 1);
              v75 -= 8;
              *--uint64_t v74 = v77;
            }
            while (v75 != v76);
            uint64_t v75 = (char *)*a6;
          }
          *a6 = v74;
          a6[1] = v56;
          a6[2] = (void *)(v67 + 8 * v68);
          if (v75) {
            operator delete(v75);
          }
        }
        else
        {
          *double v55 = v13;
          double v56 = v55 + 1;
        }
        a6[1] = v56;
      }
      else
      {
        long long v58 = a5[1];
        unint64_t v57 = (unint64_t)a5[2];
        if ((unint64_t)v58 >= v57)
        {
          uint64_t v69 = ((char *)v58 - (unsigned char *)*a5) >> 3;
          if ((unint64_t)(v69 + 1) >> 61) {
LABEL_139:
          }
            sub_10006A748();
          uint64_t v70 = v57 - (void)*a5;
          uint64_t v71 = v70 >> 2;
          if (v70 >> 2 <= (unint64_t)(v69 + 1)) {
            uint64_t v71 = v69 + 1;
          }
          if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v72 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v72 = v71;
          }
          if (v72)
          {
            unint64_t v72 = (unint64_t)sub_100048350(v72);
            uint64_t v13 = *v6;
          }
          else
          {
            uint64_t v73 = 0;
          }
          uint64_t v78 = (void *)(v72 + 8 * v69);
          *uint64_t v78 = v13;
          unint64_t v59 = v78 + 1;
          int64_t v80 = (char *)*a5;
          uint64_t v79 = (char *)a5[1];
          if (v79 != *a5)
          {
            do
            {
              uint64_t v81 = *((void *)v79 - 1);
              v79 -= 8;
              *--uint64_t v78 = v81;
            }
            while (v79 != v80);
            uint64_t v79 = (char *)*a5;
          }
          *a5 = v78;
          a5[1] = v59;
          a5[2] = (void *)(v72 + 8 * v73);
          if (v79) {
            operator delete(v79);
          }
        }
        else
        {
          void *v58 = v13;
          unint64_t v59 = v58 + 1;
        }
        a5[1] = v59;
      }
LABEL_102:
      if (++v6 == a3[1]) {
        return;
      }
    }
    double v19 = vabdd_f64(v16, v14);
    double v20 = 180.0;
    if (v19 == 180.0) {
      goto LABEL_5;
    }
    double v21 = v16 - v14;
    if (COERCE__INT64(fabs(v16 - v14)) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      double v40 = fabs(v19 + -180.0);
      if (v19 < 180.0) {
        double v19 = 180.0;
      }
      double v41 = v19 >= 1.0 ? v19 * 2.22044605e-16 : 2.22044605e-16;
      BOOL v42 = v40 > v41;
      double v20 = 180.0;
      if (!v42) {
        goto LABEL_5;
      }
    }
    if (v21 <= 180.0)
    {
      if (v21 < -180.0)
      {
        double v20 = fmod(v21 + -180.0, 360.0) + 180.0;
LABEL_5:
        double v21 = v20;
      }
    }
    else
    {
      double v21 = fmod(v21 + 180.0, 360.0) + -180.0;
      double v20 = 180.0;
      if (v21 == -180.0) {
        goto LABEL_5;
      }
      BOOL v42 = ((*(void *)&v21 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
         && (*(void *)&v21 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
      if (!v42 || *(void *)&v21 == 0)
      {
        double v44 = fabs(v21 + 180.0);
        double v45 = fabs(v21);
        if (v45 < 180.0) {
          double v45 = 180.0;
        }
        double v46 = v45 >= 1.0 ? v45 * 2.22044605e-16 : 2.22044605e-16;
        BOOL v42 = v44 > v46;
        double v20 = 180.0;
        if (!v42) {
          goto LABEL_5;
        }
      }
    }
    if (v21 < 0.0) {
      double v21 = v21 + 360.0;
    }
    double v22 = v14 + v21;
    double v23 = v18 + v14 + v21 + -360.0;
    if (vabdd_f64(v23, v17) < 180.0) {
      double v23 = v17;
    }
    if (v22 > v15 && v23 < v14) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
}

void sub_101258EA4(double *a1, uint64_t **a2, unint64_t a3, uint64_t a4)
{
  double v6 = (a1[1] + a1[3]) * 0.5;
  uint64_t v50 = *((void *)a1 + 2);
  long long v7 = *(_OWORD *)a1;
  long long v8 = *((_OWORD *)a1 + 1);
  v47[0] = *a1;
  long long v48 = v8;
  long long v49 = v7;
  double v51 = v6;
  v47[1] = v6;
  double v44 = 0;
  double v45 = 0;
  uint64_t v46 = 0;
  double v41 = 0;
  BOOL v42 = 0;
  uint64_t v43 = 0;
  unint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  sub_1012588B0((double *)&v49, v47, a2, (void **)&v44, (void **)&v41, (void **)&v38);
  double v9 = v38;
  double v10 = v39;
  if (v38 != v39)
  {
    int64x2_t v52 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    int64x2_t v53 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    double v11 = v38;
    do
      sub_101240044((double *)v52.i64, (double *)(*v11++ + 40));
    while (v11 != v10);
    v37[0] = v52;
    v37[1] = v53;
    unint64_t v12 = (char *)v10 - (char *)v9;
    uint64_t v13 = v9;
    if (a3 > 0x63 || (uint64_t v13 = v9, v12 <= 0x78))
    {
      do
      {
        double v15 = v13 + 1;
        if (v13 + 1 == v10) {
          break;
        }
        double v14 = v13 + 1;
        do
          sub_101258348(a4, *v13, *v14++);
        while (v14 != v10);
        ++v13;
      }
      while (v15 != v10);
    }
    else
    {
      sub_101257F40(v37, &v38, a3 + 1, a4);
    }
    if (v12 < 0x80 || a3 > 0x63 || (unint64_t)((char *)v45 - (char *)v44) < 0x79)
    {
      double v16 = v44;
      double v17 = v45;
      if (v44 != v45)
      {
        double v18 = v45;
        double v19 = v9;
        do
        {
          BOOL v20 = v16 == v18;
          double v18 = v16;
          if (!v20)
          {
            double v21 = v16;
            do
              sub_101258348(a4, *v19, *v21++);
            while (v21 != v17);
            double v18 = v17;
          }
          ++v19;
        }
        while (v19 != v10);
      }
    }
    else
    {
      sub_1012592B4((double *)v37, &v38, &v44, a3 + 1, a4);
    }
    if (v12 < 0x80 || a3 > 0x63 || (unint64_t)((char *)v42 - (char *)v41) < 0x79)
    {
      if (v9 != v10)
      {
        double v22 = v41;
        double v23 = v42;
        if (v41 != v42)
        {
          BOOL v24 = v42;
          double v25 = v9;
          do
          {
            BOOL v20 = v22 == v24;
            BOOL v24 = v22;
            if (!v20)
            {
              double v26 = v22;
              do
                sub_101258348(a4, *v25, *v26++);
              while (v26 != v23);
              BOOL v24 = v23;
            }
            ++v25;
          }
          while (v25 != v10);
        }
      }
    }
    else
    {
      sub_1012592B4((double *)v37, &v38, &v41, a3 + 1, a4);
    }
  }
  double v27 = v44;
  double v28 = v45;
  if (a3 > 0x63 || (unint64_t)((char *)v45 - (char *)v44) < 0x79)
  {
    if (v44 != v45)
    {
      double v29 = v44;
      do
      {
        double v30 = v29 + 1;
        if (v29 + 1 == v28) {
          break;
        }
        double v31 = v29 + 1;
        do
          sub_101258348(a4, *v29, *v31++);
        while (v31 != v28);
        ++v29;
      }
      while (v30 != v28);
    }
  }
  else
  {
    sub_101257F40(&v49, &v44, a3 + 1, a4);
  }
  unint64_t v32 = v41;
  double v33 = v42;
  if (a3 > 0x63 || (unint64_t)((char *)v42 - (char *)v41) < 0x79)
  {
    if (v41 != v42)
    {
      double v34 = v41;
      do
      {
        uint64_t v35 = v34 + 1;
        if (v34 + 1 == v33) {
          break;
        }
        uint64_t v36 = v34 + 1;
        do
          sub_101258348(a4, *v34, *v36++);
        while (v36 != v33);
        ++v34;
      }
      while (v35 != v33);
    }
  }
  else
  {
    sub_101257F40(v47, &v41, a3 + 1, a4);
  }
  if (v9) {
    operator delete(v9);
  }
  if (v32) {
    operator delete(v32);
  }
  if (v27)
  {
    operator delete(v27);
  }
}

void sub_101259260(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20)
{
  if (v20) {
    operator delete(v20);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_1012592B4(double *a1, uint64_t **a2, uint64_t **a3, unint64_t a4, uint64_t a5)
{
  double v8 = (*a1 + a1[2]) * 0.5;
  long long v9 = *((_OWORD *)a1 + 1);
  long long v81 = *(_OWORD *)a1;
  uint64_t v83 = *((void *)&v9 + 1);
  v79[1] = *((double *)&v81 + 1);
  long long v80 = v9;
  double v82 = v8;
  v79[0] = v8;
  uint64_t v76 = 0;
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  uint64_t v73 = 0;
  uint64_t v74 = 0;
  uint64_t v75 = 0;
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  unint64_t v67 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  long long __p = 0;
  uint64_t v65 = 0;
  uint64_t v66 = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  sub_1012588B0((double *)&v81, v79, a2, (void **)&v76, (void **)&v73, (void **)&v70);
  sub_1012588B0((double *)&v81, v79, a3, &v67, &__p, (void **)&v61);
  double v11 = v70;
  double v10 = v71;
  unint64_t v12 = v61;
  long long v58 = v70;
  if (v70 == v71)
  {
    double v14 = v62;
  }
  else
  {
    unint64_t v13 = (char *)v71 - (char *)v70;
    double v14 = v62;
    if ((unint64_t)((char *)v71 - (char *)v70) < 0x80
      || a4 > 0x63
      || (unint64_t)((char *)v62 - (char *)v61) < 0x79)
    {
      if (v61 != v62)
      {
        double v15 = v62;
        double v16 = v70;
        do
        {
          BOOL v42 = v12 == v15;
          double v15 = v12;
          if (!v42)
          {
            double v17 = v12;
            do
              sub_101258348(a5, *v16, *v17++);
            while (v17 != v14);
            double v15 = v14;
          }
          ++v16;
        }
        while (v16 != v10);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      do
        sub_101240044((double *)v84.i64, (double *)(*v11++ + 40));
      while (v11 != v10);
      uint64_t v19 = v84.i64[1];
      uint64_t v18 = v84.i64[0];
      uint64_t v21 = v85.i64[1];
      uint64_t v20 = v85.i64[0];
      if (v12 != v14)
      {
        double v22 = v12;
        do
          sub_101240044((double *)v84.i64, (double *)(*v22++ + 40));
        while (v22 != v14);
        uint64_t v19 = v84.i64[1];
        uint64_t v18 = v84.i64[0];
        uint64_t v21 = v85.i64[1];
        uint64_t v20 = v85.i64[0];
      }
      v59.i64[0] = v18;
      v59.i64[1] = v19;
      v60.i64[0] = v20;
      v60.i64[1] = v21;
      sub_10125997C((double *)v59.i64, &v70, &v61, a4 + 1, a5);
    }
    BOOL v24 = (uint64_t *)v67;
    double v23 = v68;
    if ((unint64_t)((char *)v68 - (unsigned char *)v67) < 0x80
      || (unint64_t)((char *)v65 - (unsigned char *)__p) < 0x80
      || a4 > 0x63
      || v13 < 0x79)
    {
      if (v67 != v68)
      {
        double v25 = v68;
        double v26 = v58;
        do
        {
          BOOL v42 = v24 == v25;
          double v25 = v24;
          if (!v42)
          {
            double v27 = v24;
            do
              sub_101258348(a5, *v26, *v27++);
            while (v27 != v23);
            double v25 = v23;
          }
          ++v26;
        }
        while (v26 != v10);
      }
      double v28 = (uint64_t *)__p;
      double v29 = v65;
      if (__p != v65)
      {
        double v30 = v65;
        double v31 = v58;
        do
        {
          BOOL v42 = v28 == v30;
          double v30 = v28;
          if (!v42)
          {
            unint64_t v32 = v28;
            do
              sub_101258348(a5, *v31, *v32++);
            while (v32 != v29);
            double v30 = v29;
          }
          ++v31;
        }
        while (v31 != v10);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      unint64_t v57 = v58;
      do
        sub_101240044((double *)v84.i64, (double *)(*v57++ + 40));
      while (v57 != v10);
      int64x2_t v59 = v84;
      int64x2_t v60 = v85;
      sub_10125997C((double *)v59.i64, &v70, (uint64_t **)&v67, a4 + 1, a5);
      sub_10125997C((double *)v59.i64, &v70, (uint64_t **)&__p, a4 + 1, a5);
    }
  }
  double v33 = v76;
  double v34 = v77;
  unint64_t v35 = (char *)v77 - (char *)v76;
  if (v12 != v14)
  {
    if (v35 < 0x80
      || (unint64_t)((char *)v74 - (char *)v73) < 0x80
      || a4 > 0x63
      || (unint64_t)((char *)v14 - (char *)v12) < 0x79)
    {
      if (v76 != v77)
      {
        uint64_t v37 = v14;
        unint64_t v38 = v76;
        do
        {
          BOOL v42 = v12 == v37;
          uint64_t v37 = v12;
          if (!v42)
          {
            uint64_t v39 = v12;
            do
              sub_101258348(a5, *v38, *v39++);
            while (v39 != v14);
            uint64_t v37 = v14;
          }
          ++v38;
        }
        while (v38 != v34);
      }
      uint64_t v40 = v73;
      double v41 = v74;
      BOOL v42 = v73 == v74 || v12 == v14;
      if (!v42)
      {
        uint64_t v43 = v14;
        do
        {
          BOOL v42 = v12 == v43;
          uint64_t v43 = v12;
          if (!v42)
          {
            double v44 = v12;
            do
              sub_101258348(a5, *v40, *v44++);
            while (v44 != v14);
            uint64_t v43 = v14;
          }
          ++v40;
        }
        while (v40 != v41);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      uint64_t v36 = v12;
      do
        sub_101240044((double *)v84.i64, (double *)(*v36++ + 40));
      while (v36 != v14);
      int64x2_t v59 = v84;
      int64x2_t v60 = v85;
      sub_10125997C((double *)v59.i64, &v76, &v61, a4 + 1, a5);
      sub_10125997C((double *)v59.i64, &v73, &v61, a4 + 1, a5);
    }
  }
  if (v35 < 0x80 || a4 > 0x63 || (unint64_t)((char *)v68 - (unsigned char *)v67) < 0x79)
  {
    if (v33 != v34)
    {
      double v45 = (uint64_t *)v67;
      uint64_t v46 = v68;
      if (v67 != v68)
      {
        double v47 = v68;
        long long v48 = v33;
        do
        {
          BOOL v42 = v45 == v47;
          double v47 = v45;
          if (!v42)
          {
            long long v49 = v45;
            do
              sub_101258348(a5, *v48, *v49++);
            while (v49 != v46);
            double v47 = v46;
          }
          ++v48;
        }
        while (v48 != v34);
      }
    }
  }
  else
  {
    sub_10125997C((double *)&v81, &v76, (uint64_t **)&v67, a4 + 1, a5);
  }
  uint64_t v50 = v73;
  double v51 = v74;
  if ((unint64_t)((char *)v74 - (char *)v73) < 0x80
    || a4 > 0x63
    || (unint64_t)((char *)v65 - (unsigned char *)__p) < 0x79)
  {
    if (v73 != v74)
    {
      int64x2_t v52 = (uint64_t *)__p;
      int64x2_t v53 = v65;
      if (__p != v65)
      {
        unint64_t v54 = v65;
        double v55 = v73;
        do
        {
          BOOL v42 = v52 == v54;
          unint64_t v54 = v52;
          if (!v42)
          {
            double v56 = v52;
            do
              sub_101258348(a5, *v55, *v56++);
            while (v56 != v53);
            unint64_t v54 = v53;
          }
          ++v55;
        }
        while (v55 != v51);
      }
    }
  }
  else
  {
    sub_10125997C(v79, &v73, (uint64_t **)&__p, a4 + 1, a5);
  }
  if (v12) {
    operator delete(v12);
  }
  if (__p) {
    operator delete(__p);
  }
  if (v67) {
    operator delete(v67);
  }
  if (v58) {
    operator delete(v58);
  }
  if (v50) {
    operator delete(v50);
  }
  if (v33)
  {
    operator delete(v33);
  }
}

void sub_1012598E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30)
{
  if (v30) {
    operator delete(v30);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a24) {
    operator delete(a24);
  }
  if (a27) {
    operator delete(a27);
  }
  if (a30) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

void sub_10125997C(double *a1, uint64_t **a2, uint64_t **a3, unint64_t a4, uint64_t a5)
{
  double v8 = a1[1] + a1[3];
  long long v81 = *(_OWORD *)a1;
  uint64_t v82 = *((void *)a1 + 2);
  long long v9 = *((_OWORD *)a1 + 1);
  *(void *)&v79[0] = v81;
  long long v80 = v9;
  double v83 = v8 * 0.5;
  v79[1] = v8 * 0.5;
  uint64_t v76 = 0;
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  uint64_t v73 = 0;
  uint64_t v74 = 0;
  uint64_t v75 = 0;
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  unint64_t v67 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  long long __p = 0;
  uint64_t v65 = 0;
  uint64_t v66 = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  sub_1012588B0((double *)&v81, v79, a2, (void **)&v76, (void **)&v73, (void **)&v70);
  sub_1012588B0((double *)&v81, v79, a3, &v67, &__p, (void **)&v61);
  double v11 = v70;
  double v10 = v71;
  unint64_t v12 = v61;
  long long v58 = v70;
  if (v70 == v71)
  {
    double v14 = v62;
  }
  else
  {
    unint64_t v13 = (char *)v71 - (char *)v70;
    double v14 = v62;
    if ((unint64_t)((char *)v71 - (char *)v70) < 0x80
      || a4 > 0x63
      || (unint64_t)((char *)v62 - (char *)v61) < 0x79)
    {
      if (v61 != v62)
      {
        double v15 = v62;
        double v16 = v70;
        do
        {
          BOOL v42 = v12 == v15;
          double v15 = v12;
          if (!v42)
          {
            double v17 = v12;
            do
              sub_101258348(a5, *v16, *v17++);
            while (v17 != v14);
            double v15 = v14;
          }
          ++v16;
        }
        while (v16 != v10);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      do
        sub_101240044((double *)v84.i64, (double *)(*v11++ + 40));
      while (v11 != v10);
      uint64_t v19 = v84.i64[1];
      uint64_t v18 = v84.i64[0];
      uint64_t v21 = v85.i64[1];
      uint64_t v20 = v85.i64[0];
      if (v12 != v14)
      {
        double v22 = v12;
        do
          sub_101240044((double *)v84.i64, (double *)(*v22++ + 40));
        while (v22 != v14);
        uint64_t v19 = v84.i64[1];
        uint64_t v18 = v84.i64[0];
        uint64_t v21 = v85.i64[1];
        uint64_t v20 = v85.i64[0];
      }
      v59.i64[0] = v18;
      v59.i64[1] = v19;
      v60.i64[0] = v20;
      v60.i64[1] = v21;
      sub_1012592B4(&v59, &v70, &v61, a4 + 1, a5);
    }
    BOOL v24 = (uint64_t *)v67;
    double v23 = v68;
    if ((unint64_t)((char *)v68 - (unsigned char *)v67) < 0x80
      || (unint64_t)((char *)v65 - (unsigned char *)__p) < 0x80
      || a4 > 0x63
      || v13 < 0x79)
    {
      if (v67 != v68)
      {
        double v25 = v68;
        double v26 = v58;
        do
        {
          BOOL v42 = v24 == v25;
          double v25 = v24;
          if (!v42)
          {
            double v27 = v24;
            do
              sub_101258348(a5, *v26, *v27++);
            while (v27 != v23);
            double v25 = v23;
          }
          ++v26;
        }
        while (v26 != v10);
      }
      double v28 = (uint64_t *)__p;
      double v29 = v65;
      if (__p != v65)
      {
        double v30 = v65;
        double v31 = v58;
        do
        {
          BOOL v42 = v28 == v30;
          double v30 = v28;
          if (!v42)
          {
            unint64_t v32 = v28;
            do
              sub_101258348(a5, *v31, *v32++);
            while (v32 != v29);
            double v30 = v29;
          }
          ++v31;
        }
        while (v31 != v10);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      unint64_t v57 = v58;
      do
        sub_101240044((double *)v84.i64, (double *)(*v57++ + 40));
      while (v57 != v10);
      int64x2_t v59 = v84;
      int64x2_t v60 = v85;
      sub_1012592B4(&v59, &v70, &v67, a4 + 1, a5);
      sub_1012592B4(&v59, &v70, &__p, a4 + 1, a5);
    }
  }
  double v33 = v76;
  double v34 = v77;
  unint64_t v35 = (char *)v77 - (char *)v76;
  if (v12 != v14)
  {
    if (v35 < 0x80
      || (unint64_t)((char *)v74 - (char *)v73) < 0x80
      || a4 > 0x63
      || (unint64_t)((char *)v14 - (char *)v12) < 0x79)
    {
      if (v76 != v77)
      {
        uint64_t v37 = v14;
        unint64_t v38 = v76;
        do
        {
          BOOL v42 = v12 == v37;
          uint64_t v37 = v12;
          if (!v42)
          {
            uint64_t v39 = v12;
            do
              sub_101258348(a5, *v38, *v39++);
            while (v39 != v14);
            uint64_t v37 = v14;
          }
          ++v38;
        }
        while (v38 != v34);
      }
      uint64_t v40 = v73;
      double v41 = v74;
      BOOL v42 = v73 == v74 || v12 == v14;
      if (!v42)
      {
        uint64_t v43 = v14;
        do
        {
          BOOL v42 = v12 == v43;
          uint64_t v43 = v12;
          if (!v42)
          {
            double v44 = v12;
            do
              sub_101258348(a5, *v40, *v44++);
            while (v44 != v14);
            uint64_t v43 = v14;
          }
          ++v40;
        }
        while (v40 != v41);
      }
    }
    else
    {
      int64x2_t v84 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      int64x2_t v85 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      uint64_t v36 = v12;
      do
        sub_101240044((double *)v84.i64, (double *)(*v36++ + 40));
      while (v36 != v14);
      int64x2_t v59 = v84;
      int64x2_t v60 = v85;
      sub_1012592B4(&v59, &v76, &v61, a4 + 1, a5);
      sub_1012592B4(&v59, &v73, &v61, a4 + 1, a5);
    }
  }
  if (v35 < 0x80 || a4 > 0x63 || (unint64_t)((char *)v68 - (unsigned char *)v67) < 0x79)
  {
    if (v33 != v34)
    {
      double v45 = (uint64_t *)v67;
      uint64_t v46 = v68;
      if (v67 != v68)
      {
        double v47 = v68;
        long long v48 = v33;
        do
        {
          BOOL v42 = v45 == v47;
          double v47 = v45;
          if (!v42)
          {
            long long v49 = v45;
            do
              sub_101258348(a5, *v48, *v49++);
            while (v49 != v46);
            double v47 = v46;
          }
          ++v48;
        }
        while (v48 != v34);
      }
    }
  }
  else
  {
    sub_1012592B4(&v81, &v76, &v67, a4 + 1, a5);
  }
  uint64_t v50 = v73;
  double v51 = v74;
  if ((unint64_t)((char *)v74 - (char *)v73) < 0x80
    || a4 > 0x63
    || (unint64_t)((char *)v65 - (unsigned char *)__p) < 0x79)
  {
    if (v73 != v74)
    {
      int64x2_t v52 = (uint64_t *)__p;
      int64x2_t v53 = v65;
      if (__p != v65)
      {
        unint64_t v54 = v65;
        double v55 = v73;
        do
        {
          BOOL v42 = v52 == v54;
          unint64_t v54 = v52;
          if (!v42)
          {
            double v56 = v52;
            do
              sub_101258348(a5, *v55, *v56++);
            while (v56 != v53);
            unint64_t v54 = v53;
          }
          ++v55;
        }
        while (v55 != v51);
      }
    }
  }
  else
  {
    sub_1012592B4(v79, &v73, &__p, a4 + 1, a5);
  }
  if (v12) {
    operator delete(v12);
  }
  if (__p) {
    operator delete(__p);
  }
  if (v67) {
    operator delete(v67);
  }
  if (v58) {
    operator delete(v58);
  }
  if (v50) {
    operator delete(v50);
  }
  if (v33)
  {
    operator delete(v33);
  }
}

void sub_101259FBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30)
{
  if (v30) {
    operator delete(v30);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a24) {
    operator delete(a24);
  }
  if (a27) {
    operator delete(a27);
  }
  if (a30) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10125A050(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v11 = *a2;
  if (*a2 != 2)
  {
    if (v11 == 1)
    {
      uint64_t v12 = a2[2];
      if (v12 >= -1)
      {
        uint64_t v13 = *(void *)(a5 + 24);
        unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a5 + 32) - v13) >> 3);
        if (v12 < (int)v14)
        {
          double v15 = (double **)a5;
          if (v12 < 0)
          {
LABEL_16:
            return sub_10125A228(a1, v15, a3, a4, a5, a6);
          }
          goto LABEL_14;
        }
      }
    }
    else
    {
      if (v11) {
        return 0;
      }
      uint64_t v12 = a2[2];
      if (v12 >= -1)
      {
        uint64_t v13 = *(void *)(a4 + 24);
        unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a4 + 32) - v13) >> 3);
        if (v12 < (int)v14)
        {
          double v15 = (double **)a4;
          if (v12 < 0) {
            goto LABEL_16;
          }
LABEL_14:
          if (v14 >= v12)
          {
            double v15 = (double **)(v13 + 24 * v12);
            goto LABEL_16;
          }
LABEL_24:
          __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
        }
      }
    }
    __assert_rtn("apply", "get_ring.hpp", 94, "id.ring_index >= -1 && id.ring_index < int(boost::size(interior_rings(polygon)))");
  }
  unint64_t v16 = a2[1];
  if (a6[5] < v16) {
    goto LABEL_24;
  }
  unint64_t v17 = a6[4];
  uint64_t v18 = a6[1];
  uint64_t v19 = (void *)(v18 + 8 * (v17 / 0xAA));
  if (a6[2] == v18) {
    uint64_t v20 = 0;
  }
  else {
    uint64_t v20 = (double **)(*v19 + 24 * (v17 % 0xAA));
  }
  double v22 = v19;
  double v23 = v20;
  sub_10119ECB0(&v22, v16);
  return sub_10125A228(a1, v23, a3, a4, a5, a6);
}

BOOL sub_10125A228(uint64_t a1, double **a2, uint64_t *a3, uint64_t a4, uint64_t a5, void *a6)
{
  double v6 = a2;
  uint64_t v7 = *a3;
  if (*a3 == 2)
  {
    unint64_t v13 = a3[1];
    if (a6[5] >= v13)
    {
      unint64_t v14 = (double *)(a1 + 8);
      unint64_t v15 = a6[4];
      uint64_t v16 = a6[1];
      unint64_t v17 = (void *)(v16 + 8 * (v15 / 0xAA));
      if (a6[2] == v16) {
        unint64_t v18 = 0;
      }
      else {
        unint64_t v18 = *v17 + 24 * (v15 % 0xAA);
      }
      double v23 = v17;
      BOOL v24 = (double **)v18;
      sub_10119ECB0(&v23, v13);
      uint64_t v12 = v24;
      uint64_t v11 = v14;
      a2 = v6;
      return (int)sub_10125A3C8(v11, a2, v12) >= 0;
    }
    goto LABEL_25;
  }
  if (v7 == 1)
  {
    uint64_t v19 = a3[2];
    if (v19 >= -1)
    {
      uint64_t v20 = *(void *)(a5 + 24);
      unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a5 + 32) - v20) >> 3);
      if (v19 < (int)v21)
      {
        if ((v19 & 0x8000000000000000) == 0)
        {
          if (v21 < v19) {
            goto LABEL_25;
          }
          a5 = v20 + 24 * v19;
        }
        uint64_t v11 = (double *)(a1 + 8);
        uint64_t v12 = (double **)a5;
        return (int)sub_10125A3C8(v11, a2, v12) >= 0;
      }
    }
LABEL_24:
    __assert_rtn("apply", "get_ring.hpp", 94, "id.ring_index >= -1 && id.ring_index < int(boost::size(interior_rings(polygon)))");
  }
  if (v7) {
    return 0;
  }
  uint64_t v8 = a3[2];
  if (v8 < -1) {
    goto LABEL_24;
  }
  uint64_t v9 = *(void *)(a4 + 24);
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a4 + 32) - v9) >> 3);
  if (v8 >= (int)v10) {
    goto LABEL_24;
  }
  if ((v8 & 0x8000000000000000) == 0)
  {
    if (v10 >= v8)
    {
      a4 = v9 + 24 * v8;
      goto LABEL_9;
    }
LABEL_25:
    __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
  }
LABEL_9:
  uint64_t v11 = (double *)(a1 + 8);
  uint64_t v12 = (double **)a4;
  return (int)sub_10125A3C8(v11, a2, v12) >= 0;
}

uint64_t sub_10125A3C8(double *a1, double **a2, double **a3)
{
  uint64_t v3 = *a3;
  double v4 = a3[1];
  if ((unint64_t)((char *)v4 - (char *)*a3) < 0x40) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  int v19 = 0;
  if (v3 + 2 == v4) {
    return 0xFFFFFFFFLL;
  }
  do
  {
    if (!sub_10124A3D0(a1, v3, v3 + 2, (uint64_t)&v17)) {
      break;
    }
    uint64_t v8 = v3 + 4;
    v3 += 2;
  }
  while (v8 != v4);
  if ((_BYTE)v19)
  {
    uint64_t v9 = *a2;
    unint64_t v10 = a2[1];
    if (*a2 == v10) {
      return 0;
    }
    uint64_t v11 = v9 + 2;
    if (v9 + 2 == v10) {
      return 0;
    }
    while (1)
    {
      uint64_t v12 = *a3;
      unint64_t v13 = a3[1];
      if ((unint64_t)((char *)v13 - (char *)*a3) < 0x40) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      int v19 = 0;
      if (v12 + 2 == v13) {
        return 0xFFFFFFFFLL;
      }
      do
      {
        if (!sub_10124A3D0(v11, v12, v12 + 2, (uint64_t)&v17)) {
          break;
        }
        unint64_t v14 = v12 + 4;
        v12 += 2;
      }
      while (v14 != v13);
      if (!(_BYTE)v19) {
        break;
      }
      uint64_t result = 0;
      v11 += 2;
      if (v11 == v10) {
        return result;
      }
    }
  }
  if (!v18 || !HIDWORD(v18))
  {
    if (v17) {
      return 1;
    }
    return 0xFFFFFFFFLL;
  }
  if ((int)v18 < 1) {
    BOOL v16 = v17 == 0;
  }
  else {
    BOOL v16 = v17 + HIDWORD(v17) == 0;
  }
  if (v16) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 1;
  }
}

char *sub_10125A534(char *result, uint64_t a2, uint64_t a3, void *a4, uint64_t *a5, int a6, char a7)
{
  uint64_t v9 = result;
  uint64_t v10 = *a5;
  if (*a5 != 2)
  {
    if (v10 == 1)
    {
      uint64_t v19 = a5[2];
      if (v19 >= -1)
      {
        uint64_t v20 = *(void *)(a3 + 24);
        unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a3 + 32) - v20) >> 3);
        if (v19 < (int)v21)
        {
          if ((v19 & 0x8000000000000000) == 0)
          {
            if (v21 < v19) {
              goto LABEL_26;
            }
            a3 = v20 + 24 * v19;
          }
          a2 = a3;
LABEL_19:
          return sub_10125A6F0(result, a2, a7, a6);
        }
      }
    }
    else
    {
      if (v10) {
        return result;
      }
      uint64_t v11 = a5[2];
      if (v11 >= -1)
      {
        uint64_t v12 = *(void *)(a2 + 24);
        unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a2 + 32) - v12) >> 3);
        if (v11 < (int)v13)
        {
          if ((v11 & 0x8000000000000000) == 0)
          {
            if (v13 >= v11)
            {
              a2 = v12 + 24 * v11;
              goto LABEL_19;
            }
LABEL_26:
            __assert_rtn("pos", "range.hpp", 96, "i <= boost::size(rng)");
          }
          goto LABEL_19;
        }
      }
    }
    __assert_rtn("apply", "get_ring.hpp", 94, "id.ring_index >= -1 && id.ring_index < int(boost::size(interior_rings(polygon)))");
  }
  unint64_t v14 = a5[1];
  if (a4[5] < v14) {
    goto LABEL_26;
  }
  unint64_t v15 = a4[4];
  uint64_t v16 = a4[1];
  uint64_t v17 = (void *)(v16 + 8 * (v15 / 0xAA));
  if (a4[2] == v16) {
    unint64_t v18 = 0;
  }
  else {
    unint64_t v18 = *v17 + 24 * (v15 % 0xAA);
  }
  double v22 = v17;
  unint64_t v23 = v18;
  sub_10119ECB0(&v22, v14);
  return sub_10125A6F0(v9, v23, a7, a6);
}

char *sub_10125A6F0(char *result, uint64_t a2, char a3, int a4)
{
  double v6 = result;
  if (a3)
  {
    if (*(void *)(a2 + 8) - *(void *)a2 >= 0x31uLL)
    {
      uint64_t v8 = *((void *)result + 3);
      uint64_t v7 = (void *)*((void *)result + 4);
      unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - v8) >> 3);
      unint64_t v10 = v9 + 1;
      if ((void *)((char *)v7 - v8) == (void *)-24)
      {
        uint64_t v11 = (void *)(v8 + 24 * v10);
        if (v7 != v11)
        {
          uint64_t v12 = (void *)*((void *)result + 4);
          do
          {
            unint64_t v14 = (void *)*(v12 - 3);
            v12 -= 3;
            unint64_t v13 = v14;
            if (v14)
            {
              *(v7 - 2) = v13;
              operator delete(v13);
            }
            uint64_t v7 = v12;
          }
          while (v12 != v11);
        }
        *((void *)v6 + 4) = v11;
      }
      else
      {
        double v22 = (void *)*((void *)result + 5);
        if (v22 == v7)
        {
          if (v10 > 0xAAAAAAAAAAAAAAALL) {
            sub_10006A748();
          }
          unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v22 - v8) >> 3);
          if (2 * v23 > v10) {
            unint64_t v10 = 2 * v23;
          }
          if (v23 >= 0x555555555555555) {
            unint64_t v24 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v24 = v10;
          }
          double v25 = (char *)sub_100601864(v24);
          double v26 = &v25[24 * v9];
          double v28 = &v25[24 * v27];
          *((void *)v26 + 1) = 0;
          *((void *)v26 + 2) = 0;
          *(void *)double v26 = 0;
          double v29 = v26 + 24;
          double v30 = (void *)*((void *)v6 + 3);
          double v31 = (void *)*((void *)v6 + 4);
          if (v31 == v30)
          {
            *((void *)v6 + 3) = v26;
            *((void *)v6 + 4) = v29;
            *((void *)v6 + 5) = v28;
          }
          else
          {
            do
            {
              *((void *)v26 - 3) = 0;
              *((void *)v26 - 2) = 0;
              v26 -= 24;
              *((void *)v26 + 2) = 0;
              long long v32 = *(_OWORD *)(v31 - 3);
              v31 -= 3;
              *(_OWORD *)double v26 = v32;
              *((void *)v26 + 2) = v31[2];
              void *v31 = 0;
              v31[1] = 0;
              v31[2] = 0;
            }
            while (v31 != v30);
            double v31 = (void *)*((void *)v6 + 3);
            double v33 = (void *)*((void *)v6 + 4);
            *((void *)v6 + 3) = v26;
            *((void *)v6 + 4) = v29;
            *((void *)v6 + 5) = v28;
            if (v33 != v31)
            {
              double v34 = v33;
              do
              {
                uint64_t v36 = (void *)*(v34 - 3);
                v34 -= 3;
                unint64_t v35 = v36;
                if (v36)
                {
                  *(v33 - 2) = v35;
                  operator delete(v35);
                }
                double v33 = v34;
              }
              while (v34 != v31);
            }
          }
          if (v31) {
            operator delete(v31);
          }
        }
        else
        {
          void *v7 = 0;
          v7[1] = 0;
          v7[2] = 0;
          *((void *)result + 4) = v7 + 3;
        }
      }
      uint64_t result = (char *)(*((void *)v6 + 4) - 24);
      if (result != (char *)a2) {
        uint64_t result = sub_10125A988(result, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
      }
      if (a4)
      {
        uint64_t v37 = *((void *)v6 + 4);
        unint64_t v38 = *(void *)(v37 - 24);
        uint64_t v39 = *(void *)(v37 - 16);
        uint64_t v40 = (_OWORD *)(v39 - 16);
        if (v38 != v39 && (unint64_t)v40 > v38)
        {
          unint64_t v42 = v38 + 16;
          do
          {
            long long v43 = *(_OWORD *)(v42 - 16);
            *(_OWORD *)(v42 - 16) = *v40;
            *v40-- = v43;
            BOOL v21 = v42 >= (unint64_t)v40;
            v42 += 16;
          }
          while (!v21);
        }
      }
    }
  }
  else
  {
    if (result != (char *)a2) {
      uint64_t result = sub_10125A988(result, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
    }
    if (a4)
    {
      unint64_t v15 = *(void *)v6;
      uint64_t v16 = *((void *)v6 + 1);
      uint64_t v17 = (_OWORD *)(v16 - 16);
      if (*(void *)v6 != v16 && (unint64_t)v17 > v15)
      {
        unint64_t v19 = v15 + 16;
        do
        {
          long long v20 = *(_OWORD *)(v19 - 16);
          *(_OWORD *)(v19 - 16) = *v17;
          *v17-- = v20;
          BOOL v21 = v19 >= (unint64_t)v17;
          v19 += 16;
        }
        while (!v21);
      }
    }
  }
  return result;
}

char *sub_10125A988(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60) {
      sub_10006A748();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = sub_100A61D48(v7, v11);
    unint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    unint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unint64_t v18 = v9;
      unint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  unint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    unint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unint64_t v18 = v9;
    unint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

void *sub_10125AA90(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_101252B54(a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  uint64_t v4 = *(void *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 32);
  if (v5 != v4)
  {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v5 - v4) >> 3);
    if (v6 >= 0xAAAAAAAAAAAAAABLL) {
      sub_10006A748();
    }
    uint64_t v7 = sub_100601864(v6);
    a1[5] = &v7[3 * v8];
    a1[3] = v7;
    a1[4] = v7;
    unint64_t v13 = v7;
    unint64_t v14 = v7;
    v11[0] = a1 + 5;
    v11[1] = &v13;
    v11[2] = &v14;
    uint64_t v12 = 0;
    unint64_t v9 = v7;
    do
    {
      *unint64_t v9 = 0;
      v9[1] = 0;
      v9[2] = 0;
      sub_101252B54(v9, *(const void **)v4, *(void *)(v4 + 8), (uint64_t)(*(void *)(v4 + 8) - *(void *)v4) >> 4);
      unint64_t v9 = v14 + 3;
      v14 += 3;
      v4 += 24;
    }
    while (v4 != v5);
    LOBYTE(v12) = 1;
    sub_10011FF2C((uint64_t)v11);
    a1[4] = v9;
  }
  return a1;
}

void sub_10125ABB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_101232E40(&a9);
  unint64_t v11 = *(void **)v9;
  if (*(void *)v9)
  {
    *(void *)(v9 + 8) = v11;
    operator delete(v11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10125ABEC(uint64_t a1)
{
  double v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      double v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 8;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 16;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10125ACB4(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        unint64_t v5 = (uint64_t *)v3[1];
        sub_101233F4C((uint64_t)(v3 + 2));
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void *sub_10125AD28(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_1004D669C(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_10125AD88(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10125ADA4(uint64_t a1)
{
  char v2 = sub_100810848(a1);
  BOOL result = 1;
  if ((v2 & 1) == 0)
  {
    char v13 = 1;
    uint64_t v4 = sub_100365D74();
    sub_100058DB0(__p, "EnableThumperByDefault");
    BOOL v5 = sub_1002260B0(v4, __p, (BOOL *)&v13);
    BOOL v6 = v5;
    if (v12 < 0)
    {
      operator delete(__p[0]);
      if (v6) {
        goto LABEL_4;
      }
    }
    else if (v5)
    {
LABEL_4:
      int v7 = v13;
      return v7 != 0;
    }
    (*(void (**)(void **__return_ptr))(**(void **)(a1 + 160) + 472))(__p);
    size_t v8 = (BOOL *)__p[0];
    int v7 = 1;
    unsigned __int8 v14 = 1;
    if (__p[0])
    {
      CFTypeID v9 = CFGetTypeID(__p[0]);
      if (v9 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)&v14, v8, v10);
        int v7 = v14;
      }
      else
      {
        int v7 = 1;
      }
    }
    sub_1000577C4((const void **)__p);
    return v7 != 0;
  }
  return result;
}

void sub_10125AEBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void getAssociatedID(void *a1@<X8>)
{
  sub_1003A9CA0(v2);
  CFTypeRef v4 = sub_1003A9B04(*(uint64_t *)v2, @"associated.account", 0);
  sub_100225AE0(a1, &v4);
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_10125AF4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void setAssociatedID(const __CFString *a1)
{
  sub_1003A9CA0(&v3);
  sub_1003A9C3C(v3, @"associated.account", a1);
  char v2 = v4;
  if (v4)
  {
    sub_10004D2C8(v2);
  }
}

void sub_10125AFD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10125AFE8(uint64_t a1, int a2)
{
  CFTypeRef v4 = *(NSObject **)(a1 + 56);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      uint64_t v6 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v6;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sSomebody wants us to stay alive", buf, 0x16u);
    }
    *(void *)std::string buf = &off_101A0BD40;
    int v7 = fopen("/var/wireless/Library/CommCenter.KeepAlive.Enabled", "w");
    size_t v8 = v7;
    if (v7) {
      fclose(v7);
    }
    FileSystemInterface::~FileSystemInterface((FileSystemInterface *)buf);
    CFTypeID v9 = *(NSObject **)(a1 + 56);
    BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      if (v10)
      {
        uint64_t v11 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v11;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        char v12 = "#I %s%sKeepAlive file touched";
LABEL_18:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v12, buf, 0x16u);
      }
    }
    else if (v10)
    {
      uint64_t v19 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v19;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      char v12 = "#I %s%sFailed to touch KeepAlive file";
      goto LABEL_18;
    }
    if (*(void *)(a1 + 600))
    {
      long long v20 = *(NSObject **)(a1 + 56);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      uint64_t v21 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v21;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      double v22 = "#I %s%sThumperKeepAlive Jetsam assertion already taken";
LABEL_52:
      unint64_t v38 = v20;
      uint32_t v39 = 22;
LABEL_53:
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v22, buf, v39);
      return;
    }
    *(_OWORD *)&uint8_t buf[16] = 0u;
    long long v47 = 0u;
    unint64_t v23 = *(NSObject **)(a1 + 56);
    os_signpost_id_t v24 = os_signpost_id_generate(v23);
    if (v24 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      double v25 = *(NSObject **)(a1 + 56);
      if (os_signpost_enabled(v25))
      {
        *(_WORD *)long long v48 = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v25, OS_SIGNPOST_INTERVAL_BEGIN, v24, "ThumperKeepAlive", (const char *)&unk_1017DEDA7, v48, 2u);
      }
    }
    *(void *)long long v48 = off_101AA42C0;
    uint64_t v50 = v48;
    *(void *)std::string buf = v24;
    *(void *)&uint8_t buf[8] = os_retain(v23);
    sub_1000336E8((uint64_t)&buf[16], (uint64_t)v48);
    sub_100033A10(v48);
    sub_100058DB0(&__p, "ThumperKeepAlive");
    v44[0] = *(void *)buf;
    v44[1] = *(void *)&buf[8];
    sub_1000336E8((uint64_t)&v45, (uint64_t)&buf[16]);
    *(void *)std::string buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_100033AF4(&buf[16]);
    Registry::createXpcJetsamAssertion();
    long long v26 = *(_OWORD *)v48;
    *(void *)long long v48 = 0;
    *(void *)&v48[8] = 0;
    uint64_t v27 = *(std::__shared_weak_count **)(a1 + 608);
    *(_OWORD *)(a1 + 600) = v26;
    if (v27)
    {
      sub_10004D2C8(v27);
      if (*(void *)&v48[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v48[8]);
      }
    }
    sub_1000339DC(v44);
    if (v43 < 0) {
      operator delete(__p);
    }
    double v28 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v29 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)long long v48 = 136315394;
      *(void *)&v48[4] = v29;
      *(_WORD *)&v48[12] = 2080;
      *(void *)&v48[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s%sThumperKeepAlive Jetsam assertion taken.", v48, 0x16u);
    }
    sub_1000339DC((uint64_t *)buf);
    return;
  }
  if (v5)
  {
    uint64_t v13 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v13;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sSomebody wants us to go away", buf, 0x16u);
  }
  *(void *)long long v48 = &off_101A0BD40;
  sub_100058DB0(buf, "/var/wireless/Library/CommCenter.KeepAlive.Enabled");
  uint64_t v14 = sub_1007ED7D4((uint64_t)v48, (uint64_t *)buf);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)v48);
  unint64_t v15 = *(NSObject **)(a1 + 56);
  BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
  if (v14)
  {
    if (v16)
    {
      uint64_t v17 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v17;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      unint64_t v18 = "#I %s%sKeepAlive file removed";
LABEL_35:
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v18, buf, 0x16u);
    }
  }
  else if (v16)
  {
    uint64_t v30 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v30;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    unint64_t v18 = "#I %s%sFailed to remove KeepAlive file";
    goto LABEL_35;
  }
  if (!*(void *)(a1 + 600))
  {
    long long v20 = *(NSObject **)(a1 + 56);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v37 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v37;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    double v22 = "#I %s%sThumperKeepAlive Jetsam assertion wasn't taken";
    goto LABEL_52;
  }
  double v31 = *(std::__shared_weak_count **)(a1 + 608);
  *(void *)(a1 + 600) = 0;
  *(void *)(a1 + 608) = 0;
  if (v31) {
    sub_10004D2C8(v31);
  }
  Registry::getXpcJetsamAssertionManager((uint64_t *)buf, *(Registry **)(a1 + 120));
  uint64_t AssertionCount = ctu::XpcJetsamAssertion::getAssertionCount(*(ctu::XpcJetsamAssertion **)buf);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  double v33 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v34 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    uint64_t v35 = v34;
    if (!AssertionCount)
    {
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = v34;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&buf[22] = 2080;
      *(void *)&uint8_t buf[24] = "We might exit after some time";
      double v22 = "#I %s%sThumperKeepAlive Jetsam assertion released. %s";
      unint64_t v38 = v33;
      uint32_t v39 = 32;
      goto LABEL_53;
    }
    Registry::getXpcJetsamAssertionManager((uint64_t *)&v40, *(Registry **)(a1 + 120));
    ctu::XpcJetsamAssertion::dumpState((uint64_t *)v48, v40);
    if (v49 >= 0) {
      uint64_t v36 = v48;
    }
    else {
      uint64_t v36 = *(uint8_t **)v48;
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v35;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v36;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I %s%sThumperKeepAlive Jetsam assertion released. %s", buf, 0x20u);
    if (v49 < 0) {
      operator delete(*(void **)v48);
    }
    if (v41) {
      sub_10004D2C8(v41);
    }
  }
}

void sub_10125B700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_10125B7A8()
{
}

void sub_10125B8B8(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    sub_10004D2C8(v2);
    if (!v1)
    {
LABEL_3:
      if (v3) {
        goto LABEL_4;
      }
      goto LABEL_5;
    }
  }
  else if (!v1)
  {
    goto LABEL_3;
  }
  sub_10004D2C8(v1);
  if (v3) {
LABEL_4:
  }
    operator delete();
LABEL_5:
  _Unwind_Resume(exception_object);
}

void sub_10125B904(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  sub_10126F44C(a2, a1);
}

void sub_10125B940(_Unwind_Exception *exception_object)
{
  int v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10125B958(uint64_t a1, uint64_t a2, NSObject **a3, uint64_t *a4, uint64_t a5, uint64_t *a6)
{
  size_t v8 = (std::__shared_weak_count *)a6[1];
  uint64_t v21 = *a6;
  double v22 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CFTypeID v9 = (std::__shared_weak_count *)a4[1];
  uint64_t v19 = *a4;
  long long v20 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100810360(a1, a2, 1, a3, &v21, &v19, a5, "ps.ths");
  if (v20) {
    sub_10004D2C8(v20);
  }
  if (v22) {
    sub_10004D2C8(v22);
  }
  *(void *)a1 = off_101AA3F98;
  *(void *)(a1 + 8) = off_101AA4100;
  *(void *)(a1 + 16) = off_101AA41D8;
  sub_100058DB0(&__p, "ths");
  BOOL v10 = *a3;
  dispatch_object_t v16 = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  dispatch_object_t object = 0;
  ctu::RestModule::RestModule();
  if (v16) {
    dispatch_release(v16);
  }
  if (v18 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 256) = 0x300000000;
  *(_OWORD *)(a1 + 280) = 0u;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = a1 + 280;
  *(unsigned char *)(a1 + 448) = 0;
  *(unsigned char *)(a1 + 456) = 0;
  *(unsigned char *)(a1 + 464) = 0;
  *(unsigned char *)(a1 + 488) = 0;
  *(unsigned char *)(a1 + 312) = 0;
  *(_OWORD *)(a1 + 296) = 0u;
  *(void *)(a1 + 496) = 850045863;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 578) = 0u;
  *(unsigned char *)(a1 + 616) = 0;
  *(_OWORD *)(a1 + 600) = 0u;
  *(void *)(a1 + 664) = 0;
  *(_WORD *)(a1 + 672) = 0;
  Registry::getNotificationSenderFactory(&v13, *(Registry **)(a1 + 120));
  (*(void (**)(long long *__return_ptr))(*(void *)v13 + 136))(&v11);
  *(_OWORD *)(a1 + 680) = v11;
  long long v11 = 0uLL;
  if (v14) {
    sub_10004D2C8(v14);
  }
  *(void *)(a1 + 696) = 0;
  *(unsigned char *)(a1 + 704) = 0;
  long long v11 = 0uLL;
  uint64_t v12 = 0;
  sub_10007665C((void *)(a1 + 712));
}

void sub_10125BBF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_object_t object, dispatch_object_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  uint64_t v26 = *(void *)(v21 + 696);
  *(void *)(v21 + 696) = 0;
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v21 + 688);
  if (v27) {
    sub_10004D2C8(v27);
  }
  sub_10126F02C((void *)(v24 + 520));
  double v28 = *(std::__shared_weak_count **)(v21 + 632);
  if (v28) {
    sub_10004D2C8(v28);
  }
  uint64_t v29 = *(std::__shared_weak_count **)(v21 + 608);
  if (v29) {
    sub_10004D2C8(v29);
  }
  sub_100057D78((const void **)(v24 + 456));
  uint64_t v30 = *(std::__shared_weak_count **)(v21 + 568);
  if (v30) {
    sub_10004D2C8(v30);
  }
  std::mutex::~mutex(v23);
  sub_1008AC324(v21 + 464);
  sub_10126F0B0(v21 + 312);
  double v31 = *(std::__shared_weak_count **)(v21 + 304);
  if (v31) {
    sub_10004D2C8(v31);
  }
  sub_10030AAD0(v22, *(void **)(v21 + 280));
  sub_1000558F4((const void **)(v21 + 264));
  long long v32 = *(std::__shared_weak_count **)(v21 + 248);
  if (v32) {
    sub_10004D2C8(v32);
  }
  sub_100810708(v21);
  _Unwind_Resume(a1);
}

void sub_10125BD20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    sub_10004D2C8(a20);
  }
  uint64_t v21 = *(std::__shared_weak_count **)(v20 - 72);
  if (v21) {
    sub_10004D2C8(v21);
  }
  JUMPOUT(0x10125BD18);
}

uint64_t sub_10125BD40(uint64_t a1)
{
  *(void *)a1 = off_101AA3F98;
  *(void *)(a1 + 8) = off_101AA4100;
  *(void *)(a1 + 16) = off_101AA41D8;
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 240));
  char v2 = *(std::__shared_weak_count **)(a1 + 736);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(void *)(a1 + 720);
  *(void *)(a1 + 720) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 696);
  *(void *)(a1 + 696) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  BOOL v5 = *(std::__shared_weak_count **)(a1 + 688);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_10126F02C((void *)(a1 + 640));
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 632);
  if (v6) {
    sub_10004D2C8(v6);
  }
  int v7 = *(std::__shared_weak_count **)(a1 + 608);
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_100057D78((const void **)(a1 + 576));
  size_t v8 = *(std::__shared_weak_count **)(a1 + 568);
  if (v8) {
    sub_10004D2C8(v8);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 496));
  sub_1008AC324(a1 + 464);
  sub_10126F0B0(a1 + 312);
  CFTypeID v9 = *(std::__shared_weak_count **)(a1 + 304);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10030AAD0(a1 + 272, *(void **)(a1 + 280));
  sub_1000558F4((const void **)(a1 + 264));
  BOOL v10 = *(std::__shared_weak_count **)(a1 + 248);
  if (v10) {
    sub_10004D2C8(v10);
  }

  return sub_100810708(a1);
}

uint64_t sub_10125BED0(uint64_t a1)
{
  return sub_10125BD40(a1 - 8);
}

uint64_t sub_10125BED8(uint64_t a1)
{
  return sub_10125BD40(a1 - 16);
}

void sub_10125BEE0(uint64_t a1)
{
  sub_10125BD40(a1);

  operator delete();
}

void sub_10125BF18(uint64_t a1)
{
  sub_10125BD40(a1 - 8);

  operator delete();
}

void sub_10125BF54(uint64_t a1)
{
  sub_10125BD40(a1 - 16);

  operator delete();
}

const void **sub_10125BF90(uint64_t *a1, const __CFString *a2, const __CFString *a3)
{
  uint64_t v6 = *a1;
  sub_1003A9CA0(v23);
  int v7 = sub_1003A9B04(*(uint64_t *)v23, a2, 0);
  double v25 = v7;
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (v7) {
    size_t v8 = sub_100080934;
  }
  else {
    size_t v8 = 0;
  }
  if (v8)
  {
    uint64_t v22 = 0;
    sub_1007FF600(*(void *)(v6 + 168), (uint64_t)a2, (uint64_t)v7, (uint64_t *)a1[1]);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(v6 + 120));
    long long v11 = ServiceMap;
    if (v12 < 0)
    {
      uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    *(void *)unint64_t v23 = v12;
    dispatch_object_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)v23);
    if (v16)
    {
      uint64_t v18 = v16[3];
      uint64_t v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
LABEL_15:
        if (a3) {
          CFStringRef v20 = a3;
        }
        else {
          CFStringRef v20 = a2;
        }
        (*(void (**)(uint64_t, uint64_t, const __CFString *, const void *, void, void, uint64_t, void))(*(void *)v18 + 16))(v18, **(void **)(v6 + 144) + 24, v20, v22, kPhoneServicesWalletDomain, 0, 4, 0);
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        sub_1003A9CA0(v23);
        sub_1003A9C3C(*(uint64_t *)v23, a2, 0);
        if (v24) {
          sub_10004D2C8(v24);
        }
        sub_1000577C4(&v22);
        return sub_1000577C4(&v25);
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    uint64_t v17 = 0;
    char v19 = 1;
    goto LABEL_15;
  }
  return sub_1000577C4(&v25);
}

void sub_10125C174(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, std::__shared_weak_count *a11, const void *a12)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  sub_1000577C4(&a9);
  sub_1000577C4(&a12);
  _Unwind_Resume(a1);
}

void sub_10125C1D8(uint64_t a1)
{
  char v2 = (uint64_t *)(a1 + 184);
  std::string::operator=((std::string *)(a1 + 184), (const std::string *)(**(void **)(a1 + 144) + 24));
  uint64_t v74 = 0;
  sub_1003A9CA0(buf);
  *(void *)uint64_t v79 = sub_1003A9B04(*(uint64_t *)buf, @"last.account", 0);
  sub_100225AE0(&v74, (CFTypeRef *)v79);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v74) {
    uint64_t v3 = sub_1000810B8;
  }
  else {
    uint64_t v3 = 0;
  }
  if (!v3)
  {
LABEL_90:
    sub_1000558F4(&v74);
    memset(buf, 0, 32);
    sub_1008AA35C(@"com.apple.callservices.identifier2", (uint64_t)buf);
    if (!buf[24]) {
      goto LABEL_103;
    }
    v56[0] = 0;
    sub_1008AA930(@"com.apple.callservices.identifier2", (CFTypeRef *)v56);
    if (v56[0]) {
      double v41 = sub_100563580;
    }
    else {
      double v41 = 0;
    }
    if (!v41)
    {
LABEL_102:
      sub_100120040((const void **)v56);
LABEL_103:
      sub_1008AC324((uint64_t)buf);
      sub_10081060C(a1);
      sub_10125DFCC(a1);
      if (!sub_100810848(a1)) {
        goto LABEL_115;
      }
      *(void *)uint64_t v79 = &off_101A0BD40;
      sub_100058DB0(buf, "/var/wireless/Library/CommCenter.KeepAlive.Enabled");
      int v48 = sub_1007ECCD4((uint64_t)v79, (uint64_t *)buf);
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      FileSystemInterface::~FileSystemInterface((FileSystemInterface *)v79);
      char v49 = *(NSObject **)(a1 + 56);
      BOOL v50 = os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT);
      if (v48)
      {
        if (v50)
        {
          uint64_t v51 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v51;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I %s%sKeepAlive file found", buf, 0x16u);
        }
        if ((sub_100810848(a1) & 1) == 0) {
          goto LABEL_115;
        }
      }
      else
      {
        if (v50)
        {
          uint64_t v52 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v52;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I %s%sKeepAlive file not found", buf, 0x16u);
        }
        if (!sub_100810848(a1))
        {
LABEL_115:
          sub_10003E168(buf, (void *)(a1 + 88));
          uint64_t v54 = *(void *)buf;
          int64x2_t v53 = *(std::__shared_weak_count **)&buf[8];
          if (*(void *)&buf[8])
          {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
            sub_10004D2C8(v53);
          }
          sub_10003E168(theDict, (void *)(a1 + 88));
          double v55 = *(NSObject **)(a1 + 104);
          v56[0] = v55;
          v56[1] = (void *)a1;
          uint64_t v57 = v54;
          long long v58 = v53;
          if (v53)
          {
            atomic_fetch_add_explicit(&v53->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            dispatch_retain(v55);
            memset(buf, 0, 32);
            atomic_fetch_add_explicit(&v53->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            dispatch_retain(v55);
            atomic_fetch_add_explicit(&v53->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            dispatch_retain(v55);
            atomic_fetch_add_explicit(&v53->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            dispatch_retain(v55);
            atomic_fetch_add_explicit(&v53->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            dispatch_retain(v55);
            atomic_fetch_add_explicit(&v53->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            dispatch_retain(v55);
            atomic_fetch_add_explicit(&v53->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            dispatch_retain(v55);
            atomic_fetch_add_explicit(&v53->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          else
          {
            dispatch_retain(v55);
            memset(buf, 0, 32);
            dispatch_retain(v55);
            dispatch_retain(v55);
            dispatch_retain(v55);
            dispatch_retain(v55);
            dispatch_retain(v55);
            dispatch_retain(v55);
          }
          *(void *)uint64_t v79 = 0;
          dispatch_retain(v55);
          operator new();
        }
      }
      sub_10125AFE8(a1, v48);
      goto LABEL_115;
    }
    sub_1008ABBDC(@"com.apple.callservices.identifier2");
    uint8_t buf[16] = 0;
    theDict[0] = 0;
    sub_100800E2C(@"com.apple.callservices.identifier.", v2, (CFStringRef *)theDict);
    BOOL v42 = sub_1008AACBC(theDict[0], (__CFString *)v56[0], (uint64_t)buf);
    char v43 = *(NSObject **)(a1 + 56);
    BOOL v44 = os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT);
    if (v42)
    {
      if (v44)
      {
        uint64_t v45 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
        *(_DWORD *)uint64_t v79 = 136315650;
        *(void *)&v79[4] = v45;
        *(_WORD *)&v79[12] = 2080;
        *(void *)&v79[14] = " ";
        *(_WORD *)&v79[22] = 2112;
        CFDictionaryRef v80 = theDict[0];
        uint64_t v46 = "#I %s%sthumper keychain identity successfully migrated to %@";
LABEL_100:
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, v46, v79, 0x20u);
      }
    }
    else if (v44)
    {
      uint64_t v47 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)uint64_t v79 = 136315650;
      *(void *)&v79[4] = v47;
      *(_WORD *)&v79[12] = 2080;
      *(void *)&v79[14] = " ";
      *(_WORD *)&v79[22] = 2112;
      CFDictionaryRef v80 = theDict[0];
      uint64_t v46 = "#W %s%sfailed to migrated thumper keychain identity %@";
      goto LABEL_100;
    }
    sub_1000558F4((const void **)theDict);
    goto LABEL_102;
  }
  memset(buf, 0, 24);
  ctu::cf::assign();
  *(_OWORD *)double v56 = *(_OWORD *)buf;
  uint64_t v57 = *(void *)&buf[16];
  sub_1003A9CA0(buf);
  sub_1003A9C3C(*(uint64_t *)buf, @"last.account", 0);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  CFStringRef v73 = 0;
  sub_100800E2C(@"LocalCredentials", (uint64_t *)v56, &v73);
  uint64_t v72 = 0;
  sub_1003A9CA0(buf);
  CFStringRef v4 = (const __CFString *)kCFLocalProvisioningApplied;
  *(void *)uint64_t v79 = sub_1003A9B04(*(uint64_t *)buf, kCFLocalProvisioningApplied, 0);
  sub_1000BE34C(&v72, (CFTypeRef *)v79);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v72, v5);
  if (!buf[0])
  {
    sub_1003A9CA0(buf);
    sub_1003A9C3C(*(uint64_t *)buf, v4, 0);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    sub_1003A9CA0(buf);
    sub_1003A9C3C(*(uint64_t *)buf, @"CarrierBundle", 0);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    sub_1003A9CA0(buf);
    sub_1003A9C3C(*(uint64_t *)buf, @"IMSInfo", 0);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    sub_1003A9CA0(buf);
    sub_1003A9C3C(*(uint64_t *)buf, @"last.dn", 0);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    sub_1003A9CA0(buf);
    sub_1003A9C3C(*(uint64_t *)buf, v73, 0);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    sub_1000C0E74(a1 + 120, @"com.apple.th");
    goto LABEL_75;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)buf[0], *(Registry **)(a1 + 120));
  int v7 = ServiceMap;
  uint64_t v9 = v8;
  if (v8 < 0)
  {
    BOOL v10 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v9;
  uint64_t v13 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v14 = 0;
  char v16 = 1;
LABEL_31:
  uint64_t v17 = kPhoneServicesWalletDomain;
  (*(void (**)(uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void, void, uint64_t, void))(*(void *)v15 + 16))(v15, **(void **)(a1 + 144) + 24, v4, kCFBooleanTrue, kPhoneServicesWalletDomain, 0, 1, 0);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  sub_1003A9CA0(buf);
  sub_1003A9C3C(*(uint64_t *)buf, v4, 0);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  v71[0] = a1;
  v71[1] = (uint64_t)v56;
  sub_10125BF90(v71, @"CarrierBundle", 0);
  sub_10125BF90(v71, @"IMSInfo", 0);
  sub_10125BF90(v71, @"last.dn", 0);
  sub_10125BF90(v71, v73, @"LocalCredentials");
  theDict[0] = 0;
  theDict[1] = 0;
  uint64_t v70 = 0;
  uint64_t v66 = 0;
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  int v18 = sub_1000BF7B4(a1 + 120, @"com.apple.th");
  if (v18)
  {
    if (v18 == 1)
    {
      char v19 = *(NSObject **)(a1 + 56);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
LABEL_71:
        sub_1000C0E74(a1 + 120, @"com.apple.th");
        if (SHIBYTE(v68) < 0) {
          operator delete(v66);
        }
        if (SHIBYTE(v70) < 0) {
          operator delete(theDict[0]);
        }
LABEL_75:
        theDict[0] = 0;
        CFDictionaryRef v36 = CFPreferencesCopyMultiple(0, @"com.apple.commcenter.callservices", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        theDict[0] = v36;
        if (v36) {
          uint64_t v37 = sub_100080778;
        }
        else {
          uint64_t v37 = 0;
        }
        if (v37)
        {
          CFIndex Count = CFDictionaryGetCount(v36);
          if (Count)
          {
            memset(buf, 0, 24);
            sub_10019E8F0(buf, Count);
            CFDictionaryGetKeysAndValues(theDict[0], *(const void ***)buf, 0);
            uint32_t v39 = *(const __CFString ***)buf;
            uint64_t v40 = *(const __CFString ***)&buf[8];
            if (*(void *)buf != *(void *)&buf[8])
            {
              do
              {
                if (CFStringHasPrefix(*v39, @"LocalCredentials"))
                {
                  sub_1003A9CA0(v79);
                  sub_1003A9C3C(*(uint64_t *)v79, *v39, 0);
                  if (*(void *)&v79[8]) {
                    sub_10004D2C8(*(std::__shared_weak_count **)&v79[8]);
                  }
                }
                ++v39;
              }
              while (v39 != v40);
              uint32_t v39 = *(const __CFString ***)buf;
            }
            if (v39)
            {
              *(void *)&uint8_t buf[8] = v39;
              operator delete(v39);
            }
          }
        }
        sub_100057D78((const void **)theDict);
        sub_100062778((const void **)&v72);
        sub_1000558F4((const void **)&v73);
        if (SHIBYTE(v57) < 0) {
          operator delete(v56[0]);
        }
        goto LABEL_90;
      }
      uint64_t v33 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v33;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      uint64_t v21 = "#I %s%smigration, No individual secret in keychain - request new one";
    }
    else
    {
      if (v18 != 2) {
        goto LABEL_71;
      }
      char v19 = *(NSObject **)(a1 + 56);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_71;
      }
      uint64_t v20 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v20;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      uint64_t v21 = "#W %s%smigration, KeyChain is locked - will re-request individual key";
    }
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v21, buf, 0x16u);
    goto LABEL_71;
  }
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  uint64_t v65 = 0;
  ctu::base64::decode();
  if (v63 == v64)
  {
    uint64_t v34 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v35 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v35;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I %s%smigration, Individual secret is not of valid format", buf, 0x16u);
    }
    goto LABEL_69;
  }
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  long long __p = 0;
  int64x2_t v60 = 0;
  sub_10005C928(&__p, v63, (uint64_t)v64, v64 - (unsigned char *)v63);
  memset(v79, 0, sizeof(v79));
  sub_10005C928(v79, __p, (uint64_t)v60, v60 - (unsigned char *)__p);
  uint64_t v75 = 0;
  memset(buf, 0, 24);
  sub_10005C928(buf, *(const void **)v79, *(uint64_t *)&v79[8], *(void *)&v79[8] - *(void *)v79);
  uint64_t v76 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v22 = v75;
    uint64_t v75 = v76;
    uint64_t v77 = v22;
    sub_100030068(&v77);
  }
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  uint64_t v62 = v75;
  uint64_t v75 = 0;
  sub_100030068(&v75);
  if (*(void *)v79)
  {
    *(void *)&v79[8] = *(void *)v79;
    operator delete(*(void **)v79);
  }
  if (__p)
  {
    int64x2_t v60 = __p;
    operator delete(__p);
  }
  if (v62) {
    unint64_t v23 = (uint64_t *)sub_10008324C;
  }
  else {
    unint64_t v23 = 0;
  }
  if (!v23)
  {
LABEL_68:
    sub_100030068(&v62);
LABEL_69:
    if (v63)
    {
      uint64_t v64 = v63;
      operator delete(v63);
    }
    goto LABEL_71;
  }
  uint64_t v24 = (std::mutex *)Registry::getServiceMap(v23, *(Registry **)(a1 + 120));
  double v25 = v24;
  if (v8 < 0)
  {
    uint64_t v26 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v27 = 5381;
    do
    {
      uint64_t v8 = v27;
      unsigned int v28 = *v26++;
      uint64_t v27 = (33 * v27) ^ v28;
    }
    while (v28);
  }
  std::mutex::lock(v24);
  *(void *)std::string buf = v8;
  uint64_t v29 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)buf);
  if (v29)
  {
    uint64_t v31 = v29[3];
    uint64_t v30 = (std::__shared_weak_count *)v29[4];
    if (v30)
    {
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v25);
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v30);
      char v32 = 0;
      goto LABEL_66;
    }
  }
  else
  {
    uint64_t v31 = 0;
  }
  std::mutex::unlock(v25);
  uint64_t v30 = 0;
  char v32 = 1;
LABEL_66:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, const void *, uint64_t, void, uint64_t, void))(*(void *)v31 + 16))(v31, **(void **)(a1 + 144) + 24, @"individualKey", v62, v17, 0, 4, 0);
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  goto LABEL_68;
}

void sub_10125D94C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,char a36,void *__p,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  if (__p) {
    operator delete(__p);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a51 < 0) {
    operator delete(a46);
  }
  sub_100062778((const void **)(v51 - 256));
  sub_1000558F4((const void **)(v51 - 248));
  if (a30 < 0) {
    operator delete(a25);
  }
  sub_1000558F4((const void **)(v51 - 240));
  _Unwind_Resume(a1);
}

const void **sub_10125DFCC(uint64_t a1)
{
  int v18 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 120));
  uint64_t v3 = ServiceMap;
  CFStringRef v4 = "8UStorage";
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    CFBooleanRef v5 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      CFStringRef v4 = (const char *)v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    BOOL v10 = (os_unfair_lock_s *)v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    BOOL v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  sub_100083254(v10, @"last.dev.icloud.ver", kPhoneServicesWalletDomain, 0, 1u, &v17);
  sub_1000842D0(&v18, &v17);
  sub_1000577C4(&v17);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (v18) {
    uint64_t v13 = sub_100081E58;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v13)
  {
    *(_DWORD *)std::string buf = 0;
    ctu::cf::assign((ctu::cf *)buf, v18, v12);
    dword_101B133E8 = *(_DWORD *)buf;
    uint64_t v14 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = v15;
      __int16 v20 = 2080;
      uint64_t v21 = " ";
      __int16 v22 = 1024;
      int v23 = dword_101B133E8;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%sRestored fLastDevSectionVer %u", buf, 0x1Cu);
    }
  }
  return sub_1000570E8((const void **)&v18);
}

void sub_10125E1C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

void sub_10125E218(void *a1, int a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      unsigned int v7 = v6;
      if (a1[5])
      {
        uint64_t v8 = *(NSObject **)(v5 + 56);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
          BOOL v10 = "locked";
          int v11 = 136315650;
          uint64_t v12 = v9;
          __int16 v13 = 2080;
          uint64_t v14 = " ";
          if (a2) {
            BOOL v10 = "unlocked. Invoking service refresh";
          }
          __int16 v15 = 2080;
          char v16 = v10;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%sKeychain is %s", (uint8_t *)&v11, 0x20u);
        }
        if (a2) {
          sub_10125E354((const void **)v5, 0, 0);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10125E33C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

const void **sub_10125E354(const void **result, BOOL a2, BOOL a3)
{
  if (*((unsigned char *)result[20] + 354)) {
    return result;
  }
  uint64_t v5 = (uint64_t)result;
  BOOL result = (const void **)(*(uint64_t (**)(const void *))(*(void *)result[21] + 16))(result[21]);
  if (!result) {
    return result;
  }
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 224))(v5);
  unsigned int v7 = *(NSObject **)(v5 + 56);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
    *(_DWORD *)std::string buf = 136316162;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&buf[22] = 2080;
    *(void *)&uint8_t buf[24] = asStringBool(a2);
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = asStringBool(a3);
    *(_WORD *)&buf[42] = 2080;
    *(void *)&buf[44] = asStringBool(v6 == 1);
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%suserAction:%s, reprovisioning:%s, service was up:%s", buf, 0x34u);
  }
  uint64_t v9 = *(void *)(v5 + 160);
  if (*(unsigned char *)(v9 + 344) && *(unsigned char *)(v9 + 276) && *(_DWORD *)(v9 + 272) == 4)
  {
    uint64_t v10 = *(void *)(v5 + 168);
    unsigned int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 176))(v5);
    sub_1007FE5B8(v10, 2u, 0, v11, (long long *)(v5 + 184), 1, 1);
    *(_OWORD *)&theDict.__r_.__value_.__l.__data_ = 0uLL;
    sub_1007FFAA4(*(void **)(v5 + 168), 1, (void **)(v5 + 184), 0, (const void **)&theDict.__r_.__value_.__l.__data_);
    if (theDict.__r_.__value_.__l.__size_) {
      uint64_t v12 = sub_100080778;
    }
    else {
      uint64_t v12 = 0;
    }
    if (v12)
    {
      v280.__r_.__value_.__r.__words[0] = (std::string::size_type)CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)theDict.__r_.__value_.__l.__size_);
      CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)v280.__r_.__value_.__l.__data_);
      if (Count)
      {
        memset(buf, 0, 24);
        sub_10019E8F0(buf, Count);
        memset(&values, 0, sizeof(values));
        sub_10004EE3C(&values, Count);
        CFDictionaryGetKeysAndValues((CFDictionaryRef)v280.__r_.__value_.__l.__data_, *(const void ***)buf, (const void **)values.__r_.__value_.__l.__data_);
        uint64_t v14 = 0;
        while (1)
        {
          CFStringRef v15 = *(const __CFString **)(values.__r_.__value_.__r.__words[0] + 8 * v14);
          if (v15)
          {
            CFTypeID v16 = CFGetTypeID(*(CFTypeRef *)(values.__r_.__value_.__r.__words[0] + 8 * v14));
            if (v16 == CFStringGetTypeID())
            {
              CFStringRef v17 = (const __CFString *)sub_1007FA824(*(void **)(v5 + 168));
              if (CFEqual(v17, v15)) {
                break;
              }
            }
          }
          if (Count == ++v14) {
            goto LABEL_22;
          }
        }
        CFDictionaryRemoveValue((CFMutableDictionaryRef)v280.__r_.__value_.__l.__data_, *(const void **)(*(void *)buf + 8 * v14));
        sub_1007FE5B8(*(void *)(v5 + 168), 1u, (CFDictionaryRef)v280.__r_.__value_.__l.__data_, LODWORD(theDict.__r_.__value_.__l.__data_) + 1, (long long *)(v5 + 184), 1, 1);
LABEL_22:
        if (values.__r_.__value_.__r.__words[0])
        {
          values.__r_.__value_.__l.__size_ = values.__r_.__value_.__r.__words[0];
          operator delete(values.__r_.__value_.__l.__data_);
        }
        if (*(void *)buf)
        {
          *(void *)&uint8_t buf[8] = *(void *)buf;
          operator delete(*(void **)buf);
        }
      }
      sub_10005717C((const void **)&v280.__r_.__value_.__l.__data_);
    }
    sub_100057D78((const void **)&theDict.__r_.__value_.__l.__size_);
  }
  else if (!a3)
  {
    int v18 = 0;
    goto LABEL_67;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 224))(v5) == 1) {
    sub_101263664(v5, 0);
  }
  if (*(unsigned char *)(v5 + 456)) {
    sub_1012650C8(v5, 0, 0);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v5 + 120));
  __int16 v20 = ServiceMap;
  uint64_t v22 = v21;
  if (v21 < 0)
  {
    int v23 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v24 = 5381;
    do
    {
      uint64_t v22 = v24;
      unsigned int v25 = *v23++;
      uint64_t v24 = (33 * v24) ^ v25;
    }
    while (v25);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v22;
  uint64_t v26 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)buf);
  if (v26)
  {
    uint64_t v28 = v26[3];
    uint64_t v27 = (std::__shared_weak_count *)v26[4];
    if (v27)
    {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v20);
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v27);
      char v29 = 0;
      goto LABEL_40;
    }
  }
  else
  {
    uint64_t v28 = 0;
  }
  std::mutex::unlock(v20);
  uint64_t v27 = 0;
  char v29 = 1;
LABEL_40:
  uint64_t v30 = kPhoneServicesWalletDomain;
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v28 + 32))(v28, **(void **)(v5 + 144) + 24, @"CarrierBundle", kPhoneServicesWalletDomain, 0, 4);
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  std::mutex::lock((std::mutex *)(v5 + 496));
  uint64_t v31 = *(void *)(v5 + 576);
  *(void *)(v5 + 576) = 0;
  *(void *)std::string buf = v31;
  sub_100057D78((const void **)buf);
  std::mutex::unlock((std::mutex *)(v5 + 496));
  char v32 = *(NSObject **)(v5 + 56);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v33 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v33;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I %s%spre-provisioning dropped ->disable personality", buf, 0x16u);
  }
  uint64_t v34 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v5 + 120));
  uint64_t v35 = v34;
  if (v36 < 0)
  {
    uint64_t v37 = (unsigned __int8 *)(v36 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v38 = 5381;
    do
    {
      uint64_t v36 = v38;
      unsigned int v39 = *v37++;
      uint64_t v38 = (33 * v38) ^ v39;
    }
    while (v39);
  }
  std::mutex::lock(v34);
  *(void *)std::string buf = v36;
  uint64_t v40 = sub_10004D37C(&v35[1].__m_.__sig, (unint64_t *)buf);
  if (v40)
  {
    uint64_t v42 = v40[3];
    double v41 = (std::__shared_weak_count *)v40[4];
    if (v41)
    {
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v35);
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v41);
      char v43 = 0;
      goto LABEL_52;
    }
  }
  else
  {
    uint64_t v42 = 0;
  }
  std::mutex::unlock(v35);
  double v41 = 0;
  char v43 = 1;
LABEL_52:
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)v42 + 64))(v42, **(void **)(v5 + 144) + 24, 0);
  if ((v43 & 1) == 0) {
    sub_10004D2C8(v41);
  }
  BOOL v44 = *(std::__shared_weak_count **)(v5 + 304);
  *(void *)(v5 + 296) = 0;
  *(void *)(v5 + 304) = 0;
  if (v44) {
    sub_10004D2C8(v44);
  }
  *(void *)std::string buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  sub_101264B68(v5, (long long **)buf);
  uint64_t v45 = **(void **)(v5 + 160);
  *(_DWORD *)(v5 + 260) = 2;
  (*(void (**)(void))(v45 + 312))();
  *(_WORD *)(v5 + 588) = 0;
  uint64_t v46 = *(void *)(v5 + 160);
  *(unsigned char *)(v46 + 353) = 0;
  *(_DWORD *)(v46 + 736) = 0;
  (*(void (**)(uint64_t, uint64_t))(*(void *)v46 + 304))(v46, 3);
  uint64_t v47 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v5 + 120));
  int v48 = v47;
  if (v21 < 0)
  {
    char v49 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v50 = 5381;
    do
    {
      uint64_t v21 = v50;
      unsigned int v51 = *v49++;
      uint64_t v50 = (33 * v50) ^ v51;
    }
    while (v51);
  }
  std::mutex::lock(v47);
  *(void *)std::string buf = v21;
  uint64_t v52 = sub_10004D37C(&v48[1].__m_.__sig, (unint64_t *)buf);
  if (!v52)
  {
    uint64_t v54 = 0;
    goto LABEL_63;
  }
  uint64_t v54 = v52[3];
  int64x2_t v53 = (std::__shared_weak_count *)v52[4];
  if (!v53)
  {
LABEL_63:
    std::mutex::unlock(v48);
    int64x2_t v53 = 0;
    char v55 = 1;
    goto LABEL_64;
  }
  atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v48);
  atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v53);
  char v55 = 0;
LABEL_64:
  (*(void (**)(uint64_t, uint64_t, void, uint64_t, void, uint64_t))(*(void *)v54 + 32))(v54, **(void **)(v5 + 144) + 24, kCFPSReprovisioningRequired, v30, 0, 1);
  if ((v55 & 1) == 0) {
    sub_10004D2C8(v53);
  }
  int v18 = 1;
LABEL_67:
  uint64_t v56 = *(void *)(v5 + 168);
  BOOL v57 = (sub_1007F89C4(v56) & 1) != 0 || *(unsigned char *)(v56 + 193) != 0;
  BOOL v274 = v57;
  int v58 = *(_DWORD *)(v5 + 256);
  if (v58) {
    BOOL v59 = v58 == 2;
  }
  else {
    BOOL v59 = sub_10125ADA4(v5);
  }
  CFDictionaryRef v275 = 0;
  uint64_t v276 = 0;
  sub_101266470((uint64_t)&v275, v5);
  int v273 = v18;
  if (!v274 || (v275 ? (int64x2_t v60 = sub_100080778) : (int64x2_t v60 = 0), !v60 || !(_BYTE)v276))
  {
    uint64_t v63 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v5 + 120));
    uint64_t v64 = v63;
    if (v65 < 0)
    {
      uint64_t v66 = (unsigned __int8 *)(v65 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v67 = 5381;
      do
      {
        uint64_t v65 = v67;
        unsigned int v68 = *v66++;
        uint64_t v67 = (33 * v67) ^ v68;
      }
      while (v68);
    }
    std::mutex::lock(v63);
    *(void *)std::string buf = v65;
    uint64_t v69 = sub_10004D37C(&v64[1].__m_.__sig, (unint64_t *)buf);
    if (v69)
    {
      uint64_t v71 = v69[3];
      uint64_t v70 = (std::__shared_weak_count *)v69[4];
      if (v70)
      {
        atomic_fetch_add_explicit(&v70->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v64);
        atomic_fetch_add_explicit(&v70->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v70);
        char v72 = 0;
LABEL_94:
        (*(void (**)(uint64_t, uint64_t))(*(void *)v71 + 56))(v71, **(void **)(v5 + 144) + 24);
        if ((v72 & 1) == 0) {
          sub_10004D2C8(v70);
        }
        if ((_BYTE)v276)
        {
          uint64_t v73 = *(void *)(v5 + 168);
          unsigned int v74 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 176))(v5);
          sub_1007FE5B8(v73, 2u, 0, v74, (long long *)(v5 + 184), 1, 1);
        }
        v278[0] = 0;
        v278[1] = 0;
        int64_t v279 = 0;
        sub_100058DB0(v278, "-");
        int v75 = 0;
        int v76 = 0;
        int v77 = 0;
        int v78 = 0;
        int v79 = 0;
        int v80 = -1;
        goto LABEL_337;
      }
    }
    else
    {
      uint64_t v71 = 0;
    }
    std::mutex::unlock(v64);
    uint64_t v70 = 0;
    char v72 = 1;
    goto LABEL_94;
  }
  if (!sub_101264F90(v5))
  {
    v278[0] = 0;
    v278[1] = 0;
    int64_t v279 = 0;
    if (CFStringCompare(*(CFStringRef *)(v5 + 264), &stru_101AC1B28, 0))
    {
      long long v81 = (std::string *)sub_100058DB0(&v316, "mismatch: '");
      int v82 = *(char *)(v5 + 207);
      if (v82 >= 0) {
        double v83 = (const std::string::value_type *)(v5 + 184);
      }
      else {
        double v83 = *(const std::string::value_type **)(v5 + 184);
      }
      if (v82 >= 0) {
        std::string::size_type v84 = *(unsigned __int8 *)(v5 + 207);
      }
      else {
        std::string::size_type v84 = *(void *)(v5 + 192);
      }
      int64x2_t v85 = std::string::append(v81, v83, v84);
      long long v86 = *(_OWORD *)&v85->__r_.__value_.__l.__data_;
      v280.__r_.__value_.__r.__words[2] = v85->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v280.__r_.__value_.__l.__data_ = v86;
      v85->__r_.__value_.__l.__size_ = 0;
      v85->__r_.__value_.__r.__words[2] = 0;
      v85->__r_.__value_.__r.__words[0] = 0;
      uint64_t v87 = std::string::append(&v280, "' vs '", 6uLL);
      long long v88 = *(_OWORD *)&v87->__r_.__value_.__l.__data_;
      theDict.__r_.__value_.__r.__words[2] = v87->__r_.__value_.__r.__words[2];
      *(_OWORD *)&theDict.__r_.__value_.__l.__data_ = v88;
      v87->__r_.__value_.__l.__size_ = 0;
      v87->__r_.__value_.__r.__words[2] = 0;
      v87->__r_.__value_.__r.__words[0] = 0;
      memset(buf, 0, 24);
      ctu::cf::assign();
      std::string __p = *(std::string *)buf;
      if (buf[23] >= 0) {
        p_p = &__p;
      }
      else {
        p_p = *(std::string **)buf;
      }
      if (buf[23] >= 0) {
        std::string::size_type v90 = buf[23];
      }
      else {
        std::string::size_type v90 = *(void *)&buf[8];
      }
      uint64_t v91 = std::string::append(&theDict, (const std::string::value_type *)p_p, v90);
      long long v92 = *(_OWORD *)&v91->__r_.__value_.__l.__data_;
      values.__r_.__value_.__r.__words[2] = v91->__r_.__value_.__r.__words[2];
      *(_OWORD *)&values.__r_.__value_.__l.__data_ = v92;
      v91->__r_.__value_.__l.__size_ = 0;
      v91->__r_.__value_.__r.__words[2] = 0;
      v91->__r_.__value_.__r.__words[0] = 0;
      char v93 = std::string::append(&values, "'", 1uLL);
      long long v94 = *(_OWORD *)&v93->__r_.__value_.__l.__data_;
      int64_t v279 = v93->__r_.__value_.__r.__words[2];
      *(_OWORD *)uint64_t v278 = v94;
      v93->__r_.__value_.__l.__size_ = 0;
      v93->__r_.__value_.__r.__words[2] = 0;
      v93->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(values.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(values.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(theDict.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v280.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v280.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v317) < 0) {
        operator delete((void *)v316);
      }
    }
    else
    {
      sub_100058DB0(v278, "disabled");
    }
    int v75 = 0;
    int v76 = 0;
    int v77 = 0;
    int v79 = 0;
    int v80 = -1;
    goto LABEL_336;
  }
  if (v6 == 1 && !*(unsigned char *)(v5 + 592)) {
    *(unsigned char *)(v5 + 592) = 1;
  }
  uint64_t v61 = (const std::string **)(v5 + 296);
  uint64_t v62 = *(void *)(v5 + 296);
  if (v62 && *(unsigned char *)(v62 + 256))
  {
    sub_101268220(v5);
    goto LABEL_310;
  }
  CFDictionaryRef v272 = v275;
  CFTypeRef Value = CFDictionaryGetValue(v275, @"masterToken");
  if (Value)
  {
    CFTypeID v96 = CFGetTypeID(Value);
    BOOL v97 = v96 == CFStringGetTypeID();
  }
  else
  {
    BOOL v97 = 0;
  }
  uint64_t v98 = *v61;
  if (*v61) {
    LODWORD(v98) = v98[10].__r_.__value_.__s.__data_[16] != 0;
  }
  BOOL v271 = v97;
  if ((v98 | v97))
  {
    std::string::size_type v283 = 0;
    goto LABEL_175;
  }
  std::string::size_type v283 = 0;
  CFArrayRef v99 = (const __CFArray *)CFDictionaryGetValue(v272, @"cfgSlots");
  CFArrayRef v100 = v99;
  if (v99)
  {
    CFIndex v101 = CFArrayGetCount(v99);
    int v102 = v101;
    if (v101)
    {
      int v103 = *(NSObject **)(v5 + 56);
      if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v104 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
        uint64_t v105 = (void *)(v5 + 184);
        if (*(char *)(v5 + 207) < 0) {
          uint64_t v105 = (void *)*v105;
        }
        *(_DWORD *)std::string buf = 136315906;
        *(void *)&uint8_t buf[4] = v104;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v105;
        *(_WORD *)&unsigned char buf[32] = 1024;
        *(_DWORD *)&buf[34] = v102;
        _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "#I %s%sAccount %s have %d data slot(s)", buf, 0x26u);
      }
      long long v289 = 0uLL;
      uint64_t v106 = (std::string *)(v5 + 184);
      sub_1007FFAA4(*(void **)(v5 + 168), 1, (void **)(v5 + 184), 0, (const void **)&v289);
      CFDictionaryRef v107 = (const __CFDictionary *)*((void *)&v289 + 1);
      if (*((void *)&v289 + 1)) {
        int v108 = sub_100080778;
      }
      else {
        int v108 = 0;
      }
      if (v108)
      {
        uint64_t v109 = *(void *)(v5 + 168);
        if (*(char *)(v5 + 207) < 0)
        {
          sub_10004FC84(buf, *(void **)(v5 + 184), *(void *)(v5 + 192));
        }
        else
        {
          *(_OWORD *)std::string buf = *(_OWORD *)&v106->__r_.__value_.__l.__data_;
          *(void *)&uint8_t buf[16] = *(void *)(v5 + 200);
        }
        uint8_t buf[24] = 1;
        int v117 = sub_1007FCB38(v109, v107, (long long *)buf, 0);
        if (buf[24] && (buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        if (v117)
        {
          CFDictionaryRef v118 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)&v289 + 1), @"assignments");
          CFDictionaryRef v119 = v118;
          if (v118)
          {
            CFIndex v120 = CFDictionaryGetCount(v118);
            if (v120)
            {
              memset(&v280, 0, sizeof(v280));
              sub_10019E8F0(&v280, v120);
              long long v316 = 0uLL;
              uint64_t v317 = 0;
              sub_10004EE3C(&v316, v120);
              CFDictionaryGetKeysAndValues(v119, (const void **)v280.__r_.__value_.__l.__data_, (const void **)v316);
              CFIndex v270 = v120;
              if (v120 >= 1)
              {
                uint64_t v121 = 0;
                while (1)
                {
                  BOOL v122 = *(const void **)(v316 + 8 * v121);
                  if (v122)
                  {
                    int v123 = (const void *)sub_1007FA824(*(void **)(v5 + 168));
                    if (CFEqual(v122, v123)) {
                      break;
                    }
                  }
                  if (v270 == ++v121) {
                    goto LABEL_536;
                  }
                }
                if (!sub_101268800(v5))
                {
                  double v230 = CFDictionaryGetValue(v272, @"primaryDeviceId");
                  if (v230)
                  {
                    (*(void (**)(void, const void *, uint64_t))(**(void **)(v5 + 168) + 24))(*(void *)(v5 + 168), v230, **(void **)(v5 + 144) + 24);
                    *(unsigned char *)(v5 + 591) = 1;
                  }
                  else
                  {
                    double v231 = *(NSObject **)(v5 + 56);
                    if (os_log_type_enabled(v231, OS_LOG_TYPE_DEFAULT))
                    {
                      std::string::size_type v232 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
                      double v233 = "true";
                      LODWORD(values.__r_.__value_.__l.__data_) = 136315650;
                      *(std::string::size_type *)((char *)values.__r_.__value_.__r.__words + 4) = v232;
                      WORD2(values.__r_.__value_.__r.__words[1]) = 2080;
                      *(std::string::size_type *)((char *)&values.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
                      if (!v272) {
                        double v233 = "false";
                      }
                      HIWORD(values.__r_.__value_.__r.__words[2]) = 2080;
                      uint64_t v288 = (std::string *)v233;
                      _os_log_impl((void *)&_mh_execute_header, v231, OS_LOG_TYPE_DEFAULT, "#I %s%sNo primary deviceId. Valid mainCfg: %s", (uint8_t *)&values, 0x20u);
                    }
                  }
                }
                if (*(void *)(v5 + 624))
                {
                  for (CFIndex i = 0; i < CFArrayGetCount(v100); ++i)
                  {
                    CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v100, i);
                    if (ValueAtIndex)
                    {
                      CFDictionaryRef v285 = 0;
                      uint64_t v236 = *(void *)(v5 + 624);
                      v278[1] = 0;
                      int64_t v279 = 0;
                      v278[0] = 0;
                      sub_10005C928(v278, *(const void **)v236, *(void *)(v236 + 8), *(void *)(v236 + 8) - *(void *)v236);
                      sub_100639DDC(ValueAtIndex, (uint64_t)v278, &cf);
                      theDict.__r_.__value_.__r.__words[0] = (std::string::size_type)cf;
                      if (cf) {
                        CFRetain(cf);
                      }
                      __p.__r_.__value_.__r.__words[0] = 0;
                      values.__r_.__value_.__r.__words[0] = 0;
                      sub_10004EFE4(&values, (CFTypeRef *)&theDict.__r_.__value_.__l.__data_);
                      if (values.__r_.__value_.__r.__words[0]) {
                        double v237 = sub_100080778;
                      }
                      else {
                        double v237 = 0;
                      }
                      if (v237) {
                        sub_100058140((const void **)&__p.__r_.__value_.__l.__data_, (const void **)&values.__r_.__value_.__l.__data_);
                      }
                      sub_100057D78((const void **)&values.__r_.__value_.__l.__data_);
                      CFDictionaryRef v285 = (CFDictionaryRef)__p.__r_.__value_.__r.__words[0];
                      __p.__r_.__value_.__r.__words[0] = 0;
                      sub_100057D78((const void **)&__p.__r_.__value_.__l.__data_);
                      sub_1000577C4((const void **)&theDict.__r_.__value_.__l.__data_);
                      sub_1000577C4(&cf);
                      if (v278[0])
                      {
                        v278[1] = v278[0];
                        operator delete(v278[0]);
                      }
                      if (v285) {
                        double v238 = sub_100080778;
                      }
                      else {
                        double v238 = 0;
                      }
                      if (v238)
                      {
                        unint64_t v239 = CFDictionaryGetValue(v285, @"slotId");
                        if (v239)
                        {
                          if (CFEqual(*(CFTypeRef *)(v280.__r_.__value_.__r.__words[0] + 8 * v121), v239))
                          {
                            sub_100058140((const void **)&v283, (const void **)&v285);
                            double v261 = *(NSObject **)(v5 + 56);
                            if (os_log_type_enabled(v261, OS_LOG_TYPE_DEFAULT))
                            {
                              std::string::size_type v262 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
                              memset(&theDict, 0, sizeof(theDict));
                              ctu::cf::assign();
                              std::string __p = theDict;
                              double v263 = (std::string *)theDict.__r_.__value_.__r.__words[0];
                              if ((theDict.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                double v263 = &__p;
                              }
                              LODWORD(values.__r_.__value_.__l.__data_) = 136315650;
                              *(std::string::size_type *)((char *)values.__r_.__value_.__r.__words + 4) = v262;
                              WORD2(values.__r_.__value_.__r.__words[1]) = 2080;
                              *(std::string::size_type *)((char *)&values.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
                              HIWORD(values.__r_.__value_.__r.__words[2]) = 2080;
                              uint64_t v288 = v263;
                              _os_log_impl((void *)&_mh_execute_header, v261, OS_LOG_TYPE_DEFAULT, "#I %s%sMy slot %s", (uint8_t *)&values, 0x20u);
                              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                                operator delete(__p.__r_.__value_.__l.__data_);
                              }
                            }
                            sub_100057D78((const void **)&v285);
                            break;
                          }
                        }
                      }
                      sub_100057D78((const void **)&v285);
                    }
                    else
                    {
                      int v240 = *(NSObject **)(v5 + 56);
                      if (os_log_type_enabled(v240, OS_LOG_TYPE_DEFAULT))
                      {
                        std::string::size_type v241 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
                        LODWORD(values.__r_.__value_.__l.__data_) = 136315650;
                        *(std::string::size_type *)((char *)values.__r_.__value_.__r.__words + 4) = v241;
                        WORD2(values.__r_.__value_.__r.__words[1]) = 2080;
                        *(std::string::size_type *)((char *)&values.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
                        HIWORD(values.__r_.__value_.__r.__words[2]) = 1024;
                        LODWORD(v288) = i;
                        _os_log_impl((void *)&_mh_execute_header, v240, OS_LOG_TYPE_DEFAULT, "#I %s%sIncorrect slot %d data format", (uint8_t *)&values, 0x1Cu);
                      }
                    }
                  }
                  if (v283) {
                    int v264 = sub_100080778;
                  }
                  else {
                    int v264 = 0;
                  }
                  if (!v264)
                  {
                    int v265 = *(NSObject **)(v5 + 56);
                    if (os_log_type_enabled(v265, OS_LOG_TYPE_DEFAULT))
                    {
                      std::string::size_type v266 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
                      LODWORD(values.__r_.__value_.__l.__data_) = 136315394;
                      *(std::string::size_type *)((char *)values.__r_.__value_.__r.__words + 4) = v266;
                      WORD2(values.__r_.__value_.__r.__words[1]) = 2080;
                      *(std::string::size_type *)((char *)&values.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
                      _os_log_impl((void *)&_mh_execute_header, v265, OS_LOG_TYPE_DEFAULT, "#I %s%sIncorrect individual key given, request new one?", (uint8_t *)&values, 0x16u);
                    }
                    uint64_t v267 = CFDictionaryGetValue(v272, @"primaryDeviceId");
                    if (v267)
                    {
                      (*(void (**)(void, const void *, uint64_t))(**(void **)(v5 + 168) + 24))(*(void *)(v5 + 168), v267, **(void **)(v5 + 144) + 24);
                      *(unsigned char *)(v5 + 591) = 1;
                    }
                  }
                }
                else
                {
                  double v242 = *(NSObject **)(v5 + 56);
                  if (os_log_type_enabled(v242, OS_LOG_TYPE_DEFAULT))
                  {
                    std::string::size_type v243 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
                    LODWORD(values.__r_.__value_.__l.__data_) = 136315394;
                    *(std::string::size_type *)((char *)values.__r_.__value_.__r.__words + 4) = v243;
                    WORD2(values.__r_.__value_.__r.__words[1]) = 2080;
                    *(std::string::size_type *)((char *)&values.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
                    _os_log_impl((void *)&_mh_execute_header, v242, OS_LOG_TYPE_DEFAULT, "#I %s%sNo individual secret key given - bailout", (uint8_t *)&values, 0x16u);
                  }
                }
                if (v270 == v121)
                {
LABEL_536:
                  int v268 = *(NSObject **)(v5 + 56);
                  if (os_log_type_enabled(v268, OS_LOG_TYPE_DEFAULT))
                  {
                    std::string::size_type v269 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
                    LODWORD(values.__r_.__value_.__l.__data_) = 136315394;
                    *(std::string::size_type *)((char *)values.__r_.__value_.__r.__words + 4) = v269;
                    WORD2(values.__r_.__value_.__r.__words[1]) = 2080;
                    *(std::string::size_type *)((char *)&values.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
                    _os_log_impl((void *)&_mh_execute_header, v268, OS_LOG_TYPE_DEFAULT, "#I %s%sImpossible! No data slot for us - bailout", (uint8_t *)&values, 0x16u);
                  }
                }
              }
              if ((void)v316)
              {
                *((void *)&v316 + 1) = v316;
                operator delete((void *)v316);
              }
              if (v280.__r_.__value_.__r.__words[0])
              {
                v280.__r_.__value_.__l.__size_ = v280.__r_.__value_.__r.__words[0];
                operator delete(v280.__r_.__value_.__l.__data_);
              }
            }
            goto LABEL_174;
          }
          uint64_t v113 = *(NSObject **)(v5 + 56);
          if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
          {
            std::string::size_type v125 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
            if (*(char *)(v5 + 207) < 0) {
              uint64_t v106 = (std::string *)v106->__r_.__value_.__r.__words[0];
            }
            LODWORD(values.__r_.__value_.__l.__data_) = 136315650;
            *(std::string::size_type *)((char *)values.__r_.__value_.__r.__words + 4) = v125;
            WORD2(values.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&values.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
            HIWORD(values.__r_.__value_.__r.__words[2]) = 2080;
            uint64_t v288 = v106;
            unint64_t v115 = "#I %s%sImpossible! No slots in assigments for account %s in storage";
LABEL_172:
            p_std::string values = &values;
LABEL_173:
            _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_DEFAULT, v115, (uint8_t *)p_values, 0x20u);
          }
        }
        else
        {
          uint64_t v113 = *(NSObject **)(v5 + 56);
          if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
          {
            std::string::size_type v124 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
            if (*(char *)(v5 + 207) < 0) {
              uint64_t v106 = (std::string *)v106->__r_.__value_.__r.__words[0];
            }
            LODWORD(values.__r_.__value_.__l.__data_) = 136315650;
            *(std::string::size_type *)((char *)values.__r_.__value_.__r.__words + 4) = v124;
            WORD2(values.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&values.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
            HIWORD(values.__r_.__value_.__r.__words[2]) = 2080;
            uint64_t v288 = v106;
            unint64_t v115 = "#I %s%sImpossible! Schema version mismatch for account %s";
            goto LABEL_172;
          }
        }
      }
      else
      {
        uint64_t v113 = *(NSObject **)(v5 + 56);
        if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v114 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
          if (*(char *)(v5 + 207) < 0) {
            uint64_t v106 = (std::string *)v106->__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::string buf = 136315650;
          *(void *)&uint8_t buf[4] = v114;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v106;
          unint64_t v115 = "#I %s%sImpossible! No assigments for account %s in storage";
          p_std::string values = (std::string *)buf;
          goto LABEL_173;
        }
      }
LABEL_174:
      sub_100057D78((const void **)&v289 + 1);
      goto LABEL_175;
    }
  }
  uint64_t v110 = *(NSObject **)(v5 + 56);
  if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v111 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
    uint64_t v112 = (void *)(v5 + 184);
    if (*(char *)(v5 + 207) < 0) {
      uint64_t v112 = (void *)*v112;
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v111;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v112;
    _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "#I %s%sAccount %s do not have data slots - bailout", buf, 0x20u);
  }
LABEL_175:
  std::mutex::lock((std::mutex *)(v5 + 496));
  if (*(void *)(v5 + 576)) {
    int v126 = sub_100080778;
  }
  else {
    int v126 = 0;
  }
  std::mutex::unlock((std::mutex *)(v5 + 496));
  if (!v126)
  {
    CFDictionaryRef v137 = (const __CFDictionary *)v283;
    if (CFDictionaryGetValue(v272, @"primarySubscriberId"))
    {
      if (CFDictionaryGetValue(v272, @"masterToken"))
      {
        int v138 = *(NSObject **)(v5 + 56);
        if (!os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_193;
        }
        uint64_t v139 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v139;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        int v140 = "#I %s%sMaster service token found";
        goto LABEL_192;
      }
      if (v137 && CFDictionaryGetValue(v137, @"token"))
      {
        int v138 = *(NSObject **)(v5 + 56);
        if (!os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
        {
LABEL_193:
          CFDictionaryRef v141 = (const __CFDictionary *)CFDictionaryGetValue(v272, @"CBRoot");
          CFDictionaryRef v142 = v141;
          if (!v141) {
            goto LABEL_309;
          }
          theDict.__r_.__value_.__r.__words[0] = (std::string::size_type)v141;
          CFRetain(v141);
          CFDictionaryRef v143 = (const __CFDictionary *)CFDictionaryGetValue(v272, @"imsCommonCredentials");
          CFDictionaryRef v144 = v143;
          if (v143)
          {
            CFTypeID v145 = CFGetTypeID(v143);
            if (v145 == CFDictionaryGetTypeID())
            {
              uint64_t v315 = 0;
              long long v313 = 0u;
              long long v314 = 0u;
              long long v311 = 0u;
              long long v312 = 0u;
              long long v309 = 0u;
              long long v310 = 0u;
              long long v307 = 0u;
              long long v308 = 0u;
              long long v305 = 0u;
              long long v306 = 0u;
              long long v303 = 0u;
              long long v304 = 0u;
              long long v301 = 0u;
              long long v302 = 0u;
              long long v299 = 0u;
              long long v300 = 0u;
              long long v297 = 0u;
              long long v298 = 0u;
              long long v295 = 0u;
              long long v296 = 0u;
              long long v293 = 0u;
              long long v294 = 0u;
              long long v291 = 0u;
              long long v292 = 0u;
              memset(buf, 0, sizeof(buf));
              sub_1003A5408((uint64_t)buf, v144);
              int v146 = CFDictionaryGetValue(v142, @"CarrierEntitlements");
              uint64_t v147 = v146;
              if (v146)
              {
                CFTypeID v148 = CFGetTypeID(v146);
                if (v148 == CFDictionaryGetTypeID())
                {
                  v280.__r_.__value_.__r.__words[0] = 0;
                  sub_10126B5B4((void **)&v280.__r_.__value_.__l.__data_, v147, (uint64_t)buf);
                  *(void *)&long long v316 = CFDictionaryCreateMutableCopy(0, 0, v142);
                  CFDictionarySetValue((CFMutableDictionaryRef)v316, @"CarrierEntitlements", v280.__r_.__value_.__l.__data_);
                  sub_10004EFE4(v278, (CFTypeRef *)&v316);
                  values.__r_.__value_.__r.__words[0] = theDict.__r_.__value_.__r.__words[0];
                  theDict.__r_.__value_.__l.__data_ = (std::string::pointer)v278[0];
                  v278[0] = 0;
                  sub_100057D78((const void **)&values.__r_.__value_.__l.__data_);
                  sub_100057D78((const void **)v278);
                  sub_10005717C((const void **)&v316);
                  sub_100057D78((const void **)&v280.__r_.__value_.__l.__data_);
                }
              }
              sub_10019D6E8((uint64_t)buf);
            }
          }
          std::mutex::lock((std::mutex *)(v5 + 496));
          sub_10126B404(v5, (CFDictionaryRef)theDict.__r_.__value_.__l.__data_);
          std::mutex::unlock((std::mutex *)(v5 + 496));
          sub_100057D78((const void **)&theDict.__r_.__value_.__l.__data_);
          memset(buf, 0, 24);
          ctu::cf::assign();
          std::string values = *(std::string *)buf;
          CarrierEntitlements::setSubscriberId();
          if (SHIBYTE(values.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(values.__r_.__value_.__l.__data_);
          }
          memset(buf, 0, 24);
          ctu::cf::assign();
          std::string values = *(std::string *)buf;
          CarrierEntitlements::setServiceToken();
          if (SHIBYTE(values.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(values.__r_.__value_.__l.__data_);
          }
          int v149 = *(NSObject **)(v5 + 56);
          if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v150 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = v150;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, "#I %s%sfCBRoot (basic) ready ->indicate", buf, 0x16u);
          }
          sub_101262D84(v5);
          uint64_t v151 = *(NSObject **)(v5 + 56);
          if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v152 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = v152;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I %s%sfCBRoot ready ->enable personality", buf, 0x16u);
          }
          int v153 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v5 + 120));
          uint64_t v154 = v153;
          if (v155 < 0)
          {
            uint64_t v156 = (unsigned __int8 *)(v155 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v157 = 5381;
            do
            {
              uint64_t v155 = v157;
              unsigned int v158 = *v156++;
              uint64_t v157 = (33 * v157) ^ v158;
            }
            while (v158);
          }
          std::mutex::lock(v153);
          *(void *)std::string buf = v155;
          uint64_t v159 = sub_10004D37C(&v154[1].__m_.__sig, (unint64_t *)buf);
          if (v159)
          {
            uint64_t v161 = v159[3];
            int v160 = (std::__shared_weak_count *)v159[4];
            if (v160)
            {
              atomic_fetch_add_explicit(&v160->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v154);
              atomic_fetch_add_explicit(&v160->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v160);
              char v162 = 0;
              goto LABEL_247;
            }
          }
          else
          {
            uint64_t v161 = 0;
          }
          std::mutex::unlock(v154);
          int v160 = 0;
          char v162 = 1;
LABEL_247:
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v161 + 64))(v161, **(void **)(v5 + 144) + 24, 1);
          if ((v162 & 1) == 0) {
            sub_10004D2C8(v160);
          }
          goto LABEL_179;
        }
        uint64_t v167 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v167;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        int v140 = "#I %s%sService token found";
LABEL_192:
        _os_log_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_DEFAULT, v140, buf, 0x16u);
        goto LABEL_193;
      }
      int v164 = *(NSObject **)(v5 + 56);
      if (!os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_309;
      }
      uint64_t v172 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v172;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      int v166 = "#I %s%sNo service-token found for the device, secondary entitlement controller cannot be provisioned";
    }
    else
    {
      int v164 = *(NSObject **)(v5 + 56);
      if (!os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_309;
      }
      uint64_t v165 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v165;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      int v166 = "#I %s%sNo subscriber ID, secondary entitlement contoller cannot be provisioned";
    }
    _os_log_impl((void *)&_mh_execute_header, v164, OS_LOG_TYPE_DEFAULT, v166, buf, 0x16u);
    goto LABEL_309;
  }
LABEL_179:
  if (!*v61 || !(*v61)[10].__r_.__value_.__s.__data_[16])
  {
    if (v271)
    {
      values.__r_.__value_.__r.__words[0] = 0;
      BOOL v127 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v5 + 120));
      int v128 = v127;
      if (v129 < 0)
      {
        int v130 = (unsigned __int8 *)(v129 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v131 = 5381;
        do
        {
          uint64_t v129 = v131;
          unsigned int v132 = *v130++;
          uint64_t v131 = (33 * v131) ^ v132;
        }
        while (v132);
      }
      std::mutex::lock(v127);
      *(void *)std::string buf = v129;
      double v133 = sub_10004D37C(&v128[1].__m_.__sig, (unint64_t *)buf);
      if (v133)
      {
        uint64_t v135 = v133[3];
        double v134 = (std::__shared_weak_count *)v133[4];
        if (v134)
        {
          atomic_fetch_add_explicit(&v134->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v128);
          atomic_fetch_add_explicit(&v134->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v134);
          char v136 = 0;
          goto LABEL_227;
        }
      }
      else
      {
        uint64_t v135 = 0;
      }
      std::mutex::unlock(v128);
      double v134 = 0;
      char v136 = 1;
LABEL_227:
      (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v135 + 24))(&theDict, v135, **(void **)(v5 + 144) + 24, @"LocalCredentials", kPhoneServicesWalletDomain, 0, 4);
      sub_10004EFE4(&values, (CFTypeRef *)&theDict.__r_.__value_.__l.__data_);
      sub_1000577C4((const void **)&theDict.__r_.__value_.__l.__data_);
      if ((v136 & 1) == 0) {
        sub_10004D2C8(v134);
      }
      if (values.__r_.__value_.__r.__words[0]) {
        int v168 = sub_100080778;
      }
      else {
        int v168 = 0;
      }
      if (v168) {
        operator new();
      }
      sub_101264EF0();
    }
    if (v283) {
      BOOL v163 = sub_100080778;
    }
    else {
      BOOL v163 = 0;
    }
    if (v163) {
      operator new();
    }
    if (*v61 && (*v61)[10].__r_.__value_.__s.__data_[16])
    {
      memset(&values, 0, sizeof(values));
      memset(&theDict, 0, sizeof(theDict));
      memset(&v280, 0, sizeof(v280));
      std::mutex::lock((std::mutex *)(v5 + 496));
      int v169 = *(const std::string **)(v5 + 560);
      if (v169)
      {
        std::string::operator=(&v280, v169);
        std::string::operator=(&values, (const std::string *)(*(void *)(v5 + 560) + 24));
        uint64_t v170 = *(long long **)(*(void *)(v5 + 560) + 48);
        if (*(long long **)(*(void *)(v5 + 560) + 56) == v170)
        {
          sub_100058DB0(buf, "");
        }
        else if (*((char *)v170 + 23) < 0)
        {
          sub_10004FC84(buf, *(void **)v170, *((void *)v170 + 1));
        }
        else
        {
          long long v171 = *v170;
          *(void *)&uint8_t buf[16] = *((void *)v170 + 2);
          *(_OWORD *)std::string buf = v171;
        }
        if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(theDict.__r_.__value_.__l.__data_);
        }
        std::string theDict = *(std::string *)buf;
      }
      std::mutex::unlock((std::mutex *)(v5 + 496));
      std::string::size_type size = HIBYTE(values.__r_.__value_.__r.__words[2]);
      if ((values.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = values.__r_.__value_.__l.__size_;
      }
      if (size) {
        goto LABEL_282;
      }
      if (*(unsigned char *)(v5 + 448) && *(unsigned char *)(v5 + 408))
      {
        uint64_t v174 = v5 + 384;
        if (*(char *)(v5 + 407) < 0)
        {
          p_std::string::size_type size = (unint64_t *)(v5 + 392);
LABEL_266:
          sub_10004FC84(buf, *(void **)v174, *p_size);
LABEL_267:
          if (SHIBYTE(values.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(values.__r_.__value_.__l.__data_);
          }
          std::string values = *(std::string *)buf;
          int v177 = *v61;
          if ((*v61)[7].__r_.__value_.__s.__data_[16])
          {
            if (v177[7].__r_.__value_.__s.__data_[15] < 0)
            {
              sub_10004FC84(buf, (void *)v177[6].__r_.__value_.__r.__words[2], v177[7].__r_.__value_.__r.__words[0]);
            }
            else
            {
              *(_OWORD *)std::string buf = *(_OWORD *)&v177[6].__r_.__value_.__r.__words[2];
              *(void *)&uint8_t buf[16] = v177[7].__r_.__value_.__l.__size_;
            }
          }
          else
          {
            sub_100058DB0(buf, "");
          }
          if (SHIBYTE(v280.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v280.__r_.__value_.__l.__data_);
          }
          std::string v280 = *(std::string *)buf;
          if (*(unsigned char *)(v5 + 448) && *(unsigned char *)(v5 + 440))
          {
            int v178 = (const std::string *)(v5 + 416);
          }
          else
          {
            if (!(*v61)[9].__r_.__value_.__s.__data_[0])
            {
              CFArrayRef v220 = (const __CFArray *)CFDictionaryGetValue(v272, @"impu");
              CFArrayRef v221 = v220;
              if (v220)
              {
                CFTypeID v222 = CFGetTypeID(v220);
                if (v222 == CFArrayGetTypeID())
                {
                  if (CFArrayGetCount(v221))
                  {
                    CFArrayGetValueAtIndex(v221, 0);
                    memset(buf, 0, 24);
                    ctu::cf::assign();
                    std::string::size_type v223 = *(void *)buf;
                    *(void *)&long long v316 = *(void *)&buf[8];
                    *(void *)((char *)&v316 + 7) = *(void *)&buf[15];
                    char v224 = buf[23];
                    if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(theDict.__r_.__value_.__l.__data_);
                    }
                    theDict.__r_.__value_.__r.__words[0] = v223;
                    theDict.__r_.__value_.__l.__size_ = v316;
                    *(std::string::size_type *)((char *)&theDict.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)&v316 + 7);
                    *((unsigned char *)&theDict.__r_.__value_.__s + 23) = v224;
                  }
                }
              }
              goto LABEL_282;
            }
            int v178 = *v61 + 8;
          }
          std::string::operator=(&theDict, v178);
LABEL_282:
          if (SHIBYTE(values.__r_.__value_.__r.__words[2]) < 0)
          {
            if (values.__r_.__value_.__l.__size_) {
              BOOL v179 = (const __CFString **)values.__r_.__value_.__r.__words[0];
            }
            else {
              BOOL v179 = 0;
            }
          }
          else if (*((unsigned char *)&values.__r_.__value_.__s + 23))
          {
            BOOL v179 = (const __CFString **)&values;
          }
          else
          {
            BOOL v179 = 0;
          }
          if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0)
          {
            if (theDict.__r_.__value_.__l.__size_) {
              p_std::string theDict = (const __CFString **)theDict.__r_.__value_.__r.__words[0];
            }
            else {
              p_std::string theDict = 0;
            }
          }
          else if (*((unsigned char *)&theDict.__r_.__value_.__s + 23))
          {
            p_std::string theDict = (const __CFString **)&theDict;
          }
          else
          {
            p_std::string theDict = 0;
          }
          if (SHIBYTE(v280.__r_.__value_.__r.__words[2]) < 0)
          {
            if (v280.__r_.__value_.__l.__size_) {
              unsigned int v181 = (const __CFString **)v280.__r_.__value_.__r.__words[0];
            }
            else {
              unsigned int v181 = 0;
            }
          }
          else if (*((unsigned char *)&v280.__r_.__value_.__s + 23))
          {
            unsigned int v181 = (const __CFString **)&v280;
          }
          else
          {
            unsigned int v181 = 0;
          }
          sub_10126790C(v5, v179, p_theDict, v181, 0, 0);
          sub_101268220(v5);
          if (SHIBYTE(v280.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v280.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(theDict.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(values.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(values.__r_.__value_.__l.__data_);
          }
          goto LABEL_309;
        }
      }
      else
      {
        int v176 = *v61;
        if (!(*v61)[5].__r_.__value_.__s.__data_[0])
        {
          sub_100058DB0(buf, "");
          goto LABEL_267;
        }
        uint64_t v174 = (uint64_t)&v176[4];
        if (SHIBYTE(v176[4].__r_.__value_.__r.__words[2]) < 0)
        {
          p_std::string::size_type size = &v176[4].__r_.__value_.__l.__size_;
          goto LABEL_266;
        }
      }
      *(_OWORD *)std::string buf = *(_OWORD *)v174;
      *(void *)&uint8_t buf[16] = *(void *)(v174 + 16);
      goto LABEL_267;
    }
  }
LABEL_309:
  sub_100057D78((const void **)&v283);
LABEL_310:
  if (*v61 && (*v61)[10].__r_.__value_.__s.__data_[16])
  {
    if (*(_DWORD *)(v5 + 260) == 2)
    {
      int v80 = sub_100A2EB74(*(void *)(v5 + 160), v18 | a2, 0);
      if (v80 == 1)
      {
        if (*(unsigned char *)(v5 + 456)) {
          int v76 = 0;
        }
        else {
          int v76 = sub_101266594(v5, v275);
        }
        int v77 = 1;
        int v79 = 1;
        int v80 = 1;
      }
      else
      {
        int v76 = 0;
        int v77 = 1;
        int v79 = 1;
      }
    }
    else
    {
      int v79 = 0;
      int v76 = 0;
      int v80 = -1;
      int v77 = 1;
    }
  }
  else
  {
    if (!sub_1012676AC(v5))
    {
      uint64_t v182 = **(PersonalityInfo ***)(v5 + 144);
      if (*((unsigned char *)v182 + 48))
      {
        uint64_t v183 = *(NSObject **)(v5 + 56);
        if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v184 = PersonalityInfo::logPrefix(v182);
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v184;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          _os_log_impl((void *)&_mh_execute_header, v183, OS_LOG_TYPE_DEFAULT, "#I %s%sno fCBRoot -> disable personality", buf, 0x16u);
        }
        sub_1003D59E4(*(Registry **)(v5 + 120), buf);
        (*(void (**)(void, uint64_t, void))(**(void **)buf + 64))(*(void *)buf, **(void **)(v5 + 144) + 24, 0);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
    }
    int v77 = 0;
    int v79 = 0;
    int v76 = 0;
    int v80 = -1;
  }
  v278[0] = 0;
  v278[1] = 0;
  int64_t v279 = 0;
  sub_100058DB0(buf, "match ");
  int v185 = *(char *)(v5 + 207);
  if (v185 >= 0) {
    uint64_t v186 = (const std::string::value_type *)(v5 + 184);
  }
  else {
    uint64_t v186 = *(const std::string::value_type **)(v5 + 184);
  }
  if (v185 >= 0) {
    std::string::size_type v187 = *(unsigned __int8 *)(v5 + 207);
  }
  else {
    std::string::size_type v187 = *(void *)(v5 + 192);
  }
  int v188 = std::string::append((std::string *)buf, v186, v187);
  long long v189 = *(_OWORD *)&v188->__r_.__value_.__l.__data_;
  int64_t v279 = v188->__r_.__value_.__r.__words[2];
  *(_OWORD *)uint64_t v278 = v189;
  v188->__r_.__value_.__l.__size_ = 0;
  v188->__r_.__value_.__r.__words[2] = 0;
  v188->__r_.__value_.__r.__words[0] = 0;
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  int v75 = 1;
LABEL_336:
  int v78 = 1;
LABEL_337:
  uint64_t v190 = *(NSObject **)(v5 + 56);
  if (os_log_type_enabled(v190, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v191 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
    int v192 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 224))(v5);
    uint64_t v193 = (char *)&unk_10161656E;
    unint64_t v194 = "Active";
    if (v192 != 1) {
      unint64_t v194 = (const char *)&unk_10161656E;
    }
    uint64_t v195 = *(int *)(v5 + 256);
    if (v195 <= 2) {
      uint64_t v193 = off_101AA4880[v195];
    }
    double v196 = "OFF";
    if (v59) {
      double v196 = "ON";
    }
    int v197 = *(unsigned __int8 *)(v5 + 456);
    *(_DWORD *)std::string buf = 136318722;
    if (!v192) {
      unint64_t v194 = "Disabled";
    }
    *(void *)&uint8_t buf[4] = v191;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v194;
    if (v274) {
      double v198 = "signed-in";
    }
    else {
      double v198 = "signed-out";
    }
    *(_WORD *)&unsigned char buf[32] = 2080;
    double v199 = v278;
    if (v279 < 0) {
      double v199 = (void **)v278[0];
    }
    *(void *)&buf[34] = v196;
    *(_WORD *)&buf[42] = 2080;
    *(void *)&buf[44] = v193;
    int v200 = "";
    if (v197) {
      int v201 = v76;
    }
    else {
      int v201 = 1;
    }
    *(_WORD *)&buf[52] = 2080;
    if (!v201) {
      int v200 = "*";
    }
    *(void *)&buf[54] = v198;
    *(_WORD *)&buf[62] = 1024;
    uint64_t v202 = "no";
    LODWORD(v291) = v78;
    WORD2(v291) = 2080;
    if (v273) {
      uint64_t v202 = "yes";
    }
    *(void *)((char *)&v291 + 6) = v199;
    HIWORD(v291) = 1024;
    LODWORD(v292) = v80;
    WORD2(v292) = 1024;
    *(_DWORD *)((char *)&v292 + 6) = v77;
    WORD5(v292) = 1024;
    HIDWORD(v292) = v79;
    LOWORD(v293) = 1024;
    *(_DWORD *)((char *)&v293 + 2) = v76;
    WORD3(v293) = 2080;
    *((void *)&v293 + 1) = v200;
    LOWORD(v294) = 1024;
    *(_DWORD *)((char *)&v294 + 2) = v197;
    WORD3(v294) = 2080;
    *((void *)&v294 + 1) = v202;
    _os_log_impl((void *)&_mh_execute_header, v190, OS_LOG_TYPE_DEFAULT, "#I %s%s+ state:%s switch:%s(%s) iCloud:%s paired:[%d] calledID:[%s] accountState:[%d] preprovisioned:[%d] serviceAllowed:[%d] provisioned:[%d%s] applied:[%d] reprovisioning:%s", buf, 0x80u);
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 224))(v5) == 1)
  {
    if ((v59 & v75 & v77) != 1 || v80 == -1 || (*(unsigned char *)(v5 + 456) ? (char v203 = 1) : (char v203 = v76), (v203 & 1) == 0)) {
      sub_101263664(v5, 0);
    }
  }
  int v204 = *(unsigned __int8 *)(v5 + 456);
  if (*(unsigned char *)(v5 + 456)) {
    int v205 = 0;
  }
  else {
    int v205 = v76;
  }
  if ((v75 & v205) == 1 && v80 == 1)
  {
    sub_1012650C8(v5, 1, v275);
    sub_101267708(v5, 1);
    int v204 = *(unsigned __int8 *)(v5 + 456);
  }
  if (v204 && (!v78 || v75 && (!v77 || *(unsigned char *)(**(void **)(v5 + 144) + 48) && v80 == -1))) {
    sub_1012650C8(v5, 0, 0);
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 224))(v5) != 1
    && v59
    && ((v75 ^ 1) & 1) == 0
    && *(unsigned char *)(v5 + 456)
    && *(unsigned char *)(**(void **)(v5 + 144) + 48))
  {
    sub_101263664(v5, 1);
  }
  (*(void (**)(unsigned char *__return_ptr, uint64_t, void))(*(void *)v5 + 200))(buf, v5, 0);
  int v206 = buf[0];
  sub_100057D78((const void **)&buf[8]);
  (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v5 + 192))(buf, v5);
  int v207 = buf[0];
  sub_100057D78((const void **)&buf[8]);
  if (*(unsigned __int8 *)(v5 + 672) != v206 || *(unsigned __int8 *)(v5 + 673) != v207)
  {
    *(_WORD *)(v5 + 672) = v206 | ((_WORD)v207 << 8);
    uint64_t v208 = *(void *)(v5 + 664);
    if (v208) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v208 + 48))(v208, v5 + 672);
    }
  }
  int v209 = *(NSObject **)(v5 + 56);
  if (os_log_type_enabled(v209, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v210 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
    int v211 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 224))(v5);
    int v212 = (const char *)&unk_10161656E;
    if (v211 == 1) {
      int v212 = "Active";
    }
    int v213 = *(unsigned __int8 *)(v5 + 456);
    *(_DWORD *)std::string buf = 136316418;
    *(void *)&uint8_t buf[4] = v210;
    if (!v211) {
      int v212 = "Disabled";
    }
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    if (v213) {
      int v214 = v76;
    }
    else {
      int v214 = 1;
    }
    *(_WORD *)&buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v212;
    int v215 = "";
    *(_WORD *)&unsigned char buf[32] = 1024;
    *(_DWORD *)&buf[34] = v76;
    *(_WORD *)&buf[38] = 2080;
    if (!v214) {
      int v215 = "*";
    }
    *(void *)&buf[40] = v215;
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = v213;
    _os_log_impl((void *)&_mh_execute_header, v209, OS_LOG_TYPE_DEFAULT, "#I %s%s- state:%s provisioned:[%d%s] applied:[%d]", buf, 0x36u);
  }
  uint64_t v216 = *(void *)(v5 + 160);
  if (!*(unsigned char *)(v216 + 353)
    && !*(unsigned char *)(v5 + 588)
    && !*(unsigned char *)(v5 + 589)
    && !*(unsigned char *)(v5 + 590)
    && !*(unsigned char *)(v5 + 591))
  {
    *(unsigned char *)(v5 + 592) = 0;
    sub_100A2FBE8((uint64_t *)v216, 1);
  }
  if (!*(unsigned char *)(v5 + 592)) {
    sub_100A2FD3C(*(void *)(v5 + 160), 1, 0);
  }
  if ((sub_100810848(v5) & 1) == 0)
  {
    if (*(unsigned char *)(**(void **)(v5 + 144) + 48)) {
      int v217 = v75;
    }
    else {
      int v217 = 0;
    }
    if ((v59 & v78 & v217) != 1
      || (*(unsigned int (**)(uint64_t))(*(void *)v5 + 224))(v5) == 1
      || (uint64_t v218 = *(void *)(v5 + 160), *(unsigned char *)(v218 + 353))
      || *(unsigned char *)(v5 + 588)
      || *(unsigned char *)(v5 + 589)
      || *(unsigned char *)(v5 + 590)
      || *(unsigned char *)(v5 + 591)
      || (int v219 = *(_DWORD *)(v5 + 260), sub_100A2EAC0(v218, v219)))
    {
      if (!v59 || (*(unsigned int (**)(uint64_t))(*(void *)v5 + 224))(v5) == 1) {
        *(unsigned char *)(v5 + 616) = 0;
      }
    }
    else if (!*(unsigned char *)(v5 + 616) && (v219 == 1 || v219 == 6 || v80 == -1))
    {
      double v225 = *(NSObject **)(v5 + 56);
      if (os_log_type_enabled(v225, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v226 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 144));
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v226;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v225, OS_LOG_TYPE_DEFAULT, "#I %s%sShowing UI popup", buf, 0x16u);
      }
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
      sub_101263598(&__p, *(Registry **)(v5 + 120));
      CFDictionaryRef v285 = 0;
      std::string::size_type v227 = __p.__r_.__value_.__r.__words[0];
      uint64_t v228 = kAlertDialogLocalizationTable;
      (*(void (**)(CFDictionaryRef *__return_ptr, std::string::size_type, void, const __CFString *, const __CFString *))(*(void *)__p.__r_.__value_.__l.__data_ + 40))(&v285, __p.__r_.__value_.__r.__words[0], kAlertDialogLocalizationTable, @"OK", @"OK");
      std::string::size_type v283 = 0;
      CFTypeRef cf = 0;
      sub_1005ABCB0(*(Registry **)(v5 + 120), buf);
      int v229 = (*(uint64_t (**)(void))(**(void **)buf + 64))(*(void *)buf);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (v229)
      {
        (*(void (**)(std::string *__return_ptr, std::string::size_type, uint64_t, const __CFString *, const __CFString *))(*(void *)v227 + 40))(&values, v227, v228, @"CANNOT_ACTIVATE_WLAN_CALLING", @"Cannot Activate WLAN Calling");
        *(void *)std::string buf = cf;
        CFTypeRef cf = (CFTypeRef)values.__r_.__value_.__r.__words[0];
        values.__r_.__value_.__r.__words[0] = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&values.__r_.__value_.__l.__data_);
        (*(void (**)(std::string *__return_ptr, std::string::size_type, uint64_t, const __CFString *, const __CFString *))(*(void *)v227 + 40))(&values, v227, v228, @"CONTACT_CARRIER_TO_ENABLE_WLAN_CALLS_FORMAT", @"To enable WLAN Calls on this account, contact your primary device carrier");
      }
      else
      {
        (*(void (**)(std::string *__return_ptr, std::string::size_type, uint64_t, const __CFString *, const __CFString *))(*(void *)v227 + 40))(&values, v227, v228, @"CANNOT_ACTIVATE_WIFI_CALLING", @"Cannot Activate Wi-Fi Calling");
        *(void *)std::string buf = cf;
        CFTypeRef cf = (CFTypeRef)values.__r_.__value_.__r.__words[0];
        values.__r_.__value_.__r.__words[0] = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&values.__r_.__value_.__l.__data_);
        (*(void (**)(std::string *__return_ptr, std::string::size_type, uint64_t, const __CFString *, const __CFString *))(*(void *)v227 + 40))(&values, v227, v228, @"CONTACT_CARRIER_TO_ENABLE_WIFI_CALLS_FORMAT", @"To enable Wi-Fi Calls on this account, contact your primary device carrier");
      }
      *(void *)std::string buf = v283;
      std::string::size_type v283 = values.__r_.__value_.__r.__words[0];
      values.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&values.__r_.__value_.__l.__data_);
      memset(&values, 0, sizeof(values));
      memset(buf, 0, 24);
      ctu::cf::assign();
      std::string values = *(std::string *)buf;
      unint64_t v244 = sub_100195000((uint64_t *)&values, "%s", 0);
      if (v244 != -1)
      {
        std::string::size_type v245 = v244;
        CFStringRef v282 = @"carrier";
        CFRetain(@"carrier");
        double v246 = *(void **)(v5 + 160);
        if (v246)
        {
          *(void *)std::string buf = 0;
          if (v246) {
            double v246 = (void *)(*(uint64_t (**)(void *))(*(void *)v246 + 112))(v246);
          }
        }
        *(void *)std::string buf = v246;
        theDict.__r_.__value_.__r.__words[0] = 0;
        if (v246) {
          unint64_t v247 = sub_100080778;
        }
        else {
          unint64_t v247 = 0;
        }
        if (v247)
        {
          if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v246, @"CarrierName", (const void **)&theDict.__r_.__value_.__l.__data_))
          {
            if (theDict.__r_.__value_.__r.__words[0])
            {
              CFTypeID v248 = CFGetTypeID(theDict.__r_.__value_.__l.__data_);
              if (v248 == CFStringGetTypeID())
              {
                v280.__r_.__value_.__r.__words[0] = theDict.__r_.__value_.__r.__words[0];
                sub_1012678BC((const void **)&v282, (CFTypeRef *)&v280.__r_.__value_.__l.__data_);
              }
            }
          }
        }
        sub_100057D78((const void **)buf);
        std::string::basic_string(&v280, &values, 0, v245, (std::allocator<char> *)buf);
        memset(buf, 0, 24);
        ctu::cf::assign();
        long long v316 = *(_OWORD *)buf;
        uint64_t v317 = *(void *)&buf[16];
        if (buf[23] >= 0) {
          double v249 = (const std::string::value_type *)&v316;
        }
        else {
          double v249 = (const std::string::value_type *)v316;
        }
        if (buf[23] >= 0) {
          std::string::size_type v250 = HIBYTE(v317);
        }
        else {
          std::string::size_type v250 = *((void *)&v316 + 1);
        }
        double v251 = std::string::append(&v280, v249, v250);
        long long v252 = *(_OWORD *)&v251->__r_.__value_.__l.__data_;
        theDict.__r_.__value_.__r.__words[2] = v251->__r_.__value_.__r.__words[2];
        *(_OWORD *)&theDict.__r_.__value_.__l.__data_ = v252;
        v251->__r_.__value_.__l.__size_ = 0;
        v251->__r_.__value_.__r.__words[2] = 0;
        v251->__r_.__value_.__r.__words[0] = 0;
        std::string::basic_string((std::string *)buf, &values, v245 + 2, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v286);
        if (buf[23] >= 0) {
          double v253 = buf;
        }
        else {
          double v253 = *(const std::string::value_type **)buf;
        }
        if (buf[23] >= 0) {
          std::string::size_type v254 = buf[23];
        }
        else {
          std::string::size_type v254 = *(void *)&buf[8];
        }
        uint64_t v255 = std::string::append(&theDict, v253, v254);
        std::string::size_type v256 = v255->__r_.__value_.__r.__words[0];
        *(void *)&long long v289 = v255->__r_.__value_.__l.__size_;
        *(void *)((char *)&v289 + 7) = *(std::string::size_type *)((char *)&v255->__r_.__value_.__r.__words[1] + 7);
        char v257 = HIBYTE(v255->__r_.__value_.__r.__words[2]);
        v255->__r_.__value_.__l.__size_ = 0;
        v255->__r_.__value_.__r.__words[2] = 0;
        v255->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(values.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(values.__r_.__value_.__l.__data_);
        }
        values.__r_.__value_.__r.__words[0] = v256;
        values.__r_.__value_.__l.__size_ = v289;
        *(std::string::size_type *)((char *)&values.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)&v289 + 7);
        *((unsigned char *)&values.__r_.__value_.__s + 23) = v257;
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(theDict.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v317) < 0) {
          operator delete((void *)v316);
        }
        if (SHIBYTE(v280.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v280.__r_.__value_.__l.__data_);
        }
        if ((values.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          int v258 = &values;
        }
        else {
          int v258 = (std::string *)values.__r_.__value_.__r.__words[0];
        }
        CFStringRef v259 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v258, 0x8000100u);
        std::string::size_type v260 = v283;
        std::string::size_type v283 = (std::string::size_type)v259;
        *(void *)std::string buf = v260;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&v282);
      }
      sub_1002BD030(*(Registry **)(v5 + 120), buf);
      (*(void (**)(void, CFTypeRef, std::string::size_type, CFDictionaryRef))(**(void **)buf + 32))(*(void *)buf, cf, v283, v285);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      *(unsigned char *)(v5 + 616) = 1;
      if (SHIBYTE(values.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(values.__r_.__value_.__l.__data_);
      }
      sub_1000558F4((const void **)&v283);
      sub_1000558F4(&cf);
      sub_1000558F4((const void **)&v285);
      if (__p.__r_.__value_.__l.__size_) {
        sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
      }
    }
  }
  if (SHIBYTE(v279) < 0) {
    operator delete(v278[0]);
  }
  return sub_100057D78((const void **)&v275);
}

void sub_101261548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, const void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,const void *a37,const void *a38,const void *a39,const void *a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51)
{
  if (a47 < 0) {
    operator delete(a42);
  }
  sub_1000558F4(&a38);
  sub_1000558F4(&a39);
  sub_1000558F4(&a40);
  if (a20) {
    sub_10004D2C8((std::__shared_weak_count *)a20);
  }
  if (a28 < 0) {
    operator delete(__p);
  }
  sub_100057D78(&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_101261B30(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101261B4C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_101261B5C(uint64_t a1)
{
}

BOOL sub_101261B64(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sloading initial states", buf, 0x16u);
  }
  uint64_t v4 = sub_101262800(a1);
  sub_101262A00(a1, HIDWORD(v4));
  *(_DWORD *)(a1 + 260) = 2;
  getAssociatedID(__p);
  uint64_t v5 = (void *)(a1 + 264);
  if ((void **)(a1 + 264) != __p)
  {
    *(void *)std::string buf = *v5;
    void *v5 = __p[0];
    __p[0] = 0;
    sub_1000558F4((const void **)buf);
  }
  sub_1000558F4((const void **)__p);
  int v6 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    *(_OWORD *)std::string __p = *(_OWORD *)buf;
    uint64_t v91 = *(void *)&buf[16];
    uint64_t v9 = *(void ***)buf;
    if ((buf[23] & 0x80u) == 0) {
      uint64_t v9 = __p;
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&buf[22] = 2080;
    char v93 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sLoaded AssociatedAccountID '%s'", buf, 0x20u);
    unsigned int v7 = (uint64_t *)SHIBYTE(v91);
    if ((v7 & 0x80000000) != 0) {
      operator delete(__p[0]);
    }
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(a1 + 120));
  unsigned int v11 = ServiceMap;
  uint64_t v13 = v12;
  if (v12 < 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v13;
  CFStringRef v17 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
  if (v17)
  {
    uint64_t v19 = v17[3];
    int v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v11);
  int v18 = 0;
  char v20 = 1;
LABEL_18:
  uint64_t v21 = kPhoneServicesWalletDomain;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, void, void, void, uint64_t))(*(void *)v19 + 24))(__p, v19, **(void **)(a1 + 144) + 24, kCFPSReprovisioningRequired, kPhoneServicesWalletDomain, 0, 1);
  uint64_t v22 = (BOOL *)__p[0];
  buf[0] = 0;
  if (__p[0])
  {
    CFTypeID v23 = CFGetTypeID(__p[0]);
    if (v23 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, v22, v24);
    }
    int v25 = buf[0];
  }
  else
  {
    int v25 = 0;
  }
  sub_1000577C4((const void **)__p);
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  if (!v25)
  {
    std::mutex::lock((std::mutex *)(a1 + 496));
    __p[0] = 0;
    uint64_t v27 = (std::mutex *)Registry::getServiceMap(v26, *(Registry **)(a1 + 120));
    uint64_t v28 = v27;
    uint64_t v29 = v12;
    if (v12 < 0)
    {
      uint64_t v30 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v31 = 5381;
      do
      {
        uint64_t v29 = v31;
        unsigned int v32 = *v30++;
        uint64_t v31 = (33 * v31) ^ v32;
      }
      while (v32);
    }
    std::mutex::lock(v27);
    *(void *)std::string buf = v29;
    uint64_t v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)buf);
    if (v33)
    {
      uint64_t v35 = v33[3];
      uint64_t v34 = (std::__shared_weak_count *)v33[4];
      if (v34)
      {
        atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v28);
        atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v34);
        char v36 = 0;
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v35 = 0;
    }
    std::mutex::unlock(v28);
    uint64_t v34 = 0;
    char v36 = 1;
LABEL_34:
    (*(void (**)(CFDictionaryRef *__return_ptr, uint64_t, uint64_t, void, uint64_t, void, uint64_t))(*(void *)v35 + 24))(&theDict, v35, **(void **)(a1 + 144) + 24, kCFLocalProvisioningApplied, v21, 0, 1);
    sub_1000057AC(__p, (CFTypeRef *)&theDict);
    sub_1000577C4((const void **)&theDict);
    if ((v36 & 1) == 0) {
      sub_10004D2C8(v34);
    }
    buf[0] = 0;
    ctu::cf::assign((ctu::cf *)buf, (BOOL *)__p[0], v37);
    uint64_t v38 = (uint64_t *)buf[0];
    *(unsigned char *)(a1 + 456) = buf[0];
    if (!v38) {
      goto LABEL_93;
    }
    unsigned int v39 = (std::mutex *)Registry::getServiceMap(v38, *(Registry **)(a1 + 120));
    uint64_t v40 = v39;
    uint64_t v41 = v12;
    if (v12 < 0)
    {
      uint64_t v42 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v43 = 5381;
      do
      {
        uint64_t v41 = v43;
        unsigned int v44 = *v42++;
        uint64_t v43 = (33 * v43) ^ v44;
      }
      while (v44);
    }
    std::mutex::lock(v39);
    *(void *)std::string buf = v41;
    uint64_t v45 = sub_10004D37C(&v40[1].__m_.__sig, (unint64_t *)buf);
    if (v45)
    {
      uint64_t v47 = v45[3];
      uint64_t v46 = (std::__shared_weak_count *)v45[4];
      if (v46)
      {
        atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v40);
        atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v46);
        char v48 = 0;
        goto LABEL_45;
      }
    }
    else
    {
      uint64_t v47 = 0;
    }
    std::mutex::unlock(v40);
    uint64_t v46 = 0;
    char v48 = 1;
LABEL_45:
    (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t, void, uint64_t))(*(void *)v47 + 24))(&v88, v47, **(void **)(a1 + 144) + 24, @"CarrierBundle", v21, 0, 4);
    sub_10004EFE4(&theDict, &v88);
    char v49 = (CFDictionaryRef *)(a1 + 576);
    if ((CFDictionaryRef *)(a1 + 576) != &theDict)
    {
      *(void *)std::string buf = *v49;
      CFDictionaryRef *v49 = theDict;
      CFDictionaryRef theDict = 0;
      sub_100057D78((const void **)buf);
    }
    sub_100057D78((const void **)&theDict);
    sub_1000577C4(&v88);
    if ((v48 & 1) == 0) {
      sub_10004D2C8(v46);
    }
    CFDictionaryRef v50 = *v49;
    if (*v49) {
      unsigned int v51 = sub_100080778;
    }
    else {
      unsigned int v51 = 0;
    }
    if (!v51)
    {
LABEL_71:
      if (v50) {
        uint64_t v65 = sub_100080778;
      }
      else {
        uint64_t v65 = 0;
      }
      if (!v65 || !*(void *)(a1 + 560))
      {
        *(void *)(a1 + 576) = 0;
        *(void *)std::string buf = v50;
        sub_100057D78((const void **)buf);
        *(unsigned char *)(a1 + 456) = 0;
        CFDictionaryRef v50 = *(CFDictionaryRef *)(a1 + 576);
      }
      if (v50) {
        uint64_t v66 = sub_100080778;
      }
      else {
        uint64_t v66 = 0;
      }
      if (!v66) {
        goto LABEL_93;
      }
      sub_101262D84(a1);
      uint64_t v67 = *(NSObject **)(a1 + 56);
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v69 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v69;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I %s%spreloaded fCBRoot in place -> enable personality", buf, 0x16u);
      }
      uint64_t v70 = (std::mutex *)Registry::getServiceMap(v68, *(Registry **)(a1 + 120));
      uint64_t v71 = v70;
      if (v72 < 0)
      {
        uint64_t v73 = (unsigned __int8 *)(v72 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v74 = 5381;
        do
        {
          uint64_t v72 = v74;
          unsigned int v75 = *v73++;
          uint64_t v74 = (33 * v74) ^ v75;
        }
        while (v75);
      }
      std::mutex::lock(v70);
      *(void *)std::string buf = v72;
      int v76 = sub_10004D37C(&v71[1].__m_.__sig, (unint64_t *)buf);
      if (v76)
      {
        uint64_t v78 = v76[3];
        int v77 = (std::__shared_weak_count *)v76[4];
        if (v77)
        {
          atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v71);
          atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v77);
          char v79 = 0;
          goto LABEL_91;
        }
      }
      else
      {
        uint64_t v78 = 0;
      }
      std::mutex::unlock(v71);
      int v77 = 0;
      char v79 = 1;
LABEL_91:
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v78 + 64))(v78, **(void **)(a1 + 144) + 24, 1);
      if ((v79 & 1) == 0) {
        sub_10004D2C8(v77);
      }
LABEL_93:
      sub_100062778((const void **)__p);
      std::mutex::unlock((std::mutex *)(a1 + 496));
      goto LABEL_94;
    }
    uint64_t v52 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v54 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v54;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I %s%sLoaded CB from local store", buf, 0x16u);
    }
    CFDictionaryRef theDict = 0;
    char v55 = (std::mutex *)Registry::getServiceMap(v53, *(Registry **)(a1 + 120));
    uint64_t v56 = v55;
    if (v12 < 0)
    {
      BOOL v57 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v58 = 5381;
      do
      {
        uint64_t v12 = v58;
        unsigned int v59 = *v57++;
        uint64_t v58 = (33 * v58) ^ v59;
      }
      while (v59);
    }
    std::mutex::lock(v55);
    *(void *)std::string buf = v12;
    int64x2_t v60 = sub_10004D37C(&v56[1].__m_.__sig, (unint64_t *)buf);
    if (v60)
    {
      uint64_t v62 = v60[3];
      uint64_t v61 = (std::__shared_weak_count *)v60[4];
      if (v61)
      {
        atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v56);
        atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v61);
        char v63 = 0;
LABEL_63:
        (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t, void, uint64_t))(*(void *)v62 + 24))(&v88, v62, **(void **)(a1 + 144) + 24, @"IMSInfo", v21, 0, 4);
        sub_10004EFE4(&theDict, &v88);
        sub_1000577C4(&v88);
        if ((v63 & 1) == 0) {
          sub_10004D2C8(v61);
        }
        if (theDict) {
          uint64_t v64 = sub_100080778;
        }
        else {
          uint64_t v64 = 0;
        }
        if (v64) {
          operator new();
        }
        sub_100057D78((const void **)&theDict);
        CFDictionaryRef v50 = *v49;
        goto LABEL_71;
      }
    }
    else
    {
      uint64_t v62 = 0;
    }
    std::mutex::unlock(v56);
    uint64_t v61 = 0;
    char v63 = 1;
    goto LABEL_63;
  }
LABEL_94:
  int v80 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v81 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    uint64_t v82 = *(int *)(a1 + 256);
    if (v82 > 2) {
      double v83 = (char *)&unk_10161656E;
    }
    else {
      double v83 = off_101AA4880[v82];
    }
    std::string::size_type v84 = (void *)(a1 + 184);
    if (*(char *)(a1 + 207) < 0) {
      std::string::size_type v84 = (void *)*v84;
    }
    uint64_t v85 = asStringBool(*(unsigned char *)(a1 + 456));
    uint64_t v86 = asStringBool(v25 != 0);
    *(_DWORD *)std::string buf = 136316418;
    *(void *)&uint8_t buf[4] = v81;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&buf[22] = 2080;
    char v93 = v83;
    __int16 v94 = 2080;
    uint64_t v95 = v84;
    __int16 v96 = 2080;
    uint64_t v97 = v85;
    __int16 v98 = 2080;
    uint64_t v99 = v86;
    _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I %s%sBootup switch is:%s, account ID:%s, fProvisioningApplied:%s, reprovisioningNeeded:%s", buf, 0x3Eu);
  }
  BOOL result = v25 != 0;
  *(unsigned char *)(a1 + 593) = 1;
  return result;
}

void sub_101262634(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  sub_100057D78(&a10);
  sub_100062778(&a11);
  std::mutex::unlock(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_101262800(uint64_t a1)
{
  if (sub_1007FA824(*(void **)(a1 + 168)))
  {
    CFTypeID v23 = 0;
    CFDictionaryRef theDict = 0;
    uint64_t v2 = *(void **)(a1 + 168);
    uint64_t v3 = sub_1007FA824(v2);
    sub_1007FFAA4(v2, 2, (void **)(a1 + 184), v3, &v23);
    if (theDict) {
      uint64_t v4 = sub_100080778;
    }
    else {
      uint64_t v4 = 0;
    }
    if (!v4)
    {
      uint64_t v15 = 0;
      uint64_t v16 = 0;
LABEL_37:
      sub_100057D78((const void **)&theDict);
      return v16 & 0x300000000 | v15;
    }
    if (CFDictionaryGetValue(theDict, @"account"))
    {
      long long v25 = 0uLL;
      unint64_t v26 = 0;
      ctu::cf::assign();
      unint64_t v22 = v26;
      *(_OWORD *)std::string __p = v25;
      uint64_t v5 = *(void *)(a1 + 192);
      int v6 = *(char *)(a1 + 207);
      unint64_t v7 = HIBYTE(v26);
      if ((v26 & 0x8000000000000000) == 0) {
        unint64_t v8 = HIBYTE(v26);
      }
      else {
        unint64_t v8 = *((void *)&v25 + 1);
      }
      if (v6 >= 0) {
        uint64_t v5 = *(unsigned __int8 *)(a1 + 207);
      }
      if (v8 != v5)
      {
        if ((v26 & 0x8000000000000000) != 0) {
          operator delete(__p[0]);
        }
        goto LABEL_35;
      }
      if (v6 >= 0) {
        uint64_t v9 = (unsigned __int8 *)(a1 + 184);
      }
      else {
        uint64_t v9 = *(unsigned __int8 **)(a1 + 184);
      }
      if ((v26 & 0x8000000000000000) != 0)
      {
        int v17 = memcmp(__p[0], v9, *((size_t *)&v25 + 1));
        operator delete(__p[0]);
        if (v17) {
          goto LABEL_35;
        }
      }
      else if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = v7 - 1;
        do
        {
          int v12 = *((unsigned __int8 *)__p + v10);
          int v13 = v9[v10];
        }
        while (v12 == v13 && v11 != v10++);
        if (v12 != v13) {
          goto LABEL_35;
        }
      }
    }
    CFTypeRef Value = (BOOL *)CFDictionaryGetValue(theDict, @"enable");
    if (Value)
    {
      LOBYTE(v25) = 0;
      ctu::cf::assign((ctu::cf *)&v25, Value, v19);
      if ((_BYTE)v25) {
        uint64_t v16 = 0x200000000;
      }
      else {
        uint64_t v16 = (uint64_t)&_mh_execute_header;
      }
      goto LABEL_36;
    }
LABEL_35:
    uint64_t v16 = 0;
LABEL_36:
    uint64_t v15 = 1;
    goto LABEL_37;
  }
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  return v16 & 0x300000000 | v15;
}

void sub_1012629D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_100057D78(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_101262A00(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = (uint64_t *)*(unsigned int *)(a1 + 256);
  if (v2 == a2) {
    return 0;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)(a1 + 120));
  unint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint64_t v27 = v8;
  int v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)v27);
  if (v12)
  {
    uint64_t v14 = (GestaltUtilityInterface *)v12[3];
    int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  int v13 = 0;
  char v15 = 1;
LABEL_11:
  int isWatch = GestaltUtilityInterface::isWatch(v14);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (isWatch)
  {
    int v17 = *(NSObject **)(a1 + 56);
    BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v18)
    {
      uint64_t v19 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      if (a2 > 2) {
        char v20 = (char *)&unk_10161656E;
      }
      else {
        char v20 = off_101AA4880[a2];
      }
      *(_DWORD *)uint64_t v27 = 136315650;
      *(void *)&v27[4] = v19;
      __int16 v28 = 2080;
      uint64_t v29 = " ";
      __int16 v30 = 2080;
      uint64_t v31 = v20;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#W %s%sThumper: user switch state on Watch cannot be changed from 'Default'. Attempted:'%s'", v27, 0x20u);
      return 0;
    }
  }
  else
  {
    uint64_t v21 = *(int *)(a1 + 256);
    *(_DWORD *)(a1 + 256) = a2;
    unint64_t v22 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      if (v21 > 2) {
        CFBooleanRef v24 = (char *)&unk_10161656E;
      }
      else {
        CFBooleanRef v24 = off_101AA4880[v21];
      }
      uint64_t v25 = *(int *)(a1 + 256);
      if (v25 > 2) {
        unint64_t v26 = (char *)&unk_10161656E;
      }
      else {
        unint64_t v26 = off_101AA4880[v25];
      }
      *(_DWORD *)uint64_t v27 = 136315906;
      *(void *)&v27[4] = v23;
      __int16 v28 = 2080;
      uint64_t v29 = " ";
      __int16 v30 = 2080;
      uint64_t v31 = v24;
      __int16 v32 = 2080;
      uint64_t v33 = v26;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s%sThumper: user switch state changed from %s -> %s", v27, 0x2Au);
    }
    return 1;
  }
  return result;
}

void sub_101262C9C(_Unwind_Exception *exception_object)
{
}

void sub_101262CD0()
{
}

void sub_101262D58(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_100350940(v1);
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

const void **sub_101262D84(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v14 = (const void *)v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v14);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 72))(v10, **(void **)(a1 + 144) + 24);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  uint64_t v12 = *(void *)(a1 + 680);
  PersonalityInfo::uuid((uint64_t *)&v14, **(PersonalityInfo ***)(a1 + 144));
  (*(void (**)(uint64_t, const void *))(*(void *)v12 + 24))(v12, v14);
  return sub_10012577C(&v14);
}

void sub_101262EDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10012577C((const void **)va);
  _Unwind_Resume(a1);
}

void sub_101262F08(uint64_t a1)
{
  (*(void (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 168) + 152) + 24))(*(void *)(*(void *)(a1 + 168) + 152), a1 + 184);
  if (sub_1007FA824(*(void **)(a1 + 168)) && !*(unsigned char *)(a1 + 593))
  {
    sub_101261B64(a1);
    *(void *)std::string buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_10003E168(buf, (void *)(a1 + 88));
    operator new();
  }
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sPostpone loading initial states until device-ID is ready", buf, 0x16u);
  }
  sub_10003E168(buf, (void *)(a1 + 88));
  uint64_t v4 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v4);
  }
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10017B514();
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_10126317C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1012631BC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[5])
      {
        uint64_t v5 = a1[6];
        if (v5) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
        }
        v6[0] = 0;
        v6[1] = 0;
        sub_10003E168(v6, (void *)(v3 + 88));
        operator new();
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1012632FC(uint64_t a1)
{
}

void sub_101263304(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  if (sub_10001D294(a2, (unsigned __int8 *)(**(void **)(a1 + 144) + 24)))
  {
    uint64_t v5 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      int v25 = 136315394;
      uint64_t v26 = v6;
      __int16 v27 = 2080;
      __int16 v28 = " ";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%s================================ Evaluate Entitlement Update ================================", (uint8_t *)&v25, 0x16u);
    }
    uint64_t v9 = *(void *)(a3 + 8);
    uint64_t v8 = a3 + 8;
    uint64_t v7 = v9;
    if (v9)
    {
      uint64_t v10 = v8;
      do
      {
        int v11 = *(_DWORD *)(v7 + 28);
        BOOL v12 = v11 < 8;
        if (v11 >= 8) {
          int v13 = (uint64_t *)v7;
        }
        else {
          int v13 = (uint64_t *)(v7 + 8);
        }
        if (!v12) {
          uint64_t v10 = v7;
        }
        uint64_t v7 = *v13;
      }
      while (*v13);
      if (v10 != v8 && *(int *)(v10 + 28) <= 8)
      {
        int v14 = *(_DWORD *)(v10 + 32);
        int v15 = *(_DWORD *)(a1 + 260);
        uint64_t v16 = *(NSObject **)(a1 + 56);
        BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
        if (v14 == 3 || v14 == v15)
        {
          if (v17)
          {
            uint64_t v19 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
            if ((v14 - 1) > 5) {
              char v20 = "???";
            }
            else {
              char v20 = off_101AA4898[v14 - 1];
            }
            int v25 = 136315650;
            uint64_t v26 = v19;
            __int16 v27 = 2080;
            __int16 v28 = " ";
            __int16 v29 = 2080;
            __int16 v30 = v20;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%sThumper Entitlement:%s - no change", (uint8_t *)&v25, 0x20u);
          }
        }
        else
        {
          if (v17)
          {
            uint64_t v21 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
            unsigned int v22 = *(_DWORD *)(a1 + 260) - 1;
            if (v22 > 5) {
              uint64_t v23 = "???";
            }
            else {
              uint64_t v23 = off_101AA4898[v22];
            }
            if ((v14 - 1) > 5) {
              CFBooleanRef v24 = "???";
            }
            else {
              CFBooleanRef v24 = off_101AA4850[v14 - 1];
            }
            int v25 = 136315906;
            uint64_t v26 = v21;
            __int16 v27 = 2080;
            __int16 v28 = " ";
            __int16 v29 = 2080;
            __int16 v30 = v23;
            __int16 v31 = 2080;
            __int16 v32 = v24;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%sThumper entitlement is changing from %s to %s", (uint8_t *)&v25, 0x2Au);
          }
          *(_DWORD *)(a1 + 260) = v14;
          sub_10125E354((const void **)a1, 0, 0);
        }
      }
    }
  }
}

void sub_101263598(void *a1, Registry *this)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(this);
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v12);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v4);
  *a1 = v11;
  a1[1] = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
}

void sub_101263664(uint64_t a1, int a2)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 224))(a1) != a2)
  {
    std::mutex::lock((std::mutex *)(a1 + 496));
    int v4 = *(_DWORD *)(a1 + 584);
    *(_DWORD *)(a1 + 584) = a2;
    unint64_t v5 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      int v7 = *(_DWORD *)(a1 + 584);
      unsigned int v8 = "Active";
      if (v4 == 1) {
        uint64_t v9 = "Active";
      }
      else {
        uint64_t v9 = (const char *)&unk_10161656E;
      }
      if (v7 != 1) {
        unsigned int v8 = (const char *)&unk_10161656E;
      }
      if (v4) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = "Disabled";
      }
      BOOL v11 = v7 == 0;
      if (v7) {
        unint64_t v12 = "on";
      }
      else {
        unint64_t v12 = "off";
      }
      if (v11) {
        int v13 = "Disabled";
      }
      else {
        int v13 = v8;
      }
      int v14 = (void *)(a1 + 184);
      if (*(char *)(a1 + 207) < 0) {
        int v14 = (void *)*v14;
      }
      *(_DWORD *)std::string buf = 136316418;
      *(void *)&uint8_t buf[4] = v6;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v12;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = v10;
      *(_WORD *)&buf[42] = 2080;
      *(void *)&buf[44] = v13;
      *(_WORD *)&buf[52] = 2080;
      *(void *)&buf[54] = v14;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sservice:%s, status:%s->%s, account id:%s", buf, 0x3Eu);
    }
    std::mutex::unlock((std::mutex *)(a1 + 496));
  }
  int v15 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    BOOL v17 = "OFF";
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v16;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[12] = 2080;
    if (a2) {
      BOOL v17 = "ON";
    }
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v17;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%sTHUMPER %s", buf, 0x20u);
  }
  if (a2 && (sub_100810848(a1) & 1) == 0)
  {
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 720) + 8))(buf);
    BOOL v18 = *(void *)buf ? sub_100080934 : 0;
    sub_1000577C4((const void **)buf);
    if (!v18)
    {
      uint64_t v19 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
      char v20 = dispatch_queue_create("LocationPopupQueue", v19);
      uint64_t v21 = *(NSObject **)(a1 + 56);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v22 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v22;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%sShowing popup to indicate location use during emergency calls", buf, 0x16u);
      }
      if (*(void *)(a1 + 728))
      {
        uint64_t v23 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v24 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v24;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s%sAlready showing a location popup!", buf, 0x16u);
        }
LABEL_64:
        if (v20) {
          dispatch_release(v20);
        }
        (***(void (****)(void, const CFBooleanRef))(a1 + 720))(*(void *)(a1 + 720), kCFBooleanTrue);
        goto LABEL_67;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
      uint64_t v26 = ServiceMap;
      if (v27 < 0)
      {
        __int16 v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v29 = 5381;
        do
        {
          uint64_t v27 = v29;
          unsigned int v30 = *v28++;
          uint64_t v29 = (33 * v29) ^ v30;
        }
        while (v30);
      }
      std::mutex::lock(ServiceMap);
      *(void *)std::string buf = v27;
      __int16 v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)buf);
      if (v31)
      {
        uint64_t v33 = v31[3];
        __int16 v32 = (std::__shared_weak_count *)v31[4];
        if (v32)
        {
          atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v26);
          atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v32);
          char v34 = 0;
LABEL_44:
          if (v33)
          {
            context[0] = 0;
            uint64_t v35 = kCBMessageLocalizationTable;
            (*(void (**)(void ***__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v33 + 40))(context, v33, kCBMessageLocalizationTable, @"THUMPER_EMERGENCY_ADDRESS_INFO_TITLE", @"Your Location Will Be Used to Make Emergency Calls");
            uint64_t v129 = 0;
            (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v33 + 40))(&v129, v33, v35, @"THUMPER_EMERGENCY_ADDRESS_INFO_MESSAGE", @"Your carrier may route emergency services based on your current location or your address on file. You can update your emergency address information in FaceTime settings.");
            uint64_t v131 = 0;
            (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v33 + 40))(&v131, v33, v35, @"OK", @"OK");
            CFDictionaryRef v118 = 0;
            (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v33 + 40))(&v118, v33, v35, @"SETTINGS", @"Settings");
            uint64_t v36 = *(void *)(a1 + 104);
            if (v36) {
              dispatch_retain(*(dispatch_object_t *)(a1 + 104));
            }
            sub_10003E168(buf, (void *)(a1 + 88));
            uint64_t v38 = *(void *)buf;
            CFBooleanRef v37 = *(std::__shared_weak_count **)&buf[8];
            if (*(void *)&buf[8])
            {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
              sub_10004D2C8(v37);
            }
            unsigned int v39 = operator new(0x78uLL);
            v39[1] = 0;
            int64x2_t v39[2] = 0;
            void *v39 = off_1019AE920;
            *(void *)__src = v20;
            if (v20) {
              dispatch_retain(v20);
            }
            uint64_t v40 = operator new(0x28uLL);
            *uint64_t v40 = off_101AA45E8;
            v40[1] = a1;
            v40[2] = v36;
            void v40[3] = v38;
            v40[4] = v37;
            *(void *)&uint8_t buf[24] = v40;
            sub_1001D7AC4((uint64_t)(v39 + 3), (const void **)context, &v129, &v131, &v118, __src, (uint64_t)buf);
            sub_1000DA3EC(buf);
            if (*(void *)__src) {
              dispatch_release(*(dispatch_object_t *)__src);
            }
            CFDictionaryRef v119 = (long long *)(v39 + 3);
            CFIndex v120 = v39;
            sub_1000B3BC8((uint64_t)&v119, v39 + 4, (uint64_t)(v39 + 3));
            uint64_t v42 = v119;
            uint64_t v41 = (atomic_ullong *)v120;
            CFDictionaryRef v119 = 0;
            CFIndex v120 = 0;
            *(void *)(a1 + 728) = v42;
            uint64_t v43 = *(std::__shared_weak_count **)(a1 + 736);
            *(void *)(a1 + 736) = v41;
            if (v43)
            {
              sub_10004D2C8(v43);
              if (v120) {
                sub_10004D2C8((std::__shared_weak_count *)v120);
              }
              uint64_t v41 = *(atomic_ullong **)(a1 + 736);
            }
            if (v41) {
              atomic_fetch_add_explicit(v41 + 1, 1uLL, memory_order_relaxed);
            }
            operator new();
          }
          unsigned int v44 = *(NSObject **)(a1 + 56);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v45 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = v45;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#W %s%sLocalization interface doesn't exist. Bailing!", buf, 0x16u);
          }
          if ((v34 & 1) == 0) {
            sub_10004D2C8(v32);
          }
          goto LABEL_64;
        }
      }
      else
      {
        uint64_t v33 = 0;
      }
      std::mutex::unlock(v26);
      __int16 v32 = 0;
      char v34 = 1;
      goto LABEL_44;
    }
  }
LABEL_67:
  uint64_t v46 = *(void *)(a1 + 160);
  int v47 = *(_DWORD *)(a1 + 584);
  if (*(char *)(a1 + 207) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 184), *(void *)(a1 + 192));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 184);
    uint64_t v114 = *(void *)(a1 + 200);
  }
  int v48 = (*(uint64_t (**)(uint64_t, uint64_t, BOOL, void **))(*(void *)v46 + 448))(v46, 1, v47 == 1, __p);
  int v49 = v48;
  if (SHIBYTE(v114) < 0)
  {
    operator delete(__p[0]);
    if (!v49) {
      return;
    }
  }
  else if (!v48)
  {
    return;
  }
  ResetAllPacketHandlersAPNs((Registry *)0xC, 0xFFFFFFFFLL, 0);
  if (a2)
  {
    uint64_t v129 = 0;
    CFDictionaryRef theDict = 0;
    sub_1007FFAA4(*(void **)(a1 + 168), 0, (void **)(a1 + 184), 0, &v129);
    if (theDict) {
      CFDictionaryRef v50 = sub_100080778;
    }
    else {
      CFDictionaryRef v50 = 0;
    }
    if (!v50)
    {
LABEL_186:
      sub_100057D78((const void **)&theDict);
      return;
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"emergencyNumbers");
    if (Value)
    {
      memset(__src, 0, sizeof(__src));
      CFIndex v120 = 0;
      uint64_t v121 = 0;
      CFDictionaryRef v119 = (long long *)&v120;
      *(void *)&uint8_t buf[8] = 0;
      *(void *)&uint8_t buf[16] = 0;
      context[1] = (void **)&buf[8];
      *(void *)std::string buf = &buf[8];
      context[0] = (void **)buf;
      CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)sub_101271EFC, context);
      int64x2_t v53 = v119;
      uint64_t v52 = v120;
      CFDictionaryRef v119 = *(long long **)buf;
      CFIndex v120 = *(void **)&buf[8];
      *(void *)std::string buf = v53;
      *(void *)&uint8_t buf[8] = v52;
      uint64_t v54 = v121;
      uint64_t v121 = *(void *)&buf[16];
      *(void *)&uint8_t buf[16] = v54;
      if (v121) {
        char v55 = (long long **)((char *)v120 + 16);
      }
      else {
        char v55 = &v119;
      }
      *char v55 = (long long *)&v120;
      if (v54) {
        uint64_t v56 = (uint8_t *)(v52 + 2);
      }
      else {
        uint64_t v56 = buf;
      }
      *(void *)uint64_t v56 = &buf[8];
      sub_100720C08((uint64_t)buf, v52);
      BOOL v57 = v120;
      *(void *)__src = v119;
      *(void *)&__src[8] = v120;
      *(void *)&__src[16] = v121;
      if (v121)
      {
        *((void *)v120 + 2) = &__src[8];
        CFDictionaryRef v119 = (long long *)&v120;
        CFIndex v120 = 0;
        uint64_t v121 = 0;
        BOOL v57 = 0;
      }
      else
      {
        *(void *)__src = &__src[8];
      }
      sub_100720C08((uint64_t)&v119, v57);
      uint64_t v70 = *(uint8_t **)__src;
      if (*(uint8_t **)__src != &__src[8])
      {
        while (1)
        {
          if ((v70[55] & 0x80u) == 0) {
            uint64_t v71 = (const char *)(v70 + 32);
          }
          else {
            uint64_t v71 = (const char *)*((void *)v70 + 4);
          }
          uint64_t v72 = atoi(v71);
          CFDictionaryRef v119 = 0;
          CFIndex v120 = 0;
          uint64_t v121 = 0;
          sub_1000302C0((char *)&v119, *((long long **)v70 + 7), *((long long **)v70 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v70 + 8) - *((void *)v70 + 7)) >> 3));
          uint64_t v73 = *(NSObject **)(a1 + 56);
          if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v74 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
            unsigned int v75 = v119;
            int v76 = v120;
            uint64_t v77 = asString();
            *(_DWORD *)std::string buf = 136315906;
            *(void *)&uint8_t buf[4] = v74;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2048;
            *(void *)&uint8_t buf[24] = 0xAAAAAAAAAAAAAAABLL * ((v76 - (unsigned char *)v75) >> 3);
            *(_WORD *)&unsigned char buf[32] = 2080;
            *(void *)&buf[34] = v77;
            _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "#I %s%sAdding %zu %s emergency number(s) from iCloud", buf, 0x2Au);
          }
          uint64_t v78 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
          char v79 = v78;
          if (v80 < 0)
          {
            uint64_t v81 = (unsigned __int8 *)(v80 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v82 = 5381;
            do
            {
              uint64_t v80 = v82;
              unsigned int v83 = *v81++;
              uint64_t v82 = (33 * v82) ^ v83;
            }
            while (v83);
          }
          std::mutex::lock(v78);
          *(void *)std::string buf = v80;
          std::string::size_type v84 = sub_10004D37C(&v79[1].__m_.__sig, (unint64_t *)buf);
          if (!v84) {
            break;
          }
          uint64_t v86 = v84[3];
          uint64_t v85 = (std::__shared_weak_count *)v84[4];
          if (!v85) {
            goto LABEL_114;
          }
          atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v79);
          atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v85);
          char v87 = 0;
LABEL_115:
          memset(buf, 0, 24);
          sub_1000302C0((char *)buf, v119, (long long *)v120, 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)v120 - (unsigned char *)v119) >> 3));
          (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t))(*(void *)v86 + 56))(v86, v72, buf, 1);
          context[0] = (void **)buf;
          sub_100047F64(context);
          if ((v87 & 1) == 0) {
            sub_10004D2C8(v85);
          }
          context[0] = (void **)&v119;
          sub_100047F64(context);
          long long v88 = (uint8_t *)*((void *)v70 + 1);
          if (v88)
          {
            do
            {
              uint64_t v89 = v88;
              long long v88 = *(uint8_t **)v88;
            }
            while (v88);
          }
          else
          {
            do
            {
              uint64_t v89 = (uint8_t *)*((void *)v70 + 2);
              BOOL v11 = *(void *)v89 == (void)v70;
              uint64_t v70 = v89;
            }
            while (!v11);
          }
          uint64_t v70 = v89;
          if (v89 == &__src[8]) {
            goto LABEL_123;
          }
        }
        uint64_t v86 = 0;
LABEL_114:
        std::mutex::unlock(v79);
        uint64_t v85 = 0;
        char v87 = 1;
        goto LABEL_115;
      }
LABEL_123:
      sub_100720C08((uint64_t)__src, *(void **)&__src[8]);
    }
    if (!CFDictionaryGetValue(theDict, @"preferredEmergencyNumber"))
    {
LABEL_158:
      int v103 = operator new(0x10uLL);
      *(void *)&uint8_t buf[8] = v103 + 2;
      *(void *)&uint8_t buf[16] = v103 + 2;
      void *v103 = @"IMSConfig";
      v103[1] = @"EmergencyNumbersOverWifiOnly";
      *(void *)std::string buf = v103;
      CFDictionaryRef v118 = 0;
      sub_10126B808(a1, (uint64_t *)buf, 0, (ctu::cf **)&cf);
      context[0] = (void **)cf;
      if (cf) {
        CFRetain(cf);
      }
      uint64_t v131 = 0;
      *(void *)__src = 0;
      sub_100044D6C(__src, (CFTypeRef *)context);
      if (*(void *)__src) {
        uint64_t v104 = sub_100083F10;
      }
      else {
        uint64_t v104 = 0;
      }
      if (v104) {
        sub_100449580(&v131, (const void **)__src);
      }
      sub_100044D00((const void **)__src);
      CFDictionaryRef v118 = v131;
      uint64_t v131 = 0;
      sub_100044D00(&v131);
      sub_1000577C4((const void **)context);
      sub_1000577C4(&cf);
      if (v118) {
        uint64_t v105 = sub_100083F10;
      }
      else {
        uint64_t v105 = 0;
      }
      if (!v105)
      {
        uint64_t v106 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v107 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
          *(_DWORD *)__src = 136315394;
          *(void *)&__src[4] = v107;
          *(_WORD *)&__src[12] = 2080;
          *(void *)&__src[14] = " ";
          _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "#I %s%sEmergency numbers over Wifi-only missing!!!", __src, 0x16u);
        }
      }
      *(void *)__src = @"IMSConfig";
      *(void *)&__src[8] = @"LocalShortCodeNumbers";
      sub_10015C6C8((char *)buf, (char *)__src, (uint64_t)&__src[16], 2uLL);
      int64_t v116 = 0;
      sub_10126B808(a1, (uint64_t *)buf, 0, (ctu::cf **)&v115);
      context[0] = (void **)v115;
      if (v115) {
        CFRetain(v115);
      }
      uint64_t v131 = 0;
      *(void *)__src = 0;
      sub_100044D6C(__src, (CFTypeRef *)context);
      if (*(void *)__src) {
        int v108 = sub_100083F10;
      }
      else {
        int v108 = 0;
      }
      if (v108) {
        sub_100449580(&v131, (const void **)__src);
      }
      sub_100044D00((const void **)__src);
      uint64_t v109 = v131;
      int64_t v116 = v131;
      uint64_t v131 = 0;
      sub_100044D00(&v131);
      sub_1000577C4((const void **)context);
      sub_1000577C4(&v115);
      if (v109) {
        uint64_t v110 = sub_100083F10;
      }
      else {
        uint64_t v110 = 0;
      }
      if (!v110)
      {
        uint64_t v111 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v112 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
          *(_DWORD *)__src = 136315394;
          *(void *)&__src[4] = v112;
          *(_WORD *)&__src[12] = 2080;
          *(void *)&__src[14] = " ";
          _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I %s%sLocalShortCodeNumbers missing!!!", __src, 0x16u);
        }
      }
      sub_100044D00(&v116);
      sub_100044D00(&v118);
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
      goto LABEL_186;
    }
    memset(__src, 0, sizeof(__src));
    memset(buf, 0, 24);
    ctu::cf::assign();
    *(_OWORD *)__src = *(_OWORD *)buf;
    *(void *)&__src[16] = *(void *)&buf[16];
    std::string::size_type v90 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v91 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      long long v92 = __src;
      if ((__src[23] & 0x80u) != 0) {
        long long v92 = *(uint8_t **)__src;
      }
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = v91;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v92;
      _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "#I %s%sSetting preferred emergency number from iCloud: %s", buf, 0x20u);
    }
    uint64_t v138 = 0;
    long long v136 = 0u;
    long long v137 = 0u;
    *(_OWORD *)double v134 = 0u;
    *(_OWORD *)uint64_t v135 = 0u;
    memset(buf, 0, sizeof(buf));
    CSIPhoneNumber::CSIPhoneNumber();
    char v93 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
    __int16 v94 = v93;
    if (v95 < 0)
    {
      __int16 v96 = (unsigned __int8 *)(v95 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v97 = 5381;
      do
      {
        uint64_t v95 = v97;
        unsigned int v98 = *v96++;
        uint64_t v97 = (33 * v97) ^ v98;
      }
      while (v98);
    }
    std::mutex::lock(v93);
    CFDictionaryRef v119 = (long long *)v95;
    uint64_t v99 = sub_10004D37C(&v94[1].__m_.__sig, (unint64_t *)&v119);
    if (v99)
    {
      uint64_t v101 = v99[3];
      CFArrayRef v100 = (std::__shared_weak_count *)v99[4];
      if (v100)
      {
        atomic_fetch_add_explicit(&v100->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v94);
        atomic_fetch_add_explicit(&v100->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v100);
        char v102 = 0;
        if (!v101) {
          goto LABEL_146;
        }
        goto LABEL_138;
      }
    }
    else
    {
      uint64_t v101 = 0;
    }
    std::mutex::unlock(v94);
    CFArrayRef v100 = 0;
    char v102 = 1;
    if (!v101)
    {
LABEL_146:
      if ((v102 & 1) == 0) {
        sub_10004D2C8(v100);
      }
      if (SHIBYTE(v136) < 0) {
        operator delete(v135[1]);
      }
      if (SHIBYTE(v135[0]) < 0) {
        operator delete(v134[0]);
      }
      if ((char)buf[55] < 0) {
        operator delete(*(void **)&buf[32]);
      }
      if ((char)buf[31] < 0) {
        operator delete(*(void **)&buf[8]);
      }
      if ((char)__src[23] < 0) {
        operator delete(*(void **)__src);
      }
      goto LABEL_158;
    }
LABEL_138:
    sub_10009DB3C((uint64_t)&v119, (uint64_t)buf);
    (*(void (**)(uint64_t, long long **, uint64_t))(*(void *)v101 + 104))(v101, &v119, 1);
    if (v128 < 0) {
      operator delete(v127);
    }
    if (v126 < 0) {
      operator delete(v125);
    }
    if (v124 < 0) {
      operator delete(v123);
    }
    if (v122 < 0) {
      operator delete(v120);
    }
    goto LABEL_146;
  }
  uint64_t v58 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
  unsigned int v59 = v58;
  if (v60 < 0)
  {
    uint64_t v61 = (unsigned __int8 *)(v60 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v62 = 5381;
    do
    {
      uint64_t v60 = v62;
      unsigned int v63 = *v61++;
      uint64_t v62 = (33 * v62) ^ v63;
    }
    while (v63);
  }
  std::mutex::lock(v58);
  *(void *)std::string buf = v60;
  uint64_t v64 = sub_10004D37C(&v59[1].__m_.__sig, (unint64_t *)buf);
  if (!v64)
  {
    uint64_t v66 = 0;
    goto LABEL_95;
  }
  uint64_t v66 = v64[3];
  uint64_t v65 = (std::__shared_weak_count *)v64[4];
  if (!v65)
  {
LABEL_95:
    std::mutex::unlock(v59);
    uint64_t v65 = 0;
    char v67 = 1;
    goto LABEL_96;
  }
  atomic_fetch_add_explicit(&v65->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v59);
  atomic_fetch_add_explicit(&v65->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v65);
  char v67 = 0;
LABEL_96:
  (*(void (**)(uint64_t))(*(void *)v66 + 64))(v66);
  if ((v67 & 1) == 0) {
    sub_10004D2C8(v65);
  }
  unsigned int v68 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v69 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v69;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I %s%siCloud emergency number(s) removed", buf, 0x16u);
  }
}

void sub_101264878(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,int a21,__int16 a22,char a23,char a24,int a25,__int16 a26,char a27,char a28,int a29,__int16 a30,char a31,char a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,void *__p,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if ((v65 & 1) == 0) {
    sub_10004D2C8(v64);
  }
  if (v63) {
    dispatch_release(v63);
  }
  _Unwind_Resume(a1);
}

void sub_101264B68(uint64_t a1, long long **a2)
{
  int v4 = *a2;
  unint64_t v5 = *(NSObject **)(a1 + 56);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      uint64_t v7 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)uint64_t v29 = 136315394;
      *(void *)&v29[4] = v7;
      __int16 v30 = 2080;
      __int16 v31 = " ";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sSaved credentials", v29, 0x16u);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
    uint64_t v9 = ServiceMap;
    if (v10 < 0)
    {
      BOOL v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)uint64_t v29 = v10;
    int v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)v29);
    if (v14)
    {
      uint64_t v16 = v14[3];
      int v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    int v15 = 0;
    char v17 = 1;
LABEL_20:
    uint64_t v28 = **(void **)(a1 + 144);
    sub_1003A5938(*a2, (CFMutableDictionaryRef *)v29);
    (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, void, uint64_t, void))(*(void *)v16 + 16))(v16, v28 + 24, @"LocalCredentials", *(void *)v29, kPhoneServicesWalletDomain, 0, 4, 0);
    sub_10005717C((const void **)v29);
    if (v17) {
      return;
    }
    goto LABEL_21;
  }
  if (v6)
  {
    uint64_t v18 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    *(_DWORD *)uint64_t v29 = 136315394;
    *(void *)&v29[4] = v18;
    __int16 v30 = 2080;
    __int16 v31 = " ";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sErased credentials", v29, 0x16u);
  }
  uint64_t v19 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
  char v20 = v19;
  if (v21 < 0)
  {
    uint64_t v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v23 = 5381;
    do
    {
      uint64_t v21 = v23;
      unsigned int v24 = *v22++;
      uint64_t v23 = (33 * v23) ^ v24;
    }
    while (v24);
  }
  std::mutex::lock(v19);
  *(void *)uint64_t v29 = v21;
  int v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)v29);
  if (v25)
  {
    uint64_t v26 = v25[3];
    int v15 = (std::__shared_weak_count *)v25[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v20);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v27 = 0;
      goto LABEL_25;
    }
  }
  else
  {
    uint64_t v26 = 0;
  }
  std::mutex::unlock(v20);
  int v15 = 0;
  char v27 = 1;
LABEL_25:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v26 + 32))(v26, **(void **)(a1 + 144) + 24, @"LocalCredentials", kPhoneServicesWalletDomain, 0, 4);
  if (v27) {
    return;
  }
LABEL_21:
  sub_10004D2C8(v15);
}

void sub_101264EA0(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101264EF0()
{
}

void sub_101264F78(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_101271C88(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_101264F90(uint64_t a1)
{
  if (*(void *)(a1 + 264)) {
    uint64_t v1 = sub_1000810B8;
  }
  else {
    uint64_t v1 = 0;
  }
  if (!v1) {
    return 1;
  }
  long long v19 = 0uLL;
  uint64_t v20 = 0;
  ctu::cf::assign();
  uint64_t v18 = 0;
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v3 = *(unsigned __int8 *)(a1 + 207);
  if ((v3 & 0x80u) == 0) {
    int v4 = (void *)*(unsigned __int8 *)(a1 + 207);
  }
  else {
    int v4 = *(void **)(a1 + 192);
  }
  unint64_t v5 = (void *)HIBYTE(v18);
  if (v18 < 0) {
    unint64_t v5 = __p[1];
  }
  if (v4 != v5) {
    return 0;
  }
  BOOL v6 = (const void **)(a1 + 184);
  uint64_t v7 = __p;
  if ((v3 & 0x80) != 0) {
    return memcmp(*v6, __p, *(void *)(a1 + 192)) == 0;
  }
  if (!*(unsigned char *)(a1 + 207)) {
    return 1;
  }
  uint64_t v8 = v3 - 1;
  do
  {
    int v10 = *(unsigned __int8 *)v6;
    BOOL v6 = (const void **)((char *)v6 + 1);
    int v9 = v10;
    int v12 = *(unsigned __int8 *)v7;
    uint64_t v7 = (void **)((char *)v7 + 1);
    int v11 = v12;
    BOOL v14 = v8-- != 0;
    BOOL v15 = v9 == v11;
  }
  while (v9 == v11 && v14);
  return v15;
}

void sub_1012650AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1012650C8(uint64_t a1, int a2, CFDictionaryRef theDict)
{
  if (!a2) {
    goto LABEL_47;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"imsCommonCredentials");
  if (!Value || (v7 = Value, CFTypeID v8 = CFGetTypeID(Value), v8 != CFDictionaryGetTypeID()))
  {
    int v9 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)uint64_t v91 = 136315394;
      *(void *)&void v91[4] = v10;
      *(_WORD *)&v91[12] = 2080;
      *(void *)&v91[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sims common credentials are unavailable", v91, 0x16u);
    }
    goto LABEL_47;
  }
  uint64_t v118 = 0;
  long long v116 = 0u;
  long long v117 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  long long v112 = 0u;
  long long v113 = 0u;
  long long v110 = 0u;
  long long v111 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  memset(v91, 0, sizeof(v91));
  sub_1003A5408((uint64_t)v91, v7);
  uint64_t v86 = 0;
  if (*(unsigned char *)(a1 + 344))
  {
    v89[0] = 0;
    v89[1] = 0;
    sub_1008A95DC();
  }
  v89[0] = 0;
  CFDataRef v11 = (const __CFData *)CFDictionaryGetValue(theDict, @"ePdgCACert");
  CFDataRef v12 = v11;
  if (v11)
  {
    CFTypeID v13 = CFGetTypeID(v11);
    if (v13 == CFDataGetTypeID())
    {
      BytePtr = (char *)CFDataGetBytePtr(v12);
      __p[0] = 0;
      __p[1] = 0;
      sub_100058DB0(buf, BytePtr);
      sub_1008A95DC();
    }
  }
  *(void *)&long long v90 = 0;
  sub_101268AE4(&v90, a1, theDict, v86, 0, (uint64_t)v91);
  if ((void)v90) {
    BOOL v15 = sub_100080778;
  }
  else {
    BOOL v15 = 0;
  }
  if (v15)
  {
    __p[0] = 0;
    std::mutex::lock((std::mutex *)(a1 + 496));
    sub_100058140((const void **)(a1 + 576), (const void **)&v90);
    IMSInfo::serialize(*(IMSInfo **)(a1 + 560), &v88);
    *(void *)std::string buf = 0;
    __p[0] = v88;
    long long v88 = 0;
    sub_100057D78((const void **)buf);
    sub_100057D78((const void **)&v88);
    std::mutex::unlock((std::mutex *)(a1 + 496));
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
    char v17 = ServiceMap;
    uint64_t v19 = v18;
    if (v18 < 0)
    {
      uint64_t v20 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        uint64_t v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v19;
    uint64_t v23 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)buf);
    if (v23)
    {
      uint64_t v25 = v23[3];
      unsigned int v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v17);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        char v26 = 0;
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    std::mutex::unlock(v17);
    unsigned int v24 = 0;
    char v26 = 1;
LABEL_25:
    uint64_t v29 = kPhoneServicesWalletDomain;
    (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, void, uint64_t, void))(*(void *)v25 + 16))(v25, **(void **)(a1 + 144) + 24, @"CarrierBundle", v90, kPhoneServicesWalletDomain, 0, 4, 0);
    if ((v26 & 1) == 0) {
      sub_10004D2C8(v24);
    }
    __int16 v30 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
    __int16 v31 = v30;
    if (v18 < 0)
    {
      __int16 v32 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v33 = 5381;
      do
      {
        uint64_t v18 = v33;
        unsigned int v34 = *v32++;
        uint64_t v33 = (33 * v33) ^ v34;
      }
      while (v34);
    }
    std::mutex::lock(v30);
    *(void *)std::string buf = v18;
    uint64_t v35 = sub_10004D37C(&v31[1].__m_.__sig, (unint64_t *)buf);
    if (v35)
    {
      uint64_t v37 = v35[3];
      uint64_t v36 = (std::__shared_weak_count *)v35[4];
      if (v36)
      {
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v31);
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v36);
        char v38 = 0;
LABEL_35:
        (*(void (**)(uint64_t, uint64_t, const __CFString *, void *, uint64_t, void, uint64_t, void))(*(void *)v37 + 16))(v37, **(void **)(a1 + 144) + 24, @"IMSInfo", __p[0], v29, 0, 4, 0);
        if ((v38 & 1) == 0) {
          sub_10004D2C8(v36);
        }
        unsigned int v39 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v40 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v40;
          __int16 v120 = 2080;
          uint64_t v121 = " ";
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I %s%sThumper provisioning applied", buf, 0x16u);
        }
        sub_100057D78((const void **)__p);
        goto LABEL_40;
      }
    }
    else
    {
      uint64_t v37 = 0;
    }
    std::mutex::unlock(v31);
    uint64_t v36 = 0;
    char v38 = 1;
    goto LABEL_35;
  }
  char v27 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v28 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v28;
    __int16 v120 = 2080;
    uint64_t v121 = " ";
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I %s%sUnable to compile CB - bailout", buf, 0x16u);
  }
LABEL_40:
  sub_100057D78((const void **)&v90);
  sub_1000558F4(v89);
  sub_1000558F4(&v86);
  sub_10019D6E8((uint64_t)v91);
  if (v15)
  {
    *(unsigned char *)(a1 + 456) = 1;
    uint64_t v41 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
    uint64_t v42 = v41;
    if (v43 < 0)
    {
      unsigned int v44 = (unsigned __int8 *)(v43 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v45 = 5381;
      do
      {
        uint64_t v43 = v45;
        unsigned int v46 = *v44++;
        uint64_t v45 = (33 * v45) ^ v46;
      }
      while (v46);
    }
    std::mutex::lock(v41);
    *(void *)uint64_t v91 = v43;
    int v47 = sub_10004D37C(&v42[1].__m_.__sig, (unint64_t *)v91);
    if (v47)
    {
      uint64_t v49 = v47[3];
      int v48 = (std::__shared_weak_count *)v47[4];
      if (v48)
      {
        atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v42);
        atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v48);
        char v50 = 0;
LABEL_100:
        (*(void (**)(uint64_t, uint64_t, void, const CFBooleanRef, void, void, uint64_t, void))(*(void *)v49 + 16))(v49, **(void **)(a1 + 144) + 24, kCFLocalProvisioningApplied, kCFBooleanTrue, kPhoneServicesWalletDomain, 0, 1, 0);
        if ((v50 & 1) == 0) {
          sub_10004D2C8(v48);
        }
        sub_101262D84(a1);
        return;
      }
    }
    else
    {
      uint64_t v49 = 0;
    }
    std::mutex::unlock(v42);
    int v48 = 0;
    char v50 = 1;
    goto LABEL_100;
  }
LABEL_47:
  std::mutex::lock((std::mutex *)(a1 + 496));
  unsigned int v51 = *(std::__shared_weak_count **)(a1 + 568);
  *(_OWORD *)(a1 + 560) = 0u;
  if (v51) {
    sub_10004D2C8(v51);
  }
  sub_10126B404(a1, *(CFDictionaryRef *)(a1 + 576));
  std::mutex::unlock((std::mutex *)(a1 + 496));
  uint64_t v52 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
  int64x2_t v53 = v52;
  uint64_t v55 = v54;
  if (v54 < 0)
  {
    uint64_t v56 = (unsigned __int8 *)(v54 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v57 = 5381;
    do
    {
      uint64_t v55 = v57;
      unsigned int v58 = *v56++;
      uint64_t v57 = (33 * v57) ^ v58;
    }
    while (v58);
  }
  std::mutex::lock(v52);
  *(void *)uint64_t v91 = v55;
  unsigned int v59 = sub_10004D37C(&v53[1].__m_.__sig, (unint64_t *)v91);
  if (v59)
  {
    uint64_t v61 = v59[3];
    uint64_t v60 = (std::__shared_weak_count *)v59[4];
    if (v60)
    {
      atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v53);
      atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v60);
      char v62 = 0;
      goto LABEL_57;
    }
  }
  else
  {
    uint64_t v61 = 0;
  }
  std::mutex::unlock(v53);
  uint64_t v60 = 0;
  char v62 = 1;
LABEL_57:
  uint64_t v63 = kPhoneServicesWalletDomain;
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v61 + 32))(v61, **(void **)(a1 + 144) + 24, @"CarrierBundle", kPhoneServicesWalletDomain, 0, 4);
  if ((v62 & 1) == 0) {
    sub_10004D2C8(v60);
  }
  uint64_t v64 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
  char v65 = v64;
  uint64_t v66 = v54;
  if (v54 < 0)
  {
    char v67 = (unsigned __int8 *)(v54 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v68 = 5381;
    do
    {
      uint64_t v66 = v68;
      unsigned int v69 = *v67++;
      uint64_t v68 = (33 * v68) ^ v69;
    }
    while (v69);
  }
  std::mutex::lock(v64);
  *(void *)uint64_t v91 = v66;
  uint64_t v70 = sub_10004D37C(&v65[1].__m_.__sig, (unint64_t *)v91);
  if (v70)
  {
    uint64_t v72 = v70[3];
    uint64_t v71 = (std::__shared_weak_count *)v70[4];
    if (v71)
    {
      atomic_fetch_add_explicit(&v71->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v65);
      atomic_fetch_add_explicit(&v71->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v71);
      char v73 = 0;
      goto LABEL_67;
    }
  }
  else
  {
    uint64_t v72 = 0;
  }
  std::mutex::unlock(v65);
  uint64_t v71 = 0;
  char v73 = 1;
LABEL_67:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, uint64_t, void, uint64_t))(*(void *)v72 + 32))(v72, **(void **)(a1 + 144) + 24, @"IMSInfo", v63, 0, 4);
  if ((v73 & 1) == 0) {
    sub_10004D2C8(v71);
  }
  if (*(unsigned char *)(a1 + 448))
  {
    *(void *)(a1 + 312) = off_101A4D3B8;
    if (*(unsigned char *)(a1 + 440) && *(char *)(a1 + 439) < 0) {
      operator delete(*(void **)(a1 + 416));
    }
    if (*(unsigned char *)(a1 + 408) && *(char *)(a1 + 407) < 0) {
      operator delete(*(void **)(a1 + 384));
    }
    if (*(unsigned char *)(a1 + 376) && *(char *)(a1 + 375) < 0) {
      operator delete(*(void **)(a1 + 352));
    }
    if (*(unsigned char *)(a1 + 344) && *(char *)(a1 + 343) < 0) {
      operator delete(*(void **)(a1 + 320));
    }
    *(unsigned char *)(a1 + 448) = 0;
  }
  uint64_t v74 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v75 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    int v76 = "removed";
    *(_DWORD *)uint64_t v91 = 136315650;
    *(void *)&void v91[4] = v75;
    *(_WORD *)&v91[12] = 2080;
    *(void *)&v91[14] = " ";
    if (a2) {
      int v76 = "cannot be applied";
    }
    *(_WORD *)&v91[22] = 2080;
    *(void *)&v91[24] = v76;
    _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I %s%sThumper provisioning %s", v91, 0x20u);
  }
  *(unsigned char *)(a1 + 456) = 0;
  uint64_t v77 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
  uint64_t v78 = v77;
  if (v54 < 0)
  {
    char v79 = (unsigned __int8 *)(v54 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v80 = 5381;
    do
    {
      uint64_t v54 = v80;
      unsigned int v81 = *v79++;
      uint64_t v80 = (33 * v80) ^ v81;
    }
    while (v81);
  }
  std::mutex::lock(v77);
  *(void *)uint64_t v91 = v54;
  uint64_t v82 = sub_10004D37C(&v78[1].__m_.__sig, (unint64_t *)v91);
  if (v82)
  {
    uint64_t v84 = v82[3];
    unsigned int v83 = (std::__shared_weak_count *)v82[4];
    if (v83)
    {
      atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v78);
      atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v83);
      char v85 = 0;
      goto LABEL_95;
    }
  }
  else
  {
    uint64_t v84 = 0;
  }
  std::mutex::unlock(v78);
  unsigned int v83 = 0;
  char v85 = 1;
LABEL_95:
  (*(void (**)(uint64_t, uint64_t, void, uint64_t, void, uint64_t))(*(void *)v84 + 32))(v84, **(void **)(a1 + 144) + 24, kCFLocalProvisioningApplied, v63, 0, 1);
  if ((v85 & 1) == 0) {
    sub_10004D2C8(v83);
  }
}

void sub_101266268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, __int16 a20,char a21,char a22,std::__shared_weak_count *a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30)
{
  if (a23) {
    sub_10004D2C8(a23);
  }
  sub_1000558F4(&a11);
  sub_1000558F4(&a12);
  sub_10019D6E8((uint64_t)&a30);
  _Unwind_Resume(a1);
}

const void **sub_101266470(uint64_t a1, uint64_t a2)
{
  sub_1007FA824(*(void **)(a2 + 168));
  long long v9 = 0uLL;
  uint64_t v10 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v8 = 0;
  uint64_t v4 = sub_1012686C0(*(void *)(*(void *)(a2 + 168) + 208), *(std::__shared_weak_count **)(*(void *)(a2 + 168) + 216), (void **)(a2 + 184), __p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  if (v4 == -1)
  {
    *(void *)a1 = 0;
    *(void *)&long long v9 = 0;
    *(unsigned char *)(a1 + 8) = 1;
    unint64_t v5 = (const void **)&v9;
  }
  else
  {
    long long v9 = 0uLL;
    sub_1007FFAA4(*(void **)(a2 + 168), 0, (void **)(a2 + 184), 0, (const void **)&v9);
    sub_100058198((const void **)a1, (const void **)&v9 + 1);
    *(unsigned char *)(a1 + 8) = BYTE4(v4);
    unint64_t v5 = (const void **)&v9 + 1;
  }
  return sub_100057D78(v5);
}

void sub_101266564(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101266594(uint64_t a1, CFDictionaryRef theDict)
{
  if (*(unsigned char *)(a1 + 448)) {
    return *(unsigned __int8 *)(a1 + 448);
  }
  if (!*(unsigned char *)(a1 + 589))
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"imsCommonCredentials");
    if (!Value) {
      return *(unsigned __int8 *)(a1 + 448);
    }
    uint64_t v7 = *(void *)(a1 + 296);
    if (!v7 || !*(unsigned char *)(v7 + 256)) {
      return *(unsigned __int8 *)(a1 + 448);
    }
    uint64_t v123 = 0;
    long long v121 = 0u;
    long long v122 = 0u;
    long long v119 = 0u;
    long long v120 = 0u;
    long long v117 = 0u;
    long long v118 = 0u;
    long long v115 = 0u;
    long long v116 = 0u;
    long long v113 = 0u;
    long long v114 = 0u;
    long long v111 = 0u;
    long long v112 = 0u;
    long long v109 = 0u;
    long long v110 = 0u;
    long long v107 = 0u;
    long long v108 = 0u;
    long long v105 = 0u;
    long long v106 = 0u;
    long long v103 = 0u;
    long long v104 = 0u;
    long long v101 = 0u;
    long long v102 = 0u;
    long long v99 = 0u;
    long long v100 = 0u;
    long long v97 = 0u;
    long long v98 = 0u;
    memset(buf, 0, sizeof(buf));
    sub_1003A5408((uint64_t)buf, Value);
    uint64_t v8 = (char *)operator new(0x128uLL);
    *((void *)v8 + 1) = 0;
    *((void *)v8 + 2) = 0;
    *(void *)uint64_t v8 = off_101A85DE8;
    std::string::size_type v9 = (std::string::size_type)(v8 + 24);
    *((_OWORD *)v8 + 2) = 0u;
    *((_OWORD *)v8 + 3) = 0u;
    *((_OWORD *)v8 + 4) = 0u;
    *((_OWORD *)v8 + 5) = 0u;
    *((_OWORD *)v8 + 6) = 0u;
    *((_OWORD *)v8 + 7) = 0u;
    *((_OWORD *)v8 + 8) = 0u;
    *((_OWORD *)v8 + 9) = 0u;
    *((_OWORD *)v8 + 10) = 0u;
    *((_OWORD *)v8 + 11) = 0u;
    *((_OWORD *)v8 + 12) = 0u;
    *((_OWORD *)v8 + 13) = 0u;
    *((_OWORD *)v8 + 14) = 0u;
    *((_OWORD *)v8 + 15) = 0u;
    *((_OWORD *)v8 + 16) = 0u;
    *((_OWORD *)v8 + 17) = 0u;
    *((void *)v8 + 36) = 0;
    *((void *)v8 + 3) = off_101A4D368;
    uint64_t v10 = *(void *)(a1 + 296);
    sub_100179AF8((std::string *)(v8 + 40), (const std::string *)v10);
    sub_100179AF8((std::string *)v8 + 3, (const std::string *)(v10 + 32));
    sub_100179AF8((std::string *)(v8 + 104), (const std::string *)(v10 + 64));
    sub_100179AF8((std::string *)(v8 + 136), (const std::string *)(v10 + 96));
    sub_100179AF8((std::string *)v8 + 7, (const std::string *)(v10 + 128));
    sub_100179AF8((std::string *)(v8 + 200), (const std::string *)(v10 + 160));
    sub_100179AF8((std::string *)(v8 + 232), (const std::string *)(v10 + 192));
    sub_100179AF8((std::string *)v8 + 11, (const std::string *)(v10 + 224));
    *((_DWORD *)v8 + 8) = 1;
    if (!(_BYTE)v123)
    {
      BOOL v14 = *(NSObject **)(a1 + 56);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
        *(_DWORD *)char v128 = 136315394;
        *(void *)&v128[4] = v15;
        *(_WORD *)&v128[12] = 2080;
        *(void *)&v128[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%sNo certificate info provided, CSR is not generated", v128, 0x16u);
      }
LABEL_139:
      uint64_t v74 = *(void *)(a1 + 160);
      int v75 = *(_DWORD *)(v74 + 408);
      if (v75 == 1)
      {
        if (!*(void *)(v74 + 416))
        {
          int v79 = *(_DWORD *)(v74 + 412);
          int v76 = *(NSObject **)(a1 + 56);
          BOOL v80 = os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT);
          if (v79)
          {
            if (!v80) {
              goto LABEL_143;
            }
            goto LABEL_142;
          }
          if (v80) {
            goto LABEL_152;
          }
          goto LABEL_153;
        }
      }
      else if (!v75)
      {
        int v76 = *(NSObject **)(a1 + 56);
        if (!os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
        {
LABEL_143:
          *(void *)&v128[16] = 0;
          *(void *)&v128[8] = 0;
          *(void *)char v128 = &v128[8];
          v124.__r_.__value_.__r.__words[0] = v9;
          v124.__r_.__value_.__l.__size_ = (std::string::size_type)v8;
          atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
          sub_101081C8C((uint64_t **)v128, 8, (uint64_t *)&v124);
          if (v124.__r_.__value_.__l.__size_) {
            sub_10004D2C8((std::__shared_weak_count *)v124.__r_.__value_.__l.__size_);
          }
          sub_1001DD354(*(Registry **)(a1 + 120), &__p);
          (**(void (***)(std::string *__return_ptr))__p.__r_.__value_.__l.__data_)(&v124);
          (*(void (**)(std::string::size_type, void, unsigned char *))(*(void *)v124.__r_.__value_.__l.__data_
                                                                          + 440))(v124.__r_.__value_.__r.__words[0], 0, v128);
          if (v124.__r_.__value_.__l.__size_) {
            sub_10004D2C8((std::__shared_weak_count *)v124.__r_.__value_.__l.__size_);
          }
          if (__p.__r_.__value_.__l.__size_) {
            sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
          }
          *(unsigned char *)(a1 + 589) = 1;
          sub_10005D0E4((uint64_t)v128, *(void **)&v128[8]);
          goto LABEL_154;
        }
LABEL_142:
        uint64_t v77 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
        *(_DWORD *)char v128 = 136315394;
        *(void *)&v128[4] = v77;
        *(_WORD *)&v128[12] = 2080;
        *(void *)&v128[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I %s%s================================ Call Set Provisiong Data Update ================================", v128, 0x16u);
        goto LABEL_143;
      }
      int v76 = *(NSObject **)(a1 + 56);
      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
      {
LABEL_152:
        uint64_t v78 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
        *(_DWORD *)char v128 = 136315394;
        *(void *)&v128[4] = v78;
        *(_WORD *)&v128[12] = 2080;
        *(void *)&v128[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I %s%sRequest throttled, scheduling service refresh", v128, 0x16u);
        uint64_t v74 = *(void *)(a1 + 160);
      }
LABEL_153:
      *(unsigned char *)(v74 + 424) = 1;
      sub_100A2B860(v74 + 360);
LABEL_154:
      sub_10004D2C8((std::__shared_weak_count *)v8);
      sub_10019D6E8((uint64_t)buf);
      return *(unsigned __int8 *)(a1 + 448);
    }
    *(unsigned char *)(a1 + 590) = 1;
    sub_100A2FD3C(*(void *)(a1 + 160), 1, 0);
    memset(&__str, 0, sizeof(__str));
    uint64_t v11 = *(void *)(a1 + 296);
    uint64_t v12 = v11 + 296;
    uint64_t v13 = 296;
    if (!*(unsigned char *)(v11 + 320))
    {
      uint64_t v13 = 160;
      uint64_t v12 = v11 + 160;
    }
    if (*(char *)(v12 + 23) < 0) {
      sub_10004FC84(&__str, *(void **)(v11 + v13), *(void *)(v12 + 8));
    }
    else {
      std::string __str = *(std::string *)v12;
    }
    CFDataRef theData = 0;
    long long v135 = 0u;
    memset(&v136, 0, sizeof(v136));
    long long v133 = 0u;
    long long v134 = 0u;
    long long v131 = 0u;
    long long v132 = 0u;
    long long v129 = 0u;
    long long v130 = 0u;
    memset(v128, 0, sizeof(v128));
    if (BYTE8(v112)) {
      std::string::operator=((std::string *)&v128[24], (const std::string *)&v111);
    }
    if (BYTE8(v114)) {
      std::string::operator=((std::string *)&v130, (const std::string *)&v113);
    }
    if (BYTE8(v116)) {
      std::string::operator=((std::string *)((char *)&v131 + 8), (const std::string *)&v115);
    }
    if (BYTE8(v118)) {
      std::string::operator=((std::string *)&v133, (const std::string *)&v117);
    }
    if (BYTE8(v120)) {
      std::string::operator=((std::string *)((char *)&v134 + 8), (const std::string *)&v119);
    }
    if (BYTE8(v122)) {
      std::string::operator=(&v136, (const std::string *)&v121);
    }
    std::string::operator=((std::string *)v128, &__str);
    uint64_t v91 = 0;
    sub_100800E2C(@"com.apple.callservices.identifier.", (uint64_t *)(a1 + 184), (CFStringRef *)&v91);
    long long v90 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
    char v17 = ServiceMap;
    std::string::size_type v19 = v18;
    if ((v18 & 0x8000000000000000) != 0)
    {
      uint64_t v20 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        std::string::size_type v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    v124.__r_.__value_.__r.__words[0] = v19;
    uint64_t v23 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&v124);
    if (v23)
    {
      uint64_t v25 = v23[3];
      unsigned int v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v17);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        char v26 = 0;
        goto LABEL_37;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    std::mutex::unlock(v17);
    unsigned int v24 = 0;
    char v26 = 1;
LABEL_37:
    uint64_t v27 = kPhoneServicesWalletDomain;
    (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v25 + 24))(&__p, v25, **(void **)(a1 + 144) + 24, @"last.dn", kPhoneServicesWalletDomain, 0, 4);
    sub_100056248(&v90, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
    sub_1000577C4((const void **)&__p.__r_.__value_.__l.__data_);
    if ((v26 & 1) == 0) {
      sub_10004D2C8(v24);
    }
    if (v90) {
      uint64_t v28 = sub_1000810B8;
    }
    else {
      uint64_t v28 = 0;
    }
    if (v28)
    {
      memset(&v124, 0, sizeof(v124));
      ctu::cf::assign();
      std::string __p = v124;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __str.__r_.__value_.__l.__size_;
      }
      std::string::size_type v30 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      int v31 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v30 = __p.__r_.__value_.__l.__size_;
      }
      if (size == v30)
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((*((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x80) != 0)
        {
          BOOL v41 = memcmp(__str.__r_.__value_.__l.__data_, p_p, __str.__r_.__value_.__l.__size_) == 0;
        }
        else if (*((unsigned char *)&__str.__r_.__value_.__s + 23))
        {
          uint64_t v33 = HIBYTE(__str.__r_.__value_.__r.__words[2]) - 1;
          p_str = &__str;
          do
          {
            int v36 = p_str->__r_.__value_.__s.__data_[0];
            p_str = (std::string *)((char *)p_str + 1);
            int v35 = v36;
            int v38 = p_p->__r_.__value_.__s.__data_[0];
            p_p = (std::string *)((char *)p_p + 1);
            int v37 = v38;
            BOOL v40 = v33-- != 0;
            BOOL v41 = v35 == v37;
          }
          while (v35 == v37 && v40);
        }
        else
        {
          BOOL v41 = 1;
        }
      }
      else
      {
        BOOL v41 = 0;
      }
      if (v31 < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (v41)
      {
        if (*(unsigned char *)(a1 + 488))
        {
          uint64_t v42 = *(NSObject **)(a1 + 56);
          std::string::size_type v9 = (std::string::size_type)(v8 + 24);
          if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_102;
          }
          std::string::size_type v43 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
          unsigned int v44 = &__str;
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            unsigned int v44 = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          LODWORD(v124.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)v124.__r_.__value_.__r.__words + 4) = v43;
          WORD2(v124.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&v124.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
          HIWORD(v124.__r_.__value_.__r.__words[2]) = 2080;
          std::string::size_type v125 = v44;
          uint64_t v45 = "#I %s%sUse existing thumper key for %s";
          unsigned int v46 = v42;
          uint32_t v47 = 32;
        }
        else
        {
          sub_1008AA35C(v91, (uint64_t)&v124);
          std::string::size_type v9 = (std::string::size_type)(v8 + 24);
          sub_10126F224((const void **)(a1 + 464), (uint64_t)&v124);
          sub_1008AC324((uint64_t)&v124);
          unsigned int v81 = *(NSObject **)(a1 + 56);
          if (!os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
          {
LABEL_102:
            if (*(unsigned char *)(a1 + 488)) {
              goto LABEL_110;
            }
            sub_1008A84C8((uint64_t)&v124);
            sub_10126F224((const void **)(a1 + 464), (uint64_t)&v124);
            sub_1008AC324((uint64_t)&v124);
            char v62 = *(NSObject **)(a1 + 56);
            if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
            {
              std::string::size_type v63 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
              uint64_t v64 = &__str;
              if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                uint64_t v64 = (std::string *)__str.__r_.__value_.__r.__words[0];
              }
              char v65 = "";
              int v66 = *(unsigned __int8 *)(a1 + 488);
              LODWORD(v124.__r_.__value_.__l.__data_) = 136315906;
              if (!v66) {
                char v65 = "out";
              }
              *(std::string::size_type *)((char *)v124.__r_.__value_.__r.__words + 4) = v63;
              WORD2(v124.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&v124.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
              HIWORD(v124.__r_.__value_.__r.__words[2]) = 2080;
              std::string::size_type v125 = v64;
              __int16 v126 = 2080;
              BOOL v127 = v65;
              _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I %s%sGenerated new thumper key for %s with%s success", (uint8_t *)&v124, 0x2Au);
            }
            if (*(unsigned char *)(a1 + 488))
            {
LABEL_110:
              sub_1008A88A8((uint64_t)v128, (const char *)&v134 + 8, (const char *)&v133, (const char *)&v131 + 8, &v128[24], (const char *)&v130, (const char *)&v136, (const void **)&__p.__r_.__value_.__l.__data_);
              v124.__r_.__value_.__r.__words[0] = 0;
              CFDataRef theData = (CFDataRef)__p.__r_.__value_.__r.__words[0];
              __p.__r_.__value_.__r.__words[0] = 0;
              sub_100030068((const void **)&v124.__r_.__value_.__l.__data_);
              sub_100030068((const void **)&__p.__r_.__value_.__l.__data_);
            }
            sub_1000558F4(&v90);
            sub_1000558F4((const void **)&v91);
            if (SHIBYTE(v136.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v136.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v135) < 0) {
              operator delete(*((void **)&v134 + 1));
            }
            if (SBYTE7(v134) < 0) {
              operator delete((void *)v133);
            }
            if (SHIBYTE(v132) < 0) {
              operator delete(*((void **)&v131 + 1));
            }
            if (SBYTE7(v131) < 0) {
              operator delete((void *)v130);
            }
            if (SHIBYTE(v129) < 0) {
              operator delete(*(void **)&v128[24]);
            }
            if ((v128[23] & 0x80000000) != 0) {
              operator delete(*(void **)v128);
            }
            if (theData) {
              char v67 = sub_10008324C;
            }
            else {
              char v67 = 0;
            }
            if (v67)
            {
              memset(&v124, 0, sizeof(v124));
              BytePtr = (char *)CFDataGetBytePtr(theData);
              sub_100058DB0(&v124, BytePtr);
              sub_100093B44((std::string *)(v8 + 40), &v124);
              unsigned int v69 = *(NSObject **)(a1 + 56);
              if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v70 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
                uint64_t v71 = &v124;
                if ((v124.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  uint64_t v71 = (std::string *)v124.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)char v128 = 136315650;
                *(void *)&v128[4] = v70;
                *(_WORD *)&v128[12] = 2080;
                *(void *)&v128[14] = " ";
                *(_WORD *)&v128[22] = 2080;
                *(void *)&v128[24] = v71;
                _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "#I %s%sCSR: %s", v128, 0x20u);
              }
              if (SHIBYTE(v124.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v124.__r_.__value_.__l.__data_);
              }
            }
            else
            {
              uint64_t v72 = *(NSObject **)(a1 + 56);
              if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v73 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
                *(_DWORD *)char v128 = 136315394;
                *(void *)&v128[4] = v73;
                *(_WORD *)&v128[12] = 2080;
                *(void *)&v128[14] = " ";
                _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I %s%sFailed to generate CSR", v128, 0x16u);
              }
            }
            *(unsigned char *)(a1 + 590) = 0;
            sub_100030068((const void **)&theData);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            goto LABEL_139;
          }
          std::string::size_type v82 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
          unsigned int v83 = &__str;
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            unsigned int v83 = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          uint64_t v84 = "";
          int v85 = *(unsigned __int8 *)(a1 + 488);
          LODWORD(v124.__r_.__value_.__l.__data_) = 136315906;
          if (!v85) {
            uint64_t v84 = "out";
          }
          *(std::string::size_type *)((char *)v124.__r_.__value_.__r.__words + 4) = v82;
          WORD2(v124.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&v124.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
          HIWORD(v124.__r_.__value_.__r.__words[2]) = 2080;
          std::string::size_type v125 = v83;
          __int16 v126 = 2080;
          BOOL v127 = v84;
          uint64_t v45 = "#I %s%sRead thumper key for %s from keychain with%s success";
          unsigned int v46 = v81;
          uint32_t v47 = 42;
        }
LABEL_101:
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, v45, (uint8_t *)&v124, v47);
        goto LABEL_102;
      }
    }
    sub_1008AA8F4((const void **)(a1 + 464));
    sub_1008ABBDC(v91);
    int v48 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
    uint64_t v49 = v48;
    if ((v18 & 0x8000000000000000) != 0)
    {
      char v50 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v51 = 5381;
      do
      {
        std::string::size_type v18 = v51;
        unsigned int v52 = *v50++;
        uint64_t v51 = (33 * v51) ^ v52;
      }
      while (v52);
    }
    std::mutex::lock(v48);
    v124.__r_.__value_.__r.__words[0] = v18;
    int64x2_t v53 = sub_10004D37C(&v49[1].__m_.__sig, (unint64_t *)&v124);
    if (v53)
    {
      uint64_t v55 = v53[3];
      uint64_t v54 = (std::__shared_weak_count *)v53[4];
      if (v54)
      {
        atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v49);
        atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v54);
        char v56 = 0;
LABEL_80:
        uint64_t v57 = **(void **)(a1 + 144);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = __str;
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = __dst;
        }
        long long v92 = 0;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v124, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
        }
        else {
          std::string v124 = __p;
        }
        long long v94 = 0;
        if (ctu::cf::convert_copy())
        {
          unsigned int v58 = v92;
          long long v92 = v94;
          long long v95 = v58;
          sub_1000558F4(&v95);
        }
        uint64_t v59 = v57 + 24;
        if (SHIBYTE(v124.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v124.__r_.__value_.__l.__data_);
        }
        uint64_t v89 = v92;
        long long v92 = 0;
        sub_1000558F4(&v92);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        (*(void (**)(uint64_t, uint64_t, const __CFString *, const void *, uint64_t, void, uint64_t, void))(*(void *)v55 + 16))(v55, v59, @"last.dn", v89, v27, 0, 4, 0);
        sub_1000558F4(&v89);
        std::string::size_type v9 = (std::string::size_type)(v8 + 24);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if ((v56 & 1) == 0) {
          sub_10004D2C8(v54);
        }
        uint64_t v60 = *(NSObject **)(a1 + 56);
        if (!os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_102;
        }
        std::string::size_type v61 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
        LODWORD(v124.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)v124.__r_.__value_.__r.__words + 4) = v61;
        WORD2(v124.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v124.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
        uint64_t v45 = "#I %s%sCleaned up keychain's Thumper key record";
        unsigned int v46 = v60;
        uint32_t v47 = 22;
        goto LABEL_101;
      }
    }
    else
    {
      uint64_t v55 = 0;
    }
    std::mutex::unlock(v49);
    uint64_t v54 = 0;
    char v56 = 1;
    goto LABEL_80;
  }
  uint64_t v4 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%ssetProvisioning call in progress - bailout", buf, 0x16u);
  }
  return *(unsigned __int8 *)(a1 + 448);
}

void sub_1012674D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,const void *a23,const void *a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  sub_1000558F4(&a23);
  sub_1000558F4(&a24);
  sub_1001F7180((uint64_t)&STACK[0x2A0]);
  sub_100030068(&a10);
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v32);
  sub_10019D6E8((uint64_t)&a32);
  _Unwind_Resume(a1);
}

BOOL sub_1012676AC(uint64_t a1)
{
  char v2 = (std::mutex *)(a1 + 496);
  std::mutex::lock((std::mutex *)(a1 + 496));
  if (*(void *)(a1 + 576)) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  BOOL v4 = v3 != 0;
  std::mutex::unlock(v2);
  return v4;
}

void sub_101267708(uint64_t a1, char a2)
{
  uint64_t v4 = sub_101262800(a1);
  int v5 = *(_DWORD *)(a1 + 256);
  if (v5) {
    BOOL v6 = v5 == 2;
  }
  else {
    BOOL v6 = sub_10125ADA4(a1);
  }
  char v7 = v6 & a2;
  if (v5 == 2) {
    char v7 = 1;
  }
  if (!v4) {
    char v7 = 0;
  }
  *(unsigned char *)(a1 + 704) = v7;
  uint64_t v8 = *(void *)(a1 + 160);
  if (v8)
  {
    std::string::size_type v9 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      uint64_t v11 = asStringBool(v4 != 0);
      uint64_t v12 = *(int *)(a1 + 256);
      uint64_t v13 = (const char *)&unk_10161656E;
      BOOL v14 = (char *)&unk_10161656E;
      if (v12 <= 2) {
        BOOL v14 = off_101AA4880[v12];
      }
      int v15 = *(_DWORD *)(a1 + 584);
      if (v15 == 1) {
        uint64_t v13 = "Active";
      }
      if (v15) {
        uint64_t v16 = v13;
      }
      else {
        uint64_t v16 = "Disabled";
      }
      uint64_t v17 = asStringBool(*(unsigned char *)(a1 + 704));
      int v18 = 136316418;
      uint64_t v19 = v10;
      __int16 v20 = 2080;
      uint64_t v21 = " ";
      __int16 v22 = 2080;
      uint64_t v23 = v11;
      __int16 v24 = 2080;
      uint64_t v25 = v14;
      __int16 v26 = 2080;
      uint64_t v27 = v16;
      __int16 v28 = 2080;
      uint64_t v29 = v17;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sevaluateWiFiLocationRequirement: paired: %s, fSwitchState: %s, fServiceStatus: %s, locationRequired: %s", (uint8_t *)&v18, 0x3Eu);
      uint64_t v8 = *(void *)(a1 + 160);
    }
    sub_100A3344C(v8);
  }
}

const void **sub_1012678B4(uint64_t a1, BOOL a2, BOOL a3)
{
  return sub_10125E354((const void **)(a1 - 8), a2, a3);
}

const void **sub_1012678BC(const void **a1, CFTypeRef *a2)
{
  int v5 = 0;
  sub_100056248(&v5, a2);
  uint64_t v3 = *a1;
  *a1 = v5;
  int v5 = v3;
  sub_1000558F4(&v5);
  return a1;
}

const void **sub_10126790C(uint64_t a1, const __CFString **a2, const __CFString **a3, const __CFString **a4, unsigned char *a5, const __CFString **a6)
{
  void (***v43)(long long *__return_ptr, void, uint64_t);
  char v44;
  char v45;
  __CFDictionary *v46;
  void *v47;
  void *v48;
  void *v49[2];
  uint64_t v50;
  char v51;
  void *v52[2];
  uint64_t v53;
  void *v54;
  void *__src[2];
  uint64_t v56;
  void *__dst[2];
  uint64_t v58;
  CFMutableDictionaryRef v59;
  const void *v60;
  CFDictionaryRef theDict;
  void *value;
  void *__p[2];
  uint64_t v64;
  long long v65;
  uint64_t v66;
  void *v67;
  const void *v68[2];

  uint64_t result = (const void **)sub_1007FA824(*(void **)(a1 + 168));
  if (!result) {
    return result;
  }
  uint64_t v60 = 0;
  CFDictionaryRef theDict = 0;
  sub_1007FFAA4(*(void **)(a1 + 168), 2, (void **)(a1 + 184), 0, &v60);
  uint64_t v59 = 0;
  if (theDict) {
    uint64_t v13 = sub_100080778;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v13)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  }
  else
  {
    MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!MutableCopy) {
      goto LABEL_9;
    }
  }
  CFMutableDictionaryRef v15 = v59;
  uint64_t v59 = MutableCopy;
  *(void *)&char v65 = v15;
  sub_10005717C((const void **)&v65);
LABEL_9:
  char v16 = sub_100810848(a1);
  if (a5) {
    char v18 = v16;
  }
  else {
    char v18 = 1;
  }
  if ((v18 & 1) == 0)
  {
    uint64_t v19 = (const void **)&kCFBooleanTrue;
    if (!*a5) {
      uint64_t v19 = (const void **)&kCFBooleanFalse;
    }
    CFDictionarySetValue(v59, @"enable", *v19);
  }
  if (a2)
  {
    __int16 v20 = v59;
    __src[0] = 0;
    __p[0] = 0;
    if (ctu::cf::convert_copy((ctu::cf *)__p, a2, (const char *)0x8000100, kCFAllocatorDefault, v17))
    {
      uint64_t v21 = __src[0];
      __src[0] = __p[0];
      *(void *)&char v65 = v21;
      sub_1000558F4((const void **)&v65);
    }
    v68[0] = __src[0];
    __src[0] = 0;
    sub_1000558F4((const void **)__src);
    CFDictionarySetValue(v20, @"impi", v68[0]);
    sub_1000558F4(v68);
  }
  if (a3)
  {
    __int16 v22 = v59;
    __src[0] = 0;
    __p[0] = 0;
    if (ctu::cf::convert_copy((ctu::cf *)__p, a3, (const char *)0x8000100, kCFAllocatorDefault, v17))
    {
      uint64_t v23 = __src[0];
      __src[0] = __p[0];
      *(void *)&char v65 = v23;
      sub_1000558F4((const void **)&v65);
    }
    v68[0] = __src[0];
    __src[0] = 0;
    sub_1000558F4((const void **)__src);
    CFDictionarySetValue(v22, @"impu", v68[0]);
    sub_1000558F4(v68);
  }
  if (a4)
  {
    __int16 v24 = v59;
    __src[0] = 0;
    __p[0] = 0;
    if (ctu::cf::convert_copy((ctu::cf *)__p, a4, (const char *)0x8000100, kCFAllocatorDefault, v17))
    {
      uint64_t v25 = __src[0];
      __src[0] = __p[0];
      *(void *)&char v65 = v25;
      sub_1000558F4((const void **)&v65);
    }
    v68[0] = __src[0];
    __src[0] = 0;
    sub_1000558F4((const void **)__src);
    CFDictionarySetValue(v24, @"imsi", v68[0]);
    sub_1000558F4(v68);
  }
  if (a6)
  {
    __int16 v26 = v59;
    __src[0] = 0;
    __p[0] = 0;
    if (ctu::cf::convert_copy((ctu::cf *)__p, a6, (const char *)0x8000100, kCFAllocatorDefault, v17))
    {
      uint64_t v27 = __src[0];
      __src[0] = __p[0];
      *(void *)&char v65 = v27;
      sub_1000558F4((const void **)&v65);
    }
    v68[0] = __src[0];
    __src[0] = 0;
    sub_1000558F4((const void **)__src);
    CFDictionarySetValue(v26, @"last-expired-token", v68[0]);
    sub_1000558F4(v68);
  }
  if (!CFDictionaryGetValue(v59, @"hardware"))
  {
    value = 0;
    uint64_t v28 = *(void *)(a1 + 160);
    if (*(char *)(v28 + 767) < 0)
    {
      sub_10004FC84(__dst, *(void **)(v28 + 744), *(void *)(v28 + 752));
    }
    else
    {
      uint64_t v29 = v28 + 744;
      *(_OWORD *)std::string __dst = *(_OWORD *)v29;
      unsigned int v58 = *(void *)(v29 + 16);
    }
    if (SHIBYTE(v58) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)__dst;
      uint64_t v64 = v58;
    }
    char v67 = 0;
    if (SHIBYTE(v64) < 0)
    {
      sub_10004FC84(&v65, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      char v65 = *(_OWORD *)__p;
      int v66 = v64;
    }
    v68[0] = 0;
    if (ctu::cf::convert_copy())
    {
      std::string::size_type v30 = v67;
      char v67 = (void *)v68[0];
      __src[0] = v30;
      sub_1000558F4((const void **)__src);
    }
    if (SHIBYTE(v66) < 0) {
      operator delete((void *)v65);
    }
    value = v67;
    char v67 = 0;
    sub_1000558F4((const void **)&v67);
    if (SHIBYTE(v64) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v58) < 0) {
      operator delete(__dst[0]);
    }
    if (value) {
      int v31 = sub_1000810B8;
    }
    else {
      int v31 = 0;
    }
    if (v31) {
      CFDictionaryAddValue(v59, @"hardware", value);
    }
    sub_1000558F4((const void **)&value);
  }
  if (CFDictionaryGetValue(v59, @"deviceCarrierId")) {
    goto LABEL_57;
  }
  __src[0] = 0;
  __src[1] = 0;
  char v56 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
  int v36 = ServiceMap;
  if (v37 < 0)
  {
    int v38 = (unsigned __int8 *)(v37 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v39 = 5381;
    do
    {
      uint64_t v37 = v39;
      unsigned int v40 = *v38++;
      uint64_t v39 = (33 * v39) ^ v40;
    }
    while (v40);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v37;
  BOOL v41 = sub_10004D37C(&v36[1].__m_.__sig, (unint64_t *)__p);
  if (v41)
  {
    std::string::size_type v43 = (void (***)(long long *__return_ptr, void, uint64_t))v41[3];
    uint64_t v42 = (std::__shared_weak_count *)v41[4];
    if (v42)
    {
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v36);
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v42);
      unsigned int v44 = 0;
      goto LABEL_80;
    }
  }
  else
  {
    std::string::size_type v43 = 0;
  }
  std::mutex::unlock(v36);
  uint64_t v42 = 0;
  unsigned int v44 = 1;
LABEL_80:
  (**v43)(&v65, v43, **(void **)(a1 + 144) + 24);
  (*(void (**)(void **__return_ptr))(*(void *)v65 + 112))(__src);
  if (*((void *)&v65 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v65 + 1));
  }
  if ((v44 & 1) == 0) {
    sub_10004D2C8(v42);
  }
  if (SHIBYTE(v56) < 0)
  {
    if (!__src[1])
    {
LABEL_104:
      operator delete(__src[0]);
      goto LABEL_57;
    }
    unsigned int v46 = v59;
    sub_10004FC84(v52, __src[0], (unint64_t)__src[1]);
LABEL_89:
    if (SHIBYTE(v53) < 0)
    {
      sub_10004FC84(__p, v52[0], (unint64_t)v52[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v52;
      uint64_t v64 = v53;
    }
    value = 0;
    if (SHIBYTE(v64) < 0)
    {
      sub_10004FC84(&v65, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      char v65 = *(_OWORD *)__p;
      int v66 = v64;
    }
    char v67 = 0;
    if (ctu::cf::convert_copy())
    {
      uint32_t v47 = value;
      value = v67;
      v68[0] = v47;
      sub_1000558F4(v68);
    }
    if (SHIBYTE(v66) < 0) {
      operator delete((void *)v65);
    }
    int v48 = value;
    uint64_t v54 = value;
    value = 0;
    sub_1000558F4((const void **)&value);
    if (SHIBYTE(v64) < 0) {
      operator delete(__p[0]);
    }
    CFDictionaryAddValue(v46, @"deviceCarrierId", v48);
    sub_1000558F4((const void **)&v54);
    if (SHIBYTE(v53) < 0) {
      operator delete(v52[0]);
    }
    if ((SHIBYTE(v56) & 0x80000000) == 0) {
      goto LABEL_57;
    }
    goto LABEL_104;
  }
  if (HIBYTE(v56))
  {
    unsigned int v46 = v59;
    *(_OWORD *)unsigned int v52 = *(_OWORD *)__src;
    int64x2_t v53 = v56;
    goto LABEL_89;
  }
LABEL_57:
  if (theDict) {
    __int16 v32 = sub_100080778;
  }
  else {
    __int16 v32 = 0;
  }
  if (!v32 || !CFEqual(theDict, v59)) {
    goto LABEL_75;
  }
  uint64_t v33 = *(void *)(a1 + 168);
  CFDictionaryRef v34 = theDict;
  if (*(char *)(a1 + 207) < 0)
  {
    sub_10004FC84(v49, *(void **)(a1 + 184), *(void *)(a1 + 192));
  }
  else
  {
    *(_OWORD *)uint64_t v49 = *(_OWORD *)(a1 + 184);
    char v50 = *(void *)(a1 + 200);
  }
  uint64_t v51 = 1;
  uint64_t v45 = sub_1007FCB38(v33, v34, (long long *)v49, 1);
  if (v51)
  {
    if (SHIBYTE(v50) < 0) {
      operator delete(v49[0]);
    }
  }
  if ((v45 & 1) == 0) {
LABEL_75:
  }
    sub_100810B58(a1, 2u, v59, 1, 1);
  sub_10005717C((const void **)&v59);
  return sub_100057D78((const void **)&theDict);
}

void sub_1012680AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,const void *a37,uint64_t a38,uint64_t a39,const void *a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  sub_1000558F4(&a40);
  if (a46 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  sub_10005717C(&a37);
  sub_100057D78(v46);
  _Unwind_Resume(a1);
}

const void **sub_101268220(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 296);
  if (*(unsigned char *)(v2 + 256) && *(unsigned char *)(v2 + 120))
  {
    uint64_t v3 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      uint64_t v5 = *(void *)(a1 + 296);
      BOOL v6 = (void **)(v5 + 96);
      if (*(char *)(v5 + 119) < 0) {
        BOOL v6 = (void **)*v6;
      }
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = v4;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      __int16 v32 = v6;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%sAssigned SIP username: %s", buf, 0x20u);
    }
    uint64_t v7 = *(void *)(a1 + 160);
    if (v7) {
      sub_1004E01D4(v7, (const std::string *)(*(void *)(a1 + 296) + 96));
    }
  }
  theDict[0] = 0;
  theDict[1] = 0;
  sub_101266470((uint64_t)theDict, a1);
  if (theDict[0]) {
    uint64_t v8 = sub_100080778;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8)
  {
    uint64_t v28 = 0;
    long long v29 = 0uLL;
    std::string __p = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    CTGetRootVersionString();
    CFDictionaryRef Value = (void *)CFDictionaryGetValue(theDict[0], @"CoreTelephonyVersion");
    uint64_t v10 = Value;
    if (Value)
    {
      CFTypeID v11 = CFGetTypeID(Value);
      if (v11 == CFStringGetTypeID())
      {
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        *(void *)((char *)&v29 + 7) = *(void *)&buf[15];
        uint64_t v10 = *(void **)buf;
        unsigned int v12 = buf[23];
        uint64_t v28 = *(void **)buf;
        *(void *)&long long v29 = *(void *)&buf[8];
        HIBYTE(v29) = buf[23];
        size_t v13 = *(void *)&buf[8];
        goto LABEL_18;
      }
      uint64_t v10 = 0;
    }
    size_t v13 = 0;
    unsigned int v12 = 0;
LABEL_18:
    uint64_t v14 = v12;
    if ((v12 & 0x80u) == 0) {
      size_t v15 = v12;
    }
    else {
      size_t v15 = v13;
    }
    uint64_t v16 = HIBYTE(v27);
    char v17 = HIBYTE(v27);
    if (v27 < 0) {
      uint64_t v16 = v26;
    }
    if (v15 == v16)
    {
      p_p = &__p;
      if ((v12 & 0x80) == 0)
      {
        if (v12)
        {
          uint64_t v19 = &v28;
          while (*(unsigned __int8 *)v19 == *(unsigned __int8 *)p_p)
          {
            uint64_t v19 = (void **)((char *)v19 + 1);
            p_p = (void **)((char *)p_p + 1);
            if (!--v14) {
              goto LABEL_37;
            }
          }
          goto LABEL_31;
        }
LABEL_37:
        if (v17 < 0) {
          operator delete(__p);
        }
        if (SHIBYTE(v29) < 0) {
          operator delete(v28);
        }
        return sub_100057D78((const void **)theDict);
      }
      if (!memcmp(v10, &__p, v13)) {
        goto LABEL_37;
      }
    }
LABEL_31:
    __int16 v20 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      __int16 v22 = &v28;
      if ((v12 & 0x80u) != 0) {
        __int16 v22 = (void **)v10;
      }
      uint64_t v23 = &__p;
      if (v27 < 0) {
        uint64_t v23 = __p;
      }
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = v21;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      __int16 v32 = v22;
      __int16 v33 = 2080;
      CFDictionaryRef v34 = v23;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s%sCT version mismatch. primary: %s, secondary: %s", buf, 0x2Au);
      char v17 = HIBYTE(v27);
    }
    goto LABEL_37;
  }
  return sub_100057D78((const void **)theDict);
}

void sub_101268520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, const void *a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_100057D78(&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_101268588(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 136))
  {
    sub_100179AF8((std::string *)(a1 + 8), (const std::string *)(a2 + 8));
    sub_100179AF8((std::string *)(a1 + 40), (const std::string *)(a2 + 40));
    sub_100179AF8((std::string *)(a1 + 72), (const std::string *)(a2 + 72));
    sub_100179AF8((std::string *)(a1 + 104), (const std::string *)(a2 + 104));
  }
  else
  {
    *(void *)a1 = off_101A4D3B8;
    sub_1000593FC(a1 + 8, (long long *)(a2 + 8));
    sub_1000593FC(a1 + 40, (long long *)(a2 + 40));
    sub_1000593FC(a1 + 72, (long long *)(a2 + 72));
    sub_1000593FC(a1 + 104, (long long *)(a2 + 104));
    *(unsigned char *)(a1 + 136) = 1;
  }
  return a1;
}

void sub_10126865C(_Unwind_Exception *exception_object)
{
  if (v1[96] && v1[95] < 0) {
    operator delete(*v4);
  }
  if (v1[64] && v1[63] < 0) {
    operator delete(*v3);
  }
  if (v1[32])
  {
    if (v1[31] < 0) {
      operator delete(*v2);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1012686C0(uint64_t a1, std::__shared_weak_count *a2, void **a3, void **a4)
{
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!a1
    || (v7 = sub_100046F68(a1 + 144, a3), uint64_t v8 = v7, (void **)(a1 + 152) == v7)
    || (char *)v7[7] + 96 == (char *)sub_100046F68((uint64_t)v7[7] + 88, a4))
  {
    uint64_t v12 = 0x1FFFFFFFFLL;
  }
  else
  {
    long long v16 = 0uLL;
    uint64_t v17 = 0;
    ctu::cf::assign();
    long long v14 = 0uLL;
    uint64_t v15 = 0;
    std::string::size_type v9 = v8[7];
    unsigned int v10 = atoi((const char *)&v14);
    if (v9[9]) {
      unint64_t v11 = (unint64_t)v9[8] << 32;
    }
    else {
      unint64_t v11 = 0;
    }
    uint64_t v12 = v11 | v10;
  }
  if (a2) {
    sub_10004D2C8(a2);
  }
  return v12;
}

void sub_1012687CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_101268800(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 624);
  if (v1) {
    return v1 != 0;
  }
  long long v16 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    BOOL v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v5;
  std::string::size_type v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (!v9)
  {
    uint64_t v11 = 0;
    goto LABEL_9;
  }
  uint64_t v11 = v9[3];
  unsigned int v10 = (std::__shared_weak_count *)v9[4];
  if (!v10)
  {
LABEL_9:
    std::mutex::unlock(v4);
    unsigned int v10 = 0;
    char v12 = 1;
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
LABEL_10:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v11 + 24))(&v15, v11, **(void **)(a1 + 144) + 24, @"individualKey", kPhoneServicesWalletDomain, 0, 4);
  sub_1000C15D8(&v16, &v15);
  sub_1000577C4(&v15);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (v16) {
    size_t v13 = sub_10008324C;
  }
  else {
    size_t v13 = 0;
  }
  if (v13) {
    operator new();
  }
  sub_100030068(&v16);
  uint64_t v1 = *(void *)(a1 + 624);
  return v1 != 0;
}

void sub_101268A68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12)
{
}

const void **sub_101268AE4(void *a1, uint64_t a2, CFDictionaryRef theDict, const void *a4, const void *a5, uint64_t a6)
{
  CFMutableDictionaryRef theDicta = 0;
  CFDictionaryRef v11 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"CBRoot");
  long long v132 = a1;
  if (!v11)
  {
    long long v16 = *(NSObject **)(a2 + 56);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v17 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 144));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v17;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%smissing CB in icloud - bailout", (uint8_t *)&buf, 0x16u);
    }
    goto LABEL_330;
  }
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v11);
  CFMutableDictionaryRef v13 = theDicta;
  CFMutableDictionaryRef theDicta = MutableCopy;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v13;
  sub_10005717C((const void **)&buf.__r_.__value_.__l.__data_);
  long long v14 = CFDictionaryGetValue(v11, @"CarrierEntitlements");
  if (v14)
  {
    value.__r_.__value_.__r.__words[0] = 0;
    sub_10126B5B4((void **)&value.__r_.__value_.__l.__data_, v14, a6);
    if (value.__r_.__value_.__r.__words[0]) {
      uint64_t v15 = sub_100080778;
    }
    else {
      uint64_t v15 = 0;
    }
    if (v15)
    {
      CFDictionarySetValue(theDicta, @"CarrierEntitlements", value.__r_.__value_.__l.__data_);
    }
    else
    {
      char v18 = *(NSObject **)(a2 + 56);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v19 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 144));
        memset(&__str, 0, sizeof(__str));
        ctu::cf::assign();
        std::string __dst = __str;
        p_dst = (std::string *)__str.__r_.__value_.__r.__words[0];
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_dst = &__dst;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v19;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
        uint64_t v154 = p_dst;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s%sfailed to create %s override ", (uint8_t *)&buf, 0x20u);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
      }
    }
    sub_100057D78((const void **)&value.__r_.__value_.__l.__data_);
  }
  uint64_t v21 = (const void *)kIWLANSettingsKey;
  CFDictionaryRef v22 = (const __CFDictionary *)CFDictionaryGetValue(v11, kIWLANSettingsKey);
  if (!v22)
  {
    uint64_t v25 = *(NSObject **)(a2 + 56);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v26 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 144));
      memset(&__str, 0, sizeof(__str));
      ctu::cf::assign();
      std::string __dst = __str;
      uint64_t v27 = (std::string *)__str.__r_.__value_.__r.__words[0];
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v27 = &__dst;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v26;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      uint64_t v154 = v27;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s%smissing %s in CB", (uint8_t *)&buf, 0x20u);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    goto LABEL_189;
  }
  long long v133 = 0;
  CFMutableDictionaryRef v144 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v22);
  CFDictionaryRef v23 = (const __CFDictionary *)CFDictionaryGetValue(v144, @"IKE");
  CFDictionaryRef v142 = 0;
  if (v23) {
    CFDictionaryRef Mutable = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v23);
  }
  else {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  CFTypeRef cf = 0;
  CFDictionaryRef v142 = Mutable;
  if (a4)
  {
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)a4;
    sub_100013168(&cf, (CFTypeRef *)&buf.__r_.__value_.__l.__data_);
    CFTypeRef v28 = cf;
  }
  else
  {
    CFTypeRef v28 = 0;
  }
  if (v28) {
    long long v29 = sub_1000810B8;
  }
  else {
    long long v29 = 0;
  }
  if (!v29)
  {
    uint64_t v30 = *(void *)(a2 + 296);
    if (*(unsigned char *)(v30 + 320))
    {
      if (*(char *)(v30 + 319) < 0) {
        sub_10004FC84(&value, *(void **)(v30 + 296), *(void *)(v30 + 304));
      }
      else {
        std::string value = *(std::string *)(v30 + 296);
      }
      if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__str, value.__r_.__value_.__l.__data_, value.__r_.__value_.__l.__size_);
      }
      else {
        std::string __str = value;
      }
      v152.__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&buf, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
      }
      else {
        std::string buf = __str;
      }
      __p.__r_.__value_.__r.__words[0] = 0;
      if (ctu::cf::convert_copy())
      {
        std::string::size_type v31 = v152.__r_.__value_.__r.__words[0];
        v152.__r_.__value_.__r.__words[0] = __p.__r_.__value_.__r.__words[0];
        __dst.__r_.__value_.__r.__words[0] = v31;
        sub_1000558F4((const void **)&__dst.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      v143.__r_.__value_.__r.__words[0] = v152.__r_.__value_.__r.__words[0];
      v152.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&v152.__r_.__value_.__l.__data_);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)cf;
      CFTypeRef cf = (CFTypeRef)v143.__r_.__value_.__r.__words[0];
      v143.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&v143.__r_.__value_.__l.__data_);
      if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(value.__r_.__value_.__l.__data_);
      }
      CFTypeRef v28 = cf;
    }
  }
  if (v28) {
    __int16 v32 = sub_1000810B8;
  }
  else {
    __int16 v32 = 0;
  }
  if (v32)
  {
    CFStringRef v33 = (const __CFString *)CFDictionaryGetValue(v142, @"LocalIdentifier");
    CFStringRef v34 = v33;
    if (v33)
    {
      CFTypeID v35 = CFGetTypeID(v33);
      if (v35 == CFStringGetTypeID())
      {
        __dst.__r_.__value_.__r.__words[0] = 0;
        CFMutableStringRef v36 = CFStringCreateMutableCopy(0, 0, v34);
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v36;
        CFMutableStringRef v140 = v36;
        if (v36) {
          CFRetain(v36);
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)_NSConcreteStackBlock;
        buf.__r_.__value_.__l.__size_ = 1174405120;
        buf.__r_.__value_.__r.__words[2] = (std::string::size_type)sub_10126BBD8;
        uint64_t v154 = (std::string *)&unk_101AA4268;
        v155[0] = cf;
        if (cf) {
          CFRetain(cf);
        }
        int v37 = DataUtils::replaceStringHolder();
        sub_10028D988((const void **)&v140);
        if (v37)
        {
          sub_100056248(&__p, (CFTypeRef *)&__dst.__r_.__value_.__l.__data_);
          __str.__r_.__value_.__r.__words[0] = (std::string::size_type)cf;
          CFTypeRef cf = (CFTypeRef)__p.__r_.__value_.__r.__words[0];
          __p.__r_.__value_.__r.__words[0] = 0;
          sub_1000558F4((const void **)&__str.__r_.__value_.__l.__data_);
          sub_1000558F4((const void **)&__p.__r_.__value_.__l.__data_);
        }
        sub_1000558F4(v155);
        sub_10028D988((const void **)&__dst.__r_.__value_.__l.__data_);
      }
    }
    CFDictionarySetValue(v142, @"LocalIdentifier", cf);
  }
  else
  {
    int v38 = *(NSObject **)(a2 + 56);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v39 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 144));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v39;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I %s%sNo LocalIdentifier created", (uint8_t *)&buf, 0x16u);
    }
  }
  uint64_t v40 = *(void *)(a2 + 296);
  if (!*(unsigned char *)(v40 + 88)) {
    goto LABEL_84;
  }
  BOOL v41 = v142;
  if (*(char *)(v40 + 87) < 0) {
    sub_10004FC84(&__p, *(void **)(v40 + 64), *(void *)(v40 + 72));
  }
  else {
    std::string __p = *(std::string *)(v40 + 64);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__dst, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else {
    std::string __dst = __p;
  }
  v139.__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__str, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    std::string __str = __dst;
  }
  v143.__r_.__value_.__r.__words[0] = 0;
  if (ctu::cf::convert_copy())
  {
    std::string::size_type v42 = v139.__r_.__value_.__r.__words[0];
    v139.__r_.__value_.__r.__words[0] = v143.__r_.__value_.__r.__words[0];
    v152.__r_.__value_.__r.__words[0] = v42;
    sub_1000558F4((const void **)&v152.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  v135.__r_.__value_.__r.__words[0] = v139.__r_.__value_.__r.__words[0];
  v139.__r_.__value_.__r.__words[0] = 0;
  sub_1000558F4((const void **)&v139.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  CFDictionarySetValue(v41, @"RemoteIdentifier", v135.__r_.__value_.__l.__data_);
  sub_1000558F4((const void **)&v135.__r_.__value_.__l.__data_);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_84:
    if (!a4) {
      goto LABEL_86;
    }
    goto LABEL_85;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (a4) {
LABEL_85:
  }
    CFDictionarySetValue(v142, @"LocalCertificate", a4);
LABEL_86:
  uint64_t v43 = *(void *)(a2 + 296);
  if (*(unsigned char *)(v43 + 352))
  {
    unsigned int v44 = v142;
    if (*(char *)(v43 + 351) < 0) {
      sub_10004FC84(&v152, *(void **)(v43 + 328), *(void *)(v43 + 336));
    }
    else {
      std::string v152 = *(std::string *)(v43 + 328);
    }
    if (SHIBYTE(v152.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, v152.__r_.__value_.__l.__data_, v152.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = v152;
    }
    v135.__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__str, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
    }
    else {
      std::string __str = __dst;
    }
    v139.__r_.__value_.__r.__words[0] = 0;
    if (ctu::cf::convert_copy())
    {
      std::string::size_type v45 = v135.__r_.__value_.__r.__words[0];
      v135.__r_.__value_.__r.__words[0] = v139.__r_.__value_.__r.__words[0];
      v143.__r_.__value_.__r.__words[0] = v45;
      sub_1000558F4((const void **)&v143.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    xpc_object_t object = (xpc_object_t)v135.__r_.__value_.__r.__words[0];
    v135.__r_.__value_.__r.__words[0] = 0;
    sub_1000558F4((const void **)&v135.__r_.__value_.__l.__data_);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    CFDictionarySetValue(v44, @"Username", object);
    sub_1000558F4((const void **)&object);
    if (SHIBYTE(v152.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v152.__r_.__value_.__l.__data_);
    }
    uint64_t v43 = *(void *)(a2 + 296);
  }
  if (!*(unsigned char *)(v43 + 384)) {
    goto LABEL_124;
  }
  unsigned int v46 = v142;
  if (*(char *)(v43 + 383) < 0) {
    sub_10004FC84(&v143, *(void **)(v43 + 360), *(void *)(v43 + 368));
  }
  else {
    std::string v143 = *(std::string *)(v43 + 360);
  }
  if (SHIBYTE(v143.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__dst, v143.__r_.__value_.__l.__data_, v143.__r_.__value_.__l.__size_);
  }
  else {
    std::string __dst = v143;
  }
  xpc_object_t object = 0;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__str, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    std::string __str = __dst;
  }
  v135.__r_.__value_.__r.__words[0] = 0;
  if (ctu::cf::convert_copy())
  {
    xpc_object_t v47 = object;
    xpc_object_t object = (xpc_object_t)v135.__r_.__value_.__r.__words[0];
    v139.__r_.__value_.__r.__words[0] = (std::string::size_type)v47;
    sub_1000558F4((const void **)&v139.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  CFDictionaryRef v146 = (CFDictionaryRef)object;
  xpc_object_t object = 0;
  sub_1000558F4((const void **)&object);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  CFDictionarySetValue(v46, @"Password", v146);
  sub_1000558F4((const void **)&v146);
  if ((SHIBYTE(v143.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_124:
    if (!a5) {
      goto LABEL_126;
    }
    goto LABEL_125;
  }
  operator delete(v143.__r_.__value_.__l.__data_);
  if (a5) {
LABEL_125:
  }
    CFDictionarySetValue(v142, @"RemoteCertificateAuthorityName", a5);
LABEL_126:
  if (*(unsigned char *)(a6 + 184))
  {
    int v48 = (BOOL *)CFDictionaryGetValue(v22, @"DoNotUseEPDGFromEntitlements");
    uint64_t v49 = v48;
    __str.__r_.__value_.__s.__data_[0] = 0;
    if (!v48) {
      goto LABEL_131;
    }
    CFTypeID v50 = CFGetTypeID(v48);
    if (v50 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)&__str, v49, v51);
    }
    if (!__str.__r_.__value_.__s.__data_[0])
    {
LABEL_131:
      CFTypeID v145 = 0;
      if (*(char *)(a6 + 183) < 0) {
        sub_10004FC84(&v139, *(void **)(a6 + 160), *(void *)(a6 + 168));
      }
      else {
        std::string v139 = *(std::string *)(a6 + 160);
      }
      if (SHIBYTE(v139.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__dst, v139.__r_.__value_.__l.__data_, v139.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = v139;
      }
      CFDictionaryRef v146 = 0;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__str, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
      }
      else {
        std::string __str = __dst;
      }
      xpc_object_t object = 0;
      if (ctu::cf::convert_copy())
      {
        CFDictionaryRef v52 = v146;
        CFDictionaryRef v146 = (CFDictionaryRef)object;
        v135.__r_.__value_.__r.__words[0] = (std::string::size_type)v52;
        sub_1000558F4((const void **)&v135.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      CFTypeID v145 = v146;
      CFDictionaryRef v146 = 0;
      sub_1000558F4((const void **)&v146);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v139.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v139.__r_.__value_.__l.__data_);
      }
      CFDictionarySetValue(v142, @"RemoteAddress", v145);
      CFDictionarySetValue(v142, @"RemoteCertificateHostname", v145);
      sub_1000558F4((const void **)&v145);
    }
  }
  if (*(unsigned char *)(a6 + 120))
  {
    CFArrayRef v53 = (const __CFArray *)CFDictionaryGetValue(v142, @"Proposals");
    CFArrayRef v54 = v53;
    if (v53)
    {
      CFTypeID v55 = CFGetTypeID(v53);
      if (v55 == CFArrayGetTypeID())
      {
        CFArrayRef v56 = CFArrayCreateMutableCopy(0, 0, v54);
        CFIndex v57 = 0;
        CFArrayRef theArray = v56;
        while (v57 < CFArrayGetCount(v56))
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v57);
          CFDictionaryRef v59 = ValueAtIndex;
          if (ValueAtIndex)
          {
            CFTypeID v60 = CFGetTypeID(ValueAtIndex);
            if (v60 == CFDictionaryGetTypeID())
            {
              CFMutableDictionaryRef v137 = 0;
              CFMutableDictionaryRef v61 = CFDictionaryCreateMutableCopy(0, 0, v59);
              CFMutableDictionaryRef v137 = v61;
              if (*(char *)(a6 + 119) < 0) {
                sub_10004FC84(&v135, *(void **)(a6 + 96), *(void *)(a6 + 104));
              }
              else {
                std::string v135 = *(std::string *)(a6 + 96);
              }
              if (SHIBYTE(v135.__r_.__value_.__r.__words[2]) < 0) {
                sub_10004FC84(&__dst, v135.__r_.__value_.__l.__data_, v135.__r_.__value_.__l.__size_);
              }
              else {
                std::string __dst = v135;
              }
              CFTypeID v145 = 0;
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                sub_10004FC84(&__str, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
              }
              else {
                std::string __str = __dst;
              }
              CFDictionaryRef v146 = 0;
              if (ctu::cf::convert_copy())
              {
                char v62 = v145;
                CFTypeID v145 = v146;
                xpc_object_t object = v62;
                sub_1000558F4((const void **)&object);
              }
              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__str.__r_.__value_.__l.__data_);
              }
              std::string v136 = v145;
              CFTypeID v145 = 0;
              sub_1000558F4((const void **)&v145);
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__dst.__r_.__value_.__l.__data_);
              }
              CFDictionarySetValue(v61, @"EAPMethod", v136);
              sub_1000558F4((const void **)&v136);
              if (SHIBYTE(v135.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v135.__r_.__value_.__l.__data_);
              }
              CFArraySetValueAtIndex(theArray, v57, v137);
              sub_10005717C((const void **)&v137);
            }
          }
          ++v57;
          CFArrayRef v56 = theArray;
        }
        CFDictionarySetValue(v142, @"Proposals", theArray);
        sub_1000440D4((const void **)&theArray);
      }
    }
  }
  CFDictionarySetValue(v144, @"IKE", v142);
  sub_10004EFE4(&v133, (CFTypeRef *)&v144);
  sub_1000558F4(&cf);
  sub_10005717C((const void **)&v142);
  sub_10005717C((const void **)&v144);
  if (v133) {
    std::string::size_type v63 = sub_100080778;
  }
  else {
    std::string::size_type v63 = 0;
  }
  if (v63)
  {
    CFDictionarySetValue(theDicta, v21, v133);
  }
  else
  {
    uint64_t v64 = *(NSObject **)(a2 + 56);
    if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v65 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 144));
      memset(&__str, 0, sizeof(__str));
      ctu::cf::assign();
      std::string __dst = __str;
      int v66 = (std::string *)__str.__r_.__value_.__r.__words[0];
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v66 = &__dst;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v65;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      uint64_t v154 = v66;
      _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I %s%sfailed to create %s override ", (uint8_t *)&buf, 0x20u);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
  }
  sub_100057D78((const void **)&v133);
LABEL_189:
  char v67 = (ctu *)CFDictionaryGetValue(v11, @"IMSConfig");
  if (v67)
  {
    CFDictionaryRef v142 = 0;
    uint64_t v68 = *(NSObject **)(a2 + 56);
    if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v69 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 144));
      ctu::cf_to_xpc((uint64_t *)&__dst, v67, v70);
      xpc::object::to_string((uint64_t *)&__str, (xpc::object *)&__dst);
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_str = &__str;
      }
      else {
        p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v69;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      uint64_t v154 = p_str;
      _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I %s%sipTel orig cfg: %s", (uint8_t *)&buf, 0x20u);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      xpc_release(__dst.__r_.__value_.__l.__data_);
    }
    CFDictionaryRef v146 = 0;
    CFDictionaryRef v72 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v67);
    CFDictionaryRef v146 = v72;
    CFMutableDictionaryRef v144 = v72;
    if (v72) {
      CFRetain(v72);
    }
    sub_100058DB0(&v143, "ipTel");
    CFDictionaryRef v73 = v144;
    if (v144) {
      uint64_t v74 = sub_1000C06D0;
    }
    else {
      uint64_t v74 = 0;
    }
    if (!v74)
    {
      CFMutableDictionaryRef v144 = 0;
      goto LABEL_283;
    }
    int v75 = CFDictionaryGetValue(v144, @"DeviceOverrides");
    int v76 = v75;
    if (v75 && (CFTypeID v77 = CFGetTypeID(v75), v77 == CFDictionaryGetTypeID()))
    {
      v139.__r_.__value_.__r.__words[0] = (std::string::size_type)v76;
      CFRetain(v76);
      std::string::size_type v78 = v139.__r_.__value_.__r.__words[0];
    }
    else
    {
      std::string::size_type v78 = 0;
      v139.__r_.__value_.__r.__words[0] = 0;
    }
    if (v78) {
      std::string::size_type v82 = sub_100080778;
    }
    else {
      std::string::size_type v82 = 0;
    }
    if (v82)
    {
      CFDictionaryRemoveValue(v144, @"DeviceOverrides");
      CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)v139.__r_.__value_.__l.__data_);
      if (Count > 0)
      {
        memset(&__str, 0, sizeof(__str));
        sub_10004EE3C(&__str, Count);
        CFDictionaryGetKeysAndValues((CFDictionaryRef)v139.__r_.__value_.__l.__data_, (const void **)__str.__r_.__value_.__l.__data_, 0);
        memset(&__dst, 0, sizeof(__dst));
        capabilities::ct::compatibleHardwareConfigurationString((uint64_t *)&__dst, v84);
        std::string::size_type size = __str.__r_.__value_.__l.__size_;
        for (CFIndex i = (CFTypeRef *)__str.__r_.__value_.__r.__words[0]; i != (CFTypeRef *)size; ++i)
        {
          memset(&value, 0, sizeof(value));
          if (*i)
          {
            CFGetTypeID(*i);
            CFStringGetTypeID();
          }
          memset(&buf, 0, sizeof(buf));
          ctu::cf::assign();
          std::string value = buf;
          memset(&__p, 0, sizeof(__p));
          ctu::tokenize();
          std::string::size_type v88 = __p.__r_.__value_.__l.__size_;
          std::string::size_type v87 = __p.__r_.__value_.__r.__words[0];
          if (__p.__r_.__value_.__r.__words[0] != __p.__r_.__value_.__l.__size_)
          {
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v89 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v89 = __dst.__r_.__value_.__l.__size_;
            }
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v90 = &__dst;
            }
            else {
              long long v90 = (std::string *)__dst.__r_.__value_.__r.__words[0];
            }
            do
            {
              uint64_t v91 = *(unsigned __int8 *)(v87 + 23);
              if ((v91 & 0x80u) == 0) {
                uint64_t v92 = *(unsigned __int8 *)(v87 + 23);
              }
              else {
                uint64_t v92 = *(void *)(v87 + 8);
              }
              if (v92 == v89)
              {
                if ((v91 & 0x80) != 0)
                {
                  if (!memcmp(*(const void **)v87, v90, *(void *)(v87 + 8)))
                  {
LABEL_255:
                    long long v100 = *(NSObject **)(a2 + 56);
                    if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
                    {
                      std::string::size_type v101 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 144));
                      long long v102 = &__dst;
                      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                        long long v102 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                      }
                      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
                      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v101;
                      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
                      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
                      uint64_t v154 = v102;
                      _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#I %s%sProcessing device-specific overrides for %s", (uint8_t *)&buf, 0x20u);
                    }
                    v135.__r_.__value_.__r.__words[0] = 0;
                    CFMutableDictionaryRef v103 = v144;
                    long long v104 = CFDictionaryGetValue((CFDictionaryRef)v139.__r_.__value_.__l.__data_, *i);
                    unint64_t v105 = (unint64_t)v104;
                    if (v104)
                    {
                      CFTypeID v106 = CFGetTypeID(v104);
                      if (v106 == CFDictionaryGetTypeID()) {
                        unint64_t v107 = v105;
                      }
                      else {
                        unint64_t v107 = 0;
                      }
                    }
                    else
                    {
                      unint64_t v107 = 0;
                    }
                    sub_10080FF0C((unint64_t)v103, v107, (const void **)a2, (unint64_t *)&v135);
                    long long v108 = *(NSObject **)(a2 + 56);
                    if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
                    {
                      std::string::size_type v110 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 144));
                      if ((v143.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                        long long v111 = &v143;
                      }
                      else {
                        long long v111 = (std::string *)v143.__r_.__value_.__r.__words[0];
                      }
                      ctu::cf_to_xpc((uint64_t *)&object, (ctu *)v135.__r_.__value_.__l.__data_, v109);
                      xpc::object::to_string((uint64_t *)&v152, (xpc::object *)&object);
                      if ((v152.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                        long long v112 = &v152;
                      }
                      else {
                        long long v112 = (std::string *)v152.__r_.__value_.__r.__words[0];
                      }
                      LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
                      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v110;
                      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
                      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
                      uint64_t v154 = v111;
                      LOWORD(v155[0]) = 2080;
                      *(const void **)((char *)v155 + 2) = v112;
                      _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "#I %s%sMerged %s cfg:\n%s", (uint8_t *)&buf, 0x2Au);
                      if (SHIBYTE(v152.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v152.__r_.__value_.__l.__data_);
                      }
                      xpc_release(object);
                    }
                    CFTypeID v145 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, (CFDictionaryRef)v135.__r_.__value_.__l.__data_);
                    sub_100057D78((const void **)&v135.__r_.__value_.__l.__data_);
                    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
                    sub_100047F64((void ***)&buf);
                    if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(value.__r_.__value_.__l.__data_);
                    }
                    goto LABEL_278;
                  }
                }
                else
                {
                  if (!*(unsigned char *)(v87 + 23)) {
                    goto LABEL_255;
                  }
                  uint64_t v93 = 0;
                  while (*(unsigned __int8 *)(v87 + v93) == v90->__r_.__value_.__s.__data_[v93])
                  {
                    if (v91 == ++v93) {
                      goto LABEL_255;
                    }
                  }
                }
              }
              v87 += 24;
            }
            while (v87 != v88);
          }
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
          sub_100047F64((void ***)&buf);
          if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(value.__r_.__value_.__l.__data_);
          }
        }
        long long v94 = *(NSObject **)(a2 + 56);
        if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
        {
          std::string::size_type v96 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 144));
          if ((v143.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v97 = &v143;
          }
          else {
            long long v97 = (std::string *)v143.__r_.__value_.__r.__words[0];
          }
          ctu::cf_to_xpc((uint64_t *)&__p, v144, v95);
          xpc::object::to_string((uint64_t *)&value, (xpc::object *)&__p);
          if ((value.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_std::string value = &value;
          }
          else {
            p_std::string value = (std::string *)value.__r_.__value_.__r.__words[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v96;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
          uint64_t v154 = v97;
          LOWORD(v155[0]) = 2080;
          *(const void **)((char *)v155 + 2) = p_value;
          _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I %s%s%s cfg unchanged:\n%s", (uint8_t *)&buf, 0x2Au);
          if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(value.__r_.__value_.__l.__data_);
          }
          xpc_release(__p.__r_.__value_.__l.__data_);
        }
        CFMutableDictionaryRef v99 = v144;
        CFMutableDictionaryRef v144 = 0;
        CFTypeID v145 = v99;
LABEL_278:
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if (__str.__r_.__value_.__r.__words[0])
        {
          __str.__r_.__value_.__l.__size_ = __str.__r_.__value_.__r.__words[0];
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        goto LABEL_282;
      }
      CFTypeID v145 = v144;
    }
    else
    {
      CFTypeID v145 = v144;
    }
    CFMutableDictionaryRef v144 = 0;
LABEL_282:
    sub_100057D78((const void **)&v139.__r_.__value_.__l.__data_);
    CFDictionaryRef v73 = (const __CFDictionary *)v145;
LABEL_283:
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v146;
    CFTypeID v145 = 0;
    CFDictionaryRef v146 = v73;
    sub_10005717C((const void **)&buf.__r_.__value_.__l.__data_);
    sub_10005717C((const void **)&v145);
    if (SHIBYTE(v143.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v143.__r_.__value_.__l.__data_);
    }
    sub_10005717C((const void **)&v144);
    CFDictionaryGetValue(v146, @"Signaling");
    uint64_t v113 = *(void *)(a2 + 296);
    if (v113)
    {
      if (*(unsigned char *)(v113 + 256))
      {
        if (*(unsigned char *)(v113 + 248))
        {
          CFDictionaryRef v114 = (const __CFDictionary *)CFDictionaryGetValue(v146, @"IPTelephony");
          v143.__r_.__value_.__r.__words[0] = 0;
          if (v114) {
            CFMutableDictionaryRef v115 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v114);
          }
          else {
            CFMutableDictionaryRef v115 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          }
          long long v120 = v115;
          v143.__r_.__value_.__r.__words[0] = (std::string::size_type)v115;
          uint64_t v121 = *(void *)(a2 + 296);
          if (*(char *)(v121 + 247) < 0) {
            sub_10004FC84(&__dst, *(void **)(v121 + 224), *(void *)(v121 + 232));
          }
          else {
            std::string __dst = *(std::string *)(v121 + 224);
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__str, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
          }
          else {
            std::string __str = __dst;
          }
          v152.__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&buf, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
          }
          else {
            std::string buf = __str;
          }
          __p.__r_.__value_.__r.__words[0] = 0;
          if (ctu::cf::convert_copy())
          {
            std::string::size_type v122 = v152.__r_.__value_.__r.__words[0];
            v152.__r_.__value_.__r.__words[0] = __p.__r_.__value_.__r.__words[0];
            value.__r_.__value_.__r.__words[0] = v122;
            sub_1000558F4((const void **)&value.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          v139.__r_.__value_.__r.__words[0] = v152.__r_.__value_.__r.__words[0];
          v152.__r_.__value_.__r.__words[0] = 0;
          sub_1000558F4((const void **)&v152.__r_.__value_.__l.__data_);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          CFDictionarySetValue(v120, @"pcscf", v139.__r_.__value_.__l.__data_);
          sub_1000558F4((const void **)&v139.__r_.__value_.__l.__data_);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          CFDictionarySetValue(v146, @"IPTelephony", v143.__r_.__value_.__l.__data_);
          uint64_t v123 = *(NSObject **)(a2 + 56);
          if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
          {
            std::string::size_type v124 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 144));
            uint64_t v125 = *(void *)(a2 + 296);
            __int16 v126 = (std::string *)(v125 + 224);
            if (*(char *)(v125 + 247) < 0) {
              __int16 v126 = (std::string *)v126->__r_.__value_.__r.__words[0];
            }
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v124;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
            uint64_t v154 = v126;
            _os_log_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_DEFAULT, "#I %s%sPCSCF address [%s] override from getProvisioning applied", (uint8_t *)&buf, 0x20u);
          }
          sub_10005717C((const void **)&v143.__r_.__value_.__l.__data_);
        }
        memset(&__str, 0, sizeof(__str));
        memset(&value, 0, sizeof(value));
        memset(&__p, 0, sizeof(__p));
        std::mutex::lock((std::mutex *)(a2 + 496));
        operator new();
      }
      long long v116 = *(NSObject **)(a2 + 56);
      if (!os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_319;
      }
      std::string::size_type v119 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 144));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v119;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      long long v118 = "#I %s%sims credentials are not present";
    }
    else
    {
      long long v116 = *(NSObject **)(a2 + 56);
      if (!os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
      {
LABEL_319:
        sub_10004EFE4(&v142, (CFTypeRef *)&v146);
        sub_10005717C((const void **)&v146);
        if (v142) {
          BOOL v127 = sub_100080778;
        }
        else {
          BOOL v127 = 0;
        }
        if (v127)
        {
          CFDictionarySetValue(theDicta, @"IMSConfig", v142);
        }
        else
        {
          char v128 = *(NSObject **)(a2 + 56);
          if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
          {
            std::string::size_type v129 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 144));
            memset(&__str, 0, sizeof(__str));
            ctu::cf::assign();
            std::string __dst = __str;
            long long v130 = &__dst;
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              long long v130 = (std::string *)__dst.__r_.__value_.__r.__words[0];
            }
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v129;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
            uint64_t v154 = v130;
            _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_DEFAULT, "#I %s%sfailed to create %s override", (uint8_t *)&buf, 0x20u);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
          }
        }
        sub_100057D78((const void **)&v142);
        goto LABEL_330;
      }
      std::string::size_type v117 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 144));
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v117;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      long long v118 = "#I %s%sfIndividualCredentials is invalid";
    }
    _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, v118, (uint8_t *)&buf, 0x16u);
    goto LABEL_319;
  }
  int v79 = *(NSObject **)(a2 + 56);
  if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v80 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 144));
    memset(&__str, 0, sizeof(__str));
    ctu::cf::assign();
    std::string __dst = __str;
    unsigned int v81 = &__dst;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      unsigned int v81 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v80;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
    uint64_t v154 = v81;
    _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#I %s%smissing %s in CB", (uint8_t *)&buf, 0x20u);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
LABEL_330:
  sub_10004EFE4(v132, (CFTypeRef *)&theDicta);
  return sub_10005717C((const void **)&theDicta);
}

void sub_10126ADB0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

const void **sub_10126B404(uint64_t a1, CFDictionaryRef theDict)
{
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  uint64_t v3 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    ctu::cf_to_xpc((uint64_t *)&object, MutableCopy, v5);
    xpc::object::to_string((uint64_t *)__p, (xpc::object *)&object);
    if (v11 >= 0) {
      BOOL v6 = __p;
    }
    else {
      BOOL v6 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v4;
    __int16 v14 = 2080;
    uint64_t v15 = " ";
    __int16 v16 = 2080;
    std::string::size_type v17 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%sSetup basic carrier bundle dictionary:\n%s", buf, 0x20u);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    xpc_release(object);
  }
  sub_10004EFE4(__p, (CFTypeRef *)&MutableCopy);
  uint64_t v7 = (void *)(a1 + 576);
  if ((void **)(a1 + 576) != __p)
  {
    *(void *)std::string buf = *v7;
    void *v7 = __p[0];
    __p[0] = 0;
    sub_100057D78((const void **)buf);
  }
  sub_100057D78((const void **)__p);
  return sub_10005717C((const void **)&MutableCopy);
}

void sub_10126B574(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10126B5B4(void **a1, const void *a2, uint64_t a3)
{
  *a1 = 0;
  uint64_t result = (const void **)sub_10004EFAC(a1, a2);
  if (*(unsigned char *)(a3 + 216))
  {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)a2);
    CFMutableDictionaryRef v13 = MutableCopy;
    if (*(char *)(a3 + 215) < 0)
    {
      sub_10004FC84(v10, *(void **)(a3 + 192), *(void *)(a3 + 200));
    }
    else
    {
      *(_OWORD *)unsigned int v10 = *(_OWORD *)(a3 + 192);
      uint64_t v11 = *(void *)(a3 + 208);
    }
    if (SHIBYTE(v11) < 0)
    {
      sub_10004FC84(__dst, v10[0], (unint64_t)v10[1]);
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)v10;
      uint64_t v16 = v11;
    }
    __int16 v14 = 0;
    if (SHIBYTE(v16) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)__dst;
      uint64_t v18 = v16;
    }
    std::string::size_type v19 = 0;
    if (ctu::cf::convert_copy())
    {
      unsigned int v8 = v14;
      __int16 v14 = v19;
      __int16 v20 = v8;
      sub_1000558F4(&v20);
    }
    if (SHIBYTE(v18) < 0) {
      operator delete(__p[0]);
    }
    std::string::size_type v9 = v14;
    char v12 = v14;
    __int16 v14 = 0;
    sub_1000558F4(&v14);
    if (SHIBYTE(v16) < 0) {
      operator delete(__dst[0]);
    }
    CFDictionarySetValue(MutableCopy, @"ServerAddress", v9);
    sub_1000558F4(&v12);
    if (SHIBYTE(v11) < 0) {
      operator delete(v10[0]);
    }
    sub_10004EFE4(__dst, (CFTypeRef *)&v13);
    if (__dst != a1)
    {
      __p[0] = *a1;
      *a1 = __dst[0];
      __dst[0] = 0;
      sub_100057D78((const void **)__p);
    }
    sub_100057D78((const void **)__dst);
    return sub_10005717C((const void **)&v13);
  }
  return result;
}

void sub_10126B780(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  sub_1000558F4(&a18);
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_10005717C(&a17);
  sub_100057D78(v31);
  _Unwind_Resume(a1);
}

void sub_10126B800()
{
}

void sub_10126B808(uint64_t a1@<X0>, uint64_t *a2@<X1>, const void *a3@<X2>, ctu::cf **a4@<X8>)
{
  unsigned int v8 = (std::mutex *)(a1 + 496);
  std::mutex::lock((std::mutex *)(a1 + 496));
  __int16 v32 = 0;
  CFDictionaryRef v9 = *(const __CFDictionary **)(a1 + 576);
  if (v9) {
    unsigned int v10 = sub_100080778;
  }
  else {
    unsigned int v10 = 0;
  }
  if (v10)
  {
    uint64_t v11 = (const void **)*a2;
    uint64_t v12 = (a2[1] - *a2) >> 3;
    if (v12)
    {
      if (v12 == 1)
      {
        *(void *)&v29[0] = CFDictionaryGetValue(v9, *v11);
        sub_100057DAC(&v32, (CFTypeRef *)v29);
      }
      else
      {
        theDict[0] = 0;
        *(void *)&v29[0] = CFDictionaryGetValue(v9, *v11);
        sub_10004EFE4(theDict, (CFTypeRef *)v29);
        CFDictionaryRef v13 = theDict[0];
        if (theDict[0]) {
          __int16 v14 = sub_100080778;
        }
        else {
          __int16 v14 = 0;
        }
        if (v14)
        {
          uint64_t v15 = a2[1] - *a2;
          if ((unint64_t)v15 >= 9)
          {
            unint64_t v16 = v15 >> 3;
            unint64_t v17 = (v15 >> 3) - 1;
            uint64_t v18 = 2 - (v15 >> 3);
            unint64_t v19 = 1;
            while (v18 + v19 != 1)
            {
              if (v19 >= (a2[1] - *a2) >> 3) {
                sub_10015B728();
              }
              CFTypeRef Value = CFDictionaryGetValue(v13, *(const void **)(*a2 + 8 * v19));
              *(void *)&v29[0] = 0;
              sub_10004EFE4(v29, &Value);
              CFDictionaryRef v20 = theDict[0];
              theDict[0] = *(CFDictionaryRef *)&v29[0];
              *(void *)&v29[0] = v20;
              sub_100057D78((const void **)v29);
              CFDictionaryRef v13 = theDict[0];
              if (theDict[0]) {
                uint64_t v21 = sub_100080778;
              }
              else {
                uint64_t v21 = 0;
              }
              if (v21)
              {
                if (++v19 < v16) {
                  continue;
                }
              }
              goto LABEL_24;
            }
            if (v17 >= (a2[1] - *a2) >> 3) {
              sub_10015B728();
            }
            *(void *)&v29[0] = CFDictionaryGetValue(v13, *(const void **)(*a2 + 8 * v17));
            sub_100057DAC(&v32, (CFTypeRef *)v29);
          }
        }
LABEL_24:
        sub_100057D78((const void **)theDict);
      }
    }
  }
  *a4 = 0;
  if (v32) {
    CFDictionaryRef v22 = sub_100080934;
  }
  else {
    CFDictionaryRef v22 = 0;
  }
  if (v22) {
    CFDictionaryRef v23 = v32;
  }
  else {
    CFDictionaryRef v23 = a3;
  }
  DeepCopy = (ctu::cf *)CFPropertyListCreateDeepCopy(kCFAllocatorDefault, v23, 1uLL);
  *a4 = DeepCopy;
  if ((**(unsigned int (***)(uint64_t, uint64_t))(a1 + 24))(a1 + 24, 20))
  {
    uint64_t v30 = 0;
    memset(v29, 0, sizeof(v29));
    ctu::LogMessageBuffer::LogMessageBuffer((ctu::LogMessageBuffer *)v29);
    ctu::operator<<();
    uint64_t v25 = ctu::operator<<();
    sub_101212428(v25, a2);
    ctu::operator<<();
    ctu::operator<<();
    ctu::cf::show((uint64_t *)theDict, DeepCopy, v26);
    ctu::operator<<();
    if (v28 < 0) {
      operator delete(theDict[0]);
    }
    ctu::LogMessageBuffer::~LogMessageBuffer((ctu::LogMessageBuffer *)v29);
  }
  sub_1000577C4(&v32);
  std::mutex::unlock(v8);
}

void sub_10126BB5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  sub_100057D78((const void **)&__p);
  sub_1000577C4((const void **)(v17 - 88));
  std::mutex::unlock(v16);
  _Unwind_Resume(a1);
}

const void **sub_10126BBD8@<X0>(uint64_t a1@<X0>, const void **a2@<X8>)
{
  *a2 = 0;
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 32);
  return sub_100013168(a2, &v3);
}

void sub_10126BC18(_Unwind_Exception *a1)
{
  sub_1000558F4(v1);
  _Unwind_Resume(a1);
}

const void **sub_10126BC2C(uint64_t a1, uint64_t a2)
{
  return sub_100083DA4((const void **)(a1 + 32), (const void **)(a2 + 32));
}

const void **sub_10126BC38(uint64_t a1)
{
  return sub_1000558F4((const void **)(a1 + 32));
}

uint64_t sub_10126BC40(uint64_t a1, int a2, int a3, CFDictionaryRef theDict, const __CFDictionary *a5)
{
  if (!a2) {
    return 0;
  }
  if (theDict && a5)
  {
    CFMutableDictionaryRef theDicta = CFDictionaryCreateMutableCopy(0, 0, theDict);
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a5);
    CFDictionaryRemoveValue(theDicta, @"cfgSlots");
    CFDictionaryRemoveValue(MutableCopy, @"cfgSlots");
    CFDictionaryRemoveValue(theDicta, @"ts");
    CFDictionaryRemoveValue(MutableCopy, @"ts");
    if (CFEqual(theDicta, MutableCopy))
    {
      sub_1007FA824(*(void **)(a1 + 168));
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      *(_OWORD *)std::string __p = 0u;
      uint64_t v44 = 0;
      int v8 = sub_1012686C0(*(void *)(*(void *)(a1 + 168) + 208), *(std::__shared_weak_count **)(*(void *)(a1 + 168) + 216), (void **)(a1 + 184), __p);
      if (SHIBYTE(v44) < 0) {
        operator delete(__p[0]);
      }
      if (v8 != -1)
      {
        CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"cfgSlots");
        CFArrayRef v10 = Value;
        if (Value)
        {
          CFTypeID v11 = CFGetTypeID(Value);
          if (v11 != CFArrayGetTypeID()) {
            CFArrayRef v10 = 0;
          }
        }
        CFArrayRef v12 = (const __CFArray *)CFDictionaryGetValue(a5, @"cfgSlots");
        CFArrayRef v13 = v12;
        if (v12)
        {
          CFTypeID v14 = CFGetTypeID(v12);
          if (v14 == CFArrayGetTypeID() && v10 && sub_101268800(a1))
          {
            CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v10, v8);
            CFDataRef v16 = ValueAtIndex;
            if (ValueAtIndex)
            {
              CFTypeID v17 = CFGetTypeID(ValueAtIndex);
              if (v17 != CFDataGetTypeID()) {
                CFDataRef v16 = 0;
              }
            }
            CFDataRef v18 = (const __CFData *)CFArrayGetValueAtIndex(v13, v8);
            CFDataRef v19 = v18;
            if (v18)
            {
              CFTypeID v20 = CFGetTypeID(v18);
              if (v20 == CFDataGetTypeID())
              {
                if (v16)
                {
                  CFTypeRef cf1 = 0;
                  uint64_t v21 = *(void *)(a1 + 624);
                  std::string::size_type v39 = 0;
                  uint64_t v40 = 0;
                  int v38 = 0;
                  sub_10005C928(&v38, *(const void **)v21, *(void *)(v21 + 8), *(void *)(v21 + 8) - *(void *)v21);
                  sub_100639DDC(v16, (uint64_t)&v38, &v41);
                  sub_1000584C8((const void **)__p, &v41);
                  xpc_object_t v47 = 0;
                  *(void *)std::string buf = 0;
                  sub_10004EFE4(buf, (CFTypeRef *)__p);
                  if (*(void *)buf) {
                    CFDictionaryRef v22 = sub_100080778;
                  }
                  else {
                    CFDictionaryRef v22 = 0;
                  }
                  if (v22) {
                    sub_100058140(&v47, (const void **)buf);
                  }
                  sub_100057D78((const void **)buf);
                  CFTypeRef cf1 = v47;
                  xpc_object_t v47 = 0;
                  sub_100057D78(&v47);
                  sub_1000577C4((const void **)__p);
                  sub_1000577C4(&v41);
                  if (v38)
                  {
                    std::string::size_type v39 = v38;
                    operator delete(v38);
                  }
                  uint64_t v23 = *(void *)(a1 + 624);
                  CFStringRef v34 = 0;
                  uint64_t v35 = 0;
                  CFStringRef v33 = 0;
                  sub_10005C928(&v33, *(const void **)v23, *(void *)(v23 + 8), *(void *)(v23 + 8) - *(void *)v23);
                  sub_100639DDC(v19, (uint64_t)&v33, &v36);
                  sub_1000584C8((const void **)__p, &v36);
                  xpc_object_t v47 = 0;
                  *(void *)std::string buf = 0;
                  sub_10004EFE4(buf, (CFTypeRef *)__p);
                  if (*(void *)buf) {
                    __int16 v24 = sub_100080778;
                  }
                  else {
                    __int16 v24 = 0;
                  }
                  if (v24) {
                    sub_100058140(&v47, (const void **)buf);
                  }
                  sub_100057D78((const void **)buf);
                  uint64_t v25 = v47;
                  int v37 = v47;
                  xpc_object_t v47 = 0;
                  sub_100057D78(&v47);
                  sub_1000577C4((const void **)__p);
                  sub_1000577C4(&v36);
                  if (v33)
                  {
                    CFStringRef v34 = v33;
                    operator delete(v33);
                  }
                  if (cf1) {
                    std::string::size_type v26 = sub_100080778;
                  }
                  else {
                    std::string::size_type v26 = 0;
                  }
                  if (v26)
                  {
                    if (v25 ? sub_100080778 : 0)
                    {
                      int v28 = CFEqual(cf1, v25);
                      sub_100057D78(&v37);
                      sub_100057D78(&cf1);
                      sub_10005717C((const void **)&MutableCopy);
                      sub_10005717C((const void **)&theDicta);
                      if (v28) {
                        return 0;
                      }
                      goto LABEL_47;
                    }
                  }
                  sub_100057D78(&v37);
                  sub_100057D78(&cf1);
                }
              }
            }
          }
        }
      }
    }
    sub_10005717C((const void **)&MutableCopy);
    sub_10005717C((const void **)&theDicta);
  }
LABEL_47:
  uint64_t v30 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v31 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    *(_OWORD *)std::string __p = *(_OWORD *)buf;
    uint64_t v44 = *(void *)&buf[16];
    __int16 v32 = __p;
    if ((buf[23] & 0x80u) != 0) {
      __int16 v32 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v31;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v49 = v32;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s%schanged %s trigger service evaluation", buf, 0x20u);
    if (SHIBYTE(v44) < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t result = 1;
  *(unsigned char *)(a1 + 232) = 1;
  return result;
}

void sub_10126C124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, int a13, const void *a14, void *a15, uint64_t a16, uint64_t a17, char a18, int a19, const void *a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,const void *a27,const void *a28,__int16 a29,char a30,char a31)
{
}

uint64_t sub_10126C238(uint64_t a1, uint64_t a2, const __CFString *a3, const __CFDictionary *a4)
{
  if (a2)
  {
    theDict[0] = 0;
    theDict[1] = 0;
    uint64_t v8 = a1 + 184;
    CFDictionaryRef v9 = *(void **)(a1 + 168);
    uint64_t v10 = sub_1007FA824(v9);
    sub_100800620(a3, v9, 2u, v8, v10, a4, (const void **)theDict);
    if (theDict[1]) {
      CFTypeID v11 = sub_100080778;
    }
    else {
      CFTypeID v11 = 0;
    }
    if (v11)
    {
      CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(theDict[1], @"enable");
      if (Value)
      {
        if (CFBooleanGetValue(Value)) {
          unsigned int v13 = 2;
        }
        else {
          unsigned int v13 = 1;
        }
      }
      else
      {
        unsigned int v13 = 0;
      }
      sub_101262A00(a1, v13);
    }
    sub_100057D78((const void **)&theDict[1]);
    CFTypeID v14 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      CFDictionaryRef v15 = (const __CFDictionary *)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      memset(theDict, 0, 24);
      ctu::cf::assign();
      *(_OWORD *)std::string __p = *(_OWORD *)theDict;
      CFDictionaryRef v19 = theDict[2];
      CFDictionaryRef v16 = (const __CFDictionary *)__p;
      if (SHIBYTE(theDict[2]) < 0) {
        CFDictionaryRef v16 = theDict[0];
      }
      LODWORD(theDict[0]) = 136315650;
      *(CFDictionaryRef *)((char *)theDict + 4) = v15;
      WORD2(theDict[1]) = 2080;
      *(CFDictionaryRef *)((char *)&theDict[1] + 6) = (CFDictionaryRef)" ";
      HIWORD(theDict[2]) = 2080;
      theDict[3] = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%schanged %s trigger service evaluation", (uint8_t *)theDict, 0x20u);
      if (SHIBYTE(v19) < 0) {
        operator delete(__p[0]);
      }
    }
    *(unsigned char *)(a1 + 232) = 1;
  }
  return a2;
}

void sub_10126C410(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10126C448(uint64_t a1, uint64_t a2, uint64_t a3, const __CFDictionary *a4, const __CFDictionary *a5)
{
  uint64_t result = sub_1007FA824(*(void **)(a1 + 168));
  if (result)
  {
    if (a5)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a5, @"assignments");
      if (Value && (v10 = Value, CFTypeID v11 = CFGetTypeID(Value), v11 == CFDictionaryGetTypeID()))
      {
        CFIndex Count = CFDictionaryGetCount(v10);
        memset(keys, 0, 24);
        sub_10019E8F0(keys, Count);
        values[0] = 0;
        values[1] = 0;
        std::string::size_type v26 = 0;
        sub_10004EE3C(values, Count);
        CFDictionaryGetKeysAndValues(v10, (const void **)keys[0], (const void **)values[0]);
        if (Count < 1)
        {
LABEL_9:
          a5 = 0;
        }
        else
        {
          uint64_t v13 = 0;
          while (1)
          {
            CFTypeID v14 = (const void *)sub_1007FA824(*(void **)(a1 + 168));
            if (CFEqual(v14, values[0][v13])) {
              break;
            }
            if (Count == ++v13) {
              goto LABEL_9;
            }
          }
          a5 = (const __CFDictionary *)keys[0][v13];
        }
        if (values[0])
        {
          values[1] = values[0];
          operator delete(values[0]);
        }
        if (keys[0])
        {
          keys[1] = keys[0];
          operator delete(keys[0]);
        }
      }
      else
      {
        a5 = 0;
      }
    }
    if (a4
      && (CFDictionaryRef v15 = (const __CFDictionary *)CFDictionaryGetValue(a4, @"assignments"), (v16 = v15) != 0)
      && (CFTypeID v17 = CFGetTypeID(v15), v17 == CFDictionaryGetTypeID()))
    {
      CFIndex v18 = CFDictionaryGetCount(v16);
      memset(keys, 0, 24);
      sub_10019E8F0(keys, v18);
      values[0] = 0;
      values[1] = 0;
      std::string::size_type v26 = 0;
      sub_10004EE3C(values, v18);
      CFDictionaryGetKeysAndValues(v16, (const void **)keys[0], (const void **)values[0]);
      if (v18 < 1)
      {
LABEL_23:
        uint64_t v21 = 0;
      }
      else
      {
        uint64_t v19 = 0;
        while (1)
        {
          CFTypeID v20 = (const void *)sub_1007FA824(*(void **)(a1 + 168));
          if (CFEqual(v20, values[0][v19])) {
            break;
          }
          if (v18 == ++v19) {
            goto LABEL_23;
          }
        }
        uint64_t v21 = keys[0][v19];
      }
      if (values[0])
      {
        values[1] = values[0];
        operator delete(values[0]);
      }
      if (keys[0])
      {
        keys[1] = keys[0];
        operator delete(keys[0]);
      }
      if ((a5 != 0) == (v21 != 0))
      {
        uint64_t result = 0;
        if (!a5 || !v21) {
          return result;
        }
        if (CFEqual(a5, v21)) {
          return 0;
        }
      }
    }
    else if (!a5)
    {
      return 0;
    }
    CFDictionaryRef v22 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = (void **)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      memset(keys, 0, 24);
      ctu::cf::assign();
      *(_OWORD *)std::string values = *(_OWORD *)keys;
      std::string::size_type v26 = keys[2];
      __int16 v24 = (void **)values;
      if (SHIBYTE(keys[2]) < 0) {
        __int16 v24 = keys[0];
      }
      LODWORD(keys[0]) = 136315650;
      *(void ***)((char *)keys + 4) = v23;
      WORD2(keys[1]) = 2080;
      *(void ***)((char *)&keys[1] + 6) = (void **)" ";
      HIWORD(keys[2]) = 2080;
      keys[3] = v24;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s%schanged %s trigger service evaluation", (uint8_t *)keys, 0x20u);
      if (SHIBYTE(v26) < 0) {
        operator delete(values[0]);
      }
    }
    uint64_t result = 1;
    *(unsigned char *)(a1 + 232) = 1;
  }
  return result;
}

void sub_10126C778(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10126C7D8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 704);
}

uint64_t sub_10126C7E0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 696);
}

const void **sub_10126C7E8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 224))(a1);
  int v5 = *(_DWORD *)(a1 + 256);
  if (v5) {
    BOOL v6 = v5 == 2;
  }
  else {
    BOOL v6 = sub_10125ADA4(a1);
  }
  if (v4 == 1)
  {
    BOOL v7 = 0;
    char v8 = 1;
    BOOL v9 = 1;
  }
  else
  {
    BOOL v7 = 0;
    char v8 = *(unsigned char *)(a1 + 592);
    BOOL v9 = v8 != 0;
    if (!v8 && v6)
    {
      BOOL v7 = sub_100A2EAC0(*(void *)(a1 + 160), *(_DWORD *)(a1 + 260));
      char v8 = 0;
      BOOL v9 = 0;
    }
  }
  CFDictionaryRef v10 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = a2;
    uint64_t v19 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    uint64_t v11 = *(int *)(a1 + 256);
    CFArrayRef v12 = (char *)&unk_10161656E;
    if (v11 <= 2) {
      CFArrayRef v12 = off_101AA4880[v11];
    }
    if (v6) {
      uint64_t v13 = "on";
    }
    else {
      uint64_t v13 = "off";
    }
    uint64_t v14 = asStringBool(v7);
    CFDictionaryRef v15 = "Active";
    if (v4 != 1) {
      CFDictionaryRef v15 = (const char *)&unk_10161656E;
    }
    if (v4) {
      CFDictionaryRef v16 = v15;
    }
    else {
      CFDictionaryRef v16 = "Disabled";
    }
    uint64_t v17 = asStringBool(*(unsigned char *)(a1 + 592));
    *(_DWORD *)std::string buf = 136316930;
    *(void *)&uint8_t buf[4] = v19;
    __int16 v22 = 2080;
    uint64_t v23 = " ";
    __int16 v24 = 2080;
    uint64_t v25 = v12;
    __int16 v26 = 2080;
    uint64_t v27 = v13;
    __int16 v28 = 2080;
    uint64_t v29 = v14;
    __int16 v30 = 2080;
    uint64_t v31 = v16;
    __int16 v32 = 2080;
    uint64_t v33 = v17;
    __int16 v34 = 2080;
    uint64_t v35 = asStringBool(v9);
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%sThumper user switch state is %s ('%s'), activating: %s; service status: %s; reprovisioining: %s; isEnabled return '%s'",
      buf,
      0x52u);
    a2 = v20;
  }
  *(unsigned char *)a2 = v8;
  *(void *)(a2 + 8) = 0;
  *(void *)std::string buf = 0;
  return sub_100057D78((const void **)buf);
}

const void **sub_10126CA30@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_10126C7E8(a1 - 8, a2);
}

const void **sub_10126CA38@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (capabilities::ct *)sub_101262800(a1);
  if (!(_BYTE)v4)
  {
    CFMutableDictionaryRef theDict = 0;
    goto LABEL_8;
  }
  CFMutableDictionaryRef theDict = 0;
  if (!capabilities::ct::supportsThumperService(v4))
  {
LABEL_8:
    LOBYTE(v7) = 0;
    LOBYTE(v6) = 0;
    char v8 = 0;
    LOWORD(v20) = 0;
    BYTE2(v20) = 0;
    CFMutableDictionaryRef v21 = 0;
    goto LABEL_41;
  }
  int v5 = *(_DWORD *)(a1 + 260);
  if (v5 != 5)
  {
    if (v5 == 2)
    {
      int v6 = 1;
      goto LABEL_10;
    }
    if (v5 != 1)
    {
      CFDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        CFMutableDictionaryRef v11 = theDict;
        CFMutableDictionaryRef theDict = Mutable;
        CFMutableDictionaryRef v20 = v11;
        sub_10005717C((const void **)&v20);
      }
      int v7 = 0;
      int v6 = 0;
      goto LABEL_14;
    }
  }
  int v6 = 0;
LABEL_10:
  sub_100A30BFC(*(void *)(a1 + 160), &v22);
  CFMutableDictionaryRef v20 = theDict;
  BOOL v9 = v22;
  __int16 v22 = 0;
  CFMutableDictionaryRef theDict = v9;
  sub_10005717C((const void **)&v20);
  sub_10005717C((const void **)&v22);
  int v7 = 1;
LABEL_14:
  int v12 = *(_DWORD *)(a1 + 256);
  if (v12) {
    BOOL v13 = v12 == 2;
  }
  else {
    BOOL v13 = sub_10125ADA4(a1);
  }
  if (*(_DWORD *)(a1 + 584) == 1) {
    goto LABEL_27;
  }
  char v14 = !v13;
  if (*(unsigned char *)(a1 + 592)) {
    char v14 = 1;
  }
  if (v14)
  {
LABEL_27:
    BOOL v16 = 0;
  }
  else
  {
    uint64_t v15 = *(void *)(a1 + 160);
    BOOL v16 = sub_100A2EAC0(v15, *(_DWORD *)(a1 + 260))
       || *(unsigned char *)(v15 + 353)
       || *(unsigned char *)(a1 + 588)
       || *(unsigned char *)(a1 + 589)
       || *(unsigned char *)(a1 + 590)
       || *(unsigned char *)(a1 + 591) != 0;
  }
  int v17 = sub_100A2EB20(*(void *)(a1 + 160));
  if (v6)
  {
    if (v16)
    {
      CFIndex v18 = (const void **)&kCTProvisioningStatusInProcess;
    }
    else if (v17 == 1)
    {
      CFIndex v18 = (const void **)&kCTProvisioningStatusSubscribed;
    }
    else
    {
      CFIndex v18 = (const void **)&kCTProvisioningStatusNotSubscribed;
    }
  }
  else if (v7)
  {
    CFIndex v18 = (const void **)&kCTProvisioningStatusInProcess;
    if (!v16) {
      CFIndex v18 = (const void **)&kCTProvisioningStatusNotSubscribed;
    }
  }
  else
  {
    CFIndex v18 = (const void **)&kCTProvisioningStatusNotAllowed;
  }
  CFDictionarySetValue(theDict, kCTProvisioningStatus, *v18);
  char v8 = 1;
  LOBYTE(v20) = 1;
  BYTE1(v20) = v7;
  BYTE2(v20) = v6;
  CFMutableDictionaryRef v21 = theDict;
  if (theDict)
  {
    CFRetain(theDict);
    char v8 = 1;
  }
LABEL_41:
  *(unsigned char *)a2 = v8;
  *(unsigned char *)(a2 + 1) = v7;
  *(unsigned char *)(a2 + 2) = v6;
  sub_10004EFE4((void *)(a2 + 8), (CFTypeRef *)&v21);
  sub_10005717C((const void **)&v21);
  return sub_10005717C((const void **)&theDict);
}

void sub_10126CCBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_10126CCF0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_10126CA38(a1 - 8, a2);
}

uint64_t sub_10126CCFC(uint64_t a1, uint64_t a2, CFDictionaryRef *a3)
{
  if (*a3) {
    int v4 = sub_100080778;
  }
  else {
    int v4 = 0;
  }
  if (!v4) {
    return 1;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(*a3, kPSUserPreference);
  if (Value)
  {
    CFTypeID v7 = CFGetTypeID(Value);
    BOOL v8 = v7 == CFBooleanGetTypeID();
  }
  else
  {
    BOOL v8 = 0;
  }
  CFStringRef v9 = (const __CFString *)CFDictionaryGetValue(*a3, kPSAssociatedAccountID);
  uint64_t result = 1;
  if (v9 && !v8)
  {
    CFTypeID v11 = CFGetTypeID(v9);
    CFTypeID TypeID = CFStringGetTypeID();
    CFStringRef v13 = *(const __CFString **)(a1 + 264);
    if (v13) {
      char v14 = sub_1000810B8;
    }
    else {
      char v14 = 0;
    }
    if ((v11 == TypeID) == (v14 == 0) || v11 == TypeID && CFStringCompare(v9, v13, 0)) {
      return 1;
    }
    uint64_t v15 = *(NSObject **)(a1 + 56);
    BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v16)
    {
      uint64_t v17 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      int v18 = 136315394;
      uint64_t v19 = v17;
      __int16 v20 = 2080;
      CFMutableDictionaryRef v21 = " ";
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%sduplicated switch account request - ignoring", (uint8_t *)&v18, 0x16u);
      return 0;
    }
  }
  return result;
}

uint64_t sub_10126CEA8(uint64_t a1, uint64_t a2, CFDictionaryRef *a3)
{
  return sub_10126CCFC(a1 - 8, 0, a3);
}

void sub_10126CEB4(uint64_t a1, BOOL a2, CFDictionaryRef *a3)
{
  if (*a3) {
    int v6 = sub_100080778;
  }
  else {
    int v6 = 0;
  }
  BOOL v7 = a2;
  if (v6)
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(*a3, kPSUserPreference);
    if (!Value) {
      goto LABEL_10;
    }
    CFBooleanRef v9 = Value;
    CFTypeID v10 = CFGetTypeID(Value);
    if (v10 != CFBooleanGetTypeID()) {
      goto LABEL_10;
    }
    BOOL v7 = CFBooleanGetValue(v9) != 0;
  }
  if (sub_100810848(a1)) {
    sub_10125AFE8(a1, v7);
  }
LABEL_10:
  CFTypeID v11 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v55 = 2080;
    CFArrayRef v56 = (char *)asStringBool(a2);
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s%ssetEnabled, val: %s", buf, 0x20u);
  }
  *(void *)std::string buf = off_101AA4760;
  *(void *)&uint8_t buf[8] = a1;
  CFArrayRef v56 = buf;
  logger::CFTypeRefLogger();
  sub_10012C330(buf);
  if (*a3) {
    CFStringRef v13 = sub_100080778;
  }
  else {
    CFStringRef v13 = 0;
  }
  if (v13)
  {
    unint64_t v14 = (unint64_t)CFDictionaryGetValue(*a3, kPSUserPreference);
    uint64_t v15 = CFDictionaryGetValue(*a3, kPSAssociatedAccountID);
    unint64_t v16 = (unint64_t)v15;
    if (v15)
    {
      CFTypeID v17 = CFGetTypeID(v15);
      if (v17 == CFStringGetTypeID())
      {
        *(void *)&long long v52 = v16;
        *(void *)std::string buf = 0;
        sub_100056248(buf, (CFTypeRef *)&v52);
        uint64_t v18 = *(void *)(a1 + 264);
        *(void *)(a1 + 264) = *(void *)buf;
        *(void *)std::string buf = v18;
      }
      else
      {
        uint64_t v19 = *(void *)(a1 + 264);
        *(void *)(a1 + 264) = 0;
        *(void *)std::string buf = v19;
      }
      sub_1000558F4((const void **)buf);
      setAssociatedID(*(const __CFString **)(a1 + 264));
      sub_1007F96BC(*(void **)(a1 + 168));
    }
  }
  else
  {
    unint64_t v14 = 0;
    unint64_t v16 = 0;
  }
  if (!sub_1007FA824(*(void **)(a1 + 168))) {
    goto LABEL_37;
  }
  if ((*(char *)(a1 + 207) & 0x80000000) == 0)
  {
    if (*(unsigned char *)(a1 + 207)) {
      goto LABEL_25;
    }
LABEL_37:
    uint64_t v33 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v34 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v34;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I %s%ssetEnabled, no device ID or account ID yet", buf, 0x16u);
    }
    goto LABEL_39;
  }
  if (!*(void *)(a1 + 192)) {
    goto LABEL_37;
  }
LABEL_25:
  __int16 v20 = (uint64_t *)(v14 | v16);
  CFBooleanRef v21 = kCFBooleanFalse;
  if (a2) {
    CFBooleanRef v21 = kCFBooleanTrue;
  }
  if (v20) {
    CFBooleanRef v22 = (CFBooleanRef)v14;
  }
  else {
    CFBooleanRef v22 = v21;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v20, *(Registry **)(a1 + 120));
  __int16 v24 = ServiceMap;
  if (v25 < 0)
  {
    __int16 v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v27 = 5381;
    do
    {
      uint64_t v25 = v27;
      unsigned int v28 = *v26++;
      uint64_t v27 = (33 * v27) ^ v28;
    }
    while (v28);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v25;
  uint64_t v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)buf);
  if (v29)
  {
    uint64_t v31 = (GestaltUtilityInterface *)v29[3];
    __int16 v30 = (std::__shared_weak_count *)v29[4];
    if (v30)
    {
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v24);
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v30);
      char v32 = 0;
      goto LABEL_42;
    }
  }
  else
  {
    uint64_t v31 = 0;
  }
  std::mutex::unlock(v24);
  __int16 v30 = 0;
  char v32 = 1;
LABEL_42:
  int isWatch = GestaltUtilityInterface::isWatch(v31);
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  if (isWatch) {
    CFBooleanRef v36 = 0;
  }
  else {
    CFBooleanRef v36 = v22;
  }
  if (*(_DWORD *)(a1 + 260) != 2 && a2)
  {
    int v37 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v38 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v38;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s%sThumper cannot be turned ON since feature is not allowed", buf, 0x16u);
    }
LABEL_39:
    sub_100A2FD3C(*(void *)(a1 + 160), 1, 1);
    return;
  }
  if (sub_101262800(a1))
  {
    if (!v36 || !sub_101264F90(a1))
    {
LABEL_86:
      sub_10125E354((const void **)a1, v36 != 0, 0);
      return;
    }
    int v39 = *(_DWORD *)(a1 + 256);
    if (CFEqual(v36, kCFBooleanTrue)) {
      unsigned int v40 = 2;
    }
    else {
      unsigned int v40 = 1;
    }
    int v41 = sub_101262A00(a1, v40);
    if (v39) {
      BOOL v42 = v39 == 2;
    }
    else {
      BOOL v42 = sub_10125ADA4(a1);
    }
    int v48 = *(_DWORD *)(a1 + 256);
    if (v48)
    {
      if (v48 == 2)
      {
        if (v42)
        {
LABEL_84:
          if (v41) {
            sub_101267708(a1, 0);
          }
          goto LABEL_86;
        }
        goto LABEL_80;
      }
      if (!v42) {
        goto LABEL_84;
      }
    }
    else
    {
      if (v42 == sub_10125ADA4(a1)) {
        goto LABEL_84;
      }
      int v48 = *(_DWORD *)(a1 + 256);
    }
    if (!v48)
    {
      BOOL v49 = sub_10125ADA4(a1);
      goto LABEL_83;
    }
    if (v48 != 2)
    {
      BOOL v49 = 0;
      goto LABEL_83;
    }
LABEL_80:
    BOOL v49 = 1;
LABEL_83:
    buf[0] = v49;
    sub_10126790C(a1, 0, 0, 0, buf, 0);
    goto LABEL_84;
  }
  uint64_t v43 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v44 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    unint64_t v45 = (unint64_t)sub_101262800(a1) >> 32;
    if (v45 == 3) {
      unsigned int v46 = (char *)&unk_10161656E;
    }
    else {
      unsigned int v46 = off_101AA4880[v45];
    }
    if (sub_1007FA824(*(void **)(a1 + 168)))
    {
      sub_1007FA824(*(void **)(a1 + 168));
      long long v52 = 0uLL;
      uint64_t v53 = 0;
      ctu::cf::assign();
      *(_OWORD *)std::string __p = v52;
      uint64_t v51 = v53;
      xpc_object_t v47 = __p;
      if (v53 < 0) {
        xpc_object_t v47 = (void **)v52;
      }
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = v44;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v55 = 2080;
      CFArrayRef v56 = v46;
      __int16 v57 = 2080;
      unsigned int v58 = (const char *)v47;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I %s%sDevice not associated. switch status: %s, deviceId: '%s'", buf, 0x2Au);
      if (SHIBYTE(v51) < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = v44;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v55 = 2080;
      CFArrayRef v56 = v46;
      __int16 v57 = 2080;
      unsigned int v58 = "";
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I %s%sDevice not associated. switch status: %s, deviceId: '%s'", buf, 0x2Au);
    }
  }
}

void sub_10126D5A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10126D5F8(uint64_t a1, BOOL a2, CFDictionaryRef *a3)
{
}

uint64_t sub_10126D600(uint64_t a1)
{
  return *(unsigned int *)(a1 + 584);
}

uint64_t sub_10126D608(uint64_t a1)
{
  return *(unsigned int *)(a1 + 576);
}

uint64_t sub_10126D610(uint64_t a1)
{
  sub_100810C84(a1);
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    uint64_t v4 = *(int *)(a1 + 256);
    int v5 = (char *)&unk_10161656E;
    if (v4 <= 2) {
      int v5 = off_101AA4880[v4];
    }
    int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 224))(a1);
    BOOL v7 = "Active";
    if (v6 != 1) {
      BOOL v7 = (const char *)&unk_10161656E;
    }
    if (v6) {
      BOOL v8 = v7;
    }
    else {
      BOOL v8 = "Disabled";
    }
    unsigned int v9 = *(_DWORD *)(a1 + 260) - 1;
    if (v9 > 5) {
      CFTypeID v10 = "???";
    }
    else {
      CFTypeID v10 = off_101AA4898[v9];
    }
    uint64_t v11 = asStringBool(*(unsigned char *)(a1 + 456));
    *(_DWORD *)std::string buf = 136316418;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v5;
    *(_WORD *)&uint8_t buf[32] = 2080;
    *(void *)&buf[34] = v8;
    *(_WORD *)&buf[42] = 2080;
    *(void *)&buf[44] = v10;
    *(_WORD *)&buf[52] = 2080;
    *(void *)&buf[54] = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s| fSwitchState: %s, fServiceStatus: %s, fEntitlementResultForThumper: %s, fProvisioningApplied: %s", buf, 0x3Eu);
    uint64_t v2 = *(NSObject **)(a1 + 56);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    memset(buf, 0, 24);
    ctu::cf::assign();
    *(_OWORD *)std::string __p = *(_OWORD *)buf;
    __p[2] = *(void **)&buf[16];
    CFStringRef v13 = *(void ***)buf;
    if ((buf[23] & 0x80u) == 0) {
      CFStringRef v13 = __p;
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s| fAssociatedAccountID: %s", buf, 0x20u);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v69 = 0;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v56 = 0u;
  memset(buf, 0, sizeof(buf));
  sub_10004BD84((uint64_t)buf);
  unint64_t v14 = sub_10004B96C(&buf[16], (uint64_t)"fSetProvisioningResultData: ", 28);
  sub_100C90F00(v14, a1 + 312);
  uint64_t v15 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v16 = (void *)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    sub_10004BC98((uint64_t)&buf[24], v45);
    CFTypeID v17 = SHIBYTE(v46) >= 0 ? v45 : (void **)v45[0];
    LODWORD(__p[0]) = 136315650;
    *(void **)((char *)__p + 4) = v16;
    WORD2(__p[1]) = 2080;
    *(void **)((char *)&__p[1] + 6) = " ";
    HIWORD(__p[2]) = 2080;
    *(void *)int v48 = v17;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%s| %s", (uint8_t *)__p, 0x20u);
    if (SHIBYTE(v46) < 0) {
      operator delete(v45[0]);
    }
  }
  uint64_t v44 = 0;
  if (*(char *)(a1 + 207) < 0)
  {
    if (!*(void *)(a1 + 192))
    {
LABEL_33:
      int v21 = 0;
      int v20 = 0;
      goto LABEL_35;
    }
  }
  else if (!*(unsigned char *)(a1 + 207))
  {
    goto LABEL_33;
  }
  if (!sub_1007FA824(*(void **)(a1 + 168))) {
    goto LABEL_33;
  }
  sub_1007FA824(*(void **)(a1 + 168));
  memset(__p, 0, sizeof(__p));
  ctu::cf::assign();
  *(_OWORD *)unint64_t v45 = *(_OWORD *)__p;
  unsigned int v46 = __p[2];
  uint64_t v18 = sub_1012686C0(*(void *)(*(void *)(a1 + 168) + 208), *(std::__shared_weak_count **)(*(void *)(a1 + 168) + 216), (void **)(a1 + 184), v45);
  int v19 = v18;
  int v20 = BYTE4(v18);
  if (SHIBYTE(v46) < 0) {
    operator delete(v45[0]);
  }
  if (v19 == -1)
  {
    int v21 = 0;
  }
  else
  {
    CFBooleanRef v22 = *(void **)(a1 + 168);
    uint64_t v23 = sub_1007FA824(v22);
    sub_1007FFAA4(v22, 0, (void **)(a1 + 184), v23, (const void **)__p);
    int v21 = (int)__p[0];
    __int16 v24 = v44;
    uint64_t v44 = __p[1];
    v45[0] = v24;
    __p[1] = 0;
    sub_100057D78((const void **)v45);
    sub_100057D78((const void **)&__p[1]);
  }
LABEL_35:
  uint64_t v25 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v26 = (void *)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    uint64_t v27 = asStringBool(v20 != 0);
    LODWORD(__p[0]) = 136315906;
    *(void **)((char *)__p + 4) = v26;
    WORD2(__p[1]) = 2080;
    *(void **)((char *)&__p[1] + 6) = " ";
    HIWORD(__p[2]) = 1024;
    *(_DWORD *)int v48 = v21;
    *(_WORD *)&v48[4] = 2080;
    *(void *)&v48[6] = v27;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s%s| Account CFG of ver %ul, trusted:%s", (uint8_t *)__p, 0x26u);
  }
  __p[0] = off_101AA47E0;
  __p[1] = (void *)a1;
  *(void *)int v48 = __p;
  logger::CFTypeRefLogger();
  sub_10012C330(__p);
  int v28 = sub_100810848(a1);
  uint64_t v29 = *(NSObject **)(a1 + 56);
  if (v28 && os_log_type_enabled(*(os_log_t *)(a1 + 56), OS_LOG_TYPE_DEFAULT))
  {
    __int16 v30 = (void *)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    uint64_t v31 = asStringBool(*(void *)(a1 + 600) != 0);
    LODWORD(__p[0]) = 136315650;
    *(void **)((char *)__p + 4) = v30;
    WORD2(__p[1]) = 2080;
    *(void **)((char *)&__p[1] + 6) = " ";
    HIWORD(__p[2]) = 2080;
    *(void *)int v48 = v31;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %s%s| fThumperKeepAliveAssertion: %s", (uint8_t *)__p, 0x20u);
    uint64_t v29 = *(NSObject **)(a1 + 56);
  }
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    char v32 = (void *)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    Registry::getXpcJetsamAssertionManager((uint64_t *)&v42, *(Registry **)(a1 + 120));
    ctu::XpcJetsamAssertion::dumpState((uint64_t *)v45, v42);
    if (SHIBYTE(v46) >= 0) {
      uint64_t v33 = v45;
    }
    else {
      uint64_t v33 = (void **)v45[0];
    }
    LODWORD(__p[0]) = 136315650;
    *(void **)((char *)__p + 4) = v32;
    WORD2(__p[1]) = 2080;
    *(void **)((char *)&__p[1] + 6) = " ";
    HIWORD(__p[2]) = 2080;
    *(void *)int v48 = v33;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %s%s| %s", (uint8_t *)__p, 0x20u);
    if (SHIBYTE(v46) < 0) {
      operator delete(v45[0]);
    }
    if (v43) {
      sub_10004D2C8(v43);
    }
    uint64_t v29 = *(NSObject **)(a1 + 56);
  }
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v34 = (void *)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    uint64_t v35 = asStringBool(*(unsigned char *)(a1 + 588));
    uint64_t v36 = asStringBool(*(unsigned char *)(a1 + 589));
    uint64_t v37 = asStringBool(*(unsigned char *)(a1 + 590));
    uint64_t v38 = asStringBool(*(unsigned char *)(a1 + 616));
    uint64_t v39 = asStringBool(*(unsigned char *)(a1 + 704));
    LODWORD(__p[0]) = 136316674;
    *(void **)((char *)__p + 4) = v34;
    WORD2(__p[1]) = 2080;
    *(void **)((char *)&__p[1] + 6) = " ";
    HIWORD(__p[2]) = 2080;
    *(void *)int v48 = v35;
    *(_WORD *)&v48[8] = 2080;
    *(void *)&v48[10] = v36;
    __int16 v49 = 2080;
    uint64_t v50 = v37;
    __int16 v51 = 2080;
    uint64_t v52 = v38;
    __int16 v53 = 2080;
    uint64_t v54 = v39;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %s%s| fAwaitingGetProvisioning: %s, fAwaitingSetProvisioning: %s, fGeneratingKeyAndCsr: %s, ProvisioningFailedAlertShown: %s, fLocationRequired: %s", (uint8_t *)__p, 0x48u);
  }
  sub_100057D78((const void **)&v44);
  *(void *)&uint8_t buf[16] = v40;
  if (SHIBYTE(v58) < 0) {
    operator delete(*((void **)&v57 + 1));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10126DE58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
}

uint64_t sub_10126DF10(uint64_t a1)
{
  return sub_10126D610(a1 - 8);
}

uint64_t sub_10126DF18(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 496);
  std::mutex::lock((std::mutex *)(a1 + 496));
  if (*(_DWORD *)(a1 + 584) == 1 && (uint64_t v5 = *(void *)(a1 + 560)) != 0)
  {
    sub_10126DF98(a2, v5);
    uint64_t v6 = 1;
  }
  else
  {
    uint64_t v6 = 0;
  }
  std::mutex::unlock(v4);
  return v6;
}

void sub_10126DF84(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10126DF98(uint64_t a1, uint64_t a2)
{
  std::string::operator=((std::string *)a1, (const std::string *)a2);
  std::string::operator=((std::string *)(a1 + 24), (const std::string *)(a2 + 24));
  if (a1 != a2) {
    sub_10005CA3C(a1 + 48, *(std::string **)(a2 + 48), *(long long **)(a2 + 56), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 56) - *(void *)(a2 + 48)) >> 3));
  }
  std::string::operator=((std::string *)(a1 + 72), (const std::string *)(a2 + 72));
  std::string::operator=((std::string *)(a1 + 96), (const std::string *)(a2 + 96));
  std::string::operator=((std::string *)(a1 + 120), (const std::string *)(a2 + 120));
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a2 + 144);
  std::string::operator=((std::string *)(a1 + 152), (const std::string *)(a2 + 152));
  *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
  std::string::operator=((std::string *)(a1 + 184), (const std::string *)(a2 + 184));
  std::string::operator=((std::string *)(a1 + 208), (const std::string *)(a2 + 208));
  std::string::operator=((std::string *)(a1 + 232), (const std::string *)(a2 + 232));
  return a1;
}

CFDictionaryRef sub_10126E05C(uint64_t a1, const void *a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 496);
  std::mutex::lock((std::mutex *)(a1 + 496));
  CFDictionaryRef v5 = *(const __CFDictionary **)(a1 + 576);
  if (v5) {
    uint64_t v6 = sub_100080778;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6 && (CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v5, a2)) != 0) {
    CFDictionaryRef Copy = CFDictionaryCreateCopy(0, Value);
  }
  else {
    CFDictionaryRef Copy = 0;
  }
  std::mutex::unlock(v4);
  return Copy;
}

void sub_10126E0E4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_10126E0F8(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v6 = (std::mutex *)(a1 + 496);
  std::mutex::lock((std::mutex *)(a1 + 496));
  if ((a2 & 0x4020000) != 0 && *(_DWORD *)(a1 + 584) == 1 && *(void *)(a1 + 560))
  {
    uint64_t v8 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    sub_1003AA8C0(&v8, (CFTypeRef *)&Mutable);
    sub_100BBEC88(&Mutable);
  }
  *a3 = 0;
  a3[1] = 0;
  std::mutex::unlock(v6);
}

void sub_10126E294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100057D78((const void **)va);
  if (v5) {
    sub_10004D2C8(v5);
  }
  std::mutex::unlock(v4);
  _Unwind_Resume(a1);
}

const void **sub_10126E2D4(uint64_t a1)
{
  uint64_t result = (const void **)sub_1007FA824(*(void **)(a1 + 168));
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 168);
    unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 176))(a1);
    return sub_1007FE5B8(v3, 2u, 0, v4, (long long *)(a1 + 184), 1, 1);
  }
  return result;
}

uint64_t sub_10126E364(uint64_t result)
{
  if (!*(unsigned char *)(result + 593))
  {
    uint64_t v1 = (const void **)result;
    uint64_t result = sub_101261B64(result);
    if (result)
    {
      return (uint64_t)sub_10125E354(v1, 0, 1);
    }
  }
  return result;
}

void sub_10126E3BC(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 120));
  uint64_t v3 = ServiceMap;
  unsigned int v4 = "8UStorage";
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    CFDictionaryRef v5 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unsigned int v4 = (const char *)v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t valuePtr = (unint64_t)v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &valuePtr);
  if (v8)
  {
    CFTypeID v10 = (os_unfair_lock_s *)v8[3];
    unsigned int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    CFTypeID v10 = 0;
  }
  std::mutex::unlock(v3);
  unsigned int v9 = 0;
  char v11 = 1;
LABEL_9:
  CFNumberRef v16 = 0;
  unint64_t valuePtr = dword_101B133E8;
  CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v12)
  {
    unint64_t v13 = (unint64_t)v16;
    CFNumberRef v16 = v12;
    unint64_t valuePtr = v13;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v14 = v16;
  CFNumberRef v15 = v16;
  CFNumberRef v16 = 0;
  sub_1000570E8((const void **)&v16);
  sub_1000825C4(v10, @"last.dev.icloud.ver", v14, kPhoneServicesWalletDomain, 0, 1u, 0, 0);
  sub_1000570E8((const void **)&v15);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_10126E514(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10126E544()
{
  return dword_101B133E8;
}

void sub_10126E550(uint64_t a1, int a2)
{
  dword_101B133E8 = a2;
}

void sub_10126E55C(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 591) = 0;
  if (!a2 || !sub_101268800(a1) || !*(void *)(a1 + 624)) {
    goto LABEL_12;
  }
  memset(v9, 0, sizeof(v9));
  ctu::cf::assign();
  uint64_t v3 = *(void *)(a1 + 624);
  if (*(void *)(v3 + 8) != *(void *)v3)
  {
    if (*(void *)v9)
    {
      operator delete(0);
      CFDictionaryRef v5 = *(NSObject **)(a1 + 56);
      BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
LABEL_6:
      if (!v6) {
LABEL_14:
      }
        operator new();
LABEL_13:
      uint64_t v8 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      *(_DWORD *)unsigned int v9 = 136315394;
      *(void *)&v9[4] = v8;
      *(_WORD *)&v9[12] = 2080;
      *(void *)&v9[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sReceived new individual encryption key", v9, 0x16u);
      goto LABEL_14;
    }
LABEL_12:
    CFDictionaryRef v5 = *(NSObject **)(a1 + 56);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  int v4 = memcmp(*(const void **)v9, *(const void **)v3, 0);
  CFDictionaryRef v5 = *(NSObject **)(a1 + 56);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4) {
    goto LABEL_6;
  }
  if (v6)
  {
    uint64_t v7 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    *(_DWORD *)unsigned int v9 = 136315394;
    *(void *)&v9[4] = v7;
    *(_WORD *)&v9[12] = 2080;
    *(void *)&v9[14] = " ";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sReceived duplicated individual encryption key", v9, 0x16u);
  }
}

void sub_10126E938(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10126E9C0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  CFMutableDictionaryRef theDict = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v5 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    __p[0] = v5;
    sub_10005717C((const void **)__p);
  }
  CFStringRef theString2 = 0;
  if (*(char *)(a1 + 207) < 0)
  {
    sub_10004FC84(v42, *(void **)(a1 + 184), *(void *)(a1 + 192));
  }
  else
  {
    *(_OWORD *)BOOL v42 = *(_OWORD *)(a1 + 184);
    uint64_t v43 = *(void *)(a1 + 200);
  }
  if (SHIBYTE(v43) < 0)
  {
    sub_10004FC84(__dst, v42[0], (unint64_t)v42[1]);
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)v42;
    uint64_t v48 = v43;
  }
  CFStringRef v46 = 0;
  if (SHIBYTE(v48) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    uint64_t v50 = v48;
  }
  CFStringRef v51 = 0;
  if (ctu::cf::convert_copy())
  {
    BOOL v6 = (__CFArray *)v46;
    CFStringRef v46 = v51;
    uint64_t v52 = v6;
    sub_1000558F4((const void **)&v52);
  }
  if (SHIBYTE(v50) < 0) {
    operator delete(__p[0]);
  }
  CFStringRef theString2 = v46;
  CFStringRef v46 = 0;
  sub_1000558F4((const void **)&v46);
  if (SHIBYTE(v48) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v43) < 0) {
    operator delete(v42[0]);
  }
  uint64_t v7 = (const void *)kPSAccountId;
  CFDictionarySetValue(theDict, kPSAccountId, theString2);
  uint64_t v8 = theDict;
  int v10 = capabilities::ct::supportsThumperService(v9);
  char v11 = (const void **)&kCFBooleanFalse;
  if (v10) {
    char v11 = (const void **)&kCFBooleanTrue;
  }
  CFDictionaryAddValue(v8, kPSThumperCalling, *v11);
  CFNumberRef v12 = *(const void **)(a1 + 264);
  if (v12) {
    unint64_t v13 = sub_1000810B8;
  }
  else {
    unint64_t v13 = 0;
  }
  if (v13) {
    CFDictionaryAddValue(theDict, kPSAssociatedAccountID, v12);
  }
  __dst[0] = 0;
  sub_100058198((const void **)__dst, (const void **)(*(void *)(a1 + 168) + 200));
  if (__dst[0]) {
    CFNumberRef v14 = sub_100080778;
  }
  else {
    CFNumberRef v14 = 0;
  }
  if (v14)
  {
    CFNumberRef v15 = (const void *)kPSDeviceId;
    CFDictionaryRef Value = CFDictionaryGetValue(__dst[0], kPSDeviceId);
    if (Value) {
      CFDictionarySetValue(theDict, v15, Value);
    }
    uint64_t v52 = 0;
    CFMutableArrayRef v17 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v17)
    {
      uint64_t v18 = v52;
      uint64_t v52 = v17;
      __p[0] = v18;
      sub_1000440D4((const void **)__p);
    }
    int v19 = (const void *)kPSAccountList;
    CFArrayRef v20 = (const __CFArray *)CFDictionaryGetValue(__dst[0], kPSAccountList);
    CFArrayRef v21 = v20;
    if (v20)
    {
      CFTypeID v22 = CFGetTypeID(v20);
      if (v22 == CFArrayGetTypeID())
      {
        CFIndex Count = CFArrayGetCount(v21);
        if (Count)
        {
          CFIndex v24 = 0;
          while (1)
          {
            CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v21, v24);
            CFDictionaryRef v26 = ValueAtIndex;
            if (ValueAtIndex)
            {
              CFTypeID v27 = CFGetTypeID(ValueAtIndex);
              if (v27 == CFDictionaryGetTypeID())
              {
                CFStringRef v28 = (const __CFString *)CFDictionaryGetValue(v26, v7);
                CFStringRef v29 = v28;
                if (v28)
                {
                  CFTypeID v30 = CFGetTypeID(v28);
                  if (v30 == CFStringGetTypeID() && CFEqual(v29, theString2)) {
                    break;
                  }
                }
              }
            }
            if (Count == ++v24) {
              goto LABEL_45;
            }
          }
          CFArrayAppendValue(v52, v26);
          char v32 = (const void *)kPSPrimaryDeviceId;
          uint64_t v33 = CFDictionaryGetValue(v26, kPSPrimaryDeviceId);
          if (v33) {
            CFDictionarySetValue(theDict, v32, v33);
          }
          uint64_t v34 = (const void *)kPSAccountFreeSlots;
          uint64_t v35 = CFDictionaryGetValue(v26, kPSAccountFreeSlots);
          if (v35) {
            CFDictionarySetValue(theDict, v34, v35);
          }
          uint64_t v36 = (const void *)kPSMdn;
          uint64_t v37 = CFDictionaryGetValue(v26, kPSMdn);
          if (v37) {
            CFDictionarySetValue(theDict, v36, v37);
          }
          uint64_t v38 = (const void *)kPSMcc;
          uint64_t v39 = CFDictionaryGetValue(v26, kPSMcc);
          if (v39) {
            CFDictionarySetValue(theDict, v38, v39);
          }
          xpc_object_t v40 = (const void *)kPSIsoMcc;
          int v41 = CFDictionaryGetValue(v26, kPSIsoMcc);
          if (v41) {
            CFDictionarySetValue(theDict, v40, v41);
          }
        }
      }
    }
LABEL_45:
    CFDictionarySetValue(theDict, v19, v52);
    sub_1000440D4((const void **)&v52);
  }
  sub_10004EFE4(a2, (CFTypeRef *)&theDict);
  sub_100057D78((const void **)__dst);
  sub_1000558F4((const void **)&theString2);
  return sub_10005717C((const void **)&theDict);
}

void sub_10126EE4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15, const void *a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  sub_1000440D4((const void **)(v32 - 88));
  sub_100057D78((const void **)&__p);
  sub_1000558F4(&a15);
  sub_10005717C(&a16);
  _Unwind_Resume(a1);
}

const void **sub_10126EF14(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 720) + 8))(&v4);
  if (v4) {
    uint64_t v2 = sub_100080934;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t result = sub_1000577C4(&v4);
  if (v2) {
    return (const void **)(*(uint64_t (**)(void))(**(void **)(a1 + 720) + 16))(*(void *)(a1 + 720));
  }
  return result;
}

const void **sub_10126EFB8(uint64_t a1)
{
  return sub_10126EF14(a1 - 8);
}

const void **sub_10126EFC0(uint64_t a1)
{
  return sub_10126EF14(a1 - 8);
}

uint64_t sub_10126EFCC()
{
  return 0;
}

uint64_t sub_10126EFDC()
{
  return 0;
}

uint64_t sub_10126EFFC()
{
  return 0;
}

uint64_t sub_10126F01C()
{
  return 0;
}

void *sub_10126F02C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10126F0B0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 136))
  {
    *(void *)a1 = off_101A4D3B8;
    if (*(unsigned char *)(a1 + 128) && *(char *)(a1 + 127) < 0) {
      operator delete(*(void **)(a1 + 104));
    }
    if (*(unsigned char *)(a1 + 96) && *(char *)(a1 + 95) < 0) {
      operator delete(*(void **)(a1 + 72));
    }
    if (*(unsigned char *)(a1 + 64) && *(char *)(a1 + 63) < 0) {
      operator delete(*(void **)(a1 + 40));
    }
    if (*(unsigned char *)(a1 + 32) && *(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
  }
  return a1;
}

unsigned char *sub_10126F158(unsigned char *a1, const __CFDictionary *a2)
{
  *a1 = 0;
  a1[256] = 0;
  a1[264] = 0;
  a1[288] = 0;
  a1[296] = 0;
  a1[320] = 0;
  a1[328] = 0;
  a1[352] = 0;
  a1[360] = 0;
  a1[384] = 0;
  sub_1003A6C6C((uint64_t)a1, a2);
  return a1;
}

void sub_10126F1A8(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 384) && *(char *)(v1 + 383) < 0) {
    operator delete(*(void **)(v1 + 360));
  }
  if (*(unsigned char *)(v1 + 352) && *(char *)(v1 + 351) < 0) {
    operator delete(*(void **)(v1 + 328));
  }
  if (*(unsigned char *)(v1 + 320) && *(char *)(v1 + 319) < 0) {
    operator delete(*(void **)(v1 + 296));
  }
  if (*(unsigned char *)(v1 + 288) && *(char *)(v1 + 287) < 0) {
    operator delete(*(void **)(v1 + 264));
  }
  if (*(unsigned char *)(v1 + 256)) {
    sub_1003AA7DC(v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10126F224(const void **result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*((unsigned __int8 *)result + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (*((unsigned char *)result + 24))
    {
      if (result != (const void **)a2)
      {
        int v4 = *result;
        void *result = 0;
        BOOL v6 = v4;
        void *result = *(const void **)a2;
        *(void *)a2 = 0;
        sub_100127DDC(&v6);
        CFMutableDictionaryRef v5 = v3[1];
        v3[1] = 0;
        BOOL v6 = v5;
        v3[1] = *(const void **)(a2 + 8);
        *(void *)(a2 + 8) = 0;
        uint64_t result = sub_100127DDC(&v6);
      }
      *((unsigned char *)v3 + 16) = *(unsigned char *)(a2 + 16);
    }
  }
  else if (*((unsigned char *)result + 24))
  {
    return sub_1008AA8F4(result);
  }
  else
  {
    void *result = 0;
    void *result = *(const void **)a2;
    *(void *)a2 = 0;
    result[1] = 0;
    result[1] = *(const void **)(a2 + 8);
    *(void *)(a2 + 8) = 0;
    *((unsigned char *)result + 16) = *(unsigned char *)(a2 + 16);
    *((unsigned char *)result + 24) = 1;
  }
  return result;
}

void sub_10126F314()
{
}

void *sub_10126F328()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_101AA42C0;
  return result;
}

void sub_10126F360(uint64_t a1, void *a2)
{
  *a2 = off_101AA42C0;
}

void sub_10126F388(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    int v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)CFMutableDictionaryRef v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "ThumperKeepAlive", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_10126F400(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10126F440()
{
}

void sub_10126F44C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10126F518(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[13], v1, (dispatch_function_t)sub_10126F5F0);
  __cxa_rethrow();
}

void sub_10126F540(_Unwind_Exception *a1)
{
}

void sub_10126F558(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10126F590(uint64_t a1)
{
}

uint64_t sub_10126F5AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10126F5F0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10126F61C(uint64_t a1)
{
  sub_100B3B188((uint64_t *)(a1 + 24));
  os_signpost_id_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

uint64_t sub_10126F65C(uint64_t result, _WORD *a2, int a3)
{
  int v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2)
      {
        sub_1001E1134(result);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N3ctu12DispatchSlotIZN23ThumperSecondaryControl10initializeEvE3$_0EE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIZN23ThumperSecondaryControl10initializeEvE3$_0EE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

void sub_10126F798(void *a1, uint64_t a2, uint64_t a3)
{
  int v4 = (void *)*a1;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a2;
    uint64_t v11 = *(void *)(a2 + 16);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v9 = *(void *)(a3 + 16);
  }
  uint64_t v5 = v4[1];
  uint64_t v6 = v4[2];
  uint64_t v7 = (std::__shared_weak_count *)v4[3];
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v14 = v6;
    CFNumberRef v15 = v7;
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v7);
    std::__shared_weak_count::__release_weak(v7);
    std::__shared_weak_count::__release_weak(v7);
    std::__shared_weak_count::__release_weak(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  else
  {
    uint64_t v14 = v4[2];
    CFNumberRef v15 = 0;
  }
  CFNumberRef v12 = off_101AA43B0;
  uint64_t v13 = v5;
  sub_100B3AB44();
}

void sub_10126F8D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10126F920(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 <= 1)
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    uint64_t v5 = *(void *)(a1 + 16);
    *(void *)(a2 + 16) = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
    }
    if (a3 != 1) {
      return;
    }
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v6) {
      return;
    }
LABEL_13:
    std::__shared_weak_count::__release_weak(v6);
    return;
  }
  if (a3 == 3)
  {
    uint64_t v7 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v7 == (const char *)((unint64_t)"ZN23ThumperSecondaryControl10initializeEvE3$_0" & 0x7FFFFFFFFFFFFFFFLL)
      || !strcmp(v7, (const char *)((unint64_t)"ZN23ThumperSecondaryControl10initializeEvE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
    {
      *(void *)a2 = a1;
    }
    else
    {
      *(void *)a2 = 0;
    }
    return;
  }
  if (a3 != 2)
  {
LABEL_2:
    *(_WORD *)(a2 + 8) = 0;
    return;
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a2 + 16);
  if (v6) {
    goto LABEL_13;
  }
}

void sub_10126FA04(uint64_t *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  int v4 = (std::__shared_weak_count *)a1[2];
  if (!v4) {
    return;
  }
  uint64_t v7 = *a1;
  uint64_t v8 = std::__shared_weak_count::lock(v4);
  if (!v8) {
    return;
  }
  uint64_t v9 = v8;
  if (a1[1] && sub_10001D294(a2, (unsigned __int8 *)(**(void **)(v7 + 144) + 24)))
  {
    int v10 = *(NSObject **)(v7 + 56);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v7 + 144));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v11;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%s================================ Evaluating Service Token Expired ================================", buf, 0x16u);
    }
    theDict[0] = 0;
    theDict[1] = 0;
    sub_101266470((uint64_t)theDict, v7);
    if (theDict[0]) {
      CFNumberRef v12 = sub_100080778;
    }
    else {
      CFNumberRef v12 = 0;
    }
    if (v12)
    {
      CFDictionaryRef Value = CFDictionaryGetValue(theDict[0], @"masterToken");
      uint64_t v14 = Value;
      if (Value)
      {
        CFTypeID v15 = CFGetTypeID(Value);
        if (v15 == CFStringGetTypeID())
        {
          memset(buf, 0, sizeof(buf));
          ctu::cf::assign();
          uint64_t v52 = *(void *)&buf[16];
          *(_OWORD *)std::string __p = *(_OWORD *)buf;
          uint64_t v16 = a3[23];
          if ((v16 & 0x80u) == 0) {
            CFMutableArrayRef v17 = (void *)a3[23];
          }
          else {
            CFMutableArrayRef v17 = (void *)*((void *)a3 + 1);
          }
          uint64_t v18 = (void *)HIBYTE(v52);
          int v19 = SHIBYTE(v52);
          if (v52 < 0) {
            uint64_t v18 = __p[1];
          }
          if (v17 == v18)
          {
            if (v52 >= 0) {
              CFArrayRef v20 = __p;
            }
            else {
              CFArrayRef v20 = (void **)__p[0];
            }
            if ((v16 & 0x80) != 0)
            {
              BOOL v29 = memcmp(*(const void **)a3, v20, *((void *)a3 + 1)) == 0;
            }
            else if (a3[23])
            {
              uint64_t v21 = v16 - 1;
              CFTypeID v22 = a3;
              do
              {
                int v24 = *v22++;
                int v23 = v24;
                int v26 = *(unsigned __int8 *)v20;
                CFArrayRef v20 = (void **)((char *)v20 + 1);
                int v25 = v26;
                BOOL v27 = v21-- != 0;
                char v28 = v27;
                BOOL v29 = v23 == v25;
              }
              while (v23 == v25 && (v28 & 1) != 0);
            }
            else
            {
              BOOL v29 = 1;
            }
          }
          else
          {
            BOOL v29 = 0;
          }
          if (v19 < 0) {
            operator delete(__p[0]);
          }
          goto LABEL_53;
        }
      }
      uint64_t v30 = *(void *)(v7 + 296);
      if (v30)
      {
        if (*(unsigned char *)(v30 + 288))
        {
          uint64_t v31 = a3[23];
          if ((v31 & 0x80u) == 0) {
            uint64_t v32 = a3[23];
          }
          else {
            uint64_t v32 = *((void *)a3 + 1);
          }
          uint64_t v33 = *(unsigned __int8 *)(v30 + 287);
          int v34 = (char)v33;
          if ((v33 & 0x80u) != 0) {
            uint64_t v33 = *(void *)(v30 + 272);
          }
          if (v32 != v33)
          {
            uint64_t v14 = 0;
            BOOL v29 = 0;
            goto LABEL_53;
          }
          uint64_t v35 = (unsigned __int8 **)(v30 + 264);
          if (v34 >= 0) {
            uint64_t v36 = (unsigned __int8 *)v35;
          }
          else {
            uint64_t v36 = *v35;
          }
          if ((v31 & 0x80) != 0)
          {
            uint64_t v14 = 0;
            BOOL v29 = memcmp(*(const void **)a3, v36, *((void *)a3 + 1)) == 0;
            goto LABEL_53;
          }
          if (a3[23])
          {
            uint64_t v37 = v31 - 1;
            uint64_t v38 = a3;
            do
            {
              uint64_t v14 = 0;
              int v40 = *v38++;
              int v39 = v40;
              int v42 = *v36++;
              int v41 = v42;
              BOOL v27 = v37-- != 0;
              char v43 = v27;
              BOOL v29 = v39 == v41;
            }
            while (v39 == v41 && (v43 & 1) != 0);
            goto LABEL_53;
          }
        }
      }
    }
    uint64_t v14 = 0;
    BOOL v29 = 1;
LABEL_53:
    uint64_t v44 = *(NSObject **)(v7 + 56);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v45 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v7 + 144));
      CFStringRef v46 = "doesn't";
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = v45;
      if (v29) {
        CFStringRef v46 = "";
      }
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(_WORD *)&unsigned char buf[22] = 2080;
      __int16 v55 = v46;
      if (v14) {
        xpc_object_t v47 = "master";
      }
      else {
        xpc_object_t v47 = "individual";
      }
      __int16 v56 = 2080;
      long long v57 = v47;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I %s%sExpired token %smatch active %s token", buf, 0x2Au);
    }
    if (v29)
    {
      if ((a3[23] & 0x80u) == 0) {
        uint64_t v48 = (const __CFString **)a3;
      }
      else {
        uint64_t v48 = *(const __CFString ***)a3;
      }
      sub_10126790C(v7, 0, 0, 0, 0, v48);
      sub_100A2F218(*(void *)(v7 + 160));
      sub_100A2B760(*(void *)(v7 + 160) + 360, 1);
    }
    else
    {
      __int16 v49 = *(NSObject **)(v7 + 56);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v50 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v7 + 144));
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v50;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I %s%sexpired token processing ignored, token is not active already", buf, 0x16u);
      }
    }
    sub_100057D78((const void **)theDict);
  }

  sub_10004D2C8(v9);
}

void sub_10126FE8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_100057D78(&a13);
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_10126FED0(uint64_t result, _WORD *a2, int a3)
{
  int v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2)
      {
        sub_1001E1134(result);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N3ctu12DispatchSlotIZN23ThumperSecondaryControl10initializeEvE3$_1EE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIZN23ThumperSecondaryControl10initializeEvE3$_1EE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

void sub_10127000C(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = (void *)*a1;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v12 = *(void *)(a2 + 16);
  }
  uint64_t v7 = *a4;
  uint64_t v6 = a4[1];
  *a4 = 0;
  a4[1] = 0;
  uint64_t v8 = v5[1];
  uint64_t v9 = v5[2];
  int v10 = (std::__shared_weak_count *)v5[3];
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v17 = v9;
    uint64_t v18 = v10;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  else
  {
    uint64_t v17 = v5[2];
    uint64_t v18 = 0;
  }
  CFTypeID v15 = off_101AA43F0;
  uint64_t v16 = v8;
  uint64_t v13 = v7;
  uint64_t v14 = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10108E5B0();
}

void sub_101270160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  sub_10108EEEC(&a18);
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1012701A8(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 <= 1)
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    uint64_t v5 = *(void *)(a1 + 16);
    *(void *)(a2 + 16) = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
    }
    if (a3 != 1) {
      return;
    }
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v6) {
      return;
    }
LABEL_13:
    std::__shared_weak_count::__release_weak(v6);
    return;
  }
  if (a3 == 3)
  {
    uint64_t v7 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v7 == (const char *)((unint64_t)"ZN23ThumperSecondaryControl10initializeEvE3$_1" & 0x7FFFFFFFFFFFFFFFLL)
      || !strcmp(v7, (const char *)((unint64_t)"ZN23ThumperSecondaryControl10initializeEvE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))
    {
      *(void *)a2 = a1;
    }
    else
    {
      *(void *)a2 = 0;
    }
    return;
  }
  if (a3 != 2)
  {
LABEL_2:
    *(_WORD *)(a2 + 8) = 0;
    return;
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a2 + 16);
  if (v6) {
    goto LABEL_13;
  }
}

void sub_10127028C(uint64_t *a1, unsigned __int8 *a2, int a3, uint64_t *a4)
{
  uint64_t v6 = *a4;
  uint64_t v5 = (std::__shared_weak_count *)a4[1];
  *a4 = 0;
  a4[1] = 0;
  uint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (v7)
  {
    uint64_t v10 = *a1;
    uint64_t v11 = std::__shared_weak_count::lock(v7);
    if (v11)
    {
      uint64_t v12 = v11;
      if (a1[1])
      {
        if (v5) {
          atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (sub_10001D294(a2, (unsigned __int8 *)(**(void **)(v10 + 144) + 24)))
        {
          uint64_t v13 = *(void *)(v10 + 160);
          uint64_t v32 = (int *)v6;
          uint64_t v33 = v5;
          if (v5) {
            atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          unsigned __int16 v14 = sub_100A2F6CC(v13, a3, &v32);
          if (v33) {
            sub_10004D2C8(v33);
          }
          if ((_BYTE)v14)
          {
            CFTypeID v15 = *(NSObject **)(v10 + 56);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v10 + 144));
              if ((a3 - 1) > 2) {
                uint64_t v17 = "RequestCanceled";
              }
              else {
                uint64_t v17 = off_101AA48C8[a3 - 1];
              }
              *(_DWORD *)std::string buf = 136315650;
              uint64_t v35 = v16;
              __int16 v36 = 2080;
              uint64_t v37 = " ";
              __int16 v38 = 2080;
              int v39 = v17;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%s================================ Evaluating Get Provisiong Data Update ==(cause:%s)==============================", buf, 0x20u);
            }
            *(unsigned char *)(v10 + 588) = 0;
            if (v14 >= 0x100u)
            {
              if (*(_DWORD *)(v10 + 260) == 2)
              {
                uint64_t v18 = *(void *)(v6 + 8);
                uint64_t v21 = *(void *)(v18 + 8);
                uint64_t v19 = v18 + 8;
                uint64_t v20 = v21;
                if (v21)
                {
                  uint64_t v22 = v19;
                  do
                  {
                    int v23 = *(_DWORD *)(v20 + 32);
                    BOOL v24 = v23 < 8;
                    if (v23 >= 8) {
                      int v25 = (uint64_t *)v20;
                    }
                    else {
                      int v25 = (uint64_t *)(v20 + 8);
                    }
                    if (!v24) {
                      uint64_t v22 = v20;
                    }
                    uint64_t v20 = *v25;
                  }
                  while (*v25);
                  if (v22 != v19 && *(int *)(v22 + 32) <= 8)
                  {
                    if (!*(unsigned char *)(v22 + 64) || (uint64_t v26 = *(void *)(v22 + 40), v27 = *(void *)(v22 + 48), v27 == v26))
                    {
                      uint64_t v30 = *(NSObject **)(v10 + 56);
                      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v31 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v10 + 144));
                        *(_DWORD *)std::string buf = 136315394;
                        uint64_t v35 = v31;
                        __int16 v36 = 2080;
                        uint64_t v37 = " ";
                        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s%sNo IMS credentials attached to getProvisioning", buf, 0x16u);
                      }
                    }
                    else
                    {
                      if (!*(void *)(v10 + 296)) {
                        operator new();
                      }
                      if (v27 == v26) {
                        sub_10015B728();
                      }
                      sub_101089824(*(char **)(v10 + 296), v26);
                      sub_101264B68(v10, (long long **)(v10 + 296));
                      sub_101268220(v10);
                    }
                  }
                }
              }
              else
              {
                char v28 = *(NSObject **)(v10 + 56);
                if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v29 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v10 + 144));
                  *(_DWORD *)std::string buf = 136315394;
                  uint64_t v35 = v29;
                  __int16 v36 = 2080;
                  uint64_t v37 = " ";
                  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s%sService is not allowed - ignore", buf, 0x16u);
                }
                sub_100A2BBB0(*(void *)(v10 + 160) + 360);
              }
            }
            sub_10125E354((const void **)v10, 0, 0);
          }
        }
        if (v5) {
          sub_10004D2C8(v5);
        }
      }
      sub_10004D2C8(v12);
    }
  }
  if (v5)
  {
    sub_10004D2C8(v5);
  }
}

void sub_10127066C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (v10)
  {
    sub_10004D2C8(v10);
    sub_10004D2C8(v11);
  }
  else
  {
    uint64_t v10 = v11;
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_1012706B0(uint64_t result, _WORD *a2, int a3)
{
  int v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2)
      {
        sub_1001E1134(result);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N3ctu12DispatchSlotIZN23ThumperSecondaryControl10initializeEvE3$_2EE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIZN23ThumperSecondaryControl10initializeEvE3$_2EE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

void sub_1012707EC(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = (void *)*a1;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v12 = *(void *)(a2 + 16);
  }
  uint64_t v7 = *a4;
  uint64_t v6 = a4[1];
  *a4 = 0;
  a4[1] = 0;
  uint64_t v8 = v5[1];
  uint64_t v9 = v5[2];
  uint64_t v10 = (std::__shared_weak_count *)v5[3];
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v17 = v9;
    uint64_t v18 = v10;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  else
  {
    uint64_t v17 = v5[2];
    uint64_t v18 = 0;
  }
  CFTypeID v15 = off_101AA4430;
  uint64_t v16 = v8;
  uint64_t v13 = v7;
  uint64_t v14 = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  sub_101090080();
}

void sub_101270940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  sub_101090AF0(&a18);
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_101270988(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 <= 1)
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    uint64_t v5 = *(void *)(a1 + 16);
    *(void *)(a2 + 16) = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
    }
    if (a3 != 1) {
      return;
    }
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v6) {
      return;
    }
LABEL_13:
    std::__shared_weak_count::__release_weak(v6);
    return;
  }
  if (a3 == 3)
  {
    uint64_t v7 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v7 == (const char *)((unint64_t)"ZN23ThumperSecondaryControl10initializeEvE3$_2" & 0x7FFFFFFFFFFFFFFFLL)
      || !strcmp(v7, (const char *)((unint64_t)"ZN23ThumperSecondaryControl10initializeEvE3$_2" & 0x7FFFFFFFFFFFFFFFLL)))
    {
      *(void *)a2 = a1;
    }
    else
    {
      *(void *)a2 = 0;
    }
    return;
  }
  if (a3 != 2)
  {
LABEL_2:
    *(_WORD *)(a2 + 8) = 0;
    return;
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a2 + 16);
  if (v6) {
    goto LABEL_13;
  }
}

void sub_101270A6C(uint64_t *a1, unsigned __int8 *a2, int a3, uint64_t *a4)
{
  uint64_t v6 = *a4;
  uint64_t v5 = (std::__shared_weak_count *)a4[1];
  *a4 = 0;
  a4[1] = 0;
  uint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (v7)
  {
    uint64_t v10 = *a1;
    uint64_t v11 = std::__shared_weak_count::lock(v7);
    if (v11)
    {
      uint64_t v12 = v11;
      if (a1[1])
      {
        if (v5) {
          atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (sub_10001D294(a2, (unsigned __int8 *)(**(void **)(v10 + 144) + 24)))
        {
          uint64_t v13 = *(void *)(v10 + 160);
          uint64_t v35 = (int *)v6;
          __int16 v36 = v5;
          if (v5) {
            atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          unsigned __int16 v14 = sub_100A2F6CC(v13, a3, &v35);
          if (v36) {
            sub_10004D2C8(v36);
          }
          if ((_BYTE)v14)
          {
            uint64_t v15 = *(void *)(v6 + 8);
            uint64_t v18 = *(void *)(v15 + 8);
            uint64_t v16 = v15 + 8;
            uint64_t v17 = v18;
            if (!v18) {
              goto LABEL_22;
            }
            uint64_t v19 = v16;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < 8;
              if (v20 >= 8) {
                uint64_t v22 = (uint64_t *)v17;
              }
              else {
                uint64_t v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                uint64_t v19 = v17;
              }
              uint64_t v17 = *v22;
            }
            while (*v22);
            if (v19 != v16 && *(int *)(v19 + 32) < 9)
            {
              int v25 = *(NSObject **)(v10 + 56);
              if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v26 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v10 + 144));
                if ((a3 - 1) > 2) {
                  uint64_t v27 = "RequestCanceled";
                }
                else {
                  uint64_t v27 = off_101AA48C8[a3 - 1];
                }
                *(_DWORD *)std::string buf = 136315650;
                uint64_t v38 = v26;
                __int16 v39 = 2080;
                int v40 = " ";
                __int16 v41 = 2080;
                int v42 = v27;
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s%s================================ Evaluating Set Provisiong Data Update ==(cause:%s)==============================", buf, 0x20u);
              }
              *(unsigned char *)(v10 + 589) = 0;
              if (v14 >= 0x100u)
              {
                int v28 = *(_DWORD *)(v10 + 260);
                uint64_t v29 = *(NSObject **)(v10 + 56);
                BOOL v30 = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
                if (v28 == 2)
                {
                  if (v30)
                  {
                    uint64_t v31 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v10 + 144));
                    *(_DWORD *)std::string buf = 136315394;
                    uint64_t v38 = v31;
                    __int16 v39 = 2080;
                    int v40 = " ";
                    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %s%sset provisioning succeed", buf, 0x16u);
                  }
                  uint64_t v32 = *(void *)(v19 + 40);
                  uint64_t v33 = *(std::__shared_weak_count **)(v19 + 48);
                  if (v33) {
                    atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  sub_101268588(v10 + 312, v32);
                  if (v33) {
                    sub_10004D2C8(v33);
                  }
                }
                else
                {
                  if (v30)
                  {
                    uint64_t v34 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v10 + 144));
                    *(_DWORD *)std::string buf = 136315394;
                    uint64_t v38 = v34;
                    __int16 v39 = 2080;
                    int v40 = " ";
                    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %s%sService is not allowed - ignore", buf, 0x16u);
                  }
                  sub_100A2BBB0(*(void *)(v10 + 160) + 360);
                }
              }
              sub_10125E354((const void **)v10, 0, 0);
            }
            else
            {
LABEL_22:
              int v23 = *(NSObject **)(v10 + 56);
              if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v24 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v10 + 144));
                *(_DWORD *)std::string buf = 136315394;
                uint64_t v38 = v24;
                __int16 v39 = 2080;
                int v40 = " ";
                _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s%sset provisioning do not have iCloudVoWiFi part - keep waiting", buf, 0x16u);
              }
            }
          }
        }
        if (v5) {
          sub_10004D2C8(v5);
        }
      }
      sub_10004D2C8(v12);
    }
  }
  if (v5)
  {
    sub_10004D2C8(v5);
  }
}

void sub_101270E30(_Unwind_Exception *a1)
{
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (v1)
  {
    sub_10004D2C8(v1);
    sub_10004D2C8(v2);
  }
  else
  {
    uint64_t v1 = v2;
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_101270E84(void *a1)
{
  *a1 = off_101AA4460;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_101270ED0(void *a1)
{
  *a1 = off_101AA4460;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_101270F3C(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_101AA4460;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_101270FA0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101AA4460;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101270FE0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_101270FF0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_101271030(uint64_t *a1, xpc_object_t *a2)
{
  sub_10031A644(a1[1], a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3)
  {
    uint64_t v4 = a1[2];
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (a1[3])
      {
        uint64_t v7 = sub_100046F68(v4 + 272, (void **)(**(void **)(v4 + 144) + 24));
        uint64_t v8 = (unsigned __int8 *)(**(void **)(v4 + 144) + 24);
        if ((void **)(v4 + 280) == v7)
        {
          v10[0] = 0;
          v10[1] = 0;
          uint64_t v9 = v10;
          sub_101263304(v4, v8, (uint64_t)&v9);
          sub_1000346F8((uint64_t)&v9, v10[0]);
        }
        else
        {
          sub_101263304(v4, v8, (uint64_t)(v7 + 8));
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1012710F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  sub_1000346F8((uint64_t)&a10, a11);
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

uint64_t sub_10127111C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10127115C()
{
}

void sub_10127116C()
{
}

void *sub_101271180(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA44E0;
  result[1] = v3;
  return result;
}

uint64_t sub_1012711C8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA44E0;
  a2[1] = v2;
  return result;
}

void sub_1012711F4(uint64_t a1, BOOL *a2)
{
  xpc_object_t v5 = 0;
  write_rest_value(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/thumper_capability");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_101271298(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1012712DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10127131C()
{
}

void sub_10127132C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101271364(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_100350940(result);
    operator delete();
  }
  return result;
}

uint64_t sub_1012713AC(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

void sub_1012713F0(const void ****a1)
{
  uint64_t v1 = a1;
  sub_10125E354(**a1, 0, *((unsigned __int8 *)*a1 + 8));
  operator delete();
}

void sub_10127144C()
{
}

uint64_t *sub_101271478(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      char v4 = v3;
      if (*(void *)(v1 + 8))
      {
        v8[0] = 0;
        v8[1] = 524531;
        if (sub_10017B48C()) {
          operator new();
        }
        sub_101272534(v8);
      }
      sub_10004D2C8(v4);
    }
  }
  sub_100004A84(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_101271700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (*(char *)(v30 - 57) < 0) {
    operator delete(*(void **)(v30 - 80));
  }
  sub_101272534((uint64_t *)(v30 - 56));
  sub_10004D2C8(v29);
  sub_100004A84(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void *sub_1012717E8(void *a1)
{
  *a1 = off_101AA45E8;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = a1[2];
  if (v3) {
    dispatch_release(v3);
  }
  return a1;
}

void sub_101271840(void *a1)
{
  *a1 = off_101AA45E8;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = a1[2];
  if (v3) {
    dispatch_release(v3);
  }

  operator delete();
}

void *sub_1012718B8(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_101AA45E8;
  sub_101271A78(v2 + 1, v1);
  return v2;
}

void *sub_10127190C(uint64_t a1, void *a2)
{
  *a2 = off_101AA45E8;
  return sub_101271A78(a2 + 1, (void *)(a1 + 8));
}

void sub_101271938(uint64_t a1)
{
}

void sub_101271940(void *a1)
{
  sub_101271AC8((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10127197C(uint64_t a1, unsigned char *a2)
{
  if (*a2 == 2) {
    sub_10134D414();
  }
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  operator new();
}

uint64_t sub_101271A2C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_101271A6C()
{
}

void *sub_101271A78(void *a1, void *a2)
{
  char v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  uint64_t v5 = a2[3];
  a1[2] = a2[2];
  a1[3] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_101271AC8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(NSObject **)(a1 + 8);
  if (v3)
  {
    dispatch_release(v3);
  }
}

uint64_t *sub_101271B18(void *a1)
{
  uint64_t v8 = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = *a1;
    char v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[1])
      {
        uint64_t v6 = *(std::__shared_weak_count **)(v3 + 736);
        *(_OWORD *)(v3 + 728) = 0u;
        if (v6) {
          sub_10004D2C8(v6);
        }
      }
      sub_10004D2C8(v5);
    }
  }
  return sub_100004A84((uint64_t *)&v8);
}

uint64_t *sub_101271B94(void *a1)
{
  uint64_t v2 = a1;
  (*(void (**)(void))(*(void *)*a1 + 16))(*a1);
  return sub_1000E3958((uint64_t *)&v2);
}

void sub_101271BEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000E3958((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_101271C04(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101271C3C(uint64_t a1)
{
  return sub_101271C88(*(void *)(a1 + 24));
}

uint64_t sub_101271C44(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101271C88(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 384) && *(char *)(result + 383) < 0) {
      operator delete(*(void **)(result + 360));
    }
    if (*(unsigned char *)(v1 + 352) && *(char *)(v1 + 351) < 0) {
      operator delete(*(void **)(v1 + 328));
    }
    if (*(unsigned char *)(v1 + 320) && *(char *)(v1 + 319) < 0) {
      operator delete(*(void **)(v1 + 296));
    }
    if (*(unsigned char *)(v1 + 288) && *(char *)(v1 + 287) < 0) {
      operator delete(*(void **)(v1 + 264));
    }
    if (*(unsigned char *)(v1 + 256)) {
      sub_1003AA7DC(v1);
    }
    operator delete();
  }
  return result;
}

void sub_101271D48()
{
}

void *sub_101271D5C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA46E0;
  result[1] = v3;
  return result;
}

uint64_t sub_101271DA4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA46E0;
  a2[1] = v2;
  return result;
}

void sub_101271DD0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  char v4 = *(NSObject **)(v3 + 56);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 144));
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = (uint64_t *)*a2;
    }
    int v7 = 136315650;
    uint64_t v8 = v5;
    __int16 v9 = 2080;
    uint64_t v10 = " ";
    __int16 v11 = 2080;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v7, 0x20u);
  }
}

uint64_t sub_101271EB0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101271EF0()
{
}

void sub_101271EFC(uint64_t a1, const void *a2, uint64_t *a3)
{
  memset(v23, 0, sizeof(v23));
  *(_OWORD *)uint64_t v22 = 0u;
  if (ctu::cf::assign())
  {
    if (a2)
    {
      CFTypeID v5 = CFGetTypeID(a2);
      if (v5 == CFArrayGetTypeID())
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v19 = 0;
        context[0] = __p;
        v28.length = CFArrayGetCount((CFArrayRef)a2);
        v28.location = 0;
        CFArrayApplyFunction((CFArrayRef)a2, v28, (CFArrayApplierFunction)sub_100449508, context);
        long long v6 = *(_OWORD *)((char *)v23 + 8);
        *(_OWORD *)((char *)v23 + 8) = *(_OWORD *)__p;
        *(_OWORD *)std::string __p = v6;
        uint64_t v7 = *((void *)&v23[1] + 1);
        *((void *)&v23[1] + 1) = v19;
        uint64_t v19 = v7;
        context[0] = __p;
        sub_100047F64(context);
      }
    }
    if (SBYTE7(v23[0]) < 0)
    {
      sub_10004FC84(__p, v22[0], (unint64_t)v22[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v22;
      uint64_t v19 = *(void *)&v23[0];
    }
    long long v20 = 0uLL;
    uint64_t v21 = 0;
    sub_1000302C0((char *)&v20, *((long long **)&v23[0] + 1), *(long long **)&v23[1], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v23[1] - *((void *)&v23[0] + 1)) >> 3));
    uint64_t v9 = *a3;
    uint64_t v8 = a3[1];
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    uint64_t v10 = (uint64_t **)sub_1000C6D50((void *)v9, v8, &v27, &v26, __p);
    __int16 v11 = *v10;
    if (!*v10)
    {
      uint64_t v25 = 0;
      uint64_t v12 = (char *)operator new(0x50uLL);
      context[0] = (void **)v12;
      context[1] = (void **)(v9 + 8);
      uint64_t v13 = v12 + 32;
      if (SHIBYTE(v19) < 0)
      {
        sub_10004FC84(v13, __p[0], (unint64_t)__p[1]);
        unsigned __int16 v14 = (uint64_t *)context[0];
      }
      else
      {
        *(_OWORD *)uint64_t v13 = *(_OWORD *)__p;
        *((void *)v12 + 6) = v19;
        unsigned __int16 v14 = (uint64_t *)v12;
      }
      *(_OWORD *)(v12 + 56) = v20;
      *((void *)v12 + 9) = v21;
      uint64_t v21 = 0;
      long long v20 = 0uLL;
      LOBYTE(v25) = 1;
      sub_100046C38((uint64_t **)v9, (uint64_t)v27, v10, v14);
      __int16 v11 = (uint64_t *)context[0];
      context[0] = 0;
      sub_100720EB4((uint64_t)context, 0);
    }
    a3[1] = (uint64_t)v11;
    uint64_t v15 = (uint64_t *)v11[1];
    if (v15)
    {
      do
      {
        uint64_t v16 = v15;
        uint64_t v15 = (uint64_t *)*v15;
      }
      while (v15);
    }
    else
    {
      do
      {
        uint64_t v16 = (uint64_t *)v11[2];
        BOOL v17 = *v16 == (void)v11;
        __int16 v11 = v16;
      }
      while (!v17);
    }
    a3[1] = (uint64_t)v16;
    context[0] = (void **)&v20;
    sub_100047F64(context);
    if (SHIBYTE(v19) < 0) {
      operator delete(__p[0]);
    }
  }
  __p[0] = (char *)v23 + 8;
  sub_100047F64((void ***)__p);
  if (SBYTE7(v23[0]) < 0) {
    operator delete(v22[0]);
  }
}

void sub_10127215C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  sub_100720EB4(v18 - 88, 0);
  sub_100F3BB80((uint64_t)&__p);
  sub_100F3BB80((uint64_t)&a18);
  _Unwind_Resume(a1);
}

void sub_1012721C8()
{
}

void *sub_1012721DC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA4760;
  result[1] = v3;
  return result;
}

uint64_t sub_101272224(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA4760;
  a2[1] = v2;
  return result;
}

void sub_101272250(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  char v4 = *(NSObject **)(v3 + 56);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 144));
    if (*((char *)a2 + 23) >= 0) {
      long long v6 = a2;
    }
    else {
      long long v6 = (uint64_t *)*a2;
    }
    int v7 = 136315650;
    uint64_t v8 = v5;
    __int16 v9 = 2080;
    uint64_t v10 = " ";
    __int16 v11 = 2080;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v7, 0x20u);
  }
}

uint64_t sub_101272330(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101272370()
{
}

void sub_101272380()
{
}

void *sub_101272394(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA47E0;
  result[1] = v3;
  return result;
}

uint64_t sub_1012723DC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA47E0;
  a2[1] = v2;
  return result;
}

void sub_101272408(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  char v4 = *(NSObject **)(v3 + 56);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 144));
    if (*((char *)a2 + 23) >= 0) {
      long long v6 = a2;
    }
    else {
      long long v6 = (uint64_t *)*a2;
    }
    int v7 = 136315650;
    uint64_t v8 = v5;
    __int16 v9 = 2080;
    uint64_t v10 = " ";
    __int16 v11 = 2080;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v7, 0x20u);
  }
}

uint64_t sub_1012724E8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_101272528()
{
}

uint64_t *sub_101272534(uint64_t *a1)
{
  if (!*a1) {
    goto LABEL_17;
  }
  unsigned int v2 = *((_DWORD *)a1 + 2);
  uint64_t v3 = sub_10001C8F4(8);
  uint64_t v5 = (wis::WISServerConnection *)*v3;
  char v4 = (std::__shared_weak_count *)v3[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5)
  {
    SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v3);
    int v7 = (wis *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v2);
    uint64_t v8 = v7;
    if (v7)
    {
      uint64_t v9 = *a1;
      *a1 = 0;
      if (v9)
      {
        if (*(unsigned char *)(v9 + 28))
        {
          unint64_t WISTimestamp = *(void *)(v9 + 8);
        }
        else
        {
          unint64_t WISTimestamp = wis::getWISTimestamp(v7);
          *(_DWORD *)(v9 + 28) |= 1u;
          *(void *)(v9 + 8) = WISTimestamp;
        }
        wis::MetricContainer::storeMetric(v8, WISTimestamp, *(_DWORD *)v8, (const wireless_diagnostics::google::protobuf::MessageLite *)v9);
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      }
      wis::WISServerConnection::SubmitMetric(v5, v8);
    }
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v11 = *a1;
  *a1 = 0;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = *a1;
    *a1 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  else
  {
LABEL_17:
    *a1 = 0;
  }
  return a1;
}

void sub_101272694(void *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  if (v1) {
    sub_10004D2C8(v1);
  }
  sub_10006A6AC(a1);
}

void SimDeactivationTracker::create(Registry **a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v5 = ServiceMap;
  int v7 = (void *)v6;
  if (v6 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      int v7 = (void *)v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = v7;
  uint64_t v11 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&__p);
  if (v11)
  {
    uint64_t v13 = (GestaltUtilityInterface *)v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  if (GestaltUtilityInterface::isIPhone(v13))
  {
    int v15 = 0;
    goto LABEL_21;
  }
  uint64_t v16 = (std::mutex *)Registry::getServiceMap(*a1);
  BOOL v17 = v16;
  if (v6 < 0)
  {
    uint64_t v18 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v19 = 5381;
    do
    {
      uint64_t v6 = v19;
      unsigned int v20 = *v18++;
      uint64_t v19 = (33 * v19) ^ v20;
    }
    while (v20);
  }
  std::mutex::lock(v16);
  std::string __p = (void *)v6;
  uint64_t v21 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&__p);
  if (v21)
  {
    int v23 = (GestaltUtilityInterface *)v21[3];
    uint64_t v22 = (std::__shared_weak_count *)v21[4];
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v22);
      goto LABEL_19;
    }
  }
  else
  {
    int v23 = 0;
  }
  std::mutex::unlock(v17);
  uint64_t v22 = 0;
LABEL_19:
  int v15 = GestaltUtilityInterface::isIPad(v23) ^ 1;
  if (v22) {
    sub_10004D2C8(v22);
  }
LABEL_21:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (!v15) {
    operator new();
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_101272CB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, ctu::OsLogLogger *a9, uint64_t a10, uint64_t a11, dispatch_object_t object, dispatch_object_t a13, void *__p, std::__shared_weak_count *a15, int a16, __int16 a17, char a18, char a19)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  if (a15) {
    sub_10004D2C8(a15);
  }
  sub_10004D2C8(v19);
  _Unwind_Resume(a1);
}

const char *sub_101272F70(int a1)
{
  uint64_t v1 = "sim.deact.tracker.?";
  if (a1 == 2) {
    uint64_t v1 = "sim.deact.tracker.2";
  }
  if (a1 == 1) {
    return "sim.deact.tracker.1";
  }
  else {
    return v1;
  }
}

void sub_101272F9C(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  char v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10127309C(uint64_t a1)
{
  uint64_t v1 = *(int **)(a1 + 184);
  uint64_t v2 = *(int **)(a1 + 192);
  if (v1 != v2)
  {
    uint64_t v3 = (uint64_t **)(a1 + 280);
    do
    {
      if ((subscriber::isSimAbsent() & 1) != 0 || subscriber::isSimUnreadable()) {
        sub_101276EA4(v3, *v1);
      }
      v1 += 42;
    }
    while (v1 != v2);
  }
}

void sub_101273100(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 160);
  uint64_t v2 = (void *)(a1 + 168);
  if (v1 != (void *)(a1 + 168))
  {
    do
    {
      char v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v1 + 7));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = *((unsigned __int8 *)v1 + 32);
        int v6 = *((unsigned __int8 *)v1 + 33);
        uint64_t v7 = asString();
        *(_DWORD *)std::string buf = 67109634;
        int v12 = v5;
        __int16 v13 = 1024;
        int v14 = v6;
        __int16 v15 = 2080;
        uint64_t v16 = v7;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I NetworkRejectCauseCodePS: %d, NetworkRejectCauseCodeCS: %d, Rat: %s", buf, 0x18u);
      }
      if (*((unsigned char *)v1 + 33)) {
        sub_101273C30(a1, *((unsigned int *)v1 + 7));
      }
      uint64_t v8 = (void *)v1[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (void *)v1[2];
          BOOL v10 = *v9 == (void)v1;
          uint64_t v1 = v9;
        }
        while (!v10);
      }
      uint64_t v1 = v9;
    }
    while (v9 != v2);
  }
}

void sub_10127327C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 232);
  uint64_t v2 = (void *)(a1 + 240);
  if (v1 != (void *)(a1 + 240))
  {
    uint64_t v32 = (uint64_t **)(a1 + 280);
    do
    {
      char v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v1 + 7));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = asString();
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Registration Status %s", buf, 0xCu);
      }
      unsigned int v6 = *((_DWORD *)v1 + 8);
      if (v6 > 6) {
        goto LABEL_55;
      }
      int v7 = 1 << v6;
      if ((v7 & 0x4A) != 0)
      {
        sub_101273C30(a1, *((unsigned int *)v1 + 7));
      }
      else if ((v7 & 0x30) != 0)
      {
        unsigned int v8 = *((_DWORD *)v1 + 7);
        uint64_t v9 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v8);
        uint64_t v11 = *(void *)(a1 + 184);
        BOOL v10 = *(uint64_t **)(a1 + 192);
        if ((uint64_t *)v11 != v10)
        {
          while (*(_DWORD *)v11 != v8)
          {
            v11 += 168;
            if ((uint64_t *)v11 == v10) {
              goto LABEL_54;
            }
          }
        }
        if ((uint64_t *)v11 != v10)
        {
          ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(a1 + 56));
          __int16 v13 = ServiceMap;
          if (v14 < 0)
          {
            __int16 v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v16 = 5381;
            do
            {
              uint64_t v14 = v16;
              unsigned int v17 = *v15++;
              uint64_t v16 = (33 * v16) ^ v17;
            }
            while (v17);
          }
          std::mutex::lock(ServiceMap);
          *(void *)std::string buf = v14;
          uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
          if (v18)
          {
            uint64_t v19 = (std::__shared_weak_count *)v18[4];
            uint64_t v31 = v18[3];
            if (v19)
            {
              atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v13);
              atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v19);
              char v20 = 0;
              goto LABEL_22;
            }
          }
          else
          {
            uint64_t v31 = 0;
          }
          std::mutex::unlock(v13);
          uint64_t v19 = 0;
          char v20 = 1;
LABEL_22:
          __dst[0] = 0;
          __dst[1] = 0;
          uint64_t v39 = 0;
          if (*(char *)(v11 + 95) < 0)
          {
            sub_10004FC84(__dst, *(void **)(v11 + 72), *(void *)(v11 + 80));
          }
          else
          {
            *(_OWORD *)std::string __dst = *(_OWORD *)(v11 + 72);
            uint64_t v39 = *(void *)(v11 + 88);
          }
          v36[0] = 0;
          v36[1] = 0;
          uint64_t v37 = 0;
          sub_101275124((uint64_t *)v36, a1, v8);
          if (SHIBYTE(v37) < 0)
          {
            sub_10004FC84(v33, v36[0], (unint64_t)v36[1]);
          }
          else
          {
            *(_OWORD *)uint64_t v33 = *(_OWORD *)v36;
            uint64_t v34 = v37;
          }
          if (SHIBYTE(v34) < 0)
          {
            sub_10004FC84(__p, v33[0], (unint64_t)v33[1]);
          }
          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)v33;
            uint64_t v42 = v34;
          }
          int v40 = 0;
          if (SHIBYTE(v42) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)__p;
            uint64_t v46 = v42;
          }
          char v43 = 0;
          if (ctu::cf::convert_copy())
          {
            uint64_t v21 = v40;
            int v40 = v43;
            uint64_t v44 = v21;
            sub_1000558F4(&v44);
          }
          if (SHIBYTE(v46) < 0) {
            operator delete(*(void **)buf);
          }
          uint64_t v22 = v40;
          uint64_t v35 = v40;
          int v40 = 0;
          sub_1000558F4(&v40);
          if (SHIBYTE(v42) < 0) {
            operator delete(__p[0]);
          }
          char v23 = v20;
          if (SHIBYTE(v34) < 0) {
            operator delete(v33[0]);
          }
          int v24 = (*(uint64_t (**)(uint64_t, void **, const __CFString *, const void *, const __CFString *, void, uint64_t, void))(*(void *)v31 + 16))(v31, __dst, @"LastRegisteredNetworkPlmn", v22, @"SimDeactivationInfo", 0, 1, 0);
          uint64_t v25 = *v9;
          uint64_t v26 = *v9;
          if (v24)
          {
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)std::string buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v24;
              _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Failed to store NetworkPlmn store in personality wallet %d", buf, 8u);
            }
          }
          else if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v27 = v36;
            if (v37 < 0) {
              uint64_t v27 = (void **)v36[0];
            }
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = v27;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I NetworkPlmn %s stored successfully in personality wallet", buf, 0xCu);
          }
          sub_1000558F4(&v35);
          if (SHIBYTE(v37) < 0) {
            operator delete(v36[0]);
          }
          if (SHIBYTE(v39) < 0)
          {
            operator delete(__dst[0]);
            if ((v23 & 1) == 0) {
LABEL_53:
            }
              sub_10004D2C8(v19);
          }
          else if ((v23 & 1) == 0)
          {
            goto LABEL_53;
          }
        }
LABEL_54:
        sub_101276EA4(v32, *((_DWORD *)v1 + 7));
      }
LABEL_55:
      CFRange v28 = (void *)v1[1];
      if (v28)
      {
        do
        {
          uint64_t v29 = v28;
          CFRange v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          uint64_t v29 = (void *)v1[2];
          BOOL v30 = *v29 == (void)v1;
          uint64_t v1 = v29;
        }
        while (!v30);
      }
      uint64_t v1 = v29;
    }
    while (v29 != v2);
  }
}

void sub_1012737A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,const void *a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  sub_1000558F4(&a37);
  if (a43 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if ((v43 & 1) == 0) {
    sub_10004D2C8(v44);
  }
  _Unwind_Resume(a1);
}

void sub_10127387C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 280);
  char v20 = (void *)(a1 + 288);
  if (v1 != (void *)(a1 + 288))
  {
    do
    {
      uint64_t v2 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v1 + 8));
      uint64_t v3 = *v2;
      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
      {
        char v4 = v1 + 5;
        if (*((char *)v1 + 63) < 0) {
          char v4 = (void *)*v4;
        }
        *(_DWORD *)std::string buf = 136315138;
        char v23 = v4;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I homePlmn: %s", buf, 0xCu);
      }
      uint64_t v5 = v1[8];
      uint64_t v6 = v1[9];
      while (v5 != v6)
      {
        int v7 = *v2;
        if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v8 = (void *)v5;
          if (*(char *)(v5 + 23) < 0) {
            unsigned int v8 = *(void **)v5;
          }
          *(_DWORD *)std::string buf = 136315138;
          char v23 = v8;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I networkPlmn: %s", buf, 0xCu);
          int v7 = *v2;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v9 = *(unsigned __int8 *)(v5 + 24);
          *(_DWORD *)std::string buf = 67109120;
          LODWORD(v23) = v9;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I isRoaming: %d", buf, 8u);
          int v7 = *v2;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v10 = (void *)(v5 + 40);
          if (*(char *)(v5 + 63) < 0) {
            BOOL v10 = (void *)*v10;
          }
          *(_DWORD *)std::string buf = 136315138;
          char v23 = v10;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I reasonCode: %s", buf, 0xCu);
          int v7 = *v2;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = *(_DWORD *)(v5 + 32);
          int v12 = "kUnknown";
          if (v11 == 1) {
            int v12 = "kCellular";
          }
          BOOL v13 = v11 == 2;
          uint64_t v14 = "kCarrierEntitlement";
          if (!v13) {
            uint64_t v14 = v12;
          }
          *(_DWORD *)std::string buf = 136315138;
          char v23 = v14;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I sourceType: %s", buf, 0xCu);
          int v7 = *v2;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v15 = *(unsigned __int8 *)(v5 + 25);
          *(_DWORD *)std::string buf = 67109120;
          LODWORD(v23) = v15;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I isNetworkInitiated: %d", buf, 8u);
          int v7 = *v2;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = asString();
          *(_DWORD *)std::string buf = 136315138;
          char v23 = (void *)v16;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I rat: %s", buf, 0xCu);
          int v7 = *v2;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v17 = *(void **)(v5 + 64);
          *(_DWORD *)std::string buf = 134217984;
          char v23 = v17;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I timeOfEvent: %ld", buf, 0xCu);
        }
        v5 += 72;
      }
      uint64_t v18 = (void *)v1[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          uint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v1[2];
          BOOL v13 = *v19 == (void)v1;
          uint64_t v1 = v19;
        }
        while (!v13);
      }
      uint64_t v1 = v19;
    }
    while (v19 != v20);
  }
}

void sub_101273C30(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  unsigned int v142 = a2;
  char v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  *(_OWORD *)std::string __p = 0u;
  long long v141 = 0u;
  sub_10127550C(__p, *(void *)(a1 + 184), *(void *)(a1 + 192), v2);
  if (!BYTE8(v141)) {
    goto LABEL_51;
  }
  *(void *)uint64_t v157 = __p;
  if (sub_101276F88((uint64_t **)(a1 + 304), __p, (long long **)v157)[80]) {
    goto LABEL_51;
  }
  memset(&v161, 0, sizeof(v161));
  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v2);
  uint64_t v6 = operator new(0x10uLL);
  *(void *)&v157[8] = v6 + 2;
  *(void *)&v157[16] = v6 + 2;
  void *v6 = @"PhoneAccountTransfer";
  v6[1] = @"RejectCauseCodesForSimDeactivation";
  *(void *)uint64_t v157 = v6;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6 + 2, *(Registry **)(a1 + 56));
  unsigned int v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    BOOL v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      std::string::size_type v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  buf.__r_.__value_.__r.__words[0] = v9;
  BOOL v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&buf);
  CFMutableDictionaryRef v137 = (os_log_t *)v5;
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_42;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (!v15) {
    goto LABEL_42;
  }
LABEL_12:
  buf.__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, unsigned char *, void, void))(*(void *)v15
                                                                                                  + 104))(&v154, v15, v2, 1, v157, 0, 0);
  sub_100044D6C(&buf, (CFTypeRef *)&v154);
  sub_1000577C4((const void **)&v154);
  if (buf.__r_.__value_.__r.__words[0]) {
    unsigned int v17 = sub_100083F10;
  }
  else {
    unsigned int v17 = 0;
  }
  if (!v17 || !CFArrayGetCount((CFArrayRef)buf.__r_.__value_.__l.__data_))
  {
    sub_100044D00((const void **)&buf.__r_.__value_.__l.__data_);
    if (v16) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  std::string v135 = v4;
  CFIndex Count = CFArrayGetCount((CFArrayRef)buf.__r_.__value_.__l.__data_);
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFDictionaryRef ValueAtIndex = (int *)CFArrayGetValueAtIndex((CFArrayRef)buf.__r_.__value_.__l.__data_, i);
      uint64_t v22 = ValueAtIndex;
      if (ValueAtIndex)
      {
        CFTypeID v23 = CFGetTypeID(ValueAtIndex);
        if (v23 == CFNumberGetTypeID()) {
          int v24 = v22;
        }
        else {
          int v24 = 0;
        }
      }
      else
      {
        int v24 = 0;
      }
      LODWORD(v154) = 0;
      ctu::cf::assign((ctu::cf *)&v154, v24, v21);
      int v25 = (int)v154;
      std::string::size_type size = v161.__r_.__value_.__l.__size_;
      if (v161.__r_.__value_.__l.__size_ >= v161.__r_.__value_.__r.__words[2])
      {
        CFRange v28 = (void *)v161.__r_.__value_.__r.__words[0];
        uint64_t v29 = (uint64_t)(v161.__r_.__value_.__l.__size_ - v161.__r_.__value_.__r.__words[0]) >> 2;
        unint64_t v30 = v29 + 1;
        if ((unint64_t)(v29 + 1) >> 62) {
          sub_10006A748();
        }
        int64_t v31 = v161.__r_.__value_.__r.__words[2] - v161.__r_.__value_.__r.__words[0];
        if ((uint64_t)(v161.__r_.__value_.__r.__words[2] - v161.__r_.__value_.__r.__words[0]) >> 1 > v30) {
          unint64_t v30 = v31 >> 1;
        }
        if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v32 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v32 = v30;
        }
        if (v32)
        {
          uint64_t v33 = (char *)sub_10005ECD8((uint64_t)&v161.__r_.__value_.__r.__words[2], v32);
          std::string::size_type size = v161.__r_.__value_.__l.__size_;
          CFRange v28 = (void *)v161.__r_.__value_.__r.__words[0];
        }
        else
        {
          uint64_t v33 = 0;
        }
        uint64_t v34 = &v33[4 * v29];
        *(_DWORD *)uint64_t v34 = v25;
        std::string::size_type v27 = (std::string::size_type)(v34 + 4);
        while ((void *)size != v28)
        {
          int v35 = *(_DWORD *)(size - 4);
          size -= 4;
          *((_DWORD *)v34 - 1) = v35;
          v34 -= 4;
        }
        v161.__r_.__value_.__r.__words[0] = (std::string::size_type)v34;
        v161.__r_.__value_.__l.__size_ = v27;
        v161.__r_.__value_.__r.__words[2] = (std::string::size_type)&v33[4 * v32];
        if (v28) {
          operator delete(v28);
        }
      }
      else
      {
        *(_DWORD *)v161.__r_.__value_.__l.__size_ = v154;
        std::string::size_type v27 = size + 4;
      }
      v161.__r_.__value_.__l.__size_ = v27;
    }
  }
  sub_100044D00((const void **)&buf.__r_.__value_.__l.__data_);
  char v4 = v135;
LABEL_42:
  __int16 v36 = *v137;
  if (os_log_type_enabled(*v137, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (uint64_t)(v161.__r_.__value_.__l.__size_
                                                                                     - v161.__r_.__value_.__r.__words[0]) >> 2;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I [%lu] more reject cause codes are defined in CB", (uint8_t *)&buf, 0xCu);
  }
  if (v16) {
    goto LABEL_46;
  }
LABEL_45:
  sub_10004D2C8(v14);
LABEL_46:
  if (*(void *)v157)
  {
    *(void *)&v157[8] = *(void *)v157;
    operator delete(*(void **)v157);
  }
  *(void *)uint64_t v157 = __p;
  uint64_t v37 = sub_101276F88((uint64_t **)(a1 + 304), __p, (long long **)v157);
  sub_100195D74((uint64_t)(v37 + 56), (__n128 *)&v161);
  if (v161.__r_.__value_.__r.__words[0])
  {
    v161.__r_.__value_.__l.__size_ = v161.__r_.__value_.__r.__words[0];
    operator delete(v161.__r_.__value_.__l.__data_);
  }
  uint64_t v2 = v142;
LABEL_51:
  uint64_t v38 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v2);
  uint64_t v40 = *(void *)(a1 + 184);
  uint64_t v39 = *(void *)(a1 + 192);
  if (v40 != v39)
  {
    while (*(_DWORD *)v40 != v2)
    {
      v40 += 168;
      if (v40 == v39) {
        goto LABEL_85;
      }
    }
  }
  if (v40 == v39 || (subscriber::isSimReady() & 1) == 0)
  {
LABEL_85:
    uint64_t v54 = *v38;
    if (os_log_type_enabled(*v38, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v157 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "Could not find sim info", v157, 2u);
    }
LABEL_87:
    __int16 v55 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v56 = subscriber::asString();
      *(_DWORD *)uint64_t v157 = 136315138;
      *(void *)&v157[4] = v56;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I SIM on slot %s is still active", v157, 0xCu);
    }
    goto LABEL_89;
  }
  uint64_t v41 = *(void *)(a1 + 240);
  if (!v41) {
    goto LABEL_67;
  }
  uint64_t v42 = a1 + 240;
  do
  {
    int v43 = *(_DWORD *)(v41 + 28);
    BOOL v44 = v43 < (int)v2;
    if (v43 >= (int)v2) {
      uint64_t v45 = (uint64_t *)v41;
    }
    else {
      uint64_t v45 = (uint64_t *)(v41 + 8);
    }
    if (!v44) {
      uint64_t v42 = v41;
    }
    uint64_t v41 = *v45;
  }
  while (*v45);
  if (v42 != a1 + 240 && *(_DWORD *)(v42 + 28) <= (int)v2) {
    unsigned int v46 = *(_DWORD *)(v42 + 32);
  }
  else {
LABEL_67:
  }
    unsigned int v46 = 0;
  memset(&v161, 0, sizeof(v161));
  sub_101275448(&v161, a1, v2, 1);
  memset(&buf, 0, sizeof(buf));
  sub_101275448(&buf, a1, v2, 2);
  uint64_t v154 = 0;
  uint64_t v155 = 0;
  uint64_t v156 = 0;
  sub_1012752F8((uint64_t *)&v154, a1, v2);
  long long __s1 = 0;
  size_t __n = 0;
  uint64_t v153 = 0;
  sub_101275124((uint64_t *)&__s1, a1, v2);
  xpc_object_t v47 = *v38;
  if (os_log_type_enabled(*v38, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v48 = &v161;
    if ((v161.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v48 = (std::string *)v161.__r_.__value_.__r.__words[0];
    }
    p_std::string buf = &buf;
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    uint64_t v50 = &v154;
    if (v156 < 0) {
      uint64_t v50 = v154;
    }
    p_s1 = &__s1;
    if (v153 < 0) {
      p_s1 = __s1;
    }
    *(_DWORD *)uint64_t v157 = 136315906;
    *(void *)&v157[4] = v48;
    *(_WORD *)&v157[12] = 2080;
    *(void *)&v157[14] = p_buf;
    *(_WORD *)&v157[22] = 2080;
    *(void *)&v157[24] = v50;
    *(_WORD *)&v157[32] = 2080;
    *(void *)&v157[34] = p_s1;
    _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I CSReasonCode: %s PSReasonCode: %s homePlmn: %s campedPlmn: %s", v157, 0x2Au);
  }
  if (v46 > 6 || ((1 << v46) & 0x4A) == 0) {
    goto LABEL_182;
  }
  uint64_t v52 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v53 = asString();
    *(_DWORD *)uint64_t v157 = 136315138;
    *(void *)&v157[4] = v53;
    _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I Registration Status %s", v157, 0xCu);
  }
  if (((1 << v46) & 0x4A) == 0) {
    goto LABEL_182;
  }
  if (SHIBYTE(v161.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__str, v161.__r_.__value_.__l.__data_, v161.__r_.__value_.__l.__size_);
  }
  else {
    std::string __str = v161;
  }
  unsigned __int8 v57 = std::stoi(&__str, 0, 10) - 2;
  if (v57 < 7u && ((0x73u >> v57) & 1) != 0)
  {
    BOOL v59 = 1;
  }
  else
  {
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = buf;
    }
    unsigned __int8 v58 = std::stoi(&__dst, 0, 10) - 2;
    BOOL v59 = v58 < 7u && ((0x73u >> v58) & 1) != 0 || sub_1012757E8(a1, v2, &v161, &buf);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  long long v60 = (uint64_t *)SHIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((v60 & 0x80000000) != 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
    if (!v59) {
      goto LABEL_182;
    }
  }
  else if (!v59)
  {
    goto LABEL_182;
  }
  long long v61 = (std::mutex *)Registry::getServiceMap(v60, *(Registry **)(a1 + 56));
  long long v62 = v61;
  if (v63 < 0)
  {
    long long v64 = (unsigned __int8 *)(v63 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v65 = 5381;
    do
    {
      uint64_t v63 = v65;
      unsigned int v66 = *v64++;
      uint64_t v65 = (33 * v65) ^ v66;
    }
    while (v66);
  }
  std::mutex::lock(v61);
  *(void *)uint64_t v157 = v63;
  long long v67 = sub_10004D37C(&v62[1].__m_.__sig, (unint64_t *)v157);
  if (v67)
  {
    uint64_t v69 = v67[3];
    long long v68 = (std::__shared_weak_count *)v67[4];
    if (v68)
    {
      atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v62);
      atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v68);
      char v70 = 0;
      goto LABEL_121;
    }
  }
  else
  {
    uint64_t v69 = 0;
  }
  std::mutex::unlock(v62);
  long long v68 = 0;
  char v70 = 1;
LABEL_121:
  v147[0] = 0;
  v147[1] = 0;
  uint64_t v148 = 0;
  if (*(char *)(v40 + 95) < 0)
  {
    sub_10004FC84(v147, *(void **)(v40 + 72), *(void *)(v40 + 80));
  }
  else
  {
    *(_OWORD *)uint64_t v147 = *(_OWORD *)(v40 + 72);
    uint64_t v148 = *(void *)(v40 + 88);
  }
  CFDictionaryRef v146 = 0;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void **, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v69 + 24))(&cf, v69, v147, @"LastRegisteredNetworkPlmn", @"SimDeactivationInfo", 0, 1);
  v143[0] = (void *)cf;
  if (cf) {
    CFRetain(cf);
  }
  *(void *)uint64_t v159 = 0;
  *(void *)uint64_t v157 = 0;
  sub_100056248(v157, (CFTypeRef *)v143);
  if (*(void *)v157) {
    uint64_t v71 = sub_1000810B8;
  }
  else {
    uint64_t v71 = 0;
  }
  if (v71) {
    sub_100083EB8((const void **)v159, (const void **)v157);
  }
  sub_1000558F4((const void **)v157);
  CFDictionaryRef v146 = *(const void **)v159;
  *(void *)uint64_t v159 = 0;
  sub_1000558F4((const void **)v159);
  sub_1000577C4((const void **)v143);
  sub_1000577C4(&cf);
  CFDictionaryRef v72 = *v38;
  if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
  {
    memset(v157, 0, 24);
    ctu::cf::assign();
    *(_OWORD *)std::string v143 = *(_OWORD *)v157;
    uint64_t v144 = *(void *)&v157[16];
    CFDictionaryRef v73 = *(void ***)v157;
    if (v157[23] >= 0) {
      CFDictionaryRef v73 = v143;
    }
    *(_DWORD *)uint64_t v159 = 136315138;
    *(void *)&v159[4] = v73;
    _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I lastRegisteredPlmn: %s", v159, 0xCu);
    if (SHIBYTE(v144) < 0) {
      operator delete(v143[0]);
    }
  }
  uint64_t v74 = HIBYTE(v153);
  if (v153 >= 0) {
    size_t v75 = HIBYTE(v153);
  }
  else {
    size_t v75 = __n;
  }
  uint64_t v76 = HIBYTE(v156);
  if (v156 < 0) {
    uint64_t v76 = v155;
  }
  if (v75 == v76)
  {
    if (v156 >= 0) {
      CFTypeID v77 = (unsigned __int8 *)&v154;
    }
    else {
      CFTypeID v77 = (unsigned __int8 *)v154;
    }
    if ((v153 & 0x8000000000000000) == 0)
    {
      if (HIBYTE(v153))
      {
        std::string::size_type v78 = &__s1;
        while (*(unsigned __int8 *)v78 == *v77)
        {
          std::string::size_type v78 = (void **)((char *)v78 + 1);
          ++v77;
          if (!--v74) {
            goto LABEL_171;
          }
        }
        goto LABEL_152;
      }
LABEL_171:
      BOOL v91 = 1;
      goto LABEL_176;
    }
    if (!memcmp(__s1, v77, __n)) {
      goto LABEL_171;
    }
  }
LABEL_152:
  memset(v157, 0, 24);
  ctu::cf::assign();
  uint64_t v144 = *(void *)&v157[16];
  *(_OWORD *)std::string v143 = *(_OWORD *)v157;
  if (v153 >= 0) {
    size_t v79 = HIBYTE(v153);
  }
  else {
    size_t v79 = __n;
  }
  std::string::size_type v80 = (void *)HIBYTE(v144);
  int v81 = SHIBYTE(v144);
  if (v144 < 0) {
    std::string::size_type v80 = v143[1];
  }
  if ((void *)v79 == v80)
  {
    if (v144 >= 0) {
      std::string::size_type v82 = v143;
    }
    else {
      std::string::size_type v82 = (void **)v143[0];
    }
    if (v153 < 0)
    {
      BOOL v91 = memcmp(__s1, v82, __n) == 0;
    }
    else if (HIBYTE(v153))
    {
      uint64_t v83 = HIBYTE(v153) - 1;
      uint64_t v84 = &__s1;
      do
      {
        int v86 = *(unsigned __int8 *)v84;
        uint64_t v84 = (void **)((char *)v84 + 1);
        int v85 = v86;
        int v88 = *(unsigned __int8 *)v82;
        std::string::size_type v82 = (void **)((char *)v82 + 1);
        int v87 = v88;
        BOOL v90 = v83-- != 0;
        BOOL v91 = v85 == v87;
      }
      while (v85 == v87 && v90);
    }
    else
    {
      BOOL v91 = 1;
    }
  }
  else
  {
    BOOL v91 = 0;
  }
  if (v81 < 0) {
    operator delete(v143[0]);
  }
LABEL_176:
  sub_1000558F4(&v146);
  if ((SHIBYTE(v148) & 0x80000000) == 0)
  {
    if (v70) {
      goto LABEL_178;
    }
LABEL_181:
    sub_10004D2C8(v68);
    if (v91) {
      goto LABEL_179;
    }
    goto LABEL_182;
  }
  operator delete(v147[0]);
  if ((v70 & 1) == 0) {
    goto LABEL_181;
  }
LABEL_178:
  if (v91)
  {
LABEL_179:
    char v92 = 1;
    goto LABEL_183;
  }
LABEL_182:
  char v92 = 0;
LABEL_183:
  if (SHIBYTE(v153) < 0) {
    operator delete(__s1);
  }
  if (SHIBYTE(v156) < 0) {
    operator delete(v154);
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v161.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v161.__r_.__value_.__l.__data_);
  }
  if ((v92 & 1) == 0) {
    goto LABEL_87;
  }
  uint64_t v93 = v142;
  memset(v157, 0, sizeof(v157));
  *(_DWORD *)&v157[28] = 11;
  long long v158 = 0u;
  sub_101275124((uint64_t *)&v161, a1, v142);
  *(std::string *)uint64_t v157 = v161;
  v157[24] = sub_1012753E4(a1, v93);
  sub_101275448(&v161, a1, v93, 1);
  uint64_t v94 = *(void *)(a1 + 168);
  *(_OWORD *)&v157[40] = *(_OWORD *)&v161.__r_.__value_.__l.__data_;
  *(void *)&long long v158 = *((void *)&v161.__r_.__value_.__l + 2);
  if (!v94) {
    goto LABEL_202;
  }
  uint64_t v95 = a1 + 168;
  do
  {
    int v96 = *(_DWORD *)(v94 + 28);
    BOOL v97 = v96 < (int)v93;
    if (v96 >= (int)v93) {
      long long v98 = (uint64_t *)v94;
    }
    else {
      long long v98 = (uint64_t *)(v94 + 8);
    }
    if (!v97) {
      uint64_t v95 = v94;
    }
    uint64_t v94 = *v98;
  }
  while (*v98);
  if (v95 != a1 + 168 && *(_DWORD *)(v95 + 28) <= (int)v93) {
    int v99 = *(_DWORD *)(v95 + 36);
  }
  else {
LABEL_202:
  }
    int v99 = 11;
  *(_DWORD *)&v157[28] = v99;
  *(_DWORD *)&v157[32] = 0;
  std::string v136 = v4;
  *((void *)&v158 + 1) = (uint64_t)(kCFAbsoluteTimeIntervalSince1970 + CFAbsoluteTimeGetCurrent());
  v157[25] = 0;
  uint64_t v100 = *(void *)(a1 + 288);
  if (v100)
  {
    uint64_t v101 = a1 + 288;
    do
    {
      int v102 = *(_DWORD *)(v100 + 32);
      BOOL v103 = v102 < (int)v93;
      if (v102 >= (int)v93) {
        long long v104 = (uint64_t *)v100;
      }
      else {
        long long v104 = (uint64_t *)(v100 + 8);
      }
      if (!v103) {
        uint64_t v101 = v100;
      }
      uint64_t v100 = *v104;
    }
    while (*v104);
    if (v101 != a1 + 288 && *(_DWORD *)(v101 + 32) <= (int)v93)
    {
      unint64_t v105 = *(unsigned __int8 **)(v101 + 64);
      CFTypeID v106 = *(unsigned __int8 **)(v101 + 72);
      if (v105 != v106)
      {
        uint64_t v107 = v157[23];
        size_t v108 = *(void *)&v157[8];
        uint64_t v138 = *(void **)v157;
        if (v157[23] >= 0) {
          uint64_t v109 = v157[23];
        }
        else {
          uint64_t v109 = *(void *)&v157[8];
        }
        uint64_t v110 = BYTE7(v158);
        long long v132 = *(const void **)&v157[40];
        size_t v133 = *(void *)&v157[48];
        if ((SBYTE7(v158) & 0x80u) == 0) {
          uint64_t v111 = BYTE7(v158);
        }
        else {
          uint64_t v111 = *(void *)&v157[48];
        }
        int v134 = *(_DWORD *)&v157[28];
        do
        {
          uint64_t v112 = v105[23];
          int v113 = (char)v112;
          if ((v112 & 0x80u) != 0) {
            uint64_t v112 = *((void *)v105 + 1);
          }
          if (v109 != v112) {
            goto LABEL_248;
          }
          if (v113 >= 0) {
            CFDictionaryRef v114 = v105;
          }
          else {
            CFDictionaryRef v114 = *(unsigned __int8 **)v105;
          }
          if ((v107 & 0x80) != 0)
          {
            if (memcmp(v138, v114, v108)) {
              goto LABEL_248;
            }
          }
          else if (v107)
          {
            CFMutableDictionaryRef v115 = v157;
            uint64_t v116 = v107;
            while (*v115 == *v114)
            {
              ++v115;
              ++v114;
              if (!--v116) {
                goto LABEL_234;
              }
            }
            goto LABEL_248;
          }
LABEL_234:
          uint64_t v117 = v105[63];
          int v118 = (char)v117;
          if ((v117 & 0x80u) != 0) {
            uint64_t v117 = *((void *)v105 + 6);
          }
          if (v111 == v117)
          {
            if (v118 >= 0) {
              std::string::size_type v119 = v105 + 40;
            }
            else {
              std::string::size_type v119 = (unsigned __int8 *)*((void *)v105 + 5);
            }
            if ((v110 & 0x80) != 0)
            {
              if (!memcmp(v132, v119, v133))
              {
LABEL_247:
                if (v134 == *((_DWORD *)v105 + 7)) {
                  goto LABEL_264;
                }
              }
            }
            else
            {
              if (!v110) {
                goto LABEL_247;
              }
              long long v120 = &v157[40];
              uint64_t v121 = v110;
              while (*v120 == *v119)
              {
                ++v120;
                ++v119;
                if (!--v121) {
                  goto LABEL_247;
                }
              }
            }
          }
LABEL_248:
          v105 += 72;
        }
        while (v105 != v106);
      }
    }
  }
  if (SBYTE7(v158) < 0)
  {
    sub_10004FC84(&v139, *(void **)&v157[40], *(unint64_t *)&v157[48]);
  }
  else
  {
    *(_OWORD *)&v139.__r_.__value_.__l.__data_ = *(_OWORD *)&v157[40];
    v139.__r_.__value_.__r.__words[2] = v158;
  }
  unsigned __int8 v122 = std::stoi(&v139, 0, 10);
  unsigned int v123 = (v122 < 9u) & (0x1CCu >> v122);
  if ((SHIBYTE(v139.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!v123) {
      goto LABEL_264;
    }
LABEL_256:
    std::string::size_type v124 = sub_101277144((uint64_t **)(a1 + 280), v93, &v142);
    sub_1012752F8((uint64_t *)&v161, a1, v93);
    uint64_t v125 = (void **)(v124 + 40);
    if (v124[63] < 0) {
      operator delete(*v125);
    }
    *(_OWORD *)uint64_t v125 = *(_OWORD *)&v161.__r_.__value_.__l.__data_;
    *((void *)v124 + 7) = *((void *)&v161.__r_.__value_.__l + 2);
    *(_DWORD *)&v157[32] = 1;
    unint64_t v126 = *((void *)v124 + 9);
    if (v126 >= *((void *)v124 + 10))
    {
      uint64_t v128 = sub_101275B38((int64x2_t *)v124 + 4, (long long *)v157);
      BOOL v127 = v136;
    }
    else
    {
      sub_101275CD8(*((char **)v124 + 9), (long long *)v157);
      BOOL v127 = v136;
      uint64_t v128 = v126 + 72;
      *((void *)v124 + 9) = v126 + 72;
    }
    *((void *)v124 + 9) = v128;
    std::string::size_type v129 = *v127;
    if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v161.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v129, OS_LOG_TYPE_DEFAULT, "#I Sending notification for Cellular failure", (uint8_t *)&v161, 2u);
    }
    (*(void (**)(void, uint64_t, void **))(**(void **)(a1 + 96) + 96))(*(void *)(a1 + 96), v93, v125);
    goto LABEL_264;
  }
  operator delete(v139.__r_.__value_.__l.__data_);
  if (v123) {
    goto LABEL_256;
  }
LABEL_264:
  if (BYTE8(v141))
  {
    sub_101274F18(a1, (uint64_t *)__p);
  }
  else
  {
    long long v130 = *v136;
    if (os_log_type_enabled(*v136, OS_LOG_TYPE_ERROR))
    {
      uint64_t v131 = subscriber::asString();
      LODWORD(v161.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v161.__r_.__value_.__r.__words + 4) = v131;
      _os_log_error_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_ERROR, "Fail to find iccid for slot %s", (uint8_t *)&v161, 0xCu);
    }
  }
  if (SBYTE7(v158) < 0) {
    operator delete(*(void **)&v157[40]);
  }
  if ((v157[23] & 0x80000000) != 0) {
    operator delete(*(void **)v157);
  }
LABEL_89:
  if (BYTE8(v141))
  {
    if (SBYTE7(v141) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_101274CF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,void *__p,uint64_t a47,int a48,__int16 a49,char a50,char a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  if ((v58 & 1) == 0) {
    sub_10004D2C8(v57);
  }
  if (a51 < 0) {
    operator delete(__p);
  }
  if (a57 < 0) {
    operator delete(a52);
  }
  if (*(char *)(v59 - 137) < 0) {
    operator delete(*(void **)(v59 - 160));
  }
  if (*(char *)(v59 - 105) < 0) {
    operator delete(*(void **)(v59 - 128));
  }
  if (a25)
  {
    if (a24 < 0) {
      operator delete(a19);
    }
  }
  _Unwind_Resume(a1);
}

void sub_101274F18(uint64_t a1, uint64_t *a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 56));
  uint64_t v5 = ServiceMap;
  uint64_t v6 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    int v7 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = (const char *)v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)char v16 = v6;
  BOOL v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)v16);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  uint64_t v14 = *(NSObject **)(a1 + 40);
  if (v12)
  {
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v15 = a2;
      }
      else {
        uint64_t v15 = (uint64_t *)*a2;
      }
      *(_DWORD *)char v16 = 136315138;
      *(void *)&v16[4] = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Set iccid %s as deactivated", v16, 0xCu);
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v12 + 912))(v12, a2);
LABEL_17:
    if (v13) {
      return;
    }
    goto LABEL_18;
  }
  if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
    goto LABEL_17;
  }
  *(_WORD *)char v16 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", v16, 2u);
  if (v13) {
    return;
  }
LABEL_18:
  sub_10004D2C8(v11);
}

void sub_1012750F8(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101275124(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v6 = *(void *)(a2 + 216);
  char v4 = (_DWORD *)(a2 + 216);
  uint64_t v5 = v6;
  if (!v6) {
    goto LABEL_11;
  }
  int v7 = v4;
  do
  {
    int v8 = *(_DWORD *)(v5 + 32);
    BOOL v9 = v8 < a3;
    if (v8 >= a3) {
      BOOL v10 = (uint64_t *)v5;
    }
    else {
      BOOL v10 = (uint64_t *)(v5 + 8);
    }
    if (!v9) {
      int v7 = (_DWORD *)v5;
    }
    uint64_t v5 = *v10;
  }
  while (*v10);
  if (v7 == v4 || v7[8] > a3)
  {
LABEL_11:
    sub_100058DB0(a1, "");
    return;
  }
  *(_OWORD *)uint64_t v18 = 0u;
  long long v19 = 0u;
  *(_OWORD *)char v16 = 0u;
  long long v17 = 0u;
  MCC::MCC((MCC *)v16, (const MCC *)(v7 + 10));
  MCC::MCC((MCC *)v18, (const MCC *)(v7 + 18));
  MCCAndMNC::getMcc(v14, (MCCAndMNC *)(v7 + 10));
  if (MCC::valid((MCC *)v14))
  {
    MCCAndMNC::getMnc(v12, (MCCAndMNC *)(v7 + 10));
    int v11 = MCC::valid((MCC *)v12);
    if (v13 < 0) {
      operator delete((void *)v12[1]);
    }
  }
  else
  {
    int v11 = 0;
  }
  if ((v15 & 0x80000000) == 0)
  {
    if (!v11) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  operator delete((void *)v14[1]);
  if (v11) {
LABEL_22:
  }
    MCCAndMNC::getStringValue(a1, (MCCAndMNC *)v16);
LABEL_23:
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[1]);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(v16[1]);
  }
  if ((v11 & 1) == 0) {
    sub_100058DB0(a1, "");
  }
}

void sub_101275294(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  sub_10013C44C((uint64_t)&a23);
  _Unwind_Resume(a1);
}

void sub_1012752E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x1012752D8);
}

void sub_1012752F8(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v6 = *(void *)(a2 + 120);
  uint64_t v4 = a2 + 120;
  uint64_t v5 = v6;
  if (!v6) {
    goto LABEL_11;
  }
  uint64_t v7 = v4;
  do
  {
    int v8 = *(_DWORD *)(v5 + 32);
    BOOL v9 = v8 < a3;
    if (v8 >= a3) {
      BOOL v10 = (uint64_t *)v5;
    }
    else {
      BOOL v10 = (uint64_t *)(v5 + 8);
    }
    if (!v9) {
      uint64_t v7 = v5;
    }
    uint64_t v5 = *v10;
  }
  while (*v10);
  if (v7 != v4 && *(_DWORD *)(v7 + 32) <= a3)
  {
    *(_OWORD *)std::string __p = 0u;
    long long v14 = 0u;
    *(_OWORD *)int v11 = 0u;
    long long v12 = 0u;
    MCCAndMNC::MCCAndMNC();
    MCCAndMNC::getStringValue(a1, (MCCAndMNC *)v11);
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[1]);
    }
    if (SHIBYTE(v12) < 0) {
      operator delete(v11[1]);
    }
  }
  else
  {
LABEL_11:
    sub_100058DB0(a1, "");
  }
}

void sub_1012753D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_1012753E4(uint64_t a1, int a2)
{
  int v6 = a2;
  char v2 = *(uint64_t **)(a1 + 144);
  if (v2)
  {
    uint64_t v3 = a1 + 136;
    do
    {
      int v4 = *((_DWORD *)v2 + 7);
      if (v4 <= a2)
      {
        if (v4 >= a2) {
          return *(_DWORD *)sub_10012EF5C(v3, &v6) == 4;
        }
        ++v2;
      }
      char v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  return 0;
}

double sub_101275448(std::string *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v7 = *(void *)(a2 + 168);
  uint64_t v5 = a2 + 168;
  uint64_t v6 = v7;
  if (!v7) {
    goto LABEL_11;
  }
  uint64_t v8 = v5;
  do
  {
    int v9 = *(_DWORD *)(v6 + 28);
    BOOL v10 = v9 < a3;
    if (v9 >= a3) {
      int v11 = (uint64_t *)v6;
    }
    else {
      int v11 = (uint64_t *)(v6 + 8);
    }
    if (!v10) {
      uint64_t v8 = v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if (v8 != v5 && *(_DWORD *)(v8 + 28) <= a3)
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    if (a4 == 2) {
      int v13 = *(unsigned __int8 *)(v8 + 32);
    }
    else {
      int v13 = *(unsigned __int8 *)(v8 + 33);
    }
    std::to_string(&v14, v13);
    double result = *(double *)&v14.__r_.__value_.__l.__data_;
    *a1 = v14;
  }
  else
  {
LABEL_11:
    sub_100058DB0(a1, "");
  }
  return result;
}

unsigned char *sub_10127550C(unsigned char *__dst, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = __dst;
  if (a2 != a3)
  {
    while (*(_DWORD *)a2 != a4)
    {
      a2 += 168;
      if (a2 == a3) {
        goto LABEL_8;
      }
    }
  }
  if (a2 == a3)
  {
LABEL_8:
    char v6 = 0;
    *std::string __dst = 0;
  }
  else
  {
    if (*(char *)(a2 + 95) < 0)
    {
      std::string __dst = sub_10004FC84(__dst, *(void **)(a2 + 72), *(void *)(a2 + 80));
    }
    else
    {
      long long v5 = *(_OWORD *)(a2 + 72);
      *((void *)__dst + 2) = *(void *)(a2 + 88);
      *(_OWORD *)std::string __dst = v5;
    }
    char v6 = 1;
  }
  v4[24] = v6;
  return __dst;
}

void sub_10127559C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1012756AC(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_101277A88;
  v7[3] = &unk_101AA4CB8;
  v7[4] = a1 + 8;
  v7[5] = &v5;
  uint64_t v8 = v7;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *(void *)(a3 + 48) = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    int v11 = sub_101277E80;
    long long v12 = &unk_101AA4CF8;
    uint64_t v13 = a3;
    std::string v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *(void *)(a3 + 48) = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    int v11 = sub_101277D34;
    long long v12 = &unk_101AA4CD8;
    uint64_t v13 = a3;
    std::string v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

BOOL sub_1012757E8(uint64_t a1, int a2, const std::string *a3, const std::string *a4)
{
  *(_OWORD *)std::string __dst = 0u;
  long long v35 = 0u;
  sub_10127550C(__dst, *(void *)(a1 + 184), *(void *)(a1 + 192), a2);
  if (BYTE8(v35))
  {
    std::string __p = __dst;
    if (sub_101276F88((uint64_t **)(a1 + 304), __dst, (long long **)&__p)[80])
    {
      std::string __p = 0;
      unint64_t v32 = 0;
      uint64_t v33 = 0;
      *(void *)std::string buf = __dst;
      uint64_t v7 = sub_101276F88((uint64_t **)(a1 + 304), __dst, (long long **)buf);
      unint64_t v32 = 0;
      uint64_t v33 = 0;
      std::string __p = 0;
      sub_100448664(&__p, *((const void **)v7 + 7), *((void *)v7 + 8), (uint64_t)(*((void *)v7 + 8) - *((void *)v7 + 7)) >> 2);
      uint64_t v8 = (__int32 *)__p;
      int v9 = v32;
      int v10 = std::stoi(a3, 0, 10);
      int v11 = wmemchr(v8, v10, v9 - v8);
      if (v11) {
        int v9 = v11;
      }
      long long v12 = v32;
      if (v9 != v32)
      {
        uint64_t v13 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_21;
        }
        int v14 = SHIBYTE(a3->__r_.__value_.__r.__words[2]);
        char v15 = (uint64_t *)a3->__r_.__value_.__r.__words[0];
        uint64_t v16 = subscriber::asString();
        if (v14 >= 0) {
          long long v17 = a3;
        }
        else {
          long long v17 = (const std::string *)v15;
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v17;
        __int16 v37 = 2080;
        uint64_t v38 = v16;
        uint64_t v18 = "#I CS reject cause code [%s] is a valid code for slot [%s]";
        long long v19 = v13;
        goto LABEL_20;
      }
      char v20 = (__int32 *)__p;
      int v21 = std::stoi(a4, 0, 10);
      uint64_t v22 = wmemchr(v20, v21, v12 - v20);
      if (v22) {
        CFTypeID v23 = v22;
      }
      else {
        CFTypeID v23 = v9;
      }
      if (v23 != v32)
      {
        int v24 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_21;
        }
        int v25 = SHIBYTE(a4->__r_.__value_.__r.__words[2]);
        uint64_t v26 = (uint64_t *)a4->__r_.__value_.__r.__words[0];
        uint64_t v27 = subscriber::asString();
        if (v25 >= 0) {
          CFRange v28 = a4;
        }
        else {
          CFRange v28 = (const std::string *)v26;
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v28;
        __int16 v37 = 2080;
        uint64_t v38 = v27;
        uint64_t v18 = "#I PS reject cause code [%s] is a valid code for slot [%s]";
        long long v19 = v24;
LABEL_20:
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, buf, 0x16u);
LABEL_21:
        if (__p)
        {
          unint64_t v32 = (__int32 *)__p;
          operator delete(__p);
        }
        goto LABEL_26;
      }
      if (__p)
      {
        unint64_t v32 = (__int32 *)__p;
        operator delete(__p);
      }
    }
  }
  if (std::stoi(a3, 0, 10) != 11)
  {
    BOOL v29 = std::stoi(a4, 0, 10) == 11;
    goto LABEL_28;
  }
LABEL_26:
  BOOL v29 = 1;
LABEL_28:
  if (BYTE8(v35) && SBYTE7(v35) < 0) {
    operator delete(__dst[0]);
  }
  return v29;
}

void sub_101275AA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a19)
  {
    if (a18 < 0) {
      operator delete(a13);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_101275B00(uint64_t a1)
{
  sub_101275DD8(a1);

  operator delete();
}

uint64_t sub_101275B38(int64x2_t *a1, long long *a2)
{
  unint64_t v2 = 0x8E38E38E38E38E39 * ((a1->i64[1] - a1->i64[0]) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x38E38E38E38E38ELL) {
    sub_10006A748();
  }
  int v6 = a1 + 1;
  if (0x1C71C71C71C71C72 * ((a1[1].i64[0] - a1->i64[0]) >> 3) > v3) {
    unint64_t v3 = 0x1C71C71C71C71C72 * ((a1[1].i64[0] - a1->i64[0]) >> 3);
  }
  if (0x8E38E38E38E38E39 * ((a1[1].i64[0] - a1->i64[0]) >> 3) >= 0x1C71C71C71C71C7) {
    unint64_t v7 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v22 = (uint64_t *)v6;
  if (v7) {
    unint64_t v7 = (unint64_t)sub_1003DD510(v7);
  }
  else {
    uint64_t v8 = 0;
  }
  unint64_t v19 = v7;
  v20.i64[0] = v7 + 72 * v2;
  unint64_t v21 = v7 + 72 * v8;
  sub_101275CD8((char *)v20.i64[0], a2);
  uint64_t v9 = v20.i64[0];
  uint64_t v10 = v20.i64[0] + 72;
  v20.i64[1] = v20.i64[0] + 72;
  uint64_t v12 = a1->i64[0];
  unint64_t v11 = a1->u64[1];
  if (v11 == a1->i64[0])
  {
    int64x2_t v16 = vdupq_n_s64(v11);
  }
  else
  {
    do
    {
      long long v13 = *(_OWORD *)(v11 - 72);
      *(void *)(v9 - 56) = *(void *)(v11 - 56);
      *(_OWORD *)(v9 - 72) = v13;
      *(void *)(v11 - 64) = 0;
      *(void *)(v11 - 56) = 0;
      *(void *)(v11 - 72) = 0;
      uint64_t v14 = *(void *)(v11 - 48);
      *(_DWORD *)(v9 - 40) = *(_DWORD *)(v11 - 40);
      *(void *)(v9 - 48) = v14;
      long long v15 = *(_OWORD *)(v11 - 32);
      *(void *)(v9 - 16) = *(void *)(v11 - 16);
      *(_OWORD *)(v9 - 32) = v15;
      *(void *)(v11 - 24) = 0;
      *(void *)(v11 - 16) = 0;
      *(void *)(v11 - 32) = 0;
      *(void *)(v9 - 8) = *(void *)(v11 - 8);
      v9 -= 72;
      v11 -= 72;
    }
    while (v11 != v12);
    int64x2_t v16 = *a1;
    uint64_t v10 = v20.i64[1];
  }
  a1->i64[0] = v9;
  a1->i64[1] = v10;
  int64x2_t v20 = v16;
  unint64_t v17 = a1[1].u64[0];
  a1[1].i64[0] = v21;
  unint64_t v21 = v17;
  unint64_t v19 = v16.i64[0];
  sub_101275D88((uint64_t)&v19);
  return v10;
}

void sub_101275CC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_101275D88((uint64_t)va);
  _Unwind_Resume(a1);
}

char *sub_101275CD8(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  uint64_t v5 = *((void *)a2 + 3);
  *((_DWORD *)__dst + 8) = *((_DWORD *)a2 + 8);
  *((void *)__dst + 3) = v5;
  int v6 = __dst + 40;
  if (*((char *)a2 + 63) < 0)
  {
    sub_10004FC84(v6, *((void **)a2 + 5), *((void *)a2 + 6));
  }
  else
  {
    long long v7 = *(long long *)((char *)a2 + 40);
    *((void *)__dst + 7) = *((void *)a2 + 7);
    *(_OWORD *)int v6 = v7;
  }
  *((void *)__dst + 8) = *((void *)a2 + 8);
  return __dst;
}

void sub_101275D6C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101275D88(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 72;
    sub_10030A71C(i - 72);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_101275DD8(uint64_t a1)
{
  *(void *)a1 = off_101AA48F0;
  sub_101275F24(*(void **)(a1 + 312));
  sub_101275FD8(*(void **)(a1 + 288));
  sub_1000346F8(a1 + 256, *(void **)(a1 + 264));
  sub_1000346F8(a1 + 232, *(void **)(a1 + 240));
  sub_10003FB28(a1 + 208, *(void **)(a1 + 216));
  long long v7 = (void **)(a1 + 184);
  sub_10008A88C(&v7);
  sub_1000346F8(a1 + 160, *(void **)(a1 + 168));
  sub_1000346F8(a1 + 136, *(void **)(a1 + 144));
  sub_10019D5B8(a1 + 112, *(void **)(a1 + 120));
  unint64_t v2 = *(std::__shared_weak_count **)(a1 + 104);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 64);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  SimDeactivationTrackerInterface::~SimDeactivationTrackerInterface((SimDeactivationTrackerInterface *)a1);
}

void sub_101275F24(void *a1)
{
  if (a1)
  {
    sub_101275F24(*a1);
    sub_101275F24(a1[1]);
    sub_101275F78((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_101275F78(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    unint64_t v2 = *(void **)(a1 + 24);
    if (v2)
    {
      *(void *)(a1 + 32) = v2;
      operator delete(v2);
    }
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

void sub_101275FD8(void *a1)
{
  if (a1)
  {
    sub_101275FD8(*a1);
    sub_101275FD8(a1[1]);
    sub_10127602C((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_10127602C(uint64_t a1)
{
  unint64_t v2 = (void **)(a1 + 32);
  sub_100DAE280(&v2);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
}

void sub_101276078(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1012760B0(uint64_t a1)
{
}

uint64_t sub_1012760CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101276110(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void sub_10127613C(ServiceManager::Service *this)
{
  *(void *)this = off_101AA4A48;
  unint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_101276198(ServiceManager::Service *this)
{
  *(void *)this = off_101AA4A48;
  unint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_101276208@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SimDeactivationTracker");
}

unsigned char *sub_101276218@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  double result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_101276258(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_101272F9C(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_101272F9C(v4, 0);
}

uint64_t sub_1012762DC()
{
  return 0;
}

uint64_t sub_1012762E4()
{
  return 1;
}

uint64_t sub_1012762EC()
{
  return 0;
}

void sub_1012762F8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1012763D8(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_1012764EC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 72));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_101276570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10127658C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  Registry::createRestModuleOneTimeUseConnection(&v10, *(Registry **)(*(void *)v1 + 56));
  ctu::RestModule::connect();
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_100D3EB10(v2 + 112);
  sub_10012E338(v2 + 136);
  sub_100D3EA30(v2 + 208);
  sub_100058DB0(__p, "/cc/props/sims_in_use");
  uint64_t v3 = operator new(0x28uLL);
  void *v3 = off_101AA4AC8;
  v3[1] = v2 + 184;
  v3[2] = v2;
  v3[3] = sub_10127309C;
  v3[4] = 0;
  long long v15 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(v14);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/network_rejects");
  uint64_t v4 = operator new(0x28uLL);
  *uint64_t v4 = off_101AA4B48;
  v4[1] = v2 + 160;
  v4[2] = v2;
  uint64_t v4[3] = sub_101273100;
  v4[4] = 0;
  long long v15 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v14);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/registration_status");
  uint64_t v5 = operator new(0x28uLL);
  void *v5 = off_101AA4BC8;
  v5[1] = v2 + 232;
  v5[2] = v2;
  v5[3] = sub_10127327C;
  void v5[4] = 0;
  long long v15 = v5;
  ctu::RestModule::observeProperty();
  sub_10003F600(v14);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v6 = operator new(0x20uLL);
  void *v6 = off_101AA4C48;
  v6[1] = v2;
  void v6[2] = sub_10127387C;
  v6[3] = 0;
  long long v15 = v6;
  ctu::RestModule::observeEvent();
  sub_10003F600(v14);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  sub_100088C88(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_10127682C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10127689C(uint64_t a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = *(NSObject **)(**(void **)a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Starting SimDeactivationTracker", buf, 2u);
  }
  operator delete();
}

void sub_10127692C()
{
}

__n128 sub_101276940(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA4AC8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101276994(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA4AC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1012769CC(uint64_t a1, xpc_object_t *a2)
{
  sub_100089CF0(*(uint64_t **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_101276A48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101276A88()
{
}

void sub_101276A98()
{
}

__n128 sub_101276AAC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA4B48;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101276B00(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA4B48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101276B38(uint64_t *a1, xpc_object_t *a2)
{
  sub_1004CF7D4(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_101276BB4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101276BF4()
{
}

void sub_101276C04()
{
}

__n128 sub_101276C18(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA4BC8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101276C6C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA4BC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101276CA4(uint64_t *a1, xpc_object_t *a2)
{
  sub_100026EC0(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_101276D20(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101276D60()
{
}

void sub_101276D70()
{
}

__n128 sub_101276D84(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101AA4C48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101276DD8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA4C48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101276E10(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_101276E58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101276E98()
{
}

void sub_101276EA4(uint64_t **a1, int a2)
{
  uint64_t v4 = (uint64_t *)(a1 + 1);
  uint64_t v3 = a1[1];
  if (v3)
  {
    uint64_t v5 = v4;
    uint64_t v6 = v3;
    do
    {
      int v7 = *((_DWORD *)v6 + 8);
      BOOL v8 = v7 < a2;
      if (v7 >= a2) {
        uint64_t v9 = (uint64_t **)v6;
      }
      else {
        uint64_t v9 = (uint64_t **)(v6 + 1);
      }
      if (!v8) {
        uint64_t v5 = v6;
      }
      uint64_t v6 = *v9;
    }
    while (*v9);
    if (v5 != v4 && *((_DWORD *)v5 + 8) <= a2)
    {
      uint64_t v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          unint64_t v11 = v10;
          uint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v12 = v5;
        do
        {
          unint64_t v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          uint64_t v12 = v11;
        }
        while (!v13);
      }
      if (*a1 == v5) {
        *a1 = v11;
      }
      a1[2] = (uint64_t *)((char *)a1[2] - 1);
      sub_10005EE6C(v3, v5);
      sub_10127602C((uint64_t)(v5 + 4));
      operator delete(v5);
    }
  }
}

char *sub_101276F88(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = (char *)a1[1];
  int v7 = (char **)(a1 + 1);
  BOOL v8 = (char **)(a1 + 1);
  if (!v5) {
    goto LABEL_10;
  }
  int v7 = (char **)(a1 + 1);
  while (1)
  {
    while (1)
    {
      BOOL v8 = (char **)v5;
      uint64_t v10 = v5 + 32;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      uint64_t v5 = *v8;
      int v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    int v7 = v8 + 1;
    uint64_t v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  unint64_t v11 = *v7;
  if (!*v7)
  {
LABEL_10:
    uint64_t v12 = *a3;
    uint64_t v19 = 0;
    BOOL v13 = (char *)operator new(0x58uLL);
    v18[0] = v13;
    v18[1] = v6;
    uint64_t v14 = v13 + 32;
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(v14, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v15 = *v12;
      *((void *)v13 + 6) = *((void *)v12 + 2);
      *(_OWORD *)uint64_t v14 = v15;
    }
    v13[56] = 0;
    v13[80] = 0;
    LOBYTE(v19) = 1;
    *(void *)BOOL v13 = 0;
    *((void *)v13 + 1) = 0;
    *((void *)v13 + 2) = v8;
    char *v7 = v13;
    int64x2_t v16 = (uint64_t *)**a1;
    if (v16)
    {
      *a1 = v16;
      BOOL v13 = *v7;
    }
    sub_100046C90(a1[1], (uint64_t *)v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    unint64_t v11 = (char *)v18[0];
    v18[0] = 0;
    sub_1012770EC((uint64_t)v18);
  }
  return v11;
}

void sub_1012770D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1012770EC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1012770EC(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_101275F78((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

char *sub_101277144(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = (char *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int v7 = v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *(char **)v7;
        uint64_t v6 = (uint64_t **)v7;
        if (!*(void *)v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = (char *)*((void *)v7 + 1);
      if (!v5)
      {
        uint64_t v6 = (uint64_t **)(v7 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    int v7 = (char *)(a1 + 1);
LABEL_9:
    uint64_t v9 = v7;
    int v7 = (char *)operator new(0x58uLL);
    *((_DWORD *)v7 + 8) = *a3;
    *(_OWORD *)(v7 + 40) = 0u;
    *(_OWORD *)(v7 + 56) = 0u;
    *(_OWORD *)(v7 + 72) = 0u;
    *(void *)int v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v9;
    uint64_t *v6 = (uint64_t *)v7;
    uint64_t v10 = (uint64_t *)**a1;
    unint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      unint64_t v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t *sub_101277220(_DWORD **a1)
{
  uint64_t v1 = *a1;
  uint64_t v40 = a1;
  uint64_t v41 = v1;
  int v2 = v1[6];
  uint64_t v3 = *(void *)v1;
  uint64_t v4 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), *(unsigned int *)(*((void *)v1 + 1) + 52));
  uint64_t v5 = *((void *)v1 + 1);
  uint64_t v6 = *(unsigned int *)(v5 + 52);
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v45 = 0;
  if (*(char *)(v5 + 47) < 0)
  {
    sub_10004FC84(__dst, *(void **)(v5 + 24), *(void *)(v5 + 32));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)(v5 + 24);
    int v7 = *(uint64_t **)(v5 + 40);
    uint64_t v45 = v7;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(v3 + 56));
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (v14)
  {
    uint64_t v16 = v14[3];
    long long v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  long long v15 = 0;
  char v17 = 1;
LABEL_12:
  if (v2 == 6000)
  {
    int v25 = (*(uint64_t (**)(uint64_t, void **, const __CFString *, const CFBooleanRef, const __CFString *, void, uint64_t, void))(*(void *)v16 + 16))(v16, __dst, @"EntitlementAuthSuccessStatus", kCFBooleanTrue, @"SimDeactivationInfo", 0, 1, 0);
    uint64_t v26 = *v4;
    uint64_t v27 = *v4;
    if (v25)
    {
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v25;
        _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Failed to store entitlement auth status, error (%d)", buf, 8u);
      }
    }
    else if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "STATUS_SUCCESS";
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Stored entitlement auth status (%s) successfully", buf, 0xCu);
    }
  }
  else if (v2 == 6004)
  {
    int v43 = 0;
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void **, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v16 + 24))(&cf, v16, __dst, @"EntitlementAuthSuccessStatus", @"SimDeactivationInfo", 0, 1);
    v47.__r_.__value_.__r.__words[0] = (std::string::size_type)cf;
    if (cf) {
      CFRetain(cf);
    }
    unsigned int v46 = 0;
    *(void *)std::string buf = 0;
    sub_1000057AC(buf, (CFTypeRef *)&v47.__r_.__value_.__l.__data_);
    if (*(void *)buf) {
      uint64_t v18 = sub_100084B4C;
    }
    else {
      uint64_t v18 = 0;
    }
    if (v18) {
      sub_1005AED68((const void **)&v46, (const void **)buf);
    }
    sub_100062778((const void **)buf);
    uint64_t v19 = v46;
    int v43 = v46;
    unsigned int v46 = 0;
    sub_100062778((const void **)&v46);
    sub_1000577C4((const void **)&v47.__r_.__value_.__l.__data_);
    sub_1000577C4(&cf);
    if (v19) {
      unint64_t v21 = sub_100084B4C;
    }
    else {
      unint64_t v21 = 0;
    }
    if (v21)
    {
      buf[0] = 0;
      ctu::cf::assign((ctu::cf *)buf, v19, v20);
      if (buf[0])
      {
        int v22 = (*(uint64_t (**)(uint64_t, void **, const __CFString *, const CFBooleanRef, const __CFString *, void, uint64_t, void))(*(void *)v16 + 16))(v16, __dst, @"EntitlementAuthSuccessStatus", kCFBooleanFalse, @"SimDeactivationInfo", 0, 1, 0);
        CFTypeID v23 = *v4;
        int v24 = *v4;
        if (v22)
        {
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v22;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Failed to store entitlement auth status, error (%d)", buf, 8u);
          }
        }
        else if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = "STATUS_UNKNOWN_SUBSCRIBER";
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Stored entitlement auth status (%s) successfully", buf, 0xCu);
        }
        LODWORD(v46) = v6;
        CFRange v28 = *(_DWORD **)(v3 + 184);
        BOOL v29 = *(_DWORD **)(v3 + 192);
        if (v28 != v29)
        {
          while (*v28 != v6)
          {
            v28 += 42;
            if (v28 == v29) {
              goto LABEL_51;
            }
          }
        }
        if (v28 != v29 && subscriber::isSimReady())
        {
          unint64_t v30 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), v6);
          int64_t v31 = sub_101277144((uint64_t **)(v3 + 280), v6, &v46);
          sub_1012752F8((uint64_t *)buf, v3, v6);
          unint64_t v32 = (void **)(v31 + 40);
          if (v31[63] < 0) {
            operator delete(*v32);
          }
          *(_OWORD *)unint64_t v32 = *(_OWORD *)buf;
          *((void *)v31 + 7) = *(void *)v49;
          int v50 = 0;
          *(_OWORD *)std::string buf = 0u;
          *(_OWORD *)__int16 v49 = 0u;
          long long __p = 0u;
          long long v52 = 0u;
          *(void *)&v49[12] = 0x20000000BLL;
          std::to_string(&v47, 6004);
          long long __p = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
          *(void *)&long long v52 = *((void *)&v47.__r_.__value_.__l + 2);
          *((void *)&v52 + 1) = (uint64_t)(kCFAbsoluteTimeIntervalSince1970 + CFAbsoluteTimeGetCurrent());
          *(_WORD *)&v49[8] = sub_1012753E4(v3, v6);
          unint64_t v33 = *((void *)v31 + 9);
          if (v33 >= *((void *)v31 + 10))
          {
            uint64_t v34 = sub_101275B38((int64x2_t *)v31 + 4, (long long *)buf);
          }
          else
          {
            sub_101275CD8(*((char **)v31 + 9), (long long *)buf);
            uint64_t v34 = v33 + 72;
            *((void *)v31 + 9) = v33 + 72;
          }
          *((void *)v31 + 9) = v34;
          long long v35 = *v30;
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v47.__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Sending notification for entitlement auth failure", (uint8_t *)&v47, 2u);
          }
          (*(void (**)(void, uint64_t, char *))(**(void **)(v3 + 96) + 96))(*(void *)(v3 + 96), v6, v31 + 40);
          if (SBYTE7(v52) < 0) {
            operator delete((void *)__p);
          }
        }
LABEL_51:
        (*(void (**)(uint64_t, void **, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v16 + 32))(v16, __dst, @"EntitlementAuthSuccessStatus", @"SimDeactivationInfo", 0, 1);
        __int16 v36 = (void *)HIBYTE(v45);
        if (SHIBYTE(v45) < 0) {
          __int16 v36 = __dst[1];
        }
        if (v36 && isReal())
        {
          __int16 v37 = *v4;
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v38 = __dst;
            if (SHIBYTE(v45) < 0) {
              uint64_t v38 = (void **)__dst[0];
            }
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = v38;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Notify iccid %s as deactivated", buf, 0xCu);
          }
          sub_101274F18(v3, (uint64_t *)__dst);
        }
      }
    }
    sub_100062778((const void **)&v43);
  }
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  sub_101277A34((uint64_t *)&v41);
  return sub_100046B58((uint64_t *)&v40);
}

void sub_101277978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 a11, char a12, char a13, int a14, const void *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  *(void *)(v31 + 72) = v32;
  sub_1002E4140((uint64_t)&a30);
  sub_100062778(&a15);
  if ((v33 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_101277A34(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101277A34(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    int v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_101277A88(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(unsigned int **)(a1 + 40);
  uint64_t v4 = *(void *)v3;
  uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v3 + 48) + 16))(*(void *)(*(void *)v3 + 48), v3[2]);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(void *)(a2 + 48) = 0;
  uint64_t v6 = *(void *)(v4 + 288);
  if (!v6) {
    goto LABEL_11;
  }
  uint64_t v7 = v4 + 288;
  signed int v8 = v3[2];
  uint64_t v9 = v4 + 288;
  do
  {
    signed int v10 = *(_DWORD *)(v6 + 32);
    BOOL v11 = v10 < v8;
    if (v10 >= v8) {
      uint64_t v12 = (uint64_t *)v6;
    }
    else {
      uint64_t v12 = (uint64_t *)(v6 + 8);
    }
    if (!v11) {
      uint64_t v9 = v6;
    }
    uint64_t v6 = *v12;
  }
  while (*v12);
  if (v9 != v7 && v8 >= *(_DWORD *)(v9 + 32))
  {
    if (*(char *)(v9 + 63) < 0)
    {
      sub_10004FC84((unsigned char *)a2, *(void **)(v9 + 40), *(void *)(v9 + 48));
    }
    else
    {
      long long v14 = *(_OWORD *)(v9 + 40);
      *(void *)(a2 + 16) = *(void *)(v9 + 56);
      *(_OWORD *)a2 = v14;
    }
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    uint64_t v15 = *(void *)(v9 + 64);
    uint64_t v16 = *(void *)(v9 + 72);
    v17[0] = a2 + 24;
    if (v16 != v15)
    {
      v17[1] = 0;
      sub_10060D740((void *)(a2 + 24), 0x8E38E38E38E38E39 * ((v16 - v15) >> 3));
      *(void *)(a2 + 32) = sub_101277CB0(v15, v16, *(void *)(a2 + 32));
    }
    *(unsigned char *)(a2 + 48) = 1;
  }
  else
  {
LABEL_11:
    unsigned int v13 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v17[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not find SimDeactivation info", (uint8_t *)v17, 2u);
    }
  }
}

void sub_101277C08(_Unwind_Exception *a1)
{
  sub_100DAE22C(v1);
  _Unwind_Resume(a1);
}

void sub_101277C48(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 72;
        sub_10030A71C(v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_101277CB0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      sub_101275CD8((char *)(a3 + v6), (long long *)(a1 + v6));
      v6 += 72;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_101277D10(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 72;
    do
    {
      sub_10030A71C(v4 + v2);
      v2 -= 72;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101277D34(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(v3);
  sub_101277D88(*(void *)(a1 + 32), v3);
  return sub_100DAE22C((uint64_t)v3);
}

__n128 sub_101277D88(uint64_t a1, long long *a2)
{
  if (*(unsigned __int8 *)(a1 + 48) == *((unsigned __int8 *)a2 + 48))
  {
    if (*(unsigned char *)(a1 + 48))
    {
      if (*(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
      long long v4 = *a2;
      *(void *)(a1 + 16) = *((void *)a2 + 2);
      *(_OWORD *)a1 = v4;
      *((unsigned char *)a2 + 23) = 0;
      *(unsigned char *)a2 = 0;
      sub_101277C48((void **)(a1 + 24));
      __n128 result = *(__n128 *)((char *)a2 + 24);
      *(__n128 *)(a1 + 24) = result;
      *(void *)(a1 + 40) = *((void *)a2 + 5);
      *((void *)a2 + 3) = 0;
      *((void *)a2 + 4) = 0;
      *((void *)a2 + 5) = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v7 = (void **)(a1 + 24);
    sub_100DAE280(&v7);
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(unsigned char *)(a1 + 48) = 0;
  }
  else
  {
    long long v6 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v6;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    __n128 result = *(__n128 *)((char *)a2 + 24);
    *(__n128 *)(a1 + 24) = result;
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *((void *)a2 + 3) = 0;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *(unsigned char *)(a1 + 48) = 1;
  }
  return result;
}

uint64_t sub_101277E80(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(v3);
  sub_101277D88(*(void *)(a1 + 32), v3);
  return sub_100DAE22C((uint64_t)v3);
}

void sub_101277ED4()
{
}

void sub_101277F48()
{
}

void sub_101277FE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101278020(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_101074D00();
}

void sub_1012780D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 8))(a11);
  }
  if (v11) {
    dispatch_release(v11);
  }
  _Unwind_Resume(exception_object);
}

void sub_101278120(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_1010EAC5C();
}

void sub_101278190(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1012781A8(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_100745424();
}

void sub_101278218(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101278230()
{
}

void sub_10127826C()
{
}

void sub_1012782A4(void *a1@<X8>)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = a1 + 1;
  uint64_t v1 = 0;
  sub_101277ED4();
}

void sub_101278420(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (v16) {
    dispatch_release(v16);
  }
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 8))(a11);
  }
  sub_10005D0E4(v15, *(void **)(v15 + 8));
  _Unwind_Resume(a1);
}

void sub_1012784C4(uint64_t a1, dispatch_object_t *a2, uint64_t a3)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  uint64_t v4 = *(void *)(a3 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  RegistrationEventHandler::create(&v5);
}

void sub_101278560(_Unwind_Exception *exception_object)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101278584()
{
  sub_100C4248C(&v0);
}

void sub_1012785C0()
{
}

double sub_1012785FC@<D0>(CCPreferences *a1@<X0>, _OWORD *a2@<X8>)
{
  CCPreferences::create((uint64_t *)&v4, a1);
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

void sub_101278634(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_101020664();
}

void sub_1012786AC(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1012786C4(RegistrationFactoryInterface *this)
{
  *(void *)this = off_101AA4D28;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  RegistrationFactoryInterface::~RegistrationFactoryInterface(this);
}

void sub_101278720(RegistrationFactoryInterface *this)
{
  *(void *)this = off_101AA4D28;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  RegistrationFactoryInterface::~RegistrationFactoryInterface(this);

  operator delete();
}

void sub_101278790(void ***a1)
{
  *a1 = (void **)off_101AA4DC0;
  sub_100110A40(a1 + 1, 0);

  PB::Base::~Base((PB::Base *)a1);
}

void sub_1012787E8(void ***a1)
{
  *a1 = (void **)off_101AA4DC0;
  sub_100110A40(a1 + 1, 0);
  PB::Base::~Base((PB::Base *)a1);

  operator delete();
}

uint64_t sub_101278854(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  long long v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  char v6 = *(unsigned char *)(a1 + 24);
  if (v6)
  {
    PB::TextFormatter::format(this, "error", *(_DWORD *)(a1 + 16));
    char v6 = *(unsigned char *)(a1 + 24);
  }
  if ((v6 & 2) != 0) {
    PB::TextFormatter::format(this, "result", *(unsigned char *)(a1 + 20));
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_1012788E8(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v13 = *(unsigned char *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v2 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_19;
        }
      }
LABEL_20:
      unsigned __int8 v19 = v11 & 7;
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v20 = v11 >> 3;
      if ((v11 >> 3) == 3)
      {
        *(unsigned char *)(a1 + 24) |= 1u;
        unint64_t v23 = *((void *)this + 1);
        unint64_t v24 = *((void *)this + 2);
        uint64_t v25 = *(void *)this;
        if (v23 > 0xFFFFFFFFFFFFFFF5 || v23 + 10 > v24)
        {
          char v35 = 0;
          unsigned int v36 = 0;
          uint64_t v28 = 0;
          if (v24 <= v23) {
            unint64_t v24 = *((void *)this + 1);
          }
          while (1)
          {
            if (v24 == v23)
            {
              LODWORD(v28) = 0;
              *((unsigned char *)this + 24) = 1;
              goto LABEL_52;
            }
            unint64_t v37 = v23 + 1;
            char v38 = *(unsigned char *)(v25 + v23);
            *((void *)this + 1) = v37;
            v28 |= (unint64_t)(v38 & 0x7F) << v35;
            if ((v38 & 0x80) == 0) {
              break;
            }
            v35 += 7;
            unint64_t v23 = v37;
            BOOL v14 = v36++ > 8;
            if (v14)
            {
LABEL_46:
              LODWORD(v28) = 0;
              goto LABEL_52;
            }
          }
          if (*((unsigned char *)this + 24)) {
            LODWORD(v28) = 0;
          }
        }
        else
        {
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v28 = 0;
          while (1)
          {
            unint64_t v29 = v23 + 1;
            *((void *)this + 1) = v23 + 1;
            char v30 = *(unsigned char *)(v25 + v23);
            v28 |= (unint64_t)(v30 & 0x7F) << v26;
            if ((v30 & 0x80) == 0) {
              break;
            }
            v26 += 7;
            unint64_t v23 = v29;
            BOOL v14 = v27++ > 8;
            if (v14) {
              goto LABEL_46;
            }
          }
        }
LABEL_52:
        *(_DWORD *)(a1 + 16) = v28;
      }
      else if (v20 == 2)
      {
        *(unsigned char *)(a1 + 24) |= 2u;
        unint64_t v31 = *((void *)this + 1);
        if (v31 >= *((void *)this + 2))
        {
          BOOL v34 = 0;
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          unint64_t v32 = v31 + 1;
          int v33 = *(unsigned __int8 *)(*(void *)this + v31);
          *((void *)this + 1) = v32;
          BOOL v34 = v33 != 0;
        }
        *(unsigned char *)(a1 + 20) = v34;
      }
      else
      {
        if (v20 == 1) {
          operator new();
        }
LABEL_25:
        uint64_t result = PB::Reader::skip(this, v20, v19, 0);
        if (!result) {
          return result;
        }
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || v4 != 0) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_20;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
      if (v14)
      {
LABEL_19:
        unsigned __int8 v19 = 0;
        LODWORD(v20) = 0;
        goto LABEL_25;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_101278BC8(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  char v5 = *(unsigned char *)(v3 + 24);
  if ((v5 & 2) != 0)
  {
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 20), 2u);
    char v5 = *(unsigned char *)(v3 + 24);
  }
  if (v5)
  {
    unsigned int v6 = *(_DWORD *)(v3 + 16);
    return PB::Writer::writeVarInt(this, v6, 3u);
  }
  return result;
}

void sub_101278C50(capabilities::ct *a1@<X0>, dispatch_object_t *a2@<X2>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  if (capabilities::ct::supportsCellRadio(a1))
  {
    if (*a2) {
      dispatch_retain(*a2);
    }
    sub_101278D4C(&v4);
  }
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_101278E5C(&v4);
}

void sub_101278D24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_101278D3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!a10) {
    JUMPOUT(0x101278D34);
  }
  JUMPOUT(0x101278D30);
}

void sub_101278D4C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_101278E14(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_101278E5C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_101278F24(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_101278F6C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_101279038(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_101279110);
  __cxa_rethrow();
}

void sub_101279060(_Unwind_Exception *a1)
{
}

void sub_101279078(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1012790B0(uint64_t a1)
{
}

uint64_t sub_1012790CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101279110(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10127913C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_101279208(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1012792E0);
  __cxa_rethrow();
}

void sub_101279230(_Unwind_Exception *a1)
{
}

void sub_101279248(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101279280(uint64_t a1)
{
}

uint64_t sub_10127929C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1012792E0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10127930C()
{
}

void sub_101279364()
{
}

void sub_101279388(uint64_t a1)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, kCtLoggingSystemName, "main");
  initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  uint64_t v3 = dispatch_queue_create_with_target_V2("CCDaemon", initially_inactive, 0);
  dispatch_set_qos_class_floor(v3, QOS_CLASS_UTILITY, 0);
  dispatch_activate(v3);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v3;
  if (v3)
  {
    dispatch_retain(v3);
    *(void *)(a1 + 24) = 0;
    dispatch_release(v3);
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &v9);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 32), (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  sub_100058DB0(&__p, "CCDaemon");
  long long v4 = *(NSObject **)(a1 + 16);
  char v5 = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  ctu::RestModule::RestModule();
  if (v5) {
    dispatch_release(v5);
  }
  if (v7 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  operator new();
}

void sub_101279610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t object, dispatch_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(v21 - 48));
  unint64_t v23 = (std::__shared_weak_count *)v19[16];
  if (v23) {
    sub_10004D2C8(v23);
  }
  unint64_t v24 = (std::__shared_weak_count *)v19[14];
  if (v24) {
    sub_10004D2C8(v24);
  }
  uint64_t v25 = v19[12];
  v19[12] = 0;
  if (v25) {
    sub_100F053A4(v25);
  }
  sub_101279DE4(v19 + 7);
  char v26 = (std::__shared_weak_count *)v19[6];
  if (v26) {
    sub_10004D2C8(v26);
  }
  ctu::OsLogLogger::~OsLogLogger(v20);
  sub_100087E88(v19);
  _Unwind_Resume(a1);
}

void sub_101279720(uint64_t a1)
{
  unint64_t v2 = *(std::__shared_weak_count **)(a1 + 112);
  uint64_t v3 = a1 + 104;
  long long v4 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  Registry::set();
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_1006C2030(*(uint64_t **)(a1 + 96), v3);
}

void sub_1012798B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1012798E0(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N CommCenter is shutting down. Clear all features (0)", (uint8_t *)&v12, 2u);
    }
    uint64_t v4 = 0;
  }
  else if (*(unsigned char *)(a1 + 141))
  {
    uint64_t v4 = (4 * *(unsigned __int8 *)(a1 + 140)) | 8;
  }
  else
  {
    uint64_t v4 = 4 * *(unsigned __int8 *)(a1 + 140);
  }
  if (byte_101B133F0)
  {
    uint64_t v5 = qword_101B133F8;
    if (qword_101B133F8 == v4) {
      goto LABEL_15;
    }
    unsigned int v6 = *(NSObject **)(a1 + 32);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_15;
    }
    int v12 = 134218240;
    uint64_t v13 = v5;
    __int16 v14 = 2048;
    uint64_t v15 = v4;
    char v7 = "#N CommCenter features changed from %llu -> %llu";
    uint64_t v8 = v6;
    uint32_t v9 = 22;
  }
  else
  {
    byte_101B133F0 = 1;
    unsigned int v10 = *(NSObject **)(a1 + 32);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_15;
    }
    int v12 = 134217984;
    uint64_t v13 = v4;
    char v7 = "#N CommCenter features initialized to %llu";
    uint64_t v8 = v10;
    uint32_t v9 = 12;
  }
  _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v12, v9);
LABEL_15:
  qword_101B133F8 = v4;
  uint64_t result = notify_is_valid_token(*(_DWORD *)(a1 + 136));
  if (result)
  {
    notify_set_state(*(_DWORD *)(a1 + 136), v4);
    return notify_post("com.apple.CoreTelephony.FeatureChanged");
  }
  return result;
}

void sub_101279A8C(uint64_t a1)
{
  unint64_t v2 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#N CommCenter Init: creating basic services", v3, 2u);
  }
  Registry::markInitializationComplete(*(Registry **)(a1 + 104));
  sub_1006C2D2C(*(void *)(a1 + 96), a1 + 104);
}

void sub_101279B04(void *a1)
{
  unint64_t v2 = (std::__shared_weak_count *)a1[16];
  a1[15] = 0;
  a1[16] = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v5 = a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10127A8E4;
  block[3] = &unk_101AA5128;
  block[4] = a1;
  block[5] = &v5;
  uint64_t v3 = a1[2];
  if (a1[3]) {
    dispatch_async_and_wait(v3, block);
  }
  else {
    dispatch_sync(v3, block);
  }
  uint64_t v4 = a1[4];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(block[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N CommCenter Init: complete", (uint8_t *)block, 2u);
  }
}

uint64_t sub_101279BDC(uint64_t a1)
{
  unint64_t v2 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#N CommCenter Shutdown: stopping services", v5, 2u);
  }
  *(_DWORD *)(a1 + 88) = 2;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 48))(v3);
  }
  return sub_1012798E0(a1, 1);
}

void sub_101279C84(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#N CommCenter Shutdown: complete", v2, 2u);
  }
}

void sub_101279CE4(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void *sub_101279DE4(void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_101279E68(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_101279F34(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[2], v1, (dispatch_function_t)sub_10127A00C);
  __cxa_rethrow();
}

void sub_101279F5C(_Unwind_Exception *a1)
{
}

void sub_101279F74(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101279FAC(uint64_t a1)
{
}

uint64_t sub_101279FC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_10127A00C(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(result + 18));
    unint64_t v2 = (std::__shared_weak_count *)v1[16];
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[14];
    if (v3) {
      sub_10004D2C8(v3);
    }
    uint64_t v4 = v1[12];
    v1[12] = 0;
    if (v4) {
      sub_100F053A4(v4);
    }
    sub_101279DE4(v1 + 7);
    uint64_t v5 = (std::__shared_weak_count *)v1[6];
    if (v5) {
      sub_10004D2C8(v5);
    }
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 4));
    sub_100087E88(v1);
    operator delete();
  }
  return result;
}

void sub_10127A0A8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101AA5048;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10127A0C8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101AA5048;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10127A11C(uint64_t a1)
{
  sub_1006C65E8((void *)(a1 + 408));
  sub_1006C5E9C((void *)(a1 + 376));
  sub_1006C5CAC((void *)(a1 + 344));
  uint64_t v2 = *(void *)(a1 + 320);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 328);
    uint64_t v4 = *(void **)(a1 + 320);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5) {
          sub_10004D2C8(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 320);
    }
    *(void *)(a1 + 328) = v2;
    operator delete(v4);
  }
  unsigned int v6 = *(void **)(a1 + 296);
  if (v6)
  {
    do
    {
      char v7 = (void *)*v6;
      uint64_t v8 = (std::__shared_weak_count *)v6[4];
      if (v8) {
        sub_10004D2C8(v8);
      }
      operator delete(v6);
      unsigned int v6 = v7;
    }
    while (v7);
  }
  uint32_t v9 = *(void **)(a1 + 280);
  *(void *)(a1 + 280) = 0;
  if (v9) {
    operator delete(v9);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 216));
  unsigned int v10 = *(std::__shared_weak_count **)(a1 + 208);
  if (v10) {
    sub_10004D2C8(v10);
  }
  unint64_t v11 = *(std::__shared_weak_count **)(a1 + 192);
  if (v11) {
    sub_10004D2C8(v11);
  }
  int v12 = *(std::__shared_weak_count **)(a1 + 176);
  if (v12) {
    sub_10004D2C8(v12);
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 160);
  if (v13) {
    sub_10004D2C8(v13);
  }
  __int16 v14 = *(std::__shared_weak_count **)(a1 + 144);
  if (v14) {
    sub_10004D2C8(v14);
  }
  uint64_t v15 = *(std::__shared_weak_count **)(a1 + 128);
  if (v15) {
    sub_10004D2C8(v15);
  }
  unsigned int v16 = *(std::__shared_weak_count **)(a1 + 112);
  if (v16) {
    sub_10004D2C8(v16);
  }
  unint64_t v17 = *(std::__shared_weak_count **)(a1 + 96);
  if (v17) {
    sub_10004D2C8(v17);
  }
  char v18 = *(std::__shared_weak_count **)(a1 + 80);
  if (v18) {
    sub_10004D2C8(v18);
  }
  unsigned __int8 v19 = *(std::__shared_weak_count **)(a1 + 64);
  if (v19) {
    sub_10004D2C8(v19);
  }
  unint64_t v20 = *(std::__shared_weak_count **)(a1 + 48);
  if (v20) {
    sub_10004D2C8(v20);
  }
  uint64_t v21 = *(std::__shared_weak_count **)(a1 + 32);
  if (v21)
  {
    sub_10004D2C8(v21);
  }
}

void sub_10127A28C(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 40);
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    CTGetRootVersionString();
    uint64_t v2 = v5 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136446210;
    *(void *)&uint8_t buf[4] = v2;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "Version: %{public}s", buf, 0xCu);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = (void *)kCTProjectBuildRevision;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "Build revision: %s", (uint8_t *)__p, 0xCu);
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = (void *)kCTProjectBuildReason;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "Build reason: %s", (uint8_t *)__p, 0xCu);
  }
  *(_OWORD *)long long __p = 0uLL;
  Registry::getServiceManager((uint64_t *)__p, *(Registry **)(v1 + 104));
  if (__p[0])
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3)
    {
      if (std::__shared_weak_count::lock(v3)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  if (__p[1]) {
    sub_10004D2C8((std::__shared_weak_count *)__p[1]);
  }
}

void sub_10127A4CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13) {
    (*(void (**)(uint64_t))(*(void *)a13 + 8))(a13);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10127A534(ServiceManager::Service *this)
{
  *(void *)this = off_101AA50B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10127A590(ServiceManager::Service *this)
{
  *(void *)this = off_101AA50B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10127A600@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "CCDaemon");
}

unsigned char *sub_10127A610@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10127A650(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_101279CE4(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_101279CE4(v4, 0);
}

uint64_t sub_10127A6D4()
{
  return 0;
}

uint64_t sub_10127A6DC()
{
  return 1;
}

uint64_t sub_10127A6E4()
{
  return 0;
}

void sub_10127A6F0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10127A7D0(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 8);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10127A8E4(uint64_t a1)
{
  return sub_1012798E0(**(void **)(a1 + 40), 0);
}

uint64_t *sub_10127A8F4(void **a1)
{
  uint64_t v1 = *a1;
  unint64_t v17 = a1;
  char v18 = v1;
  uint64_t v2 = (int *)*v1;
  uint64_t v3 = (long long *)(*v1 + 56);
  uint64_t v4 = (void *)(*v1 + 40);
  *(void *)&long long buf = off_101AA5158;
  *((void *)&buf + 1) = v4;
  p_long long buf = &buf;
  if (&buf != v3)
  {
    char v5 = (long long *)*((void *)v2 + 10);
    if (v5 == v3)
    {
      __p[1] = v4;
      uint64_t v22 = 0;
      p_long long buf = 0;
      __p[0] = off_101AA5158;
      (*(void (**)(long long *, long long *))(*(void *)v3 + 24))(v3, &buf);
      (*(void (**)(uint64_t))(**((void **)v2 + 10) + 32))(*((void *)v2 + 10));
      *((void *)v2 + 10) = 0;
      p_long long buf = &buf;
      (*((void (**)(void **, long long *))__p[0] + 3))(__p, v3);
      (*((void (**)(void **))__p[0] + 4))(__p);
    }
    else
    {
      *((void *)v2 + 7) = off_101AA5158;
      *((void *)v2 + 8) = v4;
      p_long long buf = v5;
    }
    *((void *)v2 + 10) = v3;
  }
  sub_101279DE4(&buf);
  uint64_t v6 = *((void *)v2 + 10);
  if (v6) {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 48))(v6, (uint64_t *)v2 + 11);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  *(void *)&long long buf = off_101AA51E8;
  *((void *)&buf + 1) = v2;
  p_long long buf = &buf;
  ctu::RestModule::observeEvent();
  sub_10003F600(&buf);
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[0]);
  }
  if (notify_register_check("com.apple.CoreTelephony.FeatureChanged", v2 + 34))
  {
    char v7 = *((void *)v2 + 4);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "com.apple.CoreTelephony.FeatureChanged";
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to create notify register check for notification '%s'", (uint8_t *)&buf, 0xCu);
    }
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)v2 + 1);
  if (!v8 || (uint64_t v9 = *(void *)v2, (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
    sub_100088B9C();
  }
  unint64_t v11 = v10;
  p_shared_weak_owners = &v10->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  sub_100058DB0(__p, "/cc/props/baseband_asserted");
  uint64_t v13 = (long long *)operator new(0x20uLL);
  *(void *)uint64_t v13 = off_101AA5578;
  *((void *)v13 + 1) = v2 + 35;
  *((void *)v13 + 2) = v9;
  *((void *)v13 + 3) = v11;
  p_long long buf = v13;
  ctu::RestModule::observeProperty();
  sub_10003F600(&buf);
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[0]);
  }
  atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_100058DB0(__p, "/cc/props/thumper_capability");
  __int16 v14 = (long long *)operator new(0x20uLL);
  *(void *)__int16 v14 = off_101AA55F8;
  *((void *)v14 + 1) = (char *)v2 + 141;
  *((void *)v14 + 2) = v9;
  *((void *)v14 + 3) = v11;
  p_long long buf = v14;
  ctu::RestModule::observeProperty();
  sub_10003F600(&buf);
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[0]);
  }
  std::__shared_weak_count::__release_weak(v11);
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)&buf, *((Registry **)v2 + 13));
  ctu::RestModule::connect();
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  uint64_t v15 = *((void *)v2 + 4);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Daemon bootstrapped. All REST properties bound", (uint8_t *)__p, 2u);
  }
  sub_100088C88((uint64_t *)&v18);
  return sub_100046B58((uint64_t *)&v17);
}

void sub_10127AD24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10127ADE0()
{
}

void *sub_10127ADF4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA5158;
  result[1] = v3;
  return result;
}

uint64_t sub_10127AE3C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA5158;
  a2[1] = v2;
  return result;
}

void sub_10127AE68(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = (rest_service_state *)xpc_int64_create(*a2);
  uint64_t v3 = v2;
  if (!v2)
  {
    uint64_t v2 = (rest_service_state *)xpc_null_create();
    uint64_t v3 = v2;
  }
  base_path = (char *)rest_service_state::get_base_path(v2);
  sub_100058DB0(&__p, base_path);
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_10127AF18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_10127AF60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10127AFA0()
{
}

void sub_10127AFB0()
{
}

void *sub_10127AFC4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA51E8;
  result[1] = v3;
  return result;
}

uint64_t sub_10127B00C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA51E8;
  a2[1] = v2;
  return result;
}

void sub_10127B038(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(NSObject **)(v1 + 144);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Dumping REST", buf, 2u);
  }
  sub_100058DB0(&v11, "/connections");
  *(void *)long long buf = off_101AA5258;
  uint64_t v14 = v1;
  uint64_t v15 = buf;
  ctu::RestModule::getPropertyOnce();
  sub_10003F600(buf);
  if (v12 < 0) {
    operator delete(v11);
  }
  sub_100058DB0(&__p, "/cc/assertions/*");
  *(void *)long long buf = off_101AA52D8;
  uint64_t v14 = v1;
  uint64_t v15 = buf;
  ctu::RestModule::getPropertyOnce();
  sub_10003F600(buf);
  if (v10 < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&v7, "/cc/props/*");
  *(void *)long long buf = off_101AA5378;
  uint64_t v14 = v1;
  uint64_t v15 = buf;
  ctu::RestModule::getPropertyOnce();
  sub_10003F600(buf);
  if (v8 < 0) {
    operator delete(v7);
  }
  sub_100058DB0(&v5, "/cc/device_info/*");
  *(void *)long long buf = off_101AA5418;
  uint64_t v14 = v1;
  uint64_t v15 = buf;
  ctu::RestModule::getPropertyOnce();
  sub_10003F600(buf);
  if (v6 < 0) {
    operator delete(v5);
  }
  sub_100058DB0(&v3, "/cc/prefs-nb/*");
  *(void *)long long buf = off_101AA54B8;
  uint64_t v14 = v1;
  uint64_t v15 = buf;
  ctu::RestModule::getPropertyOnce();
  sub_10003F600(buf);
  if (v4 < 0) {
    operator delete(v3);
  }
}

void sub_10127B298(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_10003F600((void *)(v15 - 64));
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10127B338(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10127B378()
{
}

void sub_10127B388()
{
}

void *sub_10127B39C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA5258;
  result[1] = v3;
  return result;
}

uint64_t sub_10127B3E4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA5258;
  a2[1] = v2;
  return result;
}

void sub_10127B410(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  *a2 = xpc_null_create();
  uint64_t v4 = *(void *)(a1 + 8);
  xpc_object_t v5 = xpc_null_create();
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_retain(v3);
    xpc_object_t v6 = v3;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
  }
  if (xpc_get_type(v6) != (xpc_type_t)&_xpc_type_array)
  {
    if (v5)
    {
      xpc_retain(v5);
      xpc_object_t v7 = v5;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
    }
    xpc_release(v6);
    xpc_object_t v6 = v7;
  }
  xpc_release(v5);
  xpc_type_t type = xpc_get_type(v6);
  uint64_t v9 = *(NSObject **)(v4 + 144);
  if (type == (xpc_type_t)&_xpc_type_array)
  {
    if (os_log_type_enabled(*(os_log_t *)(v4 + 144), OS_LOG_TYPE_DEFAULT))
    {
      if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array) {
        size_t count = xpc_array_get_count(v6);
      }
      else {
        size_t count = 0;
      }
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = count;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %ld REST connections", (uint8_t *)&buf, 0xCu);
    }
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4((void **)&buf, object, 0);
    xpc_release(object[0]);
    xpc_object_t v24 = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      xpc_object_t v24 = xpc_null_create();
    }
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array) {
      unint64_t v11 = (void *)xpc_array_get_count(v6);
    }
    else {
      unint64_t v11 = 0;
    }
    sub_100048BF4(object, &v24, v11);
    xpc_release(v24);
    for (uint64_t i = (uint64_t *)*((void *)&buf + 1); ; uint64_t i = (uint64_t *)++*((void *)&buf + 1))
    {
      if (i == object[1])
      {
        uint64_t i = (uint64_t *)object[0];
        if ((xpc_object_t)buf == object[0])
        {
          xpc_release((xpc_object_t)buf);
          xpc_release((xpc_object_t)buf);
          goto LABEL_42;
        }
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(i, *(Registry **)(v4 + 104));
      uint64_t v14 = ServiceMap;
      if (v15 < 0)
      {
        unsigned int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v17 = 5381;
        do
        {
          uint64_t v15 = v17;
          unsigned int v18 = *v16++;
          uint64_t v17 = (33 * v17) ^ v18;
        }
        while (v18);
      }
      std::mutex::lock(ServiceMap);
      xpc_object_t v24 = (xpc_object_t)v15;
      unsigned __int8 v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)&v24);
      if (v19)
      {
        uint64_t v21 = (LoggingProfileInterface *)v19[3];
        unint64_t v20 = (std::__shared_weak_count *)v19[4];
        if (v20)
        {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v14);
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v20);
          char v22 = 0;
          goto LABEL_38;
        }
      }
      else
      {
        uint64_t v21 = 0;
      }
      std::mutex::unlock(v14);
      unint64_t v20 = 0;
      char v22 = 1;
LABEL_38:
      LoggingProfileInterface::isLoggingAllowed(v21);
      if ((v22 & 1) == 0) {
        sub_10004D2C8(v20);
      }
    }
  }
  if (os_log_type_enabled(*(os_log_t *)(v4 + 144), OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not get array of REST connections", (uint8_t *)&buf, 2u);
  }
LABEL_42:
  xpc_release(v6);
  xpc_release(v3);
}

void sub_10127B748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13)
{
  xpc_release(v14);
  xpc_release(v13);
  _Unwind_Resume(a1);
}

uint64_t sub_10127B82C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10127B86C()
{
}

void sub_10127B87C()
{
}

void *sub_10127B890(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA52D8;
  result[1] = v3;
  return result;
}

uint64_t sub_10127B8D8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA52D8;
  a2[1] = v2;
  return result;
}

void sub_10127B904(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  *a2 = xpc_null_create();
  uint64_t v4 = *(void *)(a1 + 8);
  xpc_object_t v5 = *(NSObject **)(v4 + 144);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v6) = 134217984;
    *(void *)((char *)&v6 + 4) = xpc_dictionary_get_count(v3);
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %ld REST assertions", (uint8_t *)&v6, 0xCu);
  }
  *(void *)&long long v6 = _NSConcreteStackBlock;
  *((void *)&v6 + 1) = 0x40000000;
  xpc_object_t v7 = sub_10127BA9C;
  char v8 = &unk_101AA5338;
  uint64_t v9 = v4;
  xpc_dictionary_apply(v3, &v6);
  xpc_release(v3);
}

void sub_10127BA20(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10127BA50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10127BA90()
{
}

uint64_t sub_10127BA9C(uint64_t a1, char *a2, xpc_object_t xdict)
{
  xpc_object_t v3 = xdict;
  uint64_t v5 = *(void *)(a1 + 32);
  xpc_object_t value = xpc_dictionary_get_value(xdict, "generation");
  if (value)
  {
    xpc_object_t v7 = value;
    char v8 = *(NSObject **)(v5 + 144);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      xpc_object_t object = v7;
      xpc_retain(v7);
      int v10 = xpc::dyn_cast_or_default((xpc *)&object, 0, v9);
      *(_DWORD *)long long buf = 136315394;
      unsigned __int8 v19 = a2;
      __int16 v20 = 1024;
      int v21 = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s generation %u", buf, 0x12u);
      xpc_release(object);
    }
  }
  if (v3)
  {
    xpc_retain(v3);
    xpc_object_t v11 = v3;
  }
  else
  {
    xpc_object_t v11 = xpc_null_create();
    if (!v11)
    {
      xpc_object_t v12 = xpc_null_create();
      xpc_object_t v11 = 0;
      goto LABEL_11;
    }
  }
  if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v11);
    xpc_object_t v12 = v11;
  }
  else
  {
    xpc_object_t v12 = xpc_null_create();
  }
LABEL_11:
  sub_10127BDDC(v5, v12, a2, "granted");
  xpc_release(v12);
  xpc_release(v11);
  if (v3)
  {
    xpc_retain(v3);
    xpc_object_t v13 = v3;
  }
  else
  {
    xpc_object_t v13 = xpc_null_create();
    if (!v13)
    {
      xpc_object_t v14 = xpc_null_create();
      xpc_object_t v13 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v13);
    xpc_object_t v14 = v13;
  }
  else
  {
    xpc_object_t v14 = xpc_null_create();
  }
LABEL_18:
  sub_10127BDDC(v5, v14, a2, "revoked");
  xpc_release(v14);
  xpc_release(v13);
  if (v3)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    if (!v3)
    {
      xpc_object_t v15 = xpc_null_create();
      xpc_object_t v3 = 0;
      goto LABEL_25;
    }
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    xpc_object_t v15 = v3;
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
  }
LABEL_25:
  sub_10127BDDC(v5, v15, a2, "waiting");
  xpc_release(v15);
  xpc_release(v3);
  return 1;
}

void sub_10127BD1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10127BDDC(uint64_t a1, xpc_object_t xdict, char *a3, char *key)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, key);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)(a1 + 104));
  int v10 = ServiceMap;
  if (!value)
  {
    if (v11 < 0)
    {
      unsigned __int8 v19 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v20 = 5381;
      do
      {
        uint64_t v11 = v20;
        unsigned int v21 = *v19++;
        uint64_t v20 = (33 * v20) ^ v21;
      }
      while (v21);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v11;
    char v22 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
    if (v22)
    {
      unint64_t v23 = (LoggingProfileInterface *)v22[3];
      unsigned int v16 = (std::__shared_weak_count *)v22[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v24 = 0;
LABEL_22:
        if (LoggingProfileInterface::isLoggingAllowed(v23))
        {
          uint64_t v28 = *(NSObject **)(a1 + 144);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = key;
            __int16 v46 = 2082;
            std::string v47 = a3;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#N Did not find key %{public}s for %{public}s", buf, 0x16u);
          }
        }
        if ((v24 & 1) == 0) {
          goto LABEL_64;
        }
        return;
      }
    }
    else
    {
      unint64_t v23 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v24 = 1;
    goto LABEL_22;
  }
  if (v11 < 0)
  {
    xpc_object_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v11;
  xpc_object_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (!v15)
  {
    uint64_t v17 = 0;
    goto LABEL_15;
  }
  uint64_t v17 = (LoggingProfileInterface *)v15[3];
  unsigned int v16 = (std::__shared_weak_count *)v15[4];
  if (!v16)
  {
LABEL_15:
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_16;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
  char v18 = 0;
LABEL_16:
  if (LoggingProfileInterface::isLoggingAllowed(v17))
  {
    uint64_t v25 = *(NSObject **)(a1 + 144);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      xpc_retain(value);
      xpc_object_t v26 = xpc_null_create();
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_array)
      {
        xpc_retain(value);
        xpc_object_t v27 = value;
      }
      else
      {
        xpc_object_t v27 = xpc_null_create();
      }
      if (xpc_get_type(v27) != (xpc_type_t)&_xpc_type_array)
      {
        if (v26)
        {
          xpc_retain(v26);
          xpc_object_t v29 = v26;
        }
        else
        {
          xpc_object_t v29 = xpc_null_create();
        }
        xpc_release(v27);
        xpc_object_t v27 = v29;
      }
      xpc_release(v26);
      object.__r_.__value_.__r.__words[0] = (std::string::size_type)v27;
      if (v27) {
        xpc_retain(v27);
      }
      else {
        object.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
      }
      sub_100048BF4(&v38, (void **)&object.__r_.__value_.__l.__data_, 0);
      xpc_release(object.__r_.__value_.__l.__data_);
      object.__r_.__value_.__r.__words[0] = (std::string::size_type)v27;
      if (v27) {
        xpc_retain(v27);
      }
      else {
        object.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
      }
      if (xpc_get_type(v27) == (xpc_type_t)&_xpc_type_array) {
        size_t count = (void *)xpc_array_get_count(v27);
      }
      else {
        size_t count = 0;
      }
      sub_100048BF4(&v36, (void **)&object.__r_.__value_.__l.__data_, count);
      xpc_release(object.__r_.__value_.__l.__data_);
      memset(&v35, 0, sizeof(v35));
      if (v39 != v37 || (xpc_object_t v31 = v38, v38 != v36))
      {
        uint64_t v41 = &v38;
        uint64_t v42 = v39;
        sub_1000492E0((uint64_t)&v41, &v43);
        sub_10127C448();
        std::string v35 = object;
        *((unsigned char *)&object.__r_.__value_.__s + 23) = 0;
        object.__r_.__value_.__s.__data_[0] = 0;
        xpc_release(v43);
        xpc_object_t v43 = 0;
        while (1)
        {
          if (++v39 == v37)
          {
            xpc_object_t v31 = v38;
            if (v38 == v36) {
              break;
            }
          }
          *((unsigned char *)&object.__r_.__value_.__s + 23) = 1;
          strcpy((char *)&object, ",");
          std::string::append(&v35, (const std::string::value_type *)&object, 1uLL);
          if (SHIBYTE(object.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(object.__r_.__value_.__l.__data_);
          }
          uint64_t v41 = &v38;
          uint64_t v42 = v39;
          sub_1000492E0((uint64_t)&v41, &v40);
          sub_10127C448();
          if ((object.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_std::string object = &object;
          }
          else {
            p_std::string object = (std::string *)object.__r_.__value_.__r.__words[0];
          }
          if ((object.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(object.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type size = object.__r_.__value_.__l.__size_;
          }
          std::string::append(&v35, (const std::string::value_type *)p_object, size);
          if (SHIBYTE(object.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(object.__r_.__value_.__l.__data_);
          }
          xpc_release(v40);
          xpc_object_t v40 = 0;
        }
      }
      xpc_release(v31);
      xpc_object_t v36 = 0;
      xpc_release(v38);
      BOOL v34 = &v35;
      if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        BOOL v34 = (std::string *)v35.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = a3;
      __int16 v46 = 2082;
      std::string v47 = key;
      __int16 v48 = 2082;
      __int16 v49 = v34;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %{public}s %{public}s: %{public}s", buf, 0x20u);
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v35.__r_.__value_.__l.__data_);
      }
      xpc_release(v27);
      xpc_release(value);
    }
  }
  if ((v18 & 1) == 0) {
LABEL_64:
  }
    sub_10004D2C8(v16);
}

void sub_10127C2E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17, uint64_t a18, xpc_object_t a19, uint64_t a20,xpc_object_t a21,uint64_t a22,uint64_t a23,xpc_object_t object,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10127C448()
{
}

void sub_10127C490(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10127C4B0()
{
}

void *sub_10127C4C4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA5378;
  result[1] = v3;
  return result;
}

uint64_t sub_10127C50C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA5378;
  a2[1] = v2;
  return result;
}

void sub_10127C538(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  *a2 = xpc_null_create();
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(NSObject **)(v4 + 144);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v6) = 134217984;
    *(void *)((char *)&v6 + 4) = xpc_dictionary_get_count(v3);
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %ld REST properties", (uint8_t *)&v6, 0xCu);
  }
  *(void *)&long long v6 = _NSConcreteStackBlock;
  *((void *)&v6 + 1) = 0x40000000;
  xpc_object_t v7 = sub_10127C6D0;
  char v8 = &unk_101AA53D8;
  uint64_t v9 = v4;
  xpc_dictionary_apply(v3, &v6);
  xpc_release(v3);
}

void sub_10127C654(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10127C684(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10127C6C4()
{
}

uint64_t sub_10127C6D0(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(v5 + 104));
  xpc_object_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v8;
  xpc_object_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)__p);
  if (!v12)
  {
    unsigned int v14 = 0;
    goto LABEL_8;
  }
  unsigned int v14 = (LoggingProfileInterface *)v12[3];
  uint64_t v13 = (std::__shared_weak_count *)v12[4];
  if (!v13)
  {
LABEL_8:
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
LABEL_9:
  if (LoggingProfileInterface::isLoggingAllowed(v14))
  {
    unsigned int v16 = *(NSObject **)(v5 + 144);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      xpc_object_t object = a3;
      if (a3) {
        xpc_retain(a3);
      }
      else {
        xpc_object_t object = xpc_null_create();
      }
      xpc::object::to_string((uint64_t *)__p, (xpc::object *)&object);
      if (v21 >= 0) {
        uint64_t v17 = __p;
      }
      else {
        uint64_t v17 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136446466;
      uint64_t v23 = a2;
      __int16 v24 = 2082;
      uint64_t v25 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %{public}s: %{public}s", buf, 0x16u);
      if (v21 < 0) {
        operator delete(__p[0]);
      }
      xpc_release(object);
    }
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  return 1;
}

void sub_10127C8A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10127C8EC()
{
}

void *sub_10127C900(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA5418;
  result[1] = v3;
  return result;
}

uint64_t sub_10127C948(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA5418;
  a2[1] = v2;
  return result;
}

void sub_10127C974(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  *a2 = xpc_null_create();
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(NSObject **)(v4 + 144);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v6) = 134217984;
    *(void *)((char *)&v6 + 4) = xpc_dictionary_get_count(v3);
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %ld device info REST properties", (uint8_t *)&v6, 0xCu);
  }
  *(void *)&long long v6 = _NSConcreteStackBlock;
  *((void *)&v6 + 1) = 0x40000000;
  xpc_object_t v7 = sub_10127CB0C;
  uint64_t v8 = &unk_101AA5478;
  uint64_t v9 = v4;
  xpc_dictionary_apply(v3, &v6);
  xpc_release(v3);
}

void sub_10127CA90(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10127CAC0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10127CB00()
{
}

uint64_t sub_10127CB0C(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(v5 + 104));
  xpc_object_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v8;
  xpc_object_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)__p);
  if (!v12)
  {
    unsigned int v14 = 0;
    goto LABEL_8;
  }
  unsigned int v14 = (LoggingProfileInterface *)v12[3];
  uint64_t v13 = (std::__shared_weak_count *)v12[4];
  if (!v13)
  {
LABEL_8:
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
LABEL_9:
  if (LoggingProfileInterface::isLoggingAllowed(v14))
  {
    unsigned int v16 = *(NSObject **)(v5 + 144);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      xpc_object_t object = a3;
      if (a3) {
        xpc_retain(a3);
      }
      else {
        xpc_object_t object = xpc_null_create();
      }
      xpc::object::to_string((uint64_t *)__p, (xpc::object *)&object);
      if (v21 >= 0) {
        uint64_t v17 = __p;
      }
      else {
        uint64_t v17 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136446466;
      uint64_t v23 = a2;
      __int16 v24 = 2082;
      uint64_t v25 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %{public}s: %{public}s", buf, 0x16u);
      if (v21 < 0) {
        operator delete(__p[0]);
      }
      xpc_release(object);
    }
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  return 1;
}

void sub_10127CCDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10127CD28()
{
}

void *sub_10127CD3C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA54B8;
  result[1] = v3;
  return result;
}

uint64_t sub_10127CD84(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA54B8;
  a2[1] = v2;
  return result;
}

void sub_10127CDB0(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  *a2 = xpc_null_create();
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(NSObject **)(v4 + 144);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v6) = 134217984;
    *(void *)((char *)&v6 + 4) = xpc_dictionary_get_count(v3);
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %ld REST persisted properties", (uint8_t *)&v6, 0xCu);
  }
  *(void *)&long long v6 = _NSConcreteStackBlock;
  *((void *)&v6 + 1) = 1174405120;
  xpc_object_t v7 = sub_10127CF84;
  uint64_t v8 = &unk_101AA5518;
  uint64_t v9 = v4;
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  xpc_dictionary_apply(v3, &v6);
  xpc_release(object);
  xpc_release(v3);
}

void sub_10127CEEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object)
{
  xpc_release(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_10127CF38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10127CF78()
{
}

uint64_t sub_10127CF84(uint64_t a1, char *__s1, void *a3)
{
  uint64_t v6 = *(void *)(a1 + 32);
  if (!strcmp(__s1, "PersonalWallet")) {
    return 1;
  }
  if (xpc_get_type(*(xpc_object_t *)(a1 + 40)) == (xpc_type_t)&_xpc_type_BOOL)
  {
    uint64_t v17 = *(NSObject **)(v6 + 144);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)xpc_object_t object = a3;
      if (a3) {
        xpc_retain(a3);
      }
      else {
        *(void *)xpc_object_t object = xpc_null_create();
      }
      int v31 = xpc::dyn_cast_or_default((xpc *)object, 0, v18);
      unint64_t v32 = "false";
      if (v31) {
        unint64_t v32 = "true";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = __s1;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v32;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: %s", buf, 0x16u);
      xpc_release(*(xpc_object_t *)object);
    }
    return 1;
  }
  if (xpc_get_type(*(xpc_object_t *)(a1 + 40)) == (xpc_type_t)&_xpc_type_string)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)&_xpc_type_string, *(Registry **)(v6 + 104));
    uint64_t v20 = ServiceMap;
    if (v21 < 0)
    {
      char v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v23 = 5381;
      do
      {
        uint64_t v21 = v23;
        unsigned int v24 = *v22++;
        uint64_t v23 = (33 * v23) ^ v24;
      }
      while (v24);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v21;
    uint64_t v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)buf);
    if (v25)
    {
      xpc_object_t v26 = (LoggingProfileInterface *)v25[3];
      unsigned int v14 = (std::__shared_weak_count *)v25[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v20);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_31:
        if (LoggingProfileInterface::isLoggingAllowed(v26))
        {
          char v30 = *(NSObject **)(v6 + 144);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            xpc_object_t v37 = a3;
            if (a3) {
              xpc_retain(a3);
            }
            else {
              xpc_object_t v37 = xpc_null_create();
            }
            memset(buf, 0, sizeof(buf));
            xpc::dyn_cast_or_default();
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
            std::string v35 = object;
            if (v41 < 0) {
              std::string v35 = *(unsigned char **)object;
            }
            *(_DWORD *)uint64_t v42 = 136446466;
            *(void *)&v42[4] = __s1;
            __int16 v43 = 2082;
            BOOL v44 = v35;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %{public}s: %{public}s", v42, 0x16u);
            if (v41 < 0) {
              operator delete(*(void **)object);
            }
            xpc_release(v37);
          }
        }
        goto LABEL_56;
      }
    }
    else
    {
      xpc_object_t v26 = 0;
    }
    std::mutex::unlock(v20);
    unsigned int v14 = 0;
    char v16 = 1;
    goto LABEL_31;
  }
  if (xpc_get_type(*(xpc_object_t *)(a1 + 40)) != (xpc_type_t)&_xpc_type_int64)
  {
    xpc_object_t v7 = (std::mutex *)Registry::getServiceMap((uint64_t *)&_xpc_type_int64, *(Registry **)(v6 + 104));
    uint64_t v8 = v7;
    if (v9 < 0)
    {
      uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(v7);
    *(void *)long long buf = v9;
    uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
    if (v13)
    {
      char v15 = (LoggingProfileInterface *)v13[3];
      unsigned int v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_25:
        if (LoggingProfileInterface::isLoggingAllowed(v15))
        {
          xpc_object_t v29 = *(NSObject **)(v6 + 144);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)uint64_t v42 = a3;
            if (a3) {
              xpc_retain(a3);
            }
            else {
              *(void *)uint64_t v42 = xpc_null_create();
            }
            xpc::object::to_string((uint64_t *)buf, (xpc::object *)v42);
            if ((buf[23] & 0x80u) == 0) {
              BOOL v34 = buf;
            }
            else {
              BOOL v34 = *(uint8_t **)buf;
            }
            *(_DWORD *)xpc_object_t object = 136446466;
            *(void *)&object[4] = __s1;
            __int16 v39 = 2082;
            xpc_object_t v40 = v34;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %{public}s: %{public}s", object, 0x16u);
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
            xpc_release(*(xpc_object_t *)v42);
          }
        }
LABEL_56:
        if ((v16 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        return 1;
      }
    }
    else
    {
      char v15 = 0;
    }
    std::mutex::unlock(v8);
    unsigned int v14 = 0;
    char v16 = 1;
    goto LABEL_25;
  }
  xpc_object_t v27 = *(NSObject **)(v6 + 144);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)xpc_object_t object = a3;
    if (a3) {
      xpc_retain(a3);
    }
    else {
      *(void *)xpc_object_t object = xpc_null_create();
    }
    uint64_t v33 = xpc::dyn_cast_or_default((xpc *)object, 0, v28);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = __s1;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = v33;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I %s: %lld", buf, 0x16u);
    xpc_release(*(xpc_object_t *)object);
  }
  return 1;
}

void sub_10127D448(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, xpc_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void *sub_10127D4FC(void *a1)
{
  *a1 = off_101AA5578;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10127D548(void *a1)
{
  *a1 = off_101AA5578;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10127D5B4(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101AA5578;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10127D618(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101AA5578;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10127D658(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10127D668(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10127D6A8(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v5 = (std::__shared_weak_count *)a1[3];
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      xpc_object_t v7 = v6;
      uint64_t v8 = a1[2];
      if (v8) {
        sub_1012798E0(v8, 0);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10127D720(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10127D734(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10127D774()
{
}

void *sub_10127D780(void *a1)
{
  *a1 = off_101AA55F8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10127D7CC(void *a1)
{
  *a1 = off_101AA55F8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10127D838(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101AA55F8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10127D89C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101AA55F8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10127D8DC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10127D8EC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10127D92C(uint64_t *a1, xpc_object_t *a2)
{
  read_rest_value(a1[1], a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = a1[2];
      if (v6) {
        sub_1012798E0(v6, 0);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10127D998(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10127D9AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10127D9EC()
{
}

void sub_10127D9F8(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#N Daemon started. Starting Rest Services", buf, 2u);
  }
  *(_DWORD *)(v1 + 88) = 1;
  uint64_t v3 = v1 + 88;
  uint64_t v4 = *(void *)(v3 - 8);
  if (v4) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48))(v4, v3);
  }
  operator delete();
}

void sub_10127DAC4()
{
}

uint64_t *sub_10127DAF0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Daemon shutting down...", buf, 2u);
  }
  if (notify_is_valid_token(*(_DWORD *)(v2 + 136)))
  {
    notify_cancel(*(_DWORD *)(v2 + 136));
    *(_DWORD *)(v2 + 136) = -1;
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 40));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10127DB90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_10127DBAC()
{
}

void sub_10127DC7C(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10127DCB0(uint64_t a1, void *a2, int a3, NSObject **a4)
{
  uint64_t v8 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v15, kCtLoggingSystemName, "nai");
  void *v8 = 0;
  v8[1] = 0;
  uint64_t v9 = *a4;
  *(void *)(a1 + 24) = *a4;
  if (v9) {
    dispatch_retain(v9);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v13, &v15);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&v13);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v13);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v15);
  v14[0] = off_101999E18;
  v14[1] = sub_10127DFD0;
  void v14[3] = v14;
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v10) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  sub_10008863C(v14);
  *(void *)a1 = off_101AA5678;
  *(void *)(a1 + 56) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 64) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 72) = a3;
  *(_DWORD *)(a1 + 76) = 1;
  *(unsigned char *)(a1 + 80) = 0;
  return a1;
}

void sub_10127DF14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

const char *sub_10127DFD0(int a1)
{
  uint64_t v1 = "nai.?";
  if (a1 == 2) {
    uint64_t v1 = "nai.2";
  }
  if (a1 == 1) {
    return "nai.1";
  }
  else {
    return v1;
  }
}

void sub_10127DFFC(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 72));
  if (*a2)
  {
    uint64_t v5 = (NSObject **)v4;
    if (sub_10127E1D8(a1, (uint64_t *)*a2))
    {
      v11[0] = 0;
      v11[1] = 0;
      uint64_t v12 = 0;
      (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 104))(v11, a1);
      uint64_t v6 = *v5;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = asString();
        uint64_t v8 = v11;
        if (v12 < 0) {
          uint64_t v8 = (void **)v11[0];
        }
        *(_DWORD *)long long buf = 136315394;
        uint64_t v14 = v7;
        __int16 v15 = 2080;
        char v16 = v8;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Bundle changed (%s) setting NAI selection to %s", buf, 0x16u);
      }
      if (SHIBYTE(v12) < 0)
      {
        sub_10004FC84(__p, v11[0], (unint64_t)v11[1]);
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)v11;
        uint64_t v10 = v12;
      }
      sub_10127E380(a1, (uint64_t)__p);
      if (SHIBYTE(v10) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v12) < 0) {
        operator delete(v11[0]);
      }
    }
  }
}

void sub_10127E198(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL *sub_10127E1D8@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 56));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v18);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v11 + 96))(&cf, v11, *(unsigned int *)(a1 + 72), 1, @"AllowNAISelection", kCFBooleanFalse, 0);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  uint64_t v13 = (BOOL *)cf;
  LOBYTE(v18) = 0;
  if (cf)
  {
    CFTypeID v14 = CFGetTypeID(cf);
    if (v14 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v18, v13, v15);
      uint64_t v13 = (BOOL *)((_BYTE)v18 != 0);
    }
    else
    {
      uint64_t v13 = 0;
    }
  }
  sub_1000577C4(&cf);
  return v13;
}

void sub_10127E354(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10127E380(uint64_t a1, uint64_t a2)
{
  int v3 = *(char *)(a2 + 23);
  if (v3 >= 0) {
    uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v4 = *(void *)(a2 + 8);
  }
  unint64_t v5 = "custom";
  if (v4 == 8)
  {
    uint64_t v6 = v3 >= 0 ? (const void *)a2 : *(const void **)a2;
    if (!memcmp(v6, "standard", 8uLL)) {
      unint64_t v5 = "standard";
    }
  }
  uint64_t v7 = (uint64_t **)sub_100365D74();
  sub_100058DB0(&v8, "current_NAI_src");
  sub_100058DB0(&__p, v5);
  sub_10036627C(v7, &v8, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v8.__r_.__value_.__l.__data_);
  }
  *(unsigned char *)(a1 + 80) = 1;
  *(_DWORD *)(a1 + 76) = 1;
}

void sub_10127E458(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_10127E48C(uint64_t a1)
{
  int v2 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 72));
  int v3 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315138;
    uint64_t v9 = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Fetch status: %s", (uint8_t *)&v8, 0xCu);
    int v3 = *v2;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "true";
    if (!*(unsigned char *)(a1 + 80)) {
      uint64_t v4 = "false";
    }
    int v8 = 136315138;
    uint64_t v9 = (uint64_t)v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I NAI changed: %s", (uint8_t *)&v8, 0xCu);
    int v3 = *v2;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v6 = sub_10127E1D8(a1, v5);
    uint64_t v7 = "is not";
    if (v6) {
      uint64_t v7 = "is";
    }
    int v8 = 136315138;
    uint64_t v9 = (uint64_t)v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I NAI selection %s allowed", (uint8_t *)&v8, 0xCu);
  }
}

uint64_t sub_10127E62C(uint64_t a1)
{
  int v2 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 72));
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(a1 + 56));
  unint64_t v5 = ServiceMap;
  unsigned int v6 = "16IPCU_CellProfile";
  if (((unint64_t)"16IPCU_CellProfile" & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)((unint64_t)"16IPCU_CellProfile" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unsigned int v6 = (const char *)v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v18[0] = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)v18);
  if (v10)
  {
    uint64_t v11 = v10[3];
    char v12 = (std::__shared_weak_count *)v10[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v13 = 0;
      if (!v11) {
        goto LABEL_7;
      }
LABEL_12:
      if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 88))(a1))
      {
        (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v11 + 32))(v18, v11);
        if (v18[0]) {
          CFBooleanRef v15 = sub_100080778;
        }
        else {
          CFBooleanRef v15 = 0;
        }
        LOBYTE(v14) = v15 != 0;
        sub_100057D78(v18);
        char v16 = (char)v14;
        if (v13) {
          return v16 & 1;
        }
        goto LABEL_19;
      }
LABEL_18:
      LOBYTE(v14) = 0;
      char v16 = 0;
      if (v13) {
        goto LABEL_20;
      }
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v5);
  char v12 = 0;
  char v13 = 1;
  if (v11) {
    goto LABEL_12;
  }
LABEL_7:
  CFTypeID v14 = *v2;
  if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
    goto LABEL_18;
  }
  LOWORD(v18[0]) = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "isNAISelectionMenu: IPCU_CellProfile IS MISSING", (uint8_t *)v18, 2u);
  if (v13) {
    goto LABEL_21;
  }
LABEL_19:
  sub_10004D2C8(v12);
  char v16 = (char)v14;
LABEL_20:
  if (!v11) {
LABEL_21:
  }
    char v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
  return v16 & 1;
}

void sub_10127E850(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10127E870(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10127FB84;
  v5[3] = &unk_101AA5860;
  void v5[4] = a1 + 8;
  v5[5] = &v4;
  unsigned int v6 = v5;
  uint64_t v2 = a1 + 24;
  char v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    unsigned int v9 = sub_10005B680;
    uint64_t v10 = &unk_101AA58A0;
    uint64_t v11 = &v13;
    char v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    unsigned int v9 = sub_10005A91C;
    uint64_t v10 = &unk_101AA5880;
    uint64_t v11 = &v13;
    char v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

void *sub_10127E9A0@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "standard");
}

void sub_10127E9B0(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10127EA90(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10127FBDC;
  v5[3] = &unk_101AA58C0;
  void v5[4] = a1 + 8;
  v5[5] = &v4;
  unsigned int v6 = v5;
  uint64_t v2 = a1 + 24;
  char v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    unsigned int v13 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    unsigned int v9 = sub_10127FC28;
    uint64_t v10 = &unk_101AA5900;
    uint64_t v11 = &v13;
    char v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    unsigned int v13 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    unsigned int v9 = sub_10127FBEC;
    uint64_t v10 = &unk_101AA58E0;
    uint64_t v11 = &v13;
    char v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13;
}

void sub_10127EBB8(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_10127ED04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v7[0] = a1;
  v7[1] = a2;
  v7[2] = a3;
  v7[3] = a4;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  uint64_t v8[2] = sub_10127FD1C;
  v8[3] = &unk_101AA5920;
  _OWORD v8[4] = a1 + 8;
  void v8[5] = v7;
  unsigned int v9 = v8;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    char v16 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    char v12 = sub_10005B680;
    unsigned int v13 = &unk_101AA58A0;
    CFTypeID v14 = &v16;
    CFBooleanRef v15 = &v9;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    char v16 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    char v12 = sub_10005A91C;
    unsigned int v13 = &unk_101AA5880;
    CFTypeID v14 = &v16;
    CFBooleanRef v15 = &v9;
    dispatch_sync(v4, &block);
  }
  return v16 != 0;
}

void *sub_10127EE3C@<X0>(void *a1@<X8>)
{
  if (sub_10127EE8C()) {
    uint64_t v2 = "custom";
  }
  else {
    uint64_t v2 = "standard";
  }

  return sub_100058DB0(a1, v2);
}

BOOL sub_10127EE8C()
{
  memset(&v8, 0, sizeof(v8));
  uint64_t v0 = sub_100365D74();
  sub_100058DB0(__p, "current_NAI_src");
  sub_100226284(v0, __p, &v8);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  int v1 = SHIBYTE(v8.__r_.__value_.__r.__words[2]);
  if ((v8.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v8.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v8.__r_.__value_.__l.__size_;
  }
  if (size == 6)
  {
    if ((v8.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v3 = &v8;
    }
    else {
      int v3 = (std::string *)v8.__r_.__value_.__r.__words[0];
    }
    BOOL v4 = memcmp(v3, "custom", 6uLL) == 0;
    if (v1 < 0) {
      goto LABEL_13;
    }
  }
  else
  {
    BOOL v4 = 0;
    if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
LABEL_13:
    }
      operator delete(v8.__r_.__value_.__l.__data_);
  }
  return v4;
}

void sub_10127EF4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10127EF80(uint64_t a1, int a2, uint64_t a3, std::string *a4)
{
  std::string v8 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 72));
  std::string __p = 0;
  long long v28 = 0uLL;
  sub_100058DB0(&__p, "");
  if (!a2)
  {
    if (SHIBYTE(v28) < 0)
    {
      *(void *)&long long v28 = 8;
      p_p = (char *)__p;
    }
    else
    {
      HIBYTE(v28) = 8;
      p_p = (char *)&__p;
    }
    strcpy(p_p, "standard");
    sub_10003ED78(a4, "standard");
    goto LABEL_27;
  }
  CFDictionaryRef theDict = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 56));
  uint64_t v11 = ServiceMap;
  char v12 = "16IPCU_CellProfile";
  if (((unint64_t)"16IPCU_CellProfile" & 0x8000000000000000) != 0)
  {
    unsigned int v13 = (unsigned __int8 *)((unint64_t)"16IPCU_CellProfile" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      char v12 = (const char *)v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v12;
  char v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
  if (v16)
  {
    uint64_t v18 = v16[3];
    uint64_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      if (!v18) {
        goto LABEL_8;
      }
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  uint64_t v17 = 0;
  char v19 = 1;
  if (!v18)
  {
LABEL_8:
    uint64_t v20 = *v8;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "getNAIMenuItem: IPCU_CellProfile IS MISSING", buf, 2u);
    }
    goto LABEL_15;
  }
LABEL_14:
  (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v18 + 32))(buf, v18);
  sub_100058140((const void **)&theDict, (const void **)buf);
  sub_100057D78((const void **)buf);
LABEL_15:
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  if (theDict) {
    char v22 = sub_100080778;
  }
  else {
    char v22 = 0;
  }
  if (v22)
  {
    CFDictionaryGetValue(theDict, @"username");
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    uint64_t v23 = *(void **)buf;
    v30[0] = *(void *)&buf[8];
    *(void *)((char *)v30 + 7) = *(void *)&buf[15];
    uint8_t v24 = buf[23];
    if (SHIBYTE(v28) < 0) {
      operator delete(__p);
    }
    std::string __p = v23;
    *(void *)&long long v28 = v30[0];
    *(void *)((char *)&v28 + 7) = *(void *)((char *)v30 + 7);
    HIBYTE(v28) = v24;
  }
  sub_10003ED78(a4, "custom");
  sub_100057D78((const void **)&theDict);
LABEL_27:
  std::operator+<char>();
  if (*(char *)(a3 + 23) < 0) {
    operator delete(*(void **)a3);
  }
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  if (SHIBYTE(v28) < 0) {
    operator delete(__p);
  }
  return 1;
}

void sub_10127F2A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10127F324(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6 = sub_10127EE8C();
  char v7 = *(uint64_t (**)(uint64_t, BOOL, uint64_t, uint64_t))(*(void *)a1 + 32);

  return v7(a1, v6, a2, a3);
}

uint64_t sub_10127F398()
{
  return 2;
}

void sub_10127F3A0(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10127FF6C;
  v5[3] = &unk_101AA5940;
  void v5[4] = a1 + 8;
  v5[5] = &v4;
  BOOL v6 = v5;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    *a2 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    unsigned int v9 = sub_10127FFF4;
    uint64_t v10 = &unk_101AA5980;
    uint64_t v11 = a2;
    char v12 = &v6;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    *a2 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    unsigned int v9 = sub_10127FF7C;
    uint64_t v10 = &unk_101AA5960;
    uint64_t v11 = a2;
    char v12 = &v6;
    dispatch_sync(v2, &block);
  }
}

void sub_10127F4BC(const void **a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), *(unsigned int *)(a2 + 72));
  *a1 = 0;
  if (sub_10127EE8C())
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a2 + 56));
    char v7 = ServiceMap;
    uint64_t v8 = "16IPCU_CellProfile";
    if (((unint64_t)"16IPCU_CellProfile" & 0x8000000000000000) != 0)
    {
      unsigned int v9 = (unsigned __int8 *)((unint64_t)"16IPCU_CellProfile" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        uint64_t v8 = (const char *)v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v8;
    char v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
    if (v12)
    {
      uint64_t v14 = v12[3];
      unsigned int v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
        if (!v14) {
          goto LABEL_8;
        }
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    unsigned int v13 = 0;
    char v15 = 1;
    if (!v14)
    {
LABEL_8:
      char v16 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "getNAI_sync: IPCU_CellProfile IS MISSING", buf, 2u);
      }
      goto LABEL_19;
    }
LABEL_18:
    (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v14 + 32))(buf, v14);
    sub_100058140(a1, (const void **)buf);
    sub_100057D78((const void **)buf);
LABEL_19:
    if ((v15 & 1) == 0) {
      sub_10004D2C8(v13);
    }
    return;
  }
  CFArrayRef theArray = 0;
  uint64_t v17 = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a2 + 56));
  uint64_t v18 = v17;
  if (v19 < 0)
  {
    uint64_t v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      uint64_t v19 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(v17);
  *(void *)long long buf = v19;
  uint64_t v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
  if (!v23)
  {
    uint64_t v25 = 0;
    goto LABEL_22;
  }
  uint64_t v25 = v23[3];
  uint8_t v24 = (std::__shared_weak_count *)v23[4];
  if (!v24)
  {
LABEL_22:
    std::mutex::unlock(v18);
    uint8_t v24 = 0;
    char v26 = 1;
    goto LABEL_23;
  }
  atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v18);
  atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v24);
  char v26 = 0;
LABEL_23:
  (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v25 + 80))(&ValueAtIndex, v25, *(unsigned int *)(a2 + 72), 1, @"nais", 0, 0);
  sub_100044D6C(&theArray, &ValueAtIndex);
  sub_1000577C4(&ValueAtIndex);
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  if (theArray) {
    xpc_object_t v27 = sub_100083F10;
  }
  else {
    xpc_object_t v27 = 0;
  }
  if (v27 && CFArrayGetCount(theArray))
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
    *(void *)long long buf = 0;
    sub_10004EFE4(buf, &ValueAtIndex);
    long long v28 = *a1;
    *a1 = *(const void **)buf;
    *(void *)long long buf = v28;
    sub_100057D78((const void **)buf);
  }
  sub_100044D00((const void **)&theArray);
}

void sub_10127F7CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100044D00((const void **)va);
  sub_100057D78(v2);
  _Unwind_Resume(a1);
}

void sub_10127F83C(void *a1)
{
  *a1 = off_101AA5678;
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[6];
  a1[6] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  NAISelectorInterface::~NAISelectorInterface((NAISelectorInterface *)a1);
}

void sub_10127F8DC(void *a1)
{
  *a1 = off_101AA5678;
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[6];
  a1[6] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  NAISelectorInterface::~NAISelectorInterface((NAISelectorInterface *)a1);

  operator delete();
}

void sub_10127F990(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10127FA5C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10127FB34);
  __cxa_rethrow();
}

void sub_10127FA84(_Unwind_Exception *a1)
{
}

void sub_10127FA9C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10127FAD4(uint64_t a1)
{
}

uint64_t sub_10127FAF0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10127FB34(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10127FB64()
{
}

uint64_t sub_10127FB78(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

BOOL *sub_10127FB84(uint64_t a1)
{
  return sub_10127E1D8(**(void **)(a1 + 40), *(uint64_t **)(a1 + 40));
}

void sub_10127FB90(uint64_t a1)
{
  uint64_t v1 = a1;
  *(_DWORD *)(**(void **)a1 + 76) = 3;
  operator delete();
}

uint64_t sub_10127FBDC(uint64_t a1)
{
  return *(unsigned int *)(**(void **)(a1 + 40) + 76);
}

uint64_t sub_10127FBEC(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10127FC28(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t *sub_10127FC64(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(char *)(v1 + 31) < 0)
  {
    sub_10004FC84(__p, *(void **)(v1 + 8), *(void *)(v1 + 16));
  }
  else
  {
    long long v3 = *(_OWORD *)(v1 + 8);
    uint64_t v8 = *(void *)(v1 + 24);
    *(_OWORD *)std::string __p = v3;
  }
  sub_10127E380(v2, (uint64_t)__p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  sub_1001102C4(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10127FCE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

BOOL sub_10127FD1C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  int v3 = *(unsigned __int8 *)(*(void *)v1 + 80);
  *(unsigned char *)(*(void *)v1 + 80) = 0;
  if (v3)
  {
    CFDictionaryRef theDict = 0;
    sub_10127F4BC((const void **)&theDict, v2);
    if (theDict) {
      uint64_t v4 = sub_100080778;
    }
    else {
      uint64_t v4 = 0;
    }
    if (v4)
    {
      CFDictionaryGetValue(theDict, @"username");
      uint64_t v22 = 0;
      long long v23 = 0uLL;
      ctu::cf::assign();
      uint64_t v5 = v22;
      v24[0] = v23;
      *(void *)((char *)v24 + 7) = *(void *)((char *)&v23 + 7);
      char v6 = HIBYTE(v23);
      uint64_t v7 = *(void *)(v1 + 8);
      if (*(char *)(v7 + 23) < 0) {
        operator delete(*(void **)v7);
      }
      uint64_t v8 = v24[0];
      *(void *)uint64_t v7 = v5;
      *(void *)(v7 + 8) = v8;
      *(void *)(v7 + 15) = *(void *)((char *)v24 + 7);
      *(unsigned char *)(v7 + 23) = v6;
      CFDictionaryGetValue(theDict, @"password");
      uint64_t v22 = 0;
      long long v23 = 0uLL;
      ctu::cf::assign();
      uint64_t v9 = v22;
      v24[0] = v23;
      *(void *)((char *)v24 + 7) = *(void *)((char *)&v23 + 7);
      char v10 = HIBYTE(v23);
      uint64_t v11 = *(void *)(v1 + 16);
      if (*(char *)(v11 + 23) < 0) {
        operator delete(*(void **)v11);
      }
      uint64_t v12 = v24[0];
      *(void *)uint64_t v11 = v9;
      *(void *)(v11 + 8) = v12;
      *(void *)(v11 + 15) = *(void *)((char *)v24 + 7);
      *(unsigned char *)(v11 + 23) = v10;
      CFDictionaryGetValue(theDict, @"auth_type");
      uint64_t v22 = 0;
      long long v23 = 0uLL;
      ctu::cf::assign();
      uint64_t v13 = v22;
      v24[0] = v23;
      *(void *)((char *)v24 + 7) = *(void *)((char *)&v23 + 7);
      char v14 = HIBYTE(v23);
      uint64_t v15 = *(void *)(v1 + 24);
      if (*(char *)(v15 + 23) < 0) {
        operator delete(*(void **)v15);
      }
      uint64_t v16 = v24[0];
      *(void *)uint64_t v15 = v13;
      *(void *)(v15 + 8) = v16;
      *(void *)(v15 + 15) = *(void *)((char *)v24 + 7);
      *(unsigned char *)(v15 + 23) = v14;
    }
    else
    {
      uint64_t v17 = *(void *)(v1 + 24);
      if (*(char *)(v17 + 23) < 0)
      {
        *(void *)(v17 + 8) = 0;
        uint64_t v18 = *(unsigned char **)v17;
      }
      else
      {
        *(unsigned char *)(v17 + 23) = 0;
        uint64_t v18 = (unsigned char *)v17;
      }
      *uint64_t v18 = 0;
      uint64_t v19 = std::string::operator=(*(std::string **)(v1 + 16), (const std::string *)v17);
      std::string::operator=(*(std::string **)(v1 + 8), v19);
    }
    sub_100057D78((const void **)&theDict);
  }
  return v3 != 0;
}

void sub_10127FF24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100057D78(&a10);
  _Unwind_Resume(a1);
}

void sub_10127FF64()
{
}

void sub_10127FF6C(uint64_t a1@<X0>, const void **a2@<X8>)
{
}

const void **sub_10127FF7C(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    int v3 = *v2;
    std::__shared_weak_count *v2 = 0;
    char v6 = v3;
    std::__shared_weak_count *v2 = v5;
    uint64_t v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

const void **sub_10127FFF4(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    int v3 = *v2;
    std::__shared_weak_count *v2 = 0;
    char v6 = v3;
    std::__shared_weak_count *v2 = v5;
    uint64_t v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

void sub_101280374(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101280704(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101280A94(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101280E2C(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1012811C4(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1012816B8(_Unwind_Exception *a1)
{
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v4);
  }
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101281CD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, int a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  sub_1000558F4(&a18);
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if ((v35 & 1) == 0) {
    sub_10004D2C8(v34);
  }
  if ((v36 & 1) == 0) {
    sub_10004D2C8(v33);
  }

  _Unwind_Resume(a1);
}

void sub_1012820EC(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10128247C(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10128280C(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101282BA4(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101282F24(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10128341C(_Unwind_Exception *a1)
{
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v5);
  }

  _Unwind_Resume(a1);
}

void sub_101283830(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101283BC0(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101283F7C(_Unwind_Exception *a1)
{
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v4);
  }

  _Unwind_Resume(a1);
}

void sub_10128431C(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1012847BC(_Unwind_Exception *a1)
{
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v4);
  }

  _Unwind_Resume(a1);
}

void sub_101284CF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, uint64_t *a11, dispatch_object_t object, char a13, uint64_t a14)
{
  sub_1002BB62C((uint64_t **)&a9, 0);
  sub_1002BB62C(&a11, 0);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }

  _Unwind_Resume(a1);
}

void sub_101285100(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1012854D4(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1012858AC(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101285C9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }

  _Unwind_Resume(a1);
}

void sub_10128609C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }

  _Unwind_Resume(a1);
}

void sub_101286468(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1012867F8(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101286B88(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101286E54(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_101287134(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1012873E4(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_101287750(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101287B48(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_101287BE0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_101287F18(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10128834C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v28);
  }

  _Unwind_Resume(a1);
}

void sub_101288780(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101288ADC(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101288E50(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101289248(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1012895E8(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101289970(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_101289D84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }

  _Unwind_Resume(a1);
}

void sub_10128A144(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10128A4C4(_Unwind_Exception *a1)
{
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10128A8B8(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10128AC80(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10128AFF4(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10128B314(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10128B384(uint64_t a1)
{
  return a1;
}

void sub_10128B3B0(uint64_t a1)
{
  operator delete();
}

void *sub_10128B3FC(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA59B0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

void sub_10128B454(id *a1)
{
  operator delete(a1);
}

uint64_t sub_10128B490(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA5A20)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128B4D0()
{
  return &off_101AA5A20;
}

uint64_t sub_10128B4DC(uint64_t a1)
{
  return a1;
}

void sub_10128B508(uint64_t a1)
{
  operator delete();
}

void *sub_10128B554(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA5A40;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128B5AC(uint64_t a1, void *a2)
{
  *a2 = off_101AA5A40;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128B5F4(uint64_t a1)
{
}

void sub_10128B5FC(id *a1)
{
  operator delete(a1);
}

void sub_10128B638(uint64_t a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  char v4 = objc_opt_new();
  if ((v3 - 1) > 5) {
    char v5 = &kCTRegistrationStatusUnknown;
  }
  else {
    char v5 = *(&off_101AA7110 + (int)v3 - 1);
  }
  id v6 = v4;
  [v4 setRegistrationDisplayStatus:*v5];
  [v6 setIsInHomeCountry:HIDWORD(v3) & 1];
  [v6 setChangedDueToSimRemoval:(v3 >> 40) & 1];
  [v6 setIsRegistrationForcedHome:HIWORD(v3) & 1];
  [v6 setIsSatelliteSystem:HIBYTE(v3) & 1];
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_10128B6FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10128B710(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA5AB0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128B750()
{
  return &off_101AA5AB0;
}

uint64_t sub_10128B75C(uint64_t a1)
{
  return a1;
}

void sub_10128B788(uint64_t a1)
{
  operator delete();
}

void *sub_10128B7D4(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA5AD0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128B82C(uint64_t a1, void *a2)
{
  *a2 = off_101AA5AD0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128B874(uint64_t a1)
{
}

void sub_10128B87C(id *a1)
{
  operator delete(a1);
}

void sub_10128B8B8(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *(void *)(a2 + 16);
  *(_OWORD *)std::string __p = *(_OWORD *)a2;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  uint64_t v2 = *(void *)(a1 + 8);
  if (v6 >= 0) {
    unint64_t v3 = __p;
  }
  else {
    unint64_t v3 = (void **)__p[0];
  }
  char v4 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v3, __p[0], __p[1], v6);
  (*(void (**)(uint64_t, void *, void))(v2 + 16))(v2, v4, 0);

  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10128B94C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10128B974(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA5B30)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128B9B4()
{
  return &off_101AA5B30;
}

uint64_t sub_10128B9C0(uint64_t a1)
{
  return a1;
}

void sub_10128B9EC(uint64_t a1)
{
  operator delete();
}

void *sub_10128BA38(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA5B50;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

void sub_10128BA90(id *a1)
{
  operator delete(a1);
}

uint64_t sub_10128BACC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA5BB0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128BB0C()
{
  return &off_101AA5BB0;
}

uint64_t sub_10128BB18(uint64_t a1)
{
  return a1;
}

void sub_10128BB44(uint64_t a1)
{
  operator delete();
}

void *sub_10128BB90(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA5BD0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128BBE8(uint64_t a1, void *a2)
{
  *a2 = off_101AA5BD0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128BC30(uint64_t a1)
{
}

void sub_10128BC38(id *a1)
{
  operator delete(a1);
}

void sub_10128BC74(uint64_t a1, const MCC *a2)
{
  MCC::MCC((MCC *)v5, a2);
  uint64_t v3 = *(void *)(a1 + 8);
  char v4 = +[NSString stringWithFormat:@"%03d", MCC::getIntValue((MCC *)v5)];
  (*(void (**)(uint64_t, void *, void))(v3 + 16))(v3, v4, 0);

  if (v7 < 0) {
    operator delete(__p);
  }
}

void sub_10128BD04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10128BD2C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA5C30)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128BD6C()
{
  return &off_101AA5C30;
}

uint64_t sub_10128BD78(uint64_t a1)
{
  return a1;
}

void sub_10128BDA4(uint64_t a1)
{
  operator delete();
}

void *sub_10128BDF0(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA5C50;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

void sub_10128BE48(id *a1)
{
  operator delete(a1);
}

uint64_t sub_10128BE84(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA5CC0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128BEC4()
{
  return &off_101AA5CC0;
}

uint64_t sub_10128BED0(uint64_t a1)
{
  return a1;
}

void sub_10128BEFC(uint64_t a1)
{
  operator delete();
}

void *sub_10128BF48(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA5CE0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128BFA0(uint64_t a1, void *a2)
{
  *a2 = off_101AA5CE0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128BFE8(uint64_t a1)
{
}

void sub_10128BFF0(id *a1)
{
  operator delete(a1);
}

void sub_10128C02C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (HIDWORD(*a2)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    goto LABEL_8;
  }
  if (v3 == 2)
  {
    id v5 = objc_alloc((Class)NSError);
    uint64_t v6 = &NSMachErrorDomain;
    goto LABEL_10;
  }
  if (v3 != 1)
  {
LABEL_8:
    id v7 = 0;
    goto LABEL_11;
  }
  id v5 = objc_alloc((Class)NSError);
  uint64_t v6 = &NSPOSIXErrorDomain;
LABEL_10:
  id v7 = [v5 initWithDomain:*v6 code:v3 >> 32 userInfo:0];
LABEL_11:
  id v8 = v7;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_10128C108(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10128C11C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA5D50)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128C15C()
{
  return &off_101AA5D50;
}

uint64_t sub_10128C168(uint64_t a1)
{
  return a1;
}

void sub_10128C194(uint64_t a1)
{
  operator delete();
}

void *sub_10128C1E0(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA5D70;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128C238(uint64_t a1, void *a2)
{
  *a2 = off_101AA5D70;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128C280(uint64_t a1)
{
}

void sub_10128C288(id *a1)
{
  operator delete(a1);
}

void sub_10128C2C4(uint64_t a1, uint64_t *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  uint64_t v5 = *a2;
  int v6 = *a3;
  int v7 = *a4;
  if (HIDWORD(*a2)) {
    BOOL v8 = v5 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    goto LABEL_11;
  }
  if (v5 == 2)
  {
    id v9 = objc_alloc((Class)NSError);
    char v10 = &NSMachErrorDomain;
  }
  else
  {
    if (v5 != 1) {
      goto LABEL_11;
    }
    id v9 = objc_alloc((Class)NSError);
    char v10 = &NSPOSIXErrorDomain;
  }
  id v11 = [v9 initWithDomain:*v10 code:v5 >> 32 userInfo:0];
  if (v11)
  {
    id v14 = 0;
    uint64_t v12 = v11;
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v13 = objc_opt_new();
  [v13 setIsVoiceRoaming:v7 != 0];
  uint64_t v12 = 0;
  id v14 = v13;
  [v13 setIsDataRoaming:v6 != 0];
LABEL_12:
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_10128C400(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10128C418(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA5DE0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128C458()
{
  return &off_101AA5DE0;
}

uint64_t sub_10128C464(uint64_t a1)
{
  return a1;
}

void sub_10128C490(uint64_t a1)
{
  operator delete();
}

void *sub_10128C4DC(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA5E00;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128C534(uint64_t a1, void *a2)
{
  *a2 = off_101AA5E00;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128C57C(uint64_t a1)
{
}

void sub_10128C584(id *a1)
{
  operator delete(a1);
}

uint64_t sub_10128C5C0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_10128C5D8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA5E60)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128C618()
{
  return &off_101AA5E60;
}

uint64_t sub_10128C624(uint64_t a1)
{
  return a1;
}

void sub_10128C650(uint64_t a1)
{
  operator delete();
}

void *sub_10128C69C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA5E80;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

void sub_10128C6F4(id *a1)
{
  operator delete(a1);
}

uint64_t sub_10128C730(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA5EE0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128C770()
{
  return &off_101AA5EE0;
}

uint64_t sub_10128C77C(uint64_t a1)
{
  return a1;
}

void sub_10128C7A8(uint64_t a1)
{
  operator delete();
}

void *sub_10128C7F4(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA5F00;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128C84C(uint64_t a1, void *a2)
{
  *a2 = off_101AA5F00;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128C894(uint64_t a1)
{
}

void sub_10128C89C(id *a1)
{
  operator delete(a1);
}

uint64_t sub_10128C8D8(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = sub_10006941C(*a2);
  BOOL v4 = *(uint64_t (**)(uint64_t, uint64_t, void))(v2 + 16);

  return v4(v2, v3, 0);
}

uint64_t sub_10128C928(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA5F70)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128C968()
{
  return &off_101AA5F70;
}

uint64_t sub_10128C974(uint64_t a1)
{
  return a1;
}

void sub_10128C9A0(uint64_t a1)
{
  operator delete();
}

void *sub_10128C9EC(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA5F90;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128CA44(uint64_t a1, void *a2)
{
  *a2 = off_101AA5F90;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128CA8C(uint64_t a1)
{
}

void sub_10128CA94(id *a1)
{
  operator delete(a1);
}

uint64_t sub_10128CAD0(uint64_t a1)
{
  int v2 = asWirelessTechnology();
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = sub_100DC2EF0(v2);
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, void))(v3 + 16);

  return v5(v3, v4, 0);
}

uint64_t sub_10128CB24(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA5FF0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128CB64()
{
  return &off_101AA5FF0;
}

uint64_t sub_10128CB70(uint64_t a1)
{
  return a1;
}

void sub_10128CB9C(uint64_t a1)
{
  operator delete();
}

void *sub_10128CBE8(uint64_t a1)
{
  int v2 = operator new(0x10uLL);
  void *v2 = off_101AA6010;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128CC40(uint64_t a1, void *a2)
{
  *a2 = off_101AA6010;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128CC88(uint64_t a1)
{
}

void sub_10128CC90(id *a1)
{
  operator delete(a1);
}

void sub_10128CCCC(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *(void *)(a2 + 16);
  *(_OWORD *)std::string __p = *(_OWORD *)a2;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  if (v6 >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  uint64_t v4 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v3, __p[0], __p[1], v6);
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();

  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10128CD60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10128CD88(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6070)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128CDC8()
{
  return &off_101AA6070;
}

uint64_t sub_10128CDD4(uint64_t a1)
{
  return a1;
}

void sub_10128CE00(uint64_t a1)
{
  operator delete();
}

void *sub_10128CE4C(uint64_t a1)
{
  int v2 = operator new(0x10uLL);
  void *v2 = off_101AA6090;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128CEA4(uint64_t a1, void *a2)
{
  *a2 = off_101AA6090;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128CEEC(uint64_t a1)
{
}

void sub_10128CEF4(id *a1)
{
  operator delete(a1);
}

uint64_t sub_10128CF30(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  int v4 = *a2;
  int v5 = *a3;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  sub_100DC3114(v4, v5, &v8, &v7);
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_10128CF88(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA60F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128CFC8()
{
  return &off_101AA60F0;
}

uint64_t sub_10128CFD4(uint64_t a1)
{
  return a1;
}

void sub_10128D000(uint64_t a1)
{
  operator delete();
}

void *sub_10128D04C(uint64_t a1)
{
  int v2 = operator new(0x10uLL);
  void *v2 = off_101AA6110;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128D0A4(uint64_t a1, void *a2)
{
  *a2 = off_101AA6110;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128D0EC(uint64_t a1)
{
}

void sub_10128D0F4(id *a1)
{
  operator delete(a1);
}

void sub_10128D130(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v4 = *a2;
  int v5 = *a3;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  sub_100DC3114(v4, v5, &v8, &v7);
  uint64_t v6 = objc_opt_new();
  [v6 setMask:v4];
  [v6 setSelection:v8];
  [v6 setPreferred:v7];
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_10128D1C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10128D1D8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6170)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128D218()
{
  return &off_101AA6170;
}

uint64_t sub_10128D224(uint64_t a1)
{
  return a1;
}

void sub_10128D250(uint64_t a1)
{
  operator delete();
}

void *sub_10128D29C(uint64_t a1)
{
  int v2 = operator new(0x10uLL);
  void *v2 = off_101AA6190;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128D2F4(uint64_t a1, void *a2)
{
  *a2 = off_101AA6190;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128D33C(uint64_t a1)
{
}

void sub_10128D344(id *a1)
{
  operator delete(a1);
}

void sub_10128D380(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (HIDWORD(*a2)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    goto LABEL_8;
  }
  if (v3 == 2)
  {
    id v5 = objc_alloc((Class)NSError);
    uint64_t v6 = &NSMachErrorDomain;
    goto LABEL_10;
  }
  if (v3 != 1)
  {
LABEL_8:
    id v7 = 0;
    goto LABEL_11;
  }
  id v5 = objc_alloc((Class)NSError);
  uint64_t v6 = &NSPOSIXErrorDomain;
LABEL_10:
  id v7 = [v5 initWithDomain:*v6 code:v3 >> 32 userInfo:0];
LABEL_11:
  id v8 = v7;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_10128D448(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10128D45C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA61F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128D49C()
{
  return &off_101AA61F0;
}

uint64_t sub_10128D4A8(uint64_t a1)
{
  return a1;
}

void sub_10128D4D4(uint64_t a1)
{
  operator delete();
}

void *sub_10128D520(uint64_t a1)
{
  int v2 = operator new(0x10uLL);
  void *v2 = off_101AA6210;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128D578(uint64_t a1, void *a2)
{
  *a2 = off_101AA6210;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128D5C0(uint64_t a1)
{
}

void sub_10128D5C8(id *a1)
{
  operator delete(a1);
}

void sub_10128D604(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (HIDWORD(*a2)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    goto LABEL_8;
  }
  if (v3 == 2)
  {
    id v5 = objc_alloc((Class)NSError);
    uint64_t v6 = &NSMachErrorDomain;
    goto LABEL_10;
  }
  if (v3 != 1)
  {
LABEL_8:
    id v7 = 0;
    goto LABEL_11;
  }
  id v5 = objc_alloc((Class)NSError);
  uint64_t v6 = &NSPOSIXErrorDomain;
LABEL_10:
  id v7 = [v5 initWithDomain:*v6 code:v3 >> 32 userInfo:0];
LABEL_11:
  id v8 = v7;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_10128D6CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10128D6E0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6270)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128D720()
{
  return &off_101AA6270;
}

uint64_t sub_10128D72C(uint64_t a1)
{
  return a1;
}

void sub_10128D758(uint64_t a1)
{
  operator delete();
}

void *sub_10128D7A4(uint64_t a1)
{
  int v2 = operator new(0x10uLL);
  void *v2 = off_101AA6290;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128D7FC(uint64_t a1, void *a2)
{
  *a2 = off_101AA6290;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128D844(uint64_t a1)
{
}

void sub_10128D84C(id *a1)
{
  operator delete(a1);
}

const void **sub_10128D888(uint64_t a1, const void **a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  return sub_100057D78(&v3);
}

void sub_10128D8D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10128D8EC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA62F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128D92C()
{
  return &off_101AA62F0;
}

uint64_t sub_10128D938(uint64_t a1)
{
  return a1;
}

void sub_10128D964(uint64_t a1)
{
  operator delete();
}

void *sub_10128D9B0(uint64_t a1)
{
  int v2 = operator new(0x10uLL);
  void *v2 = off_101AA6310;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128DA08(uint64_t a1, void *a2)
{
  *a2 = off_101AA6310;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128DA50(uint64_t a1)
{
}

void sub_10128DA58(id *a1)
{
  operator delete(a1);
}

void sub_10128DA94(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    id v4 = objc_alloc((Class)NSError);
    if (v3 == 2) {
      id v5 = &NSMachErrorDomain;
    }
    else {
      id v5 = &NSPOSIXErrorDomain;
    }
    id v6 = [v4 initWithDomain:*v5 code:v3 >> 32 userInfo:0];
  }
  else
  {
    id v6 = 0;
  }
  id v7 = v6;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_10128DB44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10128DB58(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6370)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128DB98()
{
  return &off_101AA6370;
}

uint64_t sub_10128DBA4(uint64_t a1)
{
  return a1;
}

void sub_10128DBD0(uint64_t a1)
{
  operator delete();
}

void *sub_10128DC1C(uint64_t a1)
{
  int v2 = operator new(0x10uLL);
  void *v2 = off_101AA6390;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128DC74(uint64_t a1, void *a2)
{
  *a2 = off_101AA6390;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128DCBC(uint64_t a1)
{
}

void sub_10128DCC4(id *a1)
{
  operator delete(a1);
}

const void **sub_10128DD00(uint64_t a1, void **a2)
{
  id v8 = *a2;
  *a2 = 0;
  id v3 = objc_alloc((Class)CTBandInfo);
  id v4 = [v8 objectForKey:kCTRegistrationBandSupported];
  id v5 = [v8 objectForKey:kCTRegistrationBandActive];
  id v6 = [v3 initWithSupported:v4 andActiveBands:v5];

  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  return sub_100057D78((const void **)&v8);
}

void sub_10128DDC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10128DDFC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA63F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128DE3C()
{
  return &off_101AA63F0;
}

uint64_t sub_10128DE48(uint64_t a1)
{
  return a1;
}

void sub_10128DE74(uint64_t a1)
{
  operator delete();
}

void *sub_10128DEC0(uint64_t a1)
{
  int v2 = operator new(0x10uLL);
  void *v2 = off_101AA6410;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128DF18(uint64_t a1, void *a2)
{
  *a2 = off_101AA6410;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128DF60(uint64_t a1)
{
}

void sub_10128DF68(id *a1)
{
  operator delete(a1);
}

void sub_10128DFA4(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    id v4 = objc_alloc((Class)NSError);
    if (v3 == 2) {
      id v5 = &NSMachErrorDomain;
    }
    else {
      id v5 = &NSPOSIXErrorDomain;
    }
    id v6 = [v4 initWithDomain:*v5 code:v3 >> 32 userInfo:0];
  }
  else
  {
    id v6 = 0;
  }
  id v7 = v6;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_10128E054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10128E068(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6470)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128E0A8()
{
  return &off_101AA6470;
}

uint64_t sub_10128E0B4(uint64_t a1)
{
  return a1;
}

void sub_10128E0E0(uint64_t a1)
{
  operator delete();
}

void *sub_10128E12C(uint64_t a1)
{
  int v2 = operator new(0x10uLL);
  void *v2 = off_101AA6490;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128E184(uint64_t a1, void *a2)
{
  *a2 = off_101AA6490;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128E1CC(uint64_t a1)
{
}

void sub_10128E1D4(id *a1)
{
  operator delete(a1);
}

void sub_10128E210(uint64_t a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  uint64_t v4 = *((unsigned int *)a2 + 2);
  id v8 = (id)objc_opt_new();
  id v5 = +[NSNumber numberWithUnsignedInteger:v3];
  [v8 setBars:v5];

  id v6 = +[NSNumber numberWithUnsignedInteger:HIDWORD(v3)];
  [v8 setDisplayBars:v6];

  id v7 = +[NSNumber numberWithUnsignedInteger:v4];
  [v8 setMaxDisplayBars:v7];

  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_10128E300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10128E330(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA64F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128E370()
{
  return &off_101AA64F0;
}

uint64_t sub_10128E37C(uint64_t a1)
{
  *(void *)a1 = off_101AA6510;
  int v2 = *(NSObject **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }

  return a1;
}

void sub_10128E3D0(uint64_t a1)
{
  *(void *)a1 = off_101AA6510;
  int v2 = *(NSObject **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }

  operator delete();
}

void *sub_10128E444(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x18uLL);
  void *v2 = off_101AA6510;
  sub_100A65854(v2 + 1, v1);
  return v2;
}

void *sub_10128E498(uint64_t a1, void *a2)
{
  *a2 = off_101AA6510;
  return sub_100A65854(a2 + 1, a1 + 8);
}

void sub_10128E4C4(uint64_t a1)
{
}

void sub_10128E4CC(void *a1)
{
  sub_100A65898((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10128E508(uint64_t a1)
{
}

uint64_t sub_10128E5A0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6570)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128E5E0()
{
  return &off_101AA6570;
}

uint64_t *sub_10128E5EC(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {

    operator delete();
  }
  return result;
}

uint64_t *sub_10128E63C(int *a1)
{
  id v5 = a1;
  int v2 = +[NSNumber numberWithInteger:*a1];
  id v3 = [objc_alloc((Class)CTVoiceLinkQualityMetric) initWithLinkQuality:v2];
  (*(void (**)(void))(*((void *)a1 + 1) + 16))();

  return sub_10128E5EC((uint64_t *)&v5);
}

void sub_10128E6C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_10128E5EC((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10128E6F4(uint64_t a1)
{
  *(void *)a1 = off_101AA6590;
  int v2 = *(NSObject **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }

  return a1;
}

void sub_10128E748(uint64_t a1)
{
  *(void *)a1 = off_101AA6590;
  int v2 = *(NSObject **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }

  operator delete();
}

void *sub_10128E7BC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x18uLL);
  void *v2 = off_101AA6590;
  sub_100A65854(v2 + 1, v1);
  return v2;
}

void *sub_10128E810(uint64_t a1, void *a2)
{
  *a2 = off_101AA6590;
  return sub_100A65854(a2 + 1, a1 + 8);
}

void sub_10128E83C(uint64_t a1)
{
}

void sub_10128E844(void *a1)
{
  sub_100A65898((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10128E880(uint64_t a1, void *a2)
{
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  objc_retainBlock(*(id *)(a1 + 8));
  operator new();
}

uint64_t sub_10128E930(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA65F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128E970()
{
  return &off_101AA65F0;
}

uint64_t *sub_10128E97C(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    int v2 = *(void **)(v1 + 8);
    if (v2)
    {
      *(void *)(v1 + 16) = v2;
      operator delete(v2);
    }

    operator delete();
  }
  return result;
}

uint64_t *sub_10128E9DC(void *a1)
{
  id v5 = a1;
  int v2 = +[NSData dataWithBytes:a1[1] length:a1[2] - a1[1]];
  id v3 = [objc_alloc((Class)CTEnhancedLinkQualityMetric) initWithEnhancedLinkQuality:v2];
  (*(void (**)(void))(*a1 + 16))();

  return sub_10128E97C((uint64_t *)&v5);
}

void sub_10128EA6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_10128E97C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10128EA98(uint64_t a1)
{
  *(void *)a1 = off_101AA6610;
  int v2 = *(NSObject **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }

  return a1;
}

void sub_10128EAEC(uint64_t a1)
{
  *(void *)a1 = off_101AA6610;
  int v2 = *(NSObject **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }

  operator delete();
}

void *sub_10128EB60(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x18uLL);
  void *v2 = off_101AA6610;
  sub_100A65854(v2 + 1, v1);
  return v2;
}

void *sub_10128EBB4(uint64_t a1, void *a2)
{
  *a2 = off_101AA6610;
  return sub_100A65854(a2 + 1, a1 + 8);
}

void sub_10128EBE0(uint64_t a1)
{
}

void sub_10128EBE8(void *a1)
{
  sub_100A65898((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10128EC24(uint64_t a1)
{
}

uint64_t sub_10128ECBC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6670)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128ECFC()
{
  return &off_101AA6670;
}

id **sub_10128ED08(id **result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {

    operator delete();
  }
  return result;
}

id **sub_10128ED58(uint64_t a1)
{
  uint64_t v4 = (id *)a1;
  uint64_t v1 = *(void (***)(id, void *, void))a1;
  int v2 = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 8)];
  v1[2](v1, v2, 0);

  return sub_10128ED08(&v4);
}

void sub_10128EDC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_10128ED08((id **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10128EDE4(uint64_t a1)
{
  return a1;
}

void sub_10128EE18(uint64_t a1)
{
  operator delete();
}

void *sub_10128EE6C(uint64_t a1)
{
  int v2 = operator new(0x18uLL);
  void *v2 = off_101AA6690;
  v2[1] = *(id *)(a1 + 8);
  int v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_10128EED0(uint64_t a1, void *a2)
{
  *a2 = off_101AA6690;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_10128EF28(uint64_t a1)
{
  int v2 = *(void **)(a1 + 8);
}

void sub_10128EF64(id *a1)
{
  operator delete(a1);
}

void sub_10128EFA8(uint64_t a1, unsigned int *a2, unsigned char *a3)
{
  if (*a3)
  {
    unsigned int v4 = *a2;
    id v8 = (id)objc_opt_new();
    [v8 setIsRegisteredForVoice:v4 & 1];
    [v8 setIsRegisteredForSMS:(v4 >> 1) & 1];
    (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  }
  else
  {
    id v5 = *(void **)(a1 + 8);
    if (v5)
    {
      [v5 getLogContext];
      id v6 = v10;
    }
    else
    {
      id v6 = 0;
      *(void *)long long buf = 0;
      char v10 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to query agent status from SystemDeterminationManagerInterface", buf, 2u);
    }
    id v7 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  }
}

void sub_10128F0E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10128F10C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6700)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128F14C()
{
  return &off_101AA6700;
}

void *sub_10128F158(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10128F1DC(uint64_t a1)
{
  return a1;
}

void sub_10128F210(uint64_t a1)
{
  operator delete();
}

void *sub_10128F264(uint64_t a1)
{
  int v2 = operator new(0x18uLL);
  void *v2 = off_101AA6720;
  v2[1] = *(id *)(a1 + 8);
  int v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_10128F2C8(uint64_t a1, void *a2)
{
  *a2 = off_101AA6720;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_10128F320(uint64_t a1)
{
  int v2 = *(void **)(a1 + 8);
}

void sub_10128F35C(id *a1)
{
  operator delete(a1);
}

void sub_10128F3A0(uint64_t a1, unsigned int *a2, unsigned int *a3, unsigned char *a4)
{
  if (*a4)
  {
    uint64_t v5 = *a2;
    uint64_t v6 = *a3;
    id v10 = (id)objc_opt_new();
    [v10 setIsRegistered:1];
    [v10 setContextType:v6];
    [v10 setTransportType:v5];
    (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  }
  else
  {
    id v7 = *(void **)(a1 + 8);
    if (v7)
    {
      [v7 getLogContext];
      id v8 = v12;
    }
    else
    {
      id v8 = 0;
      *(void *)long long buf = 0;
      uint64_t v12 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to query agent status from SystemDeterminationManagerInterface", buf, 2u);
    }
    id v9 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  }
}

void sub_10128F4F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10128F518(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6790)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128F558()
{
  return &off_101AA6790;
}

void *sub_10128F564(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10128F5E8(uint64_t a1)
{
  return a1;
}

void sub_10128F614(uint64_t a1)
{
  operator delete();
}

void *sub_10128F660(uint64_t a1)
{
  int v2 = operator new(0x10uLL);
  void *v2 = off_101AA67B0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128F6B8(uint64_t a1, void *a2)
{
  *a2 = off_101AA67B0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128F700(uint64_t a1)
{
}

void sub_10128F708(id *a1)
{
  operator delete(a1);
}

void sub_10128F744(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  id v3 = sub_1005B0960((int *)&v4);
  (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v3);
}

void sub_10128F79C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10128F7AC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6810)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128F7EC()
{
  return &off_101AA6810;
}

uint64_t sub_10128F7F8(uint64_t a1)
{
  return a1;
}

void sub_10128F824(uint64_t a1)
{
  operator delete();
}

void *sub_10128F870(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA6830;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128F8C8(uint64_t a1, void *a2)
{
  *a2 = off_101AA6830;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128F910(uint64_t a1)
{
}

void sub_10128F918(id *a1)
{
  operator delete(a1);
}

uint64_t sub_10128F954(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = (*a2 - 1);
  if (v3 < 8) {
    uint64_t v4 = v3 + 1;
  }
  else {
    uint64_t v4 = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(v2 + 16))(v2, v4, 0);
}

uint64_t sub_10128F978(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6890)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128F9B8()
{
  return &off_101AA6890;
}

uint64_t sub_10128F9C4(uint64_t a1)
{
  return a1;
}

void sub_10128F9F0(uint64_t a1)
{
  operator delete();
}

void *sub_10128FA3C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA68B0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128FA94(uint64_t a1, void *a2)
{
  *a2 = off_101AA68B0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128FADC(uint64_t a1)
{
}

void sub_10128FAE4(id *a1)
{
  operator delete(a1);
}

void sub_10128FB20(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(_DWORD **)a2;
  uint64_t v4 = *(_DWORD **)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  if (v3 == v4)
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  }
  else
  {
    uint64_t v5 = +[NSMutableArray arrayWithCapacity:v4 - v3];
    uint64_t v6 = v3;
    do
    {
      if ((*v6 - 1) >= 8) {
        uint64_t v7 = 0;
      }
      else {
        uint64_t v7 = *v6;
      }
      id v8 = +[NSNumber numberWithInt:v7];
      [v5 addObject:v8];

      ++v6;
    }
    while (v6 != v4);
    uint64_t v9 = *(void *)(a1 + 8);
    id v10 = [objc_alloc((Class)CTSupportedMaxDataRates) initWithRates:v5];
    (*(void (**)(uint64_t, id, void))(v9 + 16))(v9, v10, 0);
  }
  if (v3)
  {
    operator delete(v3);
  }
}

void sub_10128FC54(_Unwind_Exception *a1)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10128FC8C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6910)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128FCCC()
{
  return &off_101AA6910;
}

uint64_t sub_10128FCD8(uint64_t a1)
{
  return a1;
}

void sub_10128FD04(uint64_t a1)
{
  operator delete();
}

void *sub_10128FD50(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA6930;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128FDA8(uint64_t a1, void *a2)
{
  *a2 = off_101AA6930;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128FDF0(uint64_t a1)
{
}

void sub_10128FDF8(id *a1)
{
  operator delete(a1);
}

uint64_t sub_10128FE34(uint64_t a1, _DWORD *a2)
{
  return (*(uint64_t (**)(void, BOOL, void))(*(void *)(a1 + 8) + 16))(*(void *)(a1 + 8), *a2 == 2, 0);
}

uint64_t sub_10128FE54(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6990)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10128FE94()
{
  return &off_101AA6990;
}

uint64_t sub_10128FEA0(uint64_t a1)
{
  return a1;
}

void sub_10128FECC(uint64_t a1)
{
  operator delete();
}

void *sub_10128FF18(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA69B0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10128FF70(uint64_t a1, void *a2)
{
  *a2 = off_101AA69B0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10128FFB8(uint64_t a1)
{
}

void sub_10128FFC0(id *a1)
{
  operator delete(a1);
}

void sub_10128FFFC(uint64_t a1, int *a2)
{
  if (*a2)
  {
    uint64_t v3 = sub_1005B0960(a2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  id v5 = (id)v3;
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    (*(void (**)(uint64_t, id))(v4 + 16))(v4, v5);
  }
}

void sub_101290074(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101290088(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6A10)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1012900C8()
{
  return &off_101AA6A10;
}

uint64_t sub_1012900D4(uint64_t a1)
{
  return a1;
}

void sub_101290100(uint64_t a1)
{
  operator delete();
}

void *sub_10129014C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA6A30;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1012901A4(uint64_t a1, void *a2)
{
  *a2 = off_101AA6A30;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1012901EC(uint64_t a1)
{
}

void sub_1012901F4(id *a1)
{
  operator delete(a1);
}

void sub_101290230(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (HIDWORD(*a2)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    goto LABEL_8;
  }
  if (v3 == 2)
  {
    id v5 = objc_alloc((Class)NSError);
    uint64_t v6 = &NSMachErrorDomain;
    goto LABEL_10;
  }
  if (v3 != 1)
  {
LABEL_8:
    id v7 = 0;
    goto LABEL_11;
  }
  id v5 = objc_alloc((Class)NSError);
  uint64_t v6 = &NSPOSIXErrorDomain;
LABEL_10:
  id v7 = [v5 initWithDomain:*v6 code:v3 >> 32 userInfo:0];
LABEL_11:
  id v8 = v7;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_1012902F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10129030C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6A90)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10129034C()
{
  return &off_101AA6A90;
}

uint64_t sub_101290358(uint64_t a1)
{
  *(void *)a1 = off_101AA6AB0;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1012903AC(uint64_t a1)
{
  *(void *)a1 = off_101AA6AB0;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_101290420(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_101AA6AB0;
  sub_101290784((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_101290474(uint64_t a1, void *a2)
{
  *a2 = off_101AA6AB0;
  return sub_101290784((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1012904A0(uint64_t a1)
{
}

void sub_1012904A8(void *a1)
{
  sub_1012907D4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1012904E4(uint64_t a1, long long *a2)
{
  long long v12 = *a2;
  uint64_t v13 = *((void *)a2 + 2);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  uint64_t v3 = objc_opt_new();
  BOOL v4 = objc_opt_new();
  [v3 setMoreComing:0];
  for (uint64_t i = (NetworkListOperator *)v12;
        i != *((NetworkListOperator **)&v12 + 1);
        uint64_t i = (NetworkListOperator *)((char *)i + 136))
  {
    uint64_t v6 = objc_opt_new();
    NetworkListOperator::getLocalizedCompositeName();
    if (v15 >= 0) {
      id v7 = __p;
    }
    else {
      id v7 = (void **)__p[0];
    }
    id v8 = +[NSString stringWithUTF8String:v7];
    [v6 setName:v8];

    if (v15 < 0) {
      operator delete(__p[0]);
    }
    NetworkListOperator::getKey((uint64_t *)__p, i);
    if (v15 >= 0) {
      uint64_t v9 = __p;
    }
    else {
      uint64_t v9 = (void **)__p[0];
    }
    id v10 = +[NSString stringWithUTF8String:v9];
    [v6 setPlmn:v10];

    if (v15 < 0) {
      operator delete(__p[0]);
    }
    int RAT = NetworkListOperator::getRAT(i);
    [v6 setRat:sub_10006941C(RAT)];
    [v4 addObject:v6];
  }
  [v3 setNetworks:v4];
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();

  __p[0] = &v12;
  sub_1004C3EF8((void ***)__p);
}

void sub_1012906B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, char *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  std::string __p = &a11;
  sub_1004C3EF8((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_101290738(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6B20)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_101290778()
{
  return &off_101AA6B20;
}

uint64_t sub_101290784(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 24) = objc_retainBlock(*(id *)(a2 + 24));
  return a1;
}

void sub_1012907D4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

uint64_t sub_101290820(uint64_t a1)
{
  return a1;
}

void sub_10129084C(uint64_t a1)
{
  operator delete();
}

void *sub_101290898(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA6B40;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1012908F0(uint64_t a1, void *a2)
{
  *a2 = off_101AA6B40;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_101290938(uint64_t a1)
{
}

void sub_101290940(id *a1)
{
  operator delete(a1);
}

void sub_10129097C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (HIDWORD(*a2)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    goto LABEL_8;
  }
  if (v3 == 2)
  {
    id v5 = objc_alloc((Class)NSError);
    uint64_t v6 = &NSMachErrorDomain;
    goto LABEL_10;
  }
  if (v3 != 1)
  {
LABEL_8:
    id v7 = 0;
    goto LABEL_11;
  }
  id v5 = objc_alloc((Class)NSError);
  uint64_t v6 = &NSPOSIXErrorDomain;
LABEL_10:
  id v7 = [v5 initWithDomain:*v6 code:v3 >> 32 userInfo:0];
LABEL_11:
  id v8 = v7;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_101290A44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101290A58(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6BA0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_101290A98()
{
  return &off_101AA6BA0;
}

uint64_t sub_101290AA4(uint64_t a1)
{
  return a1;
}

void sub_101290AD0(uint64_t a1)
{
  operator delete();
}

void *sub_101290B1C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA6BC0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_101290B74(uint64_t a1, void *a2)
{
  *a2 = off_101AA6BC0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_101290BBC(uint64_t a1)
{
}

void sub_101290BC4(id *a1)
{
  operator delete(a1);
}

void sub_101290C00(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (HIDWORD(*a2)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    goto LABEL_8;
  }
  if (v3 == 2)
  {
    id v5 = objc_alloc((Class)NSError);
    uint64_t v6 = &NSMachErrorDomain;
    goto LABEL_10;
  }
  if (v3 != 1)
  {
LABEL_8:
    id v7 = 0;
    goto LABEL_11;
  }
  id v5 = objc_alloc((Class)NSError);
  uint64_t v6 = &NSPOSIXErrorDomain;
LABEL_10:
  id v7 = [v5 initWithDomain:*v6 code:v3 >> 32 userInfo:0];
LABEL_11:
  id v8 = v7;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_101290CC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101290CDC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6C20)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_101290D1C()
{
  return &off_101AA6C20;
}

uint64_t sub_101290D28(uint64_t a1)
{
  *(void *)a1 = off_101AA6C40;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_101290D7C(uint64_t a1)
{
  *(void *)a1 = off_101AA6C40;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_101290DF0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_101AA6C40;
  sub_101290784((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_101290E44(uint64_t a1, void *a2)
{
  *a2 = off_101AA6C40;
  return sub_101290784((uint64_t)(a2 + 1), a1 + 8);
}

void sub_101290E70(uint64_t a1)
{
}

void sub_101290E78(void *a1)
{
  sub_1012907D4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_101290EB4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)id v10 = *(_OWORD *)a2;
  uint64_t v11 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  LODWORD(v12) = *(_DWORD *)(a2 + 24);
  MCC::MCC((MCC *)&v13, (const MCC *)(a2 + 32));
  MCC::MCC((MCC *)&v16, (const MCC *)(a2 + 64));
  *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 96);
  uint64_t v20 = *(void *)(a2 + 112);
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 96) = 0;
  long long v21 = *(_OWORD *)(a2 + 120);
  BOOL v4 = objc_opt_new();
  NetworkListOperator::getLocalizedCompositeName();
  if (v23 >= 0) {
    id v5 = v22;
  }
  else {
    id v5 = (void **)v22[0];
  }
  uint64_t v6 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v5, v10[0], v10[1], v11, v12);
  [v4 setName:v6];

  if (v23 < 0) {
    operator delete(v22[0]);
  }
  NetworkListOperator::getKey((uint64_t *)v22, (NetworkListOperator *)v10);
  if (v23 >= 0) {
    id v7 = v22;
  }
  else {
    id v7 = (void **)v22[0];
  }
  id v8 = +[NSString stringWithUTF8String:v7];
  [v4 setPlmn:v8];

  if (v23 < 0) {
    operator delete(v22[0]);
  }
  int RAT = NetworkListOperator::getRAT((NetworkListOperator *)v10);
  [v4 setRat:sub_10006941C(RAT)];
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();

  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  if (v18 < 0) {
    operator delete(v17);
  }
  if (v15 < 0) {
    operator delete(v14);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete(v10[0]);
  }
}

void sub_101291084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (*(char *)(v37 - 49) < 0) {
    operator delete(*(void **)(v37 - 72));
  }

  if (a35 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_101291120(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6CB0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_101291160()
{
  return &off_101AA6CB0;
}

uint64_t sub_10129116C(uint64_t a1)
{
  return a1;
}

void sub_101291198(uint64_t a1)
{
  operator delete();
}

void *sub_1012911E4(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA6CD0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10129123C(uint64_t a1, void *a2)
{
  *a2 = off_101AA6CD0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_101291284(uint64_t a1)
{
}

void sub_10129128C(id *a1)
{
  operator delete(a1);
}

uint64_t sub_1012912C8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_10129130C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6D40)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10129134C()
{
  return &off_101AA6D40;
}

uint64_t sub_101291358(uint64_t a1)
{
  *(void *)a1 = off_101AA6D60;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1012913AC(uint64_t a1)
{
  *(void *)a1 = off_101AA6D60;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_101291420(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_101AA6D60;
  sub_101290784((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_101291474(uint64_t a1, void *a2)
{
  *a2 = off_101AA6D60;
  return sub_101290784((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1012914A0(uint64_t a1)
{
}

void sub_1012914A8(void *a1)
{
  sub_1012907D4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1012914E4(uint64_t a1, int *a2, int *a3, uint64_t a4)
{
  int v6 = *a2;
  int v7 = *a3;
  *(_OWORD *)uint64_t v19 = *(_OWORD *)a4;
  uint64_t v20 = *(void *)(a4 + 16);
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)a4 = 0;
  LODWORD(v21) = *(_DWORD *)(a4 + 24);
  MCC::MCC((MCC *)&v22, (const MCC *)(a4 + 32));
  MCC::MCC((MCC *)&v25, (const MCC *)(a4 + 64));
  *(_OWORD *)std::string __p = *(_OWORD *)(a4 + 96);
  uint64_t v29 = *(void *)(a4 + 112);
  *(void *)(a4 + 104) = 0;
  *(void *)(a4 + 112) = 0;
  *(void *)(a4 + 96) = 0;
  long long v30 = *(_OWORD *)(a4 + 120);
  id v8 = objc_opt_new();
  uint64_t v9 = v8;
  if (v7) {
    uint64_t v10 = 2 * (v7 == 1);
  }
  else {
    uint64_t v10 = 1;
  }
  objc_msgSend(v8, "setSelectionMode:", v10, v19[0], v19[1], v20, v21);
  uint64_t v11 = (v6 - 1);
  if (v11 < 6) {
    uint64_t v12 = v11 + 1;
  }
  else {
    uint64_t v12 = 0;
  }
  [v9 setSelectionState:v12];
  if (v7 == 1)
  {
    uint64_t v13 = objc_opt_new();
    NetworkListOperator::getLocalizedCompositeName();
    if (v32 >= 0) {
      id v14 = v31;
    }
    else {
      id v14 = (void **)v31[0];
    }
    char v15 = +[NSString stringWithUTF8String:v14];
    [v13 setName:v15];

    if (v32 < 0) {
      operator delete(v31[0]);
    }
    NetworkListOperator::getKey((uint64_t *)v31, (NetworkListOperator *)v19);
    if (v32 >= 0) {
      uint64_t v16 = v31;
    }
    else {
      uint64_t v16 = (void **)v31[0];
    }
    char v17 = +[NSString stringWithUTF8String:v16];
    [v13 setPlmn:v17];

    if (v32 < 0) {
      operator delete(v31[0]);
    }
    int RAT = NetworkListOperator::getRAT((NetworkListOperator *)v19);
    [v13 setRat:sub_10006941C(RAT)];
    [v9 setSelection:v13];
  }
  else
  {
    [v9 setSelection:0];
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();

  if (SHIBYTE(v29) < 0) {
    operator delete(__p[0]);
  }
  if (v27 < 0) {
    operator delete(v26);
  }
  if (v24 < 0) {
    operator delete(v23);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v19[0]);
  }
}

void sub_101291720(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (*(char *)(v38 - 49) < 0) {
    operator delete(*(void **)(v38 - 72));
  }

  if (a35 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1012917CC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6DD0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10129180C()
{
  return &off_101AA6DD0;
}

uint64_t sub_101291818(uint64_t a1)
{
  return a1;
}

void sub_101291844(uint64_t a1)
{
  operator delete();
}

void *sub_101291890(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA6DF0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1012918E8(uint64_t a1, void *a2)
{
  *a2 = off_101AA6DF0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_101291930(uint64_t a1)
{
}

void sub_101291938(id *a1)
{
  operator delete(a1);
}

uint64_t sub_101291974(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_10129198C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6E50)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1012919CC()
{
  return &off_101AA6E50;
}

uint64_t sub_1012919D8(uint64_t a1)
{
  return a1;
}

void sub_101291A04(uint64_t a1)
{
  operator delete();
}

void *sub_101291A50(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA6E70;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_101291AA8(uint64_t a1, void *a2)
{
  *a2 = off_101AA6E70;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_101291AF0(uint64_t a1)
{
}

void sub_101291AF8(id *a1)
{
  operator delete(a1);
}

void sub_101291B34(uint64_t a1, _DWORD *a2, int *a3)
{
  if (*a3)
  {
    BOOL v4 = 0;
    uint64_t v5 = sub_1005B0960(a3);
  }
  else
  {
    BOOL v4 = sub_10132AE88(a2);
    uint64_t v5 = 0;
  }
  id v6 = (id)v5;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_101291BCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101291BE4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101AA6EE0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_101291C24()
{
  return &off_101AA6EE0;
}

uint64_t sub_101291C30(uint64_t a1)
{
  return a1;
}

void sub_101291C5C(uint64_t a1)
{
  operator delete();
}

void *sub_101291CA8(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101AA6F00;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_101291D00(uint64_t a1, void *a2)
{
  *a2 = off_101AA6F00;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_101291D48(uint64_t a1)
{
}

void sub_101291D50(id *a1)
{
  operator delete(a1);
}

void sub_101291D8C(uint64_t a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  uint64_t v4 = *((unsigned int *)a2 + 2);
  id v8 = (id)objc_opt_new();
  uint64_t v5 = +[NSNumber numberWithUnsignedInteger:v3];
  [v8 setBars:v5];

  id v6 = +[NSNumber numberWithUnsignedInteger:HIDWORD(v3)];
  [v8 setDisplayBars:v6];

  int v7 = +[NSNumber numberWithUnsignedInteger:v4];
  [v8 setMaxDisplayBars:v7];

  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}